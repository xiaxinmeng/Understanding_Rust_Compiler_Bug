{"sha": "bef93d3b1464b6d467482d47a53c62aadaa9f41c", "node_id": "C_kwDOAAsO6NoAKGJlZjkzZDNiMTQ2NGI2ZDQ2NzQ4MmQ0N2E1M2M2MmFhZGFhOWY0MWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-02T19:46:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-02T19:46:46Z"}, "message": "Auto merge of #7962 - Jarcho:fix_match_type_on_diagnostic_items, r=llogiq\n\nFix and improve `match_type_on_diagnostic_item`\n\nThis extracts the fix for the lint out of #7647. There's still a couple of other functions to check, but at least this will get lint working again.\n\nThe two added util functions (`is_diagnostic_item` and `is_lang_item`) are needed to handle `DefId` for unit and tuple struct/variant constructors. The `rustc_diagnostic_item` and `lang` attributes are attached to the struct/variant `DefId`, but most of the time they are used through their constructors which have a different `DefId`. The two utility functions will check if the `DefId` is for a constructor and switch to the associated struct/variant `DefId`.\n\nThere does seem to be a bug on rustc's side where constructor `DefId`s from external crates seem to be returning `DefKind::Variant` instead of `DefKind::Ctor()`. There's a workaround put in right.\n\nchangelog: None", "tree": {"sha": "48689a77210ac027077feff51677ea3ec859b6aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48689a77210ac027077feff51677ea3ec859b6aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bef93d3b1464b6d467482d47a53c62aadaa9f41c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bef93d3b1464b6d467482d47a53c62aadaa9f41c", "html_url": "https://github.com/rust-lang/rust/commit/bef93d3b1464b6d467482d47a53c62aadaa9f41c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bef93d3b1464b6d467482d47a53c62aadaa9f41c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0341198ba1980468ae190208a546a40a0634f06c", "url": "https://api.github.com/repos/rust-lang/rust/commits/0341198ba1980468ae190208a546a40a0634f06c", "html_url": "https://github.com/rust-lang/rust/commit/0341198ba1980468ae190208a546a40a0634f06c"}, {"sha": "162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "url": "https://api.github.com/repos/rust-lang/rust/commits/162aa19793f21c99cf7ec2a8c080ee2f8843f7db", "html_url": "https://github.com/rust-lang/rust/commit/162aa19793f21c99cf7ec2a8c080ee2f8843f7db"}], "stats": {"total": 1109, "additions": 735, "deletions": 374}, "files": [{"sha": "24a3588ecf16f735215a4045cd8ca26d30c57dc1", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -6,7 +6,7 @@ use rustc_hir::{def::Res, AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::GeneratorInteriorTypeCause;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n use crate::utils::conf::DisallowedType;\n \n@@ -276,9 +276,9 @@ fn emit_invalid_type(cx: &LateContext<'_>, span: Span, disallowed: &DisallowedTy\n }\n \n fn is_mutex_guard(cx: &LateContext<'_>, def_id: DefId) -> bool {\n-    match_def_path(cx, def_id, &paths::MUTEX_GUARD)\n-        || match_def_path(cx, def_id, &paths::RWLOCK_READ_GUARD)\n-        || match_def_path(cx, def_id, &paths::RWLOCK_WRITE_GUARD)\n+    cx.tcx.is_diagnostic_item(sym::MutexGuard, def_id)\n+        || cx.tcx.is_diagnostic_item(sym::RwLockReadGuard, def_id)\n+        || cx.tcx.is_diagnostic_item(sym::RwLockWriteGuard, def_id)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_MUTEX_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_READ_GUARD)\n         || match_def_path(cx, def_id, &paths::PARKING_LOT_RWLOCK_WRITE_GUARD)"}, {"sha": "0d6718c168a5c9da12865ee7633dc5078ad7e33a", "filename": "clippy_lints/src/if_then_some_else_none.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_then_some_else_none.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::eager_or_lazy::switch_to_eager_eval;\n use clippy_utils::source::snippet_with_macro_callsite;\n-use clippy_utils::{contains_return, higher, is_else_clause, is_lang_ctor, meets_msrv, msrvs, peel_blocks};\n+use clippy_utils::{\n+    contains_return, higher, is_else_clause, is_res_lang_ctor, meets_msrv, msrvs, path_res, peel_blocks,\n+};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n use rustc_hir::{Expr, ExprKind, Stmt, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -76,10 +78,8 @@ impl<'tcx> LateLintPass<'tcx> for IfThenSomeElseNone {\n             && let ExprKind::Block(then_block, _) = then.kind\n             && let Some(then_expr) = then_block.expr\n             && let ExprKind::Call(then_call, [then_arg]) = then_expr.kind\n-            && let ExprKind::Path(ref then_call_qpath) = then_call.kind\n-            && is_lang_ctor(cx, then_call_qpath, OptionSome)\n-            && let ExprKind::Path(ref qpath) = peel_blocks(els).kind\n-            && is_lang_ctor(cx, qpath, OptionNone)\n+            && is_res_lang_ctor(cx, path_res(cx, then_call), OptionSome)\n+            && is_res_lang_ctor(cx, path_res(cx, peel_blocks(els)), OptionNone)\n             && !stmts_contains_early_return(then_block.stmts)\n         {\n             let cond_snip = snippet_with_macro_callsite(cx, cond.span, \"[condition]\");"}, {"sha": "d1d2db27c6fc0acd6efa477769d5840722056f1b", "filename": "clippy_lints/src/infinite_iter.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Finfinite_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Finfinite_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finfinite_iter.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n+use clippy_utils::higher;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{higher, match_def_path, path_def_id, paths};\n use rustc_hir::{BorrowKind, Closure, Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -168,9 +168,16 @@ fn is_infinite(cx: &LateContext<'_>, expr: &Expr<'_>) -> Finiteness {\n         },\n         ExprKind::Block(block, _) => block.expr.as_ref().map_or(Finite, |e| is_infinite(cx, e)),\n         ExprKind::Box(e) | ExprKind::AddrOf(BorrowKind::Ref, _, e) => is_infinite(cx, e),\n-        ExprKind::Call(path, _) => path_def_id(cx, path)\n-            .map_or(false, |id| match_def_path(cx, id, &paths::ITER_REPEAT))\n-            .into(),\n+        ExprKind::Call(path, _) => {\n+            if let ExprKind::Path(ref qpath) = path.kind {\n+                cx.qpath_res(qpath, path.hir_id)\n+                    .opt_def_id()\n+                    .map_or(false, |id| cx.tcx.is_diagnostic_item(sym::iter_repeat, id))\n+                    .into()\n+            } else {\n+                Finite\n+            }\n+        },\n         ExprKind::Struct(..) => higher::Range::hir(expr).map_or(false, |r| r.end.is_none()).into(),\n         _ => Finite,\n     }"}, {"sha": "676136df572bd0dd7cff51bc4cc1d74945a3dd2c", "filename": "clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finherent_to_string.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n use clippy_utils::ty::{implements_trait, is_type_diagnostic_item};\n-use clippy_utils::{get_trait_def_id, paths, return_ty, trait_ref_of_method};\n+use clippy_utils::{return_ty, trait_ref_of_method};\n use if_chain::if_chain;\n use rustc_hir::{GenericParamKind, ImplItem, ImplItemKind};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -118,7 +118,10 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n }\n \n fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n-    let display_trait_id = get_trait_def_id(cx, &paths::DISPLAY_TRAIT).expect(\"Failed to get trait ID of `Display`!\");\n+    let display_trait_id = cx\n+        .tcx\n+        .get_diagnostic_item(sym::Display)\n+        .expect(\"Failed to get trait ID of `Display`!\");\n \n     // Get the real type of 'self'\n     let self_type = cx.tcx.fn_sig(item.def_id).input(0);"}, {"sha": "71dfdab369b97e93228a82f1de68ea331b89639d", "filename": "clippy_lints/src/lib.register_internal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Flib.register_internal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Flib.register_internal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_internal.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -13,10 +13,10 @@ store.register_group(true, \"clippy::internal\", Some(\"clippy_internal\"), vec![\n     LintId::of(utils::internal_lints::INVALID_CLIPPY_VERSION_ATTRIBUTE),\n     LintId::of(utils::internal_lints::INVALID_PATHS),\n     LintId::of(utils::internal_lints::LINT_WITHOUT_LINT_PASS),\n-    LintId::of(utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM),\n     LintId::of(utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE),\n     LintId::of(utils::internal_lints::MISSING_MSRV_ATTR_IMPL),\n     LintId::of(utils::internal_lints::OUTER_EXPN_EXPN_DATA),\n     LintId::of(utils::internal_lints::PRODUCE_ICE),\n+    LintId::of(utils::internal_lints::UNNECESSARY_DEF_PATH),\n     LintId::of(utils::internal_lints::UNNECESSARY_SYMBOL_STR),\n ])"}, {"sha": "307ec40f40b3b155ca7e5b17d9108a440e99d065", "filename": "clippy_lints/src/lib.register_lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Flib.register_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Flib.register_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_lints.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -24,8 +24,6 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::LINT_WITHOUT_LINT_PASS,\n     #[cfg(feature = \"internal\")]\n-    utils::internal_lints::MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n-    #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_CLIPPY_VERSION_ATTRIBUTE,\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::MISSING_MSRV_ATTR_IMPL,\n@@ -34,6 +32,8 @@ store.register_lints(&[\n     #[cfg(feature = \"internal\")]\n     utils::internal_lints::PRODUCE_ICE,\n     #[cfg(feature = \"internal\")]\n+    utils::internal_lints::UNNECESSARY_DEF_PATH,\n+    #[cfg(feature = \"internal\")]\n     utils::internal_lints::UNNECESSARY_SYMBOL_STR,\n     almost_complete_letter_range::ALMOST_COMPLETE_LETTER_RANGE,\n     approx_const::APPROX_CONSTANT,"}, {"sha": "3b78e492baa480fd12f0bb6b15575f8d5962f842", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -535,7 +535,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         store.register_late_pass(|_| Box::new(utils::internal_lints::InvalidPaths));\n         store.register_late_pass(|_| Box::<utils::internal_lints::InterningDefinedSymbol>::default());\n         store.register_late_pass(|_| Box::<utils::internal_lints::LintWithoutLintPass>::default());\n-        store.register_late_pass(|_| Box::new(utils::internal_lints::MatchTypeOnDiagItem));\n+        store.register_late_pass(|_| Box::new(utils::internal_lints::UnnecessaryDefPath));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::OuterExpnDataPass));\n         store.register_late_pass(|_| Box::new(utils::internal_lints::MsrvAttrImpl));\n     }"}, {"sha": "4bb9936e9cde7a235f674ba7483f531b8f3dc1de", "filename": "clippy_lints/src/loops/manual_find.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_find.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,7 +1,7 @@\n use super::utils::make_iterator_snippet;\n use super::MANUAL_FIND;\n use clippy_utils::{\n-    diagnostics::span_lint_and_then, higher, is_lang_ctor, path_res, peel_blocks_with_stmt,\n+    diagnostics::span_lint_and_then, higher, is_res_lang_ctor, path_res, peel_blocks_with_stmt,\n     source::snippet_with_applicability, ty::implements_trait,\n };\n use if_chain::if_chain;\n@@ -30,8 +30,8 @@ pub(super) fn check<'tcx>(\n         if let [stmt] = block.stmts;\n         if let StmtKind::Semi(semi) = stmt.kind;\n         if let ExprKind::Ret(Some(ret_value)) = semi.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ctor), .. }, [inner_ret]) = ret_value.kind;\n-        if is_lang_ctor(cx, ctor, LangItem::OptionSome);\n+        if let ExprKind::Call(ctor, [inner_ret]) = ret_value.kind;\n+        if is_res_lang_ctor(cx, path_res(cx, ctor), LangItem::OptionSome);\n         if path_res(cx, inner_ret) == Res::Local(binding_id);\n         if let Some((last_stmt, last_ret)) = last_stmt_and_ret(cx, expr);\n         then {\n@@ -143,8 +143,7 @@ fn last_stmt_and_ret<'tcx>(\n         if let Some((_, Node::Block(block))) = parent_iter.next();\n         if let Some((last_stmt, last_ret)) = extract(block);\n         if last_stmt.hir_id == node_hir;\n-        if let ExprKind::Path(path) = &last_ret.kind;\n-        if is_lang_ctor(cx, path, LangItem::OptionNone);\n+        if is_res_lang_ctor(cx, path_res(cx, last_ret), LangItem::OptionNone);\n         if let Some((_, Node::Expr(_block))) = parent_iter.next();\n         // This includes the function header\n         if let Some((_, func)) = parent_iter.next();"}, {"sha": "8c27c09404b1b28e77fb13a62b97bea0a5a6fd7b", "filename": "clippy_lints/src/loops/manual_flatten.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmanual_flatten.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -3,13 +3,13 @@ use super::MANUAL_FLATTEN;\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, path_to_local_id, peel_blocks_with_stmt};\n+use clippy_utils::{path_to_local_id, peel_blocks_with_stmt};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionSome, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{Expr, Pat, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, DefIdTree};\n use rustc_span::source_map::Span;\n \n /// Check for unnecessary `if let` usage in a for loop where only the `Some` or `Ok` variant of the\n@@ -30,8 +30,10 @@ pub(super) fn check<'tcx>(\n         if path_to_local_id(let_expr, pat_hir_id);\n         // Ensure the `if let` statement is for the `Some` variant of `Option` or the `Ok` variant of `Result`\n         if let PatKind::TupleStruct(ref qpath, _, _) = let_pat.kind;\n-        let some_ctor = is_lang_ctor(cx, qpath, OptionSome);\n-        let ok_ctor = is_lang_ctor(cx, qpath, ResultOk);\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(qpath, let_pat.hir_id);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        let some_ctor = cx.tcx.lang_items().option_some_variant() == Some(variant_id);\n+        let ok_ctor = cx.tcx.lang_items().result_ok_variant() == Some(variant_id);\n         if some_ctor || ok_ctor;\n         // Ensure expr in `if let` is not used afterwards\n         if !is_local_used(cx, if_then, pat_hir_id);"}, {"sha": "153f97e4e66c88ffe334d220c0d8425cf6589796", "filename": "clippy_lints/src/loops/while_let_on_iterator.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_let_on_iterator.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -3,13 +3,12 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::{\n-    get_enclosing_loop_or_multi_call_closure, is_refutable, is_trait_method, match_def_path, paths,\n-    visitors::is_res_used,\n+    get_enclosing_loop_or_multi_call_closure, is_refutable, is_res_lang_ctor, is_trait_method, visitors::is_res_used,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n-use rustc_hir::{def::Res, Closure, Expr, ExprKind, HirId, Local, Mutability, PatKind, QPath, UnOp};\n+use rustc_hir::{def::Res, Closure, Expr, ExprKind, HirId, LangItem, Local, Mutability, PatKind, UnOp};\n use rustc_lint::LateContext;\n use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_middle::ty::adjustment::Adjust;\n@@ -19,9 +18,8 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n     let (scrutinee_expr, iter_expr_struct, iter_expr, some_pat, loop_expr) = if_chain! {\n         if let Some(higher::WhileLet { if_then, let_pat, let_expr }) = higher::WhileLet::hir(expr);\n         // check for `Some(..)` pattern\n-        if let PatKind::TupleStruct(QPath::Resolved(None, pat_path), some_pat, _) = let_pat.kind;\n-        if let Res::Def(_, pat_did) = pat_path.res;\n-        if match_def_path(cx, pat_did, &paths::OPTION_SOME);\n+        if let PatKind::TupleStruct(ref pat_path, some_pat, _) = let_pat.kind;\n+        if is_res_lang_ctor(cx, cx.qpath_res(pat_path, let_pat.hir_id), LangItem::OptionSome);\n         // check for call to `Iterator::next`\n         if let ExprKind::MethodCall(method_name, iter_expr, [], _) = let_expr.kind;\n         if method_name.ident.name == sym::next;"}, {"sha": "3181bc86d179362e0ed6d075837ef569c7094478", "filename": "clippy_lints/src/manual_retain.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmanual_retain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmanual_retain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_retain.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -92,7 +92,7 @@ fn check_into_iter(\n         && match_def_path(cx, filter_def_id, &paths::CORE_ITER_FILTER)\n         && let hir::ExprKind::MethodCall(_, struct_expr, [], _) = &into_iter_expr.kind\n         && let Some(into_iter_def_id) = cx.typeck_results().type_dependent_def_id(into_iter_expr.hir_id)\n-        && match_def_path(cx, into_iter_def_id, &paths::CORE_ITER_INTO_ITER)\n+        && cx.tcx.lang_items().require(hir::LangItem::IntoIterIntoIter).ok() == Some(into_iter_def_id)\n         && match_acceptable_type(cx, left_expr, msrv)\n         && SpanlessEq::new(cx).eq_expr(left_expr, struct_expr) {\n         suggest(cx, parent_expr, left_expr, target_expr);"}, {"sha": "fd14d868df348e7e856c08e8b59bf2f4c9ee58d8", "filename": "clippy_lints/src/matches/collapsible_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fcollapsible_match.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,7 +1,9 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::higher::IfLetOrMatch;\n use clippy_utils::visitors::is_local_used;\n-use clippy_utils::{is_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq};\n+use clippy_utils::{\n+    is_res_lang_ctor, is_unit_expr, path_to_local, peel_blocks_with_stmt, peel_ref_operators, SpanlessEq,\n+};\n use if_chain::if_chain;\n use rustc_errors::MultiSpan;\n use rustc_hir::LangItem::OptionNone;\n@@ -110,7 +112,7 @@ fn arm_is_wild_like(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     }\n     match arm.pat.kind {\n         PatKind::Binding(..) | PatKind::Wild => true,\n-        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n         _ => false,\n     }\n }"}, {"sha": "76f5e1c941c7a270e37f0647455c8db60550588c", "filename": "clippy_lints/src/matches/manual_map.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_map.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -3,8 +3,8 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::ty::{is_type_diagnostic_item, peel_mid_ty_refs_is_mutable, type_is_unsafe_function};\n use clippy_utils::{\n-    can_move_expr_to_closure, is_else_clause, is_lang_ctor, is_lint_allowed, path_to_local_id, peel_blocks,\n-    peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n+    can_move_expr_to_closure, is_else_clause, is_lint_allowed, is_res_lang_ctor, path_res, path_to_local_id,\n+    peel_blocks, peel_hir_expr_refs, peel_hir_expr_while, CaptureKind,\n };\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::Applicability;\n@@ -251,9 +251,11 @@ fn try_parse_pattern<'tcx>(cx: &LateContext<'tcx>, pat: &'tcx Pat<'_>, ctxt: Syn\n         match pat.kind {\n             PatKind::Wild => Some(OptionPat::Wild),\n             PatKind::Ref(pat, _) => f(cx, pat, ref_count + 1, ctxt),\n-            PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone) => Some(OptionPat::None),\n+            PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionNone) => {\n+                Some(OptionPat::None)\n+            },\n             PatKind::TupleStruct(ref qpath, [pattern], _)\n-                if is_lang_ctor(cx, qpath, OptionSome) && pat.span.ctxt() == ctxt =>\n+                if is_res_lang_ctor(cx, cx.qpath_res(qpath, pat.hir_id), OptionSome) && pat.span.ctxt() == ctxt =>\n             {\n                 Some(OptionPat::Some { pattern, ref_count })\n             },\n@@ -272,16 +274,14 @@ fn get_some_expr<'tcx>(\n ) -> Option<SomeExpr<'tcx>> {\n     // TODO: Allow more complex expressions.\n     match expr.kind {\n-        ExprKind::Call(\n-            Expr {\n-                kind: ExprKind::Path(ref qpath),\n-                ..\n-            },\n-            [arg],\n-        ) if ctxt == expr.span.ctxt() && is_lang_ctor(cx, qpath, OptionSome) => Some(SomeExpr {\n-            expr: arg,\n-            needs_unsafe_block,\n-        }),\n+        ExprKind::Call(callee, [arg])\n+            if ctxt == expr.span.ctxt() && is_res_lang_ctor(cx, path_res(cx, callee), OptionSome) =>\n+        {\n+            Some(SomeExpr {\n+                expr: arg,\n+                needs_unsafe_block,\n+            })\n+        },\n         ExprKind::Block(\n             Block {\n                 stmts: [],\n@@ -302,5 +302,5 @@ fn get_some_expr<'tcx>(\n \n // Checks for the `None` value.\n fn is_none_expr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    matches!(peel_blocks(expr).kind, ExprKind::Path(ref qpath) if is_lang_ctor(cx, qpath, OptionNone))\n+    is_res_lang_ctor(cx, path_res(cx, peel_blocks(expr)), OptionNone)\n }"}, {"sha": "587c926dc01c3f02d790653c72dcbc3d8eded3e8", "filename": "clippy_lints/src/matches/manual_unwrap_or.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmanual_unwrap_or.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -3,12 +3,14 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::usage::contains_return_break_continue_macro;\n-use clippy_utils::{is_lang_ctor, path_to_local_id, sugg};\n+use clippy_utils::{is_res_lang_ctor, path_to_local_id, sugg};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n+use rustc_hir::LangItem::{OptionNone, ResultErr};\n use rustc_hir::{Arm, Expr, PatKind};\n use rustc_lint::LateContext;\n+use rustc_middle::ty::DefIdTree;\n use rustc_span::sym;\n \n use super::MANUAL_UNWRAP_OR;\n@@ -59,15 +61,19 @@ fn applicable_or_arm<'a>(cx: &LateContext<'_>, arms: &'a [Arm<'a>]) -> Option<&'\n         if arms.iter().all(|arm| arm.guard.is_none());\n         if let Some((idx, or_arm)) = arms.iter().enumerate().find(|(_, arm)| {\n             match arm.pat.kind {\n-                PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+                PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n                 PatKind::TupleStruct(ref qpath, [pat], _) =>\n-                    matches!(pat.kind, PatKind::Wild) && is_lang_ctor(cx, qpath, ResultErr),\n+                    matches!(pat.kind, PatKind::Wild)\n+                        && is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), ResultErr),\n                 _ => false,\n             }\n         });\n         let unwrap_arm = &arms[1 - idx];\n         if let PatKind::TupleStruct(ref qpath, [unwrap_pat], _) = unwrap_arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk);\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(qpath, unwrap_arm.pat.hir_id);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        if cx.tcx.lang_items().option_some_variant() == Some(variant_id)\n+            || cx.tcx.lang_items().result_ok_variant() == Some(variant_id);\n         if let PatKind::Binding(_, binding_hir_id, ..) = unwrap_pat.kind;\n         if path_to_local_id(unwrap_arm.body, binding_hir_id);\n         if cx.typeck_results().expr_adjustments(unwrap_arm.body).is_empty();"}, {"sha": "2818f030b7a6388fc85b4ca52fe99da681b75aca", "filename": "clippy_lints/src/matches/match_as_ref.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fmatch_as_ref.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n-use clippy_utils::{is_lang_ctor, peel_blocks};\n+use clippy_utils::{is_res_lang_ctor, path_res, peel_blocks};\n use rustc_errors::Applicability;\n use rustc_hir::{Arm, BindingAnnotation, ByRef, Expr, ExprKind, LangItem, Mutability, PatKind, QPath};\n use rustc_lint::LateContext;\n@@ -59,18 +59,20 @@ pub(crate) fn check(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr:\n \n // Checks if arm has the form `None => None`\n fn is_none_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n-    matches!(arm.pat.kind, PatKind::Path(ref qpath) if is_lang_ctor(cx, qpath, LangItem::OptionNone))\n+    matches!(\n+        arm.pat.kind,\n+        PatKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), LangItem::OptionNone)\n+    )\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n fn is_ref_some_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> Option<Mutability> {\n     if_chain! {\n         if let PatKind::TupleStruct(ref qpath, [first_pat, ..], _) = arm.pat.kind;\n-        if is_lang_ctor(cx, qpath, LangItem::OptionSome);\n+        if is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), LangItem::OptionSome);\n         if let PatKind::Binding(BindingAnnotation(ByRef::Yes, mutabl), .., ident, _) = first_pat.kind;\n         if let ExprKind::Call(e, [arg]) = peel_blocks(arm.body).kind;\n-        if let ExprKind::Path(ref some_path) = e.kind;\n-        if is_lang_ctor(cx, some_path, LangItem::OptionSome);\n+        if is_res_lang_ctor(cx, path_res(cx, e), LangItem::OptionSome);\n         if let ExprKind::Path(QPath::Resolved(_, path2)) = arg.kind;\n         if path2.segments.len() == 1 && ident.name == path2.segments[0].ident.name;\n         then {"}, {"sha": "c4f6852aedc3d541785111161099fba809ff86b4", "filename": "clippy_lints/src/matches/needless_match.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fneedless_match.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{\n-    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_lang_ctor, over,\n+    eq_expr_value, get_parent_expr_for_hir, get_parent_node, higher, is_else_clause, is_res_lang_ctor, over, path_res,\n     peel_blocks_with_stmt,\n };\n use rustc_errors::Applicability;\n@@ -112,10 +112,7 @@ fn check_if_let_inner(cx: &LateContext<'_>, if_let: &higher::IfLet<'_>) -> bool\n             let ret = strip_return(else_expr);\n             let let_expr_ty = cx.typeck_results().expr_ty(if_let.let_expr);\n             if is_type_diagnostic_item(cx, let_expr_ty, sym::Option) {\n-                if let ExprKind::Path(ref qpath) = ret.kind {\n-                    return is_lang_ctor(cx, qpath, OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n-                }\n-                return false;\n+                return is_res_lang_ctor(cx, path_res(cx, ret), OptionNone) || eq_expr_value(cx, if_let.let_expr, ret);\n             }\n             return eq_expr_value(cx, if_let.let_expr, ret);\n         }"}, {"sha": "81bebff34c82c78644adfbf5ba37d34f46f7ba54", "filename": "clippy_lints/src/matches/redundant_pattern_match.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Fredundant_pattern_match.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -4,10 +4,11 @@ use clippy_utils::source::snippet;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::{is_type_diagnostic_item, needs_ordered_drop};\n use clippy_utils::visitors::any_temporaries_need_ordered_drop;\n-use clippy_utils::{higher, is_lang_ctor, is_trait_method};\n+use clippy_utils::{higher, is_trait_method};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::LangItem::{self, OptionNone, OptionSome, PollPending, PollReady, ResultErr, ResultOk};\n use rustc_hir::{Arm, Expr, ExprKind, Node, Pat, PatKind, QPath, UnOp};\n use rustc_lint::LateContext;\n@@ -87,15 +88,21 @@ fn find_sugg_for_if_let<'tcx>(\n             }\n         },\n         PatKind::Path(ref path) => {\n-            let method = if is_lang_ctor(cx, path, OptionNone) {\n-                \"is_none()\"\n-            } else if is_lang_ctor(cx, path, PollPending) {\n-                \"is_pending()\"\n+            if let Res::Def(DefKind::Ctor(..), ctor_id) = cx.qpath_res(path, check_pat.hir_id)\n+                && let Some(variant_id) = cx.tcx.opt_parent(ctor_id)\n+            {\n+                let method = if cx.tcx.lang_items().option_none_variant() == Some(variant_id) {\n+                    \"is_none()\"\n+                } else if cx.tcx.lang_items().poll_pending_variant() == Some(variant_id) {\n+                    \"is_pending()\"\n+                } else {\n+                    return;\n+                };\n+                // `None` and `Pending` don't have an inner type.\n+                (method, cx.tcx.types.unit)\n             } else {\n                 return;\n-            };\n-            // `None` and `Pending` don't have an inner type.\n-            (method, cx.tcx.types.unit)\n+            }\n         },\n         _ => return,\n     };"}, {"sha": "c6cba81d8718972e89d436f83a3b4ef2facd37e2", "filename": "clippy_lints/src/matches/try_err.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches%2Ftry_err.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{get_parent_expr, is_lang_ctor, match_def_path, paths};\n+use clippy_utils::{get_parent_expr, is_res_lang_ctor, match_def_path, path_res, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::ResultErr;\n@@ -27,8 +27,7 @@ pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, scrutine\n         if let ExprKind::Path(ref match_fun_path) = match_fun.kind;\n         if matches!(match_fun_path, QPath::LangItem(LangItem::TryTraitBranch, ..));\n         if let ExprKind::Call(err_fun, [err_arg, ..]) = try_arg.kind;\n-        if let ExprKind::Path(ref err_fun_path) = err_fun.kind;\n-        if is_lang_ctor(cx, err_fun_path, ResultErr);\n+        if is_res_lang_ctor(cx, path_res(cx, err_fun), ResultErr);\n         if let Some(return_ty) = find_return_type(cx, &expr.kind);\n         then {\n             let prefix;"}, {"sha": "0c4d9f100f7a966f7c3bade76f7e3843b3518f70", "filename": "clippy_lints/src/mem_replace.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmem_replace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmem_replace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_replace.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::{span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::is_non_aggregate_primitive_type;\n-use clippy_utils::{is_default_equivalent, is_lang_ctor, meets_msrv, msrvs};\n+use clippy_utils::{is_default_equivalent, is_res_lang_ctor, meets_msrv, msrvs, path_res};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::OptionNone;\n@@ -102,40 +102,38 @@ impl_lint_pass!(MemReplace =>\n     [MEM_REPLACE_OPTION_WITH_NONE, MEM_REPLACE_WITH_UNINIT, MEM_REPLACE_WITH_DEFAULT]);\n \n fn check_replace_option_with_none(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<'_>, expr_span: Span) {\n-    if let ExprKind::Path(ref replacement_qpath) = src.kind {\n-        // Check that second argument is `Option::None`\n-        if is_lang_ctor(cx, replacement_qpath, OptionNone) {\n-            // Since this is a late pass (already type-checked),\n-            // and we already know that the second argument is an\n-            // `Option`, we do not need to check the first\n-            // argument's type. All that's left is to get\n-            // replacee's path.\n-            let replaced_path = match dest.kind {\n-                ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n-                    if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n-                        replaced_path\n-                    } else {\n-                        return;\n-                    }\n-                },\n-                ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n-                _ => return,\n-            };\n+    // Check that second argument is `Option::None`\n+    if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n+        // Since this is a late pass (already type-checked),\n+        // and we already know that the second argument is an\n+        // `Option`, we do not need to check the first\n+        // argument's type. All that's left is to get\n+        // replacee's path.\n+        let replaced_path = match dest.kind {\n+            ExprKind::AddrOf(BorrowKind::Ref, Mutability::Mut, replaced) => {\n+                if let ExprKind::Path(QPath::Resolved(None, replaced_path)) = replaced.kind {\n+                    replaced_path\n+                } else {\n+                    return;\n+                }\n+            },\n+            ExprKind::Path(QPath::Resolved(None, replaced_path)) => replaced_path,\n+            _ => return,\n+        };\n \n-            let mut applicability = Applicability::MachineApplicable;\n-            span_lint_and_sugg(\n-                cx,\n-                MEM_REPLACE_OPTION_WITH_NONE,\n-                expr_span,\n-                \"replacing an `Option` with `None`\",\n-                \"consider `Option::take()` instead\",\n-                format!(\n-                    \"{}.take()\",\n-                    snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)\n-                ),\n-                applicability,\n-            );\n-        }\n+        let mut applicability = Applicability::MachineApplicable;\n+        span_lint_and_sugg(\n+            cx,\n+            MEM_REPLACE_OPTION_WITH_NONE,\n+            expr_span,\n+            \"replacing an `Option` with `None`\",\n+            \"consider `Option::take()` instead\",\n+            format!(\n+                \"{}.take()\",\n+                snippet_with_applicability(cx, replaced_path.span, \"\", &mut applicability)\n+            ),\n+            applicability,\n+        );\n     }\n }\n \n@@ -203,10 +201,8 @@ fn check_replace_with_default(cx: &LateContext<'_>, src: &Expr<'_>, dest: &Expr<\n         return;\n     }\n     // disable lint for Option since it is covered in another lint\n-    if let ExprKind::Path(q) = &src.kind {\n-        if is_lang_ctor(cx, q, OptionNone) {\n-            return;\n-        }\n+    if is_res_lang_ctor(cx, path_res(cx, src), OptionNone) {\n+        return;\n     }\n     if is_default_equivalent(cx, src) && !in_external_macro(cx.tcx.sess, expr_span) {\n         span_lint_and_then("}, {"sha": "3fef53739fbde876c7114f2967c7ffc7231b730b", "filename": "clippy_lints/src/methods/filetype_is_file.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Ffiletype_is_file.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,17 +1,18 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n-use clippy_utils::ty::match_type;\n-use clippy_utils::{get_parent_expr, paths};\n+use clippy_utils::get_parent_expr;\n+use clippy_utils::ty::is_type_diagnostic_item;\n use if_chain::if_chain;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_span::source_map::Span;\n+use rustc_span::sym;\n \n use super::FILETYPE_IS_FILE;\n \n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     let ty = cx.typeck_results().expr_ty(recv);\n \n-    if !match_type(cx, ty, &paths::FILE_TYPE) {\n+    if !is_type_diagnostic_item(cx, ty, sym::FileType) {\n         return;\n     }\n "}, {"sha": "ede3b8bb74e97c7353dcef5154a167057bceb612", "filename": "clippy_lints/src/methods/inefficient_to_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Finefficient_to_string.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -65,7 +65,7 @@ fn specializes_tostring(cx: &LateContext<'_>, ty: Ty<'_>) -> bool {\n     }\n \n     if let ty::Adt(adt, substs) = ty.kind() {\n-        match_def_path(cx, adt.did(), &paths::COW) && substs.type_at(1).is_str()\n+        cx.tcx.is_diagnostic_item(sym::Cow, adt.did()) && substs.type_at(1).is_str()\n     } else {\n         false\n     }"}, {"sha": "4f73b3ec42247e56bacf4f6d9df9a1506095c6e7", "filename": "clippy_lints/src/methods/iter_on_single_or_empty_collections.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fiter_on_single_or_empty_collections.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n-use clippy_utils::{get_expr_use_or_unification_node, is_lang_ctor, is_no_std_crate};\n+use clippy_utils::{get_expr_use_or_unification_node, is_no_std_crate, is_res_lang_ctor, path_res};\n \n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -26,26 +26,11 @@ impl IterType {\n }\n \n pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, method_name: &str, recv: &Expr<'_>) {\n-    let item = match &recv.kind {\n-        ExprKind::Array(v) if v.len() <= 1 => v.first(),\n-        ExprKind::Path(p) => {\n-            if is_lang_ctor(cx, p, OptionNone) {\n-                None\n-            } else {\n-                return;\n-            }\n-        },\n-        ExprKind::Call(f, some_args) if some_args.len() == 1 => {\n-            if let ExprKind::Path(p) = &f.kind {\n-                if is_lang_ctor(cx, p, OptionSome) {\n-                    Some(&some_args[0])\n-                } else {\n-                    return;\n-                }\n-            } else {\n-                return;\n-            }\n-        },\n+    let item = match recv.kind {\n+        ExprKind::Array([]) => None,\n+        ExprKind::Array([e]) => Some(e),\n+        ExprKind::Path(ref p) if is_res_lang_ctor(cx, cx.qpath_res(p, recv.hir_id), OptionNone) => None,\n+        ExprKind::Call(f, [arg]) if is_res_lang_ctor(cx, path_res(cx, f), OptionSome) => Some(arg),\n         _ => return,\n     };\n     let iter_type = match method_name {"}, {"sha": "5b758f1e6547c676ea7dca16710969e9df4834ec", "filename": "clippy_lints/src/methods/manual_ok_or.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_ok_or.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,11 +1,11 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{indent_of, reindent_multiline, snippet_opt};\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, path_to_local_id};\n+use clippy_utils::{is_res_lang_ctor, path_res, path_to_local_id};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::LangItem::{ResultErr, ResultOk};\n-use rustc_hir::{Closure, Expr, ExprKind, PatKind};\n+use rustc_hir::{Expr, ExprKind, PatKind};\n use rustc_lint::LateContext;\n use rustc_span::symbol::sym;\n \n@@ -22,8 +22,8 @@ pub(super) fn check<'tcx>(\n         if let Some(method_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if let Some(impl_id) = cx.tcx.impl_of_method(method_id);\n         if is_type_diagnostic_item(cx, cx.tcx.type_of(impl_id), sym::Option);\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(err_path), .. }, [err_arg]) = or_expr.kind;\n-        if is_lang_ctor(cx, err_path, ResultErr);\n+        if let ExprKind::Call(err_path, [err_arg]) = or_expr.kind;\n+        if is_res_lang_ctor(cx, path_res(cx, err_path), ResultErr);\n         if is_ok_wrapping(cx, map_expr);\n         if let Some(recv_snippet) = snippet_opt(cx, recv.span);\n         if let Some(err_arg_snippet) = snippet_opt(cx, err_arg.span);\n@@ -46,17 +46,19 @@ pub(super) fn check<'tcx>(\n }\n \n fn is_ok_wrapping(cx: &LateContext<'_>, map_expr: &Expr<'_>) -> bool {\n-    if let ExprKind::Path(ref qpath) = map_expr.kind {\n-        if is_lang_ctor(cx, qpath, ResultOk) {\n-            return true;\n-        }\n-    }\n-    if_chain! {\n-        if let ExprKind::Closure(&Closure { body, .. }) = map_expr.kind;\n-        let body = cx.tcx.hir().body(body);\n-        if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind;\n-        if let ExprKind::Call(Expr { kind: ExprKind::Path(ok_path), .. }, [ok_arg]) = body.value.kind;\n-        if is_lang_ctor(cx, ok_path, ResultOk);\n-        then { path_to_local_id(ok_arg, param_id) } else { false }\n+    match map_expr.kind {\n+        ExprKind::Path(ref qpath) if is_res_lang_ctor(cx, cx.qpath_res(qpath, map_expr.hir_id), ResultOk) => true,\n+        ExprKind::Closure(closure) => {\n+            let body = cx.tcx.hir().body(closure.body);\n+            if let PatKind::Binding(_, param_id, ..) = body.params[0].pat.kind\n+                && let ExprKind::Call(callee, [ok_arg]) = body.value.kind\n+                && is_res_lang_ctor(cx, path_res(cx, callee), ResultOk)\n+            {\n+                path_to_local_id(ok_arg, param_id)\n+            } else {\n+                false\n+            }\n+        },\n+        _ => false,\n     }\n }"}, {"sha": "8b6b8f1bf16cbbfcf6952c4dac6fd684448d85e3", "filename": "clippy_lints/src/methods/manual_str_repeat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmanual_str_repeat.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,8 +1,8 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::is_path_diagnostic_item;\n use clippy_utils::source::{snippet_with_applicability, snippet_with_context};\n use clippy_utils::sugg::Sugg;\n-use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n-use clippy_utils::{is_expr_path_def_path, paths};\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item};\n use if_chain::if_chain;\n use rustc_ast::LitKind;\n use rustc_errors::Applicability;\n@@ -38,7 +38,7 @@ fn parse_repeat_arg(cx: &LateContext<'_>, e: &Expr<'_>) -> Option<RepeatKind> {\n         let ty = cx.typeck_results().expr_ty(e);\n         if is_type_diagnostic_item(cx, ty, sym::String)\n             || (is_type_lang_item(cx, ty, LangItem::OwnedBox) && get_ty_param(ty).map_or(false, Ty::is_str))\n-            || (match_type(cx, ty, &paths::COW) && get_ty_param(ty).map_or(false, Ty::is_str))\n+            || (is_type_diagnostic_item(cx, ty, sym::Cow) && get_ty_param(ty).map_or(false, Ty::is_str))\n         {\n             Some(RepeatKind::String)\n         } else {\n@@ -57,7 +57,7 @@ pub(super) fn check(\n ) {\n     if_chain! {\n         if let ExprKind::Call(repeat_fn, [repeat_arg]) = take_self_arg.kind;\n-        if is_expr_path_def_path(cx, repeat_fn, &paths::ITER_REPEAT);\n+        if is_path_diagnostic_item(cx, repeat_fn, sym::iter_repeat);\n         if is_type_diagnostic_item(cx, cx.typeck_results().expr_ty(collect_expr), sym::String);\n         if let Some(collect_id) = cx.typeck_results().type_dependent_def_id(collect_expr.hir_id);\n         if let Some(take_id) = cx.typeck_results().type_dependent_def_id(take_expr.hir_id);"}, {"sha": "3a23ecc50dc1d4dc76b90fd721220eed395b40dc", "filename": "clippy_lints/src/methods/option_map_or_none.rs", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Foption_map_or_none.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{is_lang_ctor, path_def_id};\n+use clippy_utils::{is_res_lang_ctor, path_def_id, path_res};\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -51,22 +51,12 @@ pub(super) fn check<'tcx>(\n         return;\n     }\n \n-    let default_arg_is_none = if let hir::ExprKind::Path(ref qpath) = def_arg.kind {\n-        is_lang_ctor(cx, qpath, OptionNone)\n-    } else {\n-        return;\n-    };\n-\n-    if !default_arg_is_none {\n+    if !is_res_lang_ctor(cx, path_res(cx, def_arg), OptionNone) {\n         // nothing to lint!\n         return;\n     }\n \n-    let f_arg_is_some = if let hir::ExprKind::Path(ref qpath) = map_arg.kind {\n-        is_lang_ctor(cx, qpath, OptionSome)\n-    } else {\n-        false\n-    };\n+    let f_arg_is_some = is_res_lang_ctor(cx, path_res(cx, map_arg), OptionSome);\n \n     if is_option {\n         let self_snippet = snippet(cx, recv.span, \"..\");"}, {"sha": "55ba6e262df7e1d44b2f3555eddec6f4b26f9d26", "filename": "clippy_lints/src/methods/or_then_unwrap.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2For_then_unwrap.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n-use clippy_utils::{diagnostics::span_lint_and_sugg, is_lang_ctor};\n+use clippy_utils::{diagnostics::span_lint_and_sugg, is_res_lang_ctor, path_res};\n use rustc_errors::Applicability;\n use rustc_hir::{lang_items::LangItem, Expr, ExprKind};\n use rustc_lint::LateContext;\n@@ -58,8 +58,7 @@ pub(super) fn check<'tcx>(\n \n fn get_content_if_ctor_matches(cx: &LateContext<'_>, expr: &Expr<'_>, item: LangItem) -> Option<Span> {\n     if let ExprKind::Call(some_expr, [arg]) = expr.kind\n-        && let ExprKind::Path(qpath) = &some_expr.kind\n-        && is_lang_ctor(cx, qpath, item)\n+        && is_res_lang_ctor(cx, path_res(cx, some_expr), item)\n     {\n         Some(arg.span)\n     } else {"}, {"sha": "50434a5658ac5cb3ce9c96f2066708cb70d89ca9", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -2,7 +2,7 @@ use super::utils::clone_or_copy_needed;\n use clippy_utils::diagnostics::span_lint;\n use clippy_utils::ty::is_copy;\n use clippy_utils::usage::mutated_variables;\n-use clippy_utils::{is_lang_ctor, is_trait_method, path_to_local_id};\n+use clippy_utils::{is_res_lang_ctor, is_trait_method, path_res, path_to_local_id};\n use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_expr, Visitor};\n use rustc_hir::LangItem::{OptionNone, OptionSome};\n@@ -61,15 +61,13 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Expr<\n \n // returns (found_mapping, found_filtering)\n fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tcx hir::Expr<'_>) -> (bool, bool) {\n-    match &expr.kind {\n+    match expr.kind {\n         hir::ExprKind::Call(func, args) => {\n-            if let hir::ExprKind::Path(ref path) = func.kind {\n-                if is_lang_ctor(cx, path, OptionSome) {\n-                    if path_to_local_id(&args[0], arg_id) {\n-                        return (false, false);\n-                    }\n-                    return (true, false);\n+            if is_res_lang_ctor(cx, path_res(cx, func), OptionSome) {\n+                if path_to_local_id(&args[0], arg_id) {\n+                    return (false, false);\n                 }\n+                return (true, false);\n             }\n             (true, true)\n         },\n@@ -80,7 +78,7 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n         hir::ExprKind::Match(_, arms, _) => {\n             let mut found_mapping = false;\n             let mut found_filtering = false;\n-            for arm in *arms {\n+            for arm in arms {\n                 let (m, f) = check_expression(cx, arg_id, arm.body);\n                 found_mapping |= m;\n                 found_filtering |= f;\n@@ -93,7 +91,9 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             let else_check = check_expression(cx, arg_id, else_arm);\n             (if_check.0 | else_check.0, if_check.1 | else_check.1)\n         },\n-        hir::ExprKind::Path(path) if is_lang_ctor(cx, path, OptionNone) => (false, true),\n+        hir::ExprKind::Path(ref path) if is_res_lang_ctor(cx, cx.qpath_res(path, expr.hir_id), OptionNone) => {\n+            (false, true)\n+        },\n         _ => (true, true),\n     }\n }"}, {"sha": "c1139d84e2f47eb1138e475a859b320db610dff2", "filename": "clippy_lints/src/methods/useless_asref.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fuseless_asref.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,19 +1,20 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::walk_ptrs_ty_depth;\n-use clippy_utils::{get_parent_expr, match_trait_method, paths};\n+use clippy_utils::{get_parent_expr, is_trait_method};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n+use rustc_span::sym;\n \n use super::USELESS_ASREF;\n \n /// Checks for the `USELESS_ASREF` lint.\n pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, call_name: &str, recvr: &hir::Expr<'_>) {\n     // when we get here, we've already checked that the call name is \"as_ref\" or \"as_mut\"\n     // check if the call is to the actual `AsRef` or `AsMut` trait\n-    if match_trait_method(cx, expr, &paths::ASREF_TRAIT) || match_trait_method(cx, expr, &paths::ASMUT_TRAIT) {\n+    if is_trait_method(cx, expr, sym::AsRef) || is_trait_method(cx, expr, sym::AsMut) {\n         // check if the type after `as_ref` or `as_mut` is the same as before\n         let rcv_ty = cx.typeck_results().expr_ty(recvr);\n         let res_ty = cx.typeck_results().expr_ty(expr);"}, {"sha": "4f967755bfa1975d5781547dd1eaa89569dd1bec", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::{match_trait_method, paths};\n+use clippy_utils::is_trait_method;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -83,7 +83,7 @@ fn min_max<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<(MinMax, Cons\n             }\n         },\n         ExprKind::MethodCall(path, receiver, args @ [_], _) => {\n-            if cx.typeck_results().expr_ty(receiver).is_floating_point() || match_trait_method(cx, expr, &paths::ORD) {\n+            if cx.typeck_results().expr_ty(receiver).is_floating_point() || is_trait_method(cx, expr, sym::Ord) {\n                 if path.ident.name == sym!(max) {\n                     fetch_const(cx, Some(receiver), args, MinMax::Max)\n                 } else if path.ident.name == sym!(min) {"}, {"sha": "97c8cfbd3eb7a195cda0aa3b4a1caa7ffdfcde40", "filename": "clippy_lints/src/needless_question_mark.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fneedless_question_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_question_mark.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,11 +1,12 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n-use clippy_utils::is_lang_ctor;\n+use clippy_utils::path_res;\n use clippy_utils::source::snippet;\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::LangItem::{OptionSome, ResultOk};\n+use rustc_hir::def::{DefKind, Res};\n use rustc_hir::{AsyncGeneratorKind, Block, Body, Expr, ExprKind, GeneratorKind, LangItem, MatchSource, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::DefIdTree;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n declare_clippy_lint! {\n@@ -112,11 +113,12 @@ impl LateLintPass<'_> for NeedlessQuestionMark {\n \n fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     if_chain! {\n-        if let ExprKind::Call(path, [arg]) = &expr.kind;\n-        if let ExprKind::Path(ref qpath) = &path.kind;\n-        let sugg_remove = if is_lang_ctor(cx, qpath, OptionSome) {\n+        if let ExprKind::Call(path, [arg]) = expr.kind;\n+        if let Res::Def(DefKind::Ctor(..), ctor_id) = path_res(cx, path);\n+        if let Some(variant_id) = cx.tcx.opt_parent(ctor_id);\n+        let sugg_remove = if cx.tcx.lang_items().option_some_variant() == Some(variant_id) {\n             \"Some()\"\n-        } else if is_lang_ctor(cx, qpath, ResultOk) {\n+        } else if cx.tcx.lang_items().result_ok_variant() == Some(variant_id) {\n             \"Ok()\"\n         } else {\n             return;"}, {"sha": "1a765b14892f6fccba6e1f6b4a2c0ca52435e6f2", "filename": "clippy_lints/src/non_octal_unix_permissions.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_octal_unix_permissions.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,12 +1,13 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::source::{snippet_opt, snippet_with_applicability};\n-use clippy_utils::ty::match_type;\n+use clippy_utils::ty::{is_type_diagnostic_item, match_type};\n use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -49,7 +50,7 @@ impl<'tcx> LateLintPass<'tcx> for NonOctalUnixPermissions {\n                 if_chain! {\n                     if (path.ident.name == sym!(mode)\n                         && (match_type(cx, obj_ty, &paths::OPEN_OPTIONS)\n-                            || match_type(cx, obj_ty, &paths::DIR_BUILDER)))\n+                            || is_type_diagnostic_item(cx, obj_ty, sym::DirBuilder)))\n                         || (path.ident.name == sym!(set_mode) && match_type(cx, obj_ty, &paths::PERMISSIONS));\n                     if let ExprKind::Lit(_) = param.kind;\n "}, {"sha": "4eb42da1fed02a1bdabb2dab559c36498e31b310", "filename": "clippy_lints/src/option_if_let_else.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,7 +1,7 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::{\n-    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_lang_ctor, peel_blocks,\n+    can_move_expr_to_closure, eager_or_lazy, higher, in_constant, is_else_clause, is_res_lang_ctor, peel_blocks,\n     peel_hir_expr_while, CaptureKind,\n };\n use if_chain::if_chain;\n@@ -174,7 +174,8 @@ fn try_get_option_occurrence<'tcx>(\n \n fn try_get_inner_pat<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'tcx>) -> Option<&'tcx Pat<'tcx>> {\n     if let PatKind::TupleStruct(ref qpath, [inner_pat], ..) = pat.kind {\n-        if is_lang_ctor(cx, qpath, OptionSome) || is_lang_ctor(cx, qpath, ResultOk) {\n+        let res = cx.qpath_res(qpath, pat.hir_id);\n+        if is_res_lang_ctor(cx, res, OptionSome) || is_res_lang_ctor(cx, res, ResultOk) {\n             return Some(inner_pat);\n         }\n     }\n@@ -226,9 +227,10 @@ fn try_convert_match<'tcx>(\n \n fn is_none_or_err_arm(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n     match arm.pat.kind {\n-        PatKind::Path(ref qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        PatKind::Path(ref qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), OptionNone),\n         PatKind::TupleStruct(ref qpath, [first_pat], _) => {\n-            is_lang_ctor(cx, qpath, ResultErr) && matches!(first_pat.kind, PatKind::Wild)\n+            is_res_lang_ctor(cx, cx.qpath_res(qpath, arm.pat.hir_id), ResultErr)\n+                && matches!(first_pat.kind, PatKind::Wild)\n         },\n         PatKind::Wild => true,\n         _ => false,"}, {"sha": "6810a2431758910ab3a62bf5ac25286882ac5e97", "filename": "clippy_lints/src/partialeq_to_none.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_to_none.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,5 +1,5 @@\n use clippy_utils::{\n-    diagnostics::span_lint_and_sugg, is_lang_ctor, peel_hir_expr_refs, peel_ref_operators, sugg,\n+    diagnostics::span_lint_and_sugg, is_res_lang_ctor, path_res, peel_hir_expr_refs, peel_ref_operators, sugg,\n     ty::is_type_diagnostic_item,\n };\n use rustc_errors::Applicability;\n@@ -54,8 +54,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialeqToNone {\n         // If the expression is a literal `Option::None`\n         let is_none_ctor = |expr: &Expr<'_>| {\n             !expr.span.from_expansion()\n-                && matches!(&peel_hir_expr_refs(expr).0.kind,\n-            ExprKind::Path(p) if is_lang_ctor(cx, p, LangItem::OptionNone))\n+                && is_res_lang_ctor(cx, path_res(cx, peel_hir_expr_refs(expr).0), LangItem::OptionNone)\n         };\n \n         let mut applicability = Applicability::MachineApplicable;"}, {"sha": "328371fd602f0c517c9c48a6ff2a6585535e90ba", "filename": "clippy_lints/src/question_mark.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fquestion_mark.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -3,11 +3,12 @@ use clippy_utils::higher;\n use clippy_utils::source::snippet_with_applicability;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n-    eq_expr_value, get_parent_node, in_constant, is_else_clause, is_lang_ctor, path_to_local, path_to_local_id,\n+    eq_expr_value, get_parent_node, in_constant, is_else_clause, is_res_lang_ctor, path_to_local, path_to_local_id,\n     peel_blocks, peel_blocks_with_stmt,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n+use rustc_hir::def::Res;\n use rustc_hir::LangItem::{OptionNone, OptionSome, ResultErr, ResultOk};\n use rustc_hir::{BindingAnnotation, ByRef, Expr, ExprKind, Node, PatKind, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n@@ -58,7 +59,7 @@ enum IfBlockType<'hir> {\n     /// Contains: let_pat_qpath (Xxx), let_pat_type, let_pat_sym (a), let_expr (b), if_then (c),\n     /// if_else (d)\n     IfLet(\n-        &'hir QPath<'hir>,\n+        Res,\n         Ty<'hir>,\n         Symbol,\n         &'hir Expr<'hir>,\n@@ -126,7 +127,14 @@ fn check_if_let_some_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr:\n         if ddpos.as_opt_usize().is_none();\n         if let PatKind::Binding(BindingAnnotation(by_ref, _), bind_id, ident, None) = field.kind;\n         let caller_ty = cx.typeck_results().expr_ty(let_expr);\n-        let if_block = IfBlockType::IfLet(path1, caller_ty, ident.name, let_expr, if_then, if_else);\n+        let if_block = IfBlockType::IfLet(\n+            cx.qpath_res(path1, let_pat.hir_id),\n+            caller_ty,\n+            ident.name,\n+            let_expr,\n+            if_then,\n+            if_else\n+        );\n         if (is_early_return(sym::Option, cx, &if_block) && path_to_local_id(peel_blocks(if_then), bind_id))\n             || is_early_return(sym::Result, cx, &if_block);\n         if if_else.map(|e| eq_expr_value(cx, let_expr, peel_blocks(e))).filter(|e| *e).is_none();\n@@ -165,21 +173,21 @@ fn is_early_return(smbl: Symbol, cx: &LateContext<'_>, if_block: &IfBlockType<'_\n                     _ => false,\n                 }\n         },\n-        IfBlockType::IfLet(qpath, let_expr_ty, let_pat_sym, let_expr, if_then, if_else) => {\n+        IfBlockType::IfLet(res, let_expr_ty, let_pat_sym, let_expr, if_then, if_else) => {\n             is_type_diagnostic_item(cx, let_expr_ty, smbl)\n                 && match smbl {\n                     sym::Option => {\n                         // We only need to check `if let Some(x) = option` not `if let None = option`,\n                         // because the later one will be suggested as `if option.is_none()` thus causing conflict.\n-                        is_lang_ctor(cx, qpath, OptionSome)\n+                        is_res_lang_ctor(cx, res, OptionSome)\n                             && if_else.is_some()\n                             && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, None)\n                     },\n                     sym::Result => {\n-                        (is_lang_ctor(cx, qpath, ResultOk)\n+                        (is_res_lang_ctor(cx, res, ResultOk)\n                             && if_else.is_some()\n                             && expr_return_none_or_err(smbl, cx, if_else.unwrap(), let_expr, Some(let_pat_sym)))\n-                            || is_lang_ctor(cx, qpath, ResultErr)\n+                            || is_res_lang_ctor(cx, res, ResultErr)\n                                 && expr_return_none_or_err(smbl, cx, if_then, let_expr, Some(let_pat_sym))\n                     },\n                     _ => false,\n@@ -198,7 +206,7 @@ fn expr_return_none_or_err(\n     match peel_blocks_with_stmt(expr).kind {\n         ExprKind::Ret(Some(ret_expr)) => expr_return_none_or_err(smbl, cx, ret_expr, cond_expr, err_sym),\n         ExprKind::Path(ref qpath) => match smbl {\n-            sym::Option => is_lang_ctor(cx, qpath, OptionNone),\n+            sym::Option => is_res_lang_ctor(cx, cx.qpath_res(qpath, expr.hir_id), OptionNone),\n             sym::Result => path_to_local(expr).is_some() && path_to_local(expr) == path_to_local(cond_expr),\n             _ => false,\n         },"}, {"sha": "760399231513f8a4b15668e35fb606f1745f313e", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -2,7 +2,7 @@ use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::sugg::Sugg;\n use clippy_utils::ty::is_type_diagnostic_item;\n use clippy_utils::{\n-    get_enclosing_block, is_expr_path_def_path, is_integer_literal, path_to_local, path_to_local_id, paths, SpanlessEq,\n+    get_enclosing_block, is_integer_literal, is_path_diagnostic_item, path_to_local, path_to_local_id, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n@@ -254,7 +254,7 @@ impl<'a, 'tcx> VectorInitializationVisitor<'a, 'tcx> {\n     fn is_repeat_zero(&self, expr: &Expr<'_>) -> bool {\n         if_chain! {\n             if let ExprKind::Call(fn_expr, [repeat_arg]) = expr.kind;\n-            if is_expr_path_def_path(self.cx, fn_expr, &paths::ITER_REPEAT);\n+            if is_path_diagnostic_item(self.cx, fn_expr, sym::iter_repeat);\n             if is_integer_literal(repeat_arg, 0);\n             then {\n                 true"}, {"sha": "016aacbf9da37c10de4e684b428429f4db34efa9", "filename": "clippy_lints/src/unnecessary_owned_empty_strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_owned_empty_strings.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -3,7 +3,7 @@ use clippy_utils::{match_def_path, paths};\n use if_chain::if_chain;\n use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n-use rustc_hir::{BorrowKind, Expr, ExprKind, Mutability};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, LangItem, Mutability};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryOwnedEmptyStrings {\n                         );\n                 } else {\n                     if_chain! {\n-                        if match_def_path(cx, fun_def_id, &paths::FROM_FROM);\n+                        if cx.tcx.lang_items().require(LangItem::FromFrom).ok() == Some(fun_def_id);\n                         if let [.., last_arg] = args;\n                         if let ExprKind::Lit(spanned) = &last_arg.kind;\n                         if let LitKind::Str(symbol, _) = spanned.node;"}, {"sha": "7211e6864f3a93b92692bb9ec524f34067814122", "filename": "clippy_lints/src/unnecessary_wraps.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Funnecessary_wraps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funnecessary_wraps.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,6 +1,6 @@\n use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::source::snippet;\n-use clippy_utils::{contains_return, is_lang_ctor, return_ty, visitors::find_all_ret_expressions};\n+use clippy_utils::{contains_return, is_res_lang_ctor, path_res, return_ty, visitors::find_all_ret_expressions};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n@@ -120,9 +120,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnecessaryWraps {\n                 if !ret_expr.span.from_expansion();\n                 // Check if a function call.\n                 if let ExprKind::Call(func, [arg]) = ret_expr.kind;\n-                // Check if OPTION_SOME or RESULT_OK, depending on return type.\n-                if let ExprKind::Path(qpath) = &func.kind;\n-                if is_lang_ctor(cx, qpath, lang_item);\n+                if is_res_lang_ctor(cx, path_res(cx, func), lang_item);\n                 // Make sure the function argument does not contain a return expression.\n                 if !contains_return(arg);\n                 then {"}, {"sha": "8bcdff66331d162c44d06971af7f9774f09698a3", "filename": "clippy_lints/src/unused_io_amount.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Funused_io_amount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Funused_io_amount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_io_amount.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -1,8 +1,9 @@\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help};\n-use clippy_utils::{is_try, match_trait_method, paths};\n+use clippy_utils::{is_trait_method, is_try, match_trait_method, paths};\n use rustc_hir as hir;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::sym;\n \n declare_clippy_lint! {\n     /// ### What it does\n@@ -116,13 +117,13 @@ fn check_method_call(cx: &LateContext<'_>, call: &hir::Expr<'_>, expr: &hir::Exp\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCREADEXT)\n                 || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCREADEXT)\n         } else {\n-            match_trait_method(cx, call, &paths::IO_READ)\n+            is_trait_method(cx, call, sym::IoRead)\n         };\n         let write_trait = if is_await {\n             match_trait_method(cx, call, &paths::FUTURES_IO_ASYNCWRITEEXT)\n                 || match_trait_method(cx, call, &paths::TOKIO_IO_ASYNCWRITEEXT)\n         } else {\n-            match_trait_method(cx, call, &paths::IO_WRITE)\n+            is_trait_method(cx, call, sym::IoWrite)\n         };\n \n         match (read_trait, write_trait, symbol, is_await) {"}, {"sha": "a82643a59f97bb11bc1c17c5ba62157073a5c753", "filename": "clippy_lints/src/useless_conversion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Fuseless_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuseless_conversion.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -5,7 +5,7 @@ use clippy_utils::ty::{is_type_diagnostic_item, same_type_and_consts};\n use clippy_utils::{get_parent_expr, is_trait_method, match_def_path, paths};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, HirId, MatchSource};\n+use rustc_hir::{Expr, ExprKind, HirId, LangItem, MatchSource};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -154,7 +154,7 @@ impl<'tcx> LateLintPass<'tcx> for UselessConversion {\n                         }\n \n                         if_chain! {\n-                            if match_def_path(cx, def_id, &paths::FROM_FROM);\n+                            if cx.tcx.lang_items().require(LangItem::FromFrom).ok() == Some(def_id);\n                             if same_type_and_consts(a, b);\n \n                             then {"}, {"sha": "6309a04c73d5de9d3230b78e772007716853c9f2", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 208, "deletions": 69, "changes": 277, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -2,11 +2,11 @@ use crate::utils::internal_lints::metadata_collector::is_deprecated_lint;\n use clippy_utils::consts::{constant_simple, Constant};\n use clippy_utils::diagnostics::{span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then};\n use clippy_utils::macros::root_macro_call_first_node;\n-use clippy_utils::source::snippet;\n+use clippy_utils::source::{snippet, snippet_with_applicability};\n use clippy_utils::ty::match_type;\n use clippy_utils::{\n-    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_def_path,\n-    method_calls, paths, peel_blocks_with_stmt, SpanlessEq,\n+    def_path_res, higher, is_else_clause, is_expn_of, is_expr_path_def_path, is_lint_allowed, match_any_def_paths,\n+    match_def_path, method_calls, paths, peel_blocks_with_stmt, peel_hir_expr_refs, SpanlessEq,\n };\n use if_chain::if_chain;\n use rustc_ast as ast;\n@@ -20,21 +20,24 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::hir_id::CRATE_HIR_ID;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{\n-    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind, Ty,\n+    BinOpKind, Block, Closure, Expr, ExprKind, HirId, Item, Local, MutTy, Mutability, Node, Path, Stmt, StmtKind,\n     TyKind, UnOp,\n };\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_lint::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::nested_filter;\n-use rustc_middle::mir::interpret::ConstValue;\n-use rustc_middle::ty::{self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, FloatTy};\n+use rustc_middle::mir::interpret::{Allocation, ConstValue, GlobalAlloc};\n+use rustc_middle::ty::{\n+    self, fast_reject::SimplifiedTypeGen, subst::GenericArgKind, AssocKind, DefIdTree, FloatTy, Ty,\n+};\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Spanned;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::{sym, BytePos, Span};\n \n use std::borrow::{Borrow, Cow};\n+use std::str;\n \n #[cfg(feature = \"internal\")]\n pub mod metadata_collector;\n@@ -226,11 +229,11 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for calls to `utils::match_type()` on a type diagnostic item\n-    /// and suggests to use `utils::is_type_diagnostic_item()` instead.\n+    /// Checks for usages of def paths when a diagnostic item or a `LangItem` could be used.\n     ///\n     /// ### Why is this bad?\n-    /// `utils::is_type_diagnostic_item()` does not require hardcoded paths.\n+    /// The path for an item is subject to change and is less efficient to look up than a\n+    /// diagnostic item or a `LangItem`.\n     ///\n     /// ### Example\n     /// ```rust,ignore\n@@ -241,9 +244,9 @@ declare_clippy_lint! {\n     /// ```rust,ignore\n     /// utils::is_type_diagnostic_item(cx, ty, sym::Vec)\n     /// ```\n-    pub MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+    pub UNNECESSARY_DEF_PATH,\n     internal,\n-    \"using `utils::match_type()` instead of `utils::is_type_diagnostic_item()`\"\n+    \"using a def path when a diagnostic item or a `LangItem` is available\"\n }\n \n declare_clippy_lint! {\n@@ -537,7 +540,7 @@ impl<'tcx> LateLintPass<'tcx> for LintWithoutLintPass {\n     }\n }\n \n-fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &Ty<'_>) -> bool {\n+fn is_lint_ref_type<'tcx>(cx: &LateContext<'tcx>, ty: &hir::Ty<'_>) -> bool {\n     if let TyKind::Rptr(\n         _,\n         MutTy {\n@@ -888,89 +891,225 @@ fn suggest_note(\n     );\n }\n \n-declare_lint_pass!(MatchTypeOnDiagItem => [MATCH_TYPE_ON_DIAGNOSTIC_ITEM]);\n+declare_lint_pass!(UnnecessaryDefPath => [UNNECESSARY_DEF_PATH]);\n \n-impl<'tcx> LateLintPass<'tcx> for MatchTypeOnDiagItem {\n+#[allow(clippy::too_many_lines)]\n+impl<'tcx> LateLintPass<'tcx> for UnnecessaryDefPath {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'_>) {\n-        if is_lint_allowed(cx, MATCH_TYPE_ON_DIAGNOSTIC_ITEM, expr.hir_id) {\n+        enum Item {\n+            LangItem(Symbol),\n+            DiagnosticItem(Symbol),\n+        }\n+        static PATHS: &[&[&str]] = &[\n+            &[\"clippy_utils\", \"match_def_path\"],\n+            &[\"clippy_utils\", \"match_trait_method\"],\n+            &[\"clippy_utils\", \"ty\", \"match_type\"],\n+            &[\"clippy_utils\", \"is_expr_path_def_path\"],\n+        ];\n+\n+        if is_lint_allowed(cx, UNNECESSARY_DEF_PATH, expr.hir_id) {\n             return;\n         }\n \n         if_chain! {\n-            // Check if this is a call to utils::match_type()\n-            if let ExprKind::Call(fn_path, [context, ty, ty_path]) = expr.kind;\n-            if is_expr_path_def_path(cx, fn_path, &[\"clippy_utils\", \"ty\", \"match_type\"]);\n+            if let ExprKind::Call(func, [cx_arg, def_arg, args@..]) = expr.kind;\n+            if let ExprKind::Path(path) = &func.kind;\n+            if let Some(id) = cx.qpath_res(path, func.hir_id).opt_def_id();\n+            if let Some(which_path) = match_any_def_paths(cx, id, PATHS);\n+            let item_arg = if which_path == 4 { &args[1] } else { &args[0] };\n             // Extract the path to the matched type\n-            if let Some(segments) = path_to_matched_type(cx, ty_path);\n-            let segments: Vec<&str> = segments.iter().map(Symbol::as_str).collect();\n-            if let Some(ty_did) = def_path_res(cx, &segments[..]).opt_def_id();\n-            // Check if the matched type is a diagnostic item\n-            if let Some(item_name) = cx.tcx.get_diagnostic_name(ty_did);\n+            if let Some(segments) = path_to_matched_type(cx, item_arg);\n+            let segments: Vec<&str> = segments.iter().map(|sym| &**sym).collect();\n+            if let Some(def_id) = def_path_res(cx, &segments[..]).opt_def_id();\n             then {\n-                // TODO: check paths constants from external crates.\n-                let cx_snippet = snippet(cx, context.span, \"_\");\n-                let ty_snippet = snippet(cx, ty.span, \"_\");\n+                // def_path_res will match field names before anything else, but for this we want to match\n+                // inherent functions first.\n+                let def_id = if cx.tcx.def_kind(def_id) == DefKind::Field {\n+                    let method_name = *segments.last().unwrap();\n+                    cx.tcx.def_key(def_id).parent\n+                        .and_then(|parent_idx|\n+                            cx.tcx.inherent_impls(DefId { index: parent_idx, krate: def_id.krate }).iter()\n+                                .find_map(|impl_id| cx.tcx.associated_items(*impl_id)\n+                                    .find_by_name_and_kind(\n+                                        cx.tcx,\n+                                        Ident::from_str(method_name),\n+                                        AssocKind::Fn,\n+                                        *impl_id,\n+                                    )\n+                                )\n+                        )\n+                        .map_or(def_id, |item| item.def_id)\n+                } else {\n+                    def_id\n+                };\n \n-                span_lint_and_sugg(\n+                // Check if the target item is a diagnostic item or LangItem.\n+                let (msg, item) = if let Some(item_name)\n+                    = cx.tcx.diagnostic_items(def_id.krate).id_to_name.get(&def_id)\n+                {\n+                    (\n+                        \"use of a def path to a diagnostic item\",\n+                        Item::DiagnosticItem(*item_name),\n+                    )\n+                } else if let Some(lang_item) = cx.tcx.lang_items().items().iter().position(|id| *id == Some(def_id)) {\n+                    let lang_items = def_path_res(cx, &[\"rustc_hir\", \"lang_items\", \"LangItem\"]).def_id();\n+                    let item_name = cx.tcx.adt_def(lang_items).variants().iter().nth(lang_item).unwrap().name;\n+                    (\n+                        \"use of a def path to a `LangItem`\",\n+                        Item::LangItem(item_name),\n+                    )\n+                } else {\n+                    return;\n+                };\n+\n+                let has_ctor = match cx.tcx.def_kind(def_id) {\n+                    DefKind::Struct => {\n+                        let variant = cx.tcx.adt_def(def_id).non_enum_variant();\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    }\n+                    DefKind::Variant => {\n+                        let variant = cx.tcx.adt_def(cx.tcx.parent(def_id)).variant_with_id(def_id);\n+                        variant.ctor_def_id.is_some() && variant.fields.iter().all(|f| f.vis.is_public())\n+                    }\n+                    _ => false,\n+                };\n+\n+                let mut app = Applicability::MachineApplicable;\n+                let cx_snip = snippet_with_applicability(cx, cx_arg.span, \"..\", &mut app);\n+                let def_snip = snippet_with_applicability(cx, def_arg.span, \"..\", &mut app);\n+                let (sugg, with_note) = match (which_path, item) {\n+                    // match_def_path\n+                    (0, Item::DiagnosticItem(item)) =>\n+                        (format!(\"{cx_snip}.tcx.is_diagnostic_item(sym::{item}, {def_snip})\"), has_ctor),\n+                    (0, Item::LangItem(item)) => (\n+                        format!(\"{cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some({def_snip})\"),\n+                        has_ctor\n+                    ),\n+                    // match_trait_method\n+                    (1, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_trait_method({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    // match_type\n+                    (2, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_type_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    (2, Item::LangItem(item)) =>\n+                        (format!(\"is_type_lang_item({cx_snip}, {def_snip}, LangItem::{item})\"), false),\n+                    // is_expr_path_def_path\n+                    (3, Item::DiagnosticItem(item)) if has_ctor => (\n+                        format!(\n+                            \"is_res_diag_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), sym::{item})\",\n+                        ),\n+                        false,\n+                    ),\n+                    (3, Item::LangItem(item)) if has_ctor => (\n+                        format!(\n+                            \"is_res_lang_ctor({cx_snip}, path_res({cx_snip}, {def_snip}), LangItem::{item})\",\n+                        ),\n+                        false,\n+                    ),\n+                    (3, Item::DiagnosticItem(item)) =>\n+                        (format!(\"is_path_diagnostic_item({cx_snip}, {def_snip}, sym::{item})\"), false),\n+                    (3, Item::LangItem(item)) => (\n+                        format!(\n+                            \"path_res({cx_snip}, {def_snip}).opt_def_id()\\\n+                                .map_or(false, |id| {cx_snip}.tcx.lang_items().require(LangItem::{item}).ok() == Some(id))\",\n+                        ),\n+                        false,\n+                    ),\n+                    _ => return,\n+                };\n+\n+                span_lint_and_then(\n                     cx,\n-                    MATCH_TYPE_ON_DIAGNOSTIC_ITEM,\n+                    UNNECESSARY_DEF_PATH,\n                     expr.span,\n-                    \"usage of `clippy_utils::ty::match_type()` on a type diagnostic item\",\n-                    \"try\",\n-                    format!(\"clippy_utils::ty::is_type_diagnostic_item({cx_snippet}, {ty_snippet}, sym::{item_name})\"),\n-                    Applicability::MaybeIncorrect,\n+                    msg,\n+                    |diag| {\n+                        diag.span_suggestion(expr.span, \"try\", sugg, app);\n+                        if with_note {\n+                            diag.help(\n+                                \"if this `DefId` came from a constructor expression or pattern then the \\\n+                                    parent `DefId` should be used instead\"\n+                            );\n+                        }\n+                    },\n                 );\n             }\n         }\n     }\n }\n \n-fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<Symbol>> {\n-    use rustc_hir::ItemKind;\n-\n-    match &expr.kind {\n-        ExprKind::AddrOf(.., expr) => return path_to_matched_type(cx, expr),\n-        ExprKind::Path(qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n+fn path_to_matched_type(cx: &LateContext<'_>, expr: &hir::Expr<'_>) -> Option<Vec<String>> {\n+    match peel_hir_expr_refs(expr).0.kind {\n+        ExprKind::Path(ref qpath) => match cx.qpath_res(qpath, expr.hir_id) {\n             Res::Local(hir_id) => {\n                 let parent_id = cx.tcx.hir().get_parent_node(hir_id);\n-                if let Some(Node::Local(local)) = cx.tcx.hir().find(parent_id) {\n-                    if let Some(init) = local.init {\n-                        return path_to_matched_type(cx, init);\n-                    }\n+                if let Some(Node::Local(Local { init: Some(init), .. })) = cx.tcx.hir().find(parent_id) {\n+                    path_to_matched_type(cx, init)\n+                } else {\n+                    None\n                 }\n             },\n-            Res::Def(DefKind::Const | DefKind::Static(..), def_id) => {\n-                if let Some(Node::Item(item)) = cx.tcx.hir().get_if_local(def_id) {\n-                    if let ItemKind::Const(.., body_id) | ItemKind::Static(.., body_id) = item.kind {\n-                        let body = cx.tcx.hir().body(body_id);\n-                        return path_to_matched_type(cx, body.value);\n-                    }\n-                }\n+            Res::Def(DefKind::Static(_), def_id) => read_mir_alloc_def_path(\n+                cx,\n+                cx.tcx.eval_static_initializer(def_id).ok()?.inner(),\n+                cx.tcx.type_of(def_id),\n+            ),\n+            Res::Def(DefKind::Const, def_id) => match cx.tcx.const_eval_poly(def_id).ok()? {\n+                ConstValue::ByRef { alloc, offset } if offset.bytes() == 0 => {\n+                    read_mir_alloc_def_path(cx, alloc.inner(), cx.tcx.type_of(def_id))\n+                },\n+                _ => None,\n             },\n-            _ => {},\n+            _ => None,\n         },\n-        ExprKind::Array(exprs) => {\n-            let segments: Vec<Symbol> = exprs\n-                .iter()\n-                .filter_map(|expr| {\n-                    if let ExprKind::Lit(lit) = &expr.kind {\n-                        if let LitKind::Str(sym, _) = lit.node {\n-                            return Some(sym);\n-                        }\n+        ExprKind::Array(exprs) => exprs\n+            .iter()\n+            .map(|expr| {\n+                if let ExprKind::Lit(lit) = &expr.kind {\n+                    if let LitKind::Str(sym, _) = lit.node {\n+                        return Some((*sym.as_str()).to_owned());\n                     }\n+                }\n \n-                    None\n-                })\n-                .collect();\n-\n-            if segments.len() == exprs.len() {\n-                return Some(segments);\n-            }\n-        },\n-        _ => {},\n+                None\n+            })\n+            .collect(),\n+        _ => None,\n     }\n+}\n \n-    None\n+fn read_mir_alloc_def_path<'tcx>(cx: &LateContext<'tcx>, alloc: &'tcx Allocation, ty: Ty<'_>) -> Option<Vec<String>> {\n+    let (alloc, ty) = if let ty::Ref(_, ty, Mutability::Not) = *ty.kind() {\n+        let &alloc = alloc.provenance().values().next()?;\n+        if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+            (alloc.inner(), ty)\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        (alloc, ty)\n+    };\n+\n+    if let ty::Array(ty, _) | ty::Slice(ty) = *ty.kind()\n+        && let ty::Ref(_, ty, Mutability::Not) = *ty.kind()\n+        && ty.is_str()\n+    {\n+        alloc\n+            .provenance()\n+            .values()\n+            .map(|&alloc| {\n+                if let GlobalAlloc::Memory(alloc) = cx.tcx.global_alloc(alloc) {\n+                    let alloc = alloc.inner();\n+                    str::from_utf8(alloc.inspect_with_uninit_and_ptr_outside_interpreter(0..alloc.len()))\n+                        .ok().map(ToOwned::to_owned)\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect()\n+    } else {\n+        None\n+    }\n }\n \n // This is not a complete resolver for paths. It works on all the paths currently used in the paths"}, {"sha": "8f67fa109fc70f27090a37e6a0960cc905c2f79c", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 65, "deletions": 8, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -238,19 +238,69 @@ pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n     }\n }\n \n-/// Checks if a `QPath` resolves to a constructor of a `LangItem`.\n+/// Checks if a `Res` refers to a constructor of a `LangItem`\n /// For example, use this to check whether a function call or a pattern is `Some(..)`.\n-pub fn is_lang_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, lang_item: LangItem) -> bool {\n+pub fn is_res_lang_ctor(cx: &LateContext<'_>, res: Res, lang_item: LangItem) -> bool {\n+    if let Res::Def(DefKind::Ctor(..), id) = res\n+        && let Ok(lang_id) = cx.tcx.lang_items().require(lang_item)\n+        && let Some(id) = cx.tcx.opt_parent(id)\n+    {\n+        id == lang_id\n+    } else {\n+        false\n+    }\n+}\n+\n+pub fn is_res_diagnostic_ctor(cx: &LateContext<'_>, res: Res, diag_item: Symbol) -> bool {\n+    if let Res::Def(DefKind::Ctor(..), id) = res\n+        && let Some(id) = cx.tcx.opt_parent(id)\n+    {\n+        cx.tcx.is_diagnostic_item(diag_item, id)\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Checks if a `QPath` resolves to a constructor of a diagnostic item.\n+pub fn is_diagnostic_ctor(cx: &LateContext<'_>, qpath: &QPath<'_>, diagnostic_item: Symbol) -> bool {\n     if let QPath::Resolved(_, path) = qpath {\n         if let Res::Def(DefKind::Ctor(..), ctor_id) = path.res {\n-            if let Ok(item_id) = cx.tcx.lang_items().require(lang_item) {\n-                return cx.tcx.parent(ctor_id) == item_id;\n-            }\n+            return cx.tcx.is_diagnostic_item(diagnostic_item, cx.tcx.parent(ctor_id));\n         }\n     }\n     false\n }\n \n+/// Checks if the `DefId` matches the given diagnostic item or it's constructor.\n+pub fn is_diagnostic_item_or_ctor(cx: &LateContext<'_>, did: DefId, item: Symbol) -> bool {\n+    let did = match cx.tcx.def_kind(did) {\n+        DefKind::Ctor(..) => cx.tcx.parent(did),\n+        // Constructors for types in external crates seem to have `DefKind::Variant`\n+        DefKind::Variant => match cx.tcx.opt_parent(did) {\n+            Some(did) if matches!(cx.tcx.def_kind(did), DefKind::Variant) => did,\n+            _ => did,\n+        },\n+        _ => did,\n+    };\n+\n+    cx.tcx.is_diagnostic_item(item, did)\n+}\n+\n+/// Checks if the `DefId` matches the given `LangItem` or it's constructor.\n+pub fn is_lang_item_or_ctor(cx: &LateContext<'_>, did: DefId, item: LangItem) -> bool {\n+    let did = match cx.tcx.def_kind(did) {\n+        DefKind::Ctor(..) => cx.tcx.parent(did),\n+        // Constructors for types in external crates seem to have `DefKind::Variant`\n+        DefKind::Variant => match cx.tcx.opt_parent(did) {\n+            Some(did) if matches!(cx.tcx.def_kind(did), DefKind::Variant) => did,\n+            _ => did,\n+        },\n+        _ => did,\n+    };\n+\n+    cx.tcx.lang_items().require(item).map_or(false, |id| id == did)\n+}\n+\n pub fn is_unit_expr(expr: &Expr<'_>) -> bool {\n     matches!(\n         expr.kind,\n@@ -486,6 +536,13 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n                 .copied()\n                 .find(|assoc_def_id| tcx.item_name(*assoc_def_id).as_str() == name)\n                 .map(|assoc_def_id| Res::Def(tcx.def_kind(assoc_def_id), assoc_def_id)),\n+            DefKind::Struct | DefKind::Union => tcx\n+                .adt_def(def_id)\n+                .non_enum_variant()\n+                .fields\n+                .iter()\n+                .find(|f| f.name.as_str() == name)\n+                .map(|f| Res::Def(DefKind::Field, f.did)),\n             _ => None,\n         }\n     }\n@@ -738,7 +795,7 @@ pub fn is_default_equivalent(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n             }\n         },\n         ExprKind::Call(repl_func, _) => is_default_equivalent_call(cx, repl_func),\n-        ExprKind::Path(qpath) => is_lang_ctor(cx, qpath, OptionNone),\n+        ExprKind::Path(qpath) => is_res_lang_ctor(cx, cx.qpath_res(qpath, e.hir_id), OptionNone),\n         ExprKind::AddrOf(rustc_hir::BorrowKind::Ref, _, expr) => matches!(expr.kind, ExprKind::Array([])),\n         _ => false,\n     }\n@@ -1553,7 +1610,7 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n         if_chain! {\n             if let PatKind::TupleStruct(ref path, pat, ddpos) = arm.pat.kind;\n             if ddpos.as_opt_usize().is_none();\n-            if is_lang_ctor(cx, path, ResultOk);\n+            if is_res_lang_ctor(cx, cx.qpath_res(path, arm.pat.hir_id), ResultOk);\n             if let PatKind::Binding(_, hir_id, _, None) = pat[0].kind;\n             if path_to_local_id(arm.body, hir_id);\n             then {\n@@ -1565,7 +1622,7 @@ pub fn is_try<'tcx>(cx: &LateContext<'_>, expr: &'tcx Expr<'tcx>) -> Option<&'tc\n \n     fn is_err(cx: &LateContext<'_>, arm: &Arm<'_>) -> bool {\n         if let PatKind::TupleStruct(ref path, _, _) = arm.pat.kind {\n-            is_lang_ctor(cx, path, ResultErr)\n+            is_res_lang_ctor(cx, cx.qpath_res(path, arm.pat.hir_id), ResultErr)\n         } else {\n             false\n         }"}, {"sha": "13938645fc3e500047b8dc5c0f384d823f0d8737", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -34,7 +34,6 @@ pub const DEFAULT_TRAIT_METHOD: [&str; 4] = [\"core\", \"default\", \"Default\", \"defa\n pub const DEREF_MUT_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"DerefMut\", \"deref_mut\"];\n /// Preferably use the diagnostic item `sym::deref_method` where possible\n pub const DEREF_TRAIT_METHOD: [&str; 5] = [\"core\", \"ops\", \"deref\", \"Deref\", \"deref\"];\n-pub const DIR_BUILDER: [&str; 3] = [\"std\", \"fs\", \"DirBuilder\"];\n pub const DISPLAY_TRAIT: [&str; 3] = [\"core\", \"fmt\", \"Display\"];\n #[cfg(feature = \"internal\")]\n pub const EARLY_CONTEXT: [&str; 2] = [\"rustc_lint\", \"EarlyContext\"];\n@@ -64,8 +63,6 @@ pub const IDENT_AS_STR: [&str; 4] = [\"rustc_span\", \"symbol\", \"Ident\", \"as_str\"];\n pub const INDEX: [&str; 3] = [\"core\", \"ops\", \"Index\"];\n pub const INDEX_MUT: [&str; 3] = [\"core\", \"ops\", \"IndexMut\"];\n pub const INSERT_STR: [&str; 4] = [\"alloc\", \"string\", \"String\", \"insert_str\"];\n-pub const IO_READ: [&str; 3] = [\"std\", \"io\", \"Read\"];\n-pub const IO_WRITE: [&str; 3] = [\"std\", \"io\", \"Write\"];\n pub const ITER_COUNT: [&str; 6] = [\"core\", \"iter\", \"traits\", \"iterator\", \"Iterator\", \"count\"];\n pub const ITER_EMPTY: [&str; 5] = [\"core\", \"iter\", \"sources\", \"empty\", \"Empty\"];\n pub const ITER_REPEAT: [&str; 5] = [\"core\", \"iter\", \"sources\", \"repeat\", \"repeat\"];"}, {"sha": "52fcaec4df32e2e92d3ffbaf5d756d1e5640f112", "filename": "tests/ui-internal/auxiliary/paths.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/tests%2Fui-internal%2Fauxiliary%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/tests%2Fui-internal%2Fauxiliary%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fauxiliary%2Fpaths.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -0,0 +1,2 @@\n+pub static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];"}, {"sha": "4b41ff15e80f904c907cb5ce02732c5eb34da2a1", "filename": "tests/ui-internal/match_type_on_diag_item.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0341198ba1980468ae190208a546a40a0634f06c/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0341198ba1980468ae190208a546a40a0634f06c/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.rs?ref=0341198ba1980468ae190208a546a40a0634f06c", "patch": "@@ -1,39 +0,0 @@\n-#![deny(clippy::internal)]\n-#![allow(clippy::missing_clippy_version_attribute)]\n-#![feature(rustc_private)]\n-\n-extern crate clippy_utils;\n-extern crate rustc_hir;\n-extern crate rustc_lint;\n-extern crate rustc_middle;\n-\n-#[macro_use]\n-extern crate rustc_session;\n-use clippy_utils::{paths, ty::match_type};\n-use rustc_hir::Expr;\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty::Ty;\n-\n-declare_lint! {\n-    pub TEST_LINT,\n-    Warn,\n-    \"\"\n-}\n-\n-declare_lint_pass!(Pass => [TEST_LINT]);\n-\n-static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n-\n-impl<'tcx> LateLintPass<'tcx> for Pass {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr) {\n-        let ty = cx.typeck_results().expr_ty(expr);\n-\n-        let _ = match_type(cx, ty, &OPTION);\n-        let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n-\n-        let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n-        let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n-    }\n-}\n-\n-fn main() {}"}, {"sha": "e3cb6b6c22eada7f40fb0edeb61261104385a7a0", "filename": "tests/ui-internal/match_type_on_diag_item.stderr", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0341198ba1980468ae190208a546a40a0634f06c/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0341198ba1980468ae190208a546a40a0634f06c/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Fmatch_type_on_diag_item.stderr?ref=0341198ba1980468ae190208a546a40a0634f06c", "patch": "@@ -1,27 +0,0 @@\n-error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:31:17\n-   |\n-LL |         let _ = match_type(cx, ty, &OPTION);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Option)`\n-   |\n-note: the lint level is defined here\n-  --> $DIR/match_type_on_diag_item.rs:1:9\n-   |\n-LL | #![deny(clippy::internal)]\n-   |         ^^^^^^^^^^^^^^^^\n-   = note: `#[deny(clippy::match_type_on_diagnostic_item)]` implied by `#[deny(clippy::internal)]`\n-\n-error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:32:17\n-   |\n-LL |         let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Result)`\n-\n-error: usage of `clippy_utils::ty::match_type()` on a type diagnostic item\n-  --> $DIR/match_type_on_diag_item.rs:35:17\n-   |\n-LL |         let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n-   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `clippy_utils::ty::is_type_diagnostic_item(cx, ty, sym::Rc)`\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "4c050332f2cc938ce497ecb9c55b3738b0d186c1", "filename": "tests/ui-internal/unnecessary_def_path.fixed", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/tests%2Fui-internal%2Funnecessary_def_path.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/tests%2Fui-internal%2Funnecessary_def_path.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.fixed?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -0,0 +1,62 @@\n+// run-rustfix\n+// aux-build:paths.rs\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate clippy_utils;\n+extern crate paths;\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+extern crate rustc_span;\n+\n+#[allow(unused)]\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n+#[allow(unused)]\n+use clippy_utils::{\n+    is_expr_path_def_path, is_path_diagnostic_item, is_res_diagnostic_ctor, is_res_lang_ctor, is_trait_method,\n+    match_def_path, match_trait_method, path_res,\n+};\n+\n+#[allow(unused)]\n+use rustc_hir::LangItem;\n+#[allow(unused)]\n+use rustc_span::sym;\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+#[allow(unused)]\n+static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+#[allow(unused)]\n+const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n+\n+fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Option);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n+\n+    #[allow(unused)]\n+    let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Rc);\n+\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Option);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::Result);\n+\n+    let _ = is_type_lang_item(cx, ty, LangItem::OwnedBox);\n+    let _ = is_type_diagnostic_item(cx, ty, sym::maybe_uninit_uninit);\n+\n+    let _ = cx.tcx.lang_items().require(LangItem::OwnedBox).ok() == Some(did);\n+    let _ = cx.tcx.is_diagnostic_item(sym::Option, did);\n+    let _ = cx.tcx.lang_items().require(LangItem::OptionSome).ok() == Some(did);\n+\n+    let _ = is_trait_method(cx, expr, sym::AsRef);\n+\n+    let _ = is_path_diagnostic_item(cx, expr, sym::Option);\n+    let _ = path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().require(LangItem::IteratorNext).ok() == Some(id));\n+    let _ = is_res_lang_ctor(cx, path_res(cx, expr), LangItem::OptionSome);\n+}\n+\n+fn main() {}"}, {"sha": "6506f1f164ac6b47d82f66485284af19042292b9", "filename": "tests/ui-internal/unnecessary_def_path.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/tests%2Fui-internal%2Funnecessary_def_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/tests%2Fui-internal%2Funnecessary_def_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.rs?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -0,0 +1,62 @@\n+// run-rustfix\n+// aux-build:paths.rs\n+#![deny(clippy::internal)]\n+#![feature(rustc_private)]\n+\n+extern crate clippy_utils;\n+extern crate paths;\n+extern crate rustc_hir;\n+extern crate rustc_lint;\n+extern crate rustc_middle;\n+extern crate rustc_span;\n+\n+#[allow(unused)]\n+use clippy_utils::ty::{is_type_diagnostic_item, is_type_lang_item, match_type};\n+#[allow(unused)]\n+use clippy_utils::{\n+    is_expr_path_def_path, is_path_diagnostic_item, is_res_diagnostic_ctor, is_res_lang_ctor, is_trait_method,\n+    match_def_path, match_trait_method, path_res,\n+};\n+\n+#[allow(unused)]\n+use rustc_hir::LangItem;\n+#[allow(unused)]\n+use rustc_span::sym;\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::Expr;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty::Ty;\n+\n+#[allow(unused)]\n+static OPTION: [&str; 3] = [\"core\", \"option\", \"Option\"];\n+#[allow(unused)]\n+const RESULT: &[&str] = &[\"core\", \"result\", \"Result\"];\n+\n+fn _f<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, did: DefId, expr: &Expr<'_>) {\n+    let _ = match_type(cx, ty, &OPTION);\n+    let _ = match_type(cx, ty, RESULT);\n+    let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+\n+    #[allow(unused)]\n+    let rc_path = &[\"alloc\", \"rc\", \"Rc\"];\n+    let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n+\n+    let _ = match_type(cx, ty, &paths::OPTION);\n+    let _ = match_type(cx, ty, paths::RESULT);\n+\n+    let _ = match_type(cx, ty, &[\"alloc\", \"boxed\", \"Box\"]);\n+    let _ = match_type(cx, ty, &[\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"]);\n+\n+    let _ = match_def_path(cx, did, &[\"alloc\", \"boxed\", \"Box\"]);\n+    let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\"]);\n+    let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+\n+    let _ = match_trait_method(cx, expr, &[\"core\", \"convert\", \"AsRef\"]);\n+\n+    let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\"]);\n+    let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"iter\", \"traits\", \"Iterator\", \"next\"]);\n+    let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+}\n+\n+fn main() {}"}, {"sha": "a99a8f71fa6a73aac3b1713ec2f7cb2ea1dcb9cb", "filename": "tests/ui-internal/unnecessary_def_path.stderr", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/bef93d3b1464b6d467482d47a53c62aadaa9f41c/tests%2Fui-internal%2Funnecessary_def_path.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bef93d3b1464b6d467482d47a53c62aadaa9f41c/tests%2Fui-internal%2Funnecessary_def_path.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-internal%2Funnecessary_def_path.stderr?ref=bef93d3b1464b6d467482d47a53c62aadaa9f41c", "patch": "@@ -0,0 +1,101 @@\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:37:13\n+   |\n+LL |     let _ = match_type(cx, ty, &OPTION);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Option)`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unnecessary_def_path.rs:3:9\n+   |\n+LL | #![deny(clippy::internal)]\n+   |         ^^^^^^^^^^^^^^^^\n+   = note: `#[deny(clippy::unnecessary_def_path)]` implied by `#[deny(clippy::internal)]`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:38:13\n+   |\n+LL |     let _ = match_type(cx, ty, RESULT);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Result)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:39:13\n+   |\n+LL |     let _ = match_type(cx, ty, &[\"core\", \"result\", \"Result\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Result)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:43:13\n+   |\n+LL |     let _ = clippy_utils::ty::match_type(cx, ty, rc_path);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Rc)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:45:13\n+   |\n+LL |     let _ = match_type(cx, ty, &paths::OPTION);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Option)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:46:13\n+   |\n+LL |     let _ = match_type(cx, ty, paths::RESULT);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::Result)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:48:13\n+   |\n+LL |     let _ = match_type(cx, ty, &[\"alloc\", \"boxed\", \"Box\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_lang_item(cx, ty, LangItem::OwnedBox)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:49:13\n+   |\n+LL |     let _ = match_type(cx, ty, &[\"core\", \"mem\", \"maybe_uninit\", \"MaybeUninit\", \"uninit\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_type_diagnostic_item(cx, ty, sym::maybe_uninit_uninit)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:51:13\n+   |\n+LL |     let _ = match_def_path(cx, did, &[\"alloc\", \"boxed\", \"Box\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().require(LangItem::OwnedBox).ok() == Some(did)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:52:13\n+   |\n+LL |     let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.is_diagnostic_item(sym::Option, did)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:53:13\n+   |\n+LL |     let _ = match_def_path(cx, did, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `cx.tcx.lang_items().require(LangItem::OptionSome).ok() == Some(did)`\n+   |\n+   = help: if this `DefId` came from a constructor expression or pattern then the parent `DefId` should be used instead\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:55:13\n+   |\n+LL |     let _ = match_trait_method(cx, expr, &[\"core\", \"convert\", \"AsRef\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_trait_method(cx, expr, sym::AsRef)`\n+\n+error: use of a def path to a diagnostic item\n+  --> $DIR/unnecessary_def_path.rs:57:13\n+   |\n+LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_path_diagnostic_item(cx, expr, sym::Option)`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:58:13\n+   |\n+LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"iter\", \"traits\", \"Iterator\", \"next\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `path_res(cx, expr).opt_def_id().map_or(false, |id| cx.tcx.lang_items().require(LangItem::IteratorNext).ok() == Some(id))`\n+\n+error: use of a def path to a `LangItem`\n+  --> $DIR/unnecessary_def_path.rs:59:13\n+   |\n+LL |     let _ = is_expr_path_def_path(cx, expr, &[\"core\", \"option\", \"Option\", \"Some\"]);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `is_res_lang_ctor(cx, path_res(cx, expr), LangItem::OptionSome)`\n+\n+error: aborting due to 15 previous errors\n+"}]}