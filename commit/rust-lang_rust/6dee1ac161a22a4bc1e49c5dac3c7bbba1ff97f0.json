{"sha": "6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkZWUxYWMxNjFhMjJhNGJjMWU0OWM1ZGFjM2M3YmJiYTFmZjk3ZjA=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-03-18T19:32:54Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-03-18T19:32:54Z"}, "message": "Merge branch 'master' of git://github.com/graydon/rust", "tree": {"sha": "f423d576e977e7a258f09e50e5a51702525782e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f423d576e977e7a258f09e50e5a51702525782e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "html_url": "https://github.com/rust-lang/rust/commit/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "830f2d02f19b45ff4b4a4d7946b69f206b5dcdff", "url": "https://api.github.com/repos/rust-lang/rust/commits/830f2d02f19b45ff4b4a4d7946b69f206b5dcdff", "html_url": "https://github.com/rust-lang/rust/commit/830f2d02f19b45ff4b4a4d7946b69f206b5dcdff"}, {"sha": "6f65ce5255ac16204490bdd7dcf99acd24876bc6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f65ce5255ac16204490bdd7dcf99acd24876bc6", "html_url": "https://github.com/rust-lang/rust/commit/6f65ce5255ac16204490bdd7dcf99acd24876bc6"}], "stats": {"total": 2558, "additions": 1835, "deletions": 723}, "files": [{"sha": "1869476165bf1c8c7e92fe87ee2448578817eb03", "filename": "Makefile.in", "status": "added", "additions": 402, "deletions": 0, "changes": 402, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -0,0 +1,402 @@\n+######################################################################\n+# Residual auto-configuration\n+######################################################################\n+\n+include config.mk\n+MKFILES := Makefile config.mk\n+\n+ifneq ($(MAKE_RESTARTS),)\n+CFG_INFO := $(info cfg: make restarts: $(MAKE_RESTARTS))\n+endif\n+\n+CFG_INFO := $(info cfg: building on $(CFG_OSTYPE) $(CFG_CPUTYPE))\n+\n+CFG_GCC_CFLAGS :=\n+CFG_GCC_LINK_FLAGS :=\n+CFG_BOOT_FLAGS := $(BOOT_FLAGS)\n+CFG_RUSTC_FLAGS := -nowarn\n+\n+# On Darwin, we need to run dsymutil so the debugging information ends\n+# up in the right place.  On other platforms, it automatically gets\n+# embedded into the executable, so use a no-op command.\n+CFG_DSYMUTIL := true\n+\n+ifeq ($(CFG_OSTYPE), FreeBSD)\n+  LIB := lib$(1).so\n+  CFG_GCC_CFLAGS += -fPIC -march=i686 -I/usr/local/include\n+  CFG_GCC_LINK_FLAGS += -shared -fPIC -lpthread -lrt\n+  ifeq ($(CFG_CPUTYPE), x86_64)\n+    CFG_GCC_CFLAGS += -m32\n+    CFG_GCC_LINK_FLAGS += -m32\n+  endif\n+  CFG_UNIXY := 1\n+endif\n+\n+ifeq ($(CFG_OSTYPE), Linux)\n+  LIB := lib$(1).so\n+  CFG_GCC_CFLAGS += -fPIC -march=i686\n+  CFG_GCC_LINK_FLAGS += -shared -fPIC -ldl -lpthread -lrt\n+  ifeq ($(CFG_CPUTYPE), x86_64)\n+    CFG_GCC_CFLAGS += -m32\n+    CFG_GCC_LINK_FLAGS += -m32\n+  endif\n+  CFG_UNIXY := 1\n+endif\n+\n+ifeq ($(CFG_OSTYPE), Darwin)\n+  LIB := lib$(1).dylib\n+  CFG_UNIXY := 1\n+  CFG_GCC_LINK_FLAGS += -dynamiclib -lpthread\n+  # Darwin has a very blurry notion of \"64 bit\", and claims it's running\n+  # \"on an i386\" when the whole userspace is 64-bit and the compiler\n+  # emits 64-bit binaries by default. So we just force -m32 here. Smarter\n+  # approaches welcome!\n+  CFG_GCC_CFLAGS += -m32\n+  CFG_GCC_LINK_FLAGS += -m32\n+  CFG_DSYMUTIL := dsymutil\n+endif\n+\n+ifneq ($(findstring MINGW,$(CFG_OSTYPE)),)\n+  CFG_WINDOWSY := 1\n+endif\n+\n+ifdef CFG_WINDOWSY\n+  CFG_INFO := $(info cfg: windows-y environment)\n+\n+  CFG_EXE_SUFFIX := .exe\n+  CFG_LIB_NAME=$(1).dll\n+  CFG_RUN_PROGRAM=$(1)\n+\n+  CFG_PATH_MUNGE := | sed -e 's/\\\\\\(.\\)/\\/\\1/g'\n+  ifdef CFG_FLEXLINK\n+    CFG_BOOT_NATIVE := 1\n+  endif\n+  CFG_GCC_CFLAGS += -march=i686\n+  CFG_GCC_LINK_FLAGS += -shared -fPIC\n+endif\n+\n+ifdef CFG_UNIXY\n+  CFG_INFO := $(info cfg: unix-y environment)\n+\n+  CFG_EXE_SUFFIX :=\n+  CFG_RUN_PROGRAM = LD_LIBRARY_PATH=$(dir $(1)) $(CFG_VALGRIND) $(1)\n+\n+  CFG_BOOT_NATIVE := 1\n+\n+  ifdef MINGW_CROSS\n+    CFG_EXE_SUFFIX := .exe\n+    CFG_LIB_NAME=$(1).dll\n+    CFG_RUN_PROGRAM=$(1)\n+\n+    CFG_INFO := $(info cfg: mingw-cross)\n+    CFG_GCC_CROSS := i586-mingw32msvc-\n+    CFG_BOOT_FLAGS += -t win32-x86-pe\n+    ifdef CFG_VALGRIND\n+      CFG_VALGRIND += wine\n+    endif\n+    CFG_GCC_CFLAGS := -march=i686\n+    CFG_GCC_LINK_FLAGS := -shared\n+    ifeq ($(CFG_CPUTYPE), x86_64)\n+      CFG_GCC_CFLAGS += -m32\n+      CFG_GCC_LINK_FLAGS += -m32\n+    endif\n+  endif\n+  ifdef CFG_VALGRIND\n+    CFG_VALGRIND += --leak-check=full \\\n+                    --error-exitcode=1 \\\n+                    --quiet --vex-iropt-level=0 \\\n+                    --suppressions=etc/x86.supp\n+  endif\n+endif\n+\n+CFG_RUNTIME :=$(call CFG_LIB_NAME,rustrt)\n+CFG_LLVMEXT :=$(call CFG_LIB_NAME,llvmext)\n+CFG_STDLIB :=$(call CFG_LIB_NAME,std)\n+\n+ifdef CFG_GCC\n+  CFG_INFO := $(info cfg: using gcc)\n+  CFG_GCC_CFLAGS += -Wall -Werror -fno-rtti -fno-exceptions -g\n+  CFG_GCC_LINK_FLAGS += -g\n+  CFG_COMPILE_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_CFLAGS) -c -o $(1) $(2)\n+  CFG_LINK_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_LINK_FLAGS) -o $(1)\n+  CFG_DEPEND_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_CFLAGS) -MT \"$(1)\" -MM $(2)\n+else\n+  CFG_ERR := $(error please try on a system with gcc)\n+endif\n+\n+ifdef CFG_OCAMLC_OPT\n+  $(info cfg: have ocaml native compiler)\n+  OPT=.opt\n+else\n+  $(info cfg: have only ocaml bytecode compiler)\n+endif\n+\n+ifdef BOOT_PROFILE\n+  $(info cfg: forcing native bootstrap compiler (BOOT_PROFILE))\n+  CFG_BOOT_NATIVE := 1\n+  CFG_OCAMLOPT_PROFILE_FLAGS := -p\n+endif\n+\n+ifdef BOOT_DEBUG\n+  $(info cfg: forcing bytecode bootstrap compiler (DEBUG))\n+  CFG_BOOT_NATIVE :=\n+endif\n+\n+ifdef CFG_BOOT_NATIVE\n+  $(info cfg: building native bootstrap compiler)\n+else\n+  $(info cfg: building bytecode bootstrap compiler)\n+endif\n+\n+ifdef NO_VALGRIND\n+  $(info cfg: disabling valgrind (NO_VALGRIND))\n+  CFG_VALGRIND :=\n+endif\n+\n+######################################################################\n+# Target-and-rule \"utility variables\"\n+######################################################################\n+\n+ifdef VERBOSE\n+  Q :=\n+  E =\n+else\n+  Q := @\n+  E = echo $(1)\n+endif\n+\n+R := $(CFG_RUN_PROGRAM)\n+S := $(CFG_SRC_DIR)\n+X := $(CFG_EXE_SUFFIX)\n+\n+# Look in doc and src dirs.\n+VPATH := $(S)doc $(S)src\n+\n+# Compilers we build, we now know how to run.\n+BOOT := $(Q)OCAMLRUNPARAM=\"b1\" boot/rustboot$(X) $(CFG_BOOT_FLAGS)\n+STAGE0 := $(Q)stage0/rustc$(X) $(CFG_RUSTC_FLAGS)\n+STAGE1 := $(Q)stage1/rustc$(X) $(CFG_RUSTC_FLAGS)\n+STAGE2 := $(Q)stage2/rustc$(X) $(CFG_RUSTC_FLAGS)\n+\n+# \"Source\" files we generate in builddir along the way.\n+GENERATED := boot/fe/lexer.ml boot/version.ml\n+\n+# Delete the built-in rules.\n+.SUFFIXES:\n+%:: %,v\n+%:: RCS/%,v\n+%:: RCS/%\n+%:: s.%\n+%:: SCCS/s.%\n+\n+######################################################################\n+# Bootstrap compiler variables\n+######################################################################\n+\n+# We must list them in link order.\n+# Nobody calculates the link-order DAG automatically, sadly.\n+\n+BOOT_MLS :=                                              \\\n+    $(addsuffix .ml,                                     \\\n+        boot/version                                     \\\n+        $(addprefix boot/util/, fmt common bits)         \\\n+        $(addprefix boot/driver/, session)               \\\n+        $(addprefix boot/fe/, ast token lexer parser     \\\n+          extfmt pexp item cexp fuzz)                    \\\n+        $(addprefix boot/be/, asm il abi)                \\\n+        $(addprefix boot/me/, walk semant resolve alias  \\\n+          simplify type dead layer effect typestate      \\\n+         loop layout transutil trans dwarf)              \\\n+        $(addprefix boot/be/, x86 ra pe elf macho)       \\\n+        $(addprefix boot/driver/, lib glue main))        \\\n+\n+BOOT_CMOS := $(BOOT_MLS:.ml=.cmo)\n+BOOT_CMXS := $(BOOT_MLS:.ml=.cmx)\n+BOOT_OBJS := $(BOOT_MLS:.ml=.o)\n+BOOT_CMIS := $(BOOT_MLS:.ml=.cmi)\n+\n+BS := $(S)/src/boot/\n+\n+BOOT_ML_DEP_INCS := -I $(BS)/fe   -I $(BS)/me      \\\n+                    -I $(BS)/be   -I $(BS)/driver  \\\n+                    -I $(BS)/util -I boot\n+\n+BOOT_ML_INCS    :=  -I boot/fe   -I boot/me      \\\n+                    -I boot/be   -I boot/driver  \\\n+                    -I boot/util -I boot\n+\n+BOOT_ML_LIBS        := unix.cma  nums.cma  bigarray.cma\n+BOOT_ML_NATIVE_LIBS := unix.cmxa nums.cmxa bigarray.cmxa\n+BOOT_OCAMLC_FLAGS   := -g $(BOOT_ML_INCS) -w Ael -warn-error Ael\n+BOOT_OCAMLOPT_FLAGS := -g $(BOOT_ML_INCS) -w Ael -warn-error Ael\n+\n+######################################################################\n+# Runtime (C++) library variables\n+######################################################################\n+\n+RUNTIME_CS := rt/sync/timer.cpp \\\n+              rt/sync/sync.cpp \\\n+              rt/sync/lock_and_signal.cpp \\\n+              rt/rust.cpp \\\n+              rt/rust_builtin.cpp \\\n+              rt/rust_run_program.cpp \\\n+              rt/rust_crate.cpp \\\n+              rt/rust_crate_cache.cpp \\\n+              rt/rust_crate_reader.cpp \\\n+              rt/rust_comm.cpp \\\n+              rt/rust_dom.cpp \\\n+              rt/rust_task.cpp \\\n+              rt/rust_task_list.cpp \\\n+              rt/rust_proxy.cpp \\\n+              rt/rust_chan.cpp \\\n+              rt/rust_port.cpp \\\n+              rt/rust_upcall.cpp \\\n+              rt/rust_log.cpp \\\n+              rt/rust_message.cpp \\\n+              rt/rust_timer.cpp \\\n+              rt/circular_buffer.cpp \\\n+              rt/isaac/randport.cpp \\\n+              rt/rust_srv.cpp \\\n+              rt/rust_kernel.cpp \\\n+              rt/memory_region.cpp \\\n+              rt/test/rust_test_harness.cpp \\\n+              rt/test/rust_test_runtime.cpp \\\n+              rt/test/rust_test_util.cpp\n+\n+RUNTIME_HDR := rt/globals.h \\\n+               rt/rust.h \\\n+               rt/rust_dwarf.h \\\n+               rt/rust_internal.h \\\n+               rt/rust_util.h \\\n+               rt/rust_chan.h \\\n+               rt/rust_port.h \\\n+               rt/rust_dom.h \\\n+               rt/rust_task.h \\\n+               rt/rust_task_list.h \\\n+               rt/rust_proxy.h \\\n+               rt/rust_log.h \\\n+               rt/rust_message.h \\\n+               rt/circular_buffer.h \\\n+               rt/util/array_list.h \\\n+               rt/util/indexed_list.h \\\n+               rt/util/synchronized_indexed_list.h \\\n+               rt/util/hash_map.h \\\n+               rt/sync/sync.h \\\n+               rt/sync/timer.h \\\n+               rt/sync/lock_free_queue.h \\\n+               rt/rust_srv.h \\\n+               rt/rust_kernel.h \\\n+               rt/memory_region.h \\\n+               rt/memory.h \\\n+               rt/test/rust_test_harness.h \\\n+               rt/test/rust_test_runtime.h \\\n+               rt/test/rust_test_util.h\n+\n+RUNTIME_INCS := -I $(S)src/rt/isaac -I $(S)src/rt/uthash\n+RUNTIME_OBJS := $(RUNTIME_CS:.cpp=.o)\n+\n+######################################################################\n+# rustc LLVM-extensions (C++) library variables\n+######################################################################\n+\n+LLVMEXT_CS := $(addprefix llvmext/, \\\n+                MachOObjectFile.cpp Object.cpp RustWrapper.cpp)\n+\n+LLVMEXT_HDR := llvmext/include/llvm-c/Object.h\n+\n+LLVMEXT_INCS := -iquote $(CFG_LLVM_INCDIR) -iquote llvmext/include\n+LLVMEXT_OBJS := $(LLVMEXT_CS:.cpp=.o)\n+LLVMEXT_LIBS := $(CFG_LLVM_LDFLAGS) $(CFG_LLVM_LIBS)\n+\n+######################################################################\n+# Standard library variables\n+######################################################################\n+\n+STDLIB_CRATE := lib/std.rc\n+STDLIB_INPUTS := $(wildcard $(addprefix $(S)src/lib/,*.rc *.rs */*.rs))\n+\n+######################################################################\n+# rustc crate variables\n+######################################################################\n+\n+COMPILER_CRATE := comp/rustc.rc\n+COMPILER_INPUTS := $(wildcard $(addprefix $(S)/src/comp/, \\\n+                                rustc.rc *.rs */*.rs))\n+\n+######################################################################\n+# Single-target rules\n+######################################################################\n+\n+all: boot/rustboot$(X) rt/$(CFG_RUNTIME) llvmext/$(CFG_LLVMEXT)\n+\n+rt/$(CFG_RUNTIME): $(RUNTIME_OBJS) $(MKFILES) $(RUNTIME_HDR)\n+\t@$(call E, link: $@)\n+\t$(Q)$(call CFG_LINK_C, $@) $(RUNTIME_OBJS)\n+\n+llvmext/$(CFG_LLVMEXT): $(LLVMEXT_OBJS) $(MKFILES) $(LLVMEXT_HDR)\n+\t@$(call E, link: $@)\n+\t$(Q)$(call CFG_LINK_C, $@ $(LLVMEXT_OBJS) \\\n+        $(CFG_LLVM_LIBS) $(CFG_LLVM_LDFLAGS))\n+\n+ifdef CFG_BOOT_NATIVE\n+boot/rustboot$(X): $(BOOT_CMXS) $(MKFILES)\n+\t@$(call E, link: $@)\n+\t$(Q)ocamlopt$(OPT) -o $@ $(BOOT_OCAMLOPT_FLAGS) $(BOOT_ML_NATIVE_LIBS) \\\n+        $(BOOT_CMXS)\n+else\n+boot/rustboot$(X): $(BOOT_CMOS) $(MKFILES)\n+\t@$(call E, link: $@)\n+\t$(Q)ocamlc$(OPT) -o $@ $(BOOT_OCAMLC_FLAGS) $(BOOT_ML_LIBS) $(BOOT_CMOS)\n+endif\n+\n+boot/version.ml: $(MKFILES)\n+\t@$(call E, git: $@)\n+\t$(Q)git log -1 \\\n+      --pretty=format:'let version = \"prerelease (%h %ci)\";;' >$@ || exit 1\n+\n+\n+######################################################################\n+# Pattern rules\n+######################################################################\n+\n+rt/%.o: rt/%.cpp $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(Q)$(call CFG_COMPILE_C, $@, $(RUNTIME_INCS)) $<\n+\n+llvmext/%.o: llvmext/%.cpp $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(Q)$(call CFG_COMPILE_C, $@, $(CFG_LLVM_CXXFLAGS) \\\n+\t\t$(SUPPORT_INCS)) $<\n+\n+%.cmo: %.ml $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(Q)ocamlc$(OPT) -c -o $@ $(BOOT_OCAMLC_FLAGS) $<\n+\n+%.cmo: %.cmi $(MKFILES)\n+\n+%.cmx %.o: %.ml $(MKFILES)\n+\t@$(call E, compile: $@)\n+\t$(Q)ocamlopt$(OPT) -c -o $@ $(BOOT_OCAMLOPT_FLAGS) $<\n+\n+%.ml: %.mll $(MKFILES)\n+\t@$(call E, lex-gen: $@)\n+\t$(Q)ocamllex$(OPT) -q -o $@ $<\n+\n+\n+######################################################################\n+# Cleanup\n+######################################################################\n+\n+.PHONY: clean\n+\n+clean:\n+\t@$(call E, cleaning)\n+\t$(Q)rm -f $(foreach ext, cmx cmi cmo cma bc o a d $(X)     \\\n+                             h cpp ml s                        \\\n+                             out bc dSYM                       \\\n+                             ,                                 \\\n+                  $(wildcard     *.$(ext)                      \\\n+                               */*.$(ext)                      \\\n+                             */*/*.$(ext)                      \\\n+                           */*/*/*.$(ext)                      \\\n+                   ))"}, {"sha": "1672375e678233b79ea79bd2c895559eff1c380e", "filename": "configure", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/configure", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -0,0 +1,133 @@\n+#!/bin/sh\n+\n+CFG_SRC_DIR=${0%${0##*/}}\n+CFG_BUILD_DIR=$PWD\n+\n+msg() {\n+    echo \"configure: $1\"\n+}\n+\n+err() {\n+    echo \"configure: error: $1\"\n+    exit 1\n+}\n+\n+make_dir() {\n+    if [ ! -d $1 ]\n+    then\n+        msg \"mkdir -p $1\"\n+        mkdir -p $1\n+    fi\n+}\n+\n+copy() {\n+    msg \"cp $1 $1\"\n+    cp $1 $2\n+}\n+\n+make_test_subdirs() {\n+    for t in run-pass run-fail compile-fail\n+    do\n+        make_dir $1/test/$t\n+    done\n+}\n+\n+putvar() {\n+    local T\n+    eval T=\\$$1\n+    printf \"%-20s := %s\\n\" $1 \"$T\"\n+    printf \"%-20s := %s\\n\" $1 \"$T\" >>config.mk\n+}\n+\n+probe() {\n+    local V=$1\n+    local P=$2\n+    local T\n+    T=$(which $P 2>&1)\n+    if [ $? -ne 0 ]\n+    then\n+        T=\"\"\n+    fi\n+    eval $V=\\$T\n+    putvar $V\n+}\n+\n+probe_need() {\n+    local V=$1\n+    local P=$2\n+    probe $1 $2\n+    eval VV=\\$$V\n+    if [ -z \"$VV\" ]\n+    then\n+        err \"required program '$P' not found\"\n+    fi\n+}\n+\n+\n+msg \"recreating config.mk\"\n+echo '' >config.mk\n+\n+msg \"making directories\"\n+for i in \\\n+    doc \\\n+    boot/fe boot/me boot/be boot/driver boot/util \\\n+    rt/isaac rt/bigint rt/sync rt/test\n+do\n+    make_dir $i\n+done\n+\n+make_test_subdirs boot\n+\n+for i in 0 1 2\n+do\n+    make_dir stage$i\n+    make_test_subdirs stage$i\n+done\n+\n+msg \"inspecting environment\"\n+\n+CFG_OSTYPE=$(uname -s)\n+CFG_CPUTYPE=$(uname -m)\n+\n+putvar CFG_SRC_DIR\n+putvar CFG_BUILD_DIR\n+putvar CFG_OSTYPE\n+putvar CFG_CPUTYPE\n+\n+msg \"looking for programs\"\n+probe_need CFG_GCC          gcc\n+probe_need CFG_LLVM_CONFIG  llvm-config\n+probe_need CFG_OCAMLC       ocamlc\n+probe_need CFG_PERL         perl\n+probe_need CFG_SED          sed\n+\n+probe CFG_VALGRIND         valgrind\n+probe CFG_OCAMLOPT         ocamlopt\n+probe CFG_OCAMLC_OPT       ocamlc.opt\n+probe CFG_OCAMLOPT_OPT     ocamlopt.opt\n+probe CFG_FLEXLINK         flexlink\n+\n+CFG_LLVM_VERSION=$(llvm-config --version)\n+case $CFG_LLVM_VERSION in\n+    (3.0svn | 3.0)\n+    msg \"found ok version of LLVM: $CFG_LLVM_VERSION\"\n+    ;;\n+    (*)\n+    err \"bad LLVM version: $CFG_LLVM_VERSION, need >=3.0svn\"\n+    ;;\n+esac\n+CFG_LLVM_INCDIR=$(llvm-config --includedir)\n+CFG_LLVM_BINDIR=$(llvm-config --bindir)\n+CFG_LLVM_CXXFLAGS=$(llvm-config --cxxflags)\n+CFG_LLVM_LDFLAGS=$(llvm-config --ldflags)\n+CFG_LLVM_LIBS=$(llvm-config --libs)\n+\n+putvar CFG_LLVM_INCDIR\n+putvar CFG_LLVM_BINDIR\n+putvar CFG_LLVM_CXXFLAGS\n+putvar CFG_LLVM_LDFLAGS\n+putvar CFG_LLVM_LIBS\n+\n+copy ${CFG_SRC_DIR}Makefile.in ./Makefile\n+\n+echo \"configure: complete\""}, {"sha": "630babf33c6196e4ba75bff6fab5375104894211", "filename": "src/Makefile", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -1,3 +1,13 @@\n+# Delete the built-in rules.\n+# This speeds builds up substantially on win32, maybe elsewhere.\n+\n+.SUFFIXES:\n+%:: %,v\n+%:: RCS/%,v\n+%:: RCS/%\n+%:: s.%\n+%:: SCCS/s.%\n+\n ######################################################################\n # Auto-configuration\n ######################################################################\n@@ -446,6 +456,7 @@ TEST_XFAILS_BOOT :=  $(TASK_XFAILS) \\\n                     test/run-pass/iter-ret.rs \\\n                     test/run-pass/leak-tag-copy.rs \\\n                     test/run-pass/lib-io.rs \\\n+                    test/run-pass/maybe-mutable.rs \\\n                     test/run-pass/mlist-cycle.rs \\\n                     test/run-pass/obj-as.rs \\\n                     test/run-pass/seq-compare.rs \\\n@@ -469,7 +480,6 @@ TEST_XFAILS_RUSTC := $(addprefix test/run-pass/, \\\n                         acyclic-unwind.rs \\\n                         alt-pattern-drop.rs \\\n                         alt-type-simple.rs \\\n-                        append-units.rs \\\n                         basic-1.rs \\\n                         basic-2.rs \\\n                         basic.rs \\\n@@ -489,6 +499,7 @@ TEST_XFAILS_RUSTC := $(addprefix test/run-pass/, \\\n                         lib-sha1.rs \\\n                         lib-sort.rs \\\n                         lib-str.rs \\\n+                        lib-str-buf.rs \\\n                         lib-task.rs \\\n                         lib-uint.rs \\\n                         lib-vec-str-conversions.rs \\"}, {"sha": "fd4bd317067ea65e330a219701d0e9a217912117", "filename": "src/Makefile.in", "status": "removed", "additions": 0, "deletions": 129, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/830f2d02f19b45ff4b4a4d7946b69f206b5dcdff/src%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/830f2d02f19b45ff4b4a4d7946b69f206b5dcdff/src%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile.in?ref=830f2d02f19b45ff4b4a4d7946b69f206b5dcdff", "patch": "@@ -1,129 +0,0 @@\n-######################################################################\n-# Residual auto-configuration\n-######################################################################\n-\n-include config.mk\n-MKFILES := Makefile config.mk\n-\n-ifneq ($(MAKE_RESTARTS),)\n-CFG_INFO := $(info cfg: make restarts: $(MAKE_RESTARTS))\n-endif\n-\n-CFG_INFO := $(info cfg: building on $(CFG_OSTYPE) $(CFG_CPUTYPE))\n-\n-ifdef CFG_OCAMLC_OPT\n-  $(info cfg: using ocaml native compiler)\n-  OPT=.opt\n-else\n-  $(info cfg: using ocaml bytecode compiler)\n-endif\n-\n-ifdef PROFILE_BOOT\n-  $(info cfg: building bootstrap compiler with profiling (forcing native))\n-  CFG_NATIVE_BOOT := 1\n-  CFG_OCAMLOPT_PROFILE_FLAGS := -p\n-endif\n-\n-ifdef DEBUG\n-  $(info cfg: forcing bytecode bootstrap compiler)\n-  CFG_NATIVE_BOOT :=\n-endif\n-\n-ifdef CFG_NATIVE_BOOT\n-  $(info cfg: building native bootstrap compiler)\n-else\n-  $(info cfg: building bytecode bootstrap compiler)\n-endif\n-\n-ifdef NO_VALGRIND\n-    CFG_VALGRIND :=\n-endif\n-\n-\n-######################################################################\n-# Bootstrap compiler variables\n-######################################################################\n-\n-# We must list them in link order.\n-# Nobody calculates the link-order DAG automatically, sadly.\n-\n-BOOT_MLS :=                                              \\\n-    $(addsuffix .ml,                                     \\\n-        $(addprefix boot/util/, version fmt common bits) \\\n-        $(addprefix boot/driver/, session)               \\\n-        $(addprefix boot/fe/, ast token lexer parser     \\\n-          extfmt pexp item cexp fuzz)                    \\\n-        $(addprefix boot/be/, asm il abi)                \\\n-        $(addprefix boot/me/, walk semant resolve alias  \\\n-          simplify type dead layer effect typestate      \\\n-         loop layout transutil trans dwarf)              \\\n-        $(addprefix boot/be/, x86 ra pe elf macho)       \\\n-        $(addprefix boot/driver/, lib glue main))        \\\n-\n-BOOT_CMOS := $(BOOT_MLS:.ml=.cmo)\n-BOOT_CMXS := $(BOOT_MLS:.ml=.cmx)\n-BOOT_OBJS := $(BOOT_MLS:.ml=.o)\n-BOOT_CMIS := $(BOOT_MLS:.ml=.cmi)\n-\n-ML_DEP_INCS := -I $(S)boot/fe     -I $(S)boot/me   -I $(S)boot/be \\\n-               -I $(S)boot/driver -I $(S)boot/util\n-\n-ML_INCS        := $(ML_DEP_INCS)\n-ML_LIBS        := unix.cma  nums.cma  bigarray.cma\n-ML_NATIVE_LIBS := unix.cmxa nums.cmxa bigarray.cmxa\n-OCAMLC_FLAGS   := -g $(ML_INCS) -w Ael -warn-error Ael\n-\n-\n-######################################################################\n-# Target-and-rule \"utility variables\"\n-######################################################################\n-\n-ifdef VERBOSE\n-  Q :=\n-  E =\n-else\n-  Q := @\n-  E = echo $(1)\n-endif\n-\n-S := $(CFG_SRC_DIR)\n-X := $(CFG_EXE_SUFFIX)\n-\n-# Look in src dir.\n-VPATH := $(CFG_SRC_DIR)\n-\n-# Delete the built-in rules.\n-.SUFFIXES:\n-%:: %,v\n-%:: RCS/%,v\n-%:: RCS/%\n-%:: s.%\n-%:: SCCS/s.%\n-\n-######################################################################\n-# Targets and rules\n-######################################################################\n-\n-all: rustboot$(X)\n-\n-ifdef CFG_NATIVE_BOOT\n-rustboot$(X): $(BOOT_CMXS) $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(Q)ocamlopt$(OPT) -o $@ $(OCAMLOPT_FLAGS) $(ML_NATIVE_LIBS) \\\n-        $(BOOT_CMXS)\n-else\n-rustboot$(X): $(BOOT_CMOS) $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(Q)ocamlc$(OPT) -o $@ $(OCAMLC_FLAGS) $(ML_LIBS) $(BOOT_CMOS)\n-endif\n-\n-\n-boot/util/version.ml: $(MKFILES)\n-\t$(Q)git log -1 \\\n-      --pretty=format:'let version = \"prerelease (%h %ci)\";;' >$@ || exit 1\n-\n-%.cmo: %.ml $(MKFILES)\n-\t@$(call E, compile: $@)\n-\t$(Q)ocamlc$(OPT) -c -o $@ $(OCAMLC_FLAGS) $<\n-\n-%.cmo: %.cmi $(MKFILES)"}, {"sha": "c4dcfe1ddaa662933a09881d74f0094849448826", "filename": "src/boot/fe/pexp.ml", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -159,7 +159,14 @@ and parse_effect (ps:pstate) : Ast.effect =\n \n and parse_mutability (ps:pstate) : Ast.mutability =\n   match peek ps with\n-      MUTABLE -> bump ps; Ast.MUT_mutable\n+      MUTABLE ->\n+        begin\n+          (* HACK: ignore \"mutable?\" *)\n+          bump ps;\n+          match peek ps with\n+              QUES -> bump ps; Ast.MUT_immutable\n+            | _ -> Ast.MUT_mutable\n+        end\n     | _ -> Ast.MUT_immutable\n \n and parse_ty_fn\n@@ -310,7 +317,12 @@ and parse_atomic_ty (ps:pstate) : Ast.ty =\n \n     | MUTABLE ->\n         bump ps;\n-        Ast.TY_mutable (parse_ty ps)\n+        begin\n+          (* HACK: ignore \"mutable?\" *)\n+          match peek ps with\n+              QUES -> bump ps; parse_ty ps\n+            | _ -> Ast.TY_mutable (parse_ty ps)\n+        end\n \n     | LPAREN ->\n         begin"}, {"sha": "72bdd40449398373e8ed02931e88ffe2db35ca8e", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -993,16 +993,14 @@ let check_block (cx:Semant.ctxt) : (fn_ctx -> Ast.block -> unit) =\n             let src_ty = check_atom ~deref:true src in\n             let dst_ty = check_lval dst in\n               match fundamental_ty dst_ty, fundamental_ty src_ty with\n-                  Ast.TY_vec elt1, Ast.TY_vec elt2\n-                | Ast.TY_vec elt1, elt2 ->\n+                  Ast.TY_vec elt1, Ast.TY_vec elt2 ->\n                     if elt1 = elt2\n                     then ()\n                     else\n                       Common.err None\n                         \"mismatched types in vec-append: %s += %s\"\n                         (pretty_ty_str dst_ty)\n                         (pretty_ty_str src_ty)\n-                | Ast.TY_str, (Ast.TY_mach Common.TY_u8)\n                 | Ast.TY_str, Ast.TY_str -> ()\n                 | _ ->\n                     infer_lval src_ty dst;"}, {"sha": "345603bb71003ff86df0bfb2a9902cf29697ef5c", "filename": "src/comp/back/x86.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fx86.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -212,10 +212,10 @@ fn upcall_glue(int n_args) -> vec[str] {\n         + store_esp_to_rust_sp_second_arg()\n         + load_esp_from_runtime_sp_second_arg()\n \n-        + vec(\"subl  $\" + wstr(n_args + 1) + \", %esp   # esp -= args\",\n+        + vec(\"subl  $\" + wstr(n_args) + \", %esp   # esp -= args\",\n               \"andl  $~0xf, %esp    # align esp down\")\n \n-        + _vec.init_fn[str](carg, (n_args + 1) as uint)\n+        + _vec.init_fn[str](carg, (n_args) as uint)\n \n         +  vec(\"movl  %edx, %edi     # save task from edx to edi\",\n                \"call  *%ecx          # call *%ecx\",\n@@ -268,7 +268,7 @@ fn get_module_asm() -> str {\n                       rust_yield_glue()))\n \n         + _vec.init_fn[str](bind decl_upcall_glue(align, prefix, _),\n-                            abi.n_upcall_glues as uint);\n+                            (abi.n_upcall_glues + 1) as uint);\n \n     ret _str.connect(glues, \"\\n\\n\");\n }"}, {"sha": "f0ce9a95f96d2f861b2a1d13d550c95f504c5482", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -203,8 +203,8 @@ impure fn main(vec[str] args) {\n                 alt (output_file) {\n                     case (none[str]) {\n                         let vec[str] parts = _str.split(ifile, '.' as u8);\n-                        parts = _vec.pop[str](parts);\n-                        parts += \".bc\";\n+                        _vec.pop[str](parts);\n+                        parts += vec(\".bc\");\n                         auto ofile = _str.concat(parts);\n                         compile_input(sess, env, ifile, ofile, shared,\n                                       library_search_paths);"}, {"sha": "605774fe92f2d49d137fa12964ffa69562385a21", "filename": "src/comp/driver/session.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Fsession.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -45,6 +45,15 @@ obj session(cfg targ) {\n         fail;\n     }\n \n+    fn span_unimpl(span sp, str msg) {\n+        log #fmt(\"%s:%u:%u:%u:%u: error: unimplemented %s\",\n+                 sp.filename,\n+                 sp.lo.line, sp.lo.col,\n+                 sp.hi.line, sp.hi.col,\n+                 msg);\n+        fail;\n+    }\n+\n     fn unimpl(str msg) {\n         log #fmt(\"error: unimplemented %s\", msg);\n         fail;"}, {"sha": "ec93db55c92a1dc7c1f953ece50b1a7ef2d2e76e", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -91,6 +91,7 @@ tag pat_ {\n tag mutability {\n     mut;\n     imm;\n+    maybe_mut;\n }\n \n tag opacity {\n@@ -168,7 +169,6 @@ tag unop {\n     bitnot;\n     not;\n     neg;\n-    _mutable;\n }\n \n fn unop_to_str(unop op) -> str {\n@@ -178,7 +178,6 @@ fn unop_to_str(unop op) -> str {\n         case (bitnot) {ret \"~\";}\n         case (not) {ret \"!\";}\n         case (neg) {ret \"-\";}\n-        case (_mutable) {ret \"mutable\";}\n     }\n }\n \n@@ -215,7 +214,7 @@ type field = rec(mutability mut, ident ident, @expr expr);\n \n type expr = spanned[expr_];\n tag expr_ {\n-    expr_vec(vec[@expr], ann);\n+    expr_vec(vec[@expr], mutability, ann);\n     expr_tup(vec[elt], ann);\n     expr_rec(vec[field], option.t[@expr], ann);\n     expr_call(@expr, vec[@expr], ann);\n@@ -263,7 +262,8 @@ tag lit_ {\n // NB: If you change this, you'll probably want to change the corresponding\n // type structure in middle/ty.rs as well.\n \n-type ty_field = rec(ident ident, @ty ty);\n+type mt = rec(@ty ty, mutability mut);\n+type ty_field = rec(ident ident, mt mt);\n type ty_arg = rec(mode mode, @ty ty);\n // TODO: effect\n type ty_method = rec(proto proto, ident ident,\n@@ -277,16 +277,15 @@ tag ty_ {\n     ty_machine(util.common.ty_mach);\n     ty_char;\n     ty_str;\n-    ty_box(@ty);\n-    ty_vec(@ty);\n+    ty_box(mt);\n+    ty_vec(mt);\n     ty_port(@ty);\n     ty_chan(@ty);\n-    ty_tup(vec[@ty]);\n+    ty_tup(vec[mt]);\n     ty_rec(vec[ty_field]);\n     ty_fn(proto, vec[ty_arg], @ty);        // TODO: effect\n     ty_obj(vec[ty_method]);\n     ty_path(path, option.t[def]);\n-    ty_mutable(@ty);\n     ty_type;\n     ty_constr(@ty, vec[@constr]);\n }"}, {"sha": "4cf3765f4d37052b23cff9901d4470e9f39d7524", "filename": "src/comp/front/eval.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Feval.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -13,7 +13,6 @@ import front.parser.new_parser;\n import front.parser.parse_mod_items;\n import util.common;\n import util.common.filename;\n-import util.common.append;\n import util.common.span;\n import util.common.new_str_hash;\n \n@@ -394,7 +393,7 @@ impure fn eval_crate_directive(parser p,\n             auto im = ast.item_mod(id, m0, next_id);\n             auto i = @spanned(cdir.span, cdir.span, im);\n             ast.index_item(index, i);\n-            append[@ast.item](items, i);\n+            _vec.push[@ast.item](items, i);\n         }\n \n         case (ast.cdir_dir_mod(?id, ?dir_opt, ?cdirs)) {\n@@ -412,11 +411,11 @@ impure fn eval_crate_directive(parser p,\n             auto im = ast.item_mod(id, m0, p.next_def_id());\n             auto i = @spanned(cdir.span, cdir.span, im);\n             ast.index_item(index, i);\n-            append[@ast.item](items, i);\n+            _vec.push[@ast.item](items, i);\n         }\n \n         case (ast.cdir_view_item(?vi)) {\n-            append[@ast.view_item](view_items, vi);\n+            _vec.push[@ast.view_item](view_items, vi);\n             ast.index_view_item(index, vi);\n         }\n "}, {"sha": "0a32a851dacd8d3a1b3686016f27ebe4a49a50f8", "filename": "src/comp/front/extfmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fextfmt.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -113,7 +113,7 @@ fn parse_fmt_string(str s) -> vec[piece] {\n     fn flush_buf(str buf, &vec[piece] pieces) -> str {\n         if (_str.byte_len(buf) > 0u) {\n             auto piece = piece_string(buf);\n-            pieces += piece;\n+            pieces += vec(piece);\n         }\n         ret \"\";\n     }\n@@ -133,7 +133,7 @@ fn parse_fmt_string(str s) -> vec[piece] {\n             } else {\n                 buf = flush_buf(buf, pieces);\n                 auto res = parse_conversion(s, i, lim);\n-                pieces += res._0;\n+                pieces += vec(res._0);\n                 i = res._1;\n             }\n         } else {"}, {"sha": "403558e29344a9f2b414c34ae6899cfd4543148a", "filename": "src/comp/front/lexer.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Flexer.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -420,7 +420,7 @@ impure fn next_token(reader rdr) -> token.token {\n \n     if (is_alpha(c) || c == '_') {\n         while (is_alnum(c) || c == '_') {\n-            accum_str += (c as u8);\n+            _str.push_byte(accum_str, (c as u8));\n             rdr.bump();\n             c = rdr.curr();\n         }\n@@ -580,23 +580,23 @@ impure fn next_token(reader rdr) -> token.token {\n                         alt (rdr.next()) {\n                             case ('n') {\n                                 rdr.bump();\n-                                accum_str += '\\n' as u8;\n+                                _str.push_byte(accum_str, '\\n' as u8);\n                             }\n                             case ('r') {\n                                 rdr.bump();\n-                                accum_str += '\\r' as u8;\n+                                _str.push_byte(accum_str, '\\r' as u8);\n                             }\n                             case ('t') {\n                                 rdr.bump();\n-                                accum_str += '\\t' as u8;\n+                                _str.push_byte(accum_str, '\\t' as u8);\n                             }\n                             case ('\\\\') {\n                                 rdr.bump();\n-                                accum_str += '\\\\' as u8;\n+                                _str.push_byte(accum_str, '\\\\' as u8);\n                             }\n                             case ('\"') {\n                                 rdr.bump();\n-                                accum_str += '\"' as u8;\n+                                _str.push_byte(accum_str, '\"' as u8);\n                             }\n                             // FIXME: unicode numeric escapes.\n                             case (?c2) {\n@@ -607,7 +607,7 @@ impure fn next_token(reader rdr) -> token.token {\n                         }\n                     }\n                     case (_) {\n-                        accum_str += rdr.curr() as u8;\n+                        _str.push_byte(accum_str, rdr.curr() as u8);\n                     }\n                 }\n                 rdr.bump();"}, {"sha": "028b8a3132df2b7169c3862a9302c8198104a0e2", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 70, "deletions": 54, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -9,7 +9,6 @@ import std.map.hashmap;\n import driver.session;\n import util.common;\n import util.common.filename;\n-import util.common.append;\n import util.common.span;\n import util.common.new_str_hash;\n \n@@ -190,6 +189,11 @@ impure fn parse_ty_fn(ast.proto proto, parser p,\n         if (p.peek() == token.BINOP(token.AND)) {\n             p.bump();\n             mode = ast.alias;\n+\n+            if (p.peek() == token.MUTABLE) {\n+                p.bump();\n+                // TODO: handle mutable alias args\n+            }\n         } else {\n             mode = ast.val;\n         }\n@@ -263,10 +267,16 @@ impure fn parse_ty_obj(parser p, &mutable ast.span hi) -> ast.ty_ {\n     ret ast.ty_obj(meths.node);\n }\n \n+impure fn parse_mt(parser p) -> ast.mt {\n+    auto mut = parse_mutability(p);\n+    auto t = parse_ty(p);\n+    ret rec(ty=t, mut=mut);\n+}\n+\n impure fn parse_ty_field(parser p) -> ast.ty_field {\n-    auto ty = parse_ty(p);\n+    auto mt = parse_mt(p);\n     auto id = parse_ident(p);\n-    ret rec(ident=id, ty=ty);\n+    ret rec(ident=id, mt=mt);\n }\n \n impure fn parse_constr_arg(parser p) -> @ast.constr_arg {\n@@ -303,7 +313,7 @@ impure fn parse_constrs(parser p) -> common.spanned[vec[@ast.constr]] {\n                 case (token.IDENT(_)) {\n                     auto constr = parse_ty_constr(p);\n                     hi = constr.span;\n-                    append[@ast.constr](constrs, constr);\n+                    _vec.push[@ast.constr](constrs, constr);\n                     if (p.peek() == token.COMMA) {\n                         p.bump();\n                         more = false;\n@@ -361,25 +371,25 @@ impure fn parse_ty(parser p) -> @ast.ty {\n \n         case (token.AT) {\n             p.bump();\n-            auto t0 = parse_ty(p);\n-            hi = t0.span;\n-            t = ast.ty_box(t0);\n+            auto mt = parse_mt(p);\n+            hi = mt.ty.span;\n+            t = ast.ty_box(mt);\n         }\n \n         case (token.VEC) {\n             p.bump();\n             expect(p, token.LBRACKET);\n-            t = ast.ty_vec(parse_ty(p));\n+            t = ast.ty_vec(parse_mt(p));\n             hi = p.get_span();\n             expect(p, token.RBRACKET);\n         }\n \n         case (token.TUP) {\n             p.bump();\n-            auto f = parse_ty; // FIXME: trans_const_lval bug\n-            auto elems = parse_seq[@ast.ty] (token.LPAREN,\n-                                             token.RPAREN,\n-                                             some(token.COMMA), f, p);\n+            auto f = parse_mt; // FIXME: trans_const_lval bug\n+            auto elems = parse_seq[ast.mt] (token.LPAREN,\n+                                            token.RPAREN,\n+                                            some(token.COMMA), f, p);\n             hi = elems.span;\n             t = ast.ty_tup(elems.node);\n         }\n@@ -396,13 +406,6 @@ impure fn parse_ty(parser p) -> @ast.ty {\n             t = ast.ty_rec(elems.node);\n         }\n \n-        case (token.MUTABLE) {\n-            p.bump();\n-            auto t0 = parse_ty(p);\n-            hi = t0.span;\n-            t = ast.ty_mutable(t0);\n-        }\n-\n         case (token.FN) {\n             auto flo = p.get_span();\n             p.bump();\n@@ -464,20 +467,22 @@ impure fn parse_arg(parser p) -> ast.arg {\n     if (p.peek() == token.BINOP(token.AND)) {\n         m = ast.alias;\n         p.bump();\n+\n+        if (p.peek() == token.MUTABLE) {\n+            // TODO: handle mutable alias args\n+            p.bump();\n+        }\n     }\n     let @ast.ty t = parse_ty(p);\n     let ast.ident i = parse_ident(p);\n     ret rec(mode=m, ty=t, ident=i, id=p.next_def_id());\n }\n \n-impure fn parse_seq[T](token.token bra,\n-                      token.token ket,\n-                      option.t[token.token] sep,\n-                      (impure fn(parser) -> T) f,\n-                      parser p) -> util.common.spanned[vec[T]] {\n+impure fn parse_seq_to_end[T](token.token ket,\n+                              option.t[token.token] sep,\n+                              (impure fn(parser) -> T) f,\n+                              parser p) -> vec[T] {\n     let bool first = true;\n-    auto lo = p.get_span();\n-    expect(p, bra);\n     let vec[T] v = vec();\n     while (p.peek() != ket) {\n         alt(sep) {\n@@ -495,9 +500,20 @@ impure fn parse_seq[T](token.token bra,\n         let T t = f(p);\n         v += vec(t);\n     }\n-    auto hi = p.get_span();\n     expect(p, ket);\n-    ret spanned(lo, hi, v);\n+    ret v;\n+}\n+\n+impure fn parse_seq[T](token.token bra,\n+                      token.token ket,\n+                      option.t[token.token] sep,\n+                      (impure fn(parser) -> T) f,\n+                      parser p) -> util.common.spanned[vec[T]] {\n+    auto lo = p.get_span();\n+    expect(p, bra);\n+    auto result = parse_seq_to_end[T](ket, sep, f, p);\n+    auto hi = p.get_span();\n+    ret spanned(lo, hi, result);\n }\n \n impure fn parse_lit(parser p) -> ast.lit {\n@@ -573,7 +589,7 @@ impure fn parse_path(parser p, greed g) -> ast.path {\n         alt (p.peek()) {\n             case (token.IDENT(?i)) {\n                 hi = p.get_span();\n-                ids += i;\n+                ids += vec(i);\n                 p.bump();\n                 if (p.peek() == token.DOT) {\n                     if (g == GREEDY) {\n@@ -596,16 +612,20 @@ impure fn parse_path(parser p, greed g) -> ast.path {\n     ret spanned(lo, tys.span, rec(idents=ids, types=tys.node));\n }\n \n-impure fn parse_mutabliity(parser p) -> ast.mutability {\n+impure fn parse_mutability(parser p) -> ast.mutability {\n     if (p.peek() == token.MUTABLE) {\n         p.bump();\n+        if (p.peek() == token.QUES) {\n+            p.bump();\n+            ret ast.maybe_mut;\n+        }\n         ret ast.mut;\n     }\n     ret ast.imm;\n }\n \n impure fn parse_field(parser p) -> ast.field {\n-    auto m = parse_mutabliity(p);\n+    auto m = parse_mutability(p);\n     auto i = parse_ident(p);\n     expect(p, token.EQ);\n     auto e = parse_expr(p);\n@@ -651,7 +671,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n         case (token.TUP) {\n             p.bump();\n             impure fn parse_elt(parser p) -> ast.elt {\n-                auto m = parse_mutabliity(p);\n+                auto m = parse_mutability(p);\n                 auto e = parse_expr(p);\n                 ret rec(mut=m, expr=e);\n             }\n@@ -668,12 +688,15 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n         case (token.VEC) {\n             p.bump();\n             auto pf = parse_expr;\n-            auto es = parse_seq[@ast.expr](token.LPAREN,\n-                                           token.RPAREN,\n-                                           some(token.COMMA),\n-                                           pf, p);\n-            hi = es.span;\n-            ex = ast.expr_vec(es.node, ast.ann_none);\n+\n+            expect(p, token.LPAREN);\n+            auto mut = parse_mutability(p);\n+\n+            auto es = parse_seq_to_end[@ast.expr](token.RPAREN,\n+                                                  some(token.COMMA),\n+                                                  pf, p);\n+            hi = p.get_span();\n+            ex = ast.expr_vec(es, mut, ast.ann_none);\n         }\n \n         case (token.REC) {\n@@ -699,7 +722,7 @@ impure fn parse_bottom_expr(parser p) -> @ast.expr {\n                     }\n                     case (token.COMMA) {\n                         p.bump();\n-                        fields += parse_field(p);\n+                        fields += vec(parse_field(p));\n                     }\n                     case (?t) {\n                         unexpected(p, t);\n@@ -877,7 +900,7 @@ impure fn extend_expr_by_ident(parser p, span lo, span hi,\n         case (ast.expr_path(?pth, ?def, ?ann)) {\n             if (_vec.len[@ast.ty](pth.node.types) == 0u) {\n                 auto idents_ = pth.node.idents;\n-                idents_ += i;\n+                idents_ += vec(i);\n                 auto tys = parse_ty_args(p, hi);\n                 auto pth_ = spanned(pth.span, tys.span,\n                                     rec(idents=idents_,\n@@ -1005,13 +1028,6 @@ impure fn parse_prefix_expr(parser p) -> @ast.expr {\n             ex = ast.expr_unary(ast.box, e, ast.ann_none);\n         }\n \n-        case (token.MUTABLE) {\n-            p.bump();\n-            auto e = parse_prefix_expr(p);\n-            hi = e.span;\n-            ex = ast.expr_unary(ast._mutable, e, ast.ann_none);\n-        }\n-\n         case (_) {\n             ret parse_dot_or_call_expr(p);\n         }\n@@ -1559,7 +1575,7 @@ fn stmt_ends_with_semi(@ast.stmt stmt) -> bool {\n         }\n         case (ast.stmt_expr(?e)) {\n             alt (e.node) {\n-                case (ast.expr_vec(_,_))        { ret true; }\n+                case (ast.expr_vec(_,_,_))      { ret true; }\n                 case (ast.expr_tup(_,_))        { ret true; }\n                 case (ast.expr_rec(_,_,_))      { ret true; }\n                 case (ast.expr_call(_,_,_))     { ret true; }\n@@ -1723,6 +1739,7 @@ impure fn parse_item_fn_or_iter(parser p, ast.effect eff) -> @ast.item {\n \n \n impure fn parse_obj_field(parser p) -> ast.obj_field {\n+    auto mut = parse_mutability(p); // TODO: store this, use it in typeck\n     auto ty = parse_ty(p);\n     auto ident = parse_ident(p);\n     ret rec(ty=ty, ident=ident, id=p.next_def_id(), ann=ast.ann_none);\n@@ -1763,8 +1780,8 @@ impure fn parse_item_obj(parser p, ast.layer lyr) -> @ast.item {\n                 dtor = some[ast.block](parse_block(p));\n             }\n             case (_) {\n-                append[@ast.method](meths,\n-                                    parse_method(p));\n+                _vec.push[@ast.method](meths,\n+                                       parse_method(p));\n             }\n         }\n     }\n@@ -2161,12 +2178,11 @@ impure fn parse_rest_import_name(parser p, ast.ident first,\n         -> @ast.view_item {\n     auto lo = p.get_span();\n     auto hi = lo;\n-    let vec[ast.ident] identifiers = vec();\n-    identifiers += first;\n+    let vec[ast.ident] identifiers = vec(first);\n     while (p.peek() != token.SEMI) {\n         expect(p, token.DOT);\n         auto i = parse_ident(p);\n-        identifiers += i;\n+        identifiers += vec(i);\n     }\n     p.bump();\n     auto defined_id;\n@@ -2402,7 +2418,7 @@ impure fn parse_crate_directives(parser p, token.token term)\n \n     while (p.peek() != term) {\n         auto cdir = @parse_crate_directive(p);\n-        append[@ast.crate_directive](cdirs, cdir);\n+        _vec.push[@ast.crate_directive](cdirs, cdir);\n     }\n \n     ret cdirs;"}, {"sha": "62c6406a6b8b6a1e1467044a4170deebc17f0f69", "filename": "src/comp/front/token.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Ffront%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftoken.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -3,6 +3,7 @@ import util.common.ty_mach_to_str;\n import util.common.new_str_hash;\n import std._int;\n import std._uint;\n+import std._str;\n \n tag binop {\n     PLUS;\n@@ -302,8 +303,8 @@ fn to_str(token t) -> str {\n         case (LIT_CHAR(?c)) {\n             // FIXME: escape and encode.\n             auto tmp = \"'\";\n-            tmp += c as u8;\n-            tmp += '\\'' as u8;\n+            _str.push_byte(tmp, c as u8);\n+            _str.push_byte(tmp, '\\'' as u8);\n             ret tmp;\n         }\n "}, {"sha": "703c7ea4400abfb617cf5a567bc38afdc879b4ae", "filename": "src/comp/middle/fold.rs", "status": "modified", "additions": 45, "deletions": 53, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -7,7 +7,6 @@ import util.common.new_str_hash;\n import util.common.spanned;\n import util.common.span;\n import util.common.ty_mach;\n-import util.common.append;\n \n import front.ast;\n import front.ast.fn_decl;\n@@ -29,6 +28,7 @@ import front.ast.arm;\n import front.ast.def;\n import front.ast.def_id;\n import front.ast.ann;\n+import front.ast.mt;\n \n import std._uint;\n import std._vec;\n@@ -47,10 +47,10 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, ty_mach tm) -> @ty)    fold_ty_machine,\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_char,\n      (fn(&ENV e, &span sp) -> @ty)                fold_ty_str,\n-     (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_box,\n-     (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_vec,\n+     (fn(&ENV e, &span sp, &mt tm) -> @ty)        fold_ty_box,\n+     (fn(&ENV e, &span sp, &mt tm) -> @ty)        fold_ty_vec,\n \n-     (fn(&ENV e, &span sp, vec[@ty] elts) -> @ty) fold_ty_tup,\n+     (fn(&ENV e, &span sp, vec[mt] elts) -> @ty)  fold_ty_tup,\n \n      (fn(&ENV e, &span sp,\n          vec[ast.ty_field] elts) -> @ty)          fold_ty_rec,\n@@ -66,13 +66,13 @@ type ast_fold[ENV] =\n      (fn(&ENV e, &span sp, ast.path p,\n          &option.t[def] d) -> @ty)                fold_ty_path,\n \n-     (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_mutable,\n      (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_chan,\n      (fn(&ENV e, &span sp, @ty t) -> @ty)         fold_ty_port,\n \n      // Expr folds.\n      (fn(&ENV e, &span sp,\n-         vec[@expr] es, ann a) -> @expr)          fold_expr_vec,\n+         vec[@expr] es, ast.mutability mut,\n+         ann a) -> @expr)                         fold_expr_vec,\n \n      (fn(&ENV e, &span sp,\n          vec[ast.elt] es, ann a) -> @expr)        fold_expr_tup,\n@@ -318,7 +318,7 @@ type ast_fold[ENV] =\n fn fold_path[ENV](&ENV env, ast_fold[ENV] fld, &path p) -> path {\n     let vec[@ast.ty] tys_ = vec();\n     for (@ast.ty t in p.node.types) {\n-        append[@ast.ty](tys_, fold_ty(env, fld, t));\n+        _vec.push[@ast.ty](tys_, fold_ty(env, fld, t));\n     }\n     let ast.path_ p_ = rec(idents=p.node.idents, types=tys_);\n     ret fld.fold_path(env, p.span, p_);\n@@ -344,29 +344,31 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n         case (ast.ty_char) { ret fld.fold_ty_char(env_, t.span); }\n         case (ast.ty_str) { ret fld.fold_ty_str(env_, t.span); }\n \n-        case (ast.ty_box(?ty)) {\n-            auto ty_ = fold_ty(env, fld, ty);\n-            ret fld.fold_ty_box(env_, t.span, ty_);\n+        case (ast.ty_box(?tm)) {\n+            auto ty_ = fold_ty(env, fld, tm.ty);\n+            ret fld.fold_ty_box(env_, t.span, rec(ty=ty_, mut=tm.mut));\n         }\n \n-        case (ast.ty_vec(?ty)) {\n-            auto ty_ = fold_ty(env, fld, ty);\n-            ret fld.fold_ty_vec(env_, t.span, ty_);\n+        case (ast.ty_vec(?tm)) {\n+            auto ty_ = fold_ty(env, fld, tm.ty);\n+            ret fld.fold_ty_vec(env_, t.span, rec(ty=ty_, mut=tm.mut));\n         }\n \n         case (ast.ty_tup(?elts)) {\n-            let vec[@ty] elts_ = vec();\n-            for (@ty elt in elts) {\n-                append[@ty](elts_,fold_ty(env, fld, elt));\n+            let vec[mt] elts_ = vec();\n+            for (mt elt in elts) {\n+                auto ty_ = fold_ty(env, fld, elt.ty);\n+                _vec.push[mt](elts_, rec(ty=ty_, mut=elt.mut));\n             }\n             ret fld.fold_ty_tup(env_, t.span, elts_);\n         }\n \n         case (ast.ty_rec(?flds)) {\n             let vec[ast.ty_field] flds_ = vec();\n             for (ast.ty_field f in flds) {\n-                append[ast.ty_field]\n-                    (flds_, rec(ty=fold_ty(env, fld, f.ty) with f));\n+                auto ty_ = fold_ty(env, fld, f.mt.ty);\n+                _vec.push[ast.ty_field]\n+                    (flds_, rec(mt=rec(ty=ty_, mut=f.mt.mut) with f));\n             }\n             ret fld.fold_ty_rec(env_, t.span, flds_);\n         }\n@@ -378,7 +380,7 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n                                       m.inputs, m.output);\n                 alt (tfn.node) {\n                     case (ast.ty_fn(?p, ?ins, ?out)) {\n-                        append[ast.ty_method]\n+                        _vec.push[ast.ty_method]\n                             (meths_, rec(proto=p, inputs=ins, output=out\n                                          with m));\n                     }\n@@ -392,11 +394,6 @@ fn fold_ty[ENV](&ENV env, ast_fold[ENV] fld, @ty t) -> @ty {\n             ret fld.fold_ty_path(env_, t.span, pth_, ref_opt);\n         }\n \n-        case (ast.ty_mutable(?ty)) {\n-            auto ty_ = fold_ty(env, fld, ty);\n-            ret fld.fold_ty_mutable(env_, t.span, ty_);\n-        }\n-\n         case (ast.ty_fn(?proto, ?inputs, ?output)) {\n             ret fold_ty_fn(env_, fld, t.span, proto, inputs, output);\n         }\n@@ -494,7 +491,7 @@ fn fold_pat[ENV](&ENV env, ast_fold[ENV] fld, @ast.pat p) -> @ast.pat {\n fn fold_exprs[ENV](&ENV env, ast_fold[ENV] fld, vec[@expr] es) -> vec[@expr] {\n     let vec[@expr] exprs = vec();\n     for (@expr e in es) {\n-        append[@expr](exprs, fold_expr(env, fld, e));\n+        _vec.push[@expr](exprs, fold_expr(env, fld, e));\n     }\n     ret exprs;\n }\n@@ -517,15 +514,15 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n     }\n \n     alt (e.node) {\n-        case (ast.expr_vec(?es, ?t)) {\n+        case (ast.expr_vec(?es, ?mut, ?t)) {\n             auto ees = fold_exprs(env_, fld, es);\n-            ret fld.fold_expr_vec(env_, e.span, ees, t);\n+            ret fld.fold_expr_vec(env_, e.span, ees, mut, t);\n         }\n \n         case (ast.expr_tup(?es, ?t)) {\n             let vec[ast.elt] elts = vec();\n             for (ast.elt e in es) {\n-                elts += fold_tup_elt[ENV](env, fld, e);\n+                elts += vec(fold_tup_elt[ENV](env, fld, e));\n             }\n             ret fld.fold_expr_tup(env_, e.span, elts, t);\n         }\n@@ -534,7 +531,7 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             let vec[ast.field] fields = vec();\n             let option.t[@expr] b = none[@expr];\n             for (ast.field f in fs) {\n-                fields += fold_rec_field(env, fld, f);\n+                fields += vec(fold_rec_field(env, fld, f));\n             }\n             alt (base) {\n                 case (none[@ast.expr]) { }\n@@ -557,7 +554,7 @@ fn fold_expr[ENV](&ENV env, ast_fold[ENV] fld, &@expr e) -> @expr {\n             for (option.t[@ast.expr] t_opt in args_opt) {\n                 alt (t_opt) {\n                     case (none[@ast.expr]) {\n-                        aargs_opt += none[@ast.expr];\n+                        aargs_opt += vec(none[@ast.expr]);\n                     }\n                     case (some[@ast.expr](?e)) {\n                         aargs_opt += vec(some(fold_expr(env_, fld, e)));\n@@ -779,7 +776,7 @@ fn fold_block[ENV](&ENV env, ast_fold[ENV] fld, &block blk) -> block {\n     let vec[@ast.stmt] stmts = vec();\n     for (@ast.stmt s in blk.node.stmts) {\n         auto new_stmt = fold_stmt[ENV](env_, fld, s);\n-        append[@ast.stmt](stmts, new_stmt);\n+        _vec.push[@ast.stmt](stmts, new_stmt);\n         ast.index_stmt(index, new_stmt);\n     }\n \n@@ -812,7 +809,7 @@ fn fold_fn_decl[ENV](&ENV env, ast_fold[ENV] fld,\n                      &ast.fn_decl decl) -> ast.fn_decl {\n     let vec[ast.arg] inputs = vec();\n     for (ast.arg a in decl.inputs) {\n-        inputs += fold_arg(env, fld, a);\n+        inputs += vec(fold_arg(env, fld, a));\n     }\n     auto output = fold_ty[ENV](env, fld, decl.output);\n     ret fld.fold_fn_decl(env, decl.effect, inputs, output);\n@@ -846,7 +843,7 @@ fn fold_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast._obj ob) -> ast._obj {\n     let vec[ast.obj_field] fields = vec();\n     let vec[@ast.method] meths = vec();\n     for (ast.obj_field f in ob.fields) {\n-        fields += fold_obj_field(env, fld, f);\n+        fields += vec(fold_obj_field(env, fld, f));\n     }\n     let option.t[block] dtor = none[block];\n     alt (ob.dtor) {\n@@ -867,7 +864,7 @@ fn fold_obj[ENV](&ENV env, ast_fold[ENV] fld, &ast._obj ob) -> ast._obj {\n                                                 m.node.ann),\n                                span=m.span);\n         let ENV _env = fld.update_env_for_item(env, i);\n-        append[@ast.method](meths, fold_method(_env, fld, m));\n+        _vec.push[@ast.method](meths, fold_method(_env, fld, m));\n     }\n     ret fld.fold_obj(env, fields, meths, dtor);\n }\n@@ -944,8 +941,8 @@ fn fold_item[ENV](&ENV env, ast_fold[ENV] fld, @item i) -> @item {\n                     auto new_ty = fold_ty[ENV](env_, fld, va.ty);\n                     new_args += vec(rec(ty=new_ty, id=va.id));\n                 }\n-                new_variants += rec(name=v.name, args=new_args, id=v.id,\n-                                    ann=v.ann);\n+                new_variants += vec(rec(name=v.name, args=new_args, id=v.id,\n+                                        ann=v.ann));\n             }\n             ret fld.fold_item_tag(env_, i.span, ident, new_variants,\n                                   ty_params, id);\n@@ -969,13 +966,13 @@ fn fold_mod[ENV](&ENV e, ast_fold[ENV] fld, &ast._mod m) -> ast._mod {\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        append[@view_item](view_items, new_vi);\n+        _vec.push[@view_item](view_items, new_vi);\n         ast.index_view_item(index, new_vi);\n     }\n \n     for (@item i in m.items) {\n         auto new_item = fold_item[ENV](e, fld, i);\n-        append[@item](items, new_item);\n+        _vec.push[@item](items, new_item);\n         ast.index_item(index, new_item);\n     }\n \n@@ -1009,12 +1006,12 @@ fn fold_native_mod[ENV](&ENV e, ast_fold[ENV] fld,\n \n     for (@view_item vi in m.view_items) {\n         auto new_vi = fold_view_item[ENV](e, fld, vi);\n-        append[@view_item](view_items, new_vi);\n+        _vec.push[@view_item](view_items, new_vi);\n     }\n \n     for (@native_item i in m.items) {\n         auto new_item = fold_native_item[ENV](e, fld, i);\n-        append[@native_item](items, new_item);\n+        _vec.push[@native_item](items, new_item);\n         ast.index_native_item(index, new_item);\n     }\n \n@@ -1078,16 +1075,16 @@ fn identity_fold_ty_str[ENV](&ENV env, &span sp) -> @ty {\n     ret @respan(sp, ast.ty_str);\n }\n \n-fn identity_fold_ty_box[ENV](&ENV env, &span sp, @ty t) -> @ty {\n-    ret @respan(sp, ast.ty_box(t));\n+fn identity_fold_ty_box[ENV](&ENV env, &span sp, &mt tm) -> @ty {\n+    ret @respan(sp, ast.ty_box(tm));\n }\n \n-fn identity_fold_ty_vec[ENV](&ENV env, &span sp, @ty t) -> @ty {\n-    ret @respan(sp, ast.ty_vec(t));\n+fn identity_fold_ty_vec[ENV](&ENV env, &span sp, &mt tm) -> @ty {\n+    ret @respan(sp, ast.ty_vec(tm));\n }\n \n fn identity_fold_ty_tup[ENV](&ENV env, &span sp,\n-                             vec[@ty] elts) -> @ty {\n+                             vec[mt] elts) -> @ty {\n     ret @respan(sp, ast.ty_tup(elts));\n }\n \n@@ -1113,10 +1110,6 @@ fn identity_fold_ty_path[ENV](&ENV env, &span sp, ast.path p,\n     ret @respan(sp, ast.ty_path(p, d));\n }\n \n-fn identity_fold_ty_mutable[ENV](&ENV env, &span sp, @ty t) -> @ty {\n-    ret @respan(sp, ast.ty_mutable(t));\n-}\n-\n fn identity_fold_ty_chan[ENV](&ENV env, &span sp, @ty t) -> @ty {\n     ret @respan(sp, ast.ty_chan(t));\n }\n@@ -1128,8 +1121,8 @@ fn identity_fold_ty_port[ENV](&ENV env, &span sp, @ty t) -> @ty {\n // Expr identities.\n \n fn identity_fold_expr_vec[ENV](&ENV env, &span sp, vec[@expr] es,\n-                               ann a) -> @expr {\n-    ret @respan(sp, ast.expr_vec(es, a));\n+                               ast.mutability mut, ann a) -> @expr {\n+    ret @respan(sp, ast.expr_vec(es, mut, a));\n }\n \n fn identity_fold_expr_tup[ENV](&ENV env, &span sp,\n@@ -1529,11 +1522,10 @@ fn new_identity_fold[ENV]() -> ast_fold[ENV] {\n          fold_ty_obj     = bind identity_fold_ty_obj[ENV](_,_,_),\n          fold_ty_fn      = bind identity_fold_ty_fn[ENV](_,_,_,_,_),\n          fold_ty_path    = bind identity_fold_ty_path[ENV](_,_,_,_),\n-         fold_ty_mutable = bind identity_fold_ty_mutable[ENV](_,_,_),\n          fold_ty_chan    = bind identity_fold_ty_chan[ENV](_,_,_),\n          fold_ty_port    = bind identity_fold_ty_port[ENV](_,_,_),\n \n-         fold_expr_vec    = bind identity_fold_expr_vec[ENV](_,_,_,_),\n+         fold_expr_vec    = bind identity_fold_expr_vec[ENV](_,_,_,_,_),\n          fold_expr_tup    = bind identity_fold_expr_tup[ENV](_,_,_,_),\n          fold_expr_rec    = bind identity_fold_expr_rec[ENV](_,_,_,_,_),\n          fold_expr_call   = bind identity_fold_expr_call[ENV](_,_,_,_,_),"}, {"sha": "2ef619cb4d2cace2f54d3a057e2edc4f67a9de2c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 122, "deletions": 114, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -20,7 +20,6 @@ import middle.ty.pat_ty;\n import middle.ty.plain_ty;\n \n import util.common;\n-import util.common.append;\n import util.common.istr;\n import util.common.new_def_hash;\n import util.common.new_str_hash;\n@@ -476,7 +475,7 @@ fn type_of_explicit_args(@crate_ctxt cx,\n     for (ty.arg arg in inputs) {\n         if (ty.type_has_dynamic_size(arg.ty)) {\n             check (arg.mode == ast.alias);\n-            atys += T_typaram_ptr(cx.tn);\n+            atys += vec(T_typaram_ptr(cx.tn));\n         } else {\n             let TypeRef t;\n             alt (arg.mode) {\n@@ -487,7 +486,7 @@ fn type_of_explicit_args(@crate_ctxt cx,\n                     t = type_of_inner(cx, arg.ty, false);\n                 }\n             }\n-            atys += t;\n+            atys += vec(t);\n         }\n     }\n     ret atys;\n@@ -510,30 +509,30 @@ fn type_of_fn_full(@crate_ctxt cx,\n \n     // Arg 0: Output pointer.\n     if (ty.type_has_dynamic_size(output)) {\n-        atys += T_typaram_ptr(cx.tn);\n+        atys += vec(T_typaram_ptr(cx.tn));\n     } else {\n-        atys += T_ptr(type_of_inner(cx, output, false));\n+        atys += vec(T_ptr(type_of_inner(cx, output, false)));\n     }\n \n     // Arg 1: Task pointer.\n-    atys += T_taskptr(cx.tn);\n+    atys += vec(T_taskptr(cx.tn));\n \n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (obj_self) {\n         case (some[TypeRef](?t)) {\n             check (t as int != 0);\n-            atys += t;\n+            atys += vec(t);\n         }\n         case (_) {\n-            atys += T_opaque_closure_ptr(cx.tn);\n+            atys += vec(T_opaque_closure_ptr(cx.tn));\n         }\n     }\n \n     // Args >3: ty params, if not acquired via capture...\n     if (obj_self == none[TypeRef]) {\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            atys += T_ptr(T_tydesc(cx.tn));\n+            atys += vec(T_ptr(T_tydesc(cx.tn)));\n             i += 1u;\n         }\n     }\n@@ -542,10 +541,11 @@ fn type_of_fn_full(@crate_ctxt cx,\n         // If it's an iter, the 'output' type of the iter is actually the\n         // *input* type of the function we're given as our iter-block\n         // argument.\n-        atys += T_fn_pair(cx.tn,\n+        atys +=\n+            vec(T_fn_pair(cx.tn,\n                           type_of_fn_full(cx, ast.proto_fn, none[TypeRef],\n                                           vec(rec(mode=ast.val, ty=output)),\n-                                          plain_ty(ty.ty_nil), 0u));\n+                                          plain_ty(ty.ty_nil), 0u)));\n     }\n \n     // ... then explicit args.\n@@ -568,12 +568,12 @@ fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n                      @ty.t output) -> TypeRef {\n     let vec[TypeRef] atys = vec();\n     if (abi == ast.native_abi_rust) {\n-        atys += T_taskptr(cx.tn);\n+        atys += vec(T_taskptr(cx.tn));\n         auto t = ty.ty_native_fn(abi, inputs, output);\n         auto ty_param_count = ty.count_ty_params(plain_ty(t));\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            atys += T_ptr(T_tydesc(cx.tn));\n+            atys += vec(T_ptr(T_tydesc(cx.tn)));\n             i += 1u;\n         }\n     }\n@@ -614,23 +614,23 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n                 llty = T_tag(cx.tn, size);\n             }\n         }\n-        case (ty.ty_box(?t)) {\n-            llty = T_ptr(T_box(type_of_inner(cx, t, true)));\n+        case (ty.ty_box(?mt)) {\n+            llty = T_ptr(T_box(type_of_inner(cx, mt.ty, true)));\n         }\n-        case (ty.ty_vec(?t)) {\n-            llty = T_ptr(T_vec(type_of_inner(cx, t, true)));\n+        case (ty.ty_vec(?mt)) {\n+            llty = T_ptr(T_vec(type_of_inner(cx, mt.ty, true)));\n         }\n         case (ty.ty_tup(?elts)) {\n             let vec[TypeRef] tys = vec();\n-            for (@ty.t elt in elts) {\n-                tys += type_of_inner(cx, elt, boxed);\n+            for (ty.mt elt in elts) {\n+                tys += vec(type_of_inner(cx, elt.ty, boxed));\n             }\n             llty = T_struct(tys);\n         }\n         case (ty.ty_rec(?fields)) {\n             let vec[TypeRef] tys = vec();\n             for (ty.field f in fields) {\n-                tys += type_of_inner(cx, f.ty, boxed);\n+                tys += vec(type_of_inner(cx, f.mt.ty, boxed));\n             }\n             llty = T_struct(tys);\n         }\n@@ -650,7 +650,7 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t, bool boxed) -> TypeRef {\n                     type_of_fn_full(cx, m.proto,\n                                     some[TypeRef](self_ty),\n                                     m.inputs, m.output, 0u);\n-                mtys += T_ptr(mty);\n+                mtys += vec(T_ptr(mty));\n             }\n             let TypeRef vtbl = T_struct(mtys);\n             let TypeRef pair = T_struct(vec(T_ptr(vtbl),\n@@ -832,8 +832,7 @@ fn decl_upcall_glue(ModuleRef llmod, type_names tn, uint _n) -> ValueRef {\n     let int n = _n as int;\n     let str s = abi.upcall_glue_name(n);\n     let vec[TypeRef] args =\n-        vec(T_int(),     // callee\n-            T_int()) // taskptr\n+        vec(T_int())     // callee\n         + _vec.init_elt[TypeRef](T_int(), n as uint);\n \n     ret decl_fastcall_fn(llmod, s, T_fn(args, T_int()));\n@@ -864,16 +863,16 @@ fn trans_upcall2(builder b, @glue_fns glues, ValueRef lltaskptr,\n                  &hashmap[str, ValueRef] upcalls,\n                  type_names tn, ModuleRef llmod, str name,\n                  vec[ValueRef] args) -> ValueRef {\n-    let int n = _vec.len[ValueRef](args) as int;\n+    let int n = (_vec.len[ValueRef](args) as int) + 1;\n     let ValueRef llupcall = get_upcall(upcalls, tn, llmod, name, n);\n     llupcall = llvm.LLVMConstPointerCast(llupcall, T_int());\n \n     let ValueRef llglue = glues.upcall_glues.(n);\n     let vec[ValueRef] call_args = vec(llupcall);\n-    call_args += b.PtrToInt(lltaskptr, T_int());\n+    call_args += vec( b.PtrToInt(lltaskptr, T_int()));\n \n     for (ValueRef a in args) {\n-        call_args += b.ZExtOrBitCast(a, T_int());\n+        call_args += vec(b.ZExtOrBitCast(a, T_int()));\n     }\n \n     ret b.FastCall(llglue, call_args);\n@@ -972,8 +971,7 @@ fn static_size_of_tag(@crate_ctxt cx, @ty.t t) -> uint {\n     auto max_size = 0u;\n     auto variants = tag_variants(cx, tid);\n     for (ast.variant variant in variants) {\n-        let vec[@ty.t] tys = variant_types(cx, variant);\n-        auto tup_ty = ty.plain_ty(ty.ty_tup(tys));\n+        auto tup_ty = ty.plain_tup_ty(variant_types(cx, variant));\n \n         // Perform any type parameter substitutions.\n         tup_ty = ty.substitute_ty_params(ty_params, subtys, tup_ty);\n@@ -1022,12 +1020,16 @@ fn dynamic_size_of(@block_ctxt cx, @ty.t t) -> result {\n             ret res(szptr.bcx, szptr.bcx.build.Load(szptr.val));\n         }\n         case (ty.ty_tup(?elts)) {\n-            ret align_elements(cx, elts);\n+            let vec[@ty.t] tys = vec();\n+            for (ty.mt mt in elts) {\n+                tys += vec(mt.ty);\n+            }\n+            ret align_elements(cx, tys);\n         }\n         case (ty.ty_rec(?flds)) {\n             let vec[@ty.t] tys = vec();\n             for (ty.field f in flds) {\n-                tys += vec(f.ty);\n+                tys += vec(f.mt.ty);\n             }\n             ret align_elements(cx, tys);\n         }\n@@ -1073,8 +1075,8 @@ fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n         case (ty.ty_tup(?elts)) {\n             auto a = C_int(1);\n             auto bcx = cx;\n-            for (@ty.t e in elts) {\n-                auto align = align_of(bcx, e);\n+            for (ty.mt e in elts) {\n+                auto align = align_of(bcx, e.ty);\n                 bcx = align.bcx;\n                 a = umax(bcx, a, align.val);\n             }\n@@ -1084,7 +1086,7 @@ fn dynamic_align_of(@block_ctxt cx, @ty.t t) -> result {\n             auto a = C_int(1);\n             auto bcx = cx;\n             for (ty.field f in flds) {\n-                auto align = align_of(bcx, f.ty);\n+                auto align = align_of(bcx, f.mt.ty);\n                 bcx = align.bcx;\n                 a = umax(bcx, a, align.val);\n             }\n@@ -1112,7 +1114,7 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n     if (! ty.type_has_dynamic_size(t)) {\n         let vec[ValueRef] v = vec();\n         for (int i in ixs) {\n-            v += C_int(i);\n+            v += vec(C_int(i));\n         }\n         ret res(cx, cx.build.GEP(base, v));\n     }\n@@ -1159,8 +1161,8 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n         let vec[@ty.t] prefix = vec();\n         let int i = 0;\n         while (i < ix) {\n-            append[@ty.t](prefix, ty.get_element_type(t, i as uint));\n-            i +=1 ;\n+            _vec.push[@ty.t](prefix, ty.get_element_type(t, i as uint));\n+            i += 1 ;\n         }\n \n         auto selected = ty.get_element_type(t, i as uint);\n@@ -1184,7 +1186,7 @@ fn GEP_tup_like(@block_ctxt cx, @ty.t t,\n     // flattened the incoming structure.\n \n     auto s = split_type(t, ixs, 0u);\n-    auto prefix_ty = plain_ty(ty.ty_tup(s.prefix));\n+    auto prefix_ty = ty.plain_tup_ty(s.prefix);\n     auto bcx = cx;\n     auto sz = size_of(bcx, prefix_ty);\n     bcx = sz.bcx;\n@@ -1228,7 +1230,8 @@ fn GEP_tag(@block_ctxt cx,\n \n         i += 1;\n     }\n-    auto tup_ty = ty.plain_ty(ty.ty_tup(true_arg_tys));\n+\n+    auto tup_ty = ty.plain_tup_ty(true_arg_tys);\n \n     // Cast the blob pointer to the appropriate type, if we need to (i.e. if\n     // the blob pointer isn't dynamically sized).\n@@ -1268,8 +1271,8 @@ fn trans_raw_malloc(@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize)\n fn trans_malloc_boxed(@block_ctxt cx, @ty.t t) -> result {\n     // Synthesize a fake box type structurally so we have something\n     // to measure the size of.\n-    auto boxed_body = plain_ty(ty.ty_tup(vec(plain_ty(ty.ty_int), t)));\n-    auto box_ptr = plain_ty(ty.ty_box(t));\n+    auto boxed_body = ty.plain_tup_ty(vec(plain_ty(ty.ty_int), t));\n+    auto box_ptr = ty.plain_box_ty(t);\n     auto sz = size_of(cx, boxed_body);\n     auto llty = type_of(cx.fcx.ccx, box_ptr);\n     ret trans_raw_malloc(sz.bcx, llty, sz.val);\n@@ -1310,8 +1313,8 @@ fn linearize_ty_params(@block_ctxt cx, @ty.t t)\n                         }\n                     }\n                     if (!seen) {\n-                        r.vals += r.cx.fcx.lltydescs.get(pid);\n-                        r.defs += pid;\n+                        r.vals += vec(r.cx.fcx.lltydescs.get(pid));\n+                        r.defs += vec(pid);\n                     }\n                 }\n                 case (_) { }\n@@ -1567,7 +1570,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                                         T_int(), C_int(0));\n         }\n \n-        case (ty.ty_box(?body_ty)) {\n+        case (ty.ty_box(?body_mt)) {\n             fn hit_zero(@block_ctxt cx, ValueRef v,\n                         @ty.t body_ty) -> result {\n                 auto body = cx.build.GEP(v,\n@@ -1580,7 +1583,7 @@ fn make_drop_glue(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n                 ret trans_non_gc_free(res.bcx, v);\n             }\n             ret decr_refcnt_and_if_zero(cx, v,\n-                                        bind hit_zero(_, v, body_ty),\n+                                        bind hit_zero(_, v, body_mt.ty),\n                                         \"free box\",\n                                         T_int(), C_int(0));\n         }\n@@ -1832,7 +1835,7 @@ fn iter_structural_ty_full(@block_ctxt cx,\n         auto box_a_ptr = cx.build.Load(box_a_cell);\n         auto box_b_ptr = cx.build.Load(box_b_cell);\n         auto tnil = plain_ty(ty.ty_nil);\n-        auto tbox = plain_ty(ty.ty_box(tnil));\n+        auto tbox = ty.plain_box_ty(tnil);\n \n         auto inner_cx = new_sub_block_ctxt(cx, \"iter box\");\n         auto next_cx = new_sub_block_ctxt(cx, \"next\");\n@@ -1847,15 +1850,15 @@ fn iter_structural_ty_full(@block_ctxt cx,\n     alt (t.struct) {\n         case (ty.ty_tup(?args)) {\n             let int i = 0;\n-            for (@ty.t arg in args) {\n+            for (ty.mt arg in args) {\n                 r = GEP_tup_like(r.bcx, t, av, vec(0, i));\n                 auto elt_a = r.val;\n                 r = GEP_tup_like(r.bcx, t, bv, vec(0, i));\n                 auto elt_b = r.val;\n                 r = f(r.bcx,\n-                      load_scalar_or_boxed(r.bcx, elt_a, arg),\n-                      load_scalar_or_boxed(r.bcx, elt_b, arg),\n-                      arg);\n+                      load_scalar_or_boxed(r.bcx, elt_a, arg.ty),\n+                      load_scalar_or_boxed(r.bcx, elt_b, arg.ty),\n+                      arg.ty);\n                 i += 1;\n             }\n         }\n@@ -1867,9 +1870,9 @@ fn iter_structural_ty_full(@block_ctxt cx,\n                 r = GEP_tup_like(r.bcx, t, bv, vec(0, i));\n                 auto llfld_b = r.val;\n                 r = f(r.bcx,\n-                      load_scalar_or_boxed(r.bcx, llfld_a, fld.ty),\n-                      load_scalar_or_boxed(r.bcx, llfld_b, fld.ty),\n-                      fld.ty);\n+                      load_scalar_or_boxed(r.bcx, llfld_a, fld.mt.ty),\n+                      load_scalar_or_boxed(r.bcx, llfld_b, fld.mt.ty),\n+                      fld.mt.ty);\n                 i += 1;\n             }\n         }\n@@ -2107,8 +2110,8 @@ fn iter_sequence(@block_ctxt cx,\n     }\n \n     alt (t.struct) {\n-        case (ty.ty_vec(?et)) {\n-            ret iter_sequence_body(cx, v, et, f, false);\n+        case (ty.ty_vec(?elt)) {\n+            ret iter_sequence_body(cx, v, elt.ty, f, false);\n         }\n         case (ty.ty_str) {\n             auto et = plain_ty(ty.ty_machine(common.ty_u8));\n@@ -2365,7 +2368,7 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n             auto box_ty = node_ann_type(sub.bcx.fcx.ccx, a);\n             sub = trans_malloc_boxed(sub.bcx, e_ty);\n             find_scope_cx(cx).cleanups +=\n-                clean(bind drop_ty(_, sub.val, box_ty));\n+                vec(clean(bind drop_ty(_, sub.val, box_ty)));\n \n             auto box = sub.val;\n             auto rc = sub.bcx.build.GEP(box,\n@@ -2398,9 +2401,6 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n             }\n             ret res(sub.bcx, val);\n         }\n-        case (ast._mutable) {\n-            ret trans_expr(cx, e);\n-        }\n     }\n     fail;\n }\n@@ -2646,7 +2646,8 @@ fn trans_vec_add(@block_ctxt cx, @ty.t t,\n     r = copy_ty(r.bcx, INIT, tmp, lhs, t);\n     auto bcx = trans_vec_append(r.bcx, t, tmp, rhs).bcx;\n     tmp = load_scalar_or_boxed(bcx, tmp, t);\n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, tmp, t));\n+    find_scope_cx(cx).cleanups +=\n+        vec(clean(bind drop_ty(_, tmp, t)));\n     ret res(bcx, tmp);\n }\n \n@@ -2698,12 +2699,12 @@ fn autoderef(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n \n     while (true) {\n         alt (t1.struct) {\n-            case (ty.ty_box(?inner)) {\n+            case (ty.ty_box(?mt)) {\n                 auto body = cx.build.GEP(v1,\n                                          vec(C_int(0),\n                                              C_int(abi.box_rc_field_body)));\n-                t1 = inner;\n-                v1 = load_scalar_or_boxed(cx, body, inner);\n+                t1 = mt.ty;\n+                v1 = load_scalar_or_boxed(cx, body, t1);\n             }\n             case (_) {\n                 ret res(cx, v1);\n@@ -2717,8 +2718,8 @@ fn autoderefed_ty(@ty.t t) -> @ty.t {\n \n     while (true) {\n         alt (t1.struct) {\n-            case (ty.ty_box(?inner)) {\n-                t1 = inner;\n+            case (ty.ty_box(?mt)) {\n+                t1 = mt.ty;\n             }\n             case (_) {\n                 ret t1;\n@@ -2800,9 +2801,9 @@ fn join_results(@block_ctxt parent_cx,\n \n     for (result r in ins) {\n         if (! is_terminated(r.bcx)) {\n-            live += r;\n-            vals += r.val;\n-            bbs += r.bcx.llbb;\n+            live += vec(r);\n+            vals += vec(r.val);\n+            bbs += vec(r.bcx.llbb);\n         }\n     }\n \n@@ -2875,7 +2876,8 @@ fn trans_for(@block_ctxt cx,\n         cx.build.Br(scope_cx.llbb);\n         auto local_res = alloc_local(scope_cx, local);\n         auto bcx = copy_ty(local_res.bcx, INIT, local_res.val, curr, t).bcx;\n-        scope_cx.cleanups += clean(bind drop_slot(_, local_res.val, t));\n+        scope_cx.cleanups +=\n+            vec(clean(bind drop_slot(_, local_res.val, t)));\n         bcx = trans_block(bcx, body).bcx;\n         bcx.build.Br(next_cx.llbb);\n         ret res(next_cx, C_nil());\n@@ -3245,7 +3247,8 @@ fn trans_pat_binding(@block_ctxt cx, @ast.pat pat, ValueRef llval)\n \n             llvm.LLVMSetValueName(dst, _str.buf(id));\n             bcx.fcx.lllocals.insert(def_id, dst);\n-            bcx.cleanups += clean(bind drop_slot(_, dst, ty));\n+            bcx.cleanups +=\n+                vec(clean(bind drop_slot(_, dst, ty)));\n \n             ret copy_ty(bcx, INIT, dst, llval, ty);\n         }\n@@ -3368,7 +3371,7 @@ fn lval_generic_fn(@block_ctxt cx,\n         for (@ty.t t in tys) {\n             auto td = get_tydesc(bcx, t);\n             bcx = td.bcx;\n-            append[ValueRef](tydescs, td.val);\n+            _vec.push[ValueRef](tydescs, td.val);\n         }\n         auto gen = rec( item_type = tpt._1,\n                         tydescs = tydescs );\n@@ -3481,7 +3484,7 @@ fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n     r = autoderef(r.bcx, r.val, t);\n     t = autoderefed_ty(t);\n     alt (t.struct) {\n-        case (ty.ty_tup(?fields)) {\n+        case (ty.ty_tup(_)) {\n             let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n             auto v = GEP_tup_like(r.bcx, t, r.val, vec(0, ix as int));\n             ret lval_mem(v.bcx, v.val);\n@@ -3621,7 +3624,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n     auto fcx = new_fn_ctxt(cx, llthunk);\n     auto bcx = new_top_block_ctxt(fcx);\n \n-    auto llclosure_ptr_ty = type_of(cx, plain_ty(ty.ty_box(closure_ty)));\n+    auto llclosure_ptr_ty = type_of(cx, ty.plain_box_ty(closure_ty));\n     auto llclosure = bcx.build.PointerCast(fcx.llenv, llclosure_ptr_ty);\n \n     auto lltarget = GEP_tup_like(bcx, closure_ty, llclosure,\n@@ -3692,7 +3695,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n                     val = bcx.build.PointerCast(val, llout_arg_ty);\n                 }\n \n-                llargs += val;\n+                llargs += vec(val);\n                 b += 1;\n             }\n \n@@ -3706,7 +3709,7 @@ fn trans_bind_thunk(@crate_ctxt cx,\n                                                        llout_arg_ty);\n                 }\n \n-                llargs += passed_arg;\n+                llargs += vec(passed_arg);\n                 a += 1u;\n             }\n         }\n@@ -3750,7 +3753,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 case (none[@ast.expr]) {\n                 }\n                 case (some[@ast.expr](?e)) {\n-                    append[@ast.expr](bound, e);\n+                    _vec.push[@ast.expr](bound, e);\n                 }\n             }\n         }\n@@ -3786,14 +3789,14 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 auto arg = trans_expr(bcx, e);\n                 bcx = arg.bcx;\n \n-                append[ValueRef](bound_vals, arg.val);\n-                append[@ty.t](bound_tys, ty.expr_ty(e));\n+                _vec.push[ValueRef](bound_vals, arg.val);\n+                _vec.push[@ty.t](bound_tys, ty.expr_ty(e));\n \n                 i += 1u;\n             }\n \n             // Synthesize a closure type.\n-            let @ty.t bindings_ty = plain_ty(ty.ty_tup(bound_tys));\n+            let @ty.t bindings_ty = ty.plain_tup_ty(bound_tys);\n \n             // NB: keep this in sync with T_closure_ptr; we're making\n             // a ty.t structure that has the same \"shape\" as the LLVM type\n@@ -3807,9 +3810,9 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                 vec(tydesc_ty,\n                     outgoing_fty,\n                     bindings_ty,\n-                    plain_ty(ty.ty_tup(captured_tys)));\n+                    ty.plain_tup_ty(captured_tys));\n \n-            let @ty.t closure_ty = plain_ty(ty.ty_tup(closure_tys));\n+            let @ty.t closure_ty = ty.plain_tup_ty(closure_tys);\n \n             auto r = trans_malloc_boxed(bcx, closure_ty);\n             auto box = r.val;\n@@ -3914,7 +3917,7 @@ fn trans_bind(@block_ctxt cx, @ast.expr f,\n                  pair_box);\n \n             find_scope_cx(cx).cleanups +=\n-                clean(bind drop_slot(_, pair_v, pair_ty));\n+                vec(clean(bind drop_slot(_, pair_v, pair_ty)));\n \n             ret res(bcx, pair_v);\n         }\n@@ -3959,34 +3962,35 @@ fn trans_args(@block_ctxt cx,\n         }\n     }\n     if (ty.type_has_dynamic_size(retty)) {\n-        llargs += bcx.build.PointerCast(llretslot,\n-                                        T_typaram_ptr(cx.fcx.ccx.tn));\n+        llargs += vec(bcx.build.PointerCast(llretslot,\n+                                            T_typaram_ptr(cx.fcx.ccx.tn)));\n     } else if (ty.count_ty_params(retty) != 0u) {\n         // It's possible that the callee has some generic-ness somewhere in\n         // its return value -- say a method signature within an obj or a fn\n         // type deep in a structure -- which the caller has a concrete view\n         // of. If so, cast the caller's view of the restlot to the callee's\n         // view, for the sake of making a type-compatible call.\n-        llargs += cx.build.PointerCast(llretslot,\n-                                       T_ptr(type_of(bcx.fcx.ccx, retty)));\n+        llargs +=\n+            vec(cx.build.PointerCast(llretslot,\n+                                     T_ptr(type_of(bcx.fcx.ccx, retty))));\n     } else {\n-        llargs += llretslot;\n+        llargs += vec(llretslot);\n     }\n \n \n     // Arg 1: Task pointer.\n-    llargs += bcx.fcx.lltaskptr;\n+    llargs += vec(bcx.fcx.lltaskptr);\n \n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (llobj) {\n         case (some[ValueRef](?ob)) {\n             // Every object is always found in memory,\n             // and not-yet-loaded (as part of an lval x.y\n             // doted method-call).\n-            llargs += bcx.build.Load(ob);\n+            llargs += vec(bcx.build.Load(ob));\n         }\n         case (_) {\n-            llargs += llenv;\n+            llargs += vec(llenv);\n         }\n     }\n \n@@ -3997,7 +4001,7 @@ fn trans_args(@block_ctxt cx,\n     alt (lliterbody) {\n         case (none[ValueRef]) {}\n         case (some[ValueRef](?lli)) {\n-            llargs += lli;\n+            llargs += vec(lli);\n         }\n     }\n \n@@ -4054,7 +4058,7 @@ fn trans_args(@block_ctxt cx,\n             val = bcx.build.PointerCast(val, lldestty);\n         }\n \n-        llargs += val;\n+        llargs += vec(val);\n         i += 1u;\n     }\n \n@@ -4116,7 +4120,8 @@ fn trans_call(@block_ctxt cx, @ast.expr f,\n         // Retval doesn't correspond to anything really tangible in the frame,\n         // but it's a ref all the same, so we put a note here to drop it when\n         // we're done in this scope.\n-        find_scope_cx(cx).cleanups += clean(bind drop_ty(_, retval, ret_ty));\n+        find_scope_cx(cx).cleanups +=\n+            vec(clean(bind drop_ty(_, retval, ret_ty)));\n     }\n \n     ret res(bcx, retval);\n@@ -4130,7 +4135,8 @@ fn trans_tup(@block_ctxt cx, vec[ast.elt] elts,\n     auto tup_val = tup_res.val;\n     bcx = tup_res.bcx;\n \n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, tup_val, t));\n+    find_scope_cx(cx).cleanups +=\n+        vec(clean(bind drop_ty(_, tup_val, t)));\n     let int i = 0;\n \n     for (ast.elt e in elts) {\n@@ -4150,8 +4156,8 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n     auto t = node_ann_type(cx.fcx.ccx, ann);\n     auto unit_ty = t;\n     alt (t.struct) {\n-        case (ty.ty_vec(?t)) {\n-            unit_ty = t;\n+        case (ty.ty_vec(?mt)) {\n+            unit_ty = mt.ty;\n         }\n         case (_) {\n             cx.fcx.ccx.sess.bug(\"non-vec type in trans_vec\");\n@@ -4171,14 +4177,15 @@ fn trans_vec(@block_ctxt cx, vec[@ast.expr] args,\n \n     auto llty = type_of(bcx.fcx.ccx, t);\n     auto vec_val = vi2p(bcx, sub.val, llty);\n-    find_scope_cx(bcx).cleanups += clean(bind drop_ty(_, vec_val, t));\n+    find_scope_cx(bcx).cleanups +=\n+        vec(clean(bind drop_ty(_, vec_val, t)));\n \n     auto body = bcx.build.GEP(vec_val, vec(C_int(0),\n                                            C_int(abi.vec_elt_data)));\n \n     auto pseudo_tup_ty =\n-        plain_ty(ty.ty_tup(_vec.init_elt[@ty.t](unit_ty,\n-                                                _vec.len[@ast.expr](args))));\n+        ty.plain_tup_ty(_vec.init_elt[@ty.t](unit_ty,\n+                                             _vec.len[@ast.expr](args)));\n     let int i = 0;\n \n     for (@ast.expr e in args) {\n@@ -4226,7 +4233,8 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n     auto rec_val = rec_res.val;\n     bcx = rec_res.bcx;\n \n-    find_scope_cx(cx).cleanups += clean(bind drop_ty(_, rec_val, t));\n+    find_scope_cx(cx).cleanups +=\n+        vec(clean(bind drop_ty(_, rec_val, t)));\n     let int i = 0;\n \n     auto base_val = C_nil();\n@@ -4246,7 +4254,7 @@ fn trans_rec(@block_ctxt cx, vec[ast.field] fields,\n     }\n \n     for (ty.field tf in ty_fields) {\n-        auto e_ty = tf.ty;\n+        auto e_ty = tf.mt.ty;\n         auto dst_res = GEP_tup_like(bcx, t, rec_val, vec(0, i));\n         bcx = dst_res.bcx;\n \n@@ -4352,7 +4360,7 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             ret trans_cast(cx, e, ann);\n         }\n \n-        case (ast.expr_vec(?args, ?ann)) {\n+        case (ast.expr_vec(?args, _, ?ann)) {\n             ret trans_vec(cx, args, ann);\n         }\n \n@@ -4499,7 +4507,7 @@ fn trans_put(@block_ctxt cx, &option.t[@ast.expr] e) -> result {\n                 llarg = bcx.build.Load(llarg);\n             }\n \n-            llargs += llarg;\n+            llargs += vec(llarg);\n         }\n     }\n \n@@ -4557,7 +4565,7 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n     auto bcx = cx;\n \n     find_scope_cx(cx).cleanups +=\n-        clean(bind drop_slot(_, llptr, ty));\n+        vec(clean(bind drop_slot(_, llptr, ty)));\n \n     alt (local.init) {\n         case (some[@ast.expr](?e)) {\n@@ -4903,7 +4911,7 @@ fn populate_fn_ctxt_from_llself(@block_ctxt cx, ValueRef llself) -> result {\n \n     // Synthesize a tuple type for the fields so that GEP_tup_like() can work\n     // its magic.\n-    auto fields_tup_ty = ty.plain_ty(ty.ty_tup(field_tys));\n+    auto fields_tup_ty = ty.plain_tup_ty(field_tys);\n \n     auto n_typarams = _vec.len[ast.ty_param](bcx.fcx.ccx.obj_typarams);\n     let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.ccx.tn, n_typarams);\n@@ -5026,7 +5034,7 @@ fn trans_vtbl(@crate_ctxt cx, TypeRef self_ty,\n \n         trans_fn(mcx, m.node.meth, m.node.id, some[TypeRef](self_ty),\n                  ty_params, m.node.ann);\n-        methods += llfn;\n+        methods += vec(llfn);\n     }\n     auto vtbl = C_struct(methods);\n     auto gvar = llvm.LLVMAddGlobal(cx.llmod,\n@@ -5085,22 +5093,22 @@ fn trans_obj(@crate_ctxt cx, &ast._obj ob, ast.def_id oid,\n         // Malloc a box for the body and copy args in.\n         let vec[@ty.t] obj_fields = vec();\n         for (ty.arg a in arg_tys) {\n-            append[@ty.t](obj_fields, a.ty);\n+            _vec.push[@ty.t](obj_fields, a.ty);\n         }\n \n         // Synthesize an obj body type.\n         auto tydesc_ty = plain_ty(ty.ty_type);\n         let vec[@ty.t] tps = vec();\n         for (ast.ty_param tp in ty_params) {\n-            append[@ty.t](tps, tydesc_ty);\n+            _vec.push[@ty.t](tps, tydesc_ty);\n         }\n \n-        let @ty.t typarams_ty = plain_ty(ty.ty_tup(tps));\n-        let @ty.t fields_ty = plain_ty(ty.ty_tup(obj_fields));\n-        let @ty.t body_ty = plain_ty(ty.ty_tup(vec(tydesc_ty,\n-                                                   typarams_ty,\n-                                                   fields_ty)));\n-        let @ty.t boxed_body_ty = plain_ty(ty.ty_box(body_ty));\n+        let @ty.t typarams_ty = ty.plain_tup_ty(tps);\n+        let @ty.t fields_ty = ty.plain_tup_ty(obj_fields);\n+        let @ty.t body_ty = ty.plain_tup_ty(vec(tydesc_ty,\n+                                                typarams_ty,\n+                                                fields_ty));\n+        let @ty.t boxed_body_ty = ty.plain_box_ty(body_ty);\n \n         // Malloc a box for the body.\n         auto box = trans_malloc_boxed(bcx, body_ty);\n@@ -6090,7 +6098,7 @@ fn make_glues(ModuleRef llmod, type_names tn) -> @glue_fns {\n \n              upcall_glues =\n              _vec.init_fn[ValueRef](bind decl_upcall_glue(llmod, tn, _),\n-                                    abi.n_upcall_glues as uint),\n+                                    abi.n_upcall_glues + 1 as uint),\n              no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n              memcpy_glue = decl_memcpy_glue(llmod),\n              bzero_glue = decl_bzero_glue(llmod),"}, {"sha": "5fdb4dc2d2cf74bf50f1a1ba77d4b0040a2eb6d7", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 176, "deletions": 89, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -11,22 +11,23 @@ import driver.session;\n import front.ast;\n import front.ast.mutability;\n import util.common;\n-import util.common.append;\n import util.common.new_def_hash;\n import util.common.span;\n \n // Data types\n \n type arg = rec(ast.mode mode, @t ty);\n-type field = rec(ast.ident ident, @t ty);\n+type field = rec(ast.ident ident, mt mt);\n type method = rec(ast.proto proto,\n                   ast.ident ident,\n                   vec[arg] inputs,\n                   @t output);\n \n+type mt = rec(@t ty, ast.mutability mut);\n+\n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast.rs as well.\n-type t = rec(sty struct, mutability mut, option.t[str] cname);\n+type t = rec(sty struct, option.t[str] cname);\n tag sty {\n     ty_nil;\n     ty_bool;\n@@ -36,11 +37,11 @@ tag sty {\n     ty_char;\n     ty_str;\n     ty_tag(ast.def_id, vec[@t]);\n-    ty_box(@t);\n-    ty_vec(@t);\n+    ty_box(mt);\n+    ty_vec(mt);\n     ty_port(@t);\n     ty_chan(@t);\n-    ty_tup(vec[@t]);\n+    ty_tup(vec[mt]);\n     ty_rec(vec[field]);\n     ty_fn(ast.proto, vec[arg], @t);                 // TODO: effect\n     ty_native_fn(ast.native_abi, vec[arg], @t);     // TODO: effect\n@@ -66,6 +67,8 @@ type unify_handler = obj {\n \n tag type_err {\n     terr_mismatch;\n+    terr_box_mutability;\n+    terr_vec_mutability;\n     terr_tuple_size(uint, uint);\n     terr_tuple_mutability;\n     terr_record_size(uint, uint);\n@@ -139,44 +142,51 @@ fn ty_to_str(&@t typ) -> str {\n     }\n \n     fn field_to_str(&field f) -> str {\n-        ret ty_to_str(f.ty) + \" \" + f.ident;\n+        ret mt_to_str(f.mt) + \" \" + f.ident;\n     }\n \n-    auto s = \"\";\n-    if (typ.mut == ast.mut) {\n-        s += \"mutable \";\n+    fn mt_to_str(&mt m) -> str {\n+        auto mstr;\n+        alt (m.mut) {\n+            case (ast.mut)       { mstr = \"mutable \"; }\n+            case (ast.imm)       { mstr = \"\";         }\n+            case (ast.maybe_mut) { mstr = \"mutable? \"; }\n+        }\n+\n+        ret mstr + ty_to_str(m.ty);\n     }\n \n+    auto s = \"\";\n     alt (typ.struct) {\n-        case (ty_native)       { s = \"native\";                     }\n-        case (ty_nil)          { s = \"()\";                         }\n-        case (ty_bool)         { s = \"bool\";                       }\n-        case (ty_int)          { s = \"int\";                        }\n-        case (ty_uint)         { s = \"uint\";                       }\n-        case (ty_machine(?tm)) { s = common.ty_mach_to_str(tm);    }\n-        case (ty_char)         { s = \"char\";                       }\n-        case (ty_str)          { s = \"str\";                        }\n-        case (ty_box(?t))      { s = \"@\" + ty_to_str(t);           }\n-        case (ty_vec(?t))      { s = \"vec[\" + ty_to_str(t) + \"]\";  }\n-        case (ty_port(?t))     { s = \"port[\" + ty_to_str(t) + \"]\"; }\n-        case (ty_chan(?t))     { s = \"chan[\" + ty_to_str(t) + \"]\"; }\n-        case (ty_type)         { s = \"type\";                       }\n+        case (ty_native)       { s += \"native\";                     }\n+        case (ty_nil)          { s += \"()\";                         }\n+        case (ty_bool)         { s += \"bool\";                       }\n+        case (ty_int)          { s += \"int\";                        }\n+        case (ty_uint)         { s += \"uint\";                       }\n+        case (ty_machine(?tm)) { s += common.ty_mach_to_str(tm);    }\n+        case (ty_char)         { s += \"char\";                       }\n+        case (ty_str)          { s += \"str\";                        }\n+        case (ty_box(?tm))     { s += \"@\" + mt_to_str(tm);          }\n+        case (ty_vec(?tm))     { s += \"vec[\" + mt_to_str(tm) + \"]\"; }\n+        case (ty_port(?t))     { s += \"port[\" + ty_to_str(t) + \"]\"; }\n+        case (ty_chan(?t))     { s += \"chan[\" + ty_to_str(t) + \"]\"; }\n+        case (ty_type)         { s += \"type\";                       }\n \n         case (ty_tup(?elems)) {\n-            auto f = ty_to_str;\n-            auto strs = _vec.map[@t,str](f, elems);\n-            s = \"tup(\" + _str.connect(strs, \",\") + \")\";\n+            auto f = mt_to_str;\n+            auto strs = _vec.map[mt,str](f, elems);\n+            s += \"tup(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n         case (ty_rec(?elems)) {\n             auto f = field_to_str;\n             auto strs = _vec.map[field,str](f, elems);\n-            s = \"rec(\" + _str.connect(strs, \",\") + \")\";\n+            s += \"rec(\" + _str.connect(strs, \",\") + \")\";\n         }\n \n         case (ty_tag(?id, ?tps)) {\n             // The user should never see this if the cname is set properly!\n-            s = \"<tag#\" + util.common.istr(id._0) + \":\" +\n+            s += \"<tag#\" + util.common.istr(id._0) + \":\" +\n                 util.common.istr(id._1) + \">\";\n             if (_vec.len[@t](tps) > 0u) {\n                 auto f = ty_to_str;\n@@ -186,31 +196,31 @@ fn ty_to_str(&@t typ) -> str {\n         }\n \n         case (ty_fn(?proto, ?inputs, ?output)) {\n-            s = fn_to_str(proto, none[ast.ident], inputs, output);\n+            s += fn_to_str(proto, none[ast.ident], inputs, output);\n         }\n \n         case (ty_native_fn(_, ?inputs, ?output)) {\n-            s = fn_to_str(ast.proto_fn, none[ast.ident], inputs, output);\n+            s += fn_to_str(ast.proto_fn, none[ast.ident], inputs, output);\n         }\n \n         case (ty_obj(?meths)) {\n             auto f = method_to_str;\n             auto m = _vec.map[method,str](f, meths);\n-            s = \"obj {\\n\\t\" + _str.connect(m, \"\\n\\t\") + \"\\n}\";\n+            s += \"obj {\\n\\t\" + _str.connect(m, \"\\n\\t\") + \"\\n}\";\n         }\n \n         case (ty_var(?v)) {\n-            s = \"<T\" + util.common.istr(v) + \">\";\n+            s += \"<T\" + util.common.istr(v) + \">\";\n         }\n \n         case (ty_local(?id)) {\n-            s = \"<L\" + util.common.istr(id._0) + \":\" + util.common.istr(id._1)\n-                + \">\";\n+            s += \"<L\" + util.common.istr(id._0) + \":\" +\n+                util.common.istr(id._1) + \">\";\n         }\n \n         case (ty_param(?id)) {\n-            s = \"<P\" + util.common.istr(id._0) + \":\" + util.common.istr(id._1)\n-                + \">\";\n+            s += \"<P\" + util.common.istr(id._0) + \":\" +\n+                util.common.istr(id._1) + \">\";\n         }\n     }\n \n@@ -225,7 +235,7 @@ type ty_fold = state obj {\n \n fn fold_ty(ty_fold fld, @t ty) -> @t {\n     fn rewrap(@t orig, &sty new) -> @t {\n-        ret @rec(struct=new, mut=orig.mut, cname=orig.cname);\n+        ret @rec(struct=new, cname=orig.cname);\n     }\n \n     alt (ty.struct) {\n@@ -238,11 +248,11 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n         case (ty_str)           { ret fld.fold_simple_ty(ty); }\n         case (ty_type)          { ret fld.fold_simple_ty(ty); }\n         case (ty_native)        { ret fld.fold_simple_ty(ty); }\n-        case (ty_box(?subty)) {\n-            ret rewrap(ty, ty_box(fold_ty(fld, subty)));\n+        case (ty_box(?tm)) {\n+            ret rewrap(ty, ty_box(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)));\n         }\n-        case (ty_vec(?subty)) {\n-            ret rewrap(ty, ty_vec(fold_ty(fld, subty)));\n+        case (ty_vec(?tm)) {\n+            ret rewrap(ty, ty_vec(rec(ty=fold_ty(fld, tm.ty), mut=tm.mut)));\n         }\n         case (ty_port(?subty)) {\n             ret rewrap(ty, ty_port(fold_ty(fld, subty)));\n@@ -257,18 +267,20 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n             }\n             ret rewrap(ty, ty_tag(tid, new_subtys));\n         }\n-        case (ty_tup(?subtys)) {\n-            let vec[@t] new_subtys = vec();\n-            for (@t subty in subtys) {\n-                new_subtys += vec(fold_ty(fld, subty));\n+        case (ty_tup(?mts)) {\n+            let vec[mt] new_mts = vec();\n+            for (mt tm in mts) {\n+                auto new_subty = fold_ty(fld, tm.ty);\n+                new_mts += vec(rec(ty=new_subty, mut=tm.mut));\n             }\n-            ret rewrap(ty, ty_tup(new_subtys));\n+            ret rewrap(ty, ty_tup(new_mts));\n         }\n         case (ty_rec(?fields)) {\n             let vec[field] new_fields = vec();\n             for (field fl in fields) {\n-                auto new_ty = fold_ty(fld, fl.ty);\n-                new_fields += vec(rec(ident=fl.ident, ty=new_ty));\n+                auto new_ty = fold_ty(fld, fl.mt.ty);\n+                auto new_mt = rec(ty=new_ty, mut=fl.mt.mut);\n+                new_fields += vec(rec(ident=fl.ident, mt=new_mt));\n             }\n             ret rewrap(ty, ty_rec(new_fields));\n         }\n@@ -352,8 +364,8 @@ fn type_is_sequence(@t ty) -> bool {\n \n fn sequence_element_type(@t ty) -> @t {\n     alt (ty.struct) {\n-        case (ty_str)     { ret plain_ty(ty_machine(common.ty_u8)); }\n-        case (ty_vec(?e)) { ret e; }\n+        case (ty_str)      { ret plain_ty(ty_machine(common.ty_u8)); }\n+        case (ty_vec(?mt)) { ret mt.ty; }\n     }\n     fail;\n }\n@@ -373,11 +385,11 @@ fn type_is_tup_like(@t ty) -> bool {\n fn get_element_type(@t ty, uint i) -> @t {\n     check (type_is_tup_like(ty));\n     alt (ty.struct) {\n-        case (ty_tup(?tys)) {\n-            ret tys.(i);\n+        case (ty_tup(?mts)) {\n+            ret mts.(i).ty;\n         }\n         case (ty_rec(?flds)) {\n-            ret flds.(i).ty;\n+            ret flds.(i).mt.ty;\n         }\n     }\n     fail;\n@@ -410,6 +422,7 @@ fn type_is_scalar(@t ty) -> bool {\n         case (ty_machine(_)) { ret true; }\n         case (ty_char) { ret true; }\n         case (ty_type) { ret true; }\n+        case (ty_native) { ret true; }\n         case (_) { ret false; }\n     }\n     fail;\n@@ -427,17 +440,17 @@ fn type_is_native(@t ty) -> bool {\n \n fn type_has_dynamic_size(@t ty) -> bool {\n     alt (ty.struct) {\n-        case (ty_tup(?ts)) {\n+        case (ty_tup(?mts)) {\n             auto i = 0u;\n-            while (i < _vec.len[@t](ts)) {\n-                if (type_has_dynamic_size(ts.(i))) { ret true; }\n+            while (i < _vec.len[mt](mts)) {\n+                if (type_has_dynamic_size(mts.(i).ty)) { ret true; }\n                 i += 1u;\n             }\n         }\n         case (ty_rec(?fields)) {\n             auto i = 0u;\n             while (i < _vec.len[field](fields)) {\n-                if (type_has_dynamic_size(fields.(i).ty)) { ret true; }\n+                if (type_has_dynamic_size(fields.(i).mt.ty)) { ret true; }\n                 i += 1u;\n             }\n         }\n@@ -518,7 +531,19 @@ fn type_param(@t ty) -> option.t[ast.def_id] {\n }\n \n fn plain_ty(&sty st) -> @t {\n-    ret @rec(struct=st, mut=ast.imm, cname=none[str]);\n+    ret @rec(struct=st, cname=none[str]);\n+}\n+\n+fn plain_box_ty(@t subty) -> @t {\n+    ret plain_ty(ty_box(rec(ty=subty, mut=ast.imm)));\n+}\n+\n+fn plain_tup_ty(vec[@t] elem_tys) -> @t {\n+    let vec[ty.mt] mts = vec();\n+    for (@ty.t typ in elem_tys) {\n+        mts += vec(rec(ty=typ, mut=ast.imm));\n+    }\n+    ret plain_ty(ty_tup(mts));\n }\n \n fn hash_ty(&@t ty) -> uint {\n@@ -703,7 +728,7 @@ fn pat_ty(@ast.pat pat) -> @t {\n \n fn expr_ty(@ast.expr expr) -> @t {\n     alt (expr.node) {\n-        case (ast.expr_vec(_, ?ann))          { ret ann_to_type(ann); }\n+        case (ast.expr_vec(_, _, ?ann))       { ret ann_to_type(ann); }\n         case (ast.expr_tup(_, ?ann))          { ret ann_to_type(ann); }\n         case (ast.expr_rec(_, _, ?ann))       { ret ann_to_type(ann); }\n         case (ast.expr_bind(_, _, ?ann))      { ret ann_to_type(ann); }\n@@ -756,7 +781,7 @@ fn field_num(session.session sess, &span sp, &ast.ident id) -> uint {\n                 accum += (c as uint) - ('0' as uint);\n             } else {\n                 auto s = \"\";\n-                s += c;\n+                s += _str.unsafe_from_byte(c);\n                 sess.span_err(sp,\n                               \"bad numeric field on tuple: \"\n                               + \" non-digit character: \"\n@@ -794,6 +819,14 @@ fn method_idx(session.session sess, &span sp,\n     fail;\n }\n \n+fn sort_methods(vec[method] meths) -> vec[method] {\n+    fn method_lteq(&method a, &method b) -> bool {\n+        ret _str.lteq(a.ident, b.ident);\n+    }\n+\n+    ret std.sort.merge_sort[method](bind method_lteq(_,_), meths);\n+}\n+\n fn is_lval(@ast.expr expr) -> bool {\n     alt (expr.node) {\n         case (ast.expr_field(_,_,_))    { ret true;  }\n@@ -826,6 +859,21 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n         ret ures_err(terr_mismatch, expected, actual);\n     }\n \n+    // Unifies two mutability flags.\n+    fn unify_mut(ast.mutability expected, ast.mutability actual)\n+            -> option.t[ast.mutability] {\n+        if (expected == actual) {\n+            ret some[ast.mutability](expected);\n+        }\n+        if (expected == ast.maybe_mut) {\n+            ret some[ast.mutability](actual);\n+        }\n+        if (actual == ast.maybe_mut) {\n+            ret some[ast.mutability](expected);\n+        }\n+        ret none[ast.mutability];\n+    }\n+\n     tag fn_common_res {\n         fn_common_res_err(unify_result);\n         fn_common_res_ok(vec[arg], @t);\n@@ -1104,7 +1152,7 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n \n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    append[@ty.t](result_tps, rty);\n+                                    _vec.push[@ty.t](result_tps, rty);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -1123,16 +1171,26 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 ret ures_err(terr_mismatch, expected, actual);\n             }\n \n-            case (ty.ty_box(?expected_sub)) {\n+            case (ty.ty_box(?expected_mt)) {\n                 alt (actual.struct) {\n-                    case (ty.ty_box(?actual_sub)) {\n+                    case (ty.ty_box(?actual_mt)) {\n+                        auto mut;\n+                        alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n+                            case (none[ast.mutability]) {\n+                                ret ures_err(terr_box_mutability, expected,\n+                                             actual);\n+                            }\n+                            case (some[ast.mutability](?m)) { mut = m; }\n+                        }\n+\n                         auto result = unify_step(bindings,\n-                                                 expected_sub,\n-                                                 actual_sub,\n+                                                 expected_mt.ty,\n+                                                 actual_mt.ty,\n                                                  handler);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(plain_ty(ty.ty_box(result_sub)));\n+                                auto mt = rec(ty=result_sub, mut=mut);\n+                                ret ures_ok(plain_ty(ty.ty_box(mt)));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1146,16 +1204,26 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 }\n             }\n \n-            case (ty.ty_vec(?expected_sub)) {\n+            case (ty.ty_vec(?expected_mt)) {\n                 alt (actual.struct) {\n-                    case (ty.ty_vec(?actual_sub)) {\n+                    case (ty.ty_vec(?actual_mt)) {\n+                        auto mut;\n+                        alt (unify_mut(expected_mt.mut, actual_mt.mut)) {\n+                            case (none[ast.mutability]) {\n+                                ret ures_err(terr_vec_mutability, expected,\n+                                             actual);\n+                            }\n+                            case (some[ast.mutability](?m)) { mut = m; }\n+                        }\n+\n                         auto result = unify_step(bindings,\n-                                                 expected_sub,\n-                                                 actual_sub,\n+                                                 expected_mt.ty,\n+                                                 actual_mt.ty,\n                                                  handler);\n                         alt (result) {\n                             case (ures_ok(?result_sub)) {\n-                                ret ures_ok(plain_ty(ty.ty_vec(result_sub)));\n+                                auto mt = rec(ty=result_sub, mut=mut);\n+                                ret ures_ok(plain_ty(ty.ty_vec(mt)));\n                             }\n                             case (_) {\n                                 ret result;\n@@ -1218,8 +1286,8 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n             case (ty.ty_tup(?expected_elems)) {\n                 alt (actual.struct) {\n                     case (ty.ty_tup(?actual_elems)) {\n-                        auto expected_len = _vec.len[@ty.t](expected_elems);\n-                        auto actual_len = _vec.len[@ty.t](actual_elems);\n+                        auto expected_len = _vec.len[ty.mt](expected_elems);\n+                        auto actual_len = _vec.len[ty.mt](actual_elems);\n                         if (expected_len != actual_len) {\n                             auto err = terr_tuple_size(expected_len,\n                                                        actual_len);\n@@ -1228,23 +1296,30 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n \n                         // TODO: implement an iterator that can iterate over\n                         // two arrays simultaneously.\n-                        let vec[@ty.t] result_elems = vec();\n+                        let vec[ty.mt] result_elems = vec();\n                         auto i = 0u;\n                         while (i < expected_len) {\n                             auto expected_elem = expected_elems.(i);\n                             auto actual_elem = actual_elems.(i);\n-                            if (expected_elem.mut != actual_elem.mut) {\n-                                auto err = terr_tuple_mutability;\n-                                ret ures_err(err, expected, actual);\n+\n+                            auto mut;\n+                            alt (unify_mut(expected_elem.mut,\n+                                           actual_elem.mut)) {\n+                                case (none[ast.mutability]) {\n+                                    auto err = terr_tuple_mutability;\n+                                    ret ures_err(err, expected, actual);\n+                                }\n+                                case (some[ast.mutability](?m)) { mut = m; }\n                             }\n \n                             auto result = unify_step(bindings,\n-                                                     expected_elem,\n-                                                     actual_elem,\n+                                                     expected_elem.ty,\n+                                                     actual_elem.ty,\n                                                      handler);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    append[@ty.t](result_elems,rty);\n+                                    auto mt = rec(ty=rty, mut=mut);\n+                                    result_elems += vec(mt);\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -1281,29 +1356,35 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                         while (i < expected_len) {\n                             auto expected_field = expected_fields.(i);\n                             auto actual_field = actual_fields.(i);\n-                            if (expected_field.ty.mut\n-                                != actual_field.ty.mut) {\n-                                auto err = terr_record_mutability;\n-                                ret ures_err(err, expected, actual);\n+\n+                            auto mut;\n+                            alt (unify_mut(expected_field.mt.mut,\n+                                           actual_field.mt.mut)) {\n+                                case (none[ast.mutability]) {\n+                                    ret ures_err(terr_record_mutability,\n+                                                 expected, actual);\n+                                }\n+                                case (some[ast.mutability](?m)) { mut = m; }\n                             }\n \n                             if (!_str.eq(expected_field.ident,\n-                                        actual_field.ident)) {\n+                                         actual_field.ident)) {\n                                 auto err =\n                                     terr_record_fields(expected_field.ident,\n                                                        actual_field.ident);\n                                 ret ures_err(err, expected, actual);\n                             }\n \n                             auto result = unify_step(bindings,\n-                                                     expected_field.ty,\n-                                                     actual_field.ty,\n+                                                     expected_field.mt.ty,\n+                                                     actual_field.mt.ty,\n                                                      handler);\n                             alt (result) {\n                                 case (ures_ok(?rty)) {\n-                                    append[field]\n+                                    auto mt = rec(ty=rty, mut=mut);\n+                                    _vec.push[field]\n                                         (result_fields,\n-                                         rec(ty=rty with expected_field));\n+                                         rec(mt=mt with expected_field));\n                                 }\n                                 case (_) {\n                                     ret result;\n@@ -1440,6 +1521,12 @@ fn type_err_to_str(&ty.type_err err) -> str {\n         case (terr_mismatch) {\n             ret \"types differ\";\n         }\n+        case (terr_box_mutability) {\n+            ret \"boxed values differ in mutability\";\n+        }\n+        case (terr_vec_mutability) {\n+            ret \"vectors differ in mutability\";\n+        }\n         case (terr_tuple_size(?e_sz, ?a_sz)) {\n             ret \"expected a tuple with \" + _uint.to_str(e_sz, 10u) +\n                 \" elements but found one with \" + _uint.to_str(a_sz, 10u) +"}, {"sha": "14d4f714b0be3d2328edd158554f92d262337b40", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 93, "deletions": 87, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -4,7 +4,6 @@ import front.ast.mutability;\n import middle.fold;\n import driver.session;\n import util.common;\n-import util.common.append;\n import util.common.span;\n \n import middle.ty;\n@@ -277,6 +276,10 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         ret rec(mode=arg.mode, ty=ast_ty_to_ty(getter, arg.ty));\n     }\n \n+    fn ast_mt_to_mt(ty_getter getter, &ast.mt mt) -> ty.mt {\n+        ret rec(ty=ast_ty_to_ty(getter, mt.ty), mut=mt.mut);\n+    }\n+\n     fn instantiate(ty_getter getter, ast.def_id id,\n                    vec[@ast.ty] args) -> @ty.t {\n         // TODO: maybe record cname chains so we can do\n@@ -306,8 +309,8 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         case (ast.ty_machine(?tm)) { sty = ty.ty_machine(tm); }\n         case (ast.ty_char)         { sty = ty.ty_char; }\n         case (ast.ty_str)          { sty = ty.ty_str; }\n-        case (ast.ty_box(?t)) { sty = ty.ty_box(ast_ty_to_ty(getter, t)); }\n-        case (ast.ty_vec(?t)) { sty = ty.ty_vec(ast_ty_to_ty(getter, t)); }\n+        case (ast.ty_box(?mt)) { sty = ty.ty_box(ast_mt_to_mt(getter, mt)); }\n+        case (ast.ty_vec(?mt)) { sty = ty.ty_vec(ast_mt_to_mt(getter, mt)); }\n \n         case (ast.ty_port(?t)) {\n             sty = ty.ty_port(ast_ty_to_ty(getter, t));\n@@ -318,17 +321,17 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n         }\n \n         case (ast.ty_tup(?fields)) {\n-            let vec[@ty.t] flds = vec();\n-            for (@ast.ty field in fields) {\n-                append[@ty.t](flds, ast_ty_to_ty(getter, field));\n+            let vec[ty.mt] flds = vec();\n+            for (ast.mt field in fields) {\n+                _vec.push[ty.mt](flds, ast_mt_to_mt(getter, field));\n             }\n             sty = ty.ty_tup(flds);\n         }\n         case (ast.ty_rec(?fields)) {\n             let vec[field] flds = vec();\n             for (ast.ty_field f in fields) {\n-                append[field](flds, rec(ident=f.ident,\n-                                        ty=ast_ty_to_ty(getter, f.ty)));\n+                _vec.push[field](flds, rec(ident=f.ident,\n+                                        mt=ast_mt_to_mt(getter, f.mt)));\n             }\n             sty = ty.ty_rec(flds);\n         }\n@@ -358,30 +361,24 @@ fn ast_ty_to_ty(ty_getter getter, &@ast.ty ast_ty) -> @ty.t {\n             cname = some(path_to_str(path));\n         }\n \n-        case (ast.ty_mutable(?t)) {\n-            mut = ast.mut;\n-            auto t0 = ast_ty_to_ty(getter, t);\n-            sty = t0.struct;\n-            cname = t0.cname;\n-        }\n-\n         case (ast.ty_obj(?meths)) {\n             let vec[ty.method] tmeths = vec();\n             auto f = bind ast_arg_to_arg(getter, _);\n             for (ast.ty_method m in meths) {\n                 auto ins = _vec.map[ast.ty_arg, arg](f, m.inputs);\n                 auto out = ast_ty_to_ty(getter, m.output);\n-                append[ty.method](tmeths,\n+                _vec.push[ty.method](tmeths,\n                                   rec(proto=m.proto,\n                                       ident=m.ident,\n                                       inputs=ins,\n                                       output=out));\n             }\n-            sty = ty.ty_obj(tmeths);\n+\n+            sty = ty.ty_obj(ty.sort_methods(tmeths));\n         }\n     }\n \n-    ret @rec(struct=sty, mut=mut, cname=cname);\n+    ret @rec(struct=sty, cname=cname);\n }\n \n fn actual_type(@ty.t t, @ast.item item) -> @ty.t {\n@@ -546,14 +543,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         auto methods =\n             _vec.map[@ast.method,method](f, obj_info.methods);\n \n-        fn method_lteq(&method a, &method b) -> bool {\n-            ret _str.lteq(a.ident, b.ident);\n-        }\n-\n-        methods = std.sort.merge_sort[method](bind method_lteq(_,_),\n-                                              methods);\n-\n-        auto t_obj = plain_ty(ty.ty_obj(methods));\n+        auto t_obj = plain_ty(ty.ty_obj(ty.sort_methods(methods)));\n         ret t_obj;\n     }\n \n@@ -565,7 +555,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         for (ast.obj_field f in obj_info.fields) {\n             auto g = bind getter(id_to_ty_item, item_to_ty, _);\n             auto t_field = ast_ty_to_ty(g, f.ty);\n-            append[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n+            _vec.push[arg](t_inputs, rec(mode=ast.alias, ty=t_field));\n         }\n         auto t_fn = plain_ty(ty.ty_fn(ast.proto_fn, t_inputs, t_obj));\n         ret t_fn;\n@@ -645,8 +635,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                     // Avoid repeating work.\n                     ret item_to_ty.get(def_id);\n                 }\n-                auto x =\n-                    @rec(struct=ty.ty_native, mut=ast.imm, cname=none[str]);\n+                auto x = @rec(struct=ty.ty_native, cname=none[str]);\n                 item_to_ty.insert(def_id, x);\n                 ret x;\n             }\n@@ -870,7 +859,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 with meth.node\n             );\n             m = @rec(node=m_ with *meth);\n-            append[@ast.method](methods, m);\n+            _vec.push[@ast.method](methods, m);\n         }\n         auto g = bind getter(e.id_to_ty_item, e.item_to_ty, _);\n         for (ast.obj_field fld in ob.fields) {\n@@ -879,7 +868,7 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 ann=ast.ann_type(fty, none[vec[@ty.t]])\n                 with fld\n             );\n-            append[ast.obj_field](fields, f);\n+            _vec.push[ast.obj_field](fields, f);\n         }\n \n         auto ob_ = rec(methods = methods,\n@@ -980,7 +969,7 @@ fn strip_boxes(@ty.t t) -> @ty.t {\n     auto t1 = t;\n     while (true) {\n         alt (t1.struct) {\n-            case (ty.ty_box(?inner)) { t1 = inner; }\n+            case (ty.ty_box(?inner)) { t1 = inner.ty; }\n             case (_) { ret t1; }\n         }\n     }\n@@ -990,7 +979,7 @@ fn strip_boxes(@ty.t t) -> @ty.t {\n fn add_boxes(uint n, @ty.t t) -> @ty.t {\n     auto t1 = t;\n     while (n != 0u) {\n-        t1 = plain_ty(ty.ty_box(t1));\n+        t1 = ty.plain_box_ty(t1);\n         n -= 1u;\n     }\n     ret t1;\n@@ -1002,7 +991,7 @@ fn count_boxes(@ty.t t) -> uint {\n     auto t1 = t;\n     while (true) {\n         alt (t1.struct) {\n-            case (ty.ty_box(?inner)) { n += 1u; t1 = inner; }\n+            case (ty.ty_box(?inner)) { n += 1u; t1 = inner.ty; }\n             case (_) { ret n; }\n         }\n     }\n@@ -1150,30 +1139,32 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n     auto e_1;\n \n     alt (e.node) {\n-        case (ast.expr_vec(?es_0, ?ann)) {\n+        case (ast.expr_vec(?es_0, ?mut, ?ann)) {\n+            // TODO: enforce mutability\n+\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             let vec[@ast.expr] es_1 = vec();\n             alt (t.struct) {\n-                case (ty.ty_vec(?subty)) {\n+                case (ty.ty_vec(?mt)) {\n                     for (@ast.expr e_0 in es_0) {\n-                        es_1 += vec(demand_expr(fcx, subty, e_0));\n+                        es_1 += vec(demand_expr(fcx, mt.ty, e_0));\n                     }\n                 }\n                 case (_) {\n                     log \"vec expr doesn't have a vec type!\";\n                     fail;\n                 }\n             }\n-            e_1 = ast.expr_vec(es_1, ast.ann_type(t, none[vec[@ty.t]]));\n+            e_1 = ast.expr_vec(es_1, mut, ast.ann_type(t, none[vec[@ty.t]]));\n         }\n         case (ast.expr_tup(?es_0, ?ann)) {\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             let vec[ast.elt] elts_1 = vec();\n             alt (t.struct) {\n-                case (ty.ty_tup(?subtys)) {\n+                case (ty.ty_tup(?mts)) {\n                     auto i = 0u;\n                     for (ast.elt elt_0 in es_0) {\n-                        auto e_1 = demand_expr(fcx, subtys.(i), elt_0.expr);\n+                        auto e_1 = demand_expr(fcx, mts.(i).ty, elt_0.expr);\n                         elts_1 += vec(rec(mut=elt_0.mut, expr=e_1));\n                         i += 1u;\n                     }\n@@ -1192,15 +1183,15 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n             auto t = demand(fcx, e.span, expected, ann_to_type(ann));\n             let vec[ast.field] fields_1 = vec();\n             alt (t.struct) {\n-                case (ty.ty_rec(?field_tys)) {\n+                case (ty.ty_rec(?field_mts)) {\n                     alt (base_0) {\n                         case (none[@ast.expr]) {\n                             auto i = 0u;\n                             for (ast.field field_0 in fields_0) {\n                                 check (_str.eq(field_0.ident,\n-                                               field_tys.(i).ident));\n+                                               field_mts.(i).ident));\n                                 auto e_1 = demand_expr(fcx,\n-                                                       field_tys.(i).ty,\n+                                                       field_mts.(i).mt.ty,\n                                                        field_0.expr);\n                                 fields_1 += vec(rec(mut=field_0.mut,\n                                                     ident=field_0.ident,\n@@ -1217,9 +1208,9 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n \n                             for (ast.field field_0 in fields_0) {\n \n-                                for (ty.field ft in field_tys) {\n+                                for (ty.field ft in field_mts) {\n                                     if (_str.eq(field_0.ident, ft.ident)) {\n-                                        auto e_1 = demand_expr(fcx, ft.ty,\n+                                        auto e_1 = demand_expr(fcx, ft.mt.ty,\n                                                                field_0.expr);\n                                         fields_1 +=\n                                             vec(rec(mut=field_0.mut,\n@@ -1411,7 +1402,8 @@ fn demand_expr_full(&@fn_ctxt fcx, @ty.t expected, @ast.expr e,\n         }\n \n         case (_) {\n-            fcx.ccx.sess.unimpl(\"type unification for expression variant\");\n+            fcx.ccx.sess.span_unimpl(e.span,\n+                \"type unification for expression variant\");\n             fail;\n         }\n     }\n@@ -1438,8 +1430,10 @@ fn demand_block(&@fn_ctxt fcx, @ty.t expected, &ast.block bloc) -> ast.block {\n \n // Writeback: the phase that writes inferred types back into the AST.\n \n-fn writeback_local(&@fn_ctxt fcx, &span sp, @ast.local local)\n+fn writeback_local(&option.t[@fn_ctxt] env, &span sp, @ast.local local)\n         -> @ast.decl {\n+    auto fcx = option.get[@fn_ctxt](env);\n+\n     if (!fcx.locals.contains_key(local.id)) {\n         fcx.ccx.sess.span_err(sp, \"unable to determine type of local: \"\n                               + local.ident);\n@@ -1453,10 +1447,25 @@ fn writeback_local(&@fn_ctxt fcx, &span sp, @ast.local local)\n }\n \n fn writeback(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n-    auto fld = fold.new_identity_fold[@fn_ctxt]();\n-    auto f = writeback_local;\n-    fld = @rec(fold_decl_local = f with *fld);\n-    ret fold.fold_block[@fn_ctxt](fcx, fld, block);\n+    fn update_env_for_item(&option.t[@fn_ctxt] env, @ast.item i)\n+            -> option.t[@fn_ctxt] {\n+        ret none[@fn_ctxt];\n+    }\n+    fn keep_going(&option.t[@fn_ctxt] env) -> bool {\n+        ret !option.is_none[@fn_ctxt](env);\n+    }\n+\n+    auto fld = fold.new_identity_fold[option.t[@fn_ctxt]]();\n+    auto wbl = writeback_local;\n+    auto uefi = update_env_for_item;\n+    auto kg = keep_going;\n+    fld = @rec(\n+        fold_decl_local = wbl,\n+        update_env_for_item = uefi,\n+        keep_going = kg\n+        with *fld\n+    );\n+    ret fold.fold_block[option.t[@fn_ctxt]](some[@fn_ctxt](fcx), fld, block);\n }\n \n // AST fragment checking\n@@ -1572,14 +1581,14 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n \n                     // FIXME: this breaks aliases. We need a ty_fn_arg.\n                     auto arg_ty = rec(mode=ast.val, ty=expr_ty(a_0));\n-                    append[arg](arg_tys_0, arg_ty);\n+                    _vec.push[arg](arg_tys_0, arg_ty);\n                 }\n                 case (none[@ast.expr]) {\n                     args_0 += vec(none[@ast.expr]);\n \n                     // FIXME: breaks aliases too?\n                     auto typ = next_ty_var(fcx.ccx);\n-                    append[arg](arg_tys_0, rec(mode=ast.val, ty=typ));\n+                    _vec.push[arg](arg_tys_0, rec(mode=ast.val, ty=typ));\n                 }\n             }\n         }\n@@ -1623,10 +1632,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (some[@ast.expr](?e_0)) {\n                     auto arg_ty_1 = arg_tys_1.(i);\n                     auto e_1 = demand_expr(fcx, arg_ty_1.ty, e_0);\n-                    append[option.t[@ast.expr]](args_1, some[@ast.expr](e_1));\n+                    _vec.push[option.t[@ast.expr]](args_1,\n+                                                   some[@ast.expr](e_1));\n                 }\n                 case (none[@ast.expr]) {\n-                    append[option.t[@ast.expr]](args_1, none[@ast.expr]);\n+                    _vec.push[option.t[@ast.expr]](args_1, none[@ast.expr]);\n                 }\n             }\n \n@@ -1693,11 +1703,14 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto oper_1 = check_expr(fcx, oper);\n             auto oper_t = expr_ty(oper_1);\n             alt (unop) {\n-                case (ast.box) { oper_t = plain_ty(ty.ty_box(oper_t)); }\n+                case (ast.box) {\n+                    // TODO: mutable\n+                    oper_t = ty.plain_box_ty(oper_t);\n+                }\n                 case (ast.deref) {\n                     alt (oper_t.struct) {\n-                        case (ty.ty_box(?inner_t)) {\n-                            oper_t = inner_t;\n+                        case (ty.ty_box(?inner)) {\n+                            oper_t = inner.ty;\n                         }\n                         case (_) {\n                             fcx.ccx.sess.span_err\n@@ -1707,9 +1720,6 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         }\n                     }\n                 }\n-                case (ast._mutable) {\n-                    oper_t = @rec(mut=ast.mut with *oper_t);\n-                }\n                 case (_) { oper_t = strip_boxes(oper_t); }\n             }\n \n@@ -2096,12 +2106,9 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                                         ast.expr_cast(e_1, t, ann));\n         }\n \n-        case (ast.expr_vec(?args, _)) {\n+        case (ast.expr_vec(?args, ?mut, _)) {\n             let vec[@ast.expr] args_1 = vec();\n \n-            // FIXME: implement mutable vectors with leading 'mutable' flag\n-            // marking the elements as mutable.\n-\n             let @ty.t t;\n             if (_vec.len[@ast.expr](args) == 0u) {\n                 t = next_ty_var(fcx.ccx);\n@@ -2114,28 +2121,27 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 auto expr_1 = check_expr(fcx, e);\n                 auto expr_t = expr_ty(expr_1);\n                 demand(fcx, expr.span, t, expr_t);\n-                append[@ast.expr](args_1,expr_1);\n+                _vec.push[@ast.expr](args_1,expr_1);\n             }\n-            auto ann = ast.ann_type(plain_ty(ty.ty_vec(t)), none[vec[@ty.t]]);\n+\n+            auto vec_sty = ty.ty_vec(rec(ty=t, mut=mut));\n+            auto ann = ast.ann_type(plain_ty(vec_sty), none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_vec(args_1, ann));\n+                                        ast.expr_vec(args_1, mut, ann));\n         }\n \n         case (ast.expr_tup(?elts, _)) {\n             let vec[ast.elt] elts_1 = vec();\n-            let vec[@ty.t] elts_t = vec();\n+            let vec[ty.mt] elts_mt = vec();\n \n             for (ast.elt e in elts) {\n                 auto expr_1 = check_expr(fcx, e.expr);\n                 auto expr_t = expr_ty(expr_1);\n-                if (e.mut == ast.mut) {\n-                    expr_t = @rec(mut=ast.mut with *expr_t);\n-                }\n-                append[ast.elt](elts_1, rec(expr=expr_1 with e));\n-                append[@ty.t](elts_t, expr_t);\n+                _vec.push[ast.elt](elts_1, rec(expr=expr_1 with e));\n+                elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n \n-            auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_t)),\n+            auto ann = ast.ann_type(plain_ty(ty.ty_tup(elts_mt)),\n                                     none[vec[@ty.t]]);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_tup(elts_1, ann));\n@@ -2157,11 +2163,10 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             for (ast.field f in fields) {\n                 auto expr_1 = check_expr(fcx, f.expr);\n                 auto expr_t = expr_ty(expr_1);\n-                if (f.mut == ast.mut) {\n-                    expr_t = @rec(mut=ast.mut with *expr_t);\n-                }\n-                append[ast.field](fields_1, rec(expr=expr_1 with f));\n-                append[field](fields_t, rec(ident=f.ident, ty=expr_t));\n+                _vec.push[ast.field](fields_1, rec(expr=expr_1 with f));\n+\n+                auto expr_mt = rec(ty=expr_t, mut=f.mut);\n+                _vec.push[field](fields_t, rec(ident=f.ident, mt=expr_mt));\n             }\n \n             auto ann = ast.ann_none;\n@@ -2195,7 +2200,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         auto found = false;\n                         for (ty.field bf in base_fields) {\n                             if (_str.eq(f.ident, bf.ident)) {\n-                                demand(fcx, expr.span, f.ty, bf.ty);\n+                                demand(fcx, expr.span, f.mt.ty, bf.mt.ty);\n                                 found = true;\n                             }\n                         }\n@@ -2220,11 +2225,11 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                 case (ty.ty_tup(?args)) {\n                     let uint ix = ty.field_num(fcx.ccx.sess,\n                                                expr.span, field);\n-                    if (ix >= _vec.len[@ty.t](args)) {\n+                    if (ix >= _vec.len[ty.mt](args)) {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n-                    auto ann = ast.ann_type(args.(ix), none[vec[@ty.t]]);\n+                    auto ann = ast.ann_type(args.(ix).ty, none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2238,7 +2243,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    auto ann = ast.ann_type(fields.(ix).ty, none[vec[@ty.t]]);\n+                    auto ann = ast.ann_type(fields.(ix).mt.ty,\n+                                            none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2278,14 +2284,14 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto idx_t = expr_ty(idx_1);\n \n             alt (base_t.struct) {\n-                case (ty.ty_vec(?t)) {\n+                case (ty.ty_vec(?mt)) {\n                     if (! type_is_integral(idx_t)) {\n                         fcx.ccx.sess.span_err\n                             (idx.span,\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(idx_t));\n                     }\n-                    auto ann = ast.ann_type(t, none[vec[@ty.t]]);\n+                    auto ann = ast.ann_type(mt.ty, none[vec[@ty.t]]);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2418,7 +2424,7 @@ fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n fn check_block(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n     let vec[@ast.stmt] stmts = vec();\n     for (@ast.stmt s in block.node.stmts) {\n-        append[@ast.stmt](stmts, check_stmt(fcx, s));\n+        _vec.push[@ast.stmt](stmts, check_stmt(fcx, s));\n     }\n \n     auto expr = none[@ast.expr];"}, {"sha": "0c355001e95fa8c02da77d40a7ef99167ed42472", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -39,12 +39,12 @@ fn mkstate(io.writer out, uint width) -> ps {\n \n impure fn push_context(ps p, contexttype tp, uint indent) {\n   before_print(p, false);\n-  p.context = _vec.push[context](p.context, rec(tp=tp, indent=base_indent(p)\n-                                                + indent));\n+  _vec.push[context](p.context, rec(tp=tp, indent=base_indent(p)\n+                                    + indent));\n }\n \n-impure fn pop_context(ps p) {\n-  p.context = _vec.pop[context](p.context);\n+fn pop_context(ps p) {\n+  _vec.pop[context](p.context);\n }\n \n impure fn add_token(ps p, token tok) {\n@@ -110,7 +110,8 @@ impure fn finish_block_scan(ps p, contexttype tp) {\n   }\n   p.scandepth = 0u;\n   push_context(p, tp, indent);\n-  for (token t in _vec.shift[token](p.buffered)) {add_token(p, t);}\n+  _vec.shift[token](p.buffered);\n+  for (token t in p.buffered) { add_token(p, t); }\n }\n \n impure fn finish_break_scan(ps p) {\n@@ -125,7 +126,8 @@ impure fn finish_break_scan(ps p) {\n     p.col += width;\n   }\n   p.scandepth = 0u;\n-  for (token t in _vec.shift[token](p.buffered)) {add_token(p, t);}\n+  _vec.shift[token](p.buffered);\n+  for (token t in p.buffered) { add_token(p, t); }\n }\n \n impure fn start_scan(ps p, token tok) {"}, {"sha": "6f5ea096b0573db090066d88d84213ea0a08b36f", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -48,7 +48,7 @@ impure fn bclose(ps s) {\n   end(s);\n   pp.cwrd(s, \"}\");\n }\n-impure fn commasep[IN](ps s, vec[IN] elts, impure fn (ps, IN) op) {\n+impure fn commasep[IN](ps s, vec[IN] elts, impure fn (ps, &IN) op) {\n   auto first = true;\n   for (IN elt in elts) {\n     if (first) {first = false;}\n@@ -57,7 +57,16 @@ impure fn commasep[IN](ps s, vec[IN] elts, impure fn (ps, IN) op) {\n   }\n }\n \n-impure fn print_type(ps s, @ast.ty ty) {\n+impure fn print_mt(ps s, &ast.mt mt) {\n+    alt (mt.mut) {\n+        case (ast.mut)       { wrd1(s, \"mutable\");  }\n+        case (ast.maybe_mut) { wrd1(s, \"mutable?\"); }\n+        case (ast.imm)       { /* nothing */        }\n+    }\n+    print_type(s, mt.ty);\n+}\n+\n+impure fn print_type(ps s, &@ast.ty ty) {\n   hbox(s);\n   alt (ty.node) {\n     case (ast.ty_nil) {wrd(s, \"()\");}\n@@ -67,22 +76,22 @@ impure fn print_type(ps s, @ast.ty ty) {\n     case (ast.ty_machine(?tm)) {wrd(s, util.common.ty_mach_to_str(tm));}\n     case (ast.ty_char) {wrd(s, \"char\");}\n     case (ast.ty_str) {wrd(s, \"str\");}\n-    case (ast.ty_box(?t)) {wrd(s, \"@\"); print_type(s, t);}\n-    case (ast.ty_vec(?t)) {wrd(s, \"vec[\"); print_type(s, t); wrd(s, \"]\");}\n+    case (ast.ty_box(?mt)) {wrd(s, \"@\"); print_mt(s, mt);}\n+    case (ast.ty_vec(?mt)) {wrd(s, \"vec[\"); print_mt(s, mt); wrd(s, \"]\");}\n     case (ast.ty_type) {wrd(s, \"type\");}\n     case (ast.ty_tup(?elts)) {\n       wrd(s, \"tup\");\n       popen(s);\n-      auto f = print_type;\n-      commasep[@ast.ty](s, elts, f);\n+      auto f = print_mt;\n+      commasep[ast.mt](s, elts, f);\n       pclose(s);\n     }\n     case (ast.ty_rec(?fields)) {\n       wrd(s, \"rec\");\n       popen(s);\n-      impure fn print_field(ps s, ast.ty_field f) {\n+      impure fn print_field(ps s, &ast.ty_field f) {\n         hbox(s);\n-        print_type(s, f.ty);\n+        print_mt(s, f.mt);\n         space(s);\n         wrd(s, f.ident);\n         end(s);\n@@ -110,10 +119,6 @@ impure fn print_type(ps s, @ast.ty ty) {\n     case (ast.ty_path(?path,_)) {\n       print_path(s, path);\n     }\n-    case (ast.ty_mutable(?t)) {\n-      wrd1(s, \"mutable\");\n-      print_type(s, t);\n-    }\n   }\n   end(s);\n }\n@@ -186,7 +191,7 @@ impure fn print_item(ps s, @ast.item item) {\n         wrd(s, v.name);\n         if (_vec.len[ast.variant_arg](v.args) > 0u) {\n           popen(s);\n-          impure fn print_variant_arg(ps s, ast.variant_arg arg) {\n+          impure fn print_variant_arg(ps s, &ast.variant_arg arg) {\n             print_type(s, arg.ty);\n           }\n           auto f = print_variant_arg;\n@@ -203,7 +208,7 @@ impure fn print_item(ps s, @ast.item item) {\n       wrd(s, id);\n       print_type_params(s, params);\n       popen(s);\n-      impure fn print_field(ps s, ast.obj_field field) {\n+      impure fn print_field(ps s, &ast.obj_field field) {\n         hbox(s);\n         print_type(s, field.ty);\n         space(s);\n@@ -285,18 +290,21 @@ impure fn print_literal(ps s, @ast.lit lit) {\n   }\n }\n \n-impure fn print_expr(ps s, @ast.expr expr) {\n+impure fn print_expr(ps s, &@ast.expr expr) {\n   auto pe = print_expr;\n   hbox(s);\n   alt (expr.node) {\n-    case (ast.expr_vec(?exprs,_)) {\n+    case (ast.expr_vec(?exprs,?mut,_)) {\n+      if (mut == ast.mut) {\n+        wrd1(s, \"mutable\");\n+      }\n       wrd(s, \"vec\");\n       popen(s);\n       commasep[@ast.expr](s, exprs, pe);\n       pclose(s);\n     }\n     case (ast.expr_tup(?exprs,_)) {\n-      impure fn printElt(ps s, ast.elt elt) {\n+      impure fn printElt(ps s, &ast.elt elt) {\n         hbox(s);\n         if (elt.mut == ast.mut) {wrd1(s, \"mutable\");}\n         print_expr(s, elt.expr);\n@@ -309,7 +317,7 @@ impure fn print_expr(ps s, @ast.expr expr) {\n       pclose(s);\n     }\n     case (ast.expr_rec(?fields,?wth,_)) {\n-      impure fn print_field(ps s, ast.field field) {\n+      impure fn print_field(ps s, &ast.field field) {\n         hbox(s);\n         if (field.mut == ast.mut) {wrd1(s, \"mutable\");}\n         wrd(s, field.ident);\n@@ -340,7 +348,7 @@ impure fn print_expr(ps s, @ast.expr expr) {\n       pclose(s);\n     }\n     case (ast.expr_bind(?func,?args,_)) {\n-      impure fn print_opt(ps s, option.t[@ast.expr] expr) {\n+      impure fn print_opt(ps s, &option.t[@ast.expr] expr) {\n         alt (expr) {\n           case (option.some[@ast.expr](?expr)) {\n             print_expr(s, expr);\n@@ -364,7 +372,6 @@ impure fn print_expr(ps s, @ast.expr expr) {\n     }\n     case (ast.expr_unary(?op,?expr,_)) {\n       wrd(s, ast.unop_to_str(op));\n-      if (op == ast._mutable) {space(s);}\n       print_expr(s, expr);\n     }\n     case (ast.expr_lit(?lit,_)) {\n@@ -577,7 +584,7 @@ impure fn print_path(ps s, ast.path path) {\n   }\n }\n \n-impure fn print_pat(ps s, @ast.pat pat) {\n+impure fn print_pat(ps s, &@ast.pat pat) {\n   alt (pat.node) {\n     case (ast.pat_wild(_)) {wrd(s, \"_\");}\n     case (ast.pat_bind(?id,_,_)) {wrd(s, \"?\" + id);}\n@@ -605,7 +612,7 @@ impure fn print_fn(ps s, ast.fn_decl decl, str name,\n   wrd(s, name);\n   print_type_params(s, typarams);\n   popen(s);\n-  impure fn print_arg(ps s, ast.arg x) {\n+  impure fn print_arg(ps s, &ast.arg x) {\n     hbox(s);\n     print_type(s, x.ty);\n     space(s);\n@@ -627,7 +634,7 @@ impure fn print_fn(ps s, ast.fn_decl decl, str name,\n impure fn print_type_params(ps s, vec[ast.ty_param] params) {\n   if (_vec.len[ast.ty_param](params) > 0u) {\n     wrd(s, \"[\");\n-    impure fn printParam(ps s, ast.ty_param param) {wrd(s, param.ident);}\n+    impure fn printParam(ps s, &ast.ty_param param) {wrd(s, param.ident);}\n     auto f = printParam;\n     commasep[ast.ty_param](s, params, f);\n     wrd(s, \"]\");\n@@ -642,7 +649,7 @@ impure fn print_view_item(ps s, @ast.view_item item) {\n       wrd(s, id);\n       if (_vec.len[@ast.meta_item](mta) > 0u) {\n         popen(s);\n-        impure fn print_meta(ps s, @ast.meta_item item) {\n+        impure fn print_meta(ps s, &@ast.meta_item item) {\n           hbox(s);\n           wrd1(s, item.node.name);\n           wrd1(s, \"=\");\n@@ -717,7 +724,7 @@ fn escape_str(str st, char to_escape) -> str {\n       case ('\\\\') {out += \"\\\\\\\\\";}\n       case (?cur) {\n         if (cur == to_escape) {out += \"\\\\\";}\n-        out += cur as u8;\n+        _str.push_byte(out, cur as u8);\n       }\n     }\n     i += 1u;\n@@ -738,7 +745,7 @@ impure fn print_ty_fn(ps s, ast.proto proto, option.t[str] id,\n     case (_) {}\n   }\n   popen(s);\n-  impure fn print_arg(ps s, ast.ty_arg input) {\n+  impure fn print_arg(ps s, &ast.ty_arg input) {\n     if (middle.ty.mode_is_alias(input.mode)) {wrd(s, \"&\");}\n     print_type(s, input.ty);\n   }"}, {"sha": "4b4f54818e900fc613d0654753fa35e3403b80d8", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -68,15 +68,6 @@ fn istr(int i) -> str {\n     ret _int.to_str(i, 10u);\n }\n \n-\n-// FIXME: Weird bug. Due to the way we auto-deref + in +=, we can't append a\n-// boxed value to a vector-of-boxes using +=.  Best to figure out a way to fix\n-// this. Deref-on-demand or something? It's a hazard of the ambiguity between\n-// single-element and vector append.\n-fn append[T](&mutable vec[T] v, &T t) {\n-    v += t;\n-}\n-\n //\n // Local Variables:\n // mode: rust"}, {"sha": "eb7416805aaa34b0d8712de6a2e39e7a8ebaa8c9", "filename": "src/configure.sh", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/830f2d02f19b45ff4b4a4d7946b69f206b5dcdff/src%2Fconfigure.sh", "raw_url": "https://github.com/rust-lang/rust/raw/830f2d02f19b45ff4b4a4d7946b69f206b5dcdff/src%2Fconfigure.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfigure.sh?ref=830f2d02f19b45ff4b4a4d7946b69f206b5dcdff", "patch": "@@ -1,39 +0,0 @@\n-#!/bin/sh\n-\n-CFG_SRC_DIR=${0%${0##*/}}\n-CFG_BUILD_DIR=$PWD\n-\n-CFG_OSTYPE=$(uname -s)\n-CFG_CPUTYPE=$(uname -m)\n-\n-echo \"configuring on $CFG_CPUTYPE $CFG_OSTYPE\"\n-\n-echo \"setting up build directories\"\n-for i in boot/{fe,me,be,driver,util} \\\n-         rt/{isaac,bigint,sync,test} \\\n-         stage{0,1,2}                \\\n-         test/{run-pass,compile-{pass,fail}}\n-do\n-    mkdir -p -v $i\n-done\n-\n-CFG_VALGRIND=$(sh which valgrind)\n-CFG_OCAMLC_OPT=$(sh which ocamlc.opt)\n-\n-echo \"copying Makefile\"\n-cp -v ${CFG_SRC_DIR}Makefile.in ./Makefile\n-\n-echo \"writing config.mk\"\n-cat >config.mk <<EOF\n-\n-CFG_OSTYPE        := $CFG_OSTYPE\n-CFG_CPUTYPE       := $CFG_CPUTYPE\n-CFG_SRC_DIR       := $CFG_SRC_DIR\n-CFG_BUILD_DIR     := $CFG_BUILD_DIR\n-\n-CFG_VALGRIND      := $CFG_VALGRIND\n-CFG_OCAMLC_OPT    := $CFG_OCAMLC_OPT\n-\n-EOF\n-\n-echo \"configured ok\""}, {"sha": "93d0a9f286a34b2f438c8986e643f554bde7d9a1", "filename": "src/lib/_str.rs", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -8,6 +8,8 @@ native \"rust\" mod rustrt {\n     fn str_byte_len(str s) -> uint;\n     fn str_alloc(uint n_bytes) -> str;\n     fn str_from_vec(vec[u8] b) -> str;\n+    fn str_from_cstr(sbuf cstr) -> str;\n+    fn str_from_buf(sbuf buf, uint len) -> str;\n     fn refcount[T](str s) -> uint;\n }\n \n@@ -111,6 +113,19 @@ fn unsafe_from_bytes(vec[u8] v) -> str {\n     ret rustrt.str_from_vec(v);\n }\n \n+fn unsafe_from_byte(u8 u) -> str {\n+    ret rustrt.str_from_vec(vec(u));\n+}\n+\n+unsafe fn str_from_cstr(sbuf cstr) -> str {\n+    ret rustrt.str_from_cstr(cstr);\n+}\n+\n+unsafe fn str_from_buf(sbuf buf, uint len) -> str {\n+    ret rustrt.str_from_buf(buf, len);\n+}\n+\n+\n fn refcount(str s) -> uint {\n     auto r = rustrt.refcount[u8](s);\n     if (r == dbg.const_refcount) {\n@@ -190,7 +205,6 @@ fn starts_with(str haystack, str needle) -> bool {\n     ret eq(substr(haystack, 0u, needle_len), needle);\n }\n \n-\n fn ends_with(str haystack, str needle) -> bool {\n     let uint haystack_len = byte_len(haystack);\n     let uint needle_len = byte_len(needle);\n@@ -206,34 +220,60 @@ fn ends_with(str haystack, str needle) -> bool {\n            needle);\n }\n \n-\n fn substr(str s, uint begin, uint len) -> str {\n     let str accum = \"\";\n     let uint i = begin;\n     while (i < begin+len) {\n-        accum += s.(i);\n+        accum += unsafe_from_byte(s.(i));\n         i += 1u;\n     }\n     ret accum;\n }\n \n+fn shift_byte(&mutable str s) -> u8 {\n+    auto len = byte_len(s);\n+    check(len > 0u);\n+    auto b = s.(0);\n+    s = substr(s, 1u, len - 1u);\n+    ret b;\n+}\n+\n+fn pop_byte(&mutable str s) -> u8 {\n+    auto len = byte_len(s);\n+    check(len > 0u);\n+    auto b = s.(len - 1u);\n+    s = substr(s, 0u, len - 1u);\n+    ret b;\n+}\n+\n+fn push_byte(&mutable str s, u8 b) {\n+    s += unsafe_from_byte(b);\n+}\n+\n+fn unshift_byte(&mutable str s, u8 b) {\n+    auto res = alloc(byte_len(s) + 1u);\n+    res += unsafe_from_byte(b);\n+    res += s;\n+    s = res;\n+}\n+\n fn split(str s, u8 sep) -> vec[str] {\n     let vec[str] v = vec();\n     let str accum = \"\";\n     let bool ends_with_sep = false;\n     for (u8 c in s) {\n         if (c == sep) {\n-            v += accum;\n+            v += vec(accum);\n             accum = \"\";\n             ends_with_sep = true;\n         } else {\n-            accum += c;\n+            accum += unsafe_from_byte(c);\n             ends_with_sep = false;\n         }\n     }\n     if (_str.byte_len(accum) != 0u ||\n         ends_with_sep) {\n-        v += accum;\n+        v += vec(accum);\n     }\n     ret v;\n }"}, {"sha": "5e8d4b975e3847028d84939c3be5cea4046a8d3f", "filename": "src/lib/_uint.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2F_uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2F_uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_uint.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -61,15 +61,15 @@ fn to_str(mutable uint n, uint radix) -> str\n \n     let str s = \"\";\n     while (n != 0u) {\n-        s += digit(n % radix) as u8;\n+        s += _str.unsafe_from_byte(digit(n % radix) as u8);\n         n /= radix;\n     }\n \n     let str s1 = \"\";\n     let uint len = _str.byte_len(s);\n     while (len != 0u) {\n         len -= 1u;\n-        s1 += s.(len);\n+        s1 += _str.unsafe_from_byte(s.(len));\n     }\n     ret s1;\n "}, {"sha": "80cd242d2c8fe0af3106996c3e6e773e2cf2ab2f", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -103,28 +103,32 @@ fn slice[T](vec[T] v, uint start, uint end) -> vec[T] {\n     ret result;\n }\n \n-fn shift[T](vec[T] v) -> vec[T] {\n-    check(len[T](v) > 0u);\n-    ret slice[T](v, 1u, len[T](v));\n+fn shift[T](&mutable vec[T] v) -> T {\n+    auto ln = len[T](v);\n+    check(ln > 0u);\n+    auto e = v.(0);\n+    v = slice[T](v, 1u, ln);\n+    ret e;\n }\n \n-fn pop[T](vec[T] v) -> vec[T] {\n-    check(len[T](v) > 0u);\n-    ret slice[T](v, 0u, len[T](v) - 1u);\n+fn pop[T](&mutable vec[T] v) -> T {\n+    auto ln = len[T](v);\n+    check(ln > 0u);\n+    ln -= 1u;\n+    auto e = v.(ln);\n+    v = slice[T](v, 0u, ln);\n+    ret e;\n }\n \n-fn push[T](vec[T] v, &T t) -> vec[T] {\n-    v += t;\n-    ret v;\n+fn push[T](&mutable vec[T] v, &T t) {\n+    v += vec(t);\n }\n \n-fn unshift[T](vec[T] v, &T t) -> vec[T] {\n+fn unshift[T](&mutable vec[T] v, &T t) {\n     auto res = alloc[T](len[T](v) + 1u);\n-    res += t;\n-    for (T t_ in v) {\n-        res += t_;\n-    }\n-    ret res;\n+    res += vec(t);\n+    res += v;\n+    v = res;\n }\n \n fn grow[T](&mutable vec[T] v, int n, &T initval) {\n@@ -152,7 +156,7 @@ fn map2[T,U,V](&operator2[T,U,V] f, &vec[T] v0, &vec[U] v1) -> vec[V] {\n     let vec[V] u = alloc[V](v0_len);\n     auto i = 0u;\n     while (i < v0_len) {\n-        u += f(v0.(i), v1.(i));\n+        u += vec(f(v0.(i), v1.(i)));\n         i += 1u;\n     }\n "}, {"sha": "677bbcc4ec867b3b84372f1f0b2c40010a74a339", "filename": "src/lib/fs.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -38,8 +38,18 @@ impure fn list_dir(path p) -> vec[str] {\n   let vec[str] full_paths = vec();\n   for (str filename in os_fs.list_dir(p)) {\n     if (!_str.eq(filename, \".\")) {if (!_str.eq(filename, \"..\")) {\n-      full_paths = _vec.push[str](full_paths, p + filename);\n+      _vec.push[str](full_paths, p + filename);\n     }}\n   }\n   ret full_paths;\n }\n+\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "a84fbbe995eb0ff3c8a9a40377acd36d21c0279f", "filename": "src/lib/io.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -52,7 +52,8 @@ state obj FILE_reader(os.libc.FILE f, bool must_close) {\n       auto buf = \"\";\n       while (true) {\n         auto ch = os.libc.fgetc(f);\n-        if (ch == -1) {break;} if (ch == 10) {break;}\n+        if (ch == -1) { ret buf; }\n+        if (ch == 10) { ret buf; }\n         buf += _str.unsafe_from_bytes(vec(ch as u8));\n       }\n       ret buf;\n@@ -61,7 +62,7 @@ state obj FILE_reader(os.libc.FILE f, bool must_close) {\n         auto buf = \"\";\n         while (true) {\n             auto ch = os.libc.fgetc(f);\n-            if (ch < 1) {break;}\n+            if (ch < 1) { ret buf; }\n             buf += _str.unsafe_from_bytes(vec(ch as u8));\n         }\n         ret buf;"}, {"sha": "29a6f6eb96ba644d24439ad2b347555324c6a6ef", "filename": "src/lib/option.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Foption.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -31,6 +31,13 @@ fn map[T, U](&operator[T, U] f, &t[T] opt) -> t[U] {\n     fail;   // FIXME: remove me when exhaustiveness checking works\n }\n \n+fn is_none[T](&t[T] opt) -> bool {\n+    alt (opt) {\n+        case (none[T])      { ret true; }\n+        case (some[T](_))   { ret false; }\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "0a37f85d16e7dbafbc1cbddf2abcb1b89160a86d", "filename": "src/lib/posix_fs.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fposix_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fposix_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fposix_fs.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -9,11 +9,23 @@ impure fn list_dir(str path) -> vec[str] {\n   let vec[str] result = vec();\n   while (true) {\n     auto ent = os.libc.readdir(dir);\n-    if (ent as int == 0) {break;}\n-    result = _vec.push[str](result, rustrt.rust_dirent_filename(ent));\n+    if (ent as int == 0) {\n+        os.libc.closedir(dir);\n+        ret result;\n+    }\n+    _vec.push[str](result, rustrt.rust_dirent_filename(ent));\n   }\n   os.libc.closedir(dir);\n   ret result;\n }\n \n const char path_sep = '/';\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "f3ea95a1d644c90ebcdc13724fa0faddff7023f1", "filename": "src/lib/run_program.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Frun_program.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Frun_program.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Frun_program.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -8,9 +8,9 @@ native \"rust\" mod rustrt {\n fn argvec(str prog, vec[str] args) -> vec[sbuf] {\n     auto argptrs = vec(_str.buf(prog));\n     for (str arg in args) {\n-        argptrs = _vec.push[sbuf](argptrs, _str.buf(arg));\n+        _vec.push[sbuf](argptrs, _str.buf(arg));\n     }\n-    argptrs = _vec.push[sbuf](argptrs, 0 as sbuf);\n+    _vec.push[sbuf](argptrs, 0 as sbuf);\n     ret argptrs;\n }\n "}, {"sha": "6b4e623b55081f0e85e3cc3c40298d8e987ce98c", "filename": "src/lib/sha1.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fsha1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fsha1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsha1.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -169,10 +169,11 @@ fn mk_sha1() -> sha1 {\n \n         let vec[u8] res = vec();\n         for (u32 hpart in st.h) {\n-            res += (hpart >> 24u32) & 0xFFu32 as u8;\n-            res += (hpart >> 16u32) & 0xFFu32 as u8;\n-            res += (hpart >> 8u32) & 0xFFu32 as u8;\n-            res += hpart & 0xFFu32 as u8;\n+            auto a = (hpart >> 24u32) & 0xFFu32 as u8;\n+            auto b = (hpart >> 16u32) & 0xFFu32 as u8;\n+            auto c = (hpart >> 8u32) & 0xFFu32 as u8;\n+            auto d = (hpart & 0xFFu32 as u8);\n+            res += vec(a,b,c,d);\n         }\n         ret res;\n     }"}, {"sha": "52839b1f6ac69b95302d904bfc54eea82613bc32", "filename": "src/lib/sort.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsort.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -5,38 +5,38 @@ type lteq[T] = fn(&T a, &T b) -> bool;\n \n fn merge_sort[T](lteq[T] le, vec[T] v) -> vec[T] {\n \n-  fn merge[T](lteq[T] le, vec[T] a, vec[T] b) -> vec[T] {\n-    let vec[T] res = vec();\n-    let uint a_len = len[T](a);\n-    let uint a_ix = 0u;\n-    let uint b_len = len[T](b);\n-    let uint b_ix = 0u;\n-    while (a_ix < a_len && b_ix < b_len) {\n-      if (le(a.(a_ix), b.(b_ix))) {\n-        res += a.(a_ix);\n-        a_ix += 1u;\n-      } else {\n-        res += b.(b_ix);\n-        b_ix += 1u;\n-      }\n+    fn merge[T](lteq[T] le, vec[T] a, vec[T] b) -> vec[T] {\n+        let vec[T] res = vec();\n+        let uint a_len = len[T](a);\n+        let uint a_ix = 0u;\n+        let uint b_len = len[T](b);\n+        let uint b_ix = 0u;\n+        while (a_ix < a_len && b_ix < b_len) {\n+            if (le(a.(a_ix), b.(b_ix))) {\n+                res += vec(a.(a_ix));\n+                a_ix += 1u;\n+            } else {\n+                res += vec(b.(b_ix));\n+                b_ix += 1u;\n+            }\n+        }\n+        res += slice[T](a, a_ix, a_len);\n+        res += slice[T](b, b_ix, b_len);\n+        ret res;\n     }\n-    res += slice[T](a, a_ix, a_len);\n-    res += slice[T](b, b_ix, b_len);\n-    ret res;\n-  }\n \n-  let uint v_len = len[T](v);\n+    let uint v_len = len[T](v);\n \n-  if (v_len <= 1u) {\n-    ret v;\n-  }\n+    if (v_len <= 1u) {\n+        ret v;\n+    }\n \n-  let uint mid = v_len / 2u;\n-  let vec[T] a = slice[T](v, 0u, mid);\n-  let vec[T] b = slice[T](v, mid, v_len);\n-  ret merge[T](le,\n-               merge_sort[T](le, a),\n-               merge_sort[T](le, b));\n+    let uint mid = v_len / 2u;\n+    let vec[T] a = slice[T](v, 0u, mid);\n+    let vec[T] b = slice[T](v, mid, v_len);\n+    ret merge[T](le,\n+                 merge_sort[T](le, a),\n+                 merge_sort[T](le, b));\n }\n \n // Local Variables:"}, {"sha": "7a3cdbb206aeda66af27f66abeeb227d738b576e", "filename": "src/lib/std.rc", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -34,6 +34,17 @@ auth _str = unsafe;\n auth _vec = unsafe;\n auth _task = unsafe;\n \n+\n+// FIXME: impure on these will infect caller in a way that is totally\n+// beyond reason, if the caller's mutated-argument doesn't escape;\n+// 'impure' needs work.\n+auth _str.unshift_byte = impure;\n+auth _str.shift_byte = impure;\n+auth _str.pop_byte = impure;\n+auth _vec.shift = impure;\n+auth _vec.unshift = impure;\n+auth _vec.pop = impure;\n+\n auth dbg = unsafe;\n \n auth _uint.next_power_of_two = unsafe;"}, {"sha": "f88d7798f9cc9f8892660a08737eb657661d9afd", "filename": "src/lib/win32_fs.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fwin32_fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Flib%2Fwin32_fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_fs.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -8,3 +8,12 @@ impure fn list_dir(str path) -> vec[str] {\n }\n \n const char path_sep = '\\\\';\n+\n+// Local Variables:\n+// mode: rust;\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C .. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "c1b521b505a2cacafa0674609dfc51dbb4b148c4", "filename": "src/llvmext/rustllvm.def", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fllvmext%2Frustllvm.def", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Fllvmext%2Frustllvm.def", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvmext%2Frustllvm.def?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -0,0 +1,473 @@\n+LIBRARY RUSTLLVM\n+EXPORTS\n+\tLLVMRustCreateMemoryBufferWithContentsOfFile\n+\tLLVMRustGetLastError\n+\tLLVMCreateObjectFile\n+\tLLVMDisposeObjectFile\n+\tLLVMGetSections\n+\tLLVMDisposeSectionIterator\n+\tLLVMIsSectionIteratorAtEnd\n+\tLLVMMoveToNextSection\n+\tLLVMGetSectionName\n+\tLLVMGetSectionSize\n+\tLLVMGetSectionContents\n+\tLLVMABIAlignmentOfType\n+\tLLVMABISizeOfType\n+\tLLVMAddAlias\n+\tLLVMAddAttribute\n+\tLLVMAddCase\n+\tLLVMAddDestination\n+\tLLVMAddFunction\n+\tLLVMAddFunctionAttr\n+\tLLVMAddGlobal\n+\tLLVMAddGlobalInAddressSpace\n+\tLLVMAddGlobalMapping\n+\tLLVMAddIncoming\n+\tLLVMAddInstrAttribute\n+\tLLVMAddModule\n+\tLLVMAddModuleProvider\n+\tLLVMAddTargetData\n+\tLLVMAddTypeName\n+\tLLVMAlignOf\n+\tLLVMAppendBasicBlock\n+\tLLVMAppendBasicBlockInContext\n+\tLLVMArrayType\n+\tLLVMBasicBlockAsValue\n+\tLLVMBlockAddress\n+\tLLVMBuildAShr\n+\tLLVMBuildAdd\n+\tLLVMBuildAggregateRet\n+\tLLVMBuildAlloca\n+\tLLVMBuildAnd\n+\tLLVMBuildArrayAlloca\n+\tLLVMBuildArrayMalloc\n+\tLLVMBuildBinOp\n+\tLLVMBuildBitCast\n+\tLLVMBuildBr\n+\tLLVMBuildCall\n+\tLLVMBuildCast\n+\tLLVMBuildCondBr\n+\tLLVMBuildExactSDiv\n+\tLLVMBuildExtractElement\n+\tLLVMBuildExtractValue\n+\tLLVMBuildFAdd\n+\tLLVMBuildFCmp\n+\tLLVMBuildFDiv\n+\tLLVMBuildFMul\n+\tLLVMBuildFNeg\n+\tLLVMBuildFPCast\n+\tLLVMBuildFPExt\n+\tLLVMBuildFPToSI\n+\tLLVMBuildFPToUI\n+\tLLVMBuildFPTrunc\n+\tLLVMBuildFRem\n+\tLLVMBuildFSub\n+\tLLVMBuildFree\n+\tLLVMBuildGEP\n+\tLLVMBuildGlobalString\n+\tLLVMBuildGlobalStringPtr\n+\tLLVMBuildICmp\n+\tLLVMBuildInBoundsGEP\n+\tLLVMBuildIndirectBr\n+\tLLVMBuildInsertElement\n+\tLLVMBuildInsertValue\n+\tLLVMBuildIntCast\n+\tLLVMBuildIntToPtr\n+\tLLVMBuildInvoke\n+\tLLVMBuildIsNotNull\n+\tLLVMBuildIsNull\n+\tLLVMBuildLShr\n+\tLLVMBuildLoad\n+\tLLVMBuildMalloc\n+\tLLVMBuildMul\n+\tLLVMBuildNSWAdd\n+\tLLVMBuildNSWMul\n+\tLLVMBuildNSWNeg\n+\tLLVMBuildNSWSub\n+\tLLVMBuildNUWAdd\n+\tLLVMBuildNUWMul\n+\tLLVMBuildNUWNeg\n+\tLLVMBuildNUWSub\n+\tLLVMBuildNeg\n+\tLLVMBuildNot\n+\tLLVMBuildOr\n+\tLLVMBuildPhi\n+\tLLVMBuildPointerCast\n+\tLLVMBuildPtrDiff\n+\tLLVMBuildPtrToInt\n+\tLLVMBuildRet\n+\tLLVMBuildRetVoid\n+\tLLVMBuildSDiv\n+\tLLVMBuildSExt\n+\tLLVMBuildSExtOrBitCast\n+\tLLVMBuildSIToFP\n+\tLLVMBuildSRem\n+\tLLVMBuildSelect\n+\tLLVMBuildShl\n+\tLLVMBuildShuffleVector\n+\tLLVMBuildStore\n+\tLLVMBuildStructGEP\n+\tLLVMBuildSub\n+\tLLVMBuildSwitch\n+\tLLVMBuildTrunc\n+\tLLVMBuildTruncOrBitCast\n+\tLLVMBuildUDiv\n+\tLLVMBuildUIToFP\n+\tLLVMBuildURem\n+\tLLVMBuildUnreachable\n+\tLLVMBuildUnwind\n+\tLLVMBuildVAArg\n+\tLLVMBuildXor\n+\tLLVMBuildZExt\n+\tLLVMBuildZExtOrBitCast\n+\tLLVMByteOrder\n+\tLLVMCallFrameAlignmentOfType\n+\tLLVMClearInsertionPosition\n+\tLLVMConstAShr\n+\tLLVMConstAdd\n+\tLLVMConstAllOnes\n+\tLLVMConstAnd\n+\tLLVMConstArray\n+\tLLVMConstBitCast\n+\tLLVMConstExactSDiv\n+\tLLVMConstExtractElement\n+\tLLVMConstExtractValue\n+\tLLVMConstFAdd\n+\tLLVMConstFCmp\n+\tLLVMConstFDiv\n+\tLLVMConstFMul\n+\tLLVMConstFNeg\n+\tLLVMConstFPCast\n+\tLLVMConstFPExt\n+\tLLVMConstFPToSI\n+\tLLVMConstFPToUI\n+\tLLVMConstFPTrunc\n+\tLLVMConstFRem\n+\tLLVMConstFSub\n+\tLLVMConstGEP\n+\tLLVMConstICmp\n+\tLLVMConstInBoundsGEP\n+\tLLVMConstInlineAsm\n+\tLLVMConstInsertElement\n+\tLLVMConstInsertValue\n+\tLLVMConstInt\n+\tLLVMConstIntCast\n+\tLLVMConstIntGetSExtValue\n+\tLLVMConstIntGetZExtValue\n+\tLLVMConstIntOfArbitraryPrecision\n+\tLLVMConstIntOfString\n+\tLLVMConstIntOfStringAndSize\n+\tLLVMConstIntToPtr\n+\tLLVMConstLShr\n+\tLLVMConstMul\n+\tLLVMConstNSWAdd\n+\tLLVMConstNSWMul\n+\tLLVMConstNSWNeg\n+\tLLVMConstNSWSub\n+\tLLVMConstNUWAdd\n+\tLLVMConstNUWMul\n+\tLLVMConstNUWNeg\n+\tLLVMConstNUWSub\n+\tLLVMConstNeg\n+\tLLVMConstNot\n+\tLLVMConstNull\n+\tLLVMConstOr\n+\tLLVMConstPointerCast\n+\tLLVMConstPointerNull\n+\tLLVMConstPtrToInt\n+\tLLVMConstReal\n+\tLLVMConstRealOfString\n+\tLLVMConstRealOfStringAndSize\n+\tLLVMConstSDiv\n+\tLLVMConstSExt\n+\tLLVMConstSExtOrBitCast\n+\tLLVMConstSIToFP\n+\tLLVMConstSRem\n+\tLLVMConstSelect\n+\tLLVMConstShl\n+\tLLVMConstShuffleVector\n+\tLLVMConstString\n+\tLLVMConstStringInContext\n+\tLLVMConstStruct\n+\tLLVMConstStructInContext\n+\tLLVMConstSub\n+\tLLVMConstTrunc\n+\tLLVMConstTruncOrBitCast\n+\tLLVMConstUDiv\n+\tLLVMConstUIToFP\n+\tLLVMConstURem\n+\tLLVMConstVector\n+\tLLVMConstXor\n+\tLLVMConstZExt\n+\tLLVMConstZExtOrBitCast\n+\tLLVMContextCreate\n+\tLLVMContextDispose\n+\tLLVMCopyStringRepOfTargetData\n+\tLLVMCountBasicBlocks\n+\tLLVMCountIncoming\n+\tLLVMCountParamTypes\n+\tLLVMCountParams\n+\tLLVMCountStructElementTypes\n+\tLLVMCreateBuilder\n+\tLLVMCreateBuilderInContext\n+\tLLVMCreateExecutionEngine\n+\tLLVMCreateExecutionEngineForModule\n+\tLLVMCreateFunctionPassManager\n+\tLLVMCreateFunctionPassManagerForModule\n+\tLLVMCreateGenericValueOfFloat\n+\tLLVMCreateGenericValueOfInt\n+\tLLVMCreateGenericValueOfPointer\n+\tLLVMCreateInterpreter\n+\tLLVMCreateInterpreterForModule\n+\tLLVMCreateJITCompiler\n+\tLLVMCreateJITCompilerForModule\n+\tLLVMCreateMemoryBufferWithContentsOfFile\n+\tLLVMCreateMemoryBufferWithSTDIN\n+\tLLVMCreateModuleProviderForExistingModule\n+\tLLVMCreateObjectFile\n+\tLLVMCreatePassManager\n+\tLLVMCreateTargetData\n+\tLLVMCreateTypeHandle\n+\tLLVMDeleteBasicBlock\n+\tLLVMDeleteFunction\n+\tLLVMDeleteGlobal\n+\tLLVMDeleteTypeName\n+\tLLVMDisposeBuilder\n+\tLLVMDisposeExecutionEngine\n+\tLLVMDisposeGenericValue\n+\tLLVMDisposeMemoryBuffer\n+\tLLVMDisposeMessage\n+\tLLVMDisposeModule\n+\tLLVMDisposeModuleProvider\n+\tLLVMDisposeObjectFile\n+\tLLVMDisposePassManager\n+\tLLVMDisposeSectionIterator\n+\tLLVMDisposeTargetData\n+\tLLVMDisposeTypeHandle\n+\tLLVMDoubleType\n+\tLLVMDoubleTypeInContext\n+\tLLVMDumpModule\n+\tLLVMDumpValue\n+\tLLVMElementAtOffset\n+\tLLVMFP128Type\n+\tLLVMFP128TypeInContext\n+\tLLVMFinalizeFunctionPassManager\n+\tLLVMFindFunction\n+\tLLVMFloatType\n+\tLLVMFloatTypeInContext\n+\tLLVMFreeMachineCodeForFunction\n+\tLLVMFunctionType\n+\tLLVMGenericValueIntWidth\n+\tLLVMGenericValueToFloat\n+\tLLVMGenericValueToInt\n+\tLLVMGenericValueToPointer\n+\tLLVMGetAlignment\n+\tLLVMGetArrayLength\n+\tLLVMGetAttribute\n+\tLLVMGetBasicBlockParent\n+\tLLVMGetBasicBlocks\n+\tLLVMGetBitcodeModule\n+\tLLVMGetBitcodeModuleInContext\n+\tLLVMGetBitcodeModuleProvider\n+\tLLVMGetBitcodeModuleProviderInContext\n+\tLLVMGetConstOpcode\n+\tLLVMGetCurrentDebugLocation\n+\tLLVMGetDataLayout\n+\tLLVMGetElementType\n+\tLLVMGetEntryBasicBlock\n+\tLLVMGetExecutionEngineTargetData\n+\tLLVMGetFirstBasicBlock\n+\tLLVMGetFirstFunction\n+\tLLVMGetFirstGlobal\n+\tLLVMGetFirstInstruction\n+\tLLVMGetFirstParam\n+\tLLVMGetFirstUse\n+\tLLVMGetFunctionAttr\n+\tLLVMGetFunctionCallConv\n+\tLLVMGetGC\n+\tLLVMGetGlobalContext\n+\tLLVMGetGlobalParent\n+\tLLVMGetGlobalPassRegistry\n+\tLLVMGetIncomingBlock\n+\tLLVMGetIncomingValue\n+\tLLVMGetInitializer\n+\tLLVMGetInsertBlock\n+\tLLVMGetInstructionCallConv\n+\tLLVMGetInstructionParent\n+\tLLVMGetIntTypeWidth\n+\tLLVMGetIntrinsicID\n+\tLLVMGetLastBasicBlock\n+\tLLVMGetLastFunction\n+\tLLVMGetLastGlobal\n+\tLLVMGetLastInstruction\n+\tLLVMGetLastParam\n+\tLLVMGetLinkage\n+\tLLVMGetMDKindID\n+\tLLVMGetMDKindIDInContext\n+\tLLVMGetMetadata\n+\tLLVMGetModuleContext\n+\tLLVMGetNamedFunction\n+\tLLVMGetNamedGlobal\n+\tLLVMGetNextBasicBlock\n+\tLLVMGetNextFunction\n+\tLLVMGetNextGlobal\n+\tLLVMGetNextInstruction\n+\tLLVMGetNextParam\n+\tLLVMGetNextUse\n+\tLLVMGetNumOperands\n+\tLLVMGetOperand\n+\tLLVMGetParam\n+\tLLVMGetParamParent\n+\tLLVMGetParamTypes\n+\tLLVMGetParams\n+\tLLVMGetPointerAddressSpace\n+\tLLVMGetPointerToGlobal\n+\tLLVMGetPreviousBasicBlock\n+\tLLVMGetPreviousFunction\n+\tLLVMGetPreviousGlobal\n+\tLLVMGetPreviousInstruction\n+\tLLVMGetPreviousParam\n+\tLLVMGetReturnType\n+\tLLVMGetSection\n+\tLLVMGetSectionContents\n+\tLLVMGetSectionName\n+\tLLVMGetSectionSize\n+\tLLVMGetSections\n+\tLLVMGetStructElementTypes\n+\tLLVMGetTarget\n+\tLLVMGetTypeByName\n+\tLLVMGetTypeContext\n+\tLLVMGetTypeKind\n+\tLLVMGetTypeName\n+\tLLVMGetUndef\n+\tLLVMGetUsedValue\n+\tLLVMGetUser\n+\tLLVMGetValueName\n+\tLLVMGetVectorSize\n+\tLLVMGetVisibility\n+\tLLVMHasMetadata\n+\tLLVMInitializeAnalysis\n+\tLLVMInitializeCodeGen\n+\tLLVMInitializeCore\n+\tLLVMInitializeFunctionPassManager\n+\tLLVMInitializeIPA\n+\tLLVMInitializeIPO\n+\tLLVMInitializeInstCombine\n+\tLLVMInitializeInstrumentation\n+\tLLVMInitializeScalarOpts\n+\tLLVMInitializeTarget\n+\tLLVMInitializeTransformUtils\n+\tLLVMInsertBasicBlock\n+\tLLVMInsertBasicBlockInContext\n+\tLLVMInsertIntoBuilder\n+\tLLVMInsertIntoBuilderWithName\n+\tLLVMInt16Type\n+\tLLVMInt16TypeInContext\n+\tLLVMInt1Type\n+\tLLVMInt1TypeInContext\n+\tLLVMInt32Type\n+\tLLVMInt32TypeInContext\n+\tLLVMInt64Type\n+\tLLVMInt64TypeInContext\n+\tLLVMInt8Type\n+\tLLVMInt8TypeInContext\n+\tLLVMIntPtrType\n+\tLLVMIntType\n+\tLLVMIntTypeInContext\n+\tLLVMInvalidateStructLayout\n+\tLLVMIsConstant\n+\tLLVMIsDeclaration\n+\tLLVMIsFunctionVarArg\n+\tLLVMIsGlobalConstant\n+\tLLVMIsNull\n+\tLLVMIsPackedStruct\n+\tLLVMIsSectionIteratorAtEnd\n+\tLLVMIsTailCall\n+\tLLVMIsThreadLocal\n+\tLLVMIsUndef\n+\tLLVMLabelType\n+\tLLVMLabelTypeInContext\n+\tLLVMLinkInInterpreter\n+\tLLVMLinkInJIT\n+\tLLVMMDNode\n+\tLLVMMDNodeInContext\n+\tLLVMMDString\n+\tLLVMMDStringInContext\n+\tLLVMModuleCreateWithName\n+\tLLVMModuleCreateWithNameInContext\n+\tLLVMMoveBasicBlockAfter\n+\tLLVMMoveBasicBlockBefore\n+\tLLVMMoveToNextSection\n+\tLLVMOffsetOfElement\n+\tLLVMOpaqueType\n+\tLLVMOpaqueTypeInContext\n+\tLLVMPPCFP128Type\n+\tLLVMPPCFP128TypeInContext\n+\tLLVMParseBitcode\n+\tLLVMParseBitcodeInContext\n+\tLLVMPointerSize\n+\tLLVMPointerType\n+\tLLVMPositionBuilder\n+\tLLVMPositionBuilderAtEnd\n+\tLLVMPositionBuilderBefore\n+\tLLVMPreferredAlignmentOfGlobal\n+\tLLVMPreferredAlignmentOfType\n+\tLLVMRecompileAndRelinkFunction\n+\tLLVMRefineType\n+\tLLVMRemoveAttribute\n+\tLLVMRemoveFunctionAttr\n+\tLLVMRemoveInstrAttribute\n+\tLLVMRemoveModule\n+\tLLVMRemoveModuleProvider\n+\tLLVMReplaceAllUsesWith\n+\tLLVMResolveTypeHandle\n+\tLLVMRunFunction\n+\tLLVMRunFunctionAsMain\n+\tLLVMRunFunctionPassManager\n+\tLLVMRunPassManager\n+\tLLVMRunStaticConstructors\n+\tLLVMRunStaticDestructors\n+\tLLVMSetAlignment\n+\tLLVMSetCurrentDebugLocation\n+\tLLVMSetDataLayout\n+\tLLVMSetFunctionCallConv\n+\tLLVMSetGC\n+\tLLVMSetGlobalConstant\n+\tLLVMSetInitializer\n+\tLLVMSetInstDebugLocation\n+\tLLVMSetInstrParamAlignment\n+\tLLVMSetInstructionCallConv\n+\tLLVMSetLinkage\n+\tLLVMSetMetadata\n+\tLLVMSetModuleInlineAsm\n+\tLLVMSetOperand\n+\tLLVMSetParamAlignment\n+\tLLVMSetSection\n+\tLLVMSetTailCall\n+\tLLVMSetTarget\n+\tLLVMSetThreadLocal\n+\tLLVMSetValueName\n+\tLLVMSetVisibility\n+\tLLVMSizeOf\n+\tLLVMSizeOfTypeInBits\n+\tLLVMStoreSizeOfType\n+\tLLVMStructType\n+\tLLVMStructTypeInContext\n+\tLLVMTypeOf\n+\tLLVMValueAsBasicBlock\n+\tLLVMValueIsBasicBlock\n+\tLLVMVectorType\n+\tLLVMVerifyFunction\n+\tLLVMVerifyModule\n+\tLLVMViewFunctionCFG\n+\tLLVMViewFunctionCFGOnly\n+\tLLVMVoidType\n+\tLLVMVoidTypeInContext\n+\tLLVMWriteBitcodeToFD\n+\tLLVMWriteBitcodeToFile\n+\tLLVMWriteBitcodeToFileHandle\n+\tLLVMX86FP80Type\n+\tLLVMX86FP80TypeInContext\n+\tLLVMX86MMXType\n+\tLLVMX86MMXTypeInContext\n+"}, {"sha": "1f17fc8c0759d375aa7b20635771d7115602f0ab", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -207,6 +207,29 @@ str_from_vec(rust_task *task, rust_vec *v)\n     return st;\n }\n \n+extern \"C\" CDECL rust_str *\n+str_from_cstr(rust_task *task, char *sbuf)\n+{\n+    size_t len = strlen(sbuf) + 1;\n+    rust_str *st = vec_alloc_with_data(task, len, len, 1, sbuf);\n+    if (!st) {\n+        task->fail(2);\n+        return NULL;\n+    }\n+    return st;\n+}\n+\n+extern \"C\" CDECL rust_str *\n+str_from_buf(rust_task *task, char *buf, unsigned int len) {\n+    rust_str *st = vec_alloc_with_data(task, len + 1, len, 1, buf);\n+    if (!st) {\n+        task->fail(2);\n+        return NULL;\n+    }\n+    st->data[st->fill++] = '\\0';\n+    return st;\n+}\n+\n extern \"C\" CDECL void *\n rand_new(rust_task *task)\n {"}, {"sha": "096389416a85516e743748f972f8feaaab45fec3", "filename": "src/test/bench/99-bottles/99bob-iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-iter.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -40,7 +40,7 @@ case (1) {\n       b += ns;\n     }\n     else {\n-      b += t.(i);\n+      _str.push_byte(b, t.(i));\n     }\n     i += 1u;\n   }"}, {"sha": "3c426f51036c5b8b100a122e9f4c56aae53edae4", "filename": "src/test/bench/99-bottles/99bob-simple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2F99-bottles%2F99bob-simple.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -39,7 +39,7 @@ case (1) {\n       b += ns;\n     }\n     else {\n-      b += t.(i);\n+      _str.push_byte(b, t.(i));\n     }\n     i += 1u;\n   }"}, {"sha": "f88f4330fcef624fd2cfd2b93fcd21e128fcddf5", "filename": "src/test/bench/shootout/fasta.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffasta.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -28,7 +28,7 @@ fn make_cumulative(vec[aminoacids] aa) -> vec[aminoacids] {\n   let vec[aminoacids] ans = vec();\n   for (aminoacids a in aa) {\n     cp += a._1;\n-    ans += tup(a._0, cp);\n+    ans += vec(tup(a._0, cp));\n   }\n   ret ans;\n }\n@@ -59,7 +59,7 @@ fn make_random_fasta(str id, str desc, vec[aminoacids] genelist, int n) {\n   auto rng = myrandom(std.rand.mk_rng().next());\n   let str op = \"\";\n   for each (uint i in _uint.range(0u, n as uint)) {\n-    op += select_random(rng.next(100u32), genelist) as u8;\n+    _str.push_byte(op, select_random(rng.next(100u32), genelist) as u8);\n     if (_str.byte_len(op) >= LINE_LENGTH()) {\n       log(op);\n       op = \"\";\n@@ -76,7 +76,7 @@ fn make_repeat_fasta(str id, str desc, str s, int n) {\n   let uint sl = _str.byte_len(s);\n   for each (uint i in _uint.range(0u, n as uint)) {\n \n-    op += s.(i % sl);\n+    _str.push_byte(op, s.(i % sl));\n     if (_str.byte_len(op) >= LINE_LENGTH()) {\n       log(op);\n       op = \"\";"}, {"sha": "05b3478ba0daa77e36700e362587a995ca03b1c9", "filename": "src/test/run-pass/append-units.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/830f2d02f19b45ff4b4a4d7946b69f206b5dcdff/src%2Ftest%2Frun-pass%2Fappend-units.rs", "raw_url": "https://github.com/rust-lang/rust/raw/830f2d02f19b45ff4b4a4d7946b69f206b5dcdff/src%2Ftest%2Frun-pass%2Fappend-units.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fappend-units.rs?ref=830f2d02f19b45ff4b4a4d7946b69f206b5dcdff", "patch": "@@ -1,15 +0,0 @@\n-fn main() {\n-  auto v = vec(1,2,3);\n-  v += 4;\n-  v += 5;\n-  check (v.(3) == 4);\n-  check (v.(4) == 5);\n-\n-  auto s = \"hello\";\n-  log s;\n-  s += 'z' as u8;\n-  s += 'y' as u8;\n-  log s;\n-  check (s.(5) == 'z' as u8);\n-  check (s.(6) == 'y' as u8);\n-}"}, {"sha": "7ba19e925d76d53f08b5c52e63b45123408bea87", "filename": "src/test/run-pass/lib-str-buf.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Ftest%2Frun-pass%2Flib-str-buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-str-buf.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -0,0 +1,14 @@\n+// -*- rust -*-\n+\n+use std;\n+import std._str;\n+\n+fn main() {\n+    auto s = \"hello\";\n+    auto sb = _str.rustrt.str_buf(s);\n+    auto s_cstr = _str.rustrt.str_from_cstr(sb);\n+    check (_str.eq(s_cstr, s));\n+    auto s_buf = _str.rustrt.str_from_buf(sb, 5u);\n+    check (_str.eq(s_buf, s));\n+}\n+"}, {"sha": "c0af0867faa5af26e98562ad11a535b28e6772d3", "filename": "src/test/run-pass/maybe-mutable.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs?ref=6dee1ac161a22a4bc1e49c5dac3c7bbba1ff97f0", "patch": "@@ -0,0 +1,17 @@\n+// -*- rust -*-\n+\n+fn len(vec[mutable? int] v) -> uint {\n+    auto i = 0u;\n+    for (int x in v) {\n+        i += 1u;\n+    }\n+    ret i;\n+}\n+\n+fn main() {\n+    auto v0 = vec(1, 2, 3, 4, 5);\n+    log len(v0);\n+    auto v1 = vec(mutable 1, 2, 3, 4, 5);\n+    log len(v1);\n+}\n+"}]}