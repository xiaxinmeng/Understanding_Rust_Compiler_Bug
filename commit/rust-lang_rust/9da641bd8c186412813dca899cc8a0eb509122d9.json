{"sha": "9da641bd8c186412813dca899cc8a0eb509122d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkYTY0MWJkOGMxODY0MTI4MTNkY2E4OTljYzhhMGViNTA5MTIyZDk=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-09T21:22:21Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-02-19T18:02:50Z"}, "message": "libsyntax: convert interner into a modern struct", "tree": {"sha": "60c312dd358e4fd048afd3a80ae8d60f6a641162", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60c312dd358e4fd048afd3a80ae8d60f6a641162"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9da641bd8c186412813dca899cc8a0eb509122d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9da641bd8c186412813dca899cc8a0eb509122d9", "html_url": "https://github.com/rust-lang/rust/commit/9da641bd8c186412813dca899cc8a0eb509122d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9da641bd8c186412813dca899cc8a0eb509122d9/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2ec958db5ae37f193d4d632635818241b134a617", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ec958db5ae37f193d4d632635818241b134a617", "html_url": "https://github.com/rust-lang/rust/commit/2ec958db5ae37f193d4d632635818241b134a617"}], "stats": {"total": 78, "additions": 36, "deletions": 42}, "files": [{"sha": "f145e433fa7c195f363d1b0122917d3bfad1303e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9da641bd8c186412813dca899cc8a0eb509122d9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da641bd8c186412813dca899cc8a0eb509122d9/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9da641bd8c186412813dca899cc8a0eb509122d9", "patch": "@@ -429,7 +429,7 @@ pub fn mk_ident_interner() -> @ident_interner {\n                 ];\n \n                 let rv = @ident_interner {\n-                    interner: interner::mk_prefill(init_vec)\n+                    interner: interner::Interner::prefill(init_vec)\n                 };\n \n                 task::local_data::local_data_set(interner_key!(), @rv);\n@@ -443,7 +443,7 @@ pub fn mk_ident_interner() -> @ident_interner {\n /* for when we don't care about the contents; doesn't interact with TLD or\n    serialization */\n pub fn mk_fake_ident_interner() -> @ident_interner {\n-    @ident_interner { interner: interner::mk::<@~str>() }\n+    @ident_interner { interner: interner::Interner::new() }\n }\n \n /**"}, {"sha": "dcb3261169be4b094b69e82e51c6d9fce9bd13ce", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9da641bd8c186412813dca899cc8a0eb509122d9/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9da641bd8c186412813dca899cc8a0eb509122d9/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=9da641bd8c186412813dca899cc8a0eb509122d9", "patch": "@@ -14,72 +14,66 @@\n \n use core::prelude::*;\n \n-use core::dvec::DVec;\n-use std::oldmap::HashMap;\n-use std::oldmap;\n+use hashmap::linear::LinearMap;\n+use dvec::DVec;\n \n-pub type hash_interner<T> = {map: HashMap<T, uint>, vect: DVec<T>};\n-\n-pub fn mk<T:Eq IterBytes Hash Const Copy>() -> Interner<T> {\n-    let m = oldmap::HashMap::<T, uint>();\n-    let hi: hash_interner<T> =\n-        {map: m, vect: DVec()};\n-    ((hi) as Interner::<T>)\n-}\n-\n-pub fn mk_prefill<T:Eq IterBytes Hash Const Copy>(init: &[T]) -> Interner<T> {\n-    let rv = mk();\n-    for init.each() |v| { rv.intern(*v); }\n-    return rv;\n+pub struct Interner<T> {\n+    priv mut map: LinearMap<T, uint>,\n+    priv vect: DVec<T>,\n }\n \n+// when traits can extend traits, we should extend index<uint,T> to get []\n+pub impl<T: Eq IterBytes Hash Const Copy> Interner<T> {\n+    static fn new() -> Interner<T> {\n+        Interner {\n+            map: LinearMap::new(),\n+            vect: DVec(),\n+        }\n+    }\n \n-/* when traits can extend traits, we should extend index<uint,T> to get [] */\n-pub trait Interner<T:Eq IterBytes Hash Const Copy> {\n-    fn intern(T) -> uint;\n-    fn gensym(T) -> uint;\n-    pure fn get(uint) -> T;\n-    fn len() -> uint;\n-}\n+    static fn prefill(init: &[T]) -> Interner<T> {\n+        let rv = Interner::new();\n+        for init.each() |v| { rv.intern(*v); }\n+        rv\n+    }\n \n-pub impl<T:Eq IterBytes Hash Const Copy> Interner<T> for hash_interner<T> {\n-    fn intern(val: T) -> uint {\n+    fn intern(&self, val: T) -> uint {\n         match self.map.find(&val) {\n-          Some(idx) => return idx,\n-          None => {\n-            let new_idx = self.vect.len();\n-            self.map.insert(val, new_idx);\n-            self.vect.push(val);\n-            return new_idx;\n-          }\n+            Some(&idx) => return idx,\n+            None => (),\n         }\n+\n+        let new_idx = self.vect.len();\n+        self.map.insert(val, new_idx);\n+        self.vect.push(val);\n+        new_idx\n     }\n-    fn gensym(val: T) -> uint {\n+\n+    fn gensym(&self, val: T) -> uint {\n         let new_idx = self.vect.len();\n         // leave out of .map to avoid colliding\n         self.vect.push(val);\n-        return new_idx;\n+        new_idx\n     }\n \n     // this isn't \"pure\" in the traditional sense, because it can go from\n     // failing to returning a value as items are interned. But for typestate,\n     // where we first check a pred and then rely on it, ceasing to fail is ok.\n-    pure fn get(idx: uint) -> T { self.vect.get_elt(idx) }\n+    pure fn get(&self, idx: uint) -> T { self.vect.get_elt(idx) }\n \n-    fn len() -> uint { return self.vect.len(); }\n+    fn len(&self) -> uint { self.vect.len() }\n }\n \n-\n #[test]\n #[should_fail]\n pub fn i1 () {\n-    let i : Interner<@~str> = mk();\n+    let i : Interner<@~str> = Interner::new();\n     i.get(13);\n }\n \n #[test]\n pub fn i2 () {\n-    let i : Interner<@~str> = mk();\n+    let i : Interner<@~str> = Interner::new();\n     // first one is zero:\n     assert i.intern (@~\"dog\") == 0;\n     // re-use gets the same entry:\n@@ -104,7 +98,7 @@ pub fn i2 () {\n \n #[test]\n pub fn i3 () {\n-    let i : Interner<@~str> = mk_prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n+    let i : Interner<@~str> = Interner::prefill([@~\"Alan\",@~\"Bob\",@~\"Carol\"]);\n     assert i.get(0) == @~\"Alan\";\n     assert i.get(1) == @~\"Bob\";\n     assert i.get(2) == @~\"Carol\";"}]}