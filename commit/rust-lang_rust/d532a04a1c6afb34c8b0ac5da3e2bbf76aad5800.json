{"sha": "d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ1MzJhMDRhMWM2YWZiMzRjOGIwYWM1ZGEzZTJiYmY3NmFhZDU4MDA=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-01-21T18:42:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-01-21T18:42:17Z"}, "message": "Rollup merge of #67686 - ssomers:keys_start_slasher, r=Mark-Simulacrum\n\nSimplify NodeHeader by avoiding slices in BTreeMaps with shared roots\n\nSimplify a complicated piece of code that creates slices of keys in node leaves.", "tree": {"sha": "2a8b1ad612db155b1ffde488b614a355d04e62b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a8b1ad612db155b1ffde488b614a355d04e62b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeJ0YJCRBK7hj4Ov3rIwAAdHIIAKUYY0WONproThyxUlALtPxy\nYT2UGsqXmFoft5e180yHYQvxR0KLgC0gqU+/BcsJn8ct5DuQEGGkI6PHv/evw1JU\nHujnidkUP7FwbU462fK41EK3ebOYPDcEltvBg0d1wNCklCmXS1eIHrl3SFmMN7T7\ng6L0Ji3HWcmVVOALuoAZ/OaIE/MMmZg/GJV0NEYE8CtDbzEst0sJXZb/9LWpc7V0\nB/1Qag/d1psZyud1Fvh277DldTnXyv+tLW3GJX7wQxsxi0vEomMPj9ExCeq0Dp5L\nL/iNlpc7vAtAuQ/rqSLq7MOOs4EHo7W95fN3HDJeJ6KFaC35Ya1lxf5g1+qzCN8=\n=3plj\n-----END PGP SIGNATURE-----\n", "payload": "tree 2a8b1ad612db155b1ffde488b614a355d04e62b4\nparent ce361fb24f0896bf7d983549117cbe1f70f32dcf\nparent 3e947ef031ae05c4ed56bbd6b3380bef644923f1\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1579632137 +0100\ncommitter GitHub <noreply@github.com> 1579632137 +0100\n\nRollup merge of #67686 - ssomers:keys_start_slasher, r=Mark-Simulacrum\n\nSimplify NodeHeader by avoiding slices in BTreeMaps with shared roots\n\nSimplify a complicated piece of code that creates slices of keys in node leaves.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800", "html_url": "https://github.com/rust-lang/rust/commit/d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce361fb24f0896bf7d983549117cbe1f70f32dcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce361fb24f0896bf7d983549117cbe1f70f32dcf", "html_url": "https://github.com/rust-lang/rust/commit/ce361fb24f0896bf7d983549117cbe1f70f32dcf"}, {"sha": "3e947ef031ae05c4ed56bbd6b3380bef644923f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e947ef031ae05c4ed56bbd6b3380bef644923f1", "html_url": "https://github.com/rust-lang/rust/commit/3e947ef031ae05c4ed56bbd6b3380bef644923f1"}], "stats": {"total": 89, "additions": 24, "deletions": 65}, "files": [{"sha": "e70f881bc3d7e4b9c7efb2b15872aebe0b12c2d0", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800", "patch": "@@ -1968,7 +1968,7 @@ where\n                 (i, false) => i,\n             },\n             (_, Unbounded) => 0,\n-            (true, Included(_)) => min_node.keys().len(),\n+            (true, Included(_)) => min_node.len(),\n             (true, Excluded(_)) => 0,\n         };\n \n@@ -1987,9 +1987,9 @@ where\n                 }\n                 (i, false) => i,\n             },\n-            (_, Unbounded) => max_node.keys().len(),\n+            (_, Unbounded) => max_node.len(),\n             (true, Included(_)) => 0,\n-            (true, Excluded(_)) => max_node.keys().len(),\n+            (true, Excluded(_)) => max_node.len(),\n         };\n \n         if !diverged {"}, {"sha": "d9cdebb4f73542495f1cac6c69ad6a72fc4090bf", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 11, "deletions": 54, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800", "patch": "@@ -54,10 +54,8 @@ pub const CAPACITY: usize = 2 * B - 1;\n /// `NodeHeader` because we do not want unnecessary padding between `len` and the keys.\n /// Crucially, `NodeHeader` can be safely transmuted to different K and V. (This is exploited\n /// by `as_header`.)\n-/// See `into_key_slice` for an explanation of K2. K2 cannot be safely transmuted around\n-/// because the size of `NodeHeader` depends on its alignment!\n #[repr(C)]\n-struct NodeHeader<K, V, K2 = ()> {\n+struct NodeHeader<K, V> {\n     /// We use `*const` as opposed to `*mut` so as to be covariant in `K` and `V`.\n     /// This either points to an actual node or is null.\n     parent: *const InternalNode<K, V>,\n@@ -72,9 +70,6 @@ struct NodeHeader<K, V, K2 = ()> {\n     /// This next to `parent_idx` to encourage the compiler to join `len` and\n     /// `parent_idx` into the same 32-bit word, reducing space overhead.\n     len: u16,\n-\n-    /// See `into_key_slice`.\n-    keys_start: [K2; 0],\n }\n #[repr(C)]\n struct LeafNode<K, V> {\n@@ -128,7 +123,7 @@ unsafe impl Sync for NodeHeader<(), ()> {}\n // We use just a header in order to save space, since no operation on an empty tree will\n // ever take a pointer past the first key.\n static EMPTY_ROOT_NODE: NodeHeader<(), ()> =\n-    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0, keys_start: [] };\n+    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0 };\n \n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n@@ -390,14 +385,13 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     /// Borrows a view into the keys stored in the node.\n-    /// Works on all possible nodes, including the shared root.\n-    pub fn keys(&self) -> &[K] {\n+    /// The caller must ensure that the node is not the shared root.\n+    pub unsafe fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n     /// Borrows a view into the values stored in the node.\n     /// The caller must ensure that the node is not the shared root.\n-    /// This function is not public, so doesn't have to support shared roots like `keys` does.\n     fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n@@ -515,7 +509,6 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     }\n \n     /// The caller must ensure that the node is not the shared root.\n-    /// This function is not public, so doesn't have to support shared roots like `keys` does.\n     fn keys_mut(&mut self) -> &mut [K] {\n         unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n@@ -527,48 +520,11 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    fn into_key_slice(self) -> &'a [K] {\n-        // We have to be careful here because we might be pointing to the shared root.\n-        // In that case, we must not create an `&LeafNode`.  We could just return\n-        // an empty slice whenever the length is 0 (this includes the shared root),\n-        // but we want to avoid that run-time check.\n-        // Instead, we create a slice pointing into the node whenever possible.\n-        // We can sometimes do this even for the shared root, as the slice will be\n-        // empty and `NodeHeader` contains an empty `keys_start` array.\n-        // We cannot *always* do this because:\n-        // - `keys_start` is not correctly typed because we want `NodeHeader`'s size to\n-        //   not depend on the alignment of `K` (needed because `as_header` should be safe).\n-        //   For this reason, `NodeHeader` has this `K2` parameter (that's usually `()`\n-        //   and hence just adds a size-0-align-1 field, not affecting layout).\n-        //   If the correctly typed header is more highly aligned than the allocated header,\n-        //   we cannot transmute safely.\n-        // - Even if we can transmute, the offset of a correctly typed `keys_start` might\n-        //   be different and outside the bounds of the allocated header!\n-        // So we do an alignment check and a size check first, that will be evaluated\n-        // at compile-time, and only do any run-time check in the rare case that\n-        // the compile-time checks signal danger.\n-        if (mem::align_of::<NodeHeader<K, V, K>>() > mem::align_of::<NodeHeader<K, V>>()\n-            || mem::size_of::<NodeHeader<K, V, K>>() != mem::size_of::<NodeHeader<K, V>>())\n-            && self.is_shared_root()\n-        {\n-            &[]\n-        } else {\n-            // If we are a `LeafNode<K, V>`, we can always transmute to\n-            // `NodeHeader<K, V, K>` and `keys_start` always has the same offset\n-            // as the actual `keys`.\n-            // Thanks to the checks above, we know that we can transmute to\n-            // `NodeHeader<K, V, K>` and that `keys_start` will be\n-            // in-bounds of some allocation even if this is the shared root!\n-            // (We might be one-past-the-end, but that is allowed by LLVM.)\n-            // Thus we can use `NodeHeader<K, V, K>`\n-            // to compute the pointer where the keys start.\n-            // This entire hack will become unnecessary once\n-            // <https://github.com/rust-lang/rfcs/pull/2582> lands, then we can just take a raw\n-            // pointer to the `keys` field of `*const InternalNode<K, V>`.\n-            let header = self.as_header() as *const _ as *const NodeHeader<K, V, K>;\n-            let keys = unsafe { &(*header).keys_start as *const _ as *const K };\n-            unsafe { slice::from_raw_parts(keys, self.len()) }\n-        }\n+    /// The caller must ensure that the node is not the shared root.\n+    unsafe fn into_key_slice(self) -> &'a [K] {\n+        debug_assert!(!self.is_shared_root());\n+        // We cannot be the shared root, so `as_leaf` is okay.\n+        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len())\n     }\n \n     /// The caller must ensure that the node is not the shared root.\n@@ -578,9 +534,10 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n         unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n+    /// The caller must ensure that the node is not the shared root.\n     fn into_slices(self) -> (&'a [K], &'a [V]) {\n         let k = unsafe { ptr::read(&self) };\n-        (k.into_key_slice(), self.into_val_slice())\n+        (unsafe { k.into_key_slice() }, self.into_val_slice())\n     }\n }\n "}, {"sha": "579624cdd2b6a8d2ab47d6ce41a3adc43be8325e", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=d532a04a1c6afb34c8b0ac5da3e2bbf76aad5800", "patch": "@@ -61,16 +61,18 @@ where\n {\n     // This function is defined over all borrow types (immutable, mutable, owned),\n     // and may be called on the shared root in each case.\n-    // Crucially, we use `keys()` here, i.e., we work with immutable data.\n-    // `keys_mut()` does not support the shared root, so we cannot use it.\n     // Using `keys()` is fine here even if BorrowType is mutable, as all we return\n     // is an index -- not a reference.\n-    for (i, k) in node.keys().iter().enumerate() {\n-        match key.cmp(k.borrow()) {\n-            Ordering::Greater => {}\n-            Ordering::Equal => return (i, true),\n-            Ordering::Less => return (i, false),\n+    let len = node.len();\n+    if len > 0 {\n+        let keys = unsafe { node.keys() }; // safe because a non-empty node cannot be the shared root\n+        for (i, k) in keys.iter().enumerate() {\n+            match key.cmp(k.borrow()) {\n+                Ordering::Greater => {}\n+                Ordering::Equal => return (i, true),\n+                Ordering::Less => return (i, false),\n+            }\n         }\n     }\n-    (node.keys().len(), false)\n+    (len, false)\n }"}]}