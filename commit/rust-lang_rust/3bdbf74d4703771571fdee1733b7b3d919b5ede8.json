{"sha": "3bdbf74d4703771571fdee1733b7b3d919b5ede8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNiZGJmNzRkNDcwMzc3MTU3MWZkZWUxNzMzYjdiM2Q5MTliNWVkZTg=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-07T11:36:12Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-07T13:54:01Z"}, "message": "Make moving of temporaries do the right thing, use it to optimize\n\nThis adds support for dropping cleanups for temporary values when they\nare moved somewhere else. It then adds wraps most copy operations\n(return, put in data structure, box, etc) in a way that will fall back\nto a move when it is safe.\n\nThis saves a lot of taking/dropping, shaving over a megabyte off the\nstage2/rustc binary size.\n\nIn some cases, most notably function returns, we could detect that the\nreturned value is a local variable, and can thus be safely moved even\nthough it is not a temporary. This will require putting some more\ninformation in lvals.\n\nI did not yet handle function arguments, since the logic for passing\nthem looked too convoluted to touch. I'll probably try that in the\nnear future, since it's bound to be a big win.", "tree": {"sha": "429bedad163dd9793849286415597b1312bbc781", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/429bedad163dd9793849286415597b1312bbc781"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3bdbf74d4703771571fdee1733b7b3d919b5ede8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3bdbf74d4703771571fdee1733b7b3d919b5ede8", "html_url": "https://github.com/rust-lang/rust/commit/3bdbf74d4703771571fdee1733b7b3d919b5ede8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3bdbf74d4703771571fdee1733b7b3d919b5ede8/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "007a736642ac88c0adf0d68e8dc6fcb22f0609c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/007a736642ac88c0adf0d68e8dc6fcb22f0609c3", "html_url": "https://github.com/rust-lang/rust/commit/007a736642ac88c0adf0d68e8dc6fcb22f0609c3"}], "stats": {"total": 321, "additions": 177, "deletions": 144}, "files": [{"sha": "28a02e869dc7ef1826ef6547b1aa8e81c8ed8136", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=3bdbf74d4703771571fdee1733b7b3d919b5ede8", "patch": "@@ -864,9 +864,8 @@ fn lookup_in_mod_strict(&env e, def m, &span sp, &ident name, namespace ns,\n     }\n }\n \n-fn lookup_in_mod(&env e, def m, &span sp, &ident name, namespace ns,\n-                 dir dr) ->\n-   option::t[def] {\n+fn lookup_in_mod(&env e, &def m, &span sp, &ident name, namespace ns,\n+                 dir dr) -> option::t[def] {\n     auto defid = ast::def_id_of_def(m);\n     if (defid._0 != ast::local_crate) {\n         // examining a module in an external crate\n@@ -966,14 +965,9 @@ fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp, &ident id,\n                       namespace wanted_ns, dir dr) -> option::t[def] {\n     fn per_ns(&env e, @indexed_mod info, &span sp, &ident id, namespace ns,\n               dir dr) -> option::t[def] {\n-        fn l_i_m_r(&env e, &def m, &span sp, &ident id, namespace ns, dir dr)\n-           -> option::t[def] {\n-            be lookup_in_mod(e, m, sp, id, ns, dr);\n-        }\n         auto matches =\n-            vec::filter_map[def,\n-                            def](bind l_i_m_r(e, _, sp, id, ns, dr),\n-                                 { info.glob_imports });\n+            vec::filter_map(bind lookup_in_mod(e, _, sp, id, ns, dr),\n+                            { info.glob_imports });\n         if (vec::len(matches) == 0u) {\n             ret none[def];\n         } else if (vec::len(matches) == 1u) {"}, {"sha": "b89df1fe8da8a2e2dfb693a275e7d2f783f6c9bd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 170, "deletions": 125, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3bdbf74d4703771571fdee1733b7b3d919b5ede8", "patch": "@@ -273,7 +273,43 @@ type fn_ctxt =\n         // This function's enclosing local context.\n         @local_ctxt lcx);\n \n-tag cleanup { clean(fn(&@block_ctxt) -> result ); }\n+tag cleanup {\n+    clean(fn(&@block_ctxt) -> result);\n+    clean_temp(ValueRef, fn(&@block_ctxt) -> result);\n+}\n+\n+fn add_clean(&@block_ctxt cx, ValueRef val, ty::t ty) {\n+    find_scope_cx(cx).cleanups += [clean(bind drop_slot(_, val, ty))];\n+}\n+fn add_clean_temp(&@block_ctxt cx, ValueRef val, ty::t ty) {\n+    find_scope_cx(cx).cleanups += [clean_temp(val, bind drop_ty(_, val, ty))];\n+}\n+\n+// Note that this only works for temporaries. We should, at some point, move\n+// to a system where we can also cancel the cleanup on local variables, but\n+// this will be more involved. For now, we simply zero out the local, and the\n+// drop glue checks whether it is zero.\n+fn revoke_clean(&@block_ctxt cx, ValueRef val) {\n+    auto sc_cx = find_scope_cx(cx);\n+    auto found = -1;\n+    auto i = 0;\n+    for (cleanup c in sc_cx.cleanups) {\n+        alt (c) {\n+            case (clean_temp(?v, _)) {\n+                if (v as uint == val as uint) { found = i; break; }\n+            }\n+            case (_) {}\n+        }\n+        i += 1;\n+    }\n+    // The value does not have a cleanup associated with it. Might be a\n+    // constant or some immediate value.\n+    if (found == -1) { ret; }\n+    // We found the cleanup and remove it\n+    sc_cx.cleanups = vec::slice(sc_cx.cleanups, 0u, found as uint) +\n+        vec::slice(sc_cx.cleanups, found as uint + 1u,\n+                   vec::len(sc_cx.cleanups));\n+}\n \n tag block_kind {\n \n@@ -3278,29 +3314,53 @@ fn copy_val(&@block_ctxt cx, copy_action action, ValueRef dst, ValueRef src,\n // FIXME: We always zero out the source. Ideally we would detect the\n // case where a variable is always deinitialized by block exit and thus\n // doesn't need to be dropped.\n-fn move_val(@block_ctxt cx, copy_action action, ValueRef dst, ValueRef src,\n-            &ty::t t) -> result {\n+fn move_val(@block_ctxt cx, copy_action action, ValueRef dst,\n+            &lval_result src, &ty::t t) -> result {\n+    auto src_val = src.res.val;\n     if (ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t) ||\n-            ty::type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n-        auto r = rslt(cx, cx.build.Store(cx.build.Load(src), dst));\n-        ret zero_alloca(r.bcx, src, t);\n+        ty::type_is_native(cx.fcx.lcx.ccx.tcx, t)) {\n+        if (src.is_mem) { src_val = cx.build.Load(src_val); }\n+        cx.build.Store(src_val, dst);\n+        ret rslt(cx, C_nil());\n     } else if (ty::type_is_nil(cx.fcx.lcx.ccx.tcx, t) ||\n-                   ty::type_is_bot(cx.fcx.lcx.ccx.tcx, t)) {\n+               ty::type_is_bot(cx.fcx.lcx.ccx.tcx, t)) {\n         ret rslt(cx, C_nil());\n     } else if (ty::type_is_boxed(cx.fcx.lcx.ccx.tcx, t)) {\n+        if (src.is_mem) { src_val = cx.build.Load(src_val); }\n         if (action == DROP_EXISTING) {\n             cx = drop_ty(cx, cx.build.Load(dst), t).bcx;\n         }\n-        auto r = rslt(cx, cx.build.Store(cx.build.Load(src), dst));\n-        ret zero_alloca(r.bcx, src, t);\n+        cx.build.Store(src_val, dst);\n+        if (src.is_mem) {\n+            ret zero_alloca(cx, src.res.val, t);\n+        } else { // It must be a temporary\n+            revoke_clean(cx, src_val);\n+            ret rslt(cx, C_nil());\n+        }\n     } else if (ty::type_is_structural(cx.fcx.lcx.ccx.tcx, t) ||\n-                   ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n+               ty::type_has_dynamic_size(cx.fcx.lcx.ccx.tcx, t)) {\n         if (action == DROP_EXISTING) { cx = drop_ty(cx, dst, t).bcx; }\n-        auto r = memmove_ty(cx, dst, src, t);\n-        ret zero_alloca(r.bcx, src, t);\n+        cx = memmove_ty(cx, dst, src_val, t).bcx;\n+        if (src.is_mem) {\n+            ret zero_alloca(cx, src_val, t);\n+        } else { // Temporary value\n+            revoke_clean(cx, src_val);\n+            ret rslt(cx, C_nil());\n+        }\n     }\n     cx.fcx.lcx.ccx.sess.bug(\"unexpected type in trans::move_val: \" +\n-                                ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n+                            ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n+}\n+\n+fn move_val_if_temp(@block_ctxt cx, copy_action action, ValueRef dst,\n+                    &lval_result src, &ty::t t) -> result {\n+    // Lvals in memory are not temporaries. Copy them.\n+    if (src.is_mem) {\n+        ret copy_val(cx, action, dst,\n+                     load_if_immediate(cx, src.res.val, t), t);\n+    } else {\n+        ret move_val(cx, action, dst, src, t);\n+    }\n }\n \n fn trans_lit(&@crate_ctxt cx, &ast::lit lit, ast::node_id id) -> ValueRef {\n@@ -3356,36 +3416,32 @@ fn node_type(&@crate_ctxt cx, &span sp, ast::node_id id) -> TypeRef {\n \n fn trans_unary(&@block_ctxt cx, ast::unop op, &@ast::expr e,\n                ast::node_id id) -> result {\n-    auto sub = trans_expr(cx, e);\n     auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n     alt (op) {\n         case (ast::not) {\n+            auto sub = trans_expr(cx, e);\n             auto dr = autoderef(sub.bcx, sub.val,\n                                 ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n             ret rslt(dr.bcx, dr.bcx.build.Not(dr.val));\n         }\n         case (ast::neg) {\n+            auto sub = trans_expr(cx, e);\n             auto dr = autoderef(sub.bcx, sub.val,\n                                 ty::expr_ty(cx.fcx.lcx.ccx.tcx, e));\n             if (ty::struct(cx.fcx.lcx.ccx.tcx, e_ty) == ty::ty_float) {\n                 ret rslt(dr.bcx, dr.bcx.build.FNeg(dr.val));\n             } else { ret rslt(dr.bcx, sub.bcx.build.Neg(dr.val)); }\n         }\n         case (ast::box(_)) {\n-            auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e);\n-            auto e_val = sub.val;\n-            auto box_ty = node_id_type(sub.bcx.fcx.lcx.ccx, id);\n-            sub = trans_malloc_boxed(sub.bcx, e_ty);\n-            find_scope_cx(cx).cleanups +=\n-                [clean(bind drop_ty(_, sub.val, box_ty))];\n+            auto lv = trans_lval(cx, e);\n+            auto box_ty = node_id_type(lv.res.bcx.fcx.lcx.ccx, id);\n+            auto sub = trans_malloc_boxed(lv.res.bcx, e_ty);\n+            add_clean_temp(cx, sub.val, box_ty);\n             auto box = sub.val;\n-            auto rc =\n-                sub.bcx.build.GEP(box,\n-                                  [C_int(0),\n-                                   C_int(abi::box_rc_field_refcnt)]);\n-            auto body =\n-                sub.bcx.build.GEP(box,\n-                                  [C_int(0), C_int(abi::box_rc_field_body)]);\n+            auto rc = sub.bcx.build.GEP\n+                (box, [C_int(0), C_int(abi::box_rc_field_refcnt)]);\n+            auto body = sub.bcx.build.GEP\n+                (box, [C_int(0), C_int(abi::box_rc_field_body)]);\n             sub.bcx.build.Store(C_int(1), rc);\n             // Cast the body type to the type of the value. This is needed to\n             // make tags work, since tags have a different LLVM type depending\n@@ -3396,7 +3452,7 @@ fn trans_unary(&@block_ctxt cx, ast::unop op, &@ast::expr e,\n                     T_ptr(type_of(sub.bcx.fcx.lcx.ccx, e.span, e_ty));\n                 body = sub.bcx.build.PointerCast(body, llety);\n             }\n-            sub = copy_val(sub.bcx, INIT, body, e_val, e_ty);\n+            sub = move_val_if_temp(sub.bcx, INIT, body, lv, e_ty);\n             ret rslt(sub.bcx, box);\n         }\n         case (ast::deref) {\n@@ -3831,8 +3887,7 @@ mod ivec {\n         auto unit_sz = ares.llunitsz;\n         auto llalen = ares.llalen;\n \n-        find_scope_cx(bcx).cleanups +=\n-            [clean(bind drop_ty(_, llvecptr, vec_ty))];\n+        add_clean_temp(bcx, llvecptr, vec_ty);\n \n         auto llunitty = type_of_or_i8(bcx, unit_ty);\n         auto llheappartty = T_ivec_heap_part(llunitty);\n@@ -4067,7 +4122,7 @@ fn trans_vec_add(&@block_ctxt cx, &ty::t t, ValueRef lhs, ValueRef rhs) ->\n     r = copy_val(r.bcx, INIT, tmp, lhs, t);\n     auto bcx = trans_vec_append(r.bcx, t, tmp, rhs).bcx;\n     tmp = load_if_immediate(bcx, tmp, t);\n-    find_scope_cx(cx).cleanups += [clean(bind drop_ty(_, tmp, t))];\n+    add_clean_temp(cx, tmp, t);\n     ret rslt(bcx, tmp);\n }\n \n@@ -4336,7 +4391,7 @@ fn trans_for(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n         cx.build.Br(scope_cx.llbb);\n         auto local_res = alloc_local(scope_cx, local);\n         auto bcx = copy_val(local_res.bcx, INIT, local_res.val, curr, t).bcx;\n-        scope_cx.cleanups += [clean(bind drop_slot(_, local_res.val, t))];\n+        add_clean(scope_cx, local_res.val, t);\n         bcx = trans_block(bcx, body, return).bcx;\n         if (!bcx.build.is_terminated()) {\n             bcx.build.Br(next_cx.llbb);\n@@ -4774,7 +4829,7 @@ fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n                 auto bcx = rslt.bcx;\n                 maybe_name_value(cx.fcx.lcx.ccx, dst, name);\n                 bcx.fcx.lllocals.insert(pat.id, dst);\n-                bcx.cleanups += [clean(bind drop_slot(_, dst, t))];\n+                add_clean(bcx, dst, t);\n                 ret copy_val(bcx, INIT, dst, llval, t);\n             }\n         }\n@@ -5143,9 +5198,8 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n         case (ast::expr_index(?base, ?idx)) {\n             ret trans_index(cx, e.span, base, idx, e.id);\n         }\n-        case (ast::expr_unary(?unop, ?base)) {\n+        case (ast::expr_unary(ast::deref, ?base)) {\n             auto ccx = cx.fcx.lcx.ccx;\n-            assert (unop == ast::deref);\n             auto sub = trans_expr(cx, base);\n             auto t = ty::expr_ty(ccx.tcx, base);\n             auto val = alt (ty::struct(ccx.tcx, t)) {\n@@ -5459,11 +5513,11 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n \n             // Translate the bound expressions.\n             let vec[ty::t] bound_tys = [];\n-            let vec[ValueRef] bound_vals = [];\n+            let vec[lval_result] bound_vals = [];\n             for (@ast::expr e in bound) {\n-                auto arg = trans_expr(bcx, e);\n-                bcx = arg.bcx;\n-                vec::push[ValueRef](bound_vals, arg.val);\n+                auto lv = trans_lval(bcx, e);\n+                bcx = lv.res.bcx;\n+                vec::push(bound_vals, lv);\n                 bound_tys += [ty::expr_ty(cx.fcx.lcx.ccx.tcx, e)];\n             }\n \n@@ -5556,10 +5610,11 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             auto bindings =\n                 bcx.build.GEP(closure,\n                               [C_int(0), C_int(abi::closure_elt_bindings)]);\n-            for (ValueRef v in bound_vals) {\n+            for (lval_result lv in bound_vals) {\n                 auto bound =\n                     bcx.build.GEP(bindings, [C_int(0), C_int(i as int)]);\n-                bcx = copy_val(bcx, INIT, bound, v, bound_tys.(i)).bcx;\n+                bcx = move_val_if_temp(bcx, INIT, bound, lv,\n+                                       bound_tys.(i)).bcx;\n                 i += 1u;\n             }\n \n@@ -5603,8 +5658,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             bcx.build.Store(bcx.build.PointerCast(box,\n                                                   T_opaque_closure_ptr(tn)),\n                             pair_box);\n-            find_scope_cx(cx).cleanups +=\n-                [clean(bind drop_slot(_, pair_v, pair_ty))];\n+            add_clean_temp(cx, pair_v, pair_ty);\n             ret rslt(bcx, pair_v);\n         }\n     }\n@@ -5635,7 +5689,6 @@ fn trans_arg_expr(&@block_ctxt cx, &ty::arg arg, TypeRef lldestty0,\n         } else {\n             // Non-mem but we're trying to alias; synthesize an\n             // alloca, spill to it and pass its address.\n-\n             val = do_spill(lv.res.bcx, lv.res.val);\n         }\n     } else { auto re = trans_expr(bcx, e); val = re.val; bcx = re.bcx; }\n@@ -5850,9 +5903,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n                     // Retval doesn't correspond to anything really tangible\n                     // in the frame, but it's a ref all the same, so we put a\n                     // note here to drop it when we're done in this scope.\n-                    \n-                    find_scope_cx(cx).cleanups +=\n-                        [clean(bind drop_ty(_, retval, ret_ty))];\n+                    add_clean_temp(cx, retval, ret_ty);\n                 }\n             }\n             case (some(_)) {\n@@ -5872,15 +5923,14 @@ fn trans_tup(&@block_ctxt cx, &vec[ast::elt] elts, ast::node_id id)\n     auto tup_res = alloc_ty(bcx, t);\n     auto tup_val = tup_res.val;\n     bcx = tup_res.bcx;\n-    find_scope_cx(cx).cleanups += [clean(bind drop_ty(_, tup_val, t))];\n+    add_clean_temp(cx, tup_val, t);\n     let int i = 0;\n     for (ast::elt e in elts) {\n         auto e_ty = ty::expr_ty(cx.fcx.lcx.ccx.tcx, e.expr);\n-        auto src_res = trans_expr(bcx, e.expr);\n-        bcx = src_res.bcx;\n+        auto src = trans_lval(bcx, e.expr);\n+        bcx = src.res.bcx;\n         auto dst_res = GEP_tup_like(bcx, t, tup_val, [0, i]);\n-        bcx = dst_res.bcx;\n-        bcx = copy_val(src_res.bcx, INIT, dst_res.val, src_res.val, e_ty).bcx;\n+        bcx = move_val_if_temp(dst_res.bcx, INIT, dst_res.val, src, e_ty).bcx;\n         i += 1;\n     }\n     ret rslt(bcx, tup_val);\n@@ -5907,15 +5957,15 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, ast::node_id id) ->\n                         C_null(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn)))]);\n     auto llty = type_of(bcx.fcx.lcx.ccx, bcx.sp, t);\n     vec_val = bcx.build.PointerCast(vec_val, llty);\n-    find_scope_cx(bcx).cleanups += [clean(bind drop_ty(_, vec_val, t))];\n+    add_clean_temp(bcx, vec_val, t);\n     auto body = bcx.build.GEP(vec_val, [C_int(0), C_int(abi::vec_elt_data)]);\n     auto pseudo_tup_ty =\n         ty::mk_imm_tup(cx.fcx.lcx.ccx.tcx,\n                        std::ivec::init_elt[ty::t](unit_ty, vec::len(args)));\n     let int i = 0;\n     for (@ast::expr e in args) {\n-        auto src_res = trans_expr(bcx, e);\n-        bcx = src_res.bcx;\n+        auto src = trans_lval(bcx, e);\n+        bcx = src.res.bcx;\n         auto dst_res = GEP_tup_like(bcx, pseudo_tup_ty, body, [0, i]);\n         bcx = dst_res.bcx;\n         // Cast the destination type to the source type. This is needed to\n@@ -5935,7 +5985,7 @@ fn trans_vec(&@block_ctxt cx, &vec[@ast::expr] args, ast::node_id id) ->\n             auto llunit_ty = type_of(cx.fcx.lcx.ccx, bcx.sp, unit_ty);\n             dst_val = bcx.build.PointerCast(dst_res.val, T_ptr(llunit_ty));\n         } else { dst_val = dst_res.val; }\n-        bcx = copy_val(bcx, INIT, dst_val, src_res.val, unit_ty).bcx;\n+        bcx = move_val_if_temp(bcx, INIT, dst_val, src, unit_ty).bcx;\n         i += 1;\n     }\n     auto fill = bcx.build.GEP(vec_val, [C_int(0), C_int(abi::vec_elt_fill)]);\n@@ -5961,7 +6011,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, ast::node_id id) ->\n     auto unit_sz = ares.llunitsz;\n     auto llalen = ares.llalen;\n \n-    find_scope_cx(bcx).cleanups += [clean(bind drop_ty(_, llvecptr, typ))];\n+    add_clean_temp(bcx, llvecptr, typ);\n \n     auto lllen = bcx.build.Mul(C_uint(vec::len(args)), unit_sz);\n     // Allocate the vector pieces and store length and allocated length.\n@@ -6021,9 +6071,8 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, ast::node_id id) ->\n \n     auto i = 0u;\n     for (@ast::expr e in args) {\n-        auto rslt = trans_expr(bcx, e);\n-        bcx = rslt.bcx;\n-        auto llsrc = rslt.val;\n+        auto lv = trans_lval(bcx, e);\n+        bcx = lv.res.bcx;\n         auto lleltptr;\n         if (ty::type_has_dynamic_size(bcx.fcx.lcx.ccx.tcx, unit_ty)) {\n             lleltptr =\n@@ -6032,7 +6081,7 @@ fn trans_ivec(@block_ctxt bcx, &vec[@ast::expr] args, ast::node_id id) ->\n         } else {\n             lleltptr = bcx.build.InBoundsGEP(llfirsteltptr, [C_uint(i)]);\n         }\n-        bcx = copy_val(bcx, INIT, lleltptr, llsrc, unit_ty).bcx;\n+        bcx = move_val_if_temp(bcx, INIT, lleltptr, lv, unit_ty).bcx;\n         i += 1u;\n     }\n     ret rslt(bcx, llvecptr);\n@@ -6045,7 +6094,7 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n     auto rec_res = alloc_ty(bcx, t);\n     auto rec_val = rec_res.val;\n     bcx = rec_res.bcx;\n-    find_scope_cx(cx).cleanups += [clean(bind drop_ty(_, rec_val, t))];\n+    add_clean_temp(cx, rec_val, t);\n     let int i = 0;\n     auto base_val = C_nil();\n     alt (base) {\n@@ -6065,20 +6114,22 @@ fn trans_rec(&@block_ctxt cx, &vec[ast::field] fields,\n         auto dst_res = GEP_tup_like(bcx, t, rec_val, [0, i]);\n         bcx = dst_res.bcx;\n         auto expr_provided = false;\n-        auto src_res = rslt(bcx, C_nil());\n         for (ast::field f in fields) {\n             if (str::eq(f.node.ident, tf.ident)) {\n                 expr_provided = true;\n-                src_res = trans_expr(bcx, f.node.expr);\n+                auto lv = trans_lval(bcx, f.node.expr);\n+                bcx = move_val_if_temp(lv.res.bcx, INIT, dst_res.val, lv,\n+                                       e_ty).bcx;\n+                break;\n             }\n         }\n         if (!expr_provided) {\n-            src_res = GEP_tup_like(bcx, t, base_val, [0, i]);\n+            auto src_res = GEP_tup_like(bcx, t, base_val, [0, i]);\n             src_res =\n                 rslt(src_res.bcx, load_if_immediate(bcx, src_res.val, e_ty));\n+            bcx = copy_val(src_res.bcx, INIT, dst_res.val, src_res.val,\n+                           e_ty).bcx;\n         }\n-        bcx = src_res.bcx;\n-        bcx = copy_val(bcx, INIT, dst_res.val, src_res.val, e_ty).bcx;\n         i += 1;\n     }\n     ret rslt(bcx, rec_val);\n@@ -6165,21 +6216,18 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n \n             auto move_res =\n                 move_val(rhs_res.res.bcx, DROP_EXISTING, lhs_res.res.val,\n-                         rhs_res.res.val, t);\n+                         rhs_res, t);\n             ret rslt(move_res.bcx, C_nil());\n         }\n         case (ast::expr_assign(?dst, ?src)) {\n             auto lhs_res = trans_lval(cx, dst);\n             assert (lhs_res.is_mem);\n             // FIXME Fill in lhs_res.res.bcx.sp\n-\n-            auto rhs_res = trans_expr(lhs_res.res.bcx, src);\n+            auto rhs = trans_lval(lhs_res.res.bcx, src);\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, src);\n             // FIXME: calculate copy init-ness in typestate.\n-\n-            auto copy_res =\n-                copy_val(rhs_res.bcx, DROP_EXISTING, lhs_res.res.val,\n-                         rhs_res.val, t);\n+            auto copy_res = move_val_if_temp\n+                (rhs.res.bcx, DROP_EXISTING, lhs_res.res.val, rhs, t);\n             ret rslt(copy_res.bcx, C_nil());\n         }\n         case (ast::expr_swap(?dst, ?src)) {\n@@ -6226,10 +6274,10 @@ fn trans_expr_out(&@block_ctxt cx, &@ast::expr e, out_method output) ->\n             auto v =\n                 trans_eager_binop(rhs_res.bcx, op, t, lhs_val, rhs_res.val);\n             // FIXME: calculate copy init-ness in typestate.\n-\n-            auto copy_res =\n-                copy_val(v.bcx, DROP_EXISTING, lhs_res.res.val, v.val, t);\n-            ret rslt(copy_res.bcx, C_nil());\n+            // This is always a temporary, so can always be safely moved\n+            auto move_res = move_val(v.bcx, DROP_EXISTING, lhs_res.res.val,\n+                                     lval_val(v.bcx, v.val), t);\n+            ret rslt(move_res.bcx, C_nil());\n         }\n         case (ast::expr_bind(?f, ?args)) {\n             ret trans_bind(cx, f, args, e.id);\n@@ -6329,11 +6377,12 @@ fn with_out_method(fn(&out_method) -> result  work, @block_ctxt cx,\n             ret drop_ty(cx, reg_val, t);\n         }\n         auto cleanup = bind drop_hoisted_ty(_, res_alloca.val, tp);\n-        find_scope_cx(cx).cleanups += [clean(cleanup)];\n+        find_scope_cx(cx).cleanups += [clean_temp(res_alloca.val, cleanup)];\n         auto done = work(save_in(res_alloca.val));\n-        done = rslt(done.bcx,\n-                    load_if_immediate(done.bcx, res_alloca.val, tp));\n-        ret done;\n+        auto loaded = load_if_immediate(done.bcx, res_alloca.val, tp);\n+        revoke_clean(cx, res_alloca.val);\n+        add_clean_temp(cx, loaded, tp);\n+        ret rslt(done.bcx, loaded);;\n     }\n }\n \n@@ -6595,19 +6644,16 @@ fn trans_cont(&span sp, &@block_ctxt cx) -> result {\n \n fn trans_ret(&@block_ctxt cx, &option::t[@ast::expr] e) -> result {\n     auto bcx = cx;\n-    auto val = C_nil();\n     alt (e) {\n         case (some(?x)) {\n             auto t = ty::expr_ty(cx.fcx.lcx.ccx.tcx, x);\n-            auto r = trans_expr(cx, x);\n-            bcx = r.bcx;\n-            val = r.val;\n-            bcx = copy_val(bcx, INIT, cx.fcx.llretptr, val, t).bcx;\n+            auto lv = trans_lval(cx, x);\n+            bcx = lv.res.bcx;\n+            bcx = move_val_if_temp(bcx, INIT, cx.fcx.llretptr, lv, t).bcx;\n         }\n         case (_) {\n             auto t = llvm::LLVMGetElementType(val_ty(cx.fcx.llretptr));\n-            auto null = lib::llvm::llvm::LLVMConstNull(t);\n-            bcx.build.Store(null, cx.fcx.llretptr);\n+            bcx.build.Store(C_null(t), cx.fcx.llretptr);\n         }\n     }\n     // run all cleanups and back out.\n@@ -6650,8 +6696,7 @@ fn trans_port(&@block_ctxt cx, ast::node_id id) -> result {\n                        [bcx.fcx.lltaskptr, unit_sz.val]);\n     auto llty = type_of(cx.fcx.lcx.ccx, cx.sp, t);\n     auto port_val = bcx.build.PointerCast(port_raw_val, llty);\n-    auto dropref = clean(bind drop_ty(_, port_val, t));\n-    find_scope_cx(bcx).cleanups += [dropref];\n+    add_clean_temp(bcx, port_val, t);\n     ret rslt(bcx, port_val);\n }\n \n@@ -6666,8 +6711,7 @@ fn trans_chan(&@block_ctxt cx, &@ast::expr e, ast::node_id id) -> result {\n     auto chan_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n     auto chan_llty = type_of(bcx.fcx.lcx.ccx, e.span, chan_ty);\n     auto chan_val = bcx.build.PointerCast(chan_raw_val, chan_llty);\n-    auto dropref = clean(bind drop_ty(_, chan_val, chan_ty));\n-    find_scope_cx(bcx).cleanups += [dropref];\n+    add_clean_temp(bcx, chan_val, chan_ty);\n     ret rslt(bcx, chan_val);\n }\n \n@@ -6761,8 +6805,7 @@ fn trans_spawn(&@block_ctxt cx, &ast::spawn_dom dom, &option::t[str] name,\n                    [bcx.fcx.lltaskptr, new_task, llfnptr_i, llargs_i,\n                     args_size]);\n     auto task_ty = node_id_type(bcx.fcx.lcx.ccx, id);\n-    auto dropref = clean(bind drop_ty(_, new_task, task_ty));\n-    find_scope_cx(bcx).cleanups += [dropref];\n+    add_clean_temp(bcx, new_task, task_ty);\n     ret rslt(bcx, new_task);\n }\n \n@@ -6868,8 +6911,8 @@ fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n     auto bcx = cx;\n     auto chn = trans_expr(bcx, lhs);\n     bcx = chn.bcx;\n-    auto data = trans_expr(bcx, rhs);\n-    bcx = data.bcx;\n+    auto data = trans_lval(bcx, rhs);\n+    bcx = data.res.bcx;\n     auto chan_ty = node_id_type(cx.fcx.lcx.ccx, id);\n     auto unit_ty;\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, chan_ty)) {\n@@ -6878,10 +6921,10 @@ fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n     }\n     auto data_alloc = alloc_ty(bcx, unit_ty);\n     bcx = data_alloc.bcx;\n-    auto data_tmp = copy_val(bcx, INIT, data_alloc.val, data.val, unit_ty);\n+    auto data_tmp = move_val_if_temp(bcx, INIT, data_alloc.val,\n+                                     data, unit_ty);\n     bcx = data_tmp.bcx;\n-    find_scope_cx(bcx).cleanups +=\n-        [clean(bind drop_ty(_, data_alloc.val, unit_ty))];\n+    add_clean_temp(bcx, data_alloc.val, unit_ty);\n     auto llchanval = bcx.build.PointerCast(chn.val, T_opaque_chan_ptr());\n     auto lldataptr = bcx.build.PointerCast(data_alloc.val, T_ptr(T_i8()));\n     bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.send,\n@@ -6914,7 +6957,6 @@ fn recv_val(&@block_ctxt cx, ValueRef to, &@ast::expr from, &ty::t unit_ty,\n     auto cp = copy_val(bcx, action, to, data_load, unit_ty);\n     bcx = cp.bcx;\n     // TODO: Any cleanup need to be done here?\n-\n     ret rslt(bcx, to);\n }\n \n@@ -7062,7 +7104,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n \n     // Take care of cleanups.\n     auto t = node_id_type(ccx, id);\n-    find_scope_cx(bcx).cleanups += [clean(bind drop_ty(_, pair, t))];\n+    add_clean_temp(bcx, pair, t);\n \n     // Grab onto the first and second elements of the pair.\n     // abi::obj_field_vtbl and abi::obj_field_box simply specify words 0 and 1\n@@ -7231,7 +7273,7 @@ fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n     auto llptr = cx.fcx.lllocals.get(local.node.id);\n     auto ty = node_id_type(cx.fcx.lcx.ccx, local.node.id);\n     auto bcx = cx;\n-    find_scope_cx(cx).cleanups += [clean(bind drop_slot(_, llptr, ty))];\n+    add_clean(cx, llptr, ty);\n     alt (local.node.init) {\n         case (some(?init)) {\n             alt (init.op) {\n@@ -7242,14 +7284,13 @@ fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n \n                     ty =\n                         node_id_type(cx.fcx.lcx.ccx, init.expr.id);\n-                    auto sub = trans_expr(bcx, init.expr);\n-                    bcx = copy_val(sub.bcx, INIT, llptr, sub.val, ty).bcx;\n+                    auto sub = trans_lval(bcx, init.expr);\n+                    bcx = move_val_if_temp(sub.res.bcx, INIT, llptr,\n+                                           sub, ty).bcx;\n                 }\n                 case (ast::init_move) {\n                     auto sub = trans_lval(bcx, init.expr);\n-                    bcx =\n-                        move_val(sub.res.bcx, INIT, llptr, sub.res.val,\n-                                 ty).bcx;\n+                    bcx = move_val(sub.res.bcx, INIT, llptr, sub, ty).bcx;\n                 }\n                 case (ast::init_recv) {\n                     bcx = recv_val(bcx, llptr, init.expr, ty, INIT).bcx;\n@@ -7269,8 +7310,7 @@ fn zero_alloca(&@block_ctxt cx, ValueRef llptr, ty::t t) -> result {\n         bcx = call_bzero(llalign.bcx, llptr, llsz.val, llalign.val).bcx;\n     } else {\n         auto llty = type_of(bcx.fcx.lcx.ccx, cx.sp, t);\n-        auto null = lib::llvm::llvm::LLVMConstNull(llty);\n-        bcx.build.Store(null, llptr);\n+        bcx.build.Store(C_null(llty), llptr);\n     }\n     ret rslt(bcx, llptr);\n }\n@@ -7374,7 +7414,10 @@ fn trans_block_cleanups(&@block_ctxt cx, &@block_ctxt cleanup_cx) ->\n     while (i > 0u) {\n         i -= 1u;\n         auto c = cleanup_cx.cleanups.(i);\n-        alt (c) { case (clean(?cfn)) { bcx = cfn(bcx).bcx; } }\n+        alt (c) {\n+            case (clean(?cfn)) { bcx = cfn(bcx).bcx; }\n+            case (clean_temp(_, ?cfn)) { bcx = cfn(bcx).bcx; }\n+        }\n     }\n     ret bcx;\n }\n@@ -7484,26 +7527,29 @@ fn trans_block(&@block_ctxt cx, &ast::block b, &out_method output) -> result {\n     }\n     alt (b.node.expr) {\n         case (some(?e)) {\n+            auto ccx = cx.fcx.lcx.ccx;\n+            auto r_ty = ty::expr_ty(ccx.tcx, e);\n             auto pass = output != return && accept_out_method(e);\n             if (pass) {\n                 r = trans_expr_out(bcx, e, output);\n-            } else { r = trans_expr(bcx, e); }\n-            bcx = r.bcx;\n-            auto ccx = cx.fcx.lcx.ccx;\n-            auto r_ty = ty::expr_ty(ccx.tcx, e);\n-            if (is_terminated(bcx) || ty::type_is_bot(ccx.tcx, r_ty)) {\n-                ret r;\n-            } else if (!pass) {\n+                bcx = r.bcx;\n+                if (is_terminated(bcx) || ty::type_is_bot(ccx.tcx, r_ty)) {\n+                    ret r;\n+                }\n+            } else {\n+                auto lv = trans_lval(bcx, e);\n+                r = lv.res;\n+                bcx = r.bcx;\n+                if (is_terminated(bcx) || ty::type_is_bot(ccx.tcx, r_ty)) {\n+                    ret r;\n+                }\n                 alt (output) {\n                     case (save_in(?target)) {\n                         // The output method is to save the value at target,\n                         // and we didn't pass it to the recursive trans_expr\n                         // call.\n-                        // FIXME Use move semantics!\n-\n-                        auto res_copy =\n-                            copy_val(bcx, INIT, target, r.val, r_ty);\n-                        bcx = res_copy.bcx;\n+                        bcx = move_val_if_temp(bcx, INIT, target,\n+                                               lv, r_ty).bcx;\n                         r = rslt(bcx, C_nil());\n                     }\n                     case (return) { }\n@@ -7692,8 +7738,7 @@ fn add_cleanups_for_args(&@block_ctxt bcx, vec[ast::arg] args,\n                 case (_) { bcx.fcx.lcx.ccx.sess.span_fatal(aarg.ty.span,\n                       \"unbound arg ID in copy_args_to_allocas\"); }\n             }\n-            find_scope_cx(bcx).cleanups +=\n-                [clean(bind drop_slot(_, argval, arg_tys.(arg_n).ty))];\n+            add_clean(bcx, argval, arg_tys.(arg_n).ty);\n         }\n         arg_n += 1u;\n     }"}, {"sha": "c2490fa37a38bd48c7ba9f3b73aa5fb2fd4cf394", "filename": "src/lib/fs.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Flib%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Flib%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ffs.rs?ref=3bdbf74d4703771571fdee1733b7b3d919b5ede8", "patch": "@@ -36,7 +36,6 @@ fn basename(path p) -> path {\n fn connect(path pre, path post) -> path {\n     auto len = str::byte_len(pre);\n     ret if (pre.(len - 1u) == os_fs::path_sep as u8) {\n-\n             // Trailing '/'?\n             pre + post\n         } else { pre + path_sep() + post };"}, {"sha": "4093872ee6941a8d28e8d62fb25dc76ebec0a97a", "filename": "src/lib/str.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Flib%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Flib%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstr.rs?ref=3bdbf74d4703771571fdee1733b7b3d919b5ede8", "patch": "@@ -313,10 +313,7 @@ fn refcount(str s) -> uint {\n     if (r == dbg::const_refcount) {\n         ret r;\n     } else {\n-        // -2 because calling this function and the native function both\n-        // incremented the refcount.\n-\n-        ret r - 2u;\n+        ret r - 1u;\n     }\n }\n "}, {"sha": "35e765fe144b1ac4216974ce8b22ce6c66bf8637", "filename": "src/lib/vec.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=3bdbf74d4703771571fdee1733b7b3d919b5ede8", "patch": "@@ -46,10 +46,7 @@ fn refcount[T](array[T] v) -> uint {\n     if (r == dbg::const_refcount) {\n         ret r;\n     } else {\n-        // -2 because calling this function and the native function both\n-        // incremented the refcount.\n-\n-        ret r - 2u;\n+        ret r - 1u;\n     }\n }\n "}, {"sha": "eb57402168f5e1d4824fd669a45a431d3b7d5a7e", "filename": "src/test/run-pass/lib-fs.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Ftest%2Frun-pass%2Flib-fs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3bdbf74d4703771571fdee1733b7b3d919b5ede8/src%2Ftest%2Frun-pass%2Flib-fs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flib-fs.rs?ref=3bdbf74d4703771571fdee1733b7b3d919b5ede8", "patch": "@@ -4,6 +4,7 @@ import std::fs;\n \n fn test_connect() {\n     auto slash = fs::path_sep();\n+    log_err fs::connect(\"a\", \"b\");\n     assert (fs::connect(\"a\", \"b\") == \"a\" + slash + \"b\");\n     assert (fs::connect(\"a\" + slash, \"b\") == \"a\" + slash + \"b\");\n }"}]}