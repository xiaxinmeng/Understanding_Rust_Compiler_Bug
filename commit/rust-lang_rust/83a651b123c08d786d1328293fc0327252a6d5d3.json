{"sha": "83a651b123c08d786d1328293fc0327252a6d5d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzYTY1MWIxMjNjMDhkNzg2ZDEzMjgyOTNmYzAzMjcyNTJhNmQ1ZDM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-07T11:52:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-07T11:52:05Z"}, "message": "Merge #6154\n\n6154: Shorten type hints for std::iter Iterators r=SomeoneToIgnore a=Veykril\n\nFixes #3750.\r\n\r\nThis re-exports the `hir_expand::name::known` module to be able to fetch the `Iterator` and `iter` names.\r\nI'm not sure if there is anything to do with `Solution::Ambig` in `normalize_trait_assoc_type` or whether discarding those results is always wanted.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "916f7c1ff5f24d3d27cb14e82044696751414843", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/916f7c1ff5f24d3d27cb14e82044696751414843"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/83a651b123c08d786d1328293fc0327252a6d5d3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJffavlCRBK7hj4Ov3rIwAAdHIIADOf+z55fK8tN/K68nVdFj6R\nL8WNJD5b7PO+QxwSdZ/+gI3vd5i2JF5NOFkKIO/L+bvRJsBv+smzBXLKj1H4t7Xc\nI8bbAJeDPrAYVqiS/sLkJXIjePyhTX0gz2MDa5+/9pDNNbsewN03FCVYaddCRXyA\nPCkd3tjuYROtiUTUcZe1cxuMAZqMtRr1xYEgWBsMWjqqwbHp66qCj9n3e8INxTcU\nJmTIh03uAfXGmx8bSbI1qaFg4ZKJ4Ff6mpDS2WGFkda+osodTwaP3RcXUjfE9aw5\n0tIWCc5xsSxA70yHQrPohEah1nanP0ettHlzGtbnKIXg1F2eeVlAC4xGcKR4lCc=\n=o+ED\n-----END PGP SIGNATURE-----\n", "payload": "tree 916f7c1ff5f24d3d27cb14e82044696751414843\nparent 5359e8f7429a7b6db7b1ab1ced5b19ff05d79123\nparent 783af171f74d95b498662e5168c3ba320cca8553\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1602071525 +0000\ncommitter GitHub <noreply@github.com> 1602071525 +0000\n\nMerge #6154\n\n6154: Shorten type hints for std::iter Iterators r=SomeoneToIgnore a=Veykril\n\nFixes #3750.\r\n\r\nThis re-exports the `hir_expand::name::known` module to be able to fetch the `Iterator` and `iter` names.\r\nI'm not sure if there is anything to do with `Solution::Ambig` in `normalize_trait_assoc_type` or whether discarding those results is always wanted.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/83a651b123c08d786d1328293fc0327252a6d5d3", "html_url": "https://github.com/rust-lang/rust/commit/83a651b123c08d786d1328293fc0327252a6d5d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/83a651b123c08d786d1328293fc0327252a6d5d3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5359e8f7429a7b6db7b1ab1ced5b19ff05d79123", "url": "https://api.github.com/repos/rust-lang/rust/commits/5359e8f7429a7b6db7b1ab1ced5b19ff05d79123", "html_url": "https://github.com/rust-lang/rust/commit/5359e8f7429a7b6db7b1ab1ced5b19ff05d79123"}, {"sha": "783af171f74d95b498662e5168c3ba320cca8553", "url": "https://api.github.com/repos/rust-lang/rust/commits/783af171f74d95b498662e5168c3ba320cca8553", "html_url": "https://github.com/rust-lang/rust/commit/783af171f74d95b498662e5168c3ba320cca8553"}], "stats": {"total": 351, "additions": 295, "deletions": 56}, "files": [{"sha": "c1847f601d5cb1f53ab9224acb28500950a3e120", "filename": "crates/assists/src/utils.rs", "status": "modified", "additions": 96, "deletions": 14, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/83a651b123c08d786d1328293fc0327252a6d5d3/crates%2Fassists%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a651b123c08d786d1328293fc0327252a6d5d3/crates%2Fassists%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Futils.rs?ref=83a651b123c08d786d1328293fc0327252a6d5d3", "patch": "@@ -3,7 +3,7 @@ pub(crate) mod insert_use;\n \n use std::{iter, ops};\n \n-use hir::{Adt, Crate, Enum, ScopeDef, Semantics, Trait, Type};\n+use hir::{Adt, Crate, Enum, Module, ScopeDef, Semantics, Trait, Type};\n use ide_db::RootDatabase;\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n@@ -274,15 +274,79 @@ impl TryEnum {\n /// somewhat similar to the known paths infra inside hir, but it different; We\n /// want to make sure that IDE specific paths don't become interesting inside\n /// the compiler itself as well.\n-pub(crate) struct FamousDefs<'a, 'b>(pub(crate) &'a Semantics<'b, RootDatabase>, pub(crate) Crate);\n+pub struct FamousDefs<'a, 'b>(pub &'a Semantics<'b, RootDatabase>, pub Crate);\n \n #[allow(non_snake_case)]\n impl FamousDefs<'_, '_> {\n-    #[cfg(test)]\n-    pub(crate) const FIXTURE: &'static str = r#\"//- /libcore.rs crate:core\n+    pub const FIXTURE: &'static str = r#\"//- /libcore.rs crate:core\n pub mod convert {\n     pub trait From<T> {\n-        fn from(T) -> Self;\n+        fn from(t: T) -> Self;\n+    }\n+}\n+\n+pub mod iter {\n+    pub use self::traits::{collect::IntoIterator, iterator::Iterator};\n+    mod traits {\n+        pub(crate) mod iterator {\n+            use crate::option::Option;\n+            pub trait Iterator {\n+                type Item;\n+                fn next(&mut self) -> Option<Self::Item>;\n+                fn by_ref(&mut self) -> &mut Self {\n+                    self\n+                }\n+                fn take(self, n: usize) -> crate::iter::Take<Self> {\n+                    crate::iter::Take { inner: self }\n+                }\n+            }\n+\n+            impl<I: Iterator> Iterator for &mut I {\n+                type Item = I::Item;\n+                fn next(&mut self) -> Option<I::Item> {\n+                    (**self).next()\n+                }\n+            }\n+        }\n+        pub(crate) mod collect {\n+            pub trait IntoIterator {\n+                type Item;\n+            }\n+        }\n+    }\n+\n+    pub use self::sources::*;\n+    pub(crate) mod sources {\n+        use super::Iterator;\n+        use crate::option::Option::{self, *};\n+        pub struct Repeat<A> {\n+            element: A,\n+        }\n+\n+        pub fn repeat<T>(elt: T) -> Repeat<T> {\n+            Repeat { element: elt }\n+        }\n+\n+        impl<A> Iterator for Repeat<A> {\n+            type Item = A;\n+\n+            fn next(&mut self) -> Option<A> {\n+                None\n+            }\n+        }\n+    }\n+\n+    pub use self::adapters::*;\n+    pub(crate) mod adapters {\n+        use super::Iterator;\n+        use crate::option::Option::{self, *};\n+        pub struct Take<I> { pub(crate) inner: I }\n+        impl<I> Iterator for Take<I> where I: Iterator {\n+            type Item = <I as Iterator>::Item;\n+            fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+                None\n+            }\n+        }\n     }\n }\n \n@@ -291,7 +355,7 @@ pub mod option {\n }\n \n pub mod prelude {\n-    pub use crate::{convert::From, option::Option::{self, *}};\n+    pub use crate::{convert::From, iter::{IntoIterator, Iterator}, option::Option::{self, *}};\n }\n #[prelude_import]\n pub use prelude::*;\n@@ -305,6 +369,14 @@ pub use prelude::*;\n         self.find_enum(\"core:option:Option\")\n     }\n \n+    pub fn core_iter_Iterator(&self) -> Option<Trait> {\n+        self.find_trait(\"core:iter:traits:iterator:Iterator\")\n+    }\n+\n+    pub fn core_iter(&self) -> Option<Module> {\n+        self.find_module(\"core:iter\")\n+    }\n+\n     fn find_trait(&self, path: &str) -> Option<Trait> {\n         match self.find_def(path)? {\n             hir::ScopeDef::ModuleDef(hir::ModuleDef::Trait(it)) => Some(it),\n@@ -319,31 +391,41 @@ pub use prelude::*;\n         }\n     }\n \n+    fn find_module(&self, path: &str) -> Option<Module> {\n+        match self.find_def(path)? {\n+            hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(it)) => Some(it),\n+            _ => None,\n+        }\n+    }\n+\n     fn find_def(&self, path: &str) -> Option<ScopeDef> {\n         let db = self.0.db;\n         let mut path = path.split(':');\n         let trait_ = path.next_back()?;\n         let std_crate = path.next()?;\n-        let std_crate = self\n+        let std_crate = if self\n             .1\n-            .dependencies(db)\n-            .into_iter()\n-            .find(|dep| &dep.name.to_string() == std_crate)?\n-            .krate;\n-\n+            .declaration_name(db)\n+            .map(|name| name.to_string() == std_crate)\n+            .unwrap_or(false)\n+        {\n+            self.1\n+        } else {\n+            self.1.dependencies(db).into_iter().find(|dep| dep.name.to_string() == std_crate)?.krate\n+        };\n         let mut module = std_crate.root_module(db);\n         for segment in path {\n             module = module.children(db).find_map(|child| {\n                 let name = child.name(db)?;\n-                if &name.to_string() == segment {\n+                if name.to_string() == segment {\n                     Some(child)\n                 } else {\n                     None\n                 }\n             })?;\n         }\n         let def =\n-            module.scope(db, None).into_iter().find(|(name, _def)| &name.to_string() == trait_)?.1;\n+            module.scope(db, None).into_iter().find(|(name, _def)| name.to_string() == trait_)?.1;\n         Some(def)\n     }\n }"}, {"sha": "031c91ccf612dd18f7fe52ae641796d6a02e6e8d", "filename": "crates/hir/src/code_model.rs", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/83a651b123c08d786d1328293fc0327252a6d5d3/crates%2Fhir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a651b123c08d786d1328293fc0327252a6d5d3/crates%2Fhir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fcode_model.rs?ref=83a651b123c08d786d1328293fc0327252a6d5d3", "patch": "@@ -30,8 +30,12 @@ use hir_expand::{\n use hir_ty::{\n     autoderef,\n     display::{HirDisplayError, HirFormatter},\n-    method_resolution, ApplicationTy, CallableDefId, Canonical, FnSig, GenericPredicate,\n-    InEnvironment, Substs, TraitEnvironment, Ty, TyDefId, TypeCtor,\n+    method_resolution,\n+    traits::Solution,\n+    traits::SolutionVariables,\n+    ApplicationTy, BoundVar, CallableDefId, Canonical, DebruijnIndex, FnSig, GenericPredicate,\n+    InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Substs, TraitEnvironment, Ty,\n+    TyDefId, TyKind, TypeCtor,\n };\n use rustc_hash::FxHashSet;\n use stdx::impl_from;\n@@ -1362,6 +1366,35 @@ impl Type {\n         db.trait_solve(self.krate, goal).is_some()\n     }\n \n+    pub fn normalize_trait_assoc_type(\n+        &self,\n+        db: &dyn HirDatabase,\n+        r#trait: Trait,\n+        args: &[Type],\n+        alias: TypeAlias,\n+    ) -> Option<Ty> {\n+        let subst = Substs::build_for_def(db, r#trait.id)\n+            .push(self.ty.value.clone())\n+            .fill(args.iter().map(|t| t.ty.value.clone()))\n+            .build();\n+        let predicate = ProjectionPredicate {\n+            projection_ty: ProjectionTy { associated_ty: alias.id, parameters: subst },\n+            ty: Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0)),\n+        };\n+        let goal = Canonical {\n+            value: InEnvironment::new(\n+                self.ty.environment.clone(),\n+                Obligation::Projection(predicate),\n+            ),\n+            kinds: Arc::new([TyKind::General]),\n+        };\n+\n+        match db.trait_solve(self.krate, goal)? {\n+            Solution::Unique(SolutionVariables(subst)) => subst.value.first().cloned(),\n+            Solution::Ambig(_) => None,\n+        }\n+    }\n+\n     pub fn is_copy(&self, db: &dyn HirDatabase) -> bool {\n         let lang_item = db.lang_item(self.krate, SmolStr::new(\"copy\"));\n         let copy_trait = match lang_item {"}, {"sha": "4094a76cbdba1076898cd4c76f5b1f04ebcfa613", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/83a651b123c08d786d1328293fc0327252a6d5d3/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a651b123c08d786d1328293fc0327252a6d5d3/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=83a651b123c08d786d1328293fc0327252a6d5d3", "patch": "@@ -55,7 +55,7 @@ pub use hir_def::{\n     type_ref::{Mutability, TypeRef},\n };\n pub use hir_expand::{\n-    name::AsName, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc,\n+    name::known, name::AsName, name::Name, HirFileId, InFile, MacroCallId, MacroCallLoc,\n     /* FIXME */ MacroDefId, MacroFile, Origin,\n };\n pub use hir_ty::display::HirDisplay;"}, {"sha": "63f8287079db26dfb1b035b251c000cdc98a1345", "filename": "crates/hir_expand/src/name.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/83a651b123c08d786d1328293fc0327252a6d5d3/crates%2Fhir_expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a651b123c08d786d1328293fc0327252a6d5d3/crates%2Fhir_expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fname.rs?ref=83a651b123c08d786d1328293fc0327252a6d5d3", "patch": "@@ -164,6 +164,7 @@ pub mod known {\n         result,\n         boxed,\n         // Components of known path (type name)\n+        Iterator,\n         IntoIterator,\n         Item,\n         Try,"}, {"sha": "7d716577e2b9b9807b0d87d9e1e859155e6aa871", "filename": "crates/ide/src/inlay_hints.rs", "status": "modified", "additions": 162, "deletions": 39, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/83a651b123c08d786d1328293fc0327252a6d5d3/crates%2Fide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/83a651b123c08d786d1328293fc0327252a6d5d3/crates%2Fide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints.rs?ref=83a651b123c08d786d1328293fc0327252a6d5d3", "patch": "@@ -1,4 +1,5 @@\n-use hir::{Adt, Callable, HirDisplay, Semantics, Type};\n+use assists::utils::FamousDefs;\n+use hir::{known, HirDisplay, Semantics};\n use ide_db::RootDatabase;\n use stdx::to_lower_snake_case;\n use syntax::{\n@@ -119,17 +120,18 @@ fn get_chaining_hints(\n             return None;\n         }\n         if matches!(expr, ast::Expr::PathExpr(_)) {\n-            if let Some(Adt::Struct(st)) = ty.as_adt() {\n+            if let Some(hir::Adt::Struct(st)) = ty.as_adt() {\n                 if st.fields(sema.db).is_empty() {\n                     return None;\n                 }\n             }\n         }\n-        let label = ty.display_truncated(sema.db, config.max_length).to_string();\n         acc.push(InlayHint {\n             range: expr.syntax().text_range(),\n             kind: InlayKind::ChainingHint,\n-            label: label.into(),\n+            label: hint_iterator(sema, config, &ty).unwrap_or_else(|| {\n+                ty.display_truncated(sema.db, config.max_length).to_string().into()\n+            }),\n         });\n     }\n     Some(())\n@@ -192,17 +194,58 @@ fn get_bind_pat_hints(\n     if should_not_display_type_hint(sema, &pat, &ty) {\n         return None;\n     }\n-\n     acc.push(InlayHint {\n         range: pat.syntax().text_range(),\n         kind: InlayKind::TypeHint,\n-        label: ty.display_truncated(sema.db, config.max_length).to_string().into(),\n+        label: hint_iterator(sema, config, &ty)\n+            .unwrap_or_else(|| ty.display_truncated(sema.db, config.max_length).to_string().into()),\n     });\n+\n     Some(())\n }\n \n-fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &Type) -> bool {\n-    if let Some(Adt::Enum(enum_data)) = pat_ty.as_adt() {\n+/// Checks if the type is an Iterator from std::iter and replaces its hint with an `impl Iterator<Item = Ty>`.\n+fn hint_iterator(\n+    sema: &Semantics<RootDatabase>,\n+    config: &InlayHintsConfig,\n+    ty: &hir::Type,\n+) -> Option<SmolStr> {\n+    let db = sema.db;\n+    let strukt = std::iter::successors(Some(ty.clone()), |ty| ty.remove_ref())\n+        .last()\n+        .and_then(|strukt| strukt.as_adt())?;\n+    let krate = strukt.krate(db)?;\n+    if krate.declaration_name(db).as_deref() != Some(\"core\") {\n+        return None;\n+    }\n+    let iter_trait = FamousDefs(sema, krate).core_iter_Iterator()?;\n+    let iter_mod = FamousDefs(sema, krate).core_iter()?;\n+    // assert this type comes from `core::iter`\n+    iter_mod.visibility_of(db, &iter_trait.into()).filter(|&vis| vis == hir::Visibility::Public)?;\n+    if ty.impls_trait(db, iter_trait, &[]) {\n+        let assoc_type_item = iter_trait.items(db).into_iter().find_map(|item| match item {\n+            hir::AssocItem::TypeAlias(alias) if alias.name(db) == known::Item => Some(alias),\n+            _ => None,\n+        })?;\n+        if let Some(ty) = ty.normalize_trait_assoc_type(db, iter_trait, &[], assoc_type_item) {\n+            const LABEL_START: &str = \"impl Iterator<Item = \";\n+            const LABEL_END: &str = \">\";\n+\n+            let ty_display = ty.display_truncated(\n+                db,\n+                config\n+                    .max_length\n+                    .map(|len| len.saturating_sub(LABEL_START.len() + LABEL_END.len())),\n+            );\n+            return Some(format!(\"{}{}{}\", LABEL_START, ty_display, LABEL_END).into());\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &hir::Type) -> bool {\n+    if let Some(hir::Adt::Enum(enum_data)) = pat_ty.as_adt() {\n         let pat_text = bind_pat.to_string();\n         enum_data\n             .variants(db)\n@@ -217,15 +260,15 @@ fn pat_is_enum_variant(db: &RootDatabase, bind_pat: &ast::IdentPat, pat_ty: &Typ\n fn should_not_display_type_hint(\n     sema: &Semantics<RootDatabase>,\n     bind_pat: &ast::IdentPat,\n-    pat_ty: &Type,\n+    pat_ty: &hir::Type,\n ) -> bool {\n     let db = sema.db;\n \n     if pat_ty.is_unknown() {\n         return true;\n     }\n \n-    if let Some(Adt::Struct(s)) = pat_ty.as_adt() {\n+    if let Some(hir::Adt::Struct(s)) = pat_ty.as_adt() {\n         if s.fields(db).is_empty() && s.name(db).to_string() == bind_pat.to_string() {\n             return true;\n         }\n@@ -269,7 +312,7 @@ fn should_not_display_type_hint(\n \n fn should_show_param_name_hint(\n     sema: &Semantics<RootDatabase>,\n-    callable: &Callable,\n+    callable: &hir::Callable,\n     param_name: &str,\n     argument: &ast::Expr,\n ) -> bool {\n@@ -316,7 +359,7 @@ fn is_enum_name_similar_to_param_name(\n     param_name: &str,\n ) -> bool {\n     match sema.type_of_expr(argument).and_then(|t| t.as_adt()) {\n-        Some(Adt::Enum(e)) => to_lower_snake_case(&e.name(sema.db).to_string()) == param_name,\n+        Some(hir::Adt::Enum(e)) => to_lower_snake_case(&e.name(sema.db).to_string()) == param_name,\n         _ => false,\n     }\n }\n@@ -337,7 +380,7 @@ fn is_obvious_param(param_name: &str) -> bool {\n     param_name.len() == 1 || is_obvious_param_name\n }\n \n-fn get_callable(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<Callable> {\n+fn get_callable(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<hir::Callable> {\n     match expr {\n         ast::Expr::CallExpr(expr) => sema.type_of_expr(&expr.expr()?)?.as_callable(sema.db),\n         ast::Expr::MethodCallExpr(expr) => sema.resolve_method_call_as_callable(expr),\n@@ -347,6 +390,7 @@ fn get_callable(sema: &Semantics<RootDatabase>, expr: &ast::Expr) -> Option<Call\n \n #[cfg(test)]\n mod tests {\n+    use assists::utils::FamousDefs;\n     use expect_test::{expect, Expect};\n     use test_utils::extract_annotations;\n \n@@ -357,7 +401,9 @@ mod tests {\n     }\n \n     fn check_with_config(config: InlayHintsConfig, ra_fixture: &str) {\n-        let (analysis, file_id) = fixture::file(ra_fixture);\n+        let ra_fixture =\n+            format!(\"//- /main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n+        let (analysis, file_id) = fixture::file(&ra_fixture);\n         let expected = extract_annotations(&*analysis.file_text(file_id).unwrap());\n         let inlay_hints = analysis.inlay_hints(file_id, &config).unwrap();\n         let actual =\n@@ -366,7 +412,9 @@ mod tests {\n     }\n \n     fn check_expect(config: InlayHintsConfig, ra_fixture: &str, expect: Expect) {\n-        let (analysis, file_id) = fixture::file(ra_fixture);\n+        let ra_fixture =\n+            format!(\"//- /main.rs crate:main deps:core\\n{}\\n{}\", ra_fixture, FamousDefs::FIXTURE);\n+        let (analysis, file_id) = fixture::file(&ra_fixture);\n         let inlay_hints = analysis.inlay_hints(file_id, &config).unwrap();\n         expect.assert_debug_eq(&inlay_hints)\n     }\n@@ -798,12 +846,12 @@ fn main() {\n             expect![[r#\"\n                 [\n                     InlayHint {\n-                        range: 147..172,\n+                        range: 148..173,\n                         kind: ChainingHint,\n                         label: \"B\",\n                     },\n                     InlayHint {\n-                        range: 147..154,\n+                        range: 148..155,\n                         kind: ChainingHint,\n                         label: \"A\",\n                     },\n@@ -864,12 +912,12 @@ fn main() {\n             expect![[r#\"\n                 [\n                     InlayHint {\n-                        range: 143..190,\n+                        range: 144..191,\n                         kind: ChainingHint,\n                         label: \"C\",\n                     },\n                     InlayHint {\n-                        range: 143..179,\n+                        range: 144..180,\n                         kind: ChainingHint,\n                         label: \"B\",\n                     },\n@@ -909,12 +957,12 @@ fn main() {\n             expect![[r#\"\n                 [\n                     InlayHint {\n-                        range: 246..283,\n+                        range: 247..284,\n                         kind: ChainingHint,\n                         label: \"B<X<i32, bool>>\",\n                     },\n                     InlayHint {\n-                        range: 246..265,\n+                        range: 247..266,\n                         kind: ChainingHint,\n                         label: \"A<X<i32, bool>>\",\n                     },\n@@ -935,7 +983,6 @@ fn main() {\n         );\n         check(\n             r#\"\n-//- /main.rs crate:main deps:core\n pub struct Vec<T> {}\n \n impl<T> Vec<T> {\n@@ -956,13 +1003,6 @@ fn main() {\n     println!(\"Unit expr\");\n }\n \n-//- /core.rs crate:core\n-#[prelude_import] use iter::*;\n-mod iter {\n-    trait IntoIterator {\n-        type Item;\n-    }\n-}\n //- /alloc.rs crate:alloc deps:core\n mod collections {\n     struct Vec<T> {}\n@@ -982,7 +1022,6 @@ mod collections {\n     fn complete_for_hint() {\n         check(\n             r#\"\n-//- /main.rs crate:main deps:core\n pub struct Vec<T> {}\n \n impl<T> Vec<T> {\n@@ -1004,14 +1043,6 @@ fn main() {\n         //^ &str\n     }\n }\n-\n-//- /core.rs crate:core\n-#[prelude_import] use iter::*;\n-mod iter {\n-    trait IntoIterator {\n-        type Item;\n-    }\n-}\n //- /alloc.rs crate:alloc deps:core\n mod collections {\n     struct Vec<T> {}\n@@ -1037,7 +1068,6 @@ mod collections {\n                 max_length: None,\n             },\n             r#\"\n-//- /main.rs crate:main\n pub struct Vec<T> {}\n \n impl<T> Vec<T> {\n@@ -1060,4 +1090,97 @@ fn main() {\n \"#,\n         );\n     }\n+\n+    #[test]\n+    fn shorten_iterator_hints() {\n+        check_with_config(\n+            InlayHintsConfig {\n+                parameter_hints: false,\n+                type_hints: true,\n+                chaining_hints: false,\n+                max_length: None,\n+            },\n+            r#\"\n+use core::iter;\n+\n+struct MyIter;\n+\n+impl Iterator for MyIter {\n+    type Item = ();\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    let _x = MyIter;\n+      //^^ MyIter\n+    let _x = iter::repeat(0);\n+      //^^ impl Iterator<Item = i32>\n+    fn generic<T: Clone>(t: T) {\n+        let _x = iter::repeat(t);\n+          //^^ impl Iterator<Item = T>\n+        let _chained = iter::repeat(t).take(10);\n+          //^^^^^^^^ impl Iterator<Item = T>\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn shorten_iterator_chaining_hints() {\n+        check_expect(\n+            InlayHintsConfig {\n+                parameter_hints: false,\n+                type_hints: false,\n+                chaining_hints: true,\n+                max_length: None,\n+            },\n+            r#\"\n+use core::iter;\n+\n+struct MyIter;\n+\n+impl Iterator for MyIter {\n+    type Item = ();\n+    fn next(&mut self) -> Option<Self::Item> {\n+        None\n+    }\n+}\n+\n+fn main() {\n+    let _x = MyIter.by_ref()\n+        .take(5)\n+        .by_ref()\n+        .take(5)\n+        .by_ref();\n+}\n+\"#,\n+            expect![[r#\"\n+                [\n+                    InlayHint {\n+                        range: 175..242,\n+                        kind: ChainingHint,\n+                        label: \"impl Iterator<Item = ()>\",\n+                    },\n+                    InlayHint {\n+                        range: 175..225,\n+                        kind: ChainingHint,\n+                        label: \"impl Iterator<Item = ()>\",\n+                    },\n+                    InlayHint {\n+                        range: 175..207,\n+                        kind: ChainingHint,\n+                        label: \"impl Iterator<Item = ()>\",\n+                    },\n+                    InlayHint {\n+                        range: 175..190,\n+                        kind: ChainingHint,\n+                        label: \"&mut MyIter\",\n+                    },\n+                ]\n+            \"#]],\n+        );\n+    }\n }"}]}