{"sha": "0a029e2ed09b8f5dedf7265038ebdf363acb661b", "node_id": "C_kwDOAAsO6NoAKDBhMDI5ZTJlZDA5YjhmNWRlZGY3MjY1MDM4ZWJkZjM2M2FjYjY2MWI", "commit": {"author": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-04T20:19:34Z"}, "committer": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-13T15:46:05Z"}, "message": "remove CollectPrivateImplItemsVisitor\n\nSigned-off-by: Miguel Guarniz <mi9uel9@gmail.com>", "tree": {"sha": "e7f1b9f43c565db1066d80ecc008d4cbb0e72040", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e7f1b9f43c565db1066d80ecc008d4cbb0e72040"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a029e2ed09b8f5dedf7265038ebdf363acb661b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a029e2ed09b8f5dedf7265038ebdf363acb661b", "html_url": "https://github.com/rust-lang/rust/commit/0a029e2ed09b8f5dedf7265038ebdf363acb661b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a029e2ed09b8f5dedf7265038ebdf363acb661b/comments", "author": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45c37da0f757283d6d50a03a6915eec787179aa4", "url": "https://api.github.com/repos/rust-lang/rust/commits/45c37da0f757283d6d50a03a6915eec787179aa4", "html_url": "https://github.com/rust-lang/rust/commit/45c37da0f757283d6d50a03a6915eec787179aa4"}], "stats": {"total": 127, "additions": 57, "deletions": 70}, "files": [{"sha": "88ca48eae3e78d0e18e1c8bb531d236b890c0c76", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 57, "deletions": 70, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/0a029e2ed09b8f5dedf7265038ebdf363acb661b/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a029e2ed09b8f5dedf7265038ebdf363acb661b/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=0a029e2ed09b8f5dedf7265038ebdf363acb661b", "patch": "@@ -10,7 +10,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::Node;\n use rustc_middle::middle::codegen_fn_attrs::{CodegenFnAttrFlags, CodegenFnAttrs};\n use rustc_middle::middle::privacy;\n@@ -314,79 +313,56 @@ impl<'tcx> ReachableContext<'tcx> {\n     }\n }\n \n-// Some methods from non-exported (completely private) trait impls still have to be\n-// reachable if they are called from inlinable code. Generally, it's not known until\n-// monomorphization if a specific trait impl item can be reachable or not. So, we\n-// conservatively mark all of them as reachable.\n-// FIXME: One possible strategy for pruning the reachable set is to avoid marking impl\n-// items of non-exported traits (or maybe all local traits?) unless their respective\n-// trait items are used from inlinable code through method call syntax or UFCS, or their\n-// trait is a lang item.\n-struct CollectPrivateImplItemsVisitor<'a, 'tcx> {\n+fn check_item<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    access_levels: &'a privacy::AccessLevels,\n-    worklist: &'a mut Vec<LocalDefId>,\n-}\n+    item: &hir::Item<'_>,\n+    worklist: &mut Vec<LocalDefId>,\n+    access_levels: &privacy::AccessLevels\n+) {\n+    push_to_worklist_if_has_custom_linkage(tcx, worklist, item.def_id);\n+\n+    // We need only trait impls here, not inherent impls, and only non-exported ones\n+    if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n+    item.kind\n+    {\n+        if !access_levels.is_reachable(item.def_id) {\n+            // FIXME(#53488) remove `let`\n+            let tcx = tcx;\n+            worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id));\n \n-impl CollectPrivateImplItemsVisitor<'_, '_> {\n-    fn push_to_worklist_if_has_custom_linkage(&mut self, def_id: LocalDefId) {\n-        // Anything which has custom linkage gets thrown on the worklist no\n-        // matter where it is in the crate, along with \"special std symbols\"\n-        // which are currently akin to allocator symbols.\n-        if self.tcx.def_kind(def_id).has_codegen_attrs() {\n-            let codegen_attrs = self.tcx.codegen_fn_attrs(def_id);\n-            if codegen_attrs.contains_extern_indicator()\n-                || codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n-                // FIXME(nbdd0121): `#[used]` are marked as reachable here so it's picked up by\n-                // `linked_symbols` in cg_ssa. They won't be exported in binary or cdylib due to their\n-                // `SymbolExportLevel::Rust` export level but may end up being exported in dylibs.\n-                || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED)\n-                || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n-            {\n-                self.worklist.push(def_id);\n+            let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n+                unreachable!();\n+            };\n+\n+            if !trait_def_id.is_local() {\n+                return;\n             }\n+\n+            worklist.extend(\n+                tcx.provided_trait_methods(trait_def_id)\n+                    .map(|assoc| assoc.def_id.expect_local()),\n+            );\n         }\n     }\n }\n \n-impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        self.push_to_worklist_if_has_custom_linkage(item.def_id);\n-\n-        // We need only trait impls here, not inherent impls, and only non-exported ones\n-        if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n-            item.kind\n+fn push_to_worklist_if_has_custom_linkage<'tcx>(tcx: TyCtxt<'tcx>, worklist: &mut Vec<LocalDefId>, def_id: LocalDefId) {\n+    // Anything which has custom linkage gets thrown on the worklist no\n+    // matter where it is in the crate, along with \"special std symbols\"\n+    // which are currently akin to allocator symbols.\n+    if tcx.def_kind(def_id).has_codegen_attrs() {\n+        let codegen_attrs = tcx.codegen_fn_attrs(def_id);\n+        if codegen_attrs.contains_extern_indicator()\n+            || codegen_attrs.flags.contains(CodegenFnAttrFlags::RUSTC_STD_INTERNAL_SYMBOL)\n+            // FIXME(nbdd0121): `#[used]` are marked as reachable here so it's picked up by\n+            // `linked_symbols` in cg_ssa. They won't be exported in binary or cdylib due to their\n+            // `SymbolExportLevel::Rust` export level but may end up being exported in dylibs.\n+            || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED)\n+            || codegen_attrs.flags.contains(CodegenFnAttrFlags::USED_LINKER)\n         {\n-            if !self.access_levels.is_reachable(item.def_id) {\n-                // FIXME(#53488) remove `let`\n-                let tcx = self.tcx;\n-                self.worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id));\n-\n-                let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n-                    unreachable!();\n-                };\n-\n-                if !trait_def_id.is_local() {\n-                    return;\n-                }\n-\n-                self.worklist.extend(\n-                    tcx.provided_trait_methods(trait_def_id)\n-                        .map(|assoc| assoc.def_id.expect_local()),\n-                );\n-            }\n+            worklist.push(def_id);\n         }\n     }\n-\n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem<'_>) {\n-        self.push_to_worklist_if_has_custom_linkage(impl_item.def_id);\n-    }\n-\n-    fn visit_foreign_item(&mut self, _foreign_item: &hir::ForeignItem<'_>) {\n-        // We never export foreign functions as they have no body to export.\n-    }\n }\n \n fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n@@ -418,12 +394,23 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n         }\n     }\n     {\n-        let mut collect_private_impl_items = CollectPrivateImplItemsVisitor {\n-            tcx,\n-            access_levels,\n-            worklist: &mut reachable_context.worklist,\n-        };\n-        tcx.hir().visit_all_item_likes(&mut collect_private_impl_items);\n+        // Some methods from non-exported (completely private) trait impls still have to be\n+        // reachable if they are called from inlinable code. Generally, it's not known until\n+        // monomorphization if a specific trait impl item can be reachable or not. So, we\n+        // conservatively mark all of them as reachable.\n+        // FIXME: One possible strategy for pruning the reachable set is to avoid marking impl\n+        // items of non-exported traits (or maybe all local traits?) unless their respective\n+        // trait items are used from inlinable code through method call syntax or UFCS, or their\n+        // trait is a lang item.\n+        let crate_items = tcx.hir_crate_items(());\n+\n+        for id in crate_items.items() {\n+            check_item(tcx, tcx.hir().item(id), &mut reachable_context.worklist, access_levels);\n+        }\n+\n+        for id in crate_items.impl_items() {\n+            push_to_worklist_if_has_custom_linkage(tcx, &mut reachable_context.worklist, id.def_id)\n+        }\n     }\n \n     // Step 2: Mark all symbols that the symbols on the worklist touch."}]}