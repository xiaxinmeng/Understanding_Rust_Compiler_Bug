{"sha": "58dd1ce8383aaebcad9b6027b89a316fd868b35c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4ZGQxY2U4MzgzYWFlYmNhZDliNjAyN2I4OWEzMTZmZDg2OGIzNWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-31T22:28:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-31T22:28:18Z"}, "message": "Auto merge of #70638 - Dylan-DPC:rollup-2tgfxjt, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #68770 (BTreeMap/BTreeSet: implement drain_filter )\n - #70081 (add `unused_braces` lint)\n - #70556 (parse_and_disallow_postfix_after_cast: account for `ExprKind::Err`.)\n - #70605 (Add missing -lmsvcrt on mingw after -lpthread)\n - #70630 (Update books.)\n - #70632 (expand vec![] to Vec::new())\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "21ba3ae00a56b802477ae80fbbeec3187dfe1c5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21ba3ae00a56b802477ae80fbbeec3187dfe1c5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/58dd1ce8383aaebcad9b6027b89a316fd868b35c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/58dd1ce8383aaebcad9b6027b89a316fd868b35c", "html_url": "https://github.com/rust-lang/rust/commit/58dd1ce8383aaebcad9b6027b89a316fd868b35c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/58dd1ce8383aaebcad9b6027b89a316fd868b35c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5b09d35473615e7142f5570f5c5fad0caf68bd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5b09d35473615e7142f5570f5c5fad0caf68bd2", "html_url": "https://github.com/rust-lang/rust/commit/a5b09d35473615e7142f5570f5c5fad0caf68bd2"}, {"sha": "8310320ebd68d5f23ad21bb5a15326abeaf91dff", "url": "https://api.github.com/repos/rust-lang/rust/commits/8310320ebd68d5f23ad21bb5a15326abeaf91dff", "html_url": "https://github.com/rust-lang/rust/commit/8310320ebd68d5f23ad21bb5a15326abeaf91dff"}], "stats": {"total": 1448, "additions": 1254, "deletions": 194}, "files": [{"sha": "c8841f2841a2d26124319ddadd1b6a245f9a1856", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1 +1 @@\n-Subproject commit 6fb3705e5230311b096d47f7e2c91f9ce24393d0\n+Subproject commit c8841f2841a2d26124319ddadd1b6a245f9a1856"}, {"sha": "411197b0e77590c967e37e8f6ec681abd359afe8", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1 +1 @@\n-Subproject commit 9f797e65e6bcc79419975b17aff8e21c9adc039f\n+Subproject commit 411197b0e77590c967e37e8f6ec681abd359afe8"}, {"sha": "89dd146154474559536d5d4049a03831c501deea", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1 +1 @@\n-Subproject commit e2f11fe4d6a5ecb471c70323197da43c70cb96b6\n+Subproject commit 89dd146154474559536d5d4049a03831c501deea"}, {"sha": "edd2a7e687358712608896730c083cb76c7b401a", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1 +1 @@\n-Subproject commit cb369ae95ca36b841960182d26f6d5d9b2e3cc18\n+Subproject commit edd2a7e687358712608896730c083cb76c7b401a"}, {"sha": "2518506b9b5f3915996f9bc84fbc0f688c1e05af", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -62,6 +62,22 @@ pub fn clone_100_and_clear(b: &mut Bencher) {\n     b.iter(|| src.clone().clear())\n }\n \n+#[bench]\n+pub fn clone_100_and_drain_all(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| src.clone().drain_filter(|_| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_100_and_drain_half(b: &mut Bencher) {\n+    let src = pos(100);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 100 / 2);\n+        assert_eq!(set.len(), 100 / 2);\n+    })\n+}\n+\n #[bench]\n pub fn clone_100_and_into_iter(b: &mut Bencher) {\n     let src = pos(100);\n@@ -115,6 +131,22 @@ pub fn clone_10k_and_clear(b: &mut Bencher) {\n     b.iter(|| src.clone().clear())\n }\n \n+#[bench]\n+pub fn clone_10k_and_drain_all(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| src.clone().drain_filter(|_| true).count())\n+}\n+\n+#[bench]\n+pub fn clone_10k_and_drain_half(b: &mut Bencher) {\n+    let src = pos(10_000);\n+    b.iter(|| {\n+        let mut set = src.clone();\n+        assert_eq!(set.drain_filter(|i| i % 2 == 0).count(), 10_000 / 2);\n+        assert_eq!(set.len(), 10_000 / 2);\n+    })\n+}\n+\n #[bench]\n pub fn clone_10k_and_into_iter(b: &mut Bencher) {\n     let src = pos(10_000);"}, {"sha": "f31717d9fd517e76b860364f430e7170d2194822", "filename": "src/liballoc/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Flib.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,3 +1,4 @@\n+#![feature(btree_drain_filter)]\n #![feature(map_first_last)]\n #![feature(repr_simd)]\n #![feature(test)]"}, {"sha": "bbeced1751d1451830e5c3673f1489a6b6953de3", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 200, "deletions": 10, "changes": 210, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1256,6 +1256,48 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         right\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, the element is removed from the map and yielded.\n+    /// If the closure returns false, or panics, the element remains in the map and will not be\n+    /// yielded.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more elements will be subjected to the closure\n+    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n+    /// or if the `DrainFilter` value is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a map into even and odd keys, reusing the original map:\n+    ///\n+    /// ```\n+    /// #![feature(btree_drain_filter)]\n+    /// use std::collections::BTreeMap;\n+    ///\n+    /// let mut map: BTreeMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n+    /// let evens: BTreeMap<_, _> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    /// let odds = map;\n+    /// assert_eq!(evens.keys().copied().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds.keys().copied().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// ```\n+    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        DrainFilter { pred, inner: self.drain_filter_inner() }\n+    }\n+    pub(super) fn drain_filter_inner(&mut self) -> DrainFilterInner<'_, K, V> {\n+        let front = self.root.as_mut().map(|r| r.as_mut().first_leaf_edge());\n+        DrainFilterInner { length: &mut self.length, cur_leaf_edge: front }\n+    }\n+\n     /// Calculates the number of elements if it is incorrect.\n     fn recalc_length(&mut self) {\n         fn dfs<'a, K, V>(node: NodeRef<marker::Immut<'a>, K, V, marker::LeafOrInternal>) -> usize\n@@ -1653,6 +1695,124 @@ impl<K, V> Clone for Values<'_, K, V> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on BTreeMap.\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+pub struct DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + Ord, // This Ord bound should be removed before stabilization.\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    pred: F,\n+    inner: DrainFilterInner<'a, K, V>,\n+}\n+pub(super) struct DrainFilterInner<'a, K, V>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+{\n+    length: &'a mut usize,\n+    cur_leaf_edge: Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>>,\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, K, V, F> Drop for DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    fn drop(&mut self) {\n+        self.for_each(drop);\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + fmt::Debug + Ord,\n+    V: 'a + fmt::Debug,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek()).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, K, V, F> Iterator for DrainFilter<'a, K, V, F>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+    F: 'a + FnMut(&K, &mut V) -> bool,\n+{\n+    type Item = (K, V);\n+\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.inner.next(&mut self.pred)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+impl<'a, K, V> DrainFilterInner<'a, K, V>\n+where\n+    K: 'a + Ord,\n+    V: 'a,\n+{\n+    /// Allow Debug implementations to predict the next element.\n+    pub(super) fn peek(&self) -> Option<(&K, &V)> {\n+        let edge = self.cur_leaf_edge.as_ref()?;\n+        edge.reborrow().next_kv().ok().map(|kv| kv.into_kv())\n+    }\n+\n+    unsafe fn next_kv(\n+        &mut self,\n+    ) -> Option<Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>> {\n+        let edge = self.cur_leaf_edge.as_ref()?;\n+        ptr::read(edge).next_kv().ok()\n+    }\n+\n+    /// Implementation of a typical `DrainFilter::next` method, given the predicate.\n+    pub(super) fn next<F>(&mut self, pred: &mut F) -> Option<(K, V)>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        while let Some(kv) = unsafe { self.next_kv() } {\n+            let (k, v) = unsafe { ptr::read(&kv) }.into_kv_mut();\n+            if pred(k, v) {\n+                *self.length -= 1;\n+                let (k, v, leaf_edge_location) = kv.remove_kv_tracking();\n+                // `remove_kv_tracking` has either preserved or invalidated `self.cur_leaf_edge`\n+                if let Some(node) = leaf_edge_location {\n+                    match search::search_tree(node, &k) {\n+                        search::SearchResult::Found(_) => unreachable!(),\n+                        search::SearchResult::GoDown(leaf) => self.cur_leaf_edge = Some(leaf),\n+                    }\n+                };\n+                return Some((k, v));\n+            }\n+            self.cur_leaf_edge = Some(kv.next_leaf_edge());\n+        }\n+        None\n+    }\n+\n+    /// Implementation of a typical `DrainFilter::size_hint` method.\n+    pub(super) fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, Some(*self.length))\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F>\n+where\n+    K: Ord,\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+}\n+\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> Iterator for Range<'a, K, V> {\n     type Item = (&'a K, &'a V);\n@@ -2531,12 +2691,31 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n     fn remove_kv(self) -> (K, V) {\n         *self.length -= 1;\n \n-        let (small_leaf, old_key, old_val) = match self.handle.force() {\n+        let (old_key, old_val, _) = self.handle.remove_kv_tracking();\n+        (old_key, old_val)\n+    }\n+}\n+\n+impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV> {\n+    /// Removes a key/value-pair from the map, and returns that pair, as well as\n+    /// the whereabouts of the leaf edge corresponding to that former pair:\n+    /// if None is returned, the leaf edge is still the left leaf edge of the KV handle;\n+    /// if a node is returned, it heads the subtree where the leaf edge may be found.\n+    fn remove_kv_tracking(\n+        self,\n+    ) -> (K, V, Option<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>>) {\n+        let mut levels_down_handled: isize;\n+        let (small_leaf, old_key, old_val) = match self.force() {\n             Leaf(leaf) => {\n+                levels_down_handled = 1; // handled at same level, but affects only the right side\n                 let (hole, old_key, old_val) = leaf.remove();\n                 (hole.into_node(), old_key, old_val)\n             }\n             Internal(mut internal) => {\n+                // Replace the location freed in the internal node with the next KV,\n+                // and remove that next KV from its leaf.\n+                levels_down_handled = unsafe { ptr::read(&internal).into_node().height() } as isize;\n+\n                 let key_loc = internal.kv_mut().0 as *mut K;\n                 let val_loc = internal.kv_mut().1 as *mut V;\n \n@@ -2556,27 +2735,39 @@ impl<'a, K: Ord, V> OccupiedEntry<'a, K, V> {\n         let mut cur_node = small_leaf.forget_type();\n         while cur_node.len() < node::MIN_LEN {\n             match handle_underfull_node(cur_node) {\n-                AtRoot => break,\n+                AtRoot(root) => {\n+                    cur_node = root;\n+                    break;\n+                }\n                 EmptyParent(_) => unreachable!(),\n                 Merged(parent) => {\n+                    levels_down_handled -= 1;\n                     if parent.len() == 0 {\n                         // We must be at the root\n-                        parent.into_root_mut().pop_level();\n+                        let root = parent.into_root_mut();\n+                        root.pop_level();\n+                        cur_node = root.as_mut();\n                         break;\n                     } else {\n                         cur_node = parent.forget_type();\n                     }\n                 }\n-                Stole(_) => break,\n+                Stole(internal_node) => {\n+                    levels_down_handled -= 1;\n+                    cur_node = internal_node.forget_type();\n+                    // This internal node might be underfull, but only if it's the root.\n+                    break;\n+                }\n             }\n         }\n \n-        (old_key, old_val)\n+        let leaf_edge_location = if levels_down_handled > 0 { None } else { Some(cur_node) };\n+        (old_key, old_val, leaf_edge_location)\n     }\n }\n \n enum UnderflowResult<'a, K, V> {\n-    AtRoot,\n+    AtRoot(NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>),\n     EmptyParent(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n     Merged(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n     Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n@@ -2585,10 +2776,9 @@ enum UnderflowResult<'a, K, V> {\n fn handle_underfull_node<K, V>(\n     node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>,\n ) -> UnderflowResult<'_, K, V> {\n-    let parent = if let Ok(parent) = node.ascend() {\n-        parent\n-    } else {\n-        return AtRoot;\n+    let parent = match node.ascend() {\n+        Ok(parent) => parent,\n+        Err(root) => return AtRoot(root),\n     };\n \n     let (is_left, mut handle) = match parent.left_kv() {"}, {"sha": "0b02223def4f85dc76c4b894e2cd5c94d222f69a", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 98, "deletions": 3, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -8,8 +8,8 @@ use core::fmt::{self, Debug};\n use core::iter::{FromIterator, FusedIterator, Peekable};\n use core::ops::{BitAnd, BitOr, BitXor, RangeBounds, Sub};\n \n+use super::map::{BTreeMap, Keys};\n use super::Recover;\n-use crate::collections::btree_map::{self, BTreeMap, Keys};\n \n // FIXME(conventions): implement bounded iterators\n \n@@ -102,7 +102,7 @@ impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct IntoIter<T> {\n-    iter: btree_map::IntoIter<T, ()>,\n+    iter: super::map::IntoIter<T, ()>,\n }\n \n /// An iterator over a sub-range of items in a `BTreeSet`.\n@@ -115,7 +115,7 @@ pub struct IntoIter<T> {\n #[derive(Debug)]\n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n pub struct Range<'a, T: 'a> {\n-    iter: btree_map::Range<'a, T, ()>,\n+    iter: super::map::Range<'a, T, ()>,\n }\n \n /// Core of SymmetricDifference and Union.\n@@ -944,6 +944,41 @@ impl<T: Ord> BTreeSet<T> {\n     {\n         BTreeSet { map: self.map.split_off(key) }\n     }\n+\n+    /// Creates an iterator which uses a closure to determine if a value should be removed.\n+    ///\n+    /// If the closure returns true, then the value is removed and yielded.\n+    /// If the closure returns false, the value will remain in the list and will not be yielded\n+    /// by the iterator.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// values will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more values will be subjected to the closure\n+    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n+    /// `DrainFilter` itself is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a set into even and odd values, reusing the original set:\n+    ///\n+    /// ```\n+    /// #![feature(btree_drain_filter)]\n+    /// use std::collections::BTreeSet;\n+    ///\n+    /// let mut set: BTreeSet<i32> = (0..8).collect();\n+    /// let evens: BTreeSet<_> = set.drain_filter(|v| v % 2 == 0).collect();\n+    /// let odds = set;\n+    /// assert_eq!(evens.into_iter().collect::<Vec<_>>(), vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7]);\n+    /// ```\n+    #[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+    pub fn drain_filter<'a, F>(&'a mut self, pred: F) -> DrainFilter<'a, T, F>\n+    where\n+        F: 'a + FnMut(&T) -> bool,\n+    {\n+        DrainFilter { pred, inner: self.map.drain_filter_inner() }\n+    }\n }\n \n impl<T> BTreeSet<T> {\n@@ -1055,6 +1090,66 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n     }\n }\n \n+/// An iterator produced by calling `drain_filter` on BTreeSet.\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+pub struct DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    pred: F,\n+    inner: super::map::DrainFilterInner<'a, T, ()>,\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> Drop for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    fn drop(&mut self) {\n+        self.for_each(drop);\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> fmt::Debug for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord + fmt::Debug,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_tuple(\"DrainFilter\").field(&self.inner.peek().map(|(k, _)| k)).finish()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, 'f, T, F> Iterator for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + 'f + FnMut(&T) -> bool,\n+{\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        let pred = &mut self.pred;\n+        let mut mapped_pred = |k: &T, _v: &mut ()| pred(k);\n+        self.inner.next(&mut mapped_pred).map(|(k, _)| k)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.inner.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"btree_drain_filter\", issue = \"70530\")]\n+impl<'a, T, F> FusedIterator for DrainFilter<'a, T, F>\n+where\n+    T: 'a + Ord,\n+    F: 'a + FnMut(&T) -> bool,\n+{\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]"}, {"sha": "4bc0c3a079d5ca80451a8a68458206be5d92a10a", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -36,6 +36,9 @@\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[allow_internal_unstable(box_syntax)]\n macro_rules! vec {\n+    () => (\n+        $crate::vec::Vec::new()\n+    );\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)\n     );\n@@ -51,6 +54,9 @@ macro_rules! vec {\n // NB see the slice::hack module in slice.rs for more information\n #[cfg(test)]\n macro_rules! vec {\n+    () => (\n+        $crate::vec::Vec::new()\n+    );\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)\n     );"}, {"sha": "14f12ca2d779a453881489ade0410bfc55c05023", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 258, "deletions": 1, "changes": 259, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -5,7 +5,7 @@ use std::fmt::Debug;\n use std::iter::FromIterator;\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::ops::RangeBounds;\n-use std::panic::catch_unwind;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::rc::Rc;\n use std::sync::atomic::{AtomicUsize, Ordering};\n \n@@ -609,6 +609,263 @@ fn test_range_mut() {\n     }\n }\n \n+mod test_drain_filter {\n+    use super::*;\n+\n+    #[test]\n+    fn empty() {\n+        let mut map: BTreeMap<i32, i32> = BTreeMap::new();\n+        map.drain_filter(|_, _| unreachable!(\"there's nothing to decide on\"));\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn consuming_nothing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(map.drain_filter(|_, _| false).eq(std::iter::empty()));\n+    }\n+\n+    #[test]\n+    fn consuming_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+        assert!(map.drain_filter(|_, _| true).eq(pairs));\n+    }\n+\n+    #[test]\n+    fn mutating_and_keeping() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                false\n+            })\n+            .eq(std::iter::empty())\n+        );\n+        assert!(map.keys().copied().eq(0..3));\n+        assert!(map.values().copied().eq(6..9));\n+    }\n+\n+    #[test]\n+    fn mutating_and_removing() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        assert!(\n+            map.drain_filter(|_, v| {\n+                *v += 6;\n+                true\n+            })\n+            .eq((0..3).map(|i| (i, i + 6)))\n+        );\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn underfull_keeping_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| false);\n+        assert!(map.keys().copied().eq(0..3));\n+    }\n+\n+    #[test]\n+    fn underfull_removing_one() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        for doomed in 0..3 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), 2);\n+        }\n+    }\n+\n+    #[test]\n+    fn underfull_keeping_one() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        for sacred in 0..3 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn underfull_removing_all() {\n+        let pairs = (0..3).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_all() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| false);\n+        assert!(map.keys().copied().eq(0..NODE_CAPACITY));\n+    }\n+\n+    #[test]\n+    fn height_0_removing_one() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        for doomed in 0..NODE_CAPACITY {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), NODE_CAPACITY - 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_one() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        for sacred in 0..NODE_CAPACITY {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn height_0_removing_all() {\n+        let pairs = (0..NODE_CAPACITY).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_0_keeping_half() {\n+        let mut map: BTreeMap<_, _> = (0..16).map(|i| (i, i)).collect();\n+        assert_eq!(map.drain_filter(|i, _| *i % 2 == 0).count(), 8);\n+        assert_eq!(map.len(), 8);\n+    }\n+\n+    #[test]\n+    fn height_1_removing_all() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn height_1_removing_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        for doomed in 0..MIN_INSERTS_HEIGHT_1 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), MIN_INSERTS_HEIGHT_1 - 1);\n+        }\n+    }\n+\n+    #[test]\n+    fn height_1_keeping_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_1).map(|i| (i, i));\n+        for sacred in 0..MIN_INSERTS_HEIGHT_1 {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    #[test]\n+    fn height_2_removing_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        for doomed in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i == doomed);\n+            assert_eq!(map.len(), MIN_INSERTS_HEIGHT_2 - 1);\n+        }\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    #[test]\n+    fn height_2_keeping_one() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        for sacred in (0..MIN_INSERTS_HEIGHT_2).step_by(12) {\n+            let mut map: BTreeMap<_, _> = pairs.clone().collect();\n+            map.drain_filter(|i, _| *i != sacred);\n+            assert!(map.keys().copied().eq(sacred..=sacred));\n+        }\n+    }\n+\n+    #[test]\n+    fn height_2_removing_all() {\n+        let pairs = (0..MIN_INSERTS_HEIGHT_2).map(|i| (i, i));\n+        let mut map: BTreeMap<_, _> = pairs.collect();\n+        map.drain_filter(|_, _| true);\n+        assert!(map.is_empty());\n+    }\n+\n+    #[test]\n+    fn drop_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                    panic!(\"panic in `drop`\");\n+                }\n+            }\n+        }\n+\n+        let mut map = BTreeMap::new();\n+        map.insert(0, D);\n+        map.insert(4, D);\n+        map.insert(8, D);\n+\n+        catch_unwind(move || {\n+            drop(map.drain_filter(|i, _| {\n+                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                true\n+            }))\n+        })\n+        .ok();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+    }\n+\n+    #[test]\n+    fn pred_panic_leak() {\n+        static PREDS: AtomicUsize = AtomicUsize::new(0);\n+        static DROPS: AtomicUsize = AtomicUsize::new(0);\n+\n+        struct D;\n+        impl Drop for D {\n+            fn drop(&mut self) {\n+                DROPS.fetch_add(1, Ordering::SeqCst);\n+            }\n+        }\n+\n+        let mut map = BTreeMap::new();\n+        map.insert(0, D);\n+        map.insert(4, D);\n+        map.insert(8, D);\n+\n+        catch_unwind(AssertUnwindSafe(|| {\n+            drop(map.drain_filter(|i, _| {\n+                PREDS.fetch_add(1usize << i, Ordering::SeqCst);\n+                match i {\n+                    0 => true,\n+                    _ => panic!(),\n+                }\n+            }))\n+        }))\n+        .ok();\n+\n+        assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+        assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+        assert_eq!(map.len(), 2);\n+        assert_eq!(map.first_entry().unwrap().key(), &4);\n+        assert_eq!(map.last_entry().unwrap().key(), &8);\n+    }\n+}\n+\n #[test]\n fn test_borrow() {\n     // make sure these compile -- using the Borrow trait"}, {"sha": "136018b9f7df53e1f44985883524fca60aac293f", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,7 @@\n use std::collections::BTreeSet;\n use std::iter::FromIterator;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::sync::atomic::{AtomicU32, Ordering};\n \n use super::DeterministicRng;\n \n@@ -302,6 +304,85 @@ fn test_is_subset() {\n     assert_eq!(is_subset(&[99, 100], &large), false);\n }\n \n+#[test]\n+fn test_drain_filter() {\n+    let mut x: BTreeSet<_> = [1].iter().copied().collect();\n+    let mut y: BTreeSet<_> = [1].iter().copied().collect();\n+\n+    x.drain_filter(|_| true);\n+    y.drain_filter(|_| false);\n+    assert_eq!(x.len(), 0);\n+    assert_eq!(y.len(), 1);\n+}\n+\n+#[test]\n+fn test_drain_filter_drop_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            if DROPS.fetch_add(1, Ordering::SeqCst) == 1 {\n+                panic!(\"panic in `drop`\");\n+            }\n+        }\n+    }\n+\n+    let mut set = BTreeSet::new();\n+    set.insert(D(0));\n+    set.insert(D(4));\n+    set.insert(D(8));\n+\n+    catch_unwind(move || {\n+        drop(set.drain_filter(|d| {\n+            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            true\n+        }))\n+    })\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 3);\n+}\n+\n+#[test]\n+fn test_drain_filter_pred_panic_leak() {\n+    static PREDS: AtomicU32 = AtomicU32::new(0);\n+    static DROPS: AtomicU32 = AtomicU32::new(0);\n+\n+    #[derive(PartialEq, Eq, PartialOrd, Ord)]\n+    struct D(i32);\n+    impl Drop for D {\n+        fn drop(&mut self) {\n+            DROPS.fetch_add(1, Ordering::SeqCst);\n+        }\n+    }\n+\n+    let mut set = BTreeSet::new();\n+    set.insert(D(0));\n+    set.insert(D(4));\n+    set.insert(D(8));\n+\n+    catch_unwind(AssertUnwindSafe(|| {\n+        drop(set.drain_filter(|d| {\n+            PREDS.fetch_add(1u32 << d.0, Ordering::SeqCst);\n+            match d.0 {\n+                0 => true,\n+                _ => panic!(),\n+            }\n+        }))\n+    }))\n+    .ok();\n+\n+    assert_eq!(PREDS.load(Ordering::SeqCst), 0x011);\n+    assert_eq!(DROPS.load(Ordering::SeqCst), 1);\n+    assert_eq!(set.len(), 2);\n+    assert_eq!(set.first().unwrap().0, 4);\n+    assert_eq!(set.last().unwrap().0, 8);\n+}\n+\n #[test]\n fn test_clear() {\n     let mut x = BTreeSet::new();"}, {"sha": "ad6feaeebc67f884208e0fd4721935579fd8f662", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,6 @@\n #![feature(allocator_api)]\n #![feature(box_syntax)]\n+#![feature(btree_drain_filter)]\n #![feature(drain_filter)]\n #![feature(exact_size_is_empty)]\n #![feature(map_first_last)]"}, {"sha": "f6b8d4ba081467647534044fe3dbbfe4428f4d3d", "filename": "src/libcore/array/iter.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibcore%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibcore%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray%2Fiter.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -39,7 +39,7 @@ where\n     alive: Range<usize>,\n }\n \n-impl<T, const N: usize> IntoIter<T, { N }>\n+impl<T, const N: usize> IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -99,7 +99,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> Iterator for IntoIter<T, { N }>\n+impl<T, const N: usize> Iterator for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -146,7 +146,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, { N }>\n+impl<T, const N: usize> DoubleEndedIterator for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -182,7 +182,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> Drop for IntoIter<T, { N }>\n+impl<T, const N: usize> Drop for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -195,7 +195,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> ExactSizeIterator for IntoIter<T, { N }>\n+impl<T, const N: usize> ExactSizeIterator for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -210,17 +210,17 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T, const N: usize> FusedIterator for IntoIter<T, { N }> where [T; N]: LengthAtMost32 {}\n+impl<T, const N: usize> FusedIterator for IntoIter<T, N> where [T; N]: LengthAtMost32 {}\n \n // The iterator indeed reports the correct length. The number of \"alive\"\n // elements (that will still be yielded) is the length of the range `alive`.\n // This range is decremented in length in either `next` or `next_back`. It is\n // always decremented by 1 in those methods, but only if `Some(_)` is returned.\n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, { N }> where [T; N]: LengthAtMost32 {}\n+unsafe impl<T, const N: usize> TrustedLen for IntoIter<T, N> where [T; N]: LengthAtMost32 {}\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T: Clone, const N: usize> Clone for IntoIter<T, { N }>\n+impl<T: Clone, const N: usize> Clone for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {\n@@ -249,7 +249,7 @@ where\n }\n \n #[stable(feature = \"array_value_iter_impls\", since = \"1.40.0\")]\n-impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, { N }>\n+impl<T: fmt::Debug, const N: usize> fmt::Debug for IntoIter<T, N>\n where\n     [T; N]: LengthAtMost32,\n {"}, {"sha": "018e9da243c70a34f1319ef6549f6e8544f2779a", "filename": "src/librustc_lint/early.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -104,6 +104,11 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_pat_post, p);\n     }\n \n+    fn visit_anon_const(&mut self, c: &'a ast::AnonConst) {\n+        run_early_pass!(self, check_anon_const, c);\n+        ast_visit::walk_anon_const(self, c);\n+    }\n+\n     fn visit_expr(&mut self, e: &'a ast::Expr) {\n         self.with_lint_attrs(e.id, &e.attrs, |cx| {\n             run_early_pass!(cx, check_expr, e);"}, {"sha": "af1fad2c6608be402f129cfa62f77891c8d869e9", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -104,6 +104,7 @@ macro_rules! early_lint_passes {\n             $args,\n             [\n                 UnusedParens: UnusedParens,\n+                UnusedBraces: UnusedBraces,\n                 UnusedImportBraces: UnusedImportBraces,\n                 UnsafeCode: UnsafeCode,\n                 AnonymousParameters: AnonymousParameters,\n@@ -275,6 +276,7 @@ fn register_builtins(store: &mut LintStore, no_interleave_lints: bool) {\n         UNUSED_FEATURES,\n         UNUSED_LABELS,\n         UNUSED_PARENS,\n+        UNUSED_BRACES,\n         REDUNDANT_SEMICOLONS\n     );\n "}, {"sha": "c9e12afedbbab6fd3cf24d1da39fa563b0c79de8", "filename": "src/librustc_lint/passes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_lint%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_lint%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fpasses.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -170,6 +170,7 @@ macro_rules! early_lint_methods {\n             fn check_stmt(a: &ast::Stmt);\n             fn check_arm(a: &ast::Arm);\n             fn check_pat(a: &ast::Pat);\n+            fn check_anon_const(a: &ast::AnonConst);\n             fn check_pat_post(a: &ast::Pat);\n             fn check_expr(a: &ast::Expr);\n             fn check_expr_post(a: &ast::Expr);"}, {"sha": "c74b399555a8a874ff96bd74e75af1aeb1515019", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 363, "deletions": 129, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,7 @@\n+use crate::Lint;\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast::ast;\n+use rustc_ast::ast::{ExprKind, StmtKind};\n use rustc_ast::attr;\n use rustc_ast::util::parser;\n use rustc_ast_pretty::pprust;\n@@ -315,123 +317,108 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n     }\n }\n \n-declare_lint! {\n-    pub(super) UNUSED_PARENS,\n-    Warn,\n-    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum UnusedDelimsCtx {\n+    FunctionArg,\n+    MethodArg,\n+    AssignedValue,\n+    IfCond,\n+    WhileCond,\n+    ForIterExpr,\n+    MatchScrutineeExpr,\n+    ReturnValue,\n+    BlockRetValue,\n+    LetScrutineeExpr,\n+    ArrayLenExpr,\n+    AnonConst,\n }\n \n-declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n+impl From<UnusedDelimsCtx> for &'static str {\n+    fn from(ctx: UnusedDelimsCtx) -> &'static str {\n+        match ctx {\n+            UnusedDelimsCtx::FunctionArg => \"function argument\",\n+            UnusedDelimsCtx::MethodArg => \"method argument\",\n+            UnusedDelimsCtx::AssignedValue => \"assigned value\",\n+            UnusedDelimsCtx::IfCond => \"`if` condition\",\n+            UnusedDelimsCtx::WhileCond => \"`while` condition\",\n+            UnusedDelimsCtx::ForIterExpr => \"`for` iterator expression\",\n+            UnusedDelimsCtx::MatchScrutineeExpr => \"`match` scrutinee expression\",\n+            UnusedDelimsCtx::ReturnValue => \"`return` value\",\n+            UnusedDelimsCtx::BlockRetValue => \"block return value\",\n+            UnusedDelimsCtx::LetScrutineeExpr => \"`let` scrutinee expression\",\n+            UnusedDelimsCtx::ArrayLenExpr | UnusedDelimsCtx::AnonConst => \"const expression\",\n+        }\n+    }\n+}\n \n-impl UnusedParens {\n-    fn is_expr_parens_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n+/// Used by both `UnusedParens` and `UnusedBraces` to prevent code duplication.\n+trait UnusedDelimLint {\n+    const DELIM_STR: &'static str;\n+\n+    // this cannot be a constant is it refers to a static.\n+    fn lint(&self) -> &'static Lint;\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    );\n+\n+    fn is_expr_delims_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n         followed_by_block\n             && match inner.kind {\n                 ast::ExprKind::Ret(_) | ast::ExprKind::Break(..) => true,\n                 _ => parser::contains_exterior_struct_lit(&inner),\n             }\n     }\n \n-    fn check_unused_parens_expr(\n+    fn emit_unused_delims_expr(\n         &self,\n         cx: &EarlyContext<'_>,\n         value: &ast::Expr,\n-        msg: &str,\n-        followed_by_block: bool,\n+        ctx: UnusedDelimsCtx,\n         left_pos: Option<BytePos>,\n         right_pos: Option<BytePos>,\n     ) {\n-        match value.kind {\n-            ast::ExprKind::Paren(ref inner) => {\n-                if !Self::is_expr_parens_necessary(inner, followed_by_block)\n-                    && value.attrs.is_empty()\n-                    && !value.span.from_expansion()\n-                {\n-                    let expr_text =\n-                        if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n-                            snippet\n-                        } else {\n-                            pprust::expr_to_string(value)\n-                        };\n-                    let keep_space = (\n-                        left_pos.map(|s| s >= value.span.lo()).unwrap_or(false),\n-                        right_pos.map(|s| s <= value.span.hi()).unwrap_or(false),\n-                    );\n-                    Self::remove_outer_parens(cx, value.span, &expr_text, msg, keep_space);\n-                }\n-            }\n-            ast::ExprKind::Let(_, ref expr) => {\n-                // FIXME(#60336): Properly handle `let true = (false && true)`\n-                // actually needing the parenthesis.\n-                self.check_unused_parens_expr(\n-                    cx,\n-                    expr,\n-                    \"`let` head expression\",\n-                    followed_by_block,\n-                    None,\n-                    None,\n-                );\n-            }\n-            _ => {}\n-        }\n+        let expr_text = if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n+            snippet\n+        } else {\n+            pprust::expr_to_string(value)\n+        };\n+        let keep_space = (\n+            left_pos.map(|s| s >= value.span.lo()).unwrap_or(false),\n+            right_pos.map(|s| s <= value.span.hi()).unwrap_or(false),\n+        );\n+        self.emit_unused_delims(cx, value.span, &expr_text, ctx.into(), keep_space);\n     }\n \n-    fn check_unused_parens_pat(\n+    fn emit_unused_delims(\n         &self,\n-        cx: &EarlyContext<'_>,\n-        value: &ast::Pat,\n-        avoid_or: bool,\n-        avoid_mut: bool,\n-    ) {\n-        use ast::{BindingMode, Mutability, PatKind};\n-\n-        if let PatKind::Paren(inner) = &value.kind {\n-            match inner.kind {\n-                // The lint visitor will visit each subpattern of `p`. We do not want to lint\n-                // any range pattern no matter where it occurs in the pattern. For something like\n-                // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n-                // that if there are unnecessary parens they serve a purpose of readability.\n-                PatKind::Range(..) => return,\n-                // Avoid `p0 | .. | pn` if we should.\n-                PatKind::Or(..) if avoid_or => return,\n-                // Avoid `mut x` and `mut x @ p` if we should:\n-                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n-                // Otherwise proceed with linting.\n-                _ => {}\n-            }\n-\n-            let pattern_text =\n-                if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n-                    snippet\n-                } else {\n-                    pprust::pat_to_string(value)\n-                };\n-            Self::remove_outer_parens(cx, value.span, &pattern_text, \"pattern\", (false, false));\n-        }\n-    }\n-\n-    fn remove_outer_parens(\n         cx: &EarlyContext<'_>,\n         span: Span,\n         pattern: &str,\n         msg: &str,\n         keep_space: (bool, bool),\n     ) {\n-        cx.struct_span_lint(UNUSED_PARENS, span, |lint| {\n-            let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n+        cx.struct_span_lint(self.lint(), span, |lint| {\n+            let span_msg = format!(\"unnecessary {} around {}\", Self::DELIM_STR, msg);\n             let mut err = lint.build(&span_msg);\n             let mut ate_left_paren = false;\n             let mut ate_right_paren = false;\n             let parens_removed = pattern.trim_matches(|c| match c {\n-                '(' => {\n+                '(' | '{' => {\n                     if ate_left_paren {\n                         false\n                     } else {\n                         ate_left_paren = true;\n                         true\n                     }\n                 }\n-                ')' => {\n+                ')' | '}' => {\n                     if ate_right_paren {\n                         false\n                     } else {\n@@ -457,61 +444,51 @@ impl UnusedParens {\n                 replace\n             };\n \n-            err.span_suggestion_short(\n-                span,\n-                \"remove these parentheses\",\n-                replace,\n-                Applicability::MachineApplicable,\n-            );\n+            let suggestion = format!(\"remove these {}\", Self::DELIM_STR);\n+\n+            err.span_suggestion_short(span, &suggestion, replace, Applicability::MachineApplicable);\n             err.emit();\n         });\n     }\n-}\n \n-impl EarlyLintPass for UnusedParens {\n     fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use rustc_ast::ast::ExprKind::*;\n-        let (value, msg, followed_by_block, left_pos, right_pos) = match e.kind {\n-            Let(ref pat, ..) => {\n-                self.check_unused_parens_pat(cx, pat, false, false);\n-                return;\n-            }\n-\n+        let (value, ctx, followed_by_block, left_pos, right_pos) = match e.kind {\n             If(ref cond, ref block, ..) => {\n                 let left = e.span.lo() + rustc_span::BytePos(2);\n                 let right = block.span.lo();\n-                (cond, \"`if` condition\", true, Some(left), Some(right))\n+                (cond, UnusedDelimsCtx::IfCond, true, Some(left), Some(right))\n             }\n \n             While(ref cond, ref block, ..) => {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n                 let right = block.span.lo();\n-                (cond, \"`while` condition\", true, Some(left), Some(right))\n+                (cond, UnusedDelimsCtx::WhileCond, true, Some(left), Some(right))\n             }\n \n-            ForLoop(ref pat, ref cond, ref block, ..) => {\n-                self.check_unused_parens_pat(cx, pat, false, false);\n-                (cond, \"`for` head expression\", true, None, Some(block.span.lo()))\n+            ForLoop(_, ref cond, ref block, ..) => {\n+                (cond, UnusedDelimsCtx::ForIterExpr, true, None, Some(block.span.lo()))\n             }\n \n             Match(ref head, _) => {\n                 let left = e.span.lo() + rustc_span::BytePos(5);\n-                (head, \"`match` head expression\", true, Some(left), None)\n+                (head, UnusedDelimsCtx::MatchScrutineeExpr, true, Some(left), None)\n             }\n \n             Ret(Some(ref value)) => {\n                 let left = e.span.lo() + rustc_span::BytePos(3);\n-                (value, \"`return` value\", false, Some(left), None)\n+                (value, UnusedDelimsCtx::ReturnValue, false, Some(left), None)\n             }\n \n-            Assign(_, ref value, _) => (value, \"assigned value\", false, None, None),\n-            AssignOp(.., ref value) => (value, \"assigned value\", false, None, None),\n+            Assign(_, ref value, _) | AssignOp(.., ref value) => {\n+                (value, UnusedDelimsCtx::AssignedValue, false, None, None)\n+            }\n             // either function/method call, or something this lint doesn't care about\n             ref call_or_other => {\n-                let (args_to_check, call_kind) = match *call_or_other {\n-                    Call(_, ref args) => (&args[..], \"function\"),\n-                    // first \"argument\" is self (which sometimes needs parens)\n-                    MethodCall(_, ref args) => (&args[1..], \"method\"),\n+                let (args_to_check, ctx) = match *call_or_other {\n+                    Call(_, ref args) => (&args[..], UnusedDelimsCtx::FunctionArg),\n+                    // first \"argument\" is self (which sometimes needs delims)\n+                    MethodCall(_, ref args) => (&args[1..], UnusedDelimsCtx::MethodArg),\n                     // actual catch-all arm\n                     _ => {\n                         return;\n@@ -524,14 +501,152 @@ impl EarlyLintPass for UnusedParens {\n                 if e.span.ctxt().outer_expn_data().call_site.from_expansion() {\n                     return;\n                 }\n-                let msg = format!(\"{} argument\", call_kind);\n                 for arg in args_to_check {\n-                    self.check_unused_parens_expr(cx, arg, &msg, false, None, None);\n+                    self.check_unused_delims_expr(cx, arg, ctx, false, None, None);\n                 }\n                 return;\n             }\n         };\n-        self.check_unused_parens_expr(cx, &value, msg, followed_by_block, left_pos, right_pos);\n+        self.check_unused_delims_expr(cx, &value, ctx, followed_by_block, left_pos, right_pos);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        match s.kind {\n+            StmtKind::Local(ref local) => {\n+                if let Some(ref value) = local.init {\n+                    self.check_unused_delims_expr(\n+                        cx,\n+                        &value,\n+                        UnusedDelimsCtx::AssignedValue,\n+                        false,\n+                        None,\n+                        None,\n+                    );\n+                }\n+            }\n+            StmtKind::Expr(ref expr) => {\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    &expr,\n+                    UnusedDelimsCtx::BlockRetValue,\n+                    false,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        use ast::ItemKind::*;\n+\n+        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n+            self.check_unused_delims_expr(\n+                cx,\n+                expr,\n+                UnusedDelimsCtx::AssignedValue,\n+                false,\n+                None,\n+                None,\n+            );\n+        }\n+    }\n+}\n+\n+declare_lint! {\n+    pub(super) UNUSED_PARENS,\n+    Warn,\n+    \"`if`, `match`, `while` and `return` do not need parentheses\"\n+}\n+\n+declare_lint_pass!(UnusedParens => [UNUSED_PARENS]);\n+\n+impl UnusedDelimLint for UnusedParens {\n+    const DELIM_STR: &'static str = \"parentheses\";\n+\n+    fn lint(&self) -> &'static Lint {\n+        UNUSED_PARENS\n+    }\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    ) {\n+        match value.kind {\n+            ast::ExprKind::Paren(ref inner) => {\n+                if !Self::is_expr_delims_necessary(inner, followed_by_block)\n+                    && value.attrs.is_empty()\n+                    && !value.span.from_expansion()\n+                {\n+                    self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n+                }\n+            }\n+            ast::ExprKind::Let(_, ref expr) => {\n+                // FIXME(#60336): Properly handle `let true = (false && true)`\n+                // actually needing the parenthesis.\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    expr,\n+                    UnusedDelimsCtx::LetScrutineeExpr,\n+                    followed_by_block,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+impl UnusedParens {\n+    fn check_unused_parens_pat(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Pat,\n+        avoid_or: bool,\n+        avoid_mut: bool,\n+    ) {\n+        use ast::{BindingMode, Mutability, PatKind};\n+\n+        if let PatKind::Paren(inner) = &value.kind {\n+            match inner.kind {\n+                // The lint visitor will visit each subpattern of `p`. We do not want to lint\n+                // any range pattern no matter where it occurs in the pattern. For something like\n+                // `&(a..=b)`, there is a recursive `check_pat` on `a` and `b`, but we will assume\n+                // that if there are unnecessary parens they serve a purpose of readability.\n+                PatKind::Range(..) => return,\n+                // Avoid `p0 | .. | pn` if we should.\n+                PatKind::Or(..) if avoid_or => return,\n+                // Avoid `mut x` and `mut x @ p` if we should:\n+                PatKind::Ident(BindingMode::ByValue(Mutability::Mut), ..) if avoid_mut => return,\n+                // Otherwise proceed with linting.\n+                _ => {}\n+            }\n+\n+            let pattern_text =\n+                if let Ok(snippet) = cx.sess().source_map().span_to_snippet(value.span) {\n+                    snippet\n+                } else {\n+                    pprust::pat_to_string(value)\n+                };\n+            self.emit_unused_delims(cx, value.span, &pattern_text, \"pattern\", (false, false));\n+        }\n+    }\n+}\n+\n+impl EarlyLintPass for UnusedParens {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        if let ExprKind::Let(ref pat, ..) | ExprKind::ForLoop(ref pat, ..) = e.kind {\n+            self.check_unused_parens_pat(cx, pat, false, false);\n+        }\n+\n+        <Self as UnusedDelimLint>::check_expr(self, cx, e)\n     }\n \n     fn check_pat(&mut self, cx: &EarlyContext<'_>, p: &ast::Pat) {\n@@ -556,22 +671,16 @@ impl EarlyLintPass for UnusedParens {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n-        use ast::StmtKind::*;\n-\n-        match s.kind {\n-            Local(ref local) => {\n-                self.check_unused_parens_pat(cx, &local.pat, false, false);\n+    fn check_anon_const(&mut self, cx: &EarlyContext<'_>, c: &ast::AnonConst) {\n+        self.check_unused_delims_expr(cx, &c.value, UnusedDelimsCtx::AnonConst, false, None, None);\n+    }\n \n-                if let Some(ref value) = local.init {\n-                    self.check_unused_parens_expr(cx, &value, \"assigned value\", false, None, None);\n-                }\n-            }\n-            Expr(ref expr) => {\n-                self.check_unused_parens_expr(cx, &expr, \"block return value\", false, None, None);\n-            }\n-            _ => {}\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        if let StmtKind::Local(ref local) = s.kind {\n+            self.check_unused_parens_pat(cx, &local.pat, false, false);\n         }\n+\n+        <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n     }\n \n     fn check_param(&mut self, cx: &EarlyContext<'_>, param: &ast::Param) {\n@@ -587,6 +696,16 @@ impl EarlyLintPass for UnusedParens {\n             match &r.kind {\n                 &ast::TyKind::TraitObject(..) => {}\n                 &ast::TyKind::ImplTrait(_, ref bounds) if bounds.len() > 1 => {}\n+                &ast::TyKind::Array(_, ref len) => {\n+                    self.check_unused_delims_expr(\n+                        cx,\n+                        &len.value,\n+                        UnusedDelimsCtx::ArrayLenExpr,\n+                        false,\n+                        None,\n+                        None,\n+                    );\n+                }\n                 _ => {\n                     let pattern_text =\n                         if let Ok(snippet) = cx.sess().source_map().span_to_snippet(ty.span) {\n@@ -595,19 +714,134 @@ impl EarlyLintPass for UnusedParens {\n                             pprust::ty_to_string(ty)\n                         };\n \n-                    Self::remove_outer_parens(cx, ty.span, &pattern_text, \"type\", (false, false));\n+                    self.emit_unused_delims(cx, ty.span, &pattern_text, \"type\", (false, false));\n                 }\n             }\n         }\n     }\n \n     fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n-        use ast::ItemKind::*;\n+        <Self as UnusedDelimLint>::check_item(self, cx, item)\n+    }\n+}\n \n-        if let Const(.., Some(expr)) | Static(.., Some(expr)) = &item.kind {\n-            self.check_unused_parens_expr(cx, expr, \"assigned value\", false, None, None);\n+declare_lint! {\n+    pub(super) UNUSED_BRACES,\n+    Warn,\n+    \"unnecessary braces around an expression\"\n+}\n+\n+declare_lint_pass!(UnusedBraces => [UNUSED_BRACES]);\n+\n+impl UnusedDelimLint for UnusedBraces {\n+    const DELIM_STR: &'static str = \"braces\";\n+\n+    fn lint(&self) -> &'static Lint {\n+        UNUSED_BRACES\n+    }\n+\n+    fn check_unused_delims_expr(\n+        &self,\n+        cx: &EarlyContext<'_>,\n+        value: &ast::Expr,\n+        ctx: UnusedDelimsCtx,\n+        followed_by_block: bool,\n+        left_pos: Option<BytePos>,\n+        right_pos: Option<BytePos>,\n+    ) {\n+        match value.kind {\n+            ast::ExprKind::Block(ref inner, None)\n+                if inner.rules == ast::BlockCheckMode::Default =>\n+            {\n+                // emit a warning under the following conditions:\n+                //\n+                // - the block does not have a label\n+                // - the block is not `unsafe`\n+                // - the block contains exactly one expression (do not lint `{ expr; }`)\n+                // - `followed_by_block` is true and the internal expr may contain a `{`\n+                // - the block is not multiline (do not lint multiline match arms)\n+                //      ```\n+                //      match expr {\n+                //          Pattern => {\n+                //              somewhat_long_expression\n+                //          }\n+                //          // ...\n+                //      }\n+                //      ```\n+                // - the block has no attribute and was not created inside a macro\n+                // - if the block is an `anon_const`, the inner expr must be a literal\n+                //      (do not lint `struct A<const N: usize>; let _: A<{ 2 + 3 }>;`)\n+                //\n+                // FIXME(const_generics): handle paths when #67075 is fixed.\n+                if let [stmt] = inner.stmts.as_slice() {\n+                    if let ast::StmtKind::Expr(ref expr) = stmt.kind {\n+                        if !Self::is_expr_delims_necessary(expr, followed_by_block)\n+                            && (ctx != UnusedDelimsCtx::AnonConst\n+                                || matches!(expr.kind, ast::ExprKind::Lit(_)))\n+                            // array length expressions are checked during `check_anon_const` and `check_ty`,\n+                            // once as `ArrayLenExpr` and once as `AnonConst`.\n+                            //\n+                            // As we do not want to lint this twice, we do not emit an error for\n+                            // `ArrayLenExpr` if `AnonConst` would do the same.\n+                            && (ctx != UnusedDelimsCtx::ArrayLenExpr\n+                                || !matches!(expr.kind, ast::ExprKind::Lit(_)))\n+                            && !cx.sess().source_map().is_multiline(value.span)\n+                            && value.attrs.is_empty()\n+                            && !value.span.from_expansion()\n+                        {\n+                            self.emit_unused_delims_expr(cx, value, ctx, left_pos, right_pos)\n+                        }\n+                    }\n+                }\n+            }\n+            ast::ExprKind::Let(_, ref expr) => {\n+                // FIXME(#60336): Properly handle `let true = (false && true)`\n+                // actually needing the parenthesis.\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    expr,\n+                    UnusedDelimsCtx::LetScrutineeExpr,\n+                    followed_by_block,\n+                    None,\n+                    None,\n+                );\n+            }\n+            _ => {}\n+        }\n+    }\n+}\n+\n+impl EarlyLintPass for UnusedBraces {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n+        <Self as UnusedDelimLint>::check_expr(self, cx, e)\n+    }\n+\n+    fn check_anon_const(&mut self, cx: &EarlyContext<'_>, c: &ast::AnonConst) {\n+        self.check_unused_delims_expr(cx, &c.value, UnusedDelimsCtx::AnonConst, false, None, None);\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n+        <Self as UnusedDelimLint>::check_stmt(self, cx, s)\n+    }\n+\n+    fn check_ty(&mut self, cx: &EarlyContext<'_>, ty: &ast::Ty) {\n+        if let &ast::TyKind::Paren(ref r) = &ty.kind {\n+            if let ast::TyKind::Array(_, ref len) = r.kind {\n+                self.check_unused_delims_expr(\n+                    cx,\n+                    &len.value,\n+                    UnusedDelimsCtx::ArrayLenExpr,\n+                    false,\n+                    None,\n+                    None,\n+                );\n+            }\n         }\n     }\n+\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n+        <Self as UnusedDelimLint>::check_item(self, cx, item)\n+    }\n }\n \n declare_lint! {"}, {"sha": "7ed77304a90e1b07a26492ea1b0eb824c1424233", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -356,9 +356,11 @@ fn add_query_description_impl(\n                 quote! { #t }\n             })\n             .unwrap_or(quote! { _ });\n+        // expr is a `Block`, meaning that `{ #expr }` gets expanded\n+        // to `{ { stmts... } }`, which triggers the `unused_braces` lint.\n         quote! {\n             #[inline]\n-            #[allow(unused_variables)]\n+            #[allow(unused_variables, unused_braces)]\n             fn cache_on_disk(\n                 #tcx: TyCtxt<'tcx>,\n                 #key: Self::Key,"}, {"sha": "cbff99f8da612d1200a4110a8dc01608b3f8406f", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -638,6 +638,7 @@ impl<'a> Parser<'a> {\n                     ExprKind::MethodCall(_, _) => \"a method call\",\n                     ExprKind::Call(_, _) => \"a function call\",\n                     ExprKind::Await(_) => \"`.await`\",\n+                    ExprKind::Err => return Ok(with_postfix),\n                     _ => unreachable!(\"parse_dot_or_call_expr_with_ shouldn't produce this\"),\n                 }\n             );"}, {"sha": "21f43b6fd4f6473b20e6bb735c681141171280b1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -2808,7 +2808,7 @@ impl<'a> Resolver<'a> {\n             ast::Path {\n                 span,\n                 segments: iter::once(Ident::with_dummy_span(kw::PathRoot))\n-                    .chain({ path_str.split(\"::\").skip(1).map(Ident::from_str) })\n+                    .chain(path_str.split(\"::\").skip(1).map(Ident::from_str))\n                     .map(|i| self.new_ast_path_segment(i))\n                     .collect(),\n             }"}, {"sha": "5f59ca8a5a311eca31ccc4ce719cf982dfa950ca", "filename": "src/librustc_target/spec/windows_base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_target%2Fspec%2Fwindows_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibrustc_target%2Fspec%2Fwindows_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fwindows_base.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -60,6 +60,8 @@ pub fn opts() -> TargetOptions {\n             \"-lgcc\".to_string(),\n             \"-lgcc_eh\".to_string(),\n             \"-lpthread\".to_string(),\n+            // libpthread depends on libmsvcrt, so we need to link it *again*.\n+            \"-lmsvcrt\".to_string(),\n             \"-lkernel32\".to_string(),\n         ],\n     );"}, {"sha": "d00381792e351dfe185f54adad843c6c0bc53ec7", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -115,8 +115,7 @@ impl RawHandle {\n     ) -> io::Result<Option<usize>> {\n         let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         let mut amt = 0;\n-        let res =\n-            cvt({ c::ReadFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, overlapped) });\n+        let res = cvt(c::ReadFile(self.0, buf.as_ptr() as c::LPVOID, len, &mut amt, overlapped));\n         match res {\n             Ok(_) => Ok(Some(amt as usize)),\n             Err(e) => {\n@@ -139,7 +138,7 @@ impl RawHandle {\n         unsafe {\n             let mut bytes = 0;\n             let wait = if wait { c::TRUE } else { c::FALSE };\n-            let res = cvt({ c::GetOverlappedResult(self.raw(), overlapped, &mut bytes, wait) });\n+            let res = cvt(c::GetOverlappedResult(self.raw(), overlapped, &mut bytes, wait));\n             match res {\n                 Ok(_) => Ok(bytes as usize),\n                 Err(e) => {"}, {"sha": "a193bf998dc73e5104b8aa3358ba2452fa6b2fb3", "filename": "src/test/incremental/const-generics/issue-61516.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61516.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61516.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fconst-generics%2Fissue-61516.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -4,7 +4,7 @@\n \n struct FakeArray<T, const N: usize>(T);\n \n-impl<T, const N: usize> FakeArray<T, { N }> {\n+impl<T, const N: usize> FakeArray<T, N> {\n     fn len(&self) -> usize {\n         N\n     }"}, {"sha": "908c39c7951c06ad510df8db8be8f0906594d539", "filename": "src/test/ui/array-slice-vec/vec-fixed-length.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-fixed-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-fixed-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fvec-fixed-length.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -9,7 +9,7 @@ fn test_big_vec() {}\n #[cfg(target_pointer_width = \"64\")]\n fn test_big_vec()\n {\n-    assert_eq!(size_of::<[u8; (1 << 32)]>(), (1 << 32));\n+    assert_eq!(size_of::<[u8; 1 << 32]>(), (1 << 32));\n }\n \n fn main() {"}, {"sha": "d993ad9945974bc7091b8798c9ccc4e44af36965", "filename": "src/test/ui/block-fn-coerce.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fblock-fn-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fblock-fn-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-fn-coerce.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n \n fn force<F>(f: F) -> isize where F: FnOnce() -> isize { return f(); }\n "}, {"sha": "c5dd87c0f5a1fb712de242c120c997ab00e82559", "filename": "src/test/ui/cleanup-rvalue-scopes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fcleanup-rvalue-scopes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fcleanup-rvalue-scopes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcleanup-rvalue-scopes.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![allow(non_snake_case)]\n #![allow(unused_variables)]\n // Test that destructors for rvalue temporaries run either at end of"}, {"sha": "d486fdf73aba8d795a1dde8c4ff37ad921efed26", "filename": "src/test/ui/coerce/coerce-expect-unsized.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-expect-unsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-expect-unsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-expect-unsized.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n #![feature(box_syntax)]\n \n use std::cell::RefCell;"}, {"sha": "d5484607c8b52021ab31d7b36e7a7b688d904543", "filename": "src/test/ui/coerce/coerce-overloaded-autoderef.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-overloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-overloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcoerce%2Fcoerce-overloaded-autoderef.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n #![allow(dead_code)]\n // pretty-expanded FIXME #23616\n "}, {"sha": "212e16253f6b812cb507a8499821faab666030e1", "filename": "src/test/ui/const-generics/issues/issue-62504.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-62504.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -7,13 +7,13 @@ trait HasSize {\n     const SIZE: usize;\n }\n \n-impl<const X: usize> HasSize for ArrayHolder<{ X }> {\n+impl<const X: usize> HasSize for ArrayHolder<X> {\n     const SIZE: usize = X;\n }\n \n struct ArrayHolder<const X: usize>([u32; X]);\n \n-impl<const X: usize> ArrayHolder<{ X }> {\n+impl<const X: usize> ArrayHolder<X> {\n     pub const fn new() -> Self {\n         ArrayHolder([0; Self::SIZE])\n         //~^ ERROR: mismatched types"}, {"sha": "a3eca0dd7d965585fea9d5be467864248c589081", "filename": "src/test/ui/const-generics/issues/issue-70125-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70125-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70125-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-70125-2.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -13,4 +13,4 @@ trait Foo<const X: usize> {\n     }\n }\n \n-impl Foo<{3}> for () {}\n+impl Foo<3> for () {}"}, {"sha": "05234faf714201f21db3bf6c80b5f83d0385f7d2", "filename": "src/test/ui/const-generics/unused_braces.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -0,0 +1,13 @@\n+// check-pass\n+#![warn(unused_braces)]\n+\n+#![feature(const_generics)]\n+//~^ WARN the feature `const_generics` is incomplete and may cause the compiler to crash\n+\n+struct A<const N: usize>;\n+\n+fn main() {\n+    let _: A<7>; // ok\n+    let _: A<{ 7 }>; //~ WARN unnecessary braces\n+    let _: A<{ 3 + 5 }>; // ok\n+}"}, {"sha": "fc3da6096e7d447dd61561e6660ef976c3dedb39", "filename": "src/test/ui/const-generics/unused_braces.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Funused_braces.stderr?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -0,0 +1,20 @@\n+warning: the feature `const_generics` is incomplete and may cause the compiler to crash\n+  --> $DIR/unused_braces.rs:4:12\n+   |\n+LL | #![feature(const_generics)]\n+   |            ^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: unnecessary braces around const expression\n+  --> $DIR/unused_braces.rs:11:14\n+   |\n+LL |     let _: A<{ 7 }>;\n+   |              ^^^^^ help: remove these braces\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_braces.rs:2:9\n+   |\n+LL | #![warn(unused_braces)]\n+   |         ^^^^^^^^^^^^^\n+"}, {"sha": "ec99c70f6e0b90587871b0c66193b14950e1f440", "filename": "src/test/ui/consts/const-block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fconsts%2Fconst-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fconsts%2Fconst-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-block.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![allow(dead_code)]\n #![allow(unused_unsafe)]\n "}, {"sha": "d081cb2be7ee39820bb146a6c5eab90f85a38ada", "filename": "src/test/ui/expr-block-generic-unique1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-block-generic-unique1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-block-generic-unique1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-block-generic-unique1.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![feature(box_syntax)]\n \n fn test_generic<T, F>(expected: Box<T>, eq: F) where T: Clone, F: FnOnce(Box<T>, Box<T>) -> bool {"}, {"sha": "9362eb86fc30976dd713c7a408d70c05469bce09", "filename": "src/test/ui/expr-block-generic-unique2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-block-generic-unique2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-block-generic-unique2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-block-generic-unique2.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![feature(box_syntax)]\n \n fn test_generic<T, F>(expected: T, eq: F) where T: Clone, F: FnOnce(T, T) -> bool {"}, {"sha": "29c7c42219c737df82b4aef911bfa8bd9d737f5d", "filename": "src/test/ui/expr-block-generic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-block-generic.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n \n fn test_generic<T: Clone, F>(expected: T, eq: F) where F: FnOnce(T, T) -> bool {\n     let actual: T = { expected.clone() };"}, {"sha": "eff3fd3a15152a78e55d7d38d381d9c037de1ec1", "filename": "src/test/ui/expr-block-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-block-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-block-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-block-unique.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![feature(box_syntax)]\n \n pub fn main() { let x: Box<_> = { box 100 }; assert_eq!(*x, 100); }"}, {"sha": "ff87595c934e9cca9375284d7df9bb88d4ab3168", "filename": "src/test/ui/expr-block.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-block.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,10 +1,7 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![allow(dead_code)]\n \n-\n-\n-\n // Tests for standalone blocks as expressions\n \n fn test_basic() { let rs: bool = { true }; assert!((rs)); }"}, {"sha": "253cbfd5d38fa12f6926da761a2c5019aa8462e3", "filename": "src/test/ui/expr-fn.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fexpr-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexpr-fn.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n \n fn test_int() {\n     fn f() -> isize { 10 }"}, {"sha": "1877414f09942f99d75f2ea9e488175b7f176f25", "filename": "src/test/ui/functions-closures/closure-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n \n fn foo(i: isize) -> isize { i + 1 }\n "}, {"sha": "4ce132e86caa4c89e5c2dadc7a513ba97585f499", "filename": "src/test/ui/functions-closures/closure-inference2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffunctions-closures%2Fclosure-inference2.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,6 +1,6 @@\n // run-pass\n // Test a rather underspecified example:\n-\n+#![allow(unused_braces)]\n \n pub fn main() {\n     let f = {|i| i};"}, {"sha": "9804c421db081cec72c5def5ef4305a808d921da", "filename": "src/test/ui/intrinsics/intrinsic-move-val-cleanups.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val-cleanups.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val-cleanups.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fintrinsics%2Fintrinsic-move-val-cleanups.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n #![allow(unused_unsafe)]\n #![allow(unreachable_code)]\n // ignore-emscripten no threads support"}, {"sha": "3de365675ad2214279537a8bcadd2e15dd588ec8", "filename": "src/test/ui/issues/issue-23898.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fissues%2Fissue-23898.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fissues%2Fissue-23898.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23898.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_parens)]\n #![allow(non_camel_case_types)]\n \n // Note: This test was used to demonstrate #5873 (now #23898)."}, {"sha": "1f426b7185e8f250c41a55f78c0124e1e6784495", "filename": "src/test/ui/issues/issue-28777.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fissues%2Fissue-28777.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fissues%2Fissue-28777.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28777.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n fn main() {\n     let v1 = { 1 + {2} * {3} };\n     let v2 =   1 + {2} * {3}  ;"}, {"sha": "623cd04d9bce35ddb1a65209554ef1c3ee0648a8", "filename": "src/test/ui/lint/lint-unnecessary-parens.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -48,11 +48,11 @@ fn main() {\n     if (true) {} //~ ERROR unnecessary parentheses around `if` condition\n     while (true) {} //~ ERROR unnecessary parentheses around `while` condition\n     //~^ WARN denote infinite loops with\n-    match (true) { //~ ERROR unnecessary parentheses around `match` head expression\n+    match (true) { //~ ERROR unnecessary parentheses around `match` scrutinee expression\n         _ => {}\n     }\n-    if let 1 = (1) {} //~ ERROR unnecessary parentheses around `let` head expression\n-    while let 1 = (2) {} //~ ERROR unnecessary parentheses around `let` head expression\n+    if let 1 = (1) {} //~ ERROR unnecessary parentheses around `let` scrutinee expression\n+    while let 1 = (2) {} //~ ERROR unnecessary parentheses around `let` scrutinee expression\n     let v = X { y: false };\n     // struct lits needs parens, so these shouldn't warn.\n     if (v == X { y: true }) {}"}, {"sha": "15184ba36ae85b68887575223c2ea413753c4f2b", "filename": "src/test/ui/lint/lint-unnecessary-parens.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-unnecessary-parens.stderr?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -72,19 +72,19 @@ LL |     while (true) {}\n    |\n    = note: `#[warn(while_true)]` on by default\n \n-error: unnecessary parentheses around `match` head expression\n+error: unnecessary parentheses around `match` scrutinee expression\n   --> $DIR/lint-unnecessary-parens.rs:51:11\n    |\n LL |     match (true) {\n    |           ^^^^^^ help: remove these parentheses\n \n-error: unnecessary parentheses around `let` head expression\n+error: unnecessary parentheses around `let` scrutinee expression\n   --> $DIR/lint-unnecessary-parens.rs:54:16\n    |\n LL |     if let 1 = (1) {}\n    |                ^^^ help: remove these parentheses\n \n-error: unnecessary parentheses around `let` head expression\n+error: unnecessary parentheses around `let` scrutinee expression\n   --> $DIR/lint-unnecessary-parens.rs:55:19\n    |\n LL |     while let 1 = (2) {}"}, {"sha": "de456ee6c230cac9a7d4c9872ba1dbde8974386d", "filename": "src/test/ui/lint/unused_braces.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Funused_braces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Funused_braces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -0,0 +1,31 @@\n+// check-pass\n+#![warn(unused_braces, unused_parens)]\n+\n+fn main() {\n+    let _ = (7);\n+    //~^WARN unnecessary parentheses\n+\n+    let _ = { 7 };\n+    //~^ WARN unnecessary braces\n+\n+    if let 7 = { 7 } {\n+        //~^ WARN unnecessary braces\n+    }\n+\n+    let _: [u8; { 3 }];\n+    //~^ WARN unnecessary braces\n+\n+    // do not emit error for multiline blocks.\n+    let _ = {\n+        7\n+    };\n+\n+    // do not emit error for unsafe blocks.\n+    let _ = unsafe { 7 };\n+\n+    // do not emit error, as the `{` would then\n+    // be parsed as part of the `return`.\n+    if { return } {\n+\n+    }\n+}"}, {"sha": "72f425ffc3e01147e88c6cc2b1c529545ded8de2", "filename": "src/test/ui/lint/unused_braces.stderr", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Funused_braces.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Funused_braces.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_braces.stderr?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -0,0 +1,36 @@\n+warning: unnecessary parentheses around assigned value\n+  --> $DIR/unused_braces.rs:5:13\n+   |\n+LL |     let _ = (7);\n+   |             ^^^ help: remove these parentheses\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_braces.rs:2:24\n+   |\n+LL | #![warn(unused_braces, unused_parens)]\n+   |                        ^^^^^^^^^^^^^\n+\n+warning: unnecessary braces around assigned value\n+  --> $DIR/unused_braces.rs:8:13\n+   |\n+LL |     let _ = { 7 };\n+   |             ^^^^^ help: remove these braces\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_braces.rs:2:9\n+   |\n+LL | #![warn(unused_braces, unused_parens)]\n+   |         ^^^^^^^^^^^^^\n+\n+warning: unnecessary braces around `let` scrutinee expression\n+  --> $DIR/unused_braces.rs:11:16\n+   |\n+LL |     if let 7 = { 7 } {\n+   |                ^^^^^ help: remove these braces\n+\n+warning: unnecessary braces around const expression\n+  --> $DIR/unused_braces.rs:15:17\n+   |\n+LL |     let _: [u8; { 3 }];\n+   |                 ^^^^^ help: remove these braces\n+"}, {"sha": "98dbbecfedde61ffeaaf3c738aa6416af090e72c", "filename": "src/test/ui/lint/unused_parens_borrow.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -0,0 +1,22 @@\n+// check-pass\n+#![warn(unused_braces)]\n+\n+// changing `&{ expr }` to `&expr` changes the semantic of the program\n+// so we should not warn this case\n+\n+#[repr(packed)]\n+struct A {\n+    a: u8,\n+    b: u32,\n+}\n+\n+fn main() {\n+    let a = A {\n+        a: 42,\n+        b: 1729,\n+    };\n+\n+    let _ = &{ a.b };\n+    let _ = { a.b };\n+    //~^ WARN unnecessary braces\n+}"}, {"sha": "7e3839ae4e0142fa53807a2d808a1ca88e836c14", "filename": "src/test/ui/lint/unused_parens_borrow.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_borrow.stderr?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -0,0 +1,12 @@\n+warning: unnecessary braces around assigned value\n+  --> $DIR/unused_parens_borrow.rs:20:13\n+   |\n+LL |     let _ = { a.b };\n+   |             ^^^^^^^ help: remove these braces\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unused_parens_borrow.rs:2:9\n+   |\n+LL | #![warn(unused_braces)]\n+   |         ^^^^^^^^^^^^^\n+"}, {"sha": "5fb67fd7c95a3a99a8ff0cbbd4c7c9cbab1f4c97", "filename": "src/test/ui/lint/unused_parens_remove_json_suggestion.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused_parens_remove_json_suggestion.stderr?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -46,14 +46,14 @@ LL |     while(true && false) {\n    |          ^^^^^^^^^^^^^^^ help: remove these parentheses\n \n \"}\n-{\"message\":\"unnecessary parentheses around `for` head expression\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":987,\"byte_end\":995,\"line_start\":44,\"line_end\":44,\"column_start\":18,\"column_end\":26,\"is_primary\":true,\"text\":[{\"text\":\"        for _ in (0 .. 3){\n+{\"message\":\"unnecessary parentheses around `for` iterator expression\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":987,\"byte_end\":995,\"line_start\":44,\"line_end\":44,\"column_start\":18,\"column_end\":26,\"is_primary\":true,\"text\":[{\"text\":\"        for _ in (0 .. 3){\n   --> $DIR/unused_parens_remove_json_suggestion.rs:44:18\n    |\n LL |         for _ in (0 .. 3){\n    |                  ^^^^^^^^ help: remove these parentheses\n \n \"}\n-{\"message\":\"unnecessary parentheses around `for` head expression\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":1088,\"byte_end\":1096,\"line_start\":49,\"line_end\":49,\"column_start\":14,\"column_end\":22,\"is_primary\":true,\"text\":[{\"text\":\"    for _ in (0 .. 3) {\n+{\"message\":\"unnecessary parentheses around `for` iterator expression\",\"code\":{\"code\":\"unused_parens\",\"explanation\":null},\"level\":\"error\",\"spans\":[{\"file_name\":\"$DIR/unused_parens_remove_json_suggestion.rs\",\"byte_start\":1088,\"byte_end\":1096,\"line_start\":49,\"line_end\":49,\"column_start\":14,\"column_end\":22,\"is_primary\":true,\"text\":[{\"text\":\"    for _ in (0 .. 3) {\n   --> $DIR/unused_parens_remove_json_suggestion.rs:49:14\n    |\n LL |     for _ in (0 .. 3) {"}, {"sha": "9b6dd7db4beb38d7c1cc53f169c6a921c600fd47", "filename": "src/test/ui/parser/issue-70552-ascription-in-parens-after-call.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fparser%2Fissue-70552-ascription-in-parens-after-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fparser%2Fissue-70552-ascription-in-parens-after-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-70552-ascription-in-parens-after-call.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    expr as fun()(:); //~ ERROR expected expression\n+}"}, {"sha": "f03c92e1b1f1780ad0df1d786a72da325b9d8bcd", "filename": "src/test/ui/parser/issue-70552-ascription-in-parens-after-call.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fparser%2Fissue-70552-ascription-in-parens-after-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fparser%2Fissue-70552-ascription-in-parens-after-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fissue-70552-ascription-in-parens-after-call.stderr?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -0,0 +1,8 @@\n+error: expected expression, found `:`\n+  --> $DIR/issue-70552-ascription-in-parens-after-call.rs:2:19\n+   |\n+LL |     expr as fun()(:);\n+   |                   ^ expected expression\n+\n+error: aborting due to previous error\n+"}, {"sha": "f3f7508d12434870b3edd509c44dd0da1dc50828", "filename": "src/test/ui/range.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces)]\n #![allow(unused_comparisons)]\n #![allow(dead_code)]\n #![allow(unused_mut)]"}, {"sha": "540b35e0392de1ef5aad30813fc508b5805e6291", "filename": "src/test/ui/range_inclusive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Frange_inclusive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Frange_inclusive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frange_inclusive.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,7 +1,7 @@\n // run-pass\n // Test inclusive range syntax.\n-\n #![feature(range_is_empty)]\n+#![allow(unused_braces)]\n #![allow(unused_comparisons)]\n \n use std::ops::RangeToInclusive;"}, {"sha": "271ab72c74fc14bec2c953b83008fcab219c7eba", "filename": "src/test/ui/structs-enums/empty-tag.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fstructs-enums%2Fempty-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fstructs-enums%2Fempty-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs-enums%2Fempty-tag.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n #![allow(non_camel_case_types)]\n \n #[derive(Copy, Clone, Debug)]"}, {"sha": "7f3f86e4df009320ba1859edc9f973381e18c8f5", "filename": "src/test/ui/type-alias-impl-trait/assoc-type-const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fassoc-type-const.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -18,16 +18,16 @@ trait MyTrait<'a, const C: usize> {\n     const MY_CONST: usize;\n }\n \n-impl<'a, const C: usize> MyTrait<'a, { C }> for MyStruct<{ C }> {\n+impl<'a, const C: usize> MyTrait<'a, C> for MyStruct<C> {\n     type MyItem = u8;\n     const MY_CONST: usize = C;\n }\n \n-impl<'a, I, const C: usize> UnwrapItemsExt<'a, { C }> for I {\n-    type Iter = impl MyTrait<'a, { C }>;\n+impl<'a, I, const C: usize> UnwrapItemsExt<'a, C> for I {\n+    type Iter = impl MyTrait<'a, C>;\n \n     fn unwrap_items(self) -> Self::Iter {\n-        MyStruct::<{ C }> {}\n+        MyStruct::<C> {}\n     }\n }\n "}, {"sha": "24c2758a0a255520e58076bd29f841bebeee50b1", "filename": "src/test/ui/unsized-locals/unsized-exprs-rpass.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsized-locals%2Funsized-exprs-rpass.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-\n+#![allow(unused_braces, unused_parens)]\n #![feature(unsized_tuple_coercion, unsized_locals)]\n \n struct A<X: ?Sized>(X);\n@@ -30,7 +30,6 @@ fn main() {\n         *foo()\n     });\n     udrop::<[u8]>({*foo()});\n-    #[allow(unused_parens)]\n     udrop::<[u8]>((*foo()));\n     udrop::<[u8]>((*tfoo()).1);\n     *afoo() + 42;"}, {"sha": "d812bbd011e0e275c1e120cc2e51784bcdea63d6", "filename": "src/test/ui/weird-exprs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fweird-exprs.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -5,7 +5,7 @@\n #![allow(non_camel_case_types)]\n #![allow(dead_code)]\n #![allow(unreachable_code)]\n-#![allow(unused_parens)]\n+#![allow(unused_braces, unused_parens)]\n \n #![recursion_limit = \"256\"]\n "}, {"sha": "2208590f7d61bbf7d30f6cc8b41adce2769791fe", "filename": "src/test/ui/zero-sized/zero-sized-tuple-struct.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/58dd1ce8383aaebcad9b6027b89a316fd868b35c/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fzero-sized%2Fzero-sized-tuple-struct.rs?ref=58dd1ce8383aaebcad9b6027b89a316fd868b35c", "patch": "@@ -1,4 +1,5 @@\n // run-pass\n+#![allow(unused_braces)]\n #![allow(unused_assignments)]\n \n // Make sure that the constructor args are codegened for zero-sized tuple structs"}]}