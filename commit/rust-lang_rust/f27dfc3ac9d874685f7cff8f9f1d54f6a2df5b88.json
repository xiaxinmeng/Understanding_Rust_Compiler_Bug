{"sha": "f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyN2RmYzNhYzlkODc0Njg1ZjdjZmY4ZjlmMWQ1NGY2YTJkZjViODg=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-17T10:57:41Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2018-08-17T10:57:41Z"}, "message": "Make CodegenCx generic over Backend", "tree": {"sha": "b6c2f455f30c7071f4c0a379000195422fed48ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6c2f455f30c7071f4c0a379000195422fed48ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88", "html_url": "https://github.com/rust-lang/rust/commit/f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb89830f2132e6cdccf425867f2161d20b64a32e", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb89830f2132e6cdccf425867f2161d20b64a32e", "html_url": "https://github.com/rust-lang/rust/commit/eb89830f2132e6cdccf425867f2161d20b64a32e"}], "stats": {"total": 201, "additions": 83, "deletions": 118}, "files": [{"sha": "08c9d09b1f8eb729eb8f982fd46680fbe49b175b", "filename": "src/base.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88", "patch": "@@ -9,7 +9,7 @@ impl Drop for PrintOnPanic {\n     }\n }\n \n-pub fn trans_mono_item<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx>, mono_item: MonoItem<'tcx>) {\n+pub fn trans_mono_item<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx, impl Backend>, mono_item: MonoItem<'tcx>) {\n     let tcx = cx.tcx;\n     let context = &mut cx.context;\n \n@@ -26,10 +26,7 @@ pub fn trans_mono_item<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx>, mono_item: Mo\n                 ::std::fs::write(mir_file_name, mir.into_inner()).unwrap();\n                 let _print_guard = PrintOnPanic(format!(\"{:?}\", inst));\n \n-                let res = each_module!(cx, |(ccx, m)| trans_fn(tcx, *m, ccx, context, inst));\n-                if let Some(func_id) = res.jit {\n-                    cx.defined_functions.push(func_id);\n-                };\n+                trans_fn(tcx, cx.module, &mut cx.ccx, context, inst);\n             }\n             Instance {\n                 def: InstanceDef::DropGlue(_, _),\n@@ -38,9 +35,7 @@ pub fn trans_mono_item<'a, 'tcx: 'a>(cx: &mut CodegenCx<'a, 'tcx>, mono_item: Mo\n             inst => unimpl!(\"Unimplemented instance {:?}\", inst),\n         },\n         MonoItem::Static(def_id) => {\n-            each_module!(cx, |(ccx, _m)| {\n-                crate::constant::codegen_static(ccx, def_id);\n-            });\n+            crate::constant::codegen_static(&mut cx.ccx, def_id);\n         }\n         MonoItem::GlobalAsm(node_id) => cx\n             .tcx\n@@ -55,7 +50,7 @@ fn trans_fn<'a, 'tcx: 'a>(\n     constants: &mut crate::constant::ConstantCx,\n     context: &mut Context,\n     instance: Instance<'tcx>,\n-) -> FuncId {\n+) {\n     // Step 1. Get mir\n     let mir = tcx.optimized_mir(instance.def_id());\n \n@@ -119,8 +114,6 @@ fn trans_fn<'a, 'tcx: 'a>(\n         module.define_function(func_id, context).unwrap();\n         context.clear();\n     }\n-\n-    func_id\n }\n \n fn verify_func(tcx: TyCtxt, writer: crate::pretty_clif::CommentWriter, func: &Function) {"}, {"sha": "bcf76d1657453fba8e20b86a7a8bbd994058fcb5", "filename": "src/lib.rs", "status": "modified", "additions": 79, "deletions": 107, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=f27dfc3ac9d874685f7cff8f9f1d54f6a2df5b88", "patch": "@@ -46,15 +46,6 @@ macro_rules! unimpl {\n     };\n }\n \n-macro_rules! each_module {\n-    ($cx:expr, |$p:pat| $res:expr) => {\n-        ModuleTup {\n-            jit: $cx.jit.as_mut().map(|$p| $res),\n-            faerie: $cx.faerie.as_mut().map(|$p| $res),\n-        }\n-    };\n-}\n-\n mod abi;\n mod analyze;\n mod base;\n@@ -77,7 +68,7 @@ mod prelude {\n         self, subst::Substs, FnSig, Instance, InstanceDef, ParamEnv, PolyFnSig, Ty, TyCtxt,\n         TypeAndMut, TypeFoldable, TypeVariants,\n     };\n-    pub use rustc_data_structures::{fx::FxHashMap, indexed_vec::Idx, sync::Lrc};\n+    pub use rustc_data_structures::{fx::{FxHashSet, FxHashMap}, indexed_vec::Idx, sync::Lrc};\n     pub use rustc_mir::monomorphize::{collector, MonoItem};\n     pub use syntax::ast::{FloatTy, IntTy, UintTy};\n     pub use syntax::codemap::DUMMY_SP;\n@@ -108,11 +99,10 @@ mod prelude {\n use crate::constant::ConstantCx;\n use crate::prelude::*;\n \n-pub struct CodegenCx<'a, 'tcx: 'a> {\n+pub struct CodegenCx<'a, 'tcx: 'a, B: Backend + 'static> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub jit: Option<(ConstantCx, &'a mut Module<SimpleJITBackend>)>,\n-    pub faerie: Option<(ConstantCx, &'a mut Module<FaerieBackend>)>,\n-    pub defined_functions: Vec<FuncId>,\n+    pub module: &'a mut Module<B>,\n+    pub ccx: ConstantCx,\n \n     // Cache\n     pub context: Context,\n@@ -223,88 +213,23 @@ impl CodegenBackend for CraneliftCodegenBackend {\n         let isa = cranelift::codegen::isa::lookup(target_lexicon::Triple::host())\n             .unwrap()\n             .finish(flags);\n-        let (mut jit_module, mut faerie_module): (\n-            Option<Module<SimpleJITBackend>>,\n-            Option<Module<FaerieBackend>>,\n-        ) = if std::env::var(\"SHOULD_RUN\").is_ok() {\n-            (Some(Module::new(SimpleJITBuilder::new())), None)\n-        } else {\n-            (\n-                None,\n-                Some(Module::new(\n-                    FaerieBuilder::new(\n-                        isa,\n-                        \"some_file.o\".to_string(),\n-                        FaerieTrapCollection::Disabled,\n-                        FaerieBuilder::default_libcall_names(),\n-                    ).unwrap(),\n-                )),\n-            )\n-        };\n \n-        let defined_functions = {\n-            use std::io::Write;\n-            let mut cx = CodegenCx {\n-                tcx,\n-                jit: jit_module.as_mut().map(|m| (ConstantCx::default(), m)),\n-                faerie: faerie_module.as_mut().map(|m| (ConstantCx::default(), m)),\n-                defined_functions: Vec::new(),\n-\n-                context: Context::new(),\n-            };\n-\n-            let mut log = ::std::fs::File::create(\"target/out/log.txt\").unwrap();\n-\n-            let before = ::std::time::Instant::now();\n-            let mono_items =\n-                collector::collect_crate_mono_items(tcx, collector::MonoItemCollectionMode::Eager)\n-                    .0;\n-\n-            // TODO: move to the end of this function when compiling libcore doesn't have unimplemented stuff anymore\n-            save_incremental(tcx);\n-            tcx.sess.warn(\"Saved incremental data\");\n-\n-            for mono_item in mono_items {\n-                let cx = &mut cx;\n-                let res = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(move || {\n-                    base::trans_mono_item(cx, mono_item);\n-                }));\n-                if let Err(err) = res {\n-                    match err.downcast::<NonFatal>() {\n-                        Ok(non_fatal) => {\n-                            writeln!(log, \"{}\", &non_fatal.0);\n-                            tcx.sess.err(&non_fatal.0)\n-                        }\n-                        Err(err) => ::std::panic::resume_unwind(err),\n-                    }\n-                }\n-            }\n-\n-            match cx {\n-                CodegenCx {\n-                    tcx,\n-                    jit,\n-                    faerie,\n-                    defined_functions: _,\n-                    context: _,\n-                } => {\n-                    jit.map(|jit| jit.0.finalize(tcx, jit.1));\n-                    faerie.map(|faerie| faerie.0.finalize(tcx, faerie.1));\n-                }\n-            }\n-\n-            let after = ::std::time::Instant::now();\n-            println!(\"time: {:?}\", after - before);\n+        let mono_items =\n+            collector::collect_crate_mono_items(tcx, collector::MonoItemCollectionMode::Eager)\n+                .0;\n+        \n+        // TODO: move to the end of this function when compiling libcore doesn't have unimplemented stuff anymore\n+        save_incremental(tcx);\n+        tcx.sess.warn(\"Saved incremental data\");\n \n-            cx.defined_functions\n-        };\n+        if std::env::var(\"SHOULD_RUN\").is_ok() {\n+            let mut jit_module: Module<SimpleJITBackend> = Module::new(SimpleJITBuilder::new());\n \n-        tcx.sess.abort_if_errors();\n+            codegen_mono_items(tcx, &mut jit_module, &mono_items);\n \n-        tcx.sess.warn(\"Compiled everything\");\n+            tcx.sess.abort_if_errors();\n+            tcx.sess.warn(\"Compiled everything\");\n \n-        // TODO: this doesn't work most of the time\n-        if let Some(mut jit_module) = jit_module {\n             tcx.sess.warn(\"Rustc codegen cranelift will JIT run the executable, because the SHOULD_RUN env var is set\");\n             let start_wrapper = tcx.lang_items().start_fn().expect(\"no start lang item\");\n \n@@ -314,33 +239,43 @@ impl CodegenBackend for CraneliftCodegenBackend {\n                 .declare_function(&name, Linkage::Import, &sig)\n                 .unwrap();\n \n-            for func_id in defined_functions {\n-                if func_id != called_func_id {\n-                    jit_module.finalize_function(func_id);\n-                }\n-            }\n+            let finalized_function: *const u8 = jit_module.finalize_function(called_func_id);\n+            jit_module.finalize_all();\n             tcx.sess.warn(\"Finalized everything\");\n \n-            let finalized_function: *const u8 = jit_module.finalize_function(called_func_id);\n             let f: extern \"C\" fn(*const u8, isize, *const *const u8) -> isize =\n                 unsafe { ::std::mem::transmute(finalized_function) };\n             let res = f(0 as *const u8, 0, 0 as *const _);\n             tcx.sess.warn(&format!(\"main returned {}\", res));\n \n             jit_module.finish();\n             ::std::process::exit(0);\n-        } else if should_codegen(tcx.sess) {\n-            faerie_module.as_mut().map(|m| m.finalize_all());\n+        } else {\n+            let mut faerie_module: Module<FaerieBackend> = Module::new(\n+                    FaerieBuilder::new(\n+                        isa,\n+                        \"some_file.o\".to_string(),\n+                        FaerieTrapCollection::Disabled,\n+                        FaerieBuilder::default_libcall_names(),\n+                    ).unwrap());\n+            \n+            codegen_mono_items(tcx, &mut faerie_module, &mono_items);\n \n-            tcx.sess.warn(\"Finalized everything\");\n-        }\n+            tcx.sess.abort_if_errors();\n+            tcx.sess.warn(\"Compiled everything\");\n+\n+            if should_codegen(tcx.sess) {\n+                faerie_module.finalize_all();\n+                tcx.sess.warn(\"Finalized everything\");\n+            }\n \n-        Box::new(OngoingCodegen {\n-            product: faerie_module.unwrap().finish(),\n-            metadata: metadata.raw_data,\n-            crate_name: tcx.crate_name(LOCAL_CRATE),\n-            crate_hash: tcx.crate_hash(LOCAL_CRATE),\n-        })\n+            return Box::new(OngoingCodegen {\n+                product: faerie_module.finish(),\n+                metadata: metadata.raw_data,\n+                crate_name: tcx.crate_name(LOCAL_CRATE),\n+                crate_hash: tcx.crate_hash(LOCAL_CRATE),\n+            });\n+        }\n     }\n \n     fn join_codegen_and_link(\n@@ -405,6 +340,43 @@ impl CodegenBackend for CraneliftCodegenBackend {\n     }\n }\n \n+fn codegen_mono_items<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>, module: &mut Module<impl Backend + 'static>, mono_items: &FxHashSet<MonoItem<'tcx>>) {\n+    use std::io::Write;\n+\n+    let mut cx = CodegenCx {\n+        tcx,\n+        module,\n+        ccx: ConstantCx::default(),\n+\n+        context: Context::new(),\n+    };\n+\n+    let mut log = ::std::fs::File::create(\"target/out/log.txt\").unwrap();\n+\n+    let before = ::std::time::Instant::now();\n+\n+    for mono_item in mono_items {\n+        let cx = &mut cx;\n+        let res = ::std::panic::catch_unwind(::std::panic::AssertUnwindSafe(move || {\n+            base::trans_mono_item(cx, *mono_item);\n+        }));\n+        if let Err(err) = res {\n+            match err.downcast::<NonFatal>() {\n+                Ok(non_fatal) => {\n+                    writeln!(log, \"{}\", &non_fatal.0);\n+                    tcx.sess.err(&non_fatal.0)\n+                }\n+                Err(err) => ::std::panic::resume_unwind(err),\n+            }\n+        }\n+    }\n+\n+    cx.ccx.finalize(tcx, cx.module);\n+\n+    let after = ::std::time::Instant::now();\n+    println!(\"time: {:?}\", after - before);\n+}\n+\n fn save_incremental<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     rustc_incremental::assert_dep_graph(tcx);\n     rustc_incremental::save_dep_graph(tcx);"}]}