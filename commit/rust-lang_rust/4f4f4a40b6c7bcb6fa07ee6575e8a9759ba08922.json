{"sha": "4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNGY0YTQwYjZjN2JjYjZmYTA3ZWU2NTc1ZThhOTc1OWJhMDg5MjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-03T18:40:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-02-03T18:40:23Z"}, "message": "Auto merge of #58081 - Centril:liballoc-2018, r=oli-obk\n\nTransition liballoc to Rust 2018\n\nThis transitions liballoc to Rust 2018 edition and applies relevant idiom lints.\nI also did a small bit of drive-by cleanup along the way.\n\nr? @oli-obk\n\nI started with liballoc since it seemed easiest. In particular, adding `edition = \"2018\"` to libcore gave me way too many errors due to stdsimd. Ideally we should be able to continue this crate-by-crate until all crates use 2018.", "tree": {"sha": "28a3d197b75da9125cc8f6de8d912f75c56e7e48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28a3d197b75da9125cc8f6de8d912f75c56e7e48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "html_url": "https://github.com/rust-lang/rust/commit/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e858c2637fa5bac40ac450628b30c56c2b4327b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e858c2637fa5bac40ac450628b30c56c2b4327b4", "html_url": "https://github.com/rust-lang/rust/commit/e858c2637fa5bac40ac450628b30c56c2b4327b4"}, {"sha": "2396780cdaedf097dd6a8f3927749bcaf5b1238b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2396780cdaedf097dd6a8f3927749bcaf5b1238b", "html_url": "https://github.com/rust-lang/rust/commit/2396780cdaedf097dd6a8f3927749bcaf5b1238b"}], "stats": {"total": 753, "additions": 360, "deletions": 393}, "files": [{"sha": "f6d6c1de8f511cf1d6aa319aeed494279820c58e", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -4,6 +4,7 @@ name = \"alloc\"\n version = \"0.0.0\"\n autotests = false\n autobenches = false\n+edition = \"2018\"\n \n [lib]\n name = \"alloc\""}, {"sha": "ec652df3b37a49829a1f2972a7f3b99ef82e0a3d", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -227,9 +227,9 @@ pub fn handle_alloc_error(layout: Layout) -> ! {\n #[cfg(test)]\n mod tests {\n     extern crate test;\n-    use self::test::Bencher;\n-    use boxed::Box;\n-    use alloc::{Global, Alloc, Layout, handle_alloc_error};\n+    use test::Bencher;\n+    use crate::boxed::Box;\n+    use crate::alloc::{Global, Alloc, Layout, handle_alloc_error};\n \n     #[test]\n     fn allocate_zeroed() {"}, {"sha": "4c17bdc3e9e9d00dfa8d102a21172d20b719abaa", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -1,6 +1,7 @@\n use std::iter::Iterator;\n use std::vec::Vec;\n use std::collections::BTreeMap;\n+\n use rand::{Rng, seq::SliceRandom, thread_rng};\n use test::{Bencher, black_box};\n "}, {"sha": "f17fb8212ce193f744b19afe9f64f39a32719844", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -1,8 +1,6 @@\n-use rand::{thread_rng};\n-use std::mem;\n-use std::ptr;\n+use std::{mem, ptr};\n \n-use rand::{Rng, SeedableRng};\n+use rand::{thread_rng, Rng, SeedableRng};\n use rand::distributions::{Standard, Alphanumeric};\n use rand_xorshift::XorShiftRng;\n use test::{Bencher, black_box};"}, {"sha": "270f48e80835ab92e93a1ed2da2d42ed6f0184a6", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -6,14 +6,14 @@ use core::cmp::Ordering;\n use core::hash::{Hash, Hasher};\n use core::ops::{Add, AddAssign, Deref};\n \n-use fmt;\n-use string::String;\n-\n-use self::Cow::*;\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::borrow::{Borrow, BorrowMut};\n \n+use crate::fmt;\n+use crate::string::String;\n+\n+use Cow::*;\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B>\n     where B: ToOwned,\n@@ -182,9 +182,7 @@ pub enum Cow<'a, B: ?Sized + 'a>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Clone for Cow<'a, B>\n-    where B: ToOwned\n-{\n+impl<'a, B: ?Sized + ToOwned> Clone for Cow<'a, B> {\n     fn clone(&self) -> Cow<'a, B> {\n         match *self {\n             Borrowed(b) => Borrowed(b),\n@@ -207,9 +205,7 @@ impl<'a, B: ?Sized> Clone for Cow<'a, B>\n     }\n }\n \n-impl<'a, B: ?Sized> Cow<'a, B>\n-    where B: ToOwned\n-{\n+impl<B: ?Sized + ToOwned> Cow<'_, B> {\n     /// Acquires a mutable reference to the owned form of the data.\n     ///\n     /// Clones the data if it is not already owned.\n@@ -285,9 +281,7 @@ impl<'a, B: ?Sized> Cow<'a, B>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Deref for Cow<'a, B>\n-    where B: ToOwned\n-{\n+impl<B: ?Sized + ToOwned> Deref for Cow<'_, B> {\n     type Target = B;\n \n     fn deref(&self) -> &B {\n@@ -299,7 +293,7 @@ impl<'a, B: ?Sized> Deref for Cow<'a, B>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> Eq for Cow<'a, B> where B: Eq + ToOwned {}\n+impl<B: ?Sized> Eq for Cow<'_, B> where B: Eq + ToOwned {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, B: ?Sized> Ord for Cow<'a, B>\n@@ -333,11 +327,11 @@ impl<'a, B: ?Sized> PartialOrd for Cow<'a, B>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B>\n+impl<B: ?Sized> fmt::Debug for Cow<'_, B>\n     where B: fmt::Debug + ToOwned,\n           <B as ToOwned>::Owned: fmt::Debug\n {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             Borrowed(ref b) => fmt::Debug::fmt(b, f),\n             Owned(ref o) => fmt::Debug::fmt(o, f),\n@@ -346,11 +340,11 @@ impl<'a, B: ?Sized> fmt::Debug for Cow<'a, B>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, B: ?Sized> fmt::Display for Cow<'a, B>\n+impl<B: ?Sized> fmt::Display for Cow<'_, B>\n     where B: fmt::Display + ToOwned,\n           <B as ToOwned>::Owned: fmt::Display\n {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             Borrowed(ref b) => fmt::Display::fmt(b, f),\n             Owned(ref o) => fmt::Display::fmt(o, f),\n@@ -380,7 +374,7 @@ impl<'a, B: ?Sized> Hash for Cow<'a, B>\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: ?Sized + ToOwned> AsRef<T> for Cow<'a, T> {\n+impl<T: ?Sized + ToOwned> AsRef<T> for Cow<'_, T> {\n     fn as_ref(&self) -> &T {\n         self\n     }"}, {"sha": "8e01e12e0b8def3106d164e2faa2f8233eaf0e49", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -73,9 +73,9 @@ use core::ops::{\n use core::ptr::{self, NonNull, Unique};\n use core::task::{LocalWaker, Poll};\n \n-use vec::Vec;\n-use raw_vec::RawVec;\n-use str::from_boxed_utf8_unchecked;\n+use crate::vec::Vec;\n+use crate::raw_vec::RawVec;\n+use crate::str::from_boxed_utf8_unchecked;\n \n /// A pointer type for heap allocation.\n ///\n@@ -603,21 +603,21 @@ impl Box<dyn Any + Send> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Display + ?Sized> fmt::Display for Box<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug + ?Sized> fmt::Debug for Box<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Box<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         // It's not possible to extract the inner Uniq directly from the Box,\n         // instead we cast it to a *const which aliases the Unique\n         let ptr: *const T = &**self;\n@@ -737,7 +737,7 @@ impl<A, F> FnBox<A> for F\n \n #[unstable(feature = \"fnbox\",\n            reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + 'a> {\n+impl<A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + '_> {\n     type Output = R;\n \n     extern \"rust-call\" fn call_once(self, args: A) -> R {\n@@ -747,7 +747,7 @@ impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + 'a> {\n \n #[unstable(feature = \"fnbox\",\n            reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-impl<'a, A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + Send + 'a> {\n+impl<A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + Send + '_> {\n     type Output = R;\n \n     extern \"rust-call\" fn call_once(self, args: A) -> R {"}, {"sha": "f97522140a8a1deb8d1b3c0e25889db1dcbee1a9", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -151,8 +151,8 @@ use core::mem::{swap, size_of, ManuallyDrop};\n use core::ptr;\n use core::fmt;\n \n-use slice;\n-use vec::{self, Vec};\n+use crate::slice;\n+use crate::vec::{self, Vec};\n \n use super::SpecExtend;\n \n@@ -227,16 +227,16 @@ pub struct PeekMut<'a, T: 'a + Ord> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: Ord + fmt::Debug> fmt::Debug for PeekMut<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: Ord + fmt::Debug> fmt::Debug for PeekMut<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"PeekMut\")\n          .field(&self.heap.data[0])\n          .finish()\n     }\n }\n \n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n-impl<'a, T: Ord> Drop for PeekMut<'a, T> {\n+impl<T: Ord> Drop for PeekMut<'_, T> {\n     fn drop(&mut self) {\n         if self.sift {\n             self.heap.sift_down(0);\n@@ -245,15 +245,15 @@ impl<'a, T: Ord> Drop for PeekMut<'a, T> {\n }\n \n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n-impl<'a, T: Ord> Deref for PeekMut<'a, T> {\n+impl<T: Ord> Deref for PeekMut<'_, T> {\n     type Target = T;\n     fn deref(&self) -> &T {\n         &self.heap.data[0]\n     }\n }\n \n #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n-impl<'a, T: Ord> DerefMut for PeekMut<'a, T> {\n+impl<T: Ord> DerefMut for PeekMut<'_, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         &mut self.heap.data[0]\n     }\n@@ -291,7 +291,7 @@ impl<T: Ord> Default for BinaryHeap<T> {\n \n #[stable(feature = \"binaryheap_debug\", since = \"1.4.0\")]\n impl<T: fmt::Debug + Ord> fmt::Debug for BinaryHeap<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.iter()).finish()\n     }\n }\n@@ -349,7 +349,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<T> {\n+    pub fn iter(&self) -> Iter<'_, T> {\n         Iter { iter: self.data.iter() }\n     }\n \n@@ -400,7 +400,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.peek(), Some(&2));\n     /// ```\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n-    pub fn peek_mut(&mut self) -> Option<PeekMut<T>> {\n+    pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n         if self.is_empty() {\n             None\n         } else {\n@@ -761,7 +761,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain(&mut self) -> Drain<T> {\n+    pub fn drain(&mut self) -> Drain<'_, T> {\n         Drain { iter: self.data.drain(..) }\n     }\n \n@@ -908,7 +908,7 @@ impl<'a, T> Hole<'a, T> {\n     }\n }\n \n-impl<'a, T> Drop for Hole<'a, T> {\n+impl<T> Drop for Hole<'_, T> {\n     #[inline]\n     fn drop(&mut self) {\n         // fill the hole again\n@@ -932,8 +932,8 @@ pub struct Iter<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Iter\")\n          .field(&self.iter.as_slice())\n          .finish()\n@@ -972,14 +972,14 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n+impl<T> ExactSizeIterator for Iter<'_, T> {\n     fn is_empty(&self) -> bool {\n         self.iter.is_empty()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T> FusedIterator for Iter<'a, T> {}\n+impl<T> FusedIterator for Iter<'_, T> {}\n \n /// An owning iterator over the elements of a `BinaryHeap`.\n ///\n@@ -996,7 +996,7 @@ pub struct IntoIter<T> {\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\")\n          .field(&self.iter.as_slice())\n          .finish()\n@@ -1050,7 +1050,7 @@ pub struct Drain<'a, T: 'a> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T: 'a> Iterator for Drain<'a, T> {\n+impl<T> Iterator for Drain<'_, T> {\n     type Item = T;\n \n     #[inline]\n@@ -1065,22 +1065,22 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n+impl<T> DoubleEndedIterator for Drain<'_, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back()\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {\n+impl<T> ExactSizeIterator for Drain<'_, T> {\n     fn is_empty(&self) -> bool {\n         self.iter.is_empty()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T: 'a> FusedIterator for Drain<'a, T> {}\n+impl<T> FusedIterator for Drain<'_, T> {}\n \n #[stable(feature = \"binary_heap_extras_15\", since = \"1.5.0\")]\n impl<T: Ord> From<Vec<T>> for BinaryHeap<T> {"}, {"sha": "aaaa419dcb849027a951483391664bd827be6417", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 44, "deletions": 50, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -1,23 +1,18 @@\n+use core::borrow::Borrow;\n use core::cmp::Ordering;\n use core::fmt::Debug;\n use core::hash::{Hash, Hasher};\n use core::iter::{FromIterator, Peekable, FusedIterator};\n use core::marker::PhantomData;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::Index;\n-use core::ops::RangeBounds;\n+use core::ops::{Index, RangeBounds};\n use core::{fmt, intrinsics, mem, ptr};\n \n-use borrow::Borrow;\n+use super::node::{self, Handle, NodeRef, marker, InsertResult::*, ForceResult::*};\n+use super::search::{self, SearchResult::*};\n \n-use super::node::{self, Handle, NodeRef, marker};\n-use super::search;\n-\n-use super::node::InsertResult::*;\n-use super::node::ForceResult::*;\n-use super::search::SearchResult::*;\n-use self::UnderflowResult::*;\n-use self::Entry::*;\n+use UnderflowResult::*;\n+use Entry::*;\n \n /// A map based on a B-Tree.\n ///\n@@ -248,7 +243,7 @@ impl<K, Q: ?Sized> super::Recover<Q> for BTreeMap<K, ()>\n \n     fn replace(&mut self, key: K) -> Option<K> {\n         self.ensure_root_is_owned();\n-        match search::search_tree::<marker::Mut, K, (), K>(self.root.as_mut(), &key) {\n+        match search::search_tree::<marker::Mut<'_>, K, (), K>(self.root.as_mut(), &key) {\n             Found(handle) => Some(mem::replace(handle.into_kv_mut().0, key)),\n             GoDown(handle) => {\n                 VacantEntry {\n@@ -278,8 +273,8 @@ pub struct Iter<'a, K: 'a, V: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, K: 'a + fmt::Debug, V: 'a + fmt::Debug> fmt::Debug for Iter<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Iter<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.clone()).finish()\n     }\n }\n@@ -314,7 +309,7 @@ pub struct IntoIter<K, V> {\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let range = Range {\n             front: self.front.reborrow(),\n             back: self.back.reborrow(),\n@@ -336,8 +331,8 @@ pub struct Keys<'a, K: 'a, V: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, K: 'a + fmt::Debug, V: 'a> fmt::Debug for Keys<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<K: fmt::Debug, V> fmt::Debug for Keys<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.clone()).finish()\n     }\n }\n@@ -355,8 +350,8 @@ pub struct Values<'a, K: 'a, V: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, K: 'a, V: 'a + fmt::Debug> fmt::Debug for Values<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<K, V: fmt::Debug> fmt::Debug for Values<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.clone()).finish()\n     }\n }\n@@ -388,8 +383,8 @@ pub struct Range<'a, K: 'a, V: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, K: 'a + fmt::Debug, V: 'a + fmt::Debug> fmt::Debug for Range<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for Range<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self.clone()).finish()\n     }\n }\n@@ -411,8 +406,8 @@ pub struct RangeMut<'a, K: 'a, V: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, K: 'a + fmt::Debug, V: 'a + fmt::Debug> fmt::Debug for RangeMut<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for RangeMut<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let range = Range {\n             front: self.front.reborrow(),\n             back: self.back.reborrow(),\n@@ -441,8 +436,8 @@ pub enum Entry<'a, K: 'a, V: 'a> {\n }\n \n #[stable(feature= \"debug_btree_map\", since = \"1.12.0\")]\n-impl<'a, K: 'a + Debug + Ord, V: 'a + Debug> Debug for Entry<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<K: Debug + Ord, V: Debug> Debug for Entry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n             Vacant(ref v) => f.debug_tuple(\"Entry\")\n                               .field(v)\n@@ -469,8 +464,8 @@ pub struct VacantEntry<'a, K: 'a, V: 'a> {\n }\n \n #[stable(feature= \"debug_btree_map\", since = \"1.12.0\")]\n-impl<'a, K: 'a + Debug + Ord, V: 'a> Debug for VacantEntry<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<K: Debug + Ord, V> Debug for VacantEntry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"VacantEntry\")\n          .field(self.key())\n          .finish()\n@@ -492,8 +487,8 @@ pub struct OccupiedEntry<'a, K: 'a, V: 'a> {\n }\n \n #[stable(feature= \"debug_btree_map\", since = \"1.12.0\")]\n-impl<'a, K: 'a + Debug + Ord, V: 'a + Debug> Debug for OccupiedEntry<'a, K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<K: Debug + Ord, V: Debug> Debug for OccupiedEntry<'_, K, V> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"OccupiedEntry\")\n          .field(\"key\", self.key())\n          .field(\"value\", self.get())\n@@ -817,7 +812,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(Some((&5, &\"b\")), map.range(4..).next());\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n-    pub fn range<T: ?Sized, R>(&self, range: R) -> Range<K, V>\n+    pub fn range<T: ?Sized, R>(&self, range: R) -> Range<'_, K, V>\n         where T: Ord, K: Borrow<T>, R: RangeBounds<T>\n     {\n         let root1 = self.root.as_ref();\n@@ -858,7 +853,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// }\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n-    pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<K, V>\n+    pub fn range_mut<T: ?Sized, R>(&mut self, range: R) -> RangeMut<'_, K, V>\n         where T: Ord, K: Borrow<T>, R: RangeBounds<T>\n     {\n         let root1 = self.root.as_mut();\n@@ -891,7 +886,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     /// assert_eq!(count[\"a\"], 3);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn entry(&mut self, key: K) -> Entry<K, V> {\n+    pub fn entry(&mut self, key: K) -> Entry<'_, K, V> {\n         // FIXME(@porglezomp) Avoid allocating if we don't insert\n         self.ensure_root_is_owned();\n         match search::search_tree(self.root.as_mut(), &key) {\n@@ -1201,7 +1196,7 @@ impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, K, V> FusedIterator for Iter<'a, K, V> {}\n+impl<K, V> FusedIterator for Iter<'_, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K: 'a, V: 'a> DoubleEndedIterator for Iter<'a, K, V> {\n@@ -1216,7 +1211,7 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for Iter<'a, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K: 'a, V: 'a> ExactSizeIterator for Iter<'a, K, V> {\n+impl<K, V> ExactSizeIterator for Iter<'_, K, V> {\n     fn len(&self) -> usize {\n         self.length\n     }\n@@ -1273,14 +1268,14 @@ impl<'a, K: 'a, V: 'a> DoubleEndedIterator for IterMut<'a, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K: 'a, V: 'a> ExactSizeIterator for IterMut<'a, K, V> {\n+impl<K, V> ExactSizeIterator for IterMut<'_, K, V> {\n     fn len(&self) -> usize {\n         self.length\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, K, V> FusedIterator for IterMut<'a, K, V> {}\n+impl<K, V> FusedIterator for IterMut<'_, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> IntoIterator for BTreeMap<K, V> {\n@@ -1436,14 +1431,14 @@ impl<'a, K, V> DoubleEndedIterator for Keys<'a, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Keys<'a, K, V> {\n+impl<K, V> ExactSizeIterator for Keys<'_, K, V> {\n     fn len(&self) -> usize {\n         self.inner.len()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, K, V> FusedIterator for Keys<'a, K, V> {}\n+impl<K, V> FusedIterator for Keys<'_, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Keys<'a, K, V> {\n@@ -1473,14 +1468,14 @@ impl<'a, K, V> DoubleEndedIterator for Values<'a, K, V> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K, V> ExactSizeIterator for Values<'a, K, V> {\n+impl<K, V> ExactSizeIterator for Values<'_, K, V> {\n     fn len(&self) -> usize {\n         self.inner.len()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, K, V> FusedIterator for Values<'a, K, V> {}\n+impl<K, V> FusedIterator for Values<'_, K, V> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, K, V> Clone for Values<'a, K, V> {\n@@ -1523,15 +1518,14 @@ impl<'a, K, V> DoubleEndedIterator for ValuesMut<'a, K, V> {\n }\n \n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n-impl<'a, K, V> ExactSizeIterator for ValuesMut<'a, K, V> {\n+impl<K, V> ExactSizeIterator for ValuesMut<'_, K, V> {\n     fn len(&self) -> usize {\n         self.inner.len()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, K, V> FusedIterator for ValuesMut<'a, K, V> {}\n-\n+impl<K, V> FusedIterator for ValuesMut<'_, K, V> {}\n \n impl<'a, K, V> Range<'a, K, V> {\n     unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n@@ -1609,7 +1603,7 @@ impl<'a, K, V> Range<'a, K, V> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, K, V> FusedIterator for Range<'a, K, V> {}\n+impl<K, V> FusedIterator for Range<'_, K, V> {}\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n impl<'a, K, V> Clone for Range<'a, K, V> {\n@@ -1678,7 +1672,7 @@ impl<'a, K, V> DoubleEndedIterator for RangeMut<'a, K, V> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, K, V> FusedIterator for RangeMut<'a, K, V> {}\n+impl<K, V> FusedIterator for RangeMut<'_, K, V> {}\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n     unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a mut V) {\n@@ -1783,13 +1777,13 @@ impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_map().entries(self.iter()).finish()\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, K: Ord, Q: ?Sized, V> Index<&'a Q> for BTreeMap<K, V>\n+impl<K: Ord, Q: ?Sized, V> Index<&Q> for BTreeMap<K, V>\n     where K: Borrow<Q>,\n           Q: Ord\n {\n@@ -1940,7 +1934,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!((*first_key, *first_value), (1, \"a\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<K, V> {\n+    pub fn iter(&self) -> Iter<'_, K, V> {\n         Iter {\n             range: Range {\n                 front: first_leaf_edge(self.root.as_ref()),\n@@ -1972,7 +1966,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// }\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter_mut(&mut self) -> IterMut<K, V> {\n+    pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n         let root1 = self.root.as_mut();\n         let root2 = unsafe { ptr::read(&root1) };\n         IterMut {\n@@ -2049,7 +2043,7 @@ impl<K, V> BTreeMap<K, V> {\n     ///                     String::from(\"goodbye!\")]);\n     /// ```\n     #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n-    pub fn values_mut(&mut self) -> ValuesMut<K, V> {\n+    pub fn values_mut(&mut self) -> ValuesMut<'_, K, V> {\n         ValuesMut { inner: self.iter_mut() }\n     }\n "}, {"sha": "c4f39430533dca46f547089831eadc67adf18f14", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -36,8 +36,8 @@ use core::mem::{self, MaybeUninit};\n use core::ptr::{self, Unique, NonNull};\n use core::slice;\n \n-use alloc::{Global, Alloc, Layout};\n-use boxed::Box;\n+use crate::alloc::{Global, Alloc, Layout};\n+use crate::boxed::Box;\n \n const B: usize = 6;\n pub const MIN_LEN: usize = B - 1;\n@@ -226,7 +226,7 @@ impl<K, V> Root<K, V> {\n     }\n \n     pub fn as_ref(&self)\n-            -> NodeRef<marker::Immut, K, V, marker::LeafOrInternal> {\n+            -> NodeRef<marker::Immut<'_>, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n@@ -236,7 +236,7 @@ impl<K, V> Root<K, V> {\n     }\n \n     pub fn as_mut(&mut self)\n-            -> NodeRef<marker::Mut, K, V, marker::LeafOrInternal> {\n+            -> NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal> {\n         NodeRef {\n             height: self.height,\n             node: self.node.as_ptr(),\n@@ -258,7 +258,7 @@ impl<K, V> Root<K, V> {\n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n     pub fn push_level(&mut self)\n-            -> NodeRef<marker::Mut, K, V, marker::Internal> {\n+            -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].set(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n@@ -531,7 +531,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// Unsafely asserts to the compiler some static information about whether this\n     /// node is a `Leaf`.\n     unsafe fn cast_unchecked<NewType>(&mut self)\n-            -> NodeRef<marker::Mut, K, V, NewType> {\n+            -> NodeRef<marker::Mut<'_>, K, V, NewType> {\n \n         NodeRef {\n             height: self.height,\n@@ -551,7 +551,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// of a reborrowed handle, out of bounds.\n     // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n     // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n-    unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut, K, V, Type> {\n+    unsafe fn reborrow_mut(&mut self) -> NodeRef<marker::Mut<'_>, K, V, Type> {\n         NodeRef {\n             height: self.height,\n             node: self.node,\n@@ -928,7 +928,7 @@ impl<BorrowType, K, V, NodeType, HandleType>\n \n     /// Temporarily takes out another, immutable handle on the same location.\n     pub fn reborrow(&self)\n-            -> Handle<NodeRef<marker::Immut, K, V, NodeType>, HandleType> {\n+            -> Handle<NodeRef<marker::Immut<'_>, K, V, NodeType>, HandleType> {\n \n         // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n         Handle {\n@@ -953,7 +953,7 @@ impl<'a, K, V, NodeType, HandleType>\n     // FIXME(@gereeter) consider adding yet another type parameter to `NodeRef` that restricts\n     // the use of `ascend` and `into_root_mut` on reborrowed pointers, preventing this unsafety.\n     pub unsafe fn reborrow_mut(&mut self)\n-            -> Handle<NodeRef<marker::Mut, K, V, NodeType>, HandleType> {\n+            -> Handle<NodeRef<marker::Mut<'_>, K, V, NodeType>, HandleType> {\n \n         // We can't use Handle::new_kv or Handle::new_edge because we don't know our type\n         Handle {\n@@ -1068,7 +1068,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n     /// Unsafely asserts to the compiler some static information about whether the underlying\n     /// node of this handle is a `Leaf`.\n     unsafe fn cast_unchecked<NewType>(&mut self)\n-            -> Handle<NodeRef<marker::Mut, K, V, NewType>, marker::Edge> {\n+            -> Handle<NodeRef<marker::Mut<'_>, K, V, NewType>, marker::Edge> {\n \n         Handle::new_edge(self.node.cast_unchecked(), self.idx)\n     }\n@@ -1558,8 +1558,8 @@ unsafe fn move_kv<K, V>(\n \n // Source and destination must have the same height.\n unsafe fn move_edges<K, V>(\n-    mut source: NodeRef<marker::Mut, K, V, marker::Internal>, source_offset: usize,\n-    mut dest: NodeRef<marker::Mut, K, V, marker::Internal>, dest_offset: usize,\n+    mut source: NodeRef<marker::Mut<'_>, K, V, marker::Internal>, source_offset: usize,\n+    mut dest: NodeRef<marker::Mut<'_>, K, V, marker::Internal>, dest_offset: usize,\n     count: usize)\n {\n     let source_ptr = source.as_internal_mut().edges.as_mut_ptr();"}, {"sha": "dfb67d2ea575612e9276134f790e61fd8222bfd0", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -1,11 +1,9 @@\n+use core::borrow::Borrow;\n use core::cmp::Ordering;\n \n-use borrow::Borrow;\n+use super::node::{Handle, NodeRef, marker, ForceResult::*};\n \n-use super::node::{Handle, NodeRef, marker};\n-\n-use super::node::ForceResult::*;\n-use self::SearchResult::*;\n+use SearchResult::*;\n \n pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     Found(Handle<NodeRef<BorrowType, K, V, FoundType>, marker::KV>),"}, {"sha": "78cd21dd4118d4cfd62db5ba4507b29774f87048", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -1,15 +1,14 @@\n // This is pretty much entirely stolen from TreeSet, since BTreeMap has an identical interface\n // to TreeMap\n \n+use core::borrow::Borrow;\n use core::cmp::Ordering::{self, Less, Greater, Equal};\n use core::cmp::{min, max};\n-use core::fmt::Debug;\n-use core::fmt;\n+use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n \n-use borrow::Borrow;\n-use collections::btree_map::{self, BTreeMap, Keys};\n+use crate::collections::btree_map::{self, BTreeMap, Keys};\n use super::Recover;\n \n // FIXME(conventions): implement bounded iterators\n@@ -76,8 +75,8 @@ pub struct Iter<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Iter\")\n          .field(&self.iter.clone())\n          .finish()\n@@ -124,8 +123,8 @@ pub struct Difference<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for Difference<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Difference\")\n          .field(&self.a)\n          .field(&self.b)\n@@ -147,8 +146,8 @@ pub struct SymmetricDifference<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for SymmetricDifference<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"SymmetricDifference\")\n          .field(&self.a)\n          .field(&self.b)\n@@ -170,8 +169,8 @@ pub struct Intersection<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for Intersection<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Intersection\")\n          .field(&self.a)\n          .field(&self.b)\n@@ -193,8 +192,8 @@ pub struct Union<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for Union<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Union\")\n          .field(&self.a)\n          .field(&self.b)\n@@ -241,7 +240,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// assert_eq!(Some(&5), set.range(4..).next());\n     /// ```\n     #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n-    pub fn range<K: ?Sized, R>(&self, range: R) -> Range<T>\n+    pub fn range<K: ?Sized, R>(&self, range: R) -> Range<'_, T>\n         where K: Ord, T: Borrow<K>, R: RangeBounds<K>\n     {\n         Range { iter: self.map.range(range) }\n@@ -703,7 +702,7 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(set_iter.next(), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<T> {\n+    pub fn iter(&self) -> Iter<'_, T> {\n         Iter { iter: self.map.keys() }\n     }\n \n@@ -809,7 +808,7 @@ impl<T: Ord> Default for BTreeSet<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n+impl<T: Ord + Clone> Sub<&BTreeSet<T>> for &BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n     /// Returns the difference of `self` and `rhs` as a new `BTreeSet<T>`.\n@@ -832,7 +831,7 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n+impl<T: Ord + Clone> BitXor<&BTreeSet<T>> for &BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n     /// Returns the symmetric difference of `self` and `rhs` as a new `BTreeSet<T>`.\n@@ -855,7 +854,7 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n+impl<T: Ord + Clone> BitAnd<&BTreeSet<T>> for &BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n     /// Returns the intersection of `self` and `rhs` as a new `BTreeSet<T>`.\n@@ -878,7 +877,7 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n+impl<T: Ord + Clone> BitOr<&BTreeSet<T>> for &BTreeSet<T> {\n     type Output = BTreeSet<T>;\n \n     /// Returns the union of `self` and `rhs` as a new `BTreeSet<T>`.\n@@ -902,7 +901,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for BTreeSet<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_set().entries(self.iter()).finish()\n     }\n }\n@@ -931,12 +930,12 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n+impl<T> ExactSizeIterator for Iter<'_, T> {\n     fn len(&self) -> usize { self.iter.len() }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T> FusedIterator for Iter<'a, T> {}\n+impl<T> FusedIterator for Iter<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Iterator for IntoIter<T> {\n@@ -987,7 +986,7 @@ impl<'a, T> DoubleEndedIterator for Range<'a, T> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T> FusedIterator for Range<'a, T> {}\n+impl<T> FusedIterator for Range<'_, T> {}\n \n /// Compare `x` and `y`, but return `short` if x is None and `long` if y is None\n fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering) -> Ordering {\n@@ -1034,7 +1033,7 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T: Ord> FusedIterator for Difference<'a, T> {}\n+impl<T: Ord> FusedIterator for Difference<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for SymmetricDifference<'a, T> {\n@@ -1068,7 +1067,7 @@ impl<'a, T: Ord> Iterator for SymmetricDifference<'a, T> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T: Ord> FusedIterator for SymmetricDifference<'a, T> {}\n+impl<T: Ord> FusedIterator for SymmetricDifference<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Intersection<'a, T> {\n@@ -1106,7 +1105,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T: Ord> FusedIterator for Intersection<'a, T> {}\n+impl<T: Ord> FusedIterator for Intersection<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Clone for Union<'a, T> {\n@@ -1140,4 +1139,4 @@ impl<'a, T: Ord> Iterator for Union<'a, T> {\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T: Ord> FusedIterator for Union<'a, T> {}\n+impl<T: Ord> FusedIterator for Union<'_, T> {}"}, {"sha": "afd8078cdd7537bcdac5bf3af0a316ef854259aa", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -20,7 +20,7 @@ use core::marker::PhantomData;\n use core::mem;\n use core::ptr::NonNull;\n \n-use boxed::Box;\n+use crate::boxed::Box;\n use super::SpecExtend;\n \n /// A doubly-linked list with owned nodes.\n@@ -61,8 +61,8 @@ pub struct Iter<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Iter\")\n          .field(&self.len)\n          .finish()\n@@ -71,7 +71,7 @@ impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Clone for Iter<'a, T> {\n+impl<T> Clone for Iter<'_, T> {\n     fn clone(&self) -> Self {\n         Iter { ..*self }\n     }\n@@ -93,8 +93,8 @@ pub struct IterMut<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"IterMut\")\n          .field(&self.list)\n          .field(&self.len)\n@@ -117,7 +117,7 @@ pub struct IntoIter<T> {\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\")\n          .field(&self.list)\n          .finish()\n@@ -331,7 +331,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<T> {\n+    pub fn iter(&self) -> Iter<'_, T> {\n         Iter {\n             head: self.head,\n             tail: self.tail,\n@@ -365,7 +365,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter_mut(&mut self) -> IterMut<T> {\n+    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n         IterMut {\n             head: self.head,\n             tail: self.tail,\n@@ -764,7 +764,7 @@ impl<T> LinkedList<T> {\n     /// assert_eq!(odds.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 9, 11, 13, 15]);\n     /// ```\n     #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n+    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F>\n         where F: FnMut(&mut T) -> bool\n     {\n         // avoid borrow issues.\n@@ -832,10 +832,10 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Iter<'a, T> {}\n+impl<T> ExactSizeIterator for Iter<'_, T> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T> FusedIterator for Iter<'a, T> {}\n+impl<T> FusedIterator for Iter<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> Iterator for IterMut<'a, T> {\n@@ -881,12 +881,12 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for IterMut<'a, T> {}\n+impl<T> ExactSizeIterator for IterMut<'_, T> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T> FusedIterator for IterMut<'a, T> {}\n+impl<T> FusedIterator for IterMut<'_, T> {}\n \n-impl<'a, T> IterMut<'a, T> {\n+impl<T> IterMut<'_, T> {\n     /// Inserts the given element just after the element most recently returned by `.next()`.\n     /// The inserted element does not appear in the iteration.\n     ///\n@@ -982,7 +982,7 @@ pub struct DrainFilter<'a, T: 'a, F: 'a>\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n+impl<T, F> Iterator for DrainFilter<'_, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     type Item = T;\n@@ -1009,7 +1009,7 @@ impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<'a, T, F> Drop for DrainFilter<'a, T, F>\n+impl<T, F> Drop for DrainFilter<'_, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {\n@@ -1018,10 +1018,10 @@ impl<'a, T, F> Drop for DrainFilter<'a, T, F>\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<'a, T: 'a + fmt::Debug, F> fmt::Debug for DrainFilter<'a, T, F>\n+impl<T: fmt::Debug, F> fmt::Debug for DrainFilter<'_, T, F>\n     where F: FnMut(&mut T) -> bool\n {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"DrainFilter\")\n          .field(&self.list)\n          .finish()\n@@ -1164,7 +1164,7 @@ impl<T: Clone> Clone for LinkedList<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for LinkedList<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self).finish()\n     }\n }"}, {"sha": "5a33ddc14f004fed0e4a20436715bc401b6f7df1", "filename": "src/liballoc/collections/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fmod.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -23,25 +23,25 @@ pub mod btree_set {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use self::binary_heap::BinaryHeap;\n+pub use binary_heap::BinaryHeap;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use self::btree_map::BTreeMap;\n+pub use btree_map::BTreeMap;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use self::btree_set::BTreeSet;\n+pub use btree_set::BTreeSet;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use self::linked_list::LinkedList;\n+pub use linked_list::LinkedList;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[doc(no_inline)]\n-pub use self::vec_deque::VecDeque;\n+pub use vec_deque::VecDeque;\n \n-use alloc::{AllocErr, LayoutErr};\n+use crate::alloc::{AllocErr, LayoutErr};\n \n /// Augments `AllocErr` with a CapacityOverflow variant.\n #[derive(Clone, PartialEq, Eq, Debug)]"}, {"sha": "99fa54acb08367fe32c97cf12fa3374ce893da2f", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 38, "deletions": 41, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -7,22 +7,19 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-use core::cmp::Ordering;\n+use core::cmp::{self, Ordering};\n use core::fmt;\n use core::iter::{repeat_with, FromIterator, FusedIterator};\n use core::mem;\n use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{Index, IndexMut, RangeBounds, Try};\n-use core::ptr;\n-use core::ptr::NonNull;\n+use core::ptr::{self, NonNull};\n use core::slice;\n-\n use core::hash::{Hash, Hasher};\n-use core::cmp;\n \n-use collections::CollectionAllocErr;\n-use raw_vec::RawVec;\n-use vec::Vec;\n+use crate::collections::CollectionAllocErr;\n+use crate::raw_vec::RawVec;\n+use crate::vec::Vec;\n \n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n@@ -798,7 +795,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(&c[..], b);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter(&self) -> Iter<T> {\n+    pub fn iter(&self) -> Iter<'_, T> {\n         Iter {\n             tail: self.tail,\n             head: self.head,\n@@ -824,7 +821,7 @@ impl<T> VecDeque<T> {\n     /// assert_eq!(&buf.iter_mut().collect::<Vec<&mut i32>>()[..], b);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn iter_mut(&mut self) -> IterMut<T> {\n+    pub fn iter_mut(&mut self) -> IterMut<'_, T> {\n         IterMut {\n             tail: self.tail,\n             head: self.head,\n@@ -958,7 +955,7 @@ impl<T> VecDeque<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain<T>\n+    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n         where R: RangeBounds<usize>\n     {\n         // Memory safety\n@@ -2083,7 +2080,7 @@ trait RingSlices: Sized {\n     }\n }\n \n-impl<'a, T> RingSlices for &'a [T] {\n+impl<T> RingSlices for &[T] {\n     fn slice(self, from: usize, to: usize) -> Self {\n         &self[from..to]\n     }\n@@ -2092,7 +2089,7 @@ impl<'a, T> RingSlices for &'a [T] {\n     }\n }\n \n-impl<'a, T> RingSlices for &'a mut [T] {\n+impl<T> RingSlices for &mut [T] {\n     fn slice(self, from: usize, to: usize) -> Self {\n         &mut self[from..to]\n     }\n@@ -2123,8 +2120,8 @@ pub struct Iter<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for Iter<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: fmt::Debug> fmt::Debug for Iter<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let (front, back) = RingSlices::ring_slices(self.ring, self.head, self.tail);\n         f.debug_tuple(\"Iter\")\n             .field(&front)\n@@ -2203,14 +2200,14 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for Iter<'a, T> {\n+impl<T> ExactSizeIterator for Iter<'_, T> {\n     fn is_empty(&self) -> bool {\n         self.head == self.tail\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T> FusedIterator for Iter<'a, T> {}\n+impl<T> FusedIterator for Iter<'_, T> {}\n \n \n /// A mutable iterator over the elements of a `VecDeque`.\n@@ -2228,8 +2225,8 @@ pub struct IterMut<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for IterMut<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<'a, T: fmt::Debug> fmt::Debug for IterMut<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         let (front, back) = RingSlices::ring_slices(&*self.ring, self.head, self.tail);\n         f.debug_tuple(\"IterMut\")\n             .field(&front)\n@@ -2296,14 +2293,14 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> ExactSizeIterator for IterMut<'a, T> {\n+impl<T> ExactSizeIterator for IterMut<'_, T> {\n     fn is_empty(&self) -> bool {\n         self.head == self.tail\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T> FusedIterator for IterMut<'a, T> {}\n+impl<T> FusedIterator for IterMut<'_, T> {}\n \n /// An owning iterator over the elements of a `VecDeque`.\n ///\n@@ -2320,7 +2317,7 @@ pub struct IntoIter<T> {\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\")\n          .field(&self.inner)\n          .finish()\n@@ -2377,8 +2374,8 @@ pub struct Drain<'a, T: 'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a, T: 'a + fmt::Debug> fmt::Debug for Drain<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl<T: fmt::Debug> fmt::Debug for Drain<'_, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Drain\")\n          .field(&self.after_tail)\n          .field(&self.after_head)\n@@ -2388,12 +2385,12 @@ impl<'a, T: 'a + fmt::Debug> fmt::Debug for Drain<'a, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}\n+unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<'a, T: Send> Send for Drain<'a, T> {}\n+unsafe impl<T: Send> Send for Drain<'_, T> {}\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T: 'a> Drop for Drain<'a, T> {\n+impl<T> Drop for Drain<'_, T> {\n     fn drop(&mut self) {\n         self.for_each(drop);\n \n@@ -2440,7 +2437,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T: 'a> Iterator for Drain<'a, T> {\n+impl<T> Iterator for Drain<'_, T> {\n     type Item = T;\n \n     #[inline]\n@@ -2455,18 +2452,18 @@ impl<'a, T: 'a> Iterator for Drain<'a, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T: 'a> DoubleEndedIterator for Drain<'a, T> {\n+impl<T> DoubleEndedIterator for Drain<'_, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back().map(|elt| unsafe { ptr::read(elt) })\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T: 'a> ExactSizeIterator for Drain<'a, T> {}\n+impl<T> ExactSizeIterator for Drain<'_, T> {}\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T: 'a> FusedIterator for Drain<'a, T> {}\n+impl<T> FusedIterator for Drain<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialEq> PartialEq for VecDeque<A> {\n@@ -2516,7 +2513,7 @@ macro_rules! __impl_slice_eq1 {\n     };\n     ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n         #[stable(feature = \"vec_deque_partial_eq_slice\", since = \"1.17.0\")]\n-        impl<'a, 'b, A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n+        impl<A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n             fn eq(&self, other: &$Rhs) -> bool {\n                 if self.len() != other.len() {\n                     return false;\n@@ -2530,15 +2527,15 @@ macro_rules! __impl_slice_eq1 {\n }\n \n __impl_slice_eq1! { VecDeque<A>, Vec<B> }\n-__impl_slice_eq1! { VecDeque<A>, &'b [B] }\n-__impl_slice_eq1! { VecDeque<A>, &'b mut [B] }\n+__impl_slice_eq1! { VecDeque<A>, &[B] }\n+__impl_slice_eq1! { VecDeque<A>, &mut [B] }\n \n macro_rules! array_impls {\n     ($($N: expr)+) => {\n         $(\n             __impl_slice_eq1! { VecDeque<A>, [B; $N] }\n-            __impl_slice_eq1! { VecDeque<A>, &'b [B; $N] }\n-            __impl_slice_eq1! { VecDeque<A>, &'b mut [B; $N] }\n+            __impl_slice_eq1! { VecDeque<A>, &[B; $N] }\n+            __impl_slice_eq1! { VecDeque<A>, &mut [B; $N] }\n         )+\n     }\n }\n@@ -2654,7 +2651,7 @@ impl<'a, T: 'a + Copy> Extend<&'a T> for VecDeque<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_list().entries(self).finish()\n     }\n }\n@@ -2758,7 +2755,7 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n \n #[cfg(test)]\n mod tests {\n-    use test;\n+    use ::test;\n \n     use super::VecDeque;\n \n@@ -3036,7 +3033,7 @@ mod tests {\n \n     #[test]\n     fn test_from_vec() {\n-        use vec::Vec;\n+        use crate::vec::Vec;\n         for cap in 0..35 {\n             for len in 0..=cap {\n                 let mut vec = Vec::with_capacity(cap);\n@@ -3052,7 +3049,7 @@ mod tests {\n \n     #[test]\n     fn test_vec_from_vecdeque() {\n-        use vec::Vec;\n+        use crate::vec::Vec;\n \n         fn create_vec_and_test_convert(cap: usize, offset: usize, len: usize) {\n             let mut vd = VecDeque::with_capacity(cap);\n@@ -3114,7 +3111,7 @@ mod tests {\n \n     #[test]\n     fn issue_53529() {\n-        use boxed::Box;\n+        use crate::boxed::Box;\n \n         let mut dst = VecDeque::new();\n         dst.push_front(Box::new(1));"}, {"sha": "9bda7034a621bb24a47c1e7a8896096517aee366", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -527,7 +527,7 @@ pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n #[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n pub use core::fmt::{Alignment};\n \n-use string;\n+use crate::string;\n \n /// The `format` function takes an [`Arguments`] struct and returns the resulting\n /// formatted string.\n@@ -557,7 +557,7 @@ use string;\n /// [`format_args!`]: ../../std/macro.format_args.html\n /// [`format!`]: ../../std/macro.format.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn format(args: Arguments) -> string::String {\n+pub fn format(args: Arguments<'_>) -> string::String {\n     let capacity = args.estimated_capacity();\n     let mut output = string::String::with_capacity(capacity);\n     output"}, {"sha": "80097a128a5f44fd5a6d910dfeaf3af27a317a78", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -63,6 +63,9 @@\n #![no_std]\n #![needs_allocator]\n \n+#![deny(rust_2018_idioms)]\n+#![allow(explicit_outlives_requirements)]\n+\n #![warn(deprecated_in_future)]\n #![warn(intra_doc_link_resolution_failure)]\n #![warn(missing_debug_implementations)]\n@@ -121,8 +124,6 @@\n extern crate std;\n #[cfg(test)]\n extern crate test;\n-#[cfg(test)]\n-extern crate rand;\n \n // Module with internal macros used by other modules (needs to be included before other modules).\n #[macro_use]\n@@ -164,5 +165,5 @@ pub mod vec;\n \n #[cfg(not(test))]\n mod std {\n-    pub use core::ops;      // RangeFull\n+    pub use core::ops; // RangeFull\n }"}, {"sha": "6767cf89f73ba2ce205cd784050eda5b9be72e5f", "filename": "src/liballoc/prelude.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -12,8 +12,8 @@\n \n #![unstable(feature = \"alloc\", issue = \"27783\")]\n \n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use borrow::ToOwned;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use boxed::Box;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use slice::SliceConcatExt;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use string::{String, ToString};\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use vec::Vec;\n+#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::borrow::ToOwned;\n+#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::boxed::Box;\n+#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::slice::SliceConcatExt;\n+#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::string::{String, ToString};\n+#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::vec::Vec;"}, {"sha": "dcecf9bc76d88d6c33d94c362b3a249ca3156118", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -7,10 +7,9 @@ use core::ops::Drop;\n use core::ptr::{self, NonNull, Unique};\n use core::slice;\n \n-use alloc::{Alloc, Layout, Global, handle_alloc_error};\n-use collections::CollectionAllocErr;\n-use collections::CollectionAllocErr::*;\n-use boxed::Box;\n+use crate::alloc::{Alloc, Layout, Global, handle_alloc_error};\n+use crate::collections::CollectionAllocErr::{self, *};\n+use crate::boxed::Box;\n \n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n@@ -621,14 +620,14 @@ enum Fallibility {\n     Infallible,\n }\n \n-use self::Fallibility::*;\n+use Fallibility::*;\n \n enum ReserveStrategy {\n     Exact,\n     Amortized,\n }\n \n-use self::ReserveStrategy::*;\n+use ReserveStrategy::*;\n \n impl<T, A: Alloc> RawVec<T, A> {\n     fn reserve_internal(\n@@ -639,7 +638,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n         strategy: ReserveStrategy,\n     ) -> Result<(), CollectionAllocErr> {\n         unsafe {\n-            use alloc::AllocErr;\n+            use crate::alloc::AllocErr;\n \n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n@@ -733,7 +732,7 @@ unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n-    if mem::size_of::<usize>() < 8 && alloc_size > ::core::isize::MAX as usize {\n+    if mem::size_of::<usize>() < 8 && alloc_size > core::isize::MAX as usize {\n         Err(CapacityOverflow)\n     } else {\n         Ok(())\n@@ -753,7 +752,7 @@ mod tests {\n \n     #[test]\n     fn allocator_param() {\n-        use alloc::AllocErr;\n+        use crate::alloc::AllocErr;\n \n         // Writing a test of integration between third-party\n         // allocators and RawVec is a little tricky because the RawVec"}, {"sha": "d78869270d563cb58d7496fffad6ffe9c75d8a36", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -227,7 +227,7 @@\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n #[cfg(not(test))]\n-use boxed::Box;\n+use crate::boxed::Box;\n #[cfg(test)]\n use std::boxed::Box;\n \n@@ -238,19 +238,18 @@ use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n-use core::marker;\n-use core::marker::{Unpin, Unsize, PhantomData};\n+use core::marker::{self, Unpin, Unsize, PhantomData};\n use core::mem::{self, align_of_val, forget, size_of_val};\n-use core::ops::{Deref, Receiver};\n-use core::ops::{CoerceUnsized, DispatchFromDyn};\n+use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n+use core::slice::from_raw_parts_mut;\n use core::convert::From;\n use core::usize;\n \n-use alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n-use string::String;\n-use vec::Vec;\n+use crate::alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n+use crate::string::String;\n+use crate::vec::Vec;\n \n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n@@ -766,8 +765,6 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n \n         impl<T> Drop for Guard<T> {\n             fn drop(&mut self) {\n-                use core::slice::from_raw_parts_mut;\n-\n                 unsafe {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n@@ -1121,21 +1118,21 @@ impl<T: ?Sized + Hash> Hash for Rc<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + fmt::Display> fmt::Display for Rc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + fmt::Debug> fmt::Debug for Rc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Rc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Pointer::fmt(&(&**self as *const T), f)\n     }\n }\n@@ -1459,7 +1456,7 @@ impl<T: ?Sized> Clone for Weak<T> {\n \n #[stable(feature = \"rc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }\n }\n@@ -1564,8 +1561,7 @@ mod tests {\n     use super::{Rc, Weak};\n     use std::boxed::Box;\n     use std::cell::RefCell;\n-    use std::option::Option;\n-    use std::option::Option::{None, Some};\n+    use std::option::Option::{self, None, Some};\n     use std::result::Result::{Err, Ok};\n     use std::mem::drop;\n     use std::clone::Clone;"}, {"sha": "479959deeb1a7b017d116f525c546a8f551b4e90", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -87,15 +87,15 @@\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n \n+use core::borrow::{Borrow, BorrowMut};\n use core::cmp::Ordering::{self, Less};\n-use core::mem::size_of;\n-use core::mem;\n+use core::mem::{self, size_of};\n use core::ptr;\n use core::{u8, u16, u32};\n \n-use borrow::{Borrow, BorrowMut, ToOwned};\n-use boxed::Box;\n-use vec::Vec;\n+use crate::borrow::ToOwned;\n+use crate::boxed::Box;\n+use crate::vec::Vec;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{Chunks, Windows};\n@@ -125,24 +125,24 @@ pub use core::slice::{RChunks, RChunksMut, RChunksExact, RChunksExactMut};\n // HACK(japaric) needed for the implementation of `vec!` macro during testing\n // NB see the hack module in this file for more details\n #[cfg(test)]\n-pub use self::hack::into_vec;\n+pub use hack::into_vec;\n \n // HACK(japaric) needed for the implementation of `Vec::clone` during testing\n // NB see the hack module in this file for more details\n #[cfg(test)]\n-pub use self::hack::to_vec;\n+pub use hack::to_vec;\n \n // HACK(japaric): With cfg(test) `impl [T]` is not available, these three\n // functions are actually methods that are in `impl [T]` but not in\n // `core::slice::SliceExt` - we need to supply these functions for the\n // `test_permutations` test\n mod hack {\n-    use boxed::Box;\n     use core::mem;\n \n+    use crate::boxed::Box;\n+    use crate::vec::Vec;\n     #[cfg(test)]\n-    use string::ToString;\n-    use vec::Vec;\n+    use crate::string::ToString;\n \n     pub fn into_vec<T>(mut b: Box<[T]>) -> Vec<T> {\n         unsafe {"}, {"sha": "1fd4c9978a6083d719a3639df5d7536885cb4d60", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -28,20 +28,20 @@\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![allow(unused_imports)]\n \n+use core::borrow::Borrow;\n use core::fmt;\n use core::str as core_str;\n-use core::str::pattern::Pattern;\n-use core::str::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n+use core::str::pattern::{Pattern, Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n use core::ptr;\n use core::iter::FusedIterator;\n use core::unicode::conversions;\n \n-use borrow::{Borrow, ToOwned};\n-use boxed::Box;\n-use slice::{SliceConcatExt, SliceIndex};\n-use string::String;\n-use vec::Vec;\n+use crate::borrow::ToOwned;\n+use crate::boxed::Box;\n+use crate::slice::{SliceConcatExt, SliceIndex};\n+use crate::string::String;\n+use crate::vec::Vec;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::str::{FromStr, Utf8Error};"}, {"sha": "73f67e98f364e6b92284aa023c0ea73eb5981647", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -50,17 +50,16 @@ use core::char::{decode_utf16, REPLACEMENT_CHARACTER};\n use core::fmt;\n use core::hash;\n use core::iter::{FromIterator, FusedIterator};\n-use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ops::{self, Add, AddAssign, Index, IndexMut, RangeBounds};\n+use core::ops::Bound::{Excluded, Included, Unbounded};\n use core::ptr;\n-use core::str::pattern::Pattern;\n-use core::str::lossy;\n+use core::str::{pattern::Pattern, lossy};\n \n-use collections::CollectionAllocErr;\n-use borrow::{Cow, ToOwned};\n-use boxed::Box;\n-use str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n-use vec::Vec;\n+use crate::borrow::{Cow, ToOwned};\n+use crate::collections::CollectionAllocErr;\n+use crate::boxed::Box;\n+use crate::str::{self, from_boxed_utf8_unchecked, FromStr, Utf8Error, Chars};\n+use crate::vec::Vec;\n \n /// A UTF-8 encoded, growable string.\n ///\n@@ -1485,7 +1484,7 @@ impl String {\n     /// assert_eq!(s, \"\");\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain\n+    pub fn drain<R>(&mut self, range: R) -> Drain<'_>\n         where R: RangeBounds<usize>\n     {\n         // Memory safety\n@@ -1669,14 +1668,14 @@ impl FromUtf8Error {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for FromUtf8Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&self.error, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for FromUtf16Error {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(\"invalid utf-16: lone surrogate found\", f)\n     }\n }\n@@ -1867,15 +1866,15 @@ impl Default for String {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for String {\n     #[inline]\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for String {\n     #[inline]\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n@@ -1926,7 +1925,7 @@ impl hash::Hash for String {\n /// let c = a.to_string() + b;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Add<&'a str> for String {\n+impl Add<&str> for String {\n     type Output = String;\n \n     #[inline]\n@@ -1940,7 +1939,7 @@ impl<'a> Add<&'a str> for String {\n ///\n /// This has the same behavior as the [`push_str`][String::push_str] method.\n #[stable(feature = \"stringaddassign\", since = \"1.12.0\")]\n-impl<'a> AddAssign<&'a str> for String {\n+impl AddAssign<&str> for String {\n     #[inline]\n     fn add_assign(&mut self, other: &str) {\n         self.push_str(other);\n@@ -2097,14 +2096,14 @@ impl Clone for ParseError {\n \n #[stable(feature = \"str_parse_error\", since = \"1.5.0\")]\n impl fmt::Debug for ParseError {\n-    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {}\n     }\n }\n \n #[stable(feature = \"str_parse_error2\", since = \"1.8.0\")]\n impl fmt::Display for ParseError {\n-    fn fmt(&self, _: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {}\n     }\n }\n@@ -2156,7 +2155,7 @@ pub trait ToString {\n impl<T: fmt::Display + ?Sized> ToString for T {\n     #[inline]\n     default fn to_string(&self) -> String {\n-        use core::fmt::Write;\n+        use fmt::Write;\n         let mut buf = String::new();\n         buf.write_fmt(format_args!(\"{}\", self))\n            .expect(\"a Display implementation returned an error unexpectedly\");\n@@ -2174,7 +2173,7 @@ impl ToString for str {\n }\n \n #[stable(feature = \"cow_str_to_string_specialization\", since = \"1.17.0\")]\n-impl<'a> ToString for Cow<'a, str> {\n+impl ToString for Cow<'_, str> {\n     #[inline]\n     fn to_string(&self) -> String {\n         self[..].to_owned()\n@@ -2364,19 +2363,19 @@ pub struct Drain<'a> {\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n-impl<'a> fmt::Debug for Drain<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+impl fmt::Debug for Drain<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.pad(\"Drain { .. }\")\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<'a> Sync for Drain<'a> {}\n+unsafe impl Sync for Drain<'_> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<'a> Send for Drain<'a> {}\n+unsafe impl Send for Drain<'_> {}\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a> Drop for Drain<'a> {\n+impl Drop for Drain<'_> {\n     fn drop(&mut self) {\n         unsafe {\n             // Use Vec::drain. \"Reaffirm\" the bounds checks to avoid\n@@ -2390,7 +2389,7 @@ impl<'a> Drop for Drain<'a> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a> Iterator for Drain<'a> {\n+impl Iterator for Drain<'_> {\n     type Item = char;\n \n     #[inline]\n@@ -2404,12 +2403,12 @@ impl<'a> Iterator for Drain<'a> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a> DoubleEndedIterator for Drain<'a> {\n+impl DoubleEndedIterator for Drain<'_> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n         self.iter.next_back()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a> FusedIterator for Drain<'a> {}\n+impl FusedIterator for Drain<'_> {}"}, {"sha": "5bdb3616ed232a53ab3075cf1df85a4dceb93482", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -14,20 +14,20 @@ use core::fmt;\n use core::cmp::{self, Ordering};\n use core::intrinsics::abort;\n use core::mem::{self, align_of_val, size_of_val};\n-use core::ops::{Deref, Receiver};\n-use core::ops::{CoerceUnsized, DispatchFromDyn};\n+use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n use core::marker::{Unpin, Unsize, PhantomData};\n use core::hash::{Hash, Hasher};\n use core::{isize, usize};\n use core::convert::From;\n+use core::slice::from_raw_parts_mut;\n \n-use alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n-use boxed::Box;\n-use rc::is_dangling;\n-use string::String;\n-use vec::Vec;\n+use crate::alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n+use crate::boxed::Box;\n+use crate::rc::is_dangling;\n+use crate::string::String;\n+use crate::vec::Vec;\n \n /// A soft limit on the amount of references that may be made to an `Arc`.\n ///\n@@ -251,7 +251,7 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Weak<U>> for Weak<T> {}\n \n #[stable(feature = \"arc_weak\", since = \"1.4.0\")]\n impl<T: ?Sized + fmt::Debug> fmt::Debug for Weak<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"(Weak)\")\n     }\n }\n@@ -672,8 +672,6 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n \n         impl<T> Drop for Guard<T> {\n             fn drop(&mut self) {\n-                use core::slice::from_raw_parts_mut;\n-\n                 unsafe {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n@@ -1550,21 +1548,21 @@ impl<T: ?Sized + Eq> Eq for Arc<T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + fmt::Display> fmt::Display for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Display::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Arc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Pointer::fmt(&(&**self as *const T), f)\n     }\n }\n@@ -1601,15 +1599,15 @@ impl<T> From<T> for Arc<T> {\n }\n \n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl<'a, T: Clone> From<&'a [T]> for Arc<[T]> {\n+impl<T: Clone> From<&[T]> for Arc<[T]> {\n     #[inline]\n     fn from(v: &[T]) -> Arc<[T]> {\n         <Self as ArcFromSlice<T>>::from_slice(v)\n     }\n }\n \n #[stable(feature = \"shared_from_slice\", since = \"1.21.0\")]\n-impl<'a> From<&'a str> for Arc<str> {\n+impl From<&str> for Arc<str> {\n     #[inline]\n     fn from(v: &str) -> Arc<str> {\n         let arc = Arc::<[u8]>::from(v.as_bytes());\n@@ -1655,16 +1653,14 @@ mod tests {\n     use std::sync::mpsc::channel;\n     use std::mem::drop;\n     use std::ops::Drop;\n-    use std::option::Option;\n-    use std::option::Option::{None, Some};\n-    use std::sync::atomic;\n-    use std::sync::atomic::Ordering::{Acquire, SeqCst};\n+    use std::option::Option::{self, None, Some};\n+    use std::sync::atomic::{self, Ordering::{Acquire, SeqCst}};\n     use std::thread;\n     use std::sync::Mutex;\n     use std::convert::From;\n \n     use super::{Arc, Weak};\n-    use vec::Vec;\n+    use crate::vec::Vec;\n \n     struct Canary(*mut atomic::AtomicUsize);\n "}, {"sha": "2261dabe2779af4b35d35107db0db391023b879d", "filename": "src/liballoc/task.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -3,15 +3,15 @@\n pub use core::task::*;\n \n #[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n-pub use self::if_arc::*;\n+pub use if_arc::*;\n \n #[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n mod if_arc {\n     use super::*;\n     use core::marker::PhantomData;\n     use core::mem;\n     use core::ptr::{self, NonNull};\n-    use sync::Arc;\n+    use crate::sync::Arc;\n \n     /// A way of waking up a specific task.\n     ///"}, {"sha": "aaf504073285dd187e1b9488306cdb5c059af7dd", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -2,8 +2,8 @@ use std::collections::BTreeMap;\n use std::collections::btree_map::Entry::{Occupied, Vacant};\n use std::ops::Bound::{self, Excluded, Included, Unbounded};\n use std::rc::Rc;\n-\n use std::iter::FromIterator;\n+\n use super::DeterministicRng;\n \n #[test]\n@@ -199,7 +199,7 @@ fn test_range_inclusive() {\n \n #[test]\n fn test_range_inclusive_max_value() {\n-    let max = ::std::usize::MAX;\n+    let max = std::usize::MAX;\n     let map: BTreeMap<_, _> = vec![(max, 0)].into_iter().collect();\n \n     assert_eq!(map.range(max..=max).collect::<Vec<_>>(), &[(&max, &0)]);"}, {"sha": "4f5168f1ce5723659d7a60857b3b621e30862145", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -1,6 +1,6 @@\n use std::collections::BTreeSet;\n-\n use std::iter::FromIterator;\n+\n use super::DeterministicRng;\n \n #[test]\n@@ -15,6 +15,8 @@ fn test_clone_eq() {\n \n #[test]\n fn test_hash() {\n+    use crate::hash;\n+\n     let mut x = BTreeSet::new();\n     let mut y = BTreeSet::new();\n \n@@ -26,7 +28,7 @@ fn test_hash() {\n     y.insert(2);\n     y.insert(1);\n \n-    assert!(::hash(&x) == ::hash(&y));\n+    assert!(hash(&x) == hash(&y));\n }\n \n fn check<F>(a: &[i32], b: &[i32], expected: &[i32], f: F)"}, {"sha": "0fbfbdccd453717e67844d6223693ff6d1ecd254", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -241,10 +241,12 @@ fn test_eq() {\n \n #[test]\n fn test_hash() {\n+    use crate::hash;\n+\n     let mut x = LinkedList::new();\n     let mut y = LinkedList::new();\n \n-    assert!(::hash(&x) == ::hash(&y));\n+    assert!(hash(&x) == hash(&y));\n \n     x.push_back(1);\n     x.push_back(2);\n@@ -254,7 +256,7 @@ fn test_hash() {\n     y.push_front(2);\n     y.push_front(1);\n \n-    assert!(::hash(&x) == ::hash(&y));\n+    assert!(hash(&x) == hash(&y));\n }\n \n #[test]"}, {"sha": "334466dfb25f5017ac52ce427a3510afffd3304e", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -1,14 +1,13 @@\n use std::cell::Cell;\n-use std::cmp::Ordering::{Equal, Greater, Less};\n-use std::cmp::Ordering;\n+use std::cmp::Ordering::{self, Equal, Greater, Less};\n use std::mem;\n use std::panic;\n use std::rc::Rc;\n-use std::sync::atomic::Ordering::Relaxed;\n-use std::sync::atomic::AtomicUsize;\n+use std::sync::atomic::{Ordering::Relaxed, AtomicUsize};\n use std::thread;\n \n-use rand::{Rng, RngCore, thread_rng, seq::SliceRandom};\n+use rand::{Rng, RngCore, thread_rng};\n+use rand::seq::SliceRandom;\n use rand::distributions::Standard;\n \n fn square(n: usize) -> usize {\n@@ -476,7 +475,7 @@ fn test_sort_stability() {\n             // the second item represents which occurrence of that\n             // number this element is, i.e., the second elements\n             // will occur in sorted order.\n-            let mut orig: Vec<_> = (0..len)\n+            let orig: Vec<_> = (0..len)\n                 .map(|_| {\n                     let n = thread_rng().gen::<usize>() % 10;\n                     counts[n] += 1;"}, {"sha": "1bc1bd8d78c57eaf5ead7f6c6879d38572fb30d4", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -584,7 +584,7 @@ mod slice_index {\n     }\n \n     mod boundary {\n-        const DATA: &'static str = \"abc\u03b1\u03b2\u03b3\";\n+        const DATA: &str = \"abc\u03b1\u03b2\u03b3\";\n \n         const BAD_START: usize = 4;\n         const GOOD_START: usize = 3;\n@@ -648,7 +648,7 @@ mod slice_index {\n         }\n     }\n \n-    const LOREM_PARAGRAPH: &'static str = \"\\\n+    const LOREM_PARAGRAPH: &str = \"\\\n     Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem \\\n     sit amet dolor ultricies condimentum. Praesent iaculis purus elit, ac malesuada \\\n     quam malesuada in. Duis sed orci eros. Suspendisse sit amet magna mollis, mollis \\\n@@ -1068,7 +1068,7 @@ fn test_rev_iterator() {\n #[test]\n fn test_chars_decoding() {\n     let mut bytes = [0; 4];\n-    for c in (0..0x110000).filter_map(::std::char::from_u32) {\n+    for c in (0..0x110000).filter_map(std::char::from_u32) {\n         let s = c.encode_utf8(&mut bytes);\n         if Some(c) != s.chars().next() {\n             panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n@@ -1079,7 +1079,7 @@ fn test_chars_decoding() {\n #[test]\n fn test_chars_rev_decoding() {\n     let mut bytes = [0; 4];\n-    for c in (0..0x110000).filter_map(::std::char::from_u32) {\n+    for c in (0..0x110000).filter_map(std::char::from_u32) {\n         let s = c.encode_utf8(&mut bytes);\n         if Some(c) != s.chars().rev().next() {\n             panic!(\"character {:x}={} does not decode correctly\", c as u32, c);\n@@ -1599,8 +1599,7 @@ fn test_repeat() {\n }\n \n mod pattern {\n-    use std::str::pattern::Pattern;\n-    use std::str::pattern::{Searcher, ReverseSearcher};\n+    use std::str::pattern::{Pattern, Searcher, ReverseSearcher};\n     use std::str::pattern::SearchStep::{self, Match, Reject, Done};\n \n     macro_rules! make_test {"}, {"sha": "e5ce51a36ee2286bc33aa1da49ca8fa05d981127", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -21,7 +21,7 @@ impl<'a> IntoCow<'a, str> for &'a str {\n \n #[test]\n fn test_from_str() {\n-    let owned: Option<::std::string::String> = \"string\".parse().ok();\n+    let owned: Option<std::string::String> = \"string\".parse().ok();\n     assert_eq!(owned.as_ref().map(|s| &**s), Some(\"string\"));\n }\n \n@@ -122,7 +122,7 @@ fn test_from_utf16() {\n         let s_as_utf16 = s.encode_utf16().collect::<Vec<u16>>();\n         let u_as_string = String::from_utf16(&u).unwrap();\n \n-        assert!(::core::char::decode_utf16(u.iter().cloned()).all(|r| r.is_ok()));\n+        assert!(core::char::decode_utf16(u.iter().cloned()).all(|r| r.is_ok()));\n         assert_eq!(s_as_utf16, u);\n \n         assert_eq!(u_as_string, s);"}, {"sha": "89f2e0a046d91ae0a05e294784162b6c49384a53", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -8,7 +8,7 @@ struct DropCounter<'a> {\n     count: &'a mut u32,\n }\n \n-impl<'a> Drop for DropCounter<'a> {\n+impl Drop for DropCounter<'_> {\n     fn drop(&mut self) {\n         *self.count += 1;\n     }\n@@ -638,7 +638,7 @@ fn test_splice_unbounded() {\n fn test_splice_forget() {\n     let mut v = vec![1, 2, 3, 4, 5];\n     let a = [10, 11, 12];\n-    ::std::mem::forget(v.splice(2..4, a.iter().cloned()));\n+    std::mem::forget(v.splice(2..4, a.iter().cloned()));\n     assert_eq!(v, &[1, 2]);\n }\n "}, {"sha": "aa49bdb009086e9e7738dbfa977aec5e271ce21d", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -1,12 +1,13 @@\n-use std::collections::VecDeque;\n use std::fmt::Debug;\n-use std::collections::vec_deque::{Drain};\n+use std::collections::{VecDeque, vec_deque::Drain};\n use std::collections::CollectionAllocErr::*;\n use std::mem::size_of;\n use std::{usize, isize};\n \n-use self::Taggy::*;\n-use self::Taggypar::*;\n+use crate::hash;\n+\n+use Taggy::*;\n+use Taggypar::*;\n \n #[test]\n fn test_simple() {\n@@ -583,7 +584,7 @@ fn test_hash() {\n     y.push_back(2);\n     y.push_back(3);\n \n-    assert!(::hash(&x) == ::hash(&y));\n+    assert!(hash(&x) == hash(&y));\n }\n \n #[test]\n@@ -599,7 +600,7 @@ fn test_hash_after_rotation() {\n             *elt -= 1;\n         }\n         ring.push_back(len - 1);\n-        assert_eq!(::hash(&orig), ::hash(&ring));\n+        assert_eq!(hash(&orig), hash(&ring));\n         assert_eq!(orig, ring);\n         assert_eq!(ring, orig);\n     }\n@@ -998,7 +999,7 @@ struct DropCounter<'a> {\n     count: &'a mut u32,\n }\n \n-impl<'a> Drop for DropCounter<'a> {\n+impl Drop for DropCounter<'_> {\n     fn drop(&mut self) {\n         *self.count += 1;\n     }"}, {"sha": "57e10498b92dbf09061dddc7aea904e29a82694d", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 35, "deletions": 44, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -63,18 +63,15 @@ use core::intrinsics::{arith_offset, assume};\n use core::iter::{FromIterator, FusedIterator, TrustedLen};\n use core::marker::PhantomData;\n use core::mem;\n+use core::ops::{self, Index, IndexMut, RangeBounds};\n use core::ops::Bound::{Excluded, Included, Unbounded};\n-use core::ops::{Index, IndexMut, RangeBounds};\n-use core::ops;\n-use core::ptr;\n-use core::ptr::NonNull;\n-use core::slice;\n-\n-use collections::CollectionAllocErr;\n-use borrow::ToOwned;\n-use borrow::Cow;\n-use boxed::Box;\n-use raw_vec::RawVec;\n+use core::ptr::{self, NonNull};\n+use core::slice::{self, SliceIndex};\n+\n+use crate::borrow::{ToOwned, Cow};\n+use crate::collections::CollectionAllocErr;\n+use crate::boxed::Box;\n+use crate::raw_vec::RawVec;\n \n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n@@ -1118,7 +1115,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(v, &[]);\n     /// ```\n     #[stable(feature = \"drain\", since = \"1.6.0\")]\n-    pub fn drain<R>(&mut self, range: R) -> Drain<T>\n+    pub fn drain<R>(&mut self, range: R) -> Drain<'_, T>\n         where R: RangeBounds<usize>\n     {\n         // Memory safety\n@@ -1477,7 +1474,7 @@ impl<'a> SetLenOnDrop<'a> {\n     }\n }\n \n-impl<'a> Drop for SetLenOnDrop<'a> {\n+impl Drop for SetLenOnDrop<'_> {\n     #[inline]\n     fn drop(&mut self) {\n         *self.len = self.local_len;\n@@ -1646,7 +1643,7 @@ impl<T: Clone> Clone for Vec<T> {\n     // NB see the slice::hack module in slice.rs for more information\n     #[cfg(test)]\n     fn clone(&self) -> Vec<T> {\n-        ::slice::to_vec(&**self)\n+        crate::slice::to_vec(&**self)\n     }\n \n     fn clone_from(&mut self, other: &Vec<T>) {\n@@ -1667,10 +1664,7 @@ impl<T: Hash> Hash for Vec<T> {\n     message=\"vector indices are of type `usize` or ranges of `usize`\",\n     label=\"vector indices are of type `usize` or ranges of `usize`\",\n )]\n-impl<T, I> Index<I> for Vec<T>\n-where\n-    I: ::core::slice::SliceIndex<[T]>,\n-{\n+impl<T, I: SliceIndex<[T]>> Index<I> for Vec<T> {\n     type Output = I::Output;\n \n     #[inline]\n@@ -1684,10 +1678,7 @@ where\n     message=\"vector indices are of type `usize` or ranges of `usize`\",\n     label=\"vector indices are of type `usize` or ranges of `usize`\",\n )]\n-impl<T, I> IndexMut<I> for Vec<T>\n-where\n-    I: ::core::slice::SliceIndex<[T]>,\n-{\n+impl<T, I: SliceIndex<[T]>> IndexMut<I> for Vec<T> {\n     #[inline]\n     fn index_mut(&mut self, index: I) -> &mut Self::Output {\n         IndexMut::index_mut(&mut **self, index)\n@@ -1981,7 +1972,7 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<I::IntoIter>\n+    pub fn splice<R, I>(&mut self, range: R, replace_with: I) -> Splice<'_, I::IntoIter>\n         where R: RangeBounds<usize>, I: IntoIterator<Item=T>\n     {\n         Splice {\n@@ -2036,7 +2027,7 @@ impl<T> Vec<T> {\n     /// assert_eq!(odds, vec![1, 3, 5, 9, 11, 13, 15]);\n     /// ```\n     #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<T, F>\n+    pub fn drain_filter<F>(&mut self, filter: F) -> DrainFilter<'_, T, F>\n         where F: FnMut(&mut T) -> bool,\n     {\n         let old_len = self.len();\n@@ -2152,7 +2143,7 @@ impl<T> Default for Vec<T> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for Vec<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         fmt::Debug::fmt(&**self, f)\n     }\n }\n@@ -2193,7 +2184,7 @@ impl<'a, T: Clone> From<&'a [T]> for Vec<T> {\n     }\n     #[cfg(test)]\n     fn from(s: &'a [T]) -> Vec<T> {\n-        ::slice::to_vec(s)\n+        crate::slice::to_vec(s)\n     }\n }\n \n@@ -2205,7 +2196,7 @@ impl<'a, T: Clone> From<&'a mut [T]> for Vec<T> {\n     }\n     #[cfg(test)]\n     fn from(s: &'a mut [T]) -> Vec<T> {\n-        ::slice::to_vec(s)\n+        crate::slice::to_vec(s)\n     }\n }\n \n@@ -2295,7 +2286,7 @@ pub struct IntoIter<T> {\n \n #[stable(feature = \"vec_intoiter_debug\", since = \"1.13.0\")]\n impl<T: fmt::Debug> fmt::Debug for IntoIter<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"IntoIter\")\n             .field(&self.as_slice())\n             .finish()\n@@ -2465,20 +2456,20 @@ pub struct Drain<'a, T: 'a> {\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<'a, T: 'a + fmt::Debug> fmt::Debug for Drain<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_tuple(\"Drain\")\n          .field(&self.iter.as_slice())\n          .finish()\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<'a, T: Sync> Sync for Drain<'a, T> {}\n+unsafe impl<T: Sync> Sync for Drain<'_, T> {}\n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-unsafe impl<'a, T: Send> Send for Drain<'a, T> {}\n+unsafe impl<T: Send> Send for Drain<'_, T> {}\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T> Iterator for Drain<'a, T> {\n+impl<T> Iterator for Drain<'_, T> {\n     type Item = T;\n \n     #[inline]\n@@ -2492,15 +2483,15 @@ impl<'a, T> Iterator for Drain<'a, T> {\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T> DoubleEndedIterator for Drain<'a, T> {\n+impl<T> DoubleEndedIterator for Drain<'_, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<T> {\n         self.iter.next_back().map(|elt| unsafe { ptr::read(elt as *const _) })\n     }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T> Drop for Drain<'a, T> {\n+impl<T> Drop for Drain<'_, T> {\n     fn drop(&mut self) {\n         // exhaust self first\n         self.for_each(drop);\n@@ -2524,14 +2515,14 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n \n #[stable(feature = \"drain\", since = \"1.6.0\")]\n-impl<'a, T> ExactSizeIterator for Drain<'a, T> {\n+impl<T> ExactSizeIterator for Drain<'_, T> {\n     fn is_empty(&self) -> bool {\n         self.iter.is_empty()\n     }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n-impl<'a, T> FusedIterator for Drain<'a, T> {}\n+impl<T> FusedIterator for Drain<'_, T> {}\n \n /// A splicing iterator for `Vec`.\n ///\n@@ -2548,7 +2539,7 @@ pub struct Splice<'a, I: Iterator + 'a> {\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n+impl<I: Iterator> Iterator for Splice<'_, I> {\n     type Item = I::Item;\n \n     fn next(&mut self) -> Option<Self::Item> {\n@@ -2561,18 +2552,18 @@ impl<'a, I: Iterator> Iterator for Splice<'a, I> {\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<'a, I: Iterator> DoubleEndedIterator for Splice<'a, I> {\n+impl<I: Iterator> DoubleEndedIterator for Splice<'_, I> {\n     fn next_back(&mut self) -> Option<Self::Item> {\n         self.drain.next_back()\n     }\n }\n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<'a, I: Iterator> ExactSizeIterator for Splice<'a, I> {}\n+impl<I: Iterator> ExactSizeIterator for Splice<'_, I> {}\n \n \n #[stable(feature = \"vec_splice\", since = \"1.21.0\")]\n-impl<'a, I: Iterator> Drop for Splice<'a, I> {\n+impl<I: Iterator> Drop for Splice<'_, I> {\n     fn drop(&mut self) {\n         self.drain.by_ref().for_each(drop);\n \n@@ -2613,7 +2604,7 @@ impl<'a, I: Iterator> Drop for Splice<'a, I> {\n }\n \n /// Private helper methods for `Splice::drop`\n-impl<'a, T> Drain<'a, T> {\n+impl<T> Drain<'_, T> {\n     /// The range from `self.vec.len` to `self.tail_start` contains elements\n     /// that have been moved out.\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n@@ -2654,7 +2645,7 @@ impl<'a, T> Drain<'a, T> {\n /// An iterator produced by calling `drain_filter` on Vec.\n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n #[derive(Debug)]\n-pub struct DrainFilter<'a, T: 'a, F>\n+pub struct DrainFilter<'a, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     vec: &'a mut Vec<T>,\n@@ -2665,7 +2656,7 @@ pub struct DrainFilter<'a, T: 'a, F>\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n+impl<T, F> Iterator for DrainFilter<'_, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     type Item = T;\n@@ -2699,7 +2690,7 @@ impl<'a, T, F> Iterator for DrainFilter<'a, T, F>\n }\n \n #[unstable(feature = \"drain_filter\", reason = \"recently added\", issue = \"43244\")]\n-impl<'a, T, F> Drop for DrainFilter<'a, T, F>\n+impl<T, F> Drop for DrainFilter<'_, T, F>\n     where F: FnMut(&mut T) -> bool,\n {\n     fn drop(&mut self) {"}, {"sha": "338caa5614ee5f69a5630e33abbfa468a2081117", "filename": "src/test/run-make-fulldeps/alloc-extern-crates/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Ftest%2Frun-make-fulldeps%2Falloc-extern-crates%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922/src%2Ftest%2Frun-make-fulldeps%2Falloc-extern-crates%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Falloc-extern-crates%2FMakefile?ref=4f4f4a40b6c7bcb6fa07ee6575e8a9759ba08922", "patch": "@@ -2,4 +2,4 @@\n \n all:\n \t$(RUSTC) fakealloc.rs\n-\t$(RUSTC) --crate-type=rlib ../../../liballoc/lib.rs --cfg feature=\\\"external_crate\\\" --extern external=$(TMPDIR)/$(shell $(RUSTC) --print file-names fakealloc.rs)\n+\t$(RUSTC) --edition=2018 --crate-type=rlib ../../../liballoc/lib.rs --cfg feature=\\\"external_crate\\\" --extern external=$(TMPDIR)/$(shell $(RUSTC) --print file-names fakealloc.rs)"}]}