{"sha": "587d8a5d4f503ec07a8b964c04376078d14bf307", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4N2Q4YTVkNGY1MDNlYzA3YThiOTY0YzA0Mzc2MDc4ZDE0YmYzMDc=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-23T10:10:06Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-04-23T10:13:59Z"}, "message": "Misc code cleanups using list::each for list iteration", "tree": {"sha": "574a91a8833e562861edd5c249a1aa6084499777", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/574a91a8833e562861edd5c249a1aa6084499777"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/587d8a5d4f503ec07a8b964c04376078d14bf307", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/587d8a5d4f503ec07a8b964c04376078d14bf307", "html_url": "https://github.com/rust-lang/rust/commit/587d8a5d4f503ec07a8b964c04376078d14bf307", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/587d8a5d4f503ec07a8b964c04376078d14bf307/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a61f107684c4e5f316d7446c02f58f35b12dbffb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a61f107684c4e5f316d7446c02f58f35b12dbffb", "html_url": "https://github.com/rust-lang/rust/commit/a61f107684c4e5f316d7446c02f58f35b12dbffb"}], "stats": {"total": 117, "additions": 46, "deletions": 71}, "files": [{"sha": "da125214cb664717c1be94229d704762734f0e88", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/587d8a5d4f503ec07a8b964c04376078d14bf307/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/587d8a5d4f503ec07a8b964c04376078d14bf307/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=587d8a5d4f503ec07a8b964c04376078d14bf307", "patch": "@@ -70,18 +70,13 @@ type ext_hash = hashmap<{did: def_id, ident: str, ns: namespace}, def>;\n fn new_ext_hash() -> ext_hash {\n     type key = {did: def_id, ident: str, ns: namespace};\n     fn hash(v: key) -> uint {\n-        ret str::hash(v.ident) + util::common::hash_def(v.did) +\n-                alt v.ns {\n-                  ns_val { 1u }\n-                  ns_type { 2u }\n-                  ns_module { 3u }\n-                };\n+        str::hash(v.ident) + util::common::hash_def(v.did) + v.ns as uint\n     }\n     fn eq(v1: key, v2: key) -> bool {\n         ret util::common::def_eq(v1.did, v2.did) &&\n-                str::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n+            str::eq(v1.ident, v2.ident) && v1.ns == v2.ns;\n     }\n-    ret std::map::hashmap::<key, def>(hash, eq);\n+    std::map::hashmap(hash, {|a, b| a == b})\n }\n \n enum mod_index_entry {\n@@ -851,22 +846,16 @@ enum ctxt { in_mod(def), in_scope(scopes), }\n \n fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n     fn find_fn_or_mod_scope(sc: scopes) -> option<scope> {\n-        let mut sc = sc;\n-        loop {\n-            alt sc {\n-              cons(cur, rest) {\n-                alt cur {\n-                  scope_crate | scope_bare_fn(_, _, _) |\n-                  scope_fn_expr(_, _, _) |\n-                  scope_item(@{node: ast::item_mod(_), _}) {\n-                    ret some(cur);\n-                  }\n-                  _ { sc = *rest; }\n-                }\n+        for list::each(sc) {|cur|\n+            alt cur {\n+              scope_crate | scope_bare_fn(_, _, _) | scope_fn_expr(_, _, _) |\n+              scope_item(@{node: ast::item_mod(_), _}) {\n+                ret some(cur);\n               }\n-              _ { ret none; }\n+              _ {}\n             }\n-        };\n+        }\n+        ret none;\n     }\n     let mut path = name;\n     alt cx {\n@@ -887,9 +876,7 @@ fn unresolved_err(e: env, cx: ctxt, sp: span, name: ident, kind: str) {\n             path = e.mod_map.get(did.node).path + path;\n         } else if did.node != ast::crate_node_id {\n             let paths = e.ext_map.get(did);\n-            if vec::len(paths) > 0u {\n-                path = str::connect(paths, \"::\") + \"::\" + path;\n-            }\n+            path = str::connect(paths + [path], \"::\");\n         }\n       }\n     }\n@@ -1673,18 +1660,12 @@ fn ns_for_def(d: def) -> namespace {\n     }\n }\n \n-// if we're searching for a value, it's ok if we found\n-// a enum\n-fn ns_ok(wanted:namespace, actual:namespace) -> bool {\n-    wanted == actual\n-}\n-\n fn lookup_external(e: env, cnum: int, ids: [ident], ns: namespace) ->\n    option<def> {\n     let mut result = none;\n     for csearch::lookup_defs(e.sess.cstore, cnum, ids).each {|d|\n         e.ext_map.insert(def_id_of_def(d), ids);\n-        if ns_ok(ns, ns_for_def(d)) { result = some(d); }\n+        if ns == ns_for_def(d) { result = some(d); }\n     }\n     ret result;\n }"}, {"sha": "9574d59184698ac32f3d8e6191989bf744c5c1d8", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/587d8a5d4f503ec07a8b964c04376078d14bf307/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/587d8a5d4f503ec07a8b964c04376078d14bf307/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=587d8a5d4f503ec07a8b964c04376078d14bf307", "patch": "@@ -4418,50 +4418,44 @@ mod vtable {\n             ret vtable_iface(did, tps);\n           }\n           _ {\n-            let mut found = none;\n-            list::iter(isc) {|impls|\n-                if option::is_none(found) {\n-                    for vec::each(*impls) {|im|\n-                        let match = alt ty::impl_iface(tcx, im.did) {\n-                          some(ity) {\n-                            alt check ty::get(ity).struct {\n-                              ty::ty_iface(id, _) { id == iface_id }\n+            for list::each(isc) {|impls|\n+                let mut found = none;\n+                for vec::each(*impls) {|im|\n+                    let match = alt ty::impl_iface(tcx, im.did) {\n+                      some(ity) {\n+                        alt check ty::get(ity).struct {\n+                          ty::ty_iface(id, _) { id == iface_id }\n+                        }\n+                      }\n+                      _ { false }\n+                    };\n+                    if match {\n+                        let {substs: substs, ty: self_ty} =\n+                            impl_self_ty(fcx, im.did);\n+                        let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n+                        alt unify::unify(fcx, ty, self_ty) {\n+                          result::ok(_) {\n+                            if option::is_some(found) {\n+                                tcx.sess.span_err(\n+                                    sp, \"multiple applicable implementations \\\n+                                         in scope\");\n+                            } else {\n+                                let vars = substs.tps;\n+                                connect_iface_tps(fcx, sp, vars,\n+                                                  iface_tps, im.did);\n+                                let params = vec::map(vars, {|t|\n+                                    fixup_ty(fcx, sp, t)});\n+                                let subres = lookup_vtables(\n+                                    fcx, isc, sp, im_bs, params, false);\n+                                found = some(vtable_static(im.did, params,\n+                                                           subres));\n                             }\n                           }\n-                          _ { false }\n-                        };\n-                        if match {\n-                            let {substs: substs, ty: self_ty} =\n-                                impl_self_ty(fcx, im.did);\n-                            let im_bs =\n-                                ty::lookup_item_type(tcx, im.did).bounds;\n-                            alt unify::unify(fcx, ty, self_ty) {\n-                              result::ok(_) {\n-                                if option::is_some(found) {\n-                                    tcx.sess.span_err(\n-                                        sp, \"multiple applicable implemen\\\n-                                             tations in scope\");\n-                                } else {\n-                                    let vars = substs.tps;\n-                                    connect_iface_tps(fcx, sp, vars,\n-                                                      iface_tps, im.did);\n-                                    let params = vec::map(vars, {|t|\n-                                        fixup_ty(fcx, sp, t)});\n-                                    let subres = lookup_vtables(\n-                                        fcx, isc, sp, im_bs, params, false);\n-                                    found = some(vtable_static(im.did, params,\n-                                                               subres));\n-                                }\n-                              }\n-                              result::err(_) {}\n-                            }\n+                          result::err(_) {}\n                         }\n                     }\n                 }\n-            }\n-            alt found {\n-              some(rslt) { ret rslt; }\n-              _ {}\n+                alt found { some(x) { ret x; } _ {} }\n             }\n           }\n         }"}]}