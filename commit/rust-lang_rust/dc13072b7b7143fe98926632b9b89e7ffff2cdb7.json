{"sha": "dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjMTMwNzJiN2I3MTQzZmU5ODkyNjYzMmI5Yjg5ZTdmZmZmMmNkYjc=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-06-04T02:47:42Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-06-09T19:45:16Z"}, "message": "Use Symbol for named arguments in fmt_macros", "tree": {"sha": "bab19f2467b2524abf232b0ddf74e38878de2e59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bab19f2467b2524abf232b0ddf74e38878de2e59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "html_url": "https://github.com/rust-lang/rust/commit/dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7795b155e04dcf245f240f4486485b1099fb4a99", "url": "https://api.github.com/repos/rust-lang/rust/commits/7795b155e04dcf245f240f4486485b1099fb4a99", "html_url": "https://github.com/rust-lang/rust/commit/7795b155e04dcf245f240f4486485b1099fb4a99"}], "stats": {"total": 140, "additions": 79, "deletions": 61}, "files": [{"sha": "73605af7936f2cc37d680d36a61047c697ce3287", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "patch": "@@ -910,6 +910,9 @@ dependencies = [\n [[package]]\n name = \"fmt_macros\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"syntax_pos 0.0.0\",\n+]\n \n [[package]]\n name = \"fnv\""}, {"sha": "fc32f21ec4e0a8b5816489b2f22e6786168e94bc", "filename": "src/libfmt_macros/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibfmt_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibfmt_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2FCargo.toml?ref=dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "patch": "@@ -8,3 +8,6 @@ edition = \"2018\"\n name = \"fmt_macros\"\n path = \"lib.rs\"\n crate-type = [\"dylib\"]\n+\n+[dependencies]\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "9d6720810b8181d511bd1a50229365fe39313933", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "patch": "@@ -24,6 +24,8 @@ use std::str;\n use std::string;\n use std::iter;\n \n+use syntax_pos::Symbol;\n+\n /// A piece is a portion of the format string which represents the next part\n /// to emit. These are emitted as a stream by the `Parser` class.\n #[derive(Copy, Clone, PartialEq)]\n@@ -39,7 +41,7 @@ pub enum Piece<'a> {\n #[derive(Copy, Clone, PartialEq)]\n pub struct Argument<'a> {\n     /// Where to find this argument\n-    pub position: Position<'a>,\n+    pub position: Position,\n     /// How to format the argument\n     pub format: FormatSpec<'a>,\n }\n@@ -54,9 +56,9 @@ pub struct FormatSpec<'a> {\n     /// Packed version of various flags provided\n     pub flags: u32,\n     /// The integer precision to use\n-    pub precision: Count<'a>,\n+    pub precision: Count,\n     /// The string width requested for the resulting format\n-    pub width: Count<'a>,\n+    pub width: Count,\n     /// The descriptor string representing the name of the format desired for\n     /// this argument, this can be empty or any number of characters, although\n     /// it is required to be one word.\n@@ -65,16 +67,16 @@ pub struct FormatSpec<'a> {\n \n /// Enum describing where an argument for a format can be located.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum Position<'a> {\n+pub enum Position {\n     /// The argument is implied to be located at an index\n     ArgumentImplicitlyIs(usize),\n     /// The argument is located at a specific index given in the format\n     ArgumentIs(usize),\n     /// The argument has a name.\n-    ArgumentNamed(&'a str),\n+    ArgumentNamed(Symbol),\n }\n \n-impl Position<'_> {\n+impl Position {\n     pub fn index(&self) -> Option<usize> {\n         match self {\n             ArgumentIs(i) | ArgumentImplicitlyIs(i) => Some(*i),\n@@ -119,11 +121,11 @@ pub enum Flag {\n /// A count is used for the precision and width parameters of an integer, and\n /// can reference either an argument or a literal integer.\n #[derive(Copy, Clone, PartialEq)]\n-pub enum Count<'a> {\n+pub enum Count {\n     /// The count is specified explicitly.\n     CountIs(usize),\n     /// The count is specified by the argument with the given name.\n-    CountIsName(&'a str),\n+    CountIsName(Symbol),\n     /// The count is specified by the argument at the given index.\n     CountIsParam(usize),\n     /// The count is implied and cannot be explicitly specified.\n@@ -431,20 +433,22 @@ impl<'a> Parser<'a> {\n     /// integer index of an argument, a named argument, or a blank string.\n     /// Returns `Some(parsed_position)` if the position is not implicitly\n     /// consuming a macro argument, `None` if it's the case.\n-    fn position(&mut self) -> Option<Position<'a>> {\n+    fn position(&mut self) -> Option<Position> {\n         if let Some(i) = self.integer() {\n             Some(ArgumentIs(i))\n         } else {\n             match self.cur.peek() {\n-                Some(&(_, c)) if c.is_alphabetic() => Some(ArgumentNamed(self.word())),\n+                Some(&(_, c)) if c.is_alphabetic() => {\n+                    Some(ArgumentNamed(Symbol::intern(self.word())))\n+                }\n                 Some(&(pos, c)) if c == '_' => {\n                     let invalid_name = self.string(pos);\n                     self.err_with_note(format!(\"invalid argument name `{}`\", invalid_name),\n                                        \"invalid argument name\",\n                                        \"argument names cannot start with an underscore\",\n                                        self.to_span_index(pos),\n                                        self.to_span_index(pos + invalid_name.len()));\n-                    Some(ArgumentNamed(invalid_name))\n+                    Some(ArgumentNamed(Symbol::intern(invalid_name)))\n                 },\n \n                 // This is an `ArgumentNext`.\n@@ -552,7 +556,7 @@ impl<'a> Parser<'a> {\n     /// Parses a Count parameter at the current position. This does not check\n     /// for 'CountIsNextParam' because that is only used in precision, not\n     /// width.\n-    fn count(&mut self) -> Count<'a> {\n+    fn count(&mut self) -> Count {\n         if let Some(i) = self.integer() {\n             if self.consume('$') {\n                 CountIsParam(i)\n@@ -566,7 +570,7 @@ impl<'a> Parser<'a> {\n                 self.cur = tmp;\n                 CountImplied\n             } else if self.consume('$') {\n-                CountIsName(word)\n+                CountIsName(Symbol::intern(word))\n             } else {\n                 self.cur = tmp;\n                 CountImplied\n@@ -756,6 +760,8 @@ mod tests {\n     }\n     #[test]\n     fn format_counts() {\n+        use syntax_pos::{GLOBALS, Globals, edition};\n+        GLOBALS.set(&Globals::new(edition::DEFAULT_EDITION), || {\n         same(\"{:10s}\",\n              &[NextArgument(Argument {\n                    position: ArgumentImplicitlyIs(0),\n@@ -811,11 +817,12 @@ mod tests {\n                        fill: None,\n                        align: AlignUnknown,\n                        flags: 0,\n-                       precision: CountIsName(\"b\"),\n-                       width: CountIsName(\"a\"),\n+                       precision: CountIsName(Symbol::intern(\"b\")),\n+                       width: CountIsName(Symbol::intern(\"a\")),\n                        ty: \"s\",\n                    },\n                })]);\n+        });\n     }\n     #[test]\n     fn format_flags() {"}, {"sha": "50d2eeef421c13d767e6a4e50196dddeb8ebd2d0", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "patch": "@@ -353,7 +353,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => {\n                 // this is a \"direct\", user-specified, rather than derived,\n                 // obligation.\n-                flags.push((\"direct\".to_owned(), None));\n+                flags.push((sym::direct, None));\n             }\n         }\n \n@@ -365,27 +365,27 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             // Currently I'm leaving it for what I need for `try`.\n             if self.tcx.trait_of_item(item) == Some(trait_ref.def_id) {\n                 let method = self.tcx.item_name(item);\n-                flags.push((\"from_method\".to_owned(), None));\n-                flags.push((\"from_method\".to_owned(), Some(method.to_string())));\n+                flags.push((sym::from_method, None));\n+                flags.push((sym::from_method, Some(method.to_string())));\n             }\n         }\n         if let Some(t) = self.get_parent_trait_ref(&obligation.cause.code) {\n-            flags.push((\"parent_trait\".to_owned(), Some(t)));\n+            flags.push((sym::parent_trait, Some(t)));\n         }\n \n         if let Some(k) = obligation.cause.span.compiler_desugaring_kind() {\n-            flags.push((\"from_desugaring\".to_owned(), None));\n-            flags.push((\"from_desugaring\".to_owned(), Some(k.name().to_string())));\n+            flags.push((sym::from_desugaring, None));\n+            flags.push((sym::from_desugaring, Some(k.name().to_string())));\n         }\n         let generics = self.tcx.generics_of(def_id);\n         let self_ty = trait_ref.self_ty();\n         // This is also included through the generics list as `Self`,\n         // but the parser won't allow you to use it\n-        flags.push((\"_Self\".to_owned(), Some(self_ty.to_string())));\n+        flags.push((sym::_Self, Some(self_ty.to_string())));\n         if let Some(def) = self_ty.ty_adt_def() {\n             // We also want to be able to select self's original\n             // signature with no type arguments resolved\n-            flags.push((\"_Self\".to_owned(), Some(self.tcx.type_of(def.did).to_string())));\n+            flags.push((sym::_Self, Some(self.tcx.type_of(def.did).to_string())));\n         }\n \n         for param in generics.params.iter() {\n@@ -396,38 +396,38 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 },\n                 GenericParamDefKind::Lifetime => continue,\n             };\n-            let name = param.name.to_string();\n+            let name = param.name.as_symbol();\n             flags.push((name, Some(value)));\n         }\n \n         if let Some(true) = self_ty.ty_adt_def().map(|def| def.did.is_local()) {\n-            flags.push((\"crate_local\".to_owned(), None));\n+            flags.push((sym::crate_local, None));\n         }\n \n         // Allow targeting all integers using `{integral}`, even if the exact type was resolved\n         if self_ty.is_integral() {\n-            flags.push((\"_Self\".to_owned(), Some(\"{integral}\".to_owned())));\n+            flags.push((sym::_Self, Some(\"{integral}\".to_owned())));\n         }\n \n         if let ty::Array(aty, len) = self_ty.sty {\n-            flags.push((\"_Self\".to_owned(), Some(\"[]\".to_owned())));\n-            flags.push((\"_Self\".to_owned(), Some(format!(\"[{}]\", aty))));\n+            flags.push((sym::_Self, Some(\"[]\".to_owned())));\n+            flags.push((sym::_Self, Some(format!(\"[{}]\", aty))));\n             if let Some(def) = aty.ty_adt_def() {\n                 // We also want to be able to select the array's type's original\n                 // signature with no type arguments resolved\n                 flags.push((\n-                    \"_Self\".to_owned(),\n+                    sym::_Self,\n                     Some(format!(\"[{}]\", self.tcx.type_of(def.did).to_string())),\n                 ));\n                 let tcx = self.tcx;\n                 if let Some(len) = len.assert_usize(tcx) {\n                     flags.push((\n-                        \"_Self\".to_owned(),\n+                        sym::_Self,\n                         Some(format!(\"[{}; {}]\", self.tcx.type_of(def.did).to_string(), len)),\n                     ));\n                 } else {\n                     flags.push((\n-                        \"_Self\".to_owned(),\n+                        sym::_Self,\n                         Some(format!(\"[{}; _]\", self.tcx.type_of(def.did).to_string())),\n                     ));\n                 }"}, {"sha": "b78396c90dc657f2a70aba7c37922ac30048891d", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "patch": "@@ -7,7 +7,7 @@ use crate::util::nodemap::FxHashMap;\n \n use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;\n-use syntax::symbol::sym;\n+use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::Span;\n use syntax_pos::symbol::LocalInternedString;\n \n@@ -167,7 +167,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n     pub fn evaluate(&self,\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     trait_ref: ty::TraitRef<'tcx>,\n-                    options: &[(String, Option<String>)])\n+                    options: &[(Symbol, Option<String>)])\n                     -> OnUnimplementedNote\n     {\n         let mut message = None;\n@@ -180,7 +180,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n                 if !attr::eval_condition(condition, &tcx.sess.parse_sess, &mut |c| {\n                     c.ident().map_or(false, |ident| {\n                         options.contains(&(\n-                            ident.to_string(),\n+                            ident.name,\n                             c.value_str().map(|s| s.as_str().to_string())\n                         ))\n                     })\n@@ -203,8 +203,8 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedDirective {\n             }\n         }\n \n-        let options: FxHashMap<String, String> = options.into_iter()\n-            .filter_map(|(k, v)| v.as_ref().map(|v| (k.to_owned(), v.to_owned())))\n+        let options: FxHashMap<Symbol, String> = options.into_iter()\n+            .filter_map(|(k, v)| v.as_ref().map(|v| (*k, v.to_owned())))\n             .collect();\n         OnUnimplementedNote {\n             label: label.map(|l| l.format(tcx, trait_ref, &options)),\n@@ -241,16 +241,16 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                 Piece::String(_) => (), // Normal string, no need to check it\n                 Piece::NextArgument(a) => match a.position {\n                     // `{Self}` is allowed\n-                    Position::ArgumentNamed(s) if s == \"Self\" => (),\n+                    Position::ArgumentNamed(s) if s == kw::SelfUpper => (),\n                     // `{ThisTraitsName}` is allowed\n-                    Position::ArgumentNamed(s) if s == name.as_str() => (),\n+                    Position::ArgumentNamed(s) if s == name => (),\n                     // `{from_method}` is allowed\n-                    Position::ArgumentNamed(s) if s == \"from_method\" => (),\n+                    Position::ArgumentNamed(s) if s == sym::from_method => (),\n                     // `{from_desugaring}` is allowed\n-                    Position::ArgumentNamed(s) if s == \"from_desugaring\" => (),\n+                    Position::ArgumentNamed(s) if s == sym::from_desugaring => (),\n                     // So is `{A}` if A is a type parameter\n                     Position::ArgumentNamed(s) => match generics.params.iter().find(|param| {\n-                        param.name.as_str() == s\n+                        param.name.as_symbol() == s\n                     }) {\n                         Some(_) => (),\n                         None => {\n@@ -276,7 +276,7 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n         &self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         trait_ref: ty::TraitRef<'tcx>,\n-        options: &FxHashMap<String, String>,\n+        options: &FxHashMap<Symbol, String>,\n     ) -> String {\n         let name = tcx.item_name(trait_ref.def_id);\n         let trait_str = tcx.def_path_str(trait_ref.def_id);\n@@ -289,25 +289,25 @@ impl<'a, 'gcx, 'tcx> OnUnimplementedFormatString {\n                 },\n                 GenericParamDefKind::Lifetime => return None\n             };\n-            let name = param.name.to_string();\n+            let name = param.name.as_symbol();\n             Some((name, value))\n-        }).collect::<FxHashMap<String, String>>();\n+        }).collect::<FxHashMap<Symbol, String>>();\n         let empty_string = String::new();\n \n         let parser = Parser::new(&self.0, None, vec![], false);\n         parser.map(|p|\n             match p {\n                 Piece::String(s) => s,\n                 Piece::NextArgument(a) => match a.position {\n-                    Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                    Position::ArgumentNamed(s) => match generic_map.get(&s) {\n                         Some(val) => val,\n-                        None if s == name.as_str() => {\n+                        None if s == name => {\n                             &trait_str\n                         }\n                         None => {\n-                            if let Some(val) = options.get(s) {\n+                            if let Some(val) = options.get(&s) {\n                                 val\n-                            } else if s == \"from_desugaring\" || s == \"from_method\" {\n+                            } else if s == sym::from_desugaring || s == sym::from_method {\n                                 // don't break messages using these two arguments incorrectly\n                                 &empty_string\n                             } else {"}, {"sha": "2863daa13a99cd1898f0ebef27af1f0529b5ecc2", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "patch": "@@ -28,7 +28,7 @@ enum ArgumentType {\n \n enum Position {\n     Exact(usize),\n-    Named(String),\n+    Named(Symbol),\n }\n \n struct Context<'a, 'b: 'a> {\n@@ -57,7 +57,7 @@ struct Context<'a, 'b: 'a> {\n     /// Unique format specs seen for each argument.\n     arg_unique_types: Vec<Vec<ArgumentType>>,\n     /// Map from named arguments to their resolved indices.\n-    names: FxHashMap<String, usize>,\n+    names: FxHashMap<Symbol, usize>,\n \n     /// The latest consecutive literal strings, or empty if there weren't any.\n     literal: String,\n@@ -127,9 +127,9 @@ fn parse_args<'a>(\n     ecx: &mut ExtCtxt<'a>,\n     sp: Span,\n     tts: &[tokenstream::TokenTree]\n-) -> Result<(P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<String, usize>), DiagnosticBuilder<'a>> {\n+) -> Result<(P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<Symbol, usize>), DiagnosticBuilder<'a>> {\n     let mut args = Vec::<P<ast::Expr>>::new();\n-    let mut names = FxHashMap::<String, usize>::default();\n+    let mut names = FxHashMap::<Symbol, usize>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n@@ -158,11 +158,10 @@ fn parse_args<'a>(\n                     \"expected ident, positional arguments cannot follow named arguments\",\n                 ));\n             };\n-            let name: &str = &name.as_str();\n \n             p.expect(&token::Eq)?;\n             let e = p.parse_expr()?;\n-            if let Some(prev) = names.get(name) {\n+            if let Some(prev) = names.get(&name) {\n                 ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", name))\n                     .span_note(args[*prev].span, \"previously here\")\n                     .emit();\n@@ -174,7 +173,7 @@ fn parse_args<'a>(\n             // if the input is valid, we can simply append to the positional\n             // args. And remember the names.\n             let slot = args.len();\n-            names.insert(name.to_string(), slot);\n+            names.insert(name, slot);\n             args.push(e);\n         } else {\n             let e = p.parse_expr()?;\n@@ -188,7 +187,7 @@ impl<'a, 'b> Context<'a, 'b> {\n     fn resolve_name_inplace(&self, p: &mut parse::Piece<'_>) {\n         // NOTE: the `unwrap_or` branch is needed in case of invalid format\n         // arguments, e.g., `format_args!(\"{foo}\")`.\n-        let lookup = |s| *self.names.get(s).unwrap_or(&0);\n+        let lookup = |s: Symbol| *self.names.get(&s).unwrap_or(&0);\n \n         match *p {\n             parse::String(_) => {}\n@@ -222,7 +221,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                 // it's written second, so it should come after width/precision.\n                 let pos = match arg.position {\n                     parse::ArgumentIs(i) | parse::ArgumentImplicitlyIs(i) => Exact(i),\n-                    parse::ArgumentNamed(s) => Named(s.to_string()),\n+                    parse::ArgumentNamed(s) => Named(s),\n                 };\n \n                 let ty = Placeholder(arg.format.ty.to_string());\n@@ -232,15 +231,15 @@ impl<'a, 'b> Context<'a, 'b> {\n         }\n     }\n \n-    fn verify_count(&mut self, c: parse::Count<'_>) {\n+    fn verify_count(&mut self, c: parse::Count) {\n         match c {\n             parse::CountImplied |\n             parse::CountIs(..) => {}\n             parse::CountIsParam(i) => {\n                 self.verify_arg_type(Exact(i), Count);\n             }\n             parse::CountIsName(s) => {\n-                self.verify_arg_type(Named(s.to_string()), Count);\n+                self.verify_arg_type(Named(s), Count);\n             }\n         }\n     }\n@@ -390,7 +389,7 @@ impl<'a, 'b> Context<'a, 'b> {\n         ecx.std_path(&[sym::fmt, sym::rt, sym::v1, Symbol::intern(s)])\n     }\n \n-    fn build_count(&self, c: parse::Count<'_>) -> P<ast::Expr> {\n+    fn build_count(&self, c: parse::Count) -> P<ast::Expr> {\n         let sp = self.macsp;\n         let count = |c, arg| {\n             let mut path = Context::rtpath(self.ecx, \"Count\");\n@@ -739,7 +738,7 @@ pub fn expand_preparsed_format_args(ecx: &mut ExtCtxt<'_>,\n                                     sp: Span,\n                                     efmt: P<ast::Expr>,\n                                     args: Vec<P<ast::Expr>>,\n-                                    names: FxHashMap<String, usize>,\n+                                    names: FxHashMap<Symbol, usize>,\n                                     append_newline: bool)\n                                     -> P<ast::Expr> {\n     // NOTE: this verbose way of initializing `Vec<Vec<ArgumentType>>` is because"}, {"sha": "95d74ce054ef9b4f3bc52eec7d72ac5fe7e609a2", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc13072b7b7143fe98926632b9b89e7ffff2cdb7/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=dc13072b7b7143fe98926632b9b89e7ffff2cdb7", "patch": "@@ -203,6 +203,7 @@ symbols! {\n         core_intrinsics,\n         crate_id,\n         crate_in_paths,\n+        crate_local,\n         crate_name,\n         crate_type,\n         crate_visibility_modifier,\n@@ -221,6 +222,7 @@ symbols! {\n         deref,\n         deref_mut,\n         derive,\n+        direct,\n         doc,\n         doc_alias,\n         doc_cfg,\n@@ -278,8 +280,10 @@ symbols! {\n         format_args_nl,\n         from,\n         From,\n+        from_desugaring,\n         from_error,\n         from_generator,\n+        from_method,\n         from_ok,\n         from_usize,\n         fundamental,\n@@ -443,6 +447,7 @@ symbols! {\n         panic_impl,\n         panic_implementation,\n         panic_runtime,\n+        parent_trait,\n         partial_cmp,\n         PartialOrd,\n         passes,\n@@ -569,6 +574,7 @@ symbols! {\n         __rust_unstable_column,\n         rvalue_static_promotion,\n         sanitizer_runtime,\n+        _Self,\n         self_in_typedefs,\n         self_struct_ctor,\n         Send,"}]}