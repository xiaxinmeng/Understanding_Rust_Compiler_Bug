{"sha": "daceedf314f882f07f040a78dde173c3b12ad6bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhY2VlZGYzMTRmODgyZjA3ZjA0MGE3OGRkZTE3M2MzYjEyYWQ2YmQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-05T10:52:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-11-16T10:57:42Z"}, "message": "region_inference: rustfmt", "tree": {"sha": "6c1d1c3ee4f739e75a20f7c68282b78757e18767", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c1d1c3ee4f739e75a20f7c68282b78757e18767"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/daceedf314f882f07f040a78dde173c3b12ad6bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/daceedf314f882f07f040a78dde173c3b12ad6bd", "html_url": "https://github.com/rust-lang/rust/commit/daceedf314f882f07f040a78dde173c3b12ad6bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/daceedf314f882f07f040a78dde173c3b12ad6bd/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "url": "https://api.github.com/repos/rust-lang/rust/commits/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da", "html_url": "https://github.com/rust-lang/rust/commit/ec48b018d6c9e8e24be70f7c7a1ef8afc1cdc5da"}], "stats": {"total": 335, "additions": 188, "deletions": 147}, "files": [{"sha": "c1518ddeda57ce0ab3d91678ee69b25df9344f25", "filename": "src/librustc/infer/region_inference/mod.rs", "status": "modified", "additions": 188, "deletions": 147, "changes": 335, "blob_url": "https://github.com/rust-lang/rust/blob/daceedf314f882f07f040a78dde173c3b12ad6bd/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/daceedf314f882f07f040a78dde173c3b12ad6bd/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_inference%2Fmod.rs?ref=daceedf314f882f07f040a78dde173c3b12ad6bd", "patch": "@@ -13,15 +13,15 @@\n use self::UndoLogEntry::*;\n use self::CombineMapType::*;\n \n-use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n+use super::{MiscVariable, RegionVariableOrigin, SubregionOrigin};\n use super::unify_key;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::unify::{self, UnificationTable};\n use ty::{self, Ty, TyCtxt};\n use ty::{Region, RegionVid};\n use ty::ReStatic;\n-use ty::{ReLateBound, ReVar, ReSkolemized, BrFresh};\n+use ty::{BrFresh, ReLateBound, ReSkolemized, ReVar};\n \n use std::collections::BTreeMap;\n use std::cell::{Cell, RefCell};\n@@ -144,7 +144,7 @@ enum CombineMapType {\n \n type CombineMap<'tcx> = FxHashMap<TwoRegions<'tcx>, RegionVid>;\n \n-pub struct RegionVarBindings<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+pub struct RegionVarBindings<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     pub(in infer) tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     pub(in infer) var_origins: RefCell<Vec<RegionVariableOrigin>>,\n \n@@ -223,15 +223,24 @@ pub struct TaintDirections {\n \n impl TaintDirections {\n     pub fn incoming() -> Self {\n-        TaintDirections { incoming: true, outgoing: false }\n+        TaintDirections {\n+            incoming: true,\n+            outgoing: false,\n+        }\n     }\n \n     pub fn outgoing() -> Self {\n-        TaintDirections { incoming: false, outgoing: true }\n+        TaintDirections {\n+            incoming: false,\n+            outgoing: true,\n+        }\n     }\n \n     pub fn both() -> Self {\n-        TaintDirections { incoming: true, outgoing: true }\n+        TaintDirections {\n+            incoming: true,\n+            outgoing: true,\n+        }\n     }\n }\n \n@@ -271,18 +280,22 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         debug!(\"RegionVarBindings: commit({})\", snapshot.length);\n         assert!(self.undo_log.borrow().len() > snapshot.length);\n         assert!((*self.undo_log.borrow())[snapshot.length] == OpenSnapshot);\n-        assert!(self.skolemization_count.get() == snapshot.skolemization_count,\n-                \"failed to pop skolemized regions: {} now vs {} at start\",\n-                self.skolemization_count.get(),\n-                snapshot.skolemization_count);\n+        assert!(\n+            self.skolemization_count.get() == snapshot.skolemization_count,\n+            \"failed to pop skolemized regions: {} now vs {} at start\",\n+            self.skolemization_count.get(),\n+            snapshot.skolemization_count\n+        );\n \n         let mut undo_log = self.undo_log.borrow_mut();\n         if snapshot.length == 0 {\n             undo_log.truncate(0);\n         } else {\n             (*undo_log)[snapshot.length] = CommitedSnapshot;\n         }\n-        self.unification_table.borrow_mut().commit(snapshot.region_snapshot);\n+        self.unification_table\n+            .borrow_mut()\n+            .commit(snapshot.region_snapshot);\n     }\n \n     pub fn rollback_to(&self, snapshot: RegionSnapshot) {\n@@ -296,7 +309,8 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         let c = undo_log.pop().unwrap();\n         assert!(c == OpenSnapshot);\n         self.skolemization_count.set(snapshot.skolemization_count);\n-        self.unification_table.borrow_mut()\n+        self.unification_table\n+            .borrow_mut()\n             .rollback_to(snapshot.region_snapshot);\n     }\n \n@@ -340,19 +354,23 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn new_region_var(&self, origin: RegionVariableOrigin) -> RegionVid {\n-        let vid = RegionVid { index: self.num_vars() };\n+        let vid = RegionVid {\n+            index: self.num_vars(),\n+        };\n         self.var_origins.borrow_mut().push(origin.clone());\n \n-        let u_vid = self.unification_table.borrow_mut().new_key(\n-            unify_key::RegionVidKey { min_vid: vid }\n-            );\n+        let u_vid = self.unification_table\n+            .borrow_mut()\n+            .new_key(unify_key::RegionVidKey { min_vid: vid });\n         assert_eq!(vid, u_vid);\n         if self.in_snapshot() {\n             self.undo_log.borrow_mut().push(AddVar(vid));\n         }\n-        debug!(\"created new region variable {:?} with origin {:?}\",\n-               vid,\n-               origin);\n+        debug!(\n+            \"created new region variable {:?} with origin {:?}\",\n+            vid,\n+            origin\n+        );\n         return vid;\n     }\n \n@@ -379,42 +397,44 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// The `snapshot` argument to this function is not really used;\n     /// it's just there to make it explicit which snapshot bounds the\n     /// skolemized region that results. It should always be the top-most snapshot.\n-    pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot)\n-                           -> Region<'tcx> {\n+    pub fn push_skolemized(&self, br: ty::BoundRegion, snapshot: &RegionSnapshot) -> Region<'tcx> {\n         assert!(self.in_snapshot());\n         assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n \n         let sc = self.skolemization_count.get();\n         self.skolemization_count.set(sc + 1);\n-        self.tcx.mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n+        self.tcx\n+            .mk_region(ReSkolemized(ty::SkolemizedRegionVid { index: sc }, br))\n     }\n \n     /// Removes all the edges to/from the skolemized regions that are\n     /// in `skols`. This is used after a higher-ranked operation\n     /// completes to remove all trace of the skolemized regions\n     /// created in that time.\n-    pub fn pop_skolemized(&self,\n-                          skols: &FxHashSet<ty::Region<'tcx>>,\n-                          snapshot: &RegionSnapshot) {\n+    pub fn pop_skolemized(&self, skols: &FxHashSet<ty::Region<'tcx>>, snapshot: &RegionSnapshot) {\n         debug!(\"pop_skolemized_regions(skols={:?})\", skols);\n \n         assert!(self.in_snapshot());\n         assert!(self.undo_log.borrow()[snapshot.length] == OpenSnapshot);\n-        assert!(self.skolemization_count.get() as usize >= skols.len(),\n-                \"popping more skolemized variables than actually exist, \\\n-                 sc now = {}, skols.len = {}\",\n-                self.skolemization_count.get(),\n-                skols.len());\n+        assert!(\n+            self.skolemization_count.get() as usize >= skols.len(),\n+            \"popping more skolemized variables than actually exist, \\\n+             sc now = {}, skols.len = {}\",\n+            self.skolemization_count.get(),\n+            skols.len()\n+        );\n \n         let last_to_pop = self.skolemization_count.get();\n         let first_to_pop = last_to_pop - (skols.len() as u32);\n \n-        assert!(first_to_pop >= snapshot.skolemization_count,\n-                \"popping more regions than snapshot contains, \\\n-                 sc now = {}, sc then = {}, skols.len = {}\",\n-                self.skolemization_count.get(),\n-                snapshot.skolemization_count,\n-                skols.len());\n+        assert!(\n+            first_to_pop >= snapshot.skolemization_count,\n+            \"popping more regions than snapshot contains, \\\n+             sc now = {}, sc then = {}, skols.len = {}\",\n+            self.skolemization_count.get(),\n+            snapshot.skolemization_count,\n+            skols.len()\n+        );\n         debug_assert! {\n             skols.iter()\n                  .all(|&k| match *k {\n@@ -432,13 +452,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         let mut undo_log = self.undo_log.borrow_mut();\n \n-        let constraints_to_kill: Vec<usize> =\n-            undo_log.iter()\n-                    .enumerate()\n-                    .rev()\n-                    .filter(|&(_, undo_entry)| kill_constraint(skols, undo_entry))\n-                    .map(|(index, _)| index)\n-                    .collect();\n+        let constraints_to_kill: Vec<usize> = undo_log\n+            .iter()\n+            .enumerate()\n+            .rev()\n+            .filter(|&(_, undo_entry)| kill_constraint(skols, undo_entry))\n+            .map(|(index, _)| index)\n+            .collect();\n \n         for index in constraints_to_kill {\n             let undo_entry = mem::replace(&mut undo_log[index], Purged);\n@@ -448,33 +468,25 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         self.skolemization_count.set(snapshot.skolemization_count);\n         return;\n \n-        fn kill_constraint<'tcx>(skols: &FxHashSet<ty::Region<'tcx>>,\n-                                 undo_entry: &UndoLogEntry<'tcx>)\n-                                 -> bool {\n+        fn kill_constraint<'tcx>(\n+            skols: &FxHashSet<ty::Region<'tcx>>,\n+            undo_entry: &UndoLogEntry<'tcx>,\n+        ) -> bool {\n             match undo_entry {\n-                &AddConstraint(Constraint::VarSubVar(..)) =>\n-                    false,\n-                &AddConstraint(Constraint::RegSubVar(a, _)) =>\n-                    skols.contains(&a),\n-                &AddConstraint(Constraint::VarSubReg(_, b)) =>\n-                    skols.contains(&b),\n-                &AddConstraint(Constraint::RegSubReg(a, b)) =>\n-                    skols.contains(&a) || skols.contains(&b),\n-                &AddGiven(..) =>\n-                    false,\n-                &AddVerify(_) =>\n-                    false,\n-                &AddCombination(_, ref two_regions) =>\n-                    skols.contains(&two_regions.a) ||\n-                    skols.contains(&two_regions.b),\n-                &AddVar(..) |\n-                &OpenSnapshot |\n-                &Purged |\n-                &CommitedSnapshot =>\n-                    false,\n+                &AddConstraint(Constraint::VarSubVar(..)) => false,\n+                &AddConstraint(Constraint::RegSubVar(a, _)) => skols.contains(&a),\n+                &AddConstraint(Constraint::VarSubReg(_, b)) => skols.contains(&b),\n+                &AddConstraint(Constraint::RegSubReg(a, b)) => {\n+                    skols.contains(&a) || skols.contains(&b)\n+                }\n+                &AddGiven(..) => false,\n+                &AddVerify(_) => false,\n+                &AddCombination(_, ref two_regions) => {\n+                    skols.contains(&two_regions.a) || skols.contains(&two_regions.b)\n+                }\n+                &AddVar(..) | &OpenSnapshot | &Purged | &CommitedSnapshot => false,\n             }\n         }\n-\n     }\n \n     pub fn new_bound(&self, debruijn: ty::DebruijnIndex) -> Region<'tcx> {\n@@ -513,12 +525,15 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         // never overwrite an existing (constraint, origin) - only insert one if it isn't\n         // present in the map yet. This prevents origins from outside the snapshot being\n         // replaced with \"less informative\" origins e.g. during calls to `can_eq`\n-        self.constraints.borrow_mut().entry(constraint).or_insert_with(|| {\n-            if self.in_snapshot() {\n-                self.undo_log.borrow_mut().push(AddConstraint(constraint));\n-            }\n-            origin\n-        });\n+        self.constraints\n+            .borrow_mut()\n+            .entry(constraint)\n+            .or_insert_with(|| {\n+                if self.in_snapshot() {\n+                    self.undo_log.borrow_mut().push(AddConstraint(constraint));\n+                }\n+                origin\n+            });\n     }\n \n     fn add_verify(&self, verify: Verify<'tcx>) {\n@@ -527,8 +542,10 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n \n         // skip no-op cases known to be satisfied\n         match verify.bound {\n-            VerifyBound::AllBounds(ref bs) if bs.len() == 0 => { return; }\n-            _ => { }\n+            VerifyBound::AllBounds(ref bs) if bs.len() == 0 => {\n+                return;\n+            }\n+            _ => {}\n         }\n \n         let mut verifys = self.verifys.borrow_mut();\n@@ -549,10 +566,12 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn make_eqregion(&self,\n-                         origin: SubregionOrigin<'tcx>,\n-                         sub: Region<'tcx>,\n-                         sup: Region<'tcx>) {\n+    pub fn make_eqregion(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) {\n         if sub != sup {\n             // Eventually, it would be nice to add direct support for\n             // equating regions.\n@@ -565,23 +584,28 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn make_subregion(&self,\n-                          origin: SubregionOrigin<'tcx>,\n-                          sub: Region<'tcx>,\n-                          sup: Region<'tcx>) {\n+    pub fn make_subregion(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        sub: Region<'tcx>,\n+        sup: Region<'tcx>,\n+    ) {\n         // cannot add constraints once regions are resolved\n-        debug!(\"RegionVarBindings: make_subregion({:?}, {:?}) due to {:?}\",\n-               sub,\n-               sup,\n-               origin);\n+        debug!(\n+            \"RegionVarBindings: make_subregion({:?}, {:?}) due to {:?}\",\n+            sub,\n+            sup,\n+            origin\n+        );\n \n         match (sub, sup) {\n-            (&ReLateBound(..), _) |\n-            (_, &ReLateBound(..)) => {\n-                span_bug!(origin.span(),\n-                          \"cannot relate bound region: {:?} <= {:?}\",\n-                          sub,\n-                          sup);\n+            (&ReLateBound(..), _) | (_, &ReLateBound(..)) => {\n+                span_bug!(\n+                    origin.span(),\n+                    \"cannot relate bound region: {:?} <= {:?}\",\n+                    sub,\n+                    sup\n+                );\n             }\n             (_, &ReStatic) => {\n                 // all regions are subregions of static, so we can ignore this\n@@ -602,11 +626,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     }\n \n     /// See `Verify::VerifyGenericBound`\n-    pub fn verify_generic_bound(&self,\n-                                origin: SubregionOrigin<'tcx>,\n-                                kind: GenericKind<'tcx>,\n-                                sub: Region<'tcx>,\n-                                bound: VerifyBound<'tcx>) {\n+    pub fn verify_generic_bound(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        kind: GenericKind<'tcx>,\n+        sub: Region<'tcx>,\n+        bound: VerifyBound<'tcx>,\n+    ) {\n         self.add_verify(Verify {\n             kind,\n             origin,\n@@ -615,11 +641,12 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         });\n     }\n \n-    pub fn lub_regions(&self,\n-                       origin: SubregionOrigin<'tcx>,\n-                       a: Region<'tcx>,\n-                       b: Region<'tcx>)\n-                       -> Region<'tcx> {\n+    pub fn lub_regions(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        a: Region<'tcx>,\n+        b: Region<'tcx>,\n+    ) -> Region<'tcx> {\n         // cannot add constraints once regions are resolved\n         debug!(\"RegionVarBindings: lub_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n@@ -631,19 +658,22 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 a // LUB(a,a) = a\n             }\n \n-            _ => {\n-                self.combine_vars(Lub, a, b, origin.clone(), |this, old_r, new_r| {\n-                    this.make_subregion(origin.clone(), old_r, new_r)\n-                })\n-            }\n+            _ => self.combine_vars(\n+                Lub,\n+                a,\n+                b,\n+                origin.clone(),\n+                |this, old_r, new_r| this.make_subregion(origin.clone(), old_r, new_r),\n+            ),\n         }\n     }\n \n-    pub fn glb_regions(&self,\n-                       origin: SubregionOrigin<'tcx>,\n-                       a: Region<'tcx>,\n-                       b: Region<'tcx>)\n-                       -> Region<'tcx> {\n+    pub fn glb_regions(\n+        &self,\n+        origin: SubregionOrigin<'tcx>,\n+        a: Region<'tcx>,\n+        b: Region<'tcx>,\n+    ) -> Region<'tcx> {\n         // cannot add constraints once regions are resolved\n         debug!(\"RegionVarBindings: glb_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n@@ -655,11 +685,13 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n                 a // GLB(a,a) = a\n             }\n \n-            _ => {\n-                self.combine_vars(Glb, a, b, origin.clone(), |this, old_r, new_r| {\n-                    this.make_subregion(origin.clone(), new_r, old_r)\n-                })\n-            }\n+            _ => self.combine_vars(\n+                Glb,\n+                a,\n+                b,\n+                origin.clone(),\n+                |this, old_r, new_r| this.make_subregion(origin.clone(), new_r, old_r),\n+            ),\n         }\n     }\n \n@@ -675,14 +707,16 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn combine_vars<F>(&self,\n-                       t: CombineMapType,\n-                       a: Region<'tcx>,\n-                       b: Region<'tcx>,\n-                       origin: SubregionOrigin<'tcx>,\n-                       mut relate: F)\n-                       -> Region<'tcx>\n-        where F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region<'tcx>, Region<'tcx>)\n+    fn combine_vars<F>(\n+        &self,\n+        t: CombineMapType,\n+        a: Region<'tcx>,\n+        b: Region<'tcx>,\n+        origin: SubregionOrigin<'tcx>,\n+        mut relate: F,\n+    ) -> Region<'tcx>\n+    where\n+        F: FnMut(&RegionVarBindings<'a, 'gcx, 'tcx>, Region<'tcx>, Region<'tcx>),\n     {\n         let vars = TwoRegions { a: a, b: b };\n         if let Some(&c) = self.combine_map(t).borrow().get(&vars) {\n@@ -702,11 +736,9 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     pub fn vars_created_since_snapshot(&self, mark: &RegionSnapshot) -> Vec<RegionVid> {\n         self.undo_log.borrow()[mark.length..]\n             .iter()\n-            .filter_map(|&elt| {\n-                match elt {\n-                    AddVar(vid) => Some(vid),\n-                    _ => None,\n-                }\n+            .filter_map(|&elt| match elt {\n+                AddVar(vid) => Some(vid),\n+                _ => None,\n             })\n             .collect()\n     }\n@@ -719,30 +751,41 @@ impl<'a, 'gcx, 'tcx> RegionVarBindings<'a, 'gcx, 'tcx> {\n     /// get the set of regions `{r|r <= r0}`. This is used when\n     /// checking whether skolemized regions are being improperly\n     /// related to other regions.\n-    pub fn tainted(&self,\n-                   mark: &RegionSnapshot,\n-                   r0: Region<'tcx>,\n-                   directions: TaintDirections)\n-                   -> FxHashSet<ty::Region<'tcx>> {\n-        debug!(\"tainted(mark={:?}, r0={:?}, directions={:?})\",\n-               mark, r0, directions);\n+    pub fn tainted(\n+        &self,\n+        mark: &RegionSnapshot,\n+        r0: Region<'tcx>,\n+        directions: TaintDirections,\n+    ) -> FxHashSet<ty::Region<'tcx>> {\n+        debug!(\n+            \"tainted(mark={:?}, r0={:?}, directions={:?})\",\n+            mark,\n+            r0,\n+            directions\n+        );\n \n         // `result_set` acts as a worklist: we explore all outgoing\n         // edges and add any new regions we find to result_set.  This\n         // is not a terribly efficient implementation.\n         let mut taint_set = taint::TaintSet::new(directions, r0);\n-        taint_set.fixed_point(self.tcx,\n-                              &self.undo_log.borrow()[mark.length..],\n-                              &self.verifys.borrow());\n+        taint_set.fixed_point(\n+            self.tcx,\n+            &self.undo_log.borrow()[mark.length..],\n+            &self.verifys.borrow(),\n+        );\n         debug!(\"tainted: result={:?}\", taint_set);\n         return taint_set.into_set();\n     }\n }\n \n impl fmt::Debug for RegionSnapshot {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"RegionSnapshot(length={},skolemization={})\",\n-               self.length, self.skolemization_count)\n+        write!(\n+            f,\n+            \"RegionSnapshot(length={},skolemization={})\",\n+            self.length,\n+            self.skolemization_count\n+        )\n     }\n }\n \n@@ -776,13 +819,11 @@ impl<'a, 'gcx, 'tcx> GenericKind<'tcx> {\n impl<'a, 'gcx, 'tcx> VerifyBound<'tcx> {\n     fn for_each_region(&self, f: &mut FnMut(ty::Region<'tcx>)) {\n         match self {\n-            &VerifyBound::AnyRegion(ref rs) |\n-            &VerifyBound::AllRegions(ref rs) => for &r in rs {\n+            &VerifyBound::AnyRegion(ref rs) | &VerifyBound::AllRegions(ref rs) => for &r in rs {\n                 f(r);\n             },\n \n-            &VerifyBound::AnyBound(ref bs) |\n-            &VerifyBound::AllBounds(ref bs) => for b in bs {\n+            &VerifyBound::AnyBound(ref bs) | &VerifyBound::AllBounds(ref bs) => for b in bs {\n                 b.for_each_region(f);\n             },\n         }"}]}