{"sha": "0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "node_id": "C_kwDOAAsO6NoAKDBiNDlkMDVlYTMzZDY4MzkxZTNkNTQ3MmYzMzk4ZDBhZDFkOWY5YTY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-20T19:02:18Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-03-20T19:36:26Z"}, "message": "Filter OnceNote in diagnostic infra.", "tree": {"sha": "29a5bae15a0ce8bbc268c68c8e12a047a4481234", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29a5bae15a0ce8bbc268c68c8e12a047a4481234"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "html_url": "https://github.com/rust-lang/rust/commit/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "056951d6289e3fbba444cbadec8b4eea7f92928e", "url": "https://api.github.com/repos/rust-lang/rust/commits/056951d6289e3fbba444cbadec8b4eea7f92928e", "html_url": "https://github.com/rust-lang/rust/commit/056951d6289e3fbba444cbadec8b4eea7f92928e"}], "stats": {"total": 465, "additions": 183, "deletions": 282}, "files": [{"sha": "5f59eba23f8e9317a5a648d36e314262250178e5", "filename": "compiler/rustc_errors/src/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fannotate_snippet_emitter_writer.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -70,7 +70,7 @@ fn annotation_type_for_level(level: Level) -> AnnotationType {\n             AnnotationType::Error\n         }\n         Level::Warning => AnnotationType::Warning,\n-        Level::Note => AnnotationType::Note,\n+        Level::Note | Level::OnceNote => AnnotationType::Note,\n         Level::Help => AnnotationType::Help,\n         // FIXME(#59346): Not sure how to map this level\n         Level::FailureNote => AnnotationType::Error,"}, {"sha": "00ecbbbb93b985eba7881fbde966f0bae74cb1cf", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -135,7 +135,12 @@ impl Diagnostic {\n             | Level::Error { .. }\n             | Level::FailureNote => true,\n \n-            Level::Warning | Level::Note | Level::Help | Level::Allow | Level::Expect(_) => false,\n+            Level::Warning\n+            | Level::Note\n+            | Level::OnceNote\n+            | Level::Help\n+            | Level::Allow\n+            | Level::Expect(_) => false,\n         }\n     }\n \n@@ -333,13 +338,27 @@ impl Diagnostic {\n         self\n     }\n \n+    /// Prints the span with a note above it.\n+    /// This is like [`Diagnostic::note()`], but it gets its own span.\n+    pub fn note_once(&mut self, msg: &str) -> &mut Self {\n+        self.sub(Level::OnceNote, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n     /// Prints the span with a note above it.\n     /// This is like [`Diagnostic::note()`], but it gets its own span.\n     pub fn span_note<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n         self.sub(Level::Note, msg, sp.into(), None);\n         self\n     }\n \n+    /// Prints the span with a note above it.\n+    /// This is like [`Diagnostic::note()`], but it gets its own span.\n+    pub fn span_note_once<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self {\n+        self.sub(Level::OnceNote, msg, sp.into(), None);\n+        self\n+    }\n+\n     /// Add a warning attached to this diagnostic.\n     pub fn warn(&mut self, msg: &str) -> &mut Self {\n         self.sub(Level::Warning, msg, MultiSpan::new(), None);"}, {"sha": "088f6091528934291f0ba8513faa6e6a7a9dff9e", "filename": "compiler/rustc_errors/src/diagnostic_builder.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_builder.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -396,11 +396,17 @@ impl<'a, G: EmissionGuarantee> DiagnosticBuilder<'a, G> {\n     ) -> &mut Self);\n \n     forward!(pub fn note(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn note_once(&mut self, msg: &str) -> &mut Self);\n     forward!(pub fn span_note(\n         &mut self,\n         sp: impl Into<MultiSpan>,\n         msg: &str,\n     ) -> &mut Self);\n+    forward!(pub fn span_note_once(\n+        &mut self,\n+        sp: impl Into<MultiSpan>,\n+        msg: &str,\n+    ) -> &mut Self);\n     forward!(pub fn warn(&mut self, msg: &str) -> &mut Self);\n     forward!(pub fn span_warn(&mut self, sp: impl Into<MultiSpan>, msg: &str) -> &mut Self);\n     forward!(pub fn help(&mut self, msg: &str) -> &mut Self);"}, {"sha": "2f2f6ed1a5afeae204a2b392033a0eccb3b5f860", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -4,6 +4,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n+#![feature(drain_filter)]\n #![feature(backtrace)]\n #![feature(if_let_guard)]\n #![feature(let_else)]\n@@ -1070,7 +1071,23 @@ impl HandlerInner {\n         // Only emit the diagnostic if we've been asked to deduplicate and\n         // haven't already emitted an equivalent diagnostic.\n         if !(self.flags.deduplicate_diagnostics && already_emitted(self)) {\n-            self.emitter.emit_diagnostic(diagnostic);\n+            debug!(?diagnostic);\n+            debug!(?self.emitted_diagnostics);\n+            let already_emitted_sub = |sub: &mut SubDiagnostic| {\n+                debug!(?sub);\n+                if sub.level != Level::OnceNote {\n+                    return false;\n+                }\n+                let mut hasher = StableHasher::new();\n+                sub.hash(&mut hasher);\n+                let diagnostic_hash = hasher.finish();\n+                debug!(?diagnostic_hash);\n+                !self.emitted_diagnostics.insert(diagnostic_hash)\n+            };\n+\n+            diagnostic.children.drain_filter(already_emitted_sub).for_each(|_| {});\n+\n+            self.emitter.emit_diagnostic(&diagnostic);\n             if diagnostic.is_error() {\n                 self.deduplicated_err_count += 1;\n             } else if diagnostic.level == Warning {\n@@ -1350,6 +1367,8 @@ pub enum Level {\n     },\n     Warning,\n     Note,\n+    /// A note that is only emitted once.\n+    OnceNote,\n     Help,\n     FailureNote,\n     Allow,\n@@ -1372,7 +1391,7 @@ impl Level {\n             Warning => {\n                 spec.set_fg(Some(Color::Yellow)).set_intense(cfg!(windows));\n             }\n-            Note => {\n+            Note | OnceNote => {\n                 spec.set_fg(Some(Color::Green)).set_intense(true);\n             }\n             Help => {\n@@ -1389,7 +1408,7 @@ impl Level {\n             Bug | DelayedBug => \"error: internal compiler error\",\n             Fatal | Error { .. } => \"error\",\n             Warning => \"warning\",\n-            Note => \"note\",\n+            Note | OnceNote => \"note\",\n             Help => \"help\",\n             FailureNote => \"failure-note\",\n             Allow => panic!(\"Shouldn't call on allowed error\"),"}, {"sha": "1f0cd907f8aceda2b4cb9254f5f484e4b3ab66e2", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 16, "deletions": 38, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -12,7 +12,7 @@ use rustc_session::lint::{\n     builtin::{self, FORBIDDEN_LINT_GROUPS},\n     FutureIncompatibilityReason, Level, Lint, LintExpectationId, LintId,\n };\n-use rustc_session::{DiagnosticMessageId, Session};\n+use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::{DesugaringKind, ExpnKind, MultiSpan};\n use rustc_span::{symbol, Span, Symbol, DUMMY_SP};\n@@ -245,7 +245,6 @@ impl<'a> LintDiagnosticBuilder<'a, ErrorGuaranteed> {\n }\n \n pub fn explain_lint_level_source(\n-    sess: &Session,\n     lint: &'static Lint,\n     level: Level,\n     src: LintLevelSource,\n@@ -254,11 +253,7 @@ pub fn explain_lint_level_source(\n     let name = lint.name_lower();\n     match src {\n         LintLevelSource::Default => {\n-            sess.diag_note_once(\n-                err,\n-                DiagnosticMessageId::from(lint),\n-                &format!(\"`#[{}({})]` on by default\", level.as_str(), name),\n-            );\n+            err.note_once(&format!(\"`#[{}({})]` on by default\", level.as_str(), name));\n         }\n         LintLevelSource::CommandLine(lint_flag_val, orig_level) => {\n             let flag = match orig_level {\n@@ -273,46 +268,29 @@ pub fn explain_lint_level_source(\n             };\n             let hyphen_case_lint_name = name.replace('_', \"-\");\n             if lint_flag_val.as_str() == name {\n-                sess.diag_note_once(\n-                    err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"requested on the command line with `{} {}`\",\n-                        flag, hyphen_case_lint_name\n-                    ),\n-                );\n+                err.note_once(&format!(\n+                    \"requested on the command line with `{} {}`\",\n+                    flag, hyphen_case_lint_name\n+                ));\n             } else {\n                 let hyphen_case_flag_val = lint_flag_val.as_str().replace('_', \"-\");\n-                sess.diag_note_once(\n-                    err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`{} {}` implied by `{} {}`\",\n-                        flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n-                    ),\n-                );\n+                err.note_once(&format!(\n+                    \"`{} {}` implied by `{} {}`\",\n+                    flag, hyphen_case_lint_name, flag, hyphen_case_flag_val\n+                ));\n             }\n         }\n         LintLevelSource::Node(lint_attr_name, src, reason) => {\n             if let Some(rationale) = reason {\n                 err.note(rationale.as_str());\n             }\n-            sess.diag_span_note_once(\n-                err,\n-                DiagnosticMessageId::from(lint),\n-                src,\n-                \"the lint level is defined here\",\n-            );\n+            err.span_note_once(src, \"the lint level is defined here\");\n             if lint_attr_name.as_str() != name {\n                 let level_str = level.as_str();\n-                sess.diag_note_once(\n-                    err,\n-                    DiagnosticMessageId::from(lint),\n-                    &format!(\n-                        \"`#[{}({})]` implied by `#[{}({})]`\",\n-                        level_str, name, level_str, lint_attr_name\n-                    ),\n-                );\n+                err.note_once(&format!(\n+                    \"`#[{}({})]` implied by `#[{}({})]`\",\n+                    level_str, name, level_str, lint_attr_name\n+                ));\n             }\n         }\n     }\n@@ -412,7 +390,7 @@ pub fn struct_lint_level<'s, 'd>(\n             return;\n         }\n \n-        explain_lint_level_source(sess, lint, level, src, &mut err);\n+        explain_lint_level_source(lint, level, src, &mut err);\n \n         let name = lint.name_lower();\n         let is_force_warn = matches!(level, Level::ForceWarn);"}, {"sha": "fd6e241346db8e9aeddada8789c59fac6736f03d", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 10, "deletions": 25, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -17,9 +17,9 @@ use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_session::lint::builtin::{DEPRECATED, DEPRECATED_IN_FUTURE, SOFT_UNSTABLE};\n use rustc_session::lint::{BuiltinLintDiagnostics, Level, Lint, LintBuffer};\n use rustc_session::parse::feature_err_issue;\n-use rustc_session::{DiagnosticMessageId, Session};\n+use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{MultiSpan, Span};\n+use rustc_span::Span;\n use std::num::NonZeroU32;\n \n #[derive(PartialEq, Clone, Copy, Debug)]\n@@ -94,30 +94,15 @@ pub fn report_unstable(\n         None => format!(\"use of unstable library feature '{}'\", &feature),\n     };\n \n-    let msp: MultiSpan = span.into();\n-    let sm = &sess.parse_sess.source_map();\n-    let span_key = msp.primary_span().and_then(|sp: Span| {\n-        if !sp.is_dummy() {\n-            let file = sm.lookup_char_pos(sp.lo()).file;\n-            if file.is_imported() { None } else { Some(span) }\n-        } else {\n-            None\n-        }\n-    });\n-\n-    let error_id = (DiagnosticMessageId::StabilityId(issue), span_key, msg.clone());\n-    let fresh = sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-    if fresh {\n-        if is_soft {\n-            soft_handler(SOFT_UNSTABLE, span, &msg)\n-        } else {\n-            let mut err =\n-                feature_err_issue(&sess.parse_sess, feature, span, GateIssue::Library(issue), &msg);\n-            if let Some((inner_types, ref msg, sugg, applicability)) = suggestion {\n-                err.span_suggestion(inner_types, msg, sugg, applicability);\n-            }\n-            err.emit();\n+    if is_soft {\n+        soft_handler(SOFT_UNSTABLE, span, &msg)\n+    } else {\n+        let mut err =\n+            feature_err_issue(&sess.parse_sess, feature, span, GateIssue::Library(issue), &msg);\n+        if let Some((inner_types, ref msg, sugg, applicability)) = suggestion {\n+            err.span_suggestion(inner_types, msg, sugg, applicability);\n         }\n+        err.emit();\n     }\n }\n "}, {"sha": "8de05990cdf1dca992db8d1985f5cab5a49f1a01", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -554,7 +554,6 @@ fn report_unused_unsafe(tcx: TyCtxt<'_>, kind: UnusedUnsafe, id: HirId) {\n                     tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, usage_lint_root);\n                 assert_eq!(level, Level::Allow);\n                 lint::explain_lint_level_source(\n-                    tcx.sess,\n                     UNSAFE_OP_IN_UNSAFE_FN,\n                     Level::Allow,\n                     source,"}, {"sha": "4b2eea5c2cbd23099910b8f63f162522dc9e760b", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 1, "deletions": 73, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -19,7 +19,7 @@ use rustc_errors::annotate_snippet_emitter_writer::AnnotateSnippetEmitterWriter;\n use rustc_errors::emitter::{Emitter, EmitterWriter, HumanReadableErrorType};\n use rustc_errors::json::JsonEmitter;\n use rustc_errors::registry::Registry;\n-use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n+use rustc_errors::{DiagnosticBuilder, DiagnosticId, ErrorGuaranteed};\n use rustc_macros::HashStable_Generic;\n pub use rustc_span::def_id::StableCrateId;\n use rustc_span::edition::Edition;\n@@ -35,7 +35,6 @@ use std::cell::{self, RefCell};\n use std::env;\n use std::fmt;\n use std::io::Write;\n-use std::num::NonZeroU32;\n use std::ops::{Div, Mul};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n@@ -136,10 +135,6 @@ pub struct Session {\n     /// `None` means that there is no source file.\n     pub local_crate_source_file: Option<PathBuf>,\n \n-    /// Set of `(DiagnosticId, Option<Span>, message)` tuples tracking\n-    /// (sub)diagnostics that have been set once, but should not be set again,\n-    /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n-    pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n     crate_types: OnceCell<Vec<CrateType>>,\n     /// The `stable_crate_id` is constructed out of the crate name and all the\n     /// `-C metadata` arguments passed to the compiler. Its value forms a unique\n@@ -209,13 +204,6 @@ pub struct PerfStats {\n     pub normalize_projection_ty: AtomicUsize,\n }\n \n-/// Enum to support dispatch of one-time diagnostics (in `Session.diag_once`).\n-enum DiagnosticBuilderMethod {\n-    Note,\n-    SpanNote,\n-    // Add more variants as needed to support one-time diagnostics.\n-}\n-\n /// Trait implemented by error types. This should not be implemented manually. Instead, use\n /// `#[derive(SessionDiagnostic)]` -- see [rustc_macros::SessionDiagnostic].\n pub trait SessionDiagnostic<'a> {\n@@ -224,21 +212,6 @@ pub trait SessionDiagnostic<'a> {\n     fn into_diagnostic(self, sess: &'a Session) -> DiagnosticBuilder<'a, ErrorGuaranteed>;\n }\n \n-/// Diagnostic message ID, used by `Session.one_time_diagnostics` to avoid\n-/// emitting the same message more than once.\n-#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n-pub enum DiagnosticMessageId {\n-    ErrorId(u16), // EXXXX error code as integer\n-    LintId(lint::LintId),\n-    StabilityId(Option<NonZeroU32>), // issue number\n-}\n-\n-impl From<&'static lint::Lint> for DiagnosticMessageId {\n-    fn from(lint: &'static lint::Lint) -> Self {\n-        DiagnosticMessageId::LintId(lint::LintId::of(lint))\n-    }\n-}\n-\n impl Session {\n     pub fn miri_unleashed_feature(&self, span: Span, feature_gate: Option<Symbol>) {\n         self.miri_unleashed_features.lock().push((span, feature_gate));\n@@ -497,50 +470,6 @@ impl Session {\n         &self.parse_sess.span_diagnostic\n     }\n \n-    /// Analogous to calling methods on the given `DiagnosticBuilder`, but\n-    /// deduplicates on lint ID, span (if any), and message for this `Session`\n-    fn diag_once(\n-        &self,\n-        diag: &mut Diagnostic,\n-        method: DiagnosticBuilderMethod,\n-        msg_id: DiagnosticMessageId,\n-        message: &str,\n-        span_maybe: Option<Span>,\n-    ) {\n-        let id_span_message = (msg_id, span_maybe, message.to_owned());\n-        let fresh = self.one_time_diagnostics.borrow_mut().insert(id_span_message);\n-        if fresh {\n-            match method {\n-                DiagnosticBuilderMethod::Note => {\n-                    diag.note(message);\n-                }\n-                DiagnosticBuilderMethod::SpanNote => {\n-                    let span = span_maybe.expect(\"`span_note` needs a span\");\n-                    diag.span_note(span, message);\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn diag_span_note_once(\n-        &self,\n-        diag: &mut Diagnostic,\n-        msg_id: DiagnosticMessageId,\n-        span: Span,\n-        message: &str,\n-    ) {\n-        self.diag_once(diag, DiagnosticBuilderMethod::SpanNote, msg_id, message, Some(span));\n-    }\n-\n-    pub fn diag_note_once(\n-        &self,\n-        diag: &mut Diagnostic,\n-        msg_id: DiagnosticMessageId,\n-        message: &str,\n-    ) {\n-        self.diag_once(diag, DiagnosticBuilderMethod::Note, msg_id, message, None);\n-    }\n-\n     #[inline]\n     pub fn source_map(&self) -> &SourceMap {\n         self.parse_sess.source_map()\n@@ -1306,7 +1235,6 @@ pub fn build_session(\n         parse_sess,\n         sysroot,\n         local_crate_source_file,\n-        one_time_diagnostics: Default::default(),\n         crate_types: OnceCell::new(),\n         stable_crate_id: OnceCell::new(),\n         features: OnceCell::new(),"}, {"sha": "5b88cff03d7fe207172c11d4257aea9be85319a2", "filename": "compiler/rustc_trait_selection/src/autoderef.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fautoderef.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -5,7 +5,7 @@ use rustc_hir as hir;\n use rustc_infer::infer::InferCtxt;\n use rustc_middle::ty::{self, TraitRef, Ty, TyCtxt};\n use rustc_middle::ty::{ToPredicate, TypeFoldable};\n-use rustc_session::{DiagnosticMessageId, Limit};\n+use rustc_session::Limit;\n use rustc_span::def_id::LOCAL_CRATE;\n use rustc_span::Span;\n \n@@ -222,24 +222,19 @@ pub fn report_autoderef_recursion_limit_error<'tcx>(tcx: TyCtxt<'tcx>, span: Spa\n         Limit(0) => Limit(2),\n         limit => limit * 2,\n     };\n-    let msg = format!(\"reached the recursion limit while auto-dereferencing `{:?}`\", ty);\n-    let error_id = (DiagnosticMessageId::ErrorId(55), Some(span), msg);\n-    let fresh = tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-    if fresh {\n-        struct_span_err!(\n-            tcx.sess,\n-            span,\n-            E0055,\n-            \"reached the recursion limit while auto-dereferencing `{:?}`\",\n-            ty\n-        )\n-        .span_label(span, \"deref recursion limit reached\")\n-        .help(&format!(\n-            \"consider increasing the recursion limit by adding a \\\n+    struct_span_err!(\n+        tcx.sess,\n+        span,\n+        E0055,\n+        \"reached the recursion limit while auto-dereferencing `{:?}`\",\n+        ty\n+    )\n+    .span_label(span, \"deref recursion limit reached\")\n+    .help(&format!(\n+        \"consider increasing the recursion limit by adding a \\\n              `#![recursion_limit = \\\"{}\\\"]` attribute to your crate (`{}`)\",\n-            suggested_limit,\n-            tcx.crate_name(LOCAL_CRATE),\n-        ))\n-        .emit();\n-    }\n+        suggested_limit,\n+        tcx.crate_name(LOCAL_CRATE),\n+    ))\n+    .emit();\n }"}, {"sha": "e32d51420903e282da439ba76f920b859ee96b25", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -27,7 +27,6 @@ use rustc_middle::ty::fold::TypeFolder;\n use rustc_middle::ty::{\n     self, SubtypePredicate, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable,\n };\n-use rustc_session::DiagnosticMessageId;\n use rustc_span::symbol::{kw, sym};\n use rustc_span::{ExpnKind, MultiSpan, Span, DUMMY_SP};\n use std::fmt;\n@@ -1401,60 +1400,49 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            let msg = format!(\"type mismatch resolving `{}`\", predicate);\n-            let error_id = (DiagnosticMessageId::ErrorId(271), Some(obligation.cause.span), msg);\n-            let fresh = self.tcx.sess.one_time_diagnostics.borrow_mut().insert(error_id);\n-            if fresh {\n-                let mut diag = struct_span_err!(\n-                    self.tcx.sess,\n-                    obligation.cause.span,\n-                    E0271,\n-                    \"type mismatch resolving `{}`\",\n-                    predicate\n-                );\n-                let secondary_span = match predicate.kind().skip_binder() {\n-                    ty::PredicateKind::Projection(proj) => self\n-                        .tcx\n-                        .opt_associated_item(proj.projection_ty.item_def_id)\n-                        .and_then(|trait_assoc_item| {\n+            let mut diag = struct_span_err!(\n+                self.tcx.sess,\n+                obligation.cause.span,\n+                E0271,\n+                \"type mismatch resolving `{}`\",\n+                predicate\n+            );\n+            let secondary_span = match predicate.kind().skip_binder() {\n+                ty::PredicateKind::Projection(proj) => self\n+                    .tcx\n+                    .opt_associated_item(proj.projection_ty.item_def_id)\n+                    .and_then(|trait_assoc_item| {\n+                        self.tcx\n+                            .trait_of_item(proj.projection_ty.item_def_id)\n+                            .map(|id| (trait_assoc_item, id))\n+                    })\n+                    .and_then(|(trait_assoc_item, id)| {\n+                        let trait_assoc_ident = trait_assoc_item.ident(self.tcx);\n+                        self.tcx.find_map_relevant_impl(id, proj.projection_ty.self_ty(), |did| {\n                             self.tcx\n-                                .trait_of_item(proj.projection_ty.item_def_id)\n-                                .map(|id| (trait_assoc_item, id))\n-                        })\n-                        .and_then(|(trait_assoc_item, id)| {\n-                            let trait_assoc_ident = trait_assoc_item.ident(self.tcx);\n-                            self.tcx.find_map_relevant_impl(\n-                                id,\n-                                proj.projection_ty.self_ty(),\n-                                |did| {\n-                                    self.tcx\n-                                        .associated_items(did)\n-                                        .in_definition_order()\n-                                        .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n-                                },\n-                            )\n+                                .associated_items(did)\n+                                .in_definition_order()\n+                                .find(|assoc| assoc.ident(self.tcx) == trait_assoc_ident)\n                         })\n-                        .and_then(|item| match self.tcx.hir().get_if_local(item.def_id) {\n-                            Some(\n-                                hir::Node::TraitItem(hir::TraitItem {\n-                                    kind: hir::TraitItemKind::Type(_, Some(ty)),\n-                                    ..\n-                                })\n-                                | hir::Node::ImplItem(hir::ImplItem {\n-                                    kind: hir::ImplItemKind::TyAlias(ty),\n-                                    ..\n-                                }),\n-                            ) => {\n-                                Some((ty.span, format!(\"type mismatch resolving `{}`\", predicate)))\n-                            }\n-                            _ => None,\n-                        }),\n-                    _ => None,\n-                };\n-                self.note_type_err(&mut diag, &obligation.cause, secondary_span, values, err, true);\n-                self.note_obligation_cause(&mut diag, obligation);\n-                diag.emit();\n-            }\n+                    })\n+                    .and_then(|item| match self.tcx.hir().get_if_local(item.def_id) {\n+                        Some(\n+                            hir::Node::TraitItem(hir::TraitItem {\n+                                kind: hir::TraitItemKind::Type(_, Some(ty)),\n+                                ..\n+                            })\n+                            | hir::Node::ImplItem(hir::ImplItem {\n+                                kind: hir::ImplItemKind::TyAlias(ty),\n+                                ..\n+                            }),\n+                        ) => Some((ty.span, format!(\"type mismatch resolving `{}`\", predicate))),\n+                        _ => None,\n+                    }),\n+                _ => None,\n+            };\n+            self.note_type_err(&mut diag, &obligation.cause, secondary_span, values, err, true);\n+            self.note_obligation_cause(&mut diag, obligation);\n+            diag.emit();\n         });\n     }\n "}, {"sha": "d2f1c6e327192faddd660887042c8dde478aecfe", "filename": "src/test/ui/autoref-autoderef/issue-38940.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fautoref-autoderef%2Fissue-38940.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fautoref-autoderef%2Fissue-38940.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fautoref-autoderef%2Fissue-38940.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -2,8 +2,10 @@\n // Test that the recursion limit can be changed. In this case, we have\n // deeply nested types that will fail the `Send` check by overflow\n // when the recursion limit is set very low.\n+// compile-flags: -Zdeduplicate-diagnostics=yes\n+\n #![allow(dead_code)]\n-#![recursion_limit=\"10\"]\n+#![recursion_limit = \"10\"]\n macro_rules! link {\n     ($outer:ident, $inner:ident) => {\n         struct $outer($inner);\n@@ -18,14 +20,17 @@ macro_rules! link {\n                 &self.0\n             }\n         }\n-    }\n+    };\n }\n+\n struct Bottom;\n+\n impl Bottom {\n     fn new() -> Bottom {\n         Bottom\n     }\n }\n+\n link!(Top, A);\n link!(A, B);\n link!(B, C);\n@@ -38,6 +43,7 @@ link!(H, I);\n link!(I, J);\n link!(J, K);\n link!(K, Bottom);\n+\n fn main() {\n     let t = Top::new();\n     let x: &Bottom = &t;"}, {"sha": "f0b8405770e8d5c3a0fa793034a7711157079eee", "filename": "src/test/ui/autoref-autoderef/issue-38940.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fautoref-autoderef%2Fissue-38940.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fautoref-autoderef%2Fissue-38940.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fautoref-autoderef%2Fissue-38940.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -1,13 +1,13 @@\n error[E0055]: reached the recursion limit while auto-dereferencing `J`\n-  --> $DIR/issue-38940.rs:43:22\n+  --> $DIR/issue-38940.rs:49:22\n    |\n LL |     let x: &Bottom = &t;\n    |                      ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"20\"]` attribute to your crate (`issue_38940`)\n \n error[E0308]: mismatched types\n-  --> $DIR/issue-38940.rs:43:22\n+  --> $DIR/issue-38940.rs:49:22\n    |\n LL |     let x: &Bottom = &t;\n    |            -------   ^^ expected struct `Bottom`, found struct `Top`"}, {"sha": "7e767cba3cc970d1493f4f425522920552ba9ded", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/liveness.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -18,11 +18,6 @@ warning: unused variable: `a`\n LL |         a += 1;\n    |         ^\n    |\n-note: the lint level is defined here\n-  --> $DIR/liveness.rs:5:9\n-   |\n-LL | #![warn(unused)]\n-   |         ^^^^^^\n    = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n    = help: did you mean to capture by reference instead?\n "}, {"sha": "2ac801b49f1300403a990302e61047b1774b0337", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/liveness_unintentional_copy.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness_unintentional_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness_unintentional_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fliveness_unintentional_copy.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -18,11 +18,6 @@ warning: unused variable: `a`\n LL |         a = s;\n    |         ^\n    |\n-note: the lint level is defined here\n-  --> $DIR/liveness_unintentional_copy.rs:4:9\n-   |\n-LL | #![warn(unused)]\n-   |         ^^^^^^\n    = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n    = help: did you mean to capture by reference instead?\n "}, {"sha": "41bbca661ddf63cb92dbcaf8f542ea6088a40a60", "filename": "src/test/ui/did_you_mean/recursion_limit_deref.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -1,6 +1,7 @@\n // Test that the recursion limit can be changed and that the compiler\n // suggests a fix. In this case, we have a long chain of Deref impls\n // which will cause an overflow during the autoderef loop.\n+// compile-flags: -Zdeduplicate-diagnostics=yes\n \n #![allow(dead_code)]\n #![recursion_limit=\"10\"]"}, {"sha": "a6b5681a68cba3ef0402ee6cbf68e9f486faeb74", "filename": "src/test/ui/did_you_mean/recursion_limit_deref.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Frecursion_limit_deref.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -1,13 +1,13 @@\n error[E0055]: reached the recursion limit while auto-dereferencing `J`\n-  --> $DIR/recursion_limit_deref.rs:50:22\n+  --> $DIR/recursion_limit_deref.rs:51:22\n    |\n LL |     let x: &Bottom = &t;\n    |                      ^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"20\"]` attribute to your crate (`recursion_limit_deref`)\n \n error[E0308]: mismatched types\n-  --> $DIR/recursion_limit_deref.rs:50:22\n+  --> $DIR/recursion_limit_deref.rs:51:22\n    |\n LL |     let x: &Bottom = &t;\n    |            -------   ^^ expected struct `Bottom`, found struct `Top`"}, {"sha": "cbbe1f81df86f5606872f623a9402af2366b6a4c", "filename": "src/test/ui/infinite/infinite-autoderef.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -1,6 +1,5 @@\n // error-pattern: reached the recursion limit while auto-dereferencing\n-\n-\n+// compile-flags: -Zdeduplicate-diagnostics=yes\n \n use std::ops::Deref;\n "}, {"sha": "2e950dbb8c7f97a05436a15d6134615557345582", "filename": "src/test/ui/infinite/infinite-autoderef.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finfinite%2Finfinite-autoderef.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/infinite-autoderef.rs:20:13\n+  --> $DIR/infinite-autoderef.rs:19:13\n    |\n LL |         x = Box::new(x);\n    |             ^^^^^^^^^^^ cyclic type of infinite size\n@@ -10,37 +10,37 @@ LL |         x = *Box::new(x);\n    |             +\n \n error[E0055]: reached the recursion limit while auto-dereferencing `Foo`\n-  --> $DIR/infinite-autoderef.rs:25:5\n+  --> $DIR/infinite-autoderef.rs:24:5\n    |\n LL |     Foo.foo;\n    |     ^^^^^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`infinite_autoderef`)\n \n error[E0055]: reached the recursion limit while auto-dereferencing `Foo`\n-  --> $DIR/infinite-autoderef.rs:25:9\n+  --> $DIR/infinite-autoderef.rs:24:9\n    |\n LL |     Foo.foo;\n    |         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`infinite_autoderef`)\n \n error[E0609]: no field `foo` on type `Foo`\n-  --> $DIR/infinite-autoderef.rs:25:9\n+  --> $DIR/infinite-autoderef.rs:24:9\n    |\n LL |     Foo.foo;\n    |         ^^^ unknown field\n \n error[E0055]: reached the recursion limit while auto-dereferencing `Foo`\n-  --> $DIR/infinite-autoderef.rs:26:9\n+  --> $DIR/infinite-autoderef.rs:25:9\n    |\n LL |     Foo.bar();\n    |         ^^^ deref recursion limit reached\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`infinite_autoderef`)\n \n error[E0599]: no method named `bar` found for struct `Foo` in the current scope\n-  --> $DIR/infinite-autoderef.rs:26:9\n+  --> $DIR/infinite-autoderef.rs:25:9\n    |\n LL | struct Foo;\n    | ----------- method `bar` not found for this"}, {"sha": "a1213623e6f94f949190794dce7602ac6cbf83cf", "filename": "src/test/ui/issues/issue-33941.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.rs?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -1,6 +1,9 @@\n+// compile-flags: -Zdeduplicate-diagnostics=yes\n+\n use std::collections::HashMap;\n \n fn main() {\n     for _ in HashMap::new().iter().cloned() {} //~ ERROR type mismatch\n     //~^ ERROR type mismatch\n+    //~| ERROR type mismatch\n }"}, {"sha": "e1ce6eed98efb9028005c7049e28041aaa4a3437", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -1,5 +1,5 @@\n error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as Iterator>::Item == &_`\n-  --> $DIR/issue-33941.rs:4:36\n+  --> $DIR/issue-33941.rs:6:36\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}\n    |                                    ^^^^^^ expected reference, found tuple\n@@ -13,7 +13,7 @@ LL |         Self: Sized + Iterator<Item = &'a T>,\n    |                                ^^^^^^^^^^^^ required by this bound in `cloned`\n \n error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as Iterator>::Item == &_`\n-  --> $DIR/issue-33941.rs:4:14\n+  --> $DIR/issue-33941.rs:6:14\n    |\n LL |     for _ in HashMap::new().iter().cloned() {}\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found reference\n@@ -23,6 +23,16 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n    = note: required because of the requirements on the impl of `Iterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n    = note: required because of the requirements on the impl of `IntoIterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n \n-error: aborting due to 2 previous errors\n+error[E0271]: type mismatch resolving `<std::collections::hash_map::Iter<'_, _, _> as Iterator>::Item == &_`\n+  --> $DIR/issue-33941.rs:6:14\n+   |\n+LL |     for _ in HashMap::new().iter().cloned() {}\n+   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected tuple, found reference\n+   |\n+   = note:  expected tuple `(&_, &_)`\n+           found reference `&_`\n+   = note: required because of the requirements on the impl of `Iterator` for `Cloned<std::collections::hash_map::Iter<'_, _, _>>`\n+\n+error: aborting due to 3 previous errors\n \n For more information about this error, try `rustc --explain E0271`."}, {"sha": "a1fc99c9a3d72ee4391bf60509520adca56ed091", "filename": "src/test/ui/lint/issue-17718-const-naming.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Flint%2Fissue-17718-const-naming.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Flint%2Fissue-17718-const-naming.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fissue-17718-const-naming.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -17,11 +17,6 @@ error: constant `foo` should have an upper case name\n LL | const foo: isize = 3;\n    |       ^^^ help: convert the identifier to upper case (notice the capitalization): `FOO`\n    |\n-note: the lint level is defined here\n-  --> $DIR/issue-17718-const-naming.rs:2:9\n-   |\n-LL | #![deny(warnings)]\n-   |         ^^^^^^^^\n    = note: `#[deny(non_upper_case_globals)]` implied by `#[deny(warnings)]`\n \n error: aborting due to 2 previous errors"}, {"sha": "fcd0101237185d7dd37268367b2fb988f2828c8c", "filename": "src/test/ui/lint/lint-group-nonstandard-style.stderr", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-group-nonstandard-style.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -43,11 +43,6 @@ error: static variable `bad` should have an upper case name\n LL |         static bad: isize = 1;\n    |                ^^^ help: convert the identifier to upper case: `BAD`\n    |\n-note: the lint level is defined here\n-  --> $DIR/lint-group-nonstandard-style.rs:10:14\n-   |\n-LL |     #[forbid(nonstandard_style)]\n-   |              ^^^^^^^^^^^^^^^^^\n    = note: `#[forbid(non_upper_case_globals)]` implied by `#[forbid(nonstandard_style)]`\n \n warning: function `CamelCase` should have a snake case name\n@@ -56,11 +51,6 @@ warning: function `CamelCase` should have a snake case name\n LL |         fn CamelCase() {}\n    |            ^^^^^^^^^ help: convert the identifier to snake case: `camel_case`\n    |\n-note: the lint level is defined here\n-  --> $DIR/lint-group-nonstandard-style.rs:18:17\n-   |\n-LL |         #![warn(nonstandard_style)]\n-   |                 ^^^^^^^^^^^^^^^^^\n    = note: `#[warn(non_snake_case)]` implied by `#[warn(nonstandard_style)]`\n \n error: aborting due to 3 previous errors; 2 warnings emitted"}, {"sha": "26fa6eb9b9bc6bcb57c6f7ceb7731f1e0486ac42", "filename": "src/test/ui/lint/unused/issue-47390-unused-variable-in-struct-pattern.stderr", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-47390-unused-variable-in-struct-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funused%2Fissue-47390-unused-variable-in-struct-pattern.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -49,11 +49,6 @@ warning: value assigned to `hours_are_suns` is never read\n LL |         hours_are_suns = false;\n    |         ^^^^^^^^^^^^^^\n    |\n-note: the lint level is defined here\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:5:9\n-   |\n-LL | #![warn(unused)] // UI tests pass `-A unused` (#43896)\n-   |         ^^^^^^\n    = note: `#[warn(unused_assignments)]` implied by `#[warn(unused)]`\n    = help: maybe it is overwritten before being read?\n \n@@ -107,11 +102,6 @@ LL |     let mut mut_unused_var = 1;\n    |         |\n    |         help: remove this `mut`\n    |\n-note: the lint level is defined here\n-  --> $DIR/issue-47390-unused-variable-in-struct-pattern.rs:5:9\n-   |\n-LL | #![warn(unused)] // UI tests pass `-A unused` (#43896)\n-   |         ^^^^^^\n    = note: `#[warn(unused_mut)]` implied by `#[warn(unused)]`\n \n warning: variable does not need to be mutable"}, {"sha": "adaf543162976fa40bd0b41d004c68d5928f5984", "filename": "src/test/ui/liveness/liveness-consts.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fliveness%2Fliveness-consts.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fliveness%2Fliveness-consts.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-consts.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -18,11 +18,6 @@ warning: value assigned to `b` is never read\n LL |     b += 1;\n    |     ^\n    |\n-note: the lint level is defined here\n-  --> $DIR/liveness-consts.rs:2:9\n-   |\n-LL | #![warn(unused)]\n-   |         ^^^^^^\n    = note: `#[warn(unused_assignments)]` implied by `#[warn(unused)]`\n    = help: maybe it is overwritten before being read?\n "}, {"sha": "cb104e0a3fddaefcf4d328c098a1026c72bfd994", "filename": "src/test/ui/liveness/liveness-upvars.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fliveness%2Fliveness-upvars.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -18,11 +18,6 @@ warning: unused variable: `last`\n LL |         last = Some(s);\n    |         ^^^^\n    |\n-note: the lint level is defined here\n-  --> $DIR/liveness-upvars.rs:4:9\n-   |\n-LL | #![warn(unused)]\n-   |         ^^^^^^\n    = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n    = help: did you mean to capture by reference instead?\n "}, {"sha": "521b82023c93b9a67bb6435f6f0622d404fb8373", "filename": "src/test/ui/never_type/never-assign-dead-code.stderr", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-dead-code.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-dead-code.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fnever-assign-dead-code.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -27,11 +27,6 @@ warning: unused variable: `x`\n LL |     let x: ! = panic!(\"aah\");\n    |         ^ help: if this is intentional, prefix it with an underscore: `_x`\n    |\n-note: the lint level is defined here\n-  --> $DIR/never-assign-dead-code.rs:6:9\n-   |\n-LL | #![warn(unused)]\n-   |         ^^^^^^\n    = note: `#[warn(unused_variables)]` implied by `#[warn(unused)]`\n \n warning: 3 warnings emitted"}, {"sha": "f1a167e37b449fef87784bee00c95fe69f09b09c", "filename": "src/test/ui/proc-macro/generate-mod.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -101,6 +101,7 @@ error: cannot find type `OuterDerive` in this scope\n LL | #[derive(generate_mod::CheckDerive)]\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n    |\n+   = note: `#[deny(proc_macro_derive_resolution_fallback)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n    = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n@@ -112,6 +113,7 @@ error: cannot find type `FromOutside` in this scope\n LL |     #[derive(generate_mod::CheckDerive)]\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n    |\n+   = note: `#[deny(proc_macro_derive_resolution_fallback)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n    = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n@@ -123,6 +125,7 @@ error: cannot find type `OuterDerive` in this scope\n LL |     #[derive(generate_mod::CheckDerive)]\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n    |\n+   = note: `#[deny(proc_macro_derive_resolution_fallback)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n    = note: this error originates in the derive macro `generate_mod::CheckDerive` (in Nightly builds, run with -Z macro-backtrace for more info)\n@@ -150,6 +153,11 @@ warning: cannot find type `OuterDeriveLint` in this scope\n LL | #[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n    |\n+note: the lint level is defined here\n+  --> $DIR/generate-mod.rs:30:10\n+   |\n+LL | #[derive(generate_mod::CheckDeriveLint)] // OK, lint is suppressed\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n    = note: this warning originates in the derive macro `generate_mod::CheckDeriveLint` (in Nightly builds, run with -Z macro-backtrace for more info)"}, {"sha": "acba357b0d336566ef6b8be5cb7fd8acd428ca69", "filename": "src/test/ui/proc-macro/group-compat-hack/group-compat-hack.stderr", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgroup-compat-hack%2Fgroup-compat-hack.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -111,6 +111,7 @@ LL |         #[my_macro] struct One($name);\n LL |     impl_macros!(Foo);\n    |     ----------------- in this macro invocation\n    |\n+   = note: `#[deny(proc_macro_back_compat)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n    = note: the `time-macros-impl` crate will stop compiling in futures version of Rust. Please update to the latest version of the `time` crate to avoid breakage\n@@ -128,6 +129,7 @@ LL |         #[my_macro] struct Two($name);\n LL |     arrays!(Foo);\n    |     ------------ in this macro invocation\n    |\n+   = note: `#[deny(proc_macro_back_compat)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n    = note: older versions of the `js-sys` crate will stop compiling in future versions of Rust; please update to `js-sys` v0.3.40 or above\n@@ -145,6 +147,7 @@ LL |         #[my_macro] struct Three($T);\n LL |     tuple_from_req!(Foo);\n    |     -------------------- in this macro invocation\n    |\n+   = note: `#[deny(proc_macro_back_compat)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n    = note: the version of `actix-web` you are using might stop compiling in future versions of Rust; please update to the latest version of the `actix-web` crate to avoid breakage\n@@ -162,6 +165,7 @@ LL |         #[my_macro] struct Three($T);\n LL |     tuple_from_req!(Foo);\n    |     -------------------- in this macro invocation\n    |\n+   = note: `#[deny(proc_macro_back_compat)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n    = note: the version of `actix-web` you are using might stop compiling in future versions of Rust; please update to the latest version of the `actix-web` crate to avoid breakage"}, {"sha": "be4239089e8817faae9163851cca5a296054cd96", "filename": "src/test/ui/proc-macro/issue-73933-procedural-masquerade.stderr", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fproc-macro%2Fissue-73933-procedural-masquerade.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6/src%2Ftest%2Fui%2Fproc-macro%2Fissue-73933-procedural-masquerade.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fissue-73933-procedural-masquerade.stderr?ref=0b49d05ea33d68391e3d5472f3398d0ad1d9f9a6", "patch": "@@ -60,6 +60,7 @@ error: using `procedural-masquerade` crate\n LL | enum ProceduralMasqueradeDummyType {\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+   = note: `#[deny(proc_macro_back_compat)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n    = note: The `procedural-masquerade` crate has been unnecessary since Rust 1.30.0. Versions of this crate below 0.1.7 will eventually stop compiling.\n@@ -71,6 +72,7 @@ error: using `procedural-masquerade` crate\n LL | enum ProceduralMasqueradeDummyType {\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+   = note: `#[deny(proc_macro_back_compat)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n    = note: The `procedural-masquerade` crate has been unnecessary since Rust 1.30.0. Versions of this crate below 0.1.7 will eventually stop compiling.\n@@ -82,6 +84,7 @@ error: using `procedural-masquerade` crate\n LL | enum ProceduralMasqueradeDummyType {\n    |      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n+   = note: `#[deny(proc_macro_back_compat)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #83125 <https://github.com/rust-lang/rust/issues/83125>\n    = note: The `procedural-masquerade` crate has been unnecessary since Rust 1.30.0. Versions of this crate below 0.1.7 will eventually stop compiling."}]}