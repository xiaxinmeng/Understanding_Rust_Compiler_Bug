{"sha": "8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlOWJkNmNkMjZhOGY5ZDExMTg4ZTM5YzUyYWFmYjQ0MzZiMDk5OTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-17T05:31:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-07-17T05:31:15Z"}, "message": "Auto merge of #27066 - rust-lang:rollup_central, r=steveklabnik\n\nEverything on this branch has passed check-stage2 on linux.\n\nThis is a temporary integration branch until [our buildbot problems](https://internals.rust-lang.org/t/buildbot-is-down-for-a-bit/2365/3) get fixed.\nAs the day progresses I'll merge more PRs into this branch once I get them through make check.\n\nThis branch isn't complete, keeping it up here so more people can merge PRs into integration if they want.\n\nr? @Manishearth", "tree": {"sha": "3430fc636040c1522036f9e07517cced365072de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3430fc636040c1522036f9e07517cced365072de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "html_url": "https://github.com/rust-lang/rust/commit/8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4e93196e16030ebf7a20c473849534235d676f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4e93196e16030ebf7a20c473849534235d676f8", "html_url": "https://github.com/rust-lang/rust/commit/e4e93196e16030ebf7a20c473849534235d676f8"}, {"sha": "c9e6d9a32368da5b2639ddb4f0069486d9cc14f0", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e6d9a32368da5b2639ddb4f0069486d9cc14f0", "html_url": "https://github.com/rust-lang/rust/commit/c9e6d9a32368da5b2639ddb4f0069486d9cc14f0"}], "stats": {"total": 3388, "additions": 2441, "deletions": 947}, "files": [{"sha": "dc955bc2f2be2e3527b553786db41fb2a5b2a1ba", "filename": ".travis.yml", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -1,20 +1,38 @@\n-# Use something that's not 'ruby' so we don't set up things like\n-# RVM/bundler/ruby and whatnot. Right now 'rust' as a language actually\n-# downloads a rust/cargo snapshot, which we don't really want for building rust.\n+# ccache support is disabled unless your language is a C-derivative. However\n+# `language: C` unconditionally sets `CC=compiler`. If we just set it in our\n+# `env` it will be overwritten by the default (gcc 4.6).\n language: c\n+compiler: /usr/bin/gcc-4.7\n+cache: ccache\n sudo: false\n \n # The test suite is in general way too stressful for travis, especially in\n # terms of time limit and reliability. In the past we've tried to scale things\n # back to only build the stage1 compiler and run a subset of tests, but this\n # didn't end up panning out very well.\n #\n-# As a result, we're just using travis to run `make tidy` now. It'll help\n-# everyone find out about their trailing spaces early on!\n+# As a result, we're just using travis to run `make tidy` and *only* build\n+# stage1 but *not* test it for now (a strict subset of the bootstrap). This will\n+# catch \"obvious\" errors like style or not even compiling.\n+#\n+# We need gcc4.7 or higher to build LLVM, and travis (well, Ubuntu 12.04)\n+# currently ships with 4.6. Gotta download our own.\n before_script:\n-  - ./configure --llvm-root=path/to/nowhere\n+  - ./configure --enable-ccache\n script:\n   - make tidy\n+  - make rustc-stage1 -j4\n+\n+env:\n+  - CXX=/usr/bin/g++-4.7\n+\n+addons:\n+  apt:\n+    sources:\n+    - ubuntu-toolchain-r-test\n+    packages:\n+    - gcc-4.7\n+    - g++-4.7\n \n # Real testing happens on http://buildbot.rust-lang.org/\n #"}, {"sha": "22a23de07078034e4fec65394d17ff4c1243b689", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -133,8 +133,8 @@ Documentation improvements are very welcome. The source of `doc.rust-lang.org`\n is located in `src/doc` in the tree, and standard API documentation is generated\n from the source code itself.\n \n-Documentation pull requests function in the same as other pull requests, though\n-you may see a slightly different form of `r+`:\n+Documentation pull requests function in the same way as other pull requests,\n+though you may see a slightly different form of `r+`:\n \n     @bors: r+ 38fe8d2 rollup\n "}, {"sha": "db1c7380a788b4a5d3a408957f7df034360072b2", "filename": "RELEASES.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -28,6 +28,9 @@ Breaking Changes\n   in, and the same value reported by clang's\n   `alignof`. [`mem::min_align_of`] is deprecated. This is not known to\n   break real code.\n+* [The `#[packed]` attribute is no longer silently accepted by the\n+  compiler][packed]. This attribute did nothing and code that\n+  mentioned it likely did not work as intended.\n \n Language\n --------\n@@ -140,7 +143,7 @@ Misc\n [fat]: https://github.com/rust-lang/rust/pull/26411\n [dst]: https://github.com/rust-lang/rfcs/blob/master/text/0982-dst-coercion.md\n [parcodegen]: https://github.com/rust-lang/rust/pull/26018\n-\n+[packed]: https://github.com/rust-lang/rust/pull/25541\n \n Version 1.1.0 (June 2015)\n ========================="}, {"sha": "3d04cf7519ed4aa695224c296611a8edaa7ab7db", "filename": "configure", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/configure", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -1031,15 +1031,12 @@ fi\n \n if [ ! -z \"$CFG_ENABLE_CCACHE\" ]\n then\n-    if [ -z \"$CC\" ]\n+    if [ -z \"$CFG_CCACHE\" ]\n     then\n-        if [ -z \"$CFG_CCACHE\" ]\n-        then\n-            err \"ccache requested but not found\"\n-        fi\n-\n-        CFG_CC=\"ccache $CFG_CC\"\n+        err \"ccache requested but not found\"\n     fi\n+\n+    CFG_CC=\"ccache $CFG_CC\"\n fi\n \n if [ -z \"$CC\" -a -z \"$CFG_ENABLE_CLANG\" -a -z \"$CFG_GCC\" ]\n@@ -1528,11 +1525,26 @@ do\n \n             (*)\n             msg \"inferring LLVM_CXX/CC from CXX/CC = $CXX/$CC\"\n-            LLVM_CXX_32=\"$CXX\"\n-            LLVM_CC_32=\"$CC\"\n+            if [ ! -z \"$CFG_ENABLE_CCACHE\" ]\n+            then\n+                if [ -z \"$CFG_CCACHE\" ]\n+                then\n+                    err \"ccache requested but not found\"\n+                fi\n+\n+                LLVM_CXX_32=\"ccache $CXX\"\n+                LLVM_CC_32=\"ccache $CC\"\n+\n+                LLVM_CXX_64=\"ccache $CXX\"\n+                LLVM_CC_64=\"ccache $CC\"\n+            else\n+                LLVM_CXX_32=\"$CXX\"\n+                LLVM_CC_32=\"$CC\"\n+\n+                LLVM_CXX_64=\"$CXX\"\n+                LLVM_CC_64=\"$CC\"\n+            fi\n \n-            LLVM_CXX_64=\"$CXX\"\n-            LLVM_CC_64=\"$CC\"\n             ;;\n         esac\n "}, {"sha": "a37e1c146681e4f600c3ecff63f64fd6f9bee599", "filename": "src/doc/reference.md", "status": "modified", "additions": 74, "deletions": 51, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -343,10 +343,10 @@ The type of an _unsuffixed_ integer literal is determined by type inference:\n * If an integer type can be _uniquely_ determined from the surrounding\n   program context, the unsuffixed integer literal has that type.\n \n-* If the program context underconstrains the type, it defaults to the\n+* If the program context under-constrains the type, it defaults to the\n   signed 32-bit integer `i32`.\n \n-* If the program context overconstrains the type, it is considered a\n+* If the program context over-constrains the type, it is considered a\n   static type error.\n \n Examples of integer literals of various forms:\n@@ -382,9 +382,9 @@ type inference:\n   surrounding program context, the unsuffixed floating-point literal\n   has that type.\n \n-* If the program context underconstrains the type, it defaults to `f64`.\n+* If the program context under-constrains the type, it defaults to `f64`.\n \n-* If the program context overconstrains the type, it is considered a\n+* If the program context over-constrains the type, it is considered a\n   static type error.\n \n Examples of floating-point literals of various forms:\n@@ -1292,7 +1292,7 @@ All access to a static is safe, but there are a number of restrictions on\n statics:\n \n * Statics may not contain any destructors.\n-* The types of static values must ascribe to `Sync` to allow threadsafe access.\n+* The types of static values must ascribe to `Sync` to allow thread-safe access.\n * Statics may not refer to other statics by value, only by reference.\n * Constants cannot refer to statics.\n \n@@ -1694,7 +1694,7 @@ explain, here's a few use cases and what they would entail:\n * A crate needs a global available \"helper module\" to itself, but it doesn't\n   want to expose the helper module as a public API. To accomplish this, the\n   root of the crate's hierarchy would have a private module which then\n-  internally has a \"public api\". Because the entire crate is a descendant of\n+  internally has a \"public API\". Because the entire crate is a descendant of\n   the root, then the entire local crate can access this private module through\n   the second case.\n \n@@ -1957,8 +1957,6 @@ macro scope.\n   object file that this item's contents will be placed into.\n - `no_mangle` - on any item, do not apply the standard name mangling. Set the\n   symbol for this item to its identifier.\n-- `packed` - on structs or enums, eliminate any padding that would be used to\n-  align fields.\n - `simd` - on certain tuple structs, derive the arithmetic operators, which\n   lower to the target's SIMD instructions, if any; the `simd` feature gate\n   is necessary to use this attribute.\n@@ -3663,47 +3661,71 @@ sites are:\n \n * `let` statements where an explicit type is given.\n \n-    In `let _: U = e;`, `e` is coerced to have type `U`.\n+   For example, `128` is coerced to have type `i8` in the following:\n+\n+   ```rust\n+   let _: i8 = 128;\n+   ```\n \n * `static` and `const` statements (similar to `let` statements).\n \n-* arguments for function calls.\n+* Arguments for function calls\n+\n+  The value being coerced is the actual parameter, and it is coerced to\n+  the type of the formal parameter.\n+\n+  For example, `128` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  fn bar(_: i8) { }\n \n-    The value being coerced is the\n-    actual parameter and it is coerced to the type of the formal parameter. For\n-    example, let `foo` be defined as `fn foo(x: U) { ... }` and call it as\n-    `foo(e);`. Then `e` is coerced to have type `U`;\n+  fn main() {\n+     bar(128);\n+  }\n+  ```\n \n-* instantiations of struct or variant fields.\n+* Instantiations of struct or variant fields\n \n-    Assume we have a `struct\n-    Foo { x: U }` and instantiate it as `Foo { x: e }`. Then `e` is coerced to\n-    have type `U`.\n+  For example, `128` is coerced to have type `i8` in the following:\n \n-* function results (either the final line of a block if it is not semicolon\n-terminated or any expression in a `return` statement).\n+  ```rust\n+  struct Foo { x: i8 }\n \n-    In `fn foo() -> U { e }`, `e` is coerced to to have type `U`.\n+  fn main() {\n+      Foo { x: 128 };\n+  }\n+  ```\n+\n+* Function results, either the final line of a block if it is not\n+  semicolon-terminated or any expression in a `return` statement\n+\n+  For example, `128` is coerced to have type `i8` in the following:\n+\n+  ```rust\n+  fn foo() -> i8 {\n+      128\n+  }\n+  ```\n \n If the expression in one of these coercion sites is a coercion-propagating\n expression, then the relevant sub-expressions in that expression are also\n coercion sites. Propagation recurses from these new coercion sites.\n Propagating expressions and their relevant sub-expressions are:\n \n-* array literals, where the array has type `[U; n]`. Each sub-expression in\n+* Array literals, where the array has type `[U; n]`. Each sub-expression in\n the array literal is a coercion site for coercion to type `U`.\n \n-* array literals with repeating syntax, where the array has type `[U; n]`. The\n+* Array literals with repeating syntax, where the array has type `[U; n]`. The\n repeated sub-expression is a coercion site for coercion to type `U`.\n \n-* tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`.\n+* Tuples, where a tuple is a coercion site to type `(U_0, U_1, ..., U_n)`.\n Each sub-expression is a coercion site to the respective type, e.g. the\n zeroth sub-expression is a coercion site to type `U_0`.\n \n-* parenthesised sub-expressions (`(e)`). If the expression has type `U`, then\n+* Parenthesised sub-expressions (`(e)`): if the expression has type `U`, then\n the sub-expression is a coercion site to `U`.\n \n-* blocks. If a block has type `U`, then the last expression in the block (if\n+* Blocks: if a block has type `U`, then the last expression in the block (if\n it is not semicolon-terminated) is a coercion site to `U`. This includes\n blocks which are part of control flow statements, such as `if`/`else`, if\n the block has a known type.\n@@ -3712,45 +3734,46 @@ the block has a known type.\n \n Coercion is allowed between the following types:\n \n-* `T` to `U` if `T` is a subtype of `U` (*reflexive case*).\n+* `T` to `U` if `T` is a subtype of `U` (*reflexive case*)\n \n * `T_1` to `T_3` where `T_1` coerces to `T_2` and `T_2` coerces to `T_3`\n-(*transitive case*).\n+(*transitive case*)\n \n     Note that this is not fully supported yet\n \n-* `&mut T` to `&T`.\n+* `&mut T` to `&T`\n \n-* `*mut T` to `*const T`.\n+* `*mut T` to `*const T`\n \n-* `&T` to `*const T`.\n+* `&T` to `*const T`\n \n-* `&mut T` to `*mut T`.\n+* `&mut T` to `*mut T`\n \n * `&T` to `&U` if `T` implements `Deref<Target = U>`. For example:\n \n-```rust\n-use std::ops::Deref;\n+  ```rust\n+  use std::ops::Deref;\n \n-struct CharContainer {\n-    value: char\n-}\n+  struct CharContainer {\n+      value: char\n+  }\n \n-impl Deref for CharContainer {\n-    type Target = char;\n+  impl Deref for CharContainer {\n+      type Target = char;\n \n-    fn deref<'a>(&'a self) -> &'a char {\n-        &self.value\n-    }\n-}\n+      fn deref<'a>(&'a self) -> &'a char {\n+          &self.value\n+      }\n+  }\n \n-fn foo(arg: &char) {}\n+  fn foo(arg: &char) {}\n+\n+  fn main() {\n+      let x = &mut CharContainer { value: 'y' };\n+      foo(x); //&mut CharContainer is coerced to &char.\n+  }\n+  ```\n \n-fn main() {\n-    let x = &mut CharContainer { value: 'y' };\n-    foo(x); //&mut CharContainer is coerced to &char.\n-}\n-```\n * `&mut T` to `&mut U` if `T` implements `DerefMut<Target = U>`.\n \n * TyCtor(`T`) to TyCtor(coerce_inner(`T`)), where TyCtor(`T`) is one of\n@@ -3964,7 +3987,7 @@ In general, `--crate-type=bin` or `--crate-type=lib` should be sufficient for\n all compilation needs, and the other options are just available if more\n fine-grained control is desired over the output format of a Rust crate.\n \n-# Appendix: Rationales and design tradeoffs\n+# Appendix: Rationales and design trade-offs\n \n *TODO*.\n \n@@ -3974,7 +3997,7 @@ Rust is not a particularly original language, with design elements coming from\n a wide range of sources. Some of these are listed below (including elements\n that have since been removed):\n \n-* SML, OCaml: algebraic datatypes, pattern matching, type inference,\n+* SML, OCaml: algebraic data types, pattern matching, type inference,\n   semicolon statement separation\n * C++: references, RAII, smart pointers, move semantics, monomorphisation,\n   memory model"}, {"sha": "8dd5a3650ef5260eb2d55201e4db9e6dc1a7f0a8", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -50,6 +50,8 @@ is very wrong. Wrong enough that we can't continue with things in the current\n state. Another example is using the `unreachable!()` macro:\n \n ```rust,ignore\n+use Event::NewRelease;\n+\n enum Event {\n     NewRelease,\n }\n@@ -71,7 +73,7 @@ fn descriptive_probability(event: Event) -> &'static str {\n }\n \n fn main() {\n-    std::io::println(descriptive_probability(NewRelease));\n+    println!(\"{}\", descriptive_probability(NewRelease));\n }\n ```\n "}, {"sha": "ff81590cc03b9b6a97ba837a946826c4509b40df", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -176,7 +176,7 @@ After `bar()` is over, its frame is deallocated, leaving just `foo()` and\n | 1       | a    | 5     |\n | 0       | x    | 42    |\n \n-And then `foo()` ends, leaving just `main()`\n+And then `foo()` ends, leaving just `main()`:\n \n | Address | Name | Value |\n |---------|------|-------|\n@@ -537,7 +537,7 @@ Generally, you should prefer stack allocation, and so, Rust stack-allocates by\n default. The LIFO model of the stack is simpler, at a fundamental level. This\n has two big impacts: runtime efficiency and semantic impact.\n \n-## Runtime Efficiency.\n+## Runtime Efficiency\n \n Managing the memory for the stack is trivial: The machine just\n increments or decrements a single value, the so-called \u201cstack pointer\u201d."}, {"sha": "d26e9ab7072055d9a7a24f38e2e31ca58fa10409", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -10,8 +10,6 @@\n \n //! An implementation of SipHash 2-4.\n \n-#![allow(deprecated)] // until the next snapshot for inherent wrapping ops\n-\n use prelude::*;\n use super::Hasher;\n "}, {"sha": "697c3ee254b983ee3323381c14e6f8bb649bf654", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+mod sip;\n+\n use std::mem;\n use std::hash::{Hash, Hasher};\n use std::default::Default;"}, {"sha": "7832985d3f1c1ee158291af85f1ea502e871a3d1", "filename": "src/libcoretest/hash/sip.rs", "status": "modified", "additions": 59, "deletions": 67, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibcoretest%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibcoretest%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fsip.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -8,28 +8,55 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n use test::Bencher;\n-use std::prelude::*;\n-use std::fmt;\n \n-use str::Str;\n-use string::String;\n-use slice::{AsSlice, SlicePrelude};\n-use vec::Vec;\n-\n-use core::hash::{Hash, Writer};\n-use core::hash::sip::{SipState, hash, hash_with_keys};\n+use core::hash::{Hash, Hasher};\n+use core::hash::SipHasher;\n \n // Hash just the bytes of the slice, without length prefix\n struct Bytes<'a>(&'a [u8]);\n \n-impl<'a, S: Writer> Hash<S> for Bytes<'a> {\n+impl<'a> Hash for Bytes<'a> {\n     #[allow(unused_must_use)]\n-    fn hash(&self, state: &mut S) {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n         let Bytes(v) = *self;\n         state.write(v);\n     }\n }\n \n+macro_rules! u8to64_le {\n+    ($buf:expr, $i:expr) =>\n+    ($buf[0+$i] as u64 |\n+     ($buf[1+$i] as u64) << 8 |\n+     ($buf[2+$i] as u64) << 16 |\n+     ($buf[3+$i] as u64) << 24 |\n+     ($buf[4+$i] as u64) << 32 |\n+     ($buf[5+$i] as u64) << 40 |\n+     ($buf[6+$i] as u64) << 48 |\n+     ($buf[7+$i] as u64) << 56);\n+    ($buf:expr, $i:expr, $len:expr) =>\n+    ({\n+        let mut t = 0;\n+        let mut out = 0;\n+        while t < $len {\n+            out |= ($buf[t+$i] as u64) << t*8;\n+            t += 1;\n+        }\n+        out\n+    });\n+}\n+\n+fn hash<T: Hash>(x: &T) -> u64 {\n+    let mut st = SipHasher::new();\n+    x.hash(&mut st);\n+    st.finish()\n+}\n+\n+fn hash_with_keys<T: Hash>(k1: u64, k2: u64, x: &T) -> u64 {\n+    let mut st = SipHasher::new_with_keys(k1, k2);\n+    x.hash(&mut st);\n+    st.finish()\n+}\n+\n #[test]\n #[allow(unused_must_use)]\n fn test_siphash() {\n@@ -104,79 +131,43 @@ fn test_siphash() {\n     let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n     let mut buf = Vec::new();\n     let mut t = 0;\n-    let mut state_inc = SipState::new_with_keys(k0, k1);\n-    let mut state_full = SipState::new_with_keys(k0, k1);\n-\n-    fn to_hex_str(r: &[u8; 8]) -> String {\n-        let mut s = String::new();\n-        for b in r {\n-            s.push_str(format!(\"{}\", fmt::radix(*b, 16)));\n-        }\n-        s\n-    }\n-\n-    fn result_bytes(h: u64) -> Vec<u8> {\n-        vec![(h >> 0) as u8,\n-          (h >> 8) as u8,\n-          (h >> 16) as u8,\n-          (h >> 24) as u8,\n-          (h >> 32) as u8,\n-          (h >> 40) as u8,\n-          (h >> 48) as u8,\n-          (h >> 56) as u8,\n-        ]\n-    }\n-\n-    fn result_str(h: u64) -> String {\n-        let r = result_bytes(h);\n-        let mut s = String::new();\n-        for b in &r {\n-            s.push_str(format!(\"{}\", fmt::radix(*b, 16)));\n-        }\n-        s\n-    }\n+    let mut state_inc = SipHasher::new_with_keys(k0, k1);\n \n     while t < 64 {\n-        debug!(\"siphash test {}: {}\", t, buf);\n         let vec = u8to64_le!(vecs[t], 0);\n-        let out = hash_with_keys(k0, k1, &Bytes(buf));\n-        debug!(\"got {}, expected {}\", out, vec);\n+        let out = hash_with_keys(k0, k1, &Bytes(&buf));\n         assert_eq!(vec, out);\n \n-        state_full.reset();\n-        state_full.write(buf);\n-        let f = result_str(state_full.result());\n-        let i = result_str(state_inc.result());\n-        let v = to_hex_str(&vecs[t]);\n-        debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n+        let full = hash_with_keys(k0, k1, &Bytes(&buf));\n+        let i = state_inc.finish();\n \n-        assert_eq!(f, i);\n-        assert_eq!(f, v);\n+        assert_eq!(full, i);\n+        assert_eq!(full, vec);\n \n         buf.push(t as u8);\n-        state_inc.write(&[t as u8]);\n+        Hasher::write(&mut state_inc, &[t as u8]);\n \n         t += 1;\n     }\n }\n \n #[test] #[cfg(target_arch = \"arm\")]\n-fn test_hash_uint() {\n+fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert!(hash(&(val as u64)) != hash(&(val as uint)));\n-    assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n+    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n }\n #[test] #[cfg(target_arch = \"x86_64\")]\n-fn test_hash_uint() {\n+fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert_eq!(hash(&(val as u64)), hash(&(val as uint)));\n-    assert!(hash(&(val as u32)) != hash(&(val as uint)));\n+    assert_eq!(hash(&(val as u64)), hash(&(val as usize)));\n+    assert!(hash(&(val as u32)) != hash(&(val as usize)));\n }\n #[test] #[cfg(target_arch = \"x86\")]\n-fn test_hash_uint() {\n+fn test_hash_usize() {\n     let val = 0xdeadbeef_deadbeef_u64;\n-    assert!(hash(&(val as u64)) != hash(&(val as uint)));\n-    assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n+    assert!(hash(&(val as u64)) != hash(&(val as usize)));\n+    assert_eq!(hash(&(val as u32)), hash(&(val as usize)));\n }\n \n #[test]\n@@ -200,7 +191,7 @@ fn test_hash_no_bytes_dropped_64() {\n     assert!(hash(&val) != hash(&zero_byte(val, 6)));\n     assert!(hash(&val) != hash(&zero_byte(val, 7)));\n \n-    fn zero_byte(val: u64, byte: uint) -> u64 {\n+    fn zero_byte(val: u64, byte: usize) -> u64 {\n         assert!(byte < 8);\n         val & !(0xff << (byte * 8))\n     }\n@@ -215,7 +206,7 @@ fn test_hash_no_bytes_dropped_32() {\n     assert!(hash(&val) != hash(&zero_byte(val, 2)));\n     assert!(hash(&val) != hash(&zero_byte(val, 3)));\n \n-    fn zero_byte(val: u32, byte: uint) -> u32 {\n+    fn zero_byte(val: u32, byte: usize) -> u32 {\n         assert!(byte < 4);\n         val & !(0xff << (byte * 8))\n     }\n@@ -230,8 +221,9 @@ fn test_hash_no_concat_alias() {\n     assert!(s != t && t != u);\n     assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n \n-    let v: (&[u8], &[u8], &[u8]) = (&[1], &[0, 0], &[0]);\n-    let w: (&[u8], &[u8], &[u8]) = (&[1, 0, 0, 0], &[], &[]);\n+    let u = [1, 0, 0, 0];\n+    let v = (&u[..1], &u[1..3], &u[3..]);\n+    let w = (&u[..], &u[4..4], &u[4..4]);\n \n     assert!(v != w);\n     assert!(hash(&v) != hash(&w));"}, {"sha": "5c10cc6aaa8dbe23003e61649cc228f5bde3651b", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -411,6 +411,13 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n+    pub fn expect_trait_item(&self, id: NodeId) -> &'ast TraitItem {\n+        match self.find(id) {\n+            Some(NodeTraitItem(item)) => item,\n+            _ => panic!(\"expected trait item, found {}\", self.node_to_string(id))\n+        }\n+    }\n+\n     pub fn expect_struct(&self, id: NodeId) -> &'ast StructDef {\n         match self.find(id) {\n             Some(NodeItem(i)) => {"}, {"sha": "4b77c211df9839b603790b011556cb2913667f4d", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -972,16 +972,16 @@ Updates to the borrow checker in a future version of Rust may remove this\n restriction, but for now patterns must be rewritten without sub-bindings.\n \n ```\n-// Code like this...\n-match Some(5) {\n-    ref op_num @ Some(num) => ...\n+// Before.\n+match Some(\"hi\".to_string()) {\n+    ref op_string_ref @ Some(ref s) => ...\n     None => ...\n }\n \n // After.\n match Some(\"hi\".to_string()) {\n     Some(ref s) => {\n-        let op_string_ref = &Some(&s);\n+        let op_string_ref = &Some(s);\n         ...\n     }\n     None => ..."}, {"sha": "57665b6d9392348833f973f4502273dc1d448608", "filename": "src/librustc/middle/infer/higher_ranked/README.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2FREADME.md?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -17,7 +17,7 @@ The problem we are addressing is that there is a kind of subtyping\n between functions with bound region parameters. Consider, for\n example, whether the following relation holds:\n \n-    for<'a> fn(&'a int) <: for<'b> fn(&'b int)? (Yes, a => b)\n+    for<'a> fn(&'a isize) <: for<'b> fn(&'b isize)? (Yes, a => b)\n \n The answer is that of course it does. These two types are basically\n the same, except that in one we used the name `a` and one we used\n@@ -27,14 +27,14 @@ In the examples that follow, it becomes very important to know whether\n a lifetime is bound in a function type (that is, is a lifetime\n parameter) or appears free (is defined in some outer scope).\n Therefore, from now on I will always write the bindings explicitly,\n-using the Rust syntax `for<'a> fn(&'a int)` to indicate that `a` is a\n+using the Rust syntax `for<'a> fn(&'a isize)` to indicate that `a` is a\n lifetime parameter.\n \n Now let's consider two more function types. Here, we assume that the\n `'b` lifetime is defined somewhere outside and hence is not a lifetime\n parameter bound by the function type (it \"appears free\"):\n \n-    for<'a> fn(&'a int) <: fn(&'b int)? (Yes, a => b)\n+    for<'a> fn(&'a isize) <: fn(&'b isize)? (Yes, a => b)\n \n This subtyping relation does in fact hold. To see why, you have to\n consider what subtyping means. One way to look at `T1 <: T2` is to\n@@ -51,7 +51,7 @@ to the same thing: a function that accepts pointers with any lifetime\n \n So, what if we reverse the order of the two function types, like this:\n \n-    fn(&'b int) <: for<'a> fn(&'a int)? (No)\n+    fn(&'b isize) <: for<'a> fn(&'a isize)? (No)\n \n Does the subtyping relationship still hold?  The answer of course is\n no. In this case, the function accepts *only the lifetime `'b`*,\n@@ -60,8 +60,8 @@ accepted any lifetime.\n \n What about these two examples:\n \n-    for<'a,'b> fn(&'a int, &'b int) <: for<'a>    fn(&'a int, &'a int)? (Yes)\n-    for<'a>    fn(&'a int, &'a int) <: for<'a,'b> fn(&'a int, &'b int)? (No)\n+    for<'a,'b> fn(&'a isize, &'b isize) <: for<'a>    fn(&'a isize, &'a isize)? (Yes)\n+    for<'a>    fn(&'a isize, &'a isize) <: for<'a,'b> fn(&'a isize, &'b isize)? (No)\n \n Here, it is true that functions which take two pointers with any two\n lifetimes can be treated as if they only accepted two pointers with"}, {"sha": "2dc16d4fa1dd419e0edacba3142cb00847adebe4", "filename": "src/librustc/middle/infer/region_inference/README.md", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2FREADME.md?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -121,7 +121,7 @@ every expression, block, and pattern (patterns are considered to\n \"execute\" by testing the value they are applied to and creating any\n relevant bindings).  So, for example:\n \n-    fn foo(x: int, y: int) { // -+\n+    fn foo(x: isize, y: isize) { // -+\n     //  +------------+       //  |\n     //  |      +-----+       //  |\n     //  |  +-+ +-+ +-+       //  |\n@@ -168,13 +168,13 @@ an error.\n Here is a more involved example (which is safe) so we can see what's\n going on:\n \n-    struct Foo { f: uint, g: uint }\n+    struct Foo { f: usize, g: usize }\n     ...\n-    fn add(p: &mut uint, v: uint) {\n+    fn add(p: &mut usize, v: usize) {\n         *p += v;\n     }\n     ...\n-    fn inc(p: &mut uint) -> uint {\n+    fn inc(p: &mut usize) -> usize {\n         *p += 1; *p\n     }\n     fn weird() {\n@@ -199,8 +199,8 @@ in a call expression:\n \n     'a: {\n         'a_arg1: let a_temp1: ... = add;\n-        'a_arg2: let a_temp2: &'a mut uint = &'a mut (*x).f;\n-        'a_arg3: let a_temp3: uint = {\n+        'a_arg2: let a_temp2: &'a mut usize = &'a mut (*x).f;\n+        'a_arg3: let a_temp3: usize = {\n             let b_temp1: ... = inc;\n             let b_temp2: &'b = &'b mut (*x).f;\n             'b_call: b_temp1(b_temp2)\n@@ -225,13 +225,13 @@ it will not be *dereferenced* during the evaluation of the second\n argument, it can still be *invalidated* by that evaluation. Consider\n this similar but unsound example:\n \n-    struct Foo { f: uint, g: uint }\n+    struct Foo { f: usize, g: usize }\n     ...\n-    fn add(p: &mut uint, v: uint) {\n+    fn add(p: &mut usize, v: usize) {\n         *p += v;\n     }\n     ...\n-    fn consume(x: Box<Foo>) -> uint {\n+    fn consume(x: Box<Foo>) -> usize {\n         x.f + x.g\n     }\n     fn weird() {"}, {"sha": "92982af92dcfe7ad772500cb809f66812070bafa", "filename": "src/librustc/middle/traits/README.md", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2FREADME.md?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -12,10 +12,10 @@ reference to a trait. So, for example, if there is a generic function like:\n \n and then a call to that function:\n \n-    let v: Vec<int> = clone_slice([1, 2, 3])\n+    let v: Vec<isize> = clone_slice([1, 2, 3])\n \n it is the job of trait resolution to figure out (in which case)\n-whether there exists an impl of `int : Clone`\n+whether there exists an impl of `isize : Clone`\n \n Note that in some cases, like generic functions, we may not be able to\n find a specific impl, but we can figure out that the caller must\n@@ -115,27 +115,27 @@ trait Convert<Target> {\n \n This trait just has one method. It's about as simple as it gets. It\n converts from the (implicit) `Self` type to the `Target` type. If we\n-wanted to permit conversion between `int` and `uint`, we might\n+wanted to permit conversion between `isize` and `usize`, we might\n implement `Convert` like so:\n \n ```rust\n-impl Convert<uint> for int { ... } // int -> uint\n-impl Convert<int> for uint { ... } // uint -> int\n+impl Convert<usize> for isize { ... } // isize -> usize\n+impl Convert<isize> for usize { ... } // usize -> isize\n ```\n \n Now imagine there is some code like the following:\n \n ```rust\n-let x: int = ...;\n+let x: isize = ...;\n let y = x.convert();\n ```\n \n The call to convert will generate a trait reference `Convert<$Y> for\n-int`, where `$Y` is the type variable representing the type of\n+isize`, where `$Y` is the type variable representing the type of\n `y`. When we match this against the two impls we can see, we will find\n-that only one remains: `Convert<uint> for int`. Therefore, we can\n+that only one remains: `Convert<usize> for isize`. Therefore, we can\n select this impl, which will cause the type of `$Y` to be unified to\n-`uint`. (Note that while assembling candidates, we do the initial\n+`usize`. (Note that while assembling candidates, we do the initial\n unifications in a transaction, so that they don't affect one another.)\n \n There are tests to this effect in src/test/run-pass:\n@@ -225,7 +225,7 @@ Confirmation unifies the output type parameters of the trait with the\n values found in the obligation, possibly yielding a type error.  If we\n return to our example of the `Convert` trait from the previous\n section, confirmation is where an error would be reported, because the\n-impl specified that `T` would be `uint`, but the obligation reported\n+impl specified that `T` would be `usize`, but the obligation reported\n `char`. Hence the result of selection would be an error.\n \n ### Selection during translation\n@@ -250,20 +250,20 @@ Here is an example:\n     trait Foo { ... }\n     impl<U,T:Bar<U>> Foo for Vec<T> { ... }\n \n-    impl Bar<uint> for int { ... }\n+    impl Bar<usize> for isize { ... }\n \n-After one shallow round of selection for an obligation like `Vec<int>\n+After one shallow round of selection for an obligation like `Vec<isize>\n : Foo`, we would know which impl we want, and we would know that\n-`T=int`, but we do not know the type of `U`.  We must select the\n-nested obligation `int : Bar<U>` to find out that `U=uint`.\n+`T=isize`, but we do not know the type of `U`.  We must select the\n+nested obligation `isize : Bar<U>` to find out that `U=usize`.\n \n It would be good to only do *just as much* nested resolution as\n necessary. Currently, though, we just do a full resolution.\n \n # Higher-ranked trait bounds\n \n One of the more subtle concepts at work are *higher-ranked trait\n-bounds*. An example of such a bound is `for<'a> MyTrait<&'a int>`.\n+bounds*. An example of such a bound is `for<'a> MyTrait<&'a isize>`.\n Let's walk through how selection on higher-ranked trait references\n works.\n \n@@ -279,21 +279,21 @@ trait Foo<X> {\n ```\n \n Let's say we have a function `want_hrtb` that wants a type which\n-implements `Foo<&'a int>` for any `'a`:\n+implements `Foo<&'a isize>` for any `'a`:\n \n ```rust\n-fn want_hrtb<T>() where T : for<'a> Foo<&'a int> { ... }\n+fn want_hrtb<T>() where T : for<'a> Foo<&'a isize> { ... }\n ```\n \n-Now we have a struct `AnyInt` that implements `Foo<&'a int>` for any\n+Now we have a struct `AnyInt` that implements `Foo<&'a isize>` for any\n `'a`:\n \n ```rust\n struct AnyInt;\n-impl<'a> Foo<&'a int> for AnyInt { }\n+impl<'a> Foo<&'a isize> for AnyInt { }\n ```\n \n-And the question is, does `AnyInt : for<'a> Foo<&'a int>`? We want the\n+And the question is, does `AnyInt : for<'a> Foo<&'a isize>`? We want the\n answer to be yes. The algorithm for figuring it out is closely related\n to the subtyping for higher-ranked types (which is described in\n `middle::infer::higher_ranked::doc`, but also in a [paper by SPJ] that\n@@ -306,12 +306,12 @@ I recommend you read).\n [paper by SPJ]: http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n \n So let's work through our example. The first thing we would do is to\n-skolemize the obligation, yielding `AnyInt : Foo<&'0 int>` (here `'0`\n+skolemize the obligation, yielding `AnyInt : Foo<&'0 isize>` (here `'0`\n represents skolemized region #0). Note that now have no quantifiers;\n in terms of the compiler type, this changes from a `ty::PolyTraitRef`\n to a `TraitRef`. We would then create the `TraitRef` from the impl,\n using fresh variables for it's bound regions (and thus getting\n-`Foo<&'$a int>`, where `'$a` is the inference variable for `'a`). Next\n+`Foo<&'$a isize>`, where `'$a` is the inference variable for `'a`). Next\n we relate the two trait refs, yielding a graph with the constraint\n that `'0 == '$a`. Finally, we check for skolemization \"leaks\" -- a\n leak is basically any attempt to relate a skolemized region to another\n@@ -327,13 +327,13 @@ Let's consider a failure case. Imagine we also have a struct\n \n ```rust\n struct StaticInt;\n-impl Foo<&'static int> for StaticInt;\n+impl Foo<&'static isize> for StaticInt;\n ```\n \n-We want the obligation `StaticInt : for<'a> Foo<&'a int>` to be\n+We want the obligation `StaticInt : for<'a> Foo<&'a isize>` to be\n considered unsatisfied. The check begins just as before. `'a` is\n skolemized to `'0` and the impl trait reference is instantiated to\n-`Foo<&'static int>`. When we relate those two, we get a constraint\n+`Foo<&'static isize>`. When we relate those two, we get a constraint\n like `'static == '0`. This means that the taint set for `'0` is `{'0,\n 'static}`, which fails the leak check.\n \n@@ -358,13 +358,13 @@ impl<X,F> Foo<X> for F\n }\n ```\n \n-Now let's say we have a obligation `for<'a> Foo<&'a int>` and we match\n+Now let's say we have a obligation `for<'a> Foo<&'a isize>` and we match\n this impl. What obligation is generated as a result? We want to get\n-`for<'a> Bar<&'a int>`, but how does that happen?\n+`for<'a> Bar<&'a isize>`, but how does that happen?\n \n After the matching, we are in a position where we have a skolemized\n-substitution like `X => &'0 int`. If we apply this substitution to the\n-impl obligations, we get `F : Bar<&'0 int>`. Obviously this is not\n+substitution like `X => &'0 isize`. If we apply this substitution to the\n+impl obligations, we get `F : Bar<&'0 isize>`. Obviously this is not\n directly usable because the skolemized region `'0` cannot leak out of\n our computation.\n \n@@ -375,7 +375,7 @@ leak check passed, so this taint set consists solely of the skolemized\n region itself plus various intermediate region variables. We then walk\n the trait-reference and convert every region in that taint set back to\n a late-bound region, so in this case we'd wind up with `for<'a> F :\n-Bar<&'a int>`.\n+Bar<&'a isize>`.\n \n # Caching and subtle considerations therewith\n \n@@ -391,8 +391,8 @@ but *replay* its effects on the type variables.\n \n The high-level idea of how the cache works is that we first replace\n all unbound inference variables with skolemized versions. Therefore,\n-if we had a trait reference `uint : Foo<$1>`, where `$n` is an unbound\n-inference variable, we might replace it with `uint : Foo<%0>`, where\n+if we had a trait reference `usize : Foo<$1>`, where `$n` is an unbound\n+inference variable, we might replace it with `usize : Foo<%0>`, where\n `%n` is a skolemized type. We would then look this up in the cache.\n If we found a hit, the hit would tell us the immediate next step to\n take in the selection process: i.e., apply impl #22, or apply where\n@@ -401,17 +401,17 @@ Therefore, we search through impls and where clauses and so forth, and\n we come to the conclusion that the only possible impl is this one,\n with def-id 22:\n \n-    impl Foo<int> for uint { ... } // Impl #22\n+    impl Foo<isize> for usize { ... } // Impl #22\n \n-We would then record in the cache `uint : Foo<%0> ==>\n+We would then record in the cache `usize : Foo<%0> ==>\n ImplCandidate(22)`. Next we would confirm `ImplCandidate(22)`, which\n-would (as a side-effect) unify `$1` with `int`.\n+would (as a side-effect) unify `$1` with `isize`.\n \n-Now, at some later time, we might come along and see a `uint :\n-Foo<$3>`.  When skolemized, this would yield `uint : Foo<%0>`, just as\n+Now, at some later time, we might come along and see a `usize :\n+Foo<$3>`.  When skolemized, this would yield `usize : Foo<%0>`, just as\n before, and hence the cache lookup would succeed, yielding\n `ImplCandidate(22)`. We would confirm `ImplCandidate(22)` which would\n-(as a side-effect) unify `$3` with `int`.\n+(as a side-effect) unify `$3` with `isize`.\n \n ## Where clauses and the local vs global cache\n "}, {"sha": "8f2e5deb92c7dd5f9be9487f7e576f1b9a108e56", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -705,8 +705,19 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                             ol,\n                             moved_lp_msg,\n                             pat_ty));\n-                self.tcx.sess.fileline_help(span,\n-                    \"use `ref` to override\");\n+                match self.tcx.sess.codemap().span_to_snippet(span) {\n+                    Ok(string) => {\n+                        self.tcx.sess.span_suggestion(\n+                            span,\n+                            &format!(\"if you would like to borrow the value instead, \\\n+                                      use a `ref` binding as shown:\"),\n+                            format!(\"ref {}\", string));\n+                    },\n+                    Err(_) => {\n+                        self.tcx.sess.fileline_help(span,\n+                            \"use `ref` to override\");\n+                    },\n+                }\n             }\n \n             move_data::Captured => {"}, {"sha": "873950b0be893a9f93c835af860cf7413266a6e9", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -202,20 +202,24 @@ pub trait CompilerCalls<'a> {\n     // be called straight after options have been parsed but before anything\n     // else (e.g., selecting input and output).\n     fn early_callback(&mut self,\n-                      &getopts::Matches,\n-                      &diagnostics::registry::Registry)\n-                      -> Compilation;\n+                      _: &getopts::Matches,\n+                      _: &diagnostics::registry::Registry)\n+                      -> Compilation {\n+        Compilation::Continue\n+    }\n \n     // Hook for a callback late in the process of handling arguments. This will\n     // be called just before actual compilation starts (and before build_controller\n     // is called), after all arguments etc. have been completely handled.\n     fn late_callback(&mut self,\n-                     &getopts::Matches,\n-                     &Session,\n-                     &Input,\n-                     &Option<PathBuf>,\n-                     &Option<PathBuf>)\n-                     -> Compilation;\n+                     _: &getopts::Matches,\n+                     _: &Session,\n+                     _: &Input,\n+                     _: &Option<PathBuf>,\n+                     _: &Option<PathBuf>)\n+                     -> Compilation {\n+        Compilation::Continue\n+    }\n \n     // Called after we extract the input from the arguments. Gives the implementer\n     // an opportunity to change the inputs or to add some custom input handling.\n@@ -231,12 +235,14 @@ pub trait CompilerCalls<'a> {\n     // emitting error messages. Returning None will cause compilation to stop\n     // at this point.\n     fn no_input(&mut self,\n-                &getopts::Matches,\n-                &config::Options,\n-                &Option<PathBuf>,\n-                &Option<PathBuf>,\n-                &diagnostics::registry::Registry)\n-                -> Option<(Input, Option<PathBuf>)>;\n+                _: &getopts::Matches,\n+                _: &config::Options,\n+                _: &Option<PathBuf>,\n+                _: &Option<PathBuf>,\n+                _: &diagnostics::registry::Registry)\n+                -> Option<(Input, Option<PathBuf>)> {\n+        None\n+    }\n \n     // Parse pretty printing information from the arguments. The implementer can\n     // choose to ignore this (the default will return None) which will skip pretty"}, {"sha": "aa7f93776da22918cb8fd56d560d57a660459ce3", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -26,6 +26,7 @@ use ParentLink::{self, ModuleParentLink, BlockParentLink};\n use Resolver;\n use resolve_imports::Shadowable;\n use TypeNsDef;\n+use {resolve_error, ResolutionError};\n \n use self::DuplicateCheckingMode::*;\n use self::NamespaceError::*;\n@@ -208,10 +209,13 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     // Return an error here by looking up the namespace that\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n-                    self.resolve_error(sp,\n-                        &format!(\"duplicate definition of {} `{}`\",\n-                             namespace_error_to_string(duplicate_type),\n-                             token::get_name(name)));\n+                    resolve_error(\n+                        self,\n+                        sp,\n+                        ResolutionError::DuplicateDefinition(\n+                            namespace_error_to_string(duplicate_type),\n+                            name)\n+                    );\n                     {\n                         let r = child.span_for_namespace(ns);\n                         if let Some(sp) = r {\n@@ -304,8 +308,10 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             full_path.segments.last().unwrap().identifier.name;\n                         if &token::get_name(source_name)[..] == \"mod\" ||\n                            &token::get_name(source_name)[..] == \"self\" {\n-                            self.resolve_error(view_path.span,\n-                                \"`self` imports are only allowed within a { } list\");\n+                            resolve_error(self,\n+                                            view_path.span,\n+                                            ResolutionError::SelfImportsOnlyAllowedWithin\n+                            );\n                         }\n \n                         let subclass = SingleImport(binding.name,\n@@ -325,8 +331,11 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                             _ => None\n                         }).collect::<Vec<Span>>();\n                         if mod_spans.len() > 1 {\n-                            self.resolve_error(mod_spans[0],\n-                                \"`self` import can only appear once in the list\");\n+                            resolve_error(\n+                                self,\n+                                mod_spans[0],\n+                                ResolutionError::SelfImportCanOnlyAppearOnceInTheList\n+                            );\n                             for other_span in mod_spans.iter().skip(1) {\n                                 self.session.span_note(*other_span,\n                                     \"another `self` import appears here\");\n@@ -341,9 +350,12 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                                     let name = match module_path.last() {\n                                         Some(name) => *name,\n                                         None => {\n-                                            self.resolve_error(source_item.span,\n-                                                \"`self` import can only appear in an import list \\\n-                                                 with a non-empty prefix\");\n+                                            resolve_error(\n+                                                self,\n+                                                source_item.span,\n+                                                ResolutionError::\n+                                                SelfImportOnlyInImportListWithNonEmptyPrefix\n+                                            );\n                                             continue;\n                                         }\n                                     };"}, {"sha": "939991da20307f0679918f33677d9055b2c8e785", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -202,12 +202,52 @@ http://doc.rust-lang.org/reference.html#types\n }\n \n register_diagnostics! {\n-    E0157,\n-    E0153,\n+    E0153, // called no where\n+    E0157, // called from no where\n     E0253, // not directly importable\n     E0254, // import conflicts with imported crate in this module\n     E0257,\n     E0258,\n     E0364, // item is private\n-    E0365  // item is private\n+    E0365, // item is private\n+    E0401, // can't use type parameters from outer function\n+    E0402, // cannot use an outer type parameter in this context\n+    E0403, // the name `{}` is already used\n+    E0404, // is not a trait\n+    E0405, // use of undeclared trait name\n+    E0406, // undeclared associated type\n+    E0407, // method is not a member of trait\n+    E0408, // variable from pattern #1 is not bound in pattern #\n+    E0409, // variable is bound with different mode in pattern # than in\n+           // pattern #1\n+    E0410, // variable from pattern is not bound in pattern 1\n+    E0411, // use of `Self` outside of an impl or trait\n+    E0412, // use of undeclared\n+    E0413, // declaration of shadows an enum variant or unit-like struct in\n+           // scope\n+    E0414, // only irrefutable patterns allowed here\n+    E0415, // identifier is bound more than once in this parameter list\n+    E0416, // identifier is bound more than once in the same pattern\n+    E0417, // static variables cannot be referenced in a pattern, use a\n+           // `const` instead\n+    E0418, // is not an enum variant, struct or const\n+    E0419, // unresolved enum variant, struct or const\n+    E0420, // is not an associated const\n+    E0421, // unresolved associated const\n+    E0422, // does not name a structure\n+    E0423, // is a struct variant name, but this expression uses it like a\n+           // function name\n+    E0424, // `self` is not available in a static method.\n+    E0425, // unresolved name\n+    E0426, // use of undeclared label\n+    E0427, // cannot use `ref` binding mode with ...\n+    E0428, // duplicate definition of ...\n+    E0429, // `self` imports are only allowed within a { } list\n+    E0430, // `self` import can only appear once in the list\n+    E0431, // `self` import can only appear in an import list with a non-empty\n+           // prefix\n+    E0432, // unresolved import\n+    E0433, // failed to resolve\n+    E0434, // can't capture dynamic environment in a fn item\n+    E0435  // attempt to use a non-constant value in a constant\n }"}, {"sha": "e1afc33684ce65ea7b595d3b546feeace5405295", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 449, "deletions": 181, "changes": 630, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -99,7 +99,6 @@ use std::usize;\n use resolve_imports::{Target, ImportDirective, ImportResolution};\n use resolve_imports::Shadowable;\n \n-\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;\n@@ -109,6 +108,262 @@ mod record_exports;\n mod build_reduced_graph;\n mod resolve_imports;\n \n+pub enum ResolutionError<'a> {\n+    /// error E0401: can't use type parameters from outer function\n+    TypeParametersFromOuterFunction,\n+    /// error E0402: cannot use an outer type parameter in this context\n+    OuterTypeParameterContext,\n+    /// error E0403: the name is already used for a type parameter in this type parameter list\n+    NameAlreadyUsedInTypeParameterList(Name),\n+    /// error E0404: is not a trait\n+    IsNotATrait(&'a str),\n+    /// error E0405: use of undeclared trait name\n+    UndeclaredTraitName(&'a str),\n+    /// error E0406: undeclared associated type\n+    UndeclaredAssociatedType,\n+    /// error E0407: method is not a member of trait\n+    MethodNotMemberOfTrait(Name, &'a str),\n+    /// error E0408: variable `{}` from pattern #1 is not bound in pattern\n+    VariableNotBoundInPattern(Name, usize),\n+    /// error E0409: variable is bound with different mode in pattern #{} than in pattern #1\n+    VariableBoundWithDifferentMode(Name, usize),\n+    /// error E0410: variable from pattern is not bound in pattern #1\n+    VariableNotBoundInParentPattern(Name, usize),\n+    /// error E0411: use of `Self` outside of an impl or trait\n+    SelfUsedOutsideImplOrTrait,\n+    /// error E0412: use of undeclared\n+    UseOfUndeclared(&'a str, &'a str),\n+    /// error E0413: declaration shadows an enum variant or unit-like struct in scope\n+    DeclarationShadowsEnumVariantOrUnitLikeStruct(Name),\n+    /// error E0414: only irrefutable patterns allowed here\n+    OnlyIrrefutablePatternsAllowedHere,\n+    /// error E0415: identifier is bound more than once in this parameter list\n+    IdentifierBoundMoreThanOnceInParameterList(&'a str),\n+    /// error E0416: identifier is bound more than once in the same pattern\n+    IdentifierBoundMoreThanOnceInSamePattern(&'a str),\n+    /// error E0417: static variables cannot be referenced in a pattern\n+    StaticVariableReference,\n+    /// error E0418: is not an enum variant, struct or const\n+    NotAnEnumVariantStructOrConst(&'a str),\n+    /// error E0419: unresolved enum variant, struct or const\n+    UnresolvedEnumVariantStructOrConst(&'a str),\n+    /// error E0420: is not an associated const\n+    NotAnAssociatedConst(&'a str),\n+    /// error E0421: unresolved associated const\n+    UnresolvedAssociatedConst(&'a str),\n+    /// error E0422: does not name a struct\n+    DoesNotNameAStruct(&'a str),\n+    /// error E0423: is a struct variant name, but this expression uses it like a function name\n+    StructVariantUsedAsFunction(&'a str),\n+    /// error E0424: `self` is not available in a static method\n+    SelfNotAvailableInStaticMethod,\n+    /// error E0425: unresolved name\n+    UnresolvedName(&'a str, &'a str),\n+    /// error E0426: use of undeclared label\n+    UndeclaredLabel(&'a str),\n+    /// error E0427: cannot use `ref` binding mode with ...\n+    CannotUseRefBindingModeWith(&'a str),\n+    /// error E0428: duplicate definition\n+    DuplicateDefinition(&'a str, Name),\n+    /// error E0429: `self` imports are only allowed within a { } list\n+    SelfImportsOnlyAllowedWithin,\n+    /// error E0430: `self` import can only appear once in the list\n+    SelfImportCanOnlyAppearOnceInTheList,\n+    /// error E0431: `self` import can only appear in an import list with a non-empty prefix\n+    SelfImportOnlyInImportListWithNonEmptyPrefix,\n+    /// error E0432: unresolved import\n+    UnresolvedImport(Option<(&'a str, Option<&'a str>)>),\n+    /// error E0433: failed to resolve\n+    FailedToResolve(&'a str),\n+    /// error E0434: can't capture dynamic environment in a fn item\n+    CannotCaptureDynamicEnvironmentInFnItem,\n+    /// error E0435: attempt to use a non-constant value in a constant\n+    AttemptToUseNonConstantValueInConstant,\n+}\n+\n+fn resolve_error<'b, 'a:'b, 'tcx:'a>(resolver: &'b Resolver<'a, 'tcx>, span: syntax::codemap::Span,\n+                                     resolution_error: ResolutionError<'b>) {\n+    if !resolver.emit_errors {\n+        return;\n+    }\n+    match resolution_error {\n+        ResolutionError::TypeParametersFromOuterFunction => {\n+            span_err!(resolver.session, span, E0401, \"can't use type parameters from \\\n+                                                      outer function; try using a local \\\n+                                                      type parameter instead\");\n+        },\n+        ResolutionError::OuterTypeParameterContext => {\n+            span_err!(resolver.session, span, E0402,\n+                         \"cannot use an outer type parameter in this context\");\n+        },\n+        ResolutionError::NameAlreadyUsedInTypeParameterList(name) => {\n+            span_err!(resolver.session, span, E0403,\n+                         \"the name `{}` is already used for a type \\\n+                          parameter in this type parameter list\", name);\n+        },\n+        ResolutionError::IsNotATrait(name) => {\n+            span_err!(resolver.session, span, E0404,\n+                         \"`{}` is not a trait\",\n+                         name);\n+        },\n+        ResolutionError::UndeclaredTraitName(name) => {\n+            span_err!(resolver.session, span, E0405,\n+                         \"use of undeclared trait name `{}`\",\n+                         name);\n+        },\n+        ResolutionError::UndeclaredAssociatedType => {\n+            span_err!(resolver.session, span, E0406, \"undeclared associated type\");\n+        },\n+        ResolutionError::MethodNotMemberOfTrait(method, trait_) => {\n+            span_err!(resolver.session, span, E0407,\n+                         \"method `{}` is not a member of trait `{}`\",\n+                         method,\n+                         trait_);\n+        },\n+        ResolutionError::VariableNotBoundInPattern(variable_name, pattern_number) => {\n+            span_err!(resolver.session, span, E0408,\n+                         \"variable `{}` from pattern #1 is not bound in pattern #{}\",\n+                         variable_name,\n+                         pattern_number);\n+        },\n+        ResolutionError::VariableBoundWithDifferentMode(variable_name, pattern_number) => {\n+            span_err!(resolver.session, span, E0409,\n+                         \"variable `{}` is bound with different \\\n+                         mode in pattern #{} than in pattern #1\",\n+                         variable_name,\n+                         pattern_number);\n+        },\n+        ResolutionError::VariableNotBoundInParentPattern(variable_name, pattern_number) => {\n+            span_err!(resolver.session, span, E0410,\n+                         \"variable `{}` from pattern #{} is not bound in pattern #1\",\n+                         variable_name,\n+                         pattern_number);\n+        },\n+        ResolutionError::SelfUsedOutsideImplOrTrait => {\n+            span_err!(resolver.session, span, E0411, \"use of `Self` outside of an impl or trait\");\n+        },\n+        ResolutionError::UseOfUndeclared(kind, name) => {\n+            span_err!(resolver.session, span, E0412,\n+                         \"use of undeclared {} `{}`\",\n+                         kind,\n+                         name);\n+        },\n+        ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(name) => {\n+            span_err!(resolver.session, span, E0413,\n+                         \"declaration of `{}` shadows an enum variant or unit-like struct in \\\n+                          scope\",\n+                         name);\n+        },\n+        ResolutionError::OnlyIrrefutablePatternsAllowedHere => {\n+            span_err!(resolver.session, span, E0414, \"only irrefutable patterns allowed here\");\n+        },\n+        ResolutionError::IdentifierBoundMoreThanOnceInParameterList(identifier) => {\n+            span_err!(resolver.session, span, E0415,\n+                         \"identifier `{}` is bound more than once in this parameter list\",\n+                         identifier);\n+        },\n+        ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(identifier) => {\n+            span_err!(resolver.session, span, E0416,\n+                         \"identifier `{}` is bound more than once in the same pattern\",\n+                         identifier);\n+        },\n+        ResolutionError::StaticVariableReference => {\n+            span_err!(resolver.session, span, E0417, \"static variables cannot be \\\n+                                                      referenced in a pattern, \\\n+                                                      use a `const` instead\");\n+        },\n+        ResolutionError::NotAnEnumVariantStructOrConst(name) => {\n+            span_err!(resolver.session, span, E0418,\n+                         \"`{}` is not an enum variant, struct or const\",\n+                         name);\n+        },\n+        ResolutionError::UnresolvedEnumVariantStructOrConst(name) => {\n+            span_err!(resolver.session, span, E0419,\n+                         \"unresolved enum variant, struct or const `{}`\",\n+                         name);\n+        },\n+        ResolutionError::NotAnAssociatedConst(name) => {\n+            span_err!(resolver.session, span, E0420,\n+                         \"`{}` is not an associated const\",\n+                         name);\n+        },\n+        ResolutionError::UnresolvedAssociatedConst(name) => {\n+            span_err!(resolver.session, span, E0421,\n+                         \"unresolved associated const `{}`\",\n+                         name);\n+        },\n+        ResolutionError::DoesNotNameAStruct(name) => {\n+            span_err!(resolver.session, span, E0422, \"`{}` does not name a structure\", name);\n+        },\n+        ResolutionError::StructVariantUsedAsFunction(path_name) => {\n+            span_err!(resolver.session, span, E0423,\n+                         \"`{}` is a struct variant name, but \\\n+                          this expression \\\n+                          uses it like a function name\",\n+                          path_name);\n+        },\n+        ResolutionError::SelfNotAvailableInStaticMethod => {\n+            span_err!(resolver.session, span, E0424, \"`self` is not available in a static method. \\\n+                                                      Maybe a `self` argument is missing?\");\n+        },\n+        ResolutionError::UnresolvedName(path, name) => {\n+            span_err!(resolver.session, span, E0425,\n+                         \"unresolved name `{}`{}\",\n+                         path,\n+                         name);\n+        },\n+        ResolutionError::UndeclaredLabel(name) => {\n+            span_err!(resolver.session, span, E0426,\n+                         \"use of undeclared label `{}`\",\n+                         name);\n+        },\n+        ResolutionError::CannotUseRefBindingModeWith(descr) => {\n+            span_err!(resolver.session, span, E0427,\n+                         \"cannot use `ref` binding mode with {}\",\n+                         descr);\n+        },\n+        ResolutionError::DuplicateDefinition(namespace, name) => {\n+            span_err!(resolver.session, span, E0428,\n+                         \"duplicate definition of {} `{}`\",\n+                         namespace,\n+                         name);\n+        },\n+        ResolutionError::SelfImportsOnlyAllowedWithin => {\n+            span_err!(resolver.session, span, E0429, \"{}\",\n+                         \"`self` imports are only allowed within a { } list\");\n+        },\n+        ResolutionError::SelfImportCanOnlyAppearOnceInTheList => {\n+            span_err!(resolver.session, span, E0430,\n+                         \"`self` import can only appear once in the list\");\n+        },\n+        ResolutionError::SelfImportOnlyInImportListWithNonEmptyPrefix => {\n+            span_err!(resolver.session, span, E0431,\n+                         \"`self` import can only appear in an import list with a \\\n+                          non-empty prefix\");\n+        }\n+        ResolutionError::UnresolvedImport(name) => {\n+            let msg = match name {\n+                Some((n, Some(p))) => format!(\"unresolved import `{}`{}\", n, p),\n+                Some((n, None)) => format!(\"unresolved import (maybe you meant `{}::*`?)\", n),\n+                None => \"unresolved import\".to_owned()\n+            };\n+            span_err!(resolver.session, span, E0432, \"{}\", msg);\n+        },\n+        ResolutionError::FailedToResolve(msg) => {\n+            span_err!(resolver.session, span, E0433, \"failed to resolve. {}\", msg);\n+        },\n+        ResolutionError::CannotCaptureDynamicEnvironmentInFnItem => {\n+            span_err!(resolver.session, span, E0434, \"{}\",\n+                         \"can't capture dynamic environment in a fn item; \\\n+                          use the || { ... } closure form instead\");\n+        },\n+        ResolutionError::AttemptToUseNonConstantValueInConstant =>{\n+            span_err!(resolver.session, span, E0435,\n+                         \"attempt to use a non-constant value in a constant\");\n+        },\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n struct BindingInfo {\n     span: Span,\n@@ -947,8 +1202,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if module.external_module_children.borrow().contains_key(&name) {\n                 span_err!(self.session, span, E0259,\n                           \"an external crate named `{}` has already \\\n-                                   been imported into this module\",\n-                                  &token::get_name(name));\n+                           been imported into this module\",\n+                          name);\n         }\n     }\n \n@@ -960,9 +1215,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if module.external_module_children.borrow().contains_key(&name) {\n                 span_err!(self.session, span, E0260,\n                           \"the name `{}` conflicts with an external \\\n-                                   crate that has been imported into this \\\n-                                   module\",\n-                                  &token::get_name(name));\n+                           crate that has been imported into this \\\n+                           module\",\n+                           name);\n         }\n     }\n \n@@ -1041,7 +1296,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Indeterminate => {\n                     debug!(\"(resolving module path for import) module \\\n                             resolution is indeterminate: {}\",\n-                            token::get_name(name));\n+                            name);\n                     return Indeterminate;\n                 }\n                 Success((target, used_proxy)) => {\n@@ -1052,7 +1307,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             match type_def.module_def {\n                                 None => {\n                                     let msg = format!(\"Not a module `{}`\",\n-                                                        token::get_name(name));\n+                                                        name);\n \n                                     return Failed(Some((span, msg)));\n                                 }\n@@ -1078,7 +1333,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         None => {\n                             // There are no type bindings at all.\n                             let msg = format!(\"Not a module `{}`\",\n-                                              token::get_name(name));\n+                                              name);\n                             return Failed(Some((span, msg)));\n                         }\n                     }\n@@ -1200,7 +1455,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving item in lexical scope) resolving `{}` in \\\n                 namespace {:?} in `{}`\",\n-               token::get_name(name),\n+               name,\n                namespace,\n                module_to_string(&*module_));\n \n@@ -1302,9 +1557,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               namespace,\n                                               PathSearch,\n                                               true) {\n-                Failed(Some((span, msg))) =>\n-                    self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                     msg)),\n+                Failed(Some((span, msg))) => {\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n+                },\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -1469,7 +1724,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                               allow_private_imports: bool)\n                               -> ResolveResult<(Target, bool)> {\n         debug!(\"(resolving name in module) resolving `{}` in `{}`\",\n-               &token::get_name(name),\n+               name,\n                module_to_string(&*module_));\n \n         // First, check the direct children of the module.\n@@ -1547,7 +1802,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // We're out of luck.\n         debug!(\"(resolving name in module) failed to resolve `{}`\",\n-               &token::get_name(name));\n+               name);\n         return Failed(None);\n     }\n \n@@ -1561,12 +1816,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                          .span_to_snippet((*imports)[index].span)\n                          .unwrap();\n             if sn.contains(\"::\") {\n-                self.resolve_error((*imports)[index].span,\n-                                   \"unresolved import\");\n+                resolve_error(self,\n+                              (*imports)[index].span,\n+                              ResolutionError::UnresolvedImport(None));\n             } else {\n-                let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n-                                  sn);\n-                self.resolve_error((*imports)[index].span, &err[..]);\n+                resolve_error(self,\n+                              (*imports)[index].span,\n+                              ResolutionError::UnresolvedImport(Some((&*sn, None))));\n             }\n         }\n \n@@ -1623,15 +1879,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match orig_module.children.borrow().get(&name) {\n                     None => {\n                         debug!(\"!!! (with scope) didn't find `{}` in `{}`\",\n-                               token::get_name(name),\n+                               name,\n                                module_to_string(&*orig_module));\n                     }\n                     Some(name_bindings) => {\n                         match (*name_bindings).get_module_if_available() {\n                             None => {\n                                 debug!(\"!!! (with scope) didn't find module \\\n                                         for `{}` in `{}`\",\n-                                       token::get_name(name),\n+                                       name,\n                                        module_to_string(&*orig_module));\n                             }\n                             Some(module_) => {\n@@ -1692,17 +1948,20 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-\n-                            self.resolve_error(span,\n-                                \"can't capture dynamic environment in a fn item; \\\n-                                 use the || { ... } closure form instead\");\n+                            resolve_error(\n+                                self,\n+                                span,\n+                                ResolutionError::CannotCaptureDynamicEnvironmentInFnItem\n+                            );\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // Still doesn't deal with upvars\n-                            self.resolve_error(span,\n-                                               \"attempt to use a non-constant \\\n-                                                value in a constant\");\n+                            resolve_error(\n+                                self,\n+                                span,\n+                                ResolutionError::AttemptToUseNonConstantValueInConstant\n+                            );\n                             return None;\n                         }\n                     }\n@@ -1718,17 +1977,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             // This was an attempt to use a type parameter outside\n                             // its scope.\n \n-                            self.resolve_error(span,\n-                                               \"can't use type parameters from \\\n-                                                outer function; try using a local \\\n-                                                type parameter instead\");\n+                            resolve_error(self,\n+                                          span,\n+                                          ResolutionError::TypeParametersFromOuterFunction);\n                             return None;\n                         }\n                         ConstantItemRibKind => {\n                             // see #9186\n-                            self.resolve_error(span,\n-                                               \"cannot use an outer type \\\n-                                                parameter in this context\");\n+                            resolve_error(self, span, ResolutionError::OuterTypeParameterContext);\n                             return None;\n                         }\n                     }\n@@ -1795,7 +2051,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name = item.ident.name;\n \n         debug!(\"(resolving item) resolving {}\",\n-               token::get_name(name));\n+               name);\n \n         match item.node {\n             ItemEnum(_, ref generics) |\n@@ -1921,12 +2177,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     debug!(\"with_type_parameter_rib: {}\", type_parameter.id);\n \n                     if seen_bindings.contains(&name) {\n-                        self.resolve_error(type_parameter.span,\n-                                           &format!(\"the name `{}` is already \\\n-                                                     used for a type \\\n-                                                     parameter in this type \\\n-                                                     parameter list\",\n-                                                    token::get_name(name)))\n+                        resolve_error(self,\n+                                      type_parameter.span,\n+                                      ResolutionError::NameAlreadyUsedInTypeParameterList(\n+                                        name)\n+                        );\n                     }\n                     seen_bindings.insert(name);\n \n@@ -2013,9 +2268,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 debug!(\"(resolving trait) found trait def: {:?}\", path_res);\n                 Ok(path_res)\n             } else {\n-                self.resolve_error(trait_path.span,\n-                    &format!(\"`{}` is not a trait\",\n-                             path_names_to_string(trait_path, path_depth)));\n+                resolve_error(self,\n+                              trait_path.span,\n+                              ResolutionError::IsNotATrait(&*path_names_to_string(trait_path,\n+                                                                                   path_depth))\n+                             );\n \n                 // If it's a typedef, give a note\n                 if let DefTy(..) = path_res.base_def {\n@@ -2025,9 +2282,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 Err(())\n             }\n         } else {\n-            let msg = format!(\"use of undeclared trait name `{}`\",\n-                              path_names_to_string(trait_path, path_depth));\n-            self.resolve_error(trait_path.span, &msg);\n+            resolve_error(self,\n+                          trait_path.span,\n+                          ResolutionError::UndeclaredTraitName(\n+                            &*path_names_to_string(trait_path, path_depth))\n+                         );\n             Err(())\n         }\n     }\n@@ -2045,7 +2304,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     if let Some(PathResolution { base_def: DefTyParam(..), .. }) = path_res {\n                         self.record_def(eq_pred.id, path_res.unwrap());\n                     } else {\n-                        self.resolve_error(eq_pred.path.span, \"undeclared associated type\");\n+                        resolve_error(self,\n+                                      eq_pred.span,\n+                                      ResolutionError::UndeclaredAssociatedType);\n                     }\n                 }\n             }\n@@ -2170,10 +2431,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if let Some((did, ref trait_ref)) = self.current_trait_ref {\n             if !self.trait_item_map.contains_key(&(name, did)) {\n                 let path_str = path_names_to_string(&trait_ref.path, 0);\n-                self.resolve_error(span,\n-                                    &format!(\"method `{}` is not a member of trait `{}`\",\n-                                            token::get_name(name),\n-                                            path_str));\n+                resolve_error(self,\n+                              span,\n+                              ResolutionError::MethodNotMemberOfTrait(name,\n+                                                                       &*path_str));\n             }\n         }\n     }\n@@ -2220,34 +2481,29 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             for (&key, &binding_0) in &map_0 {\n                 match map_i.get(&key) {\n                   None => {\n-                    self.resolve_error(\n-                        p.span,\n-                        &format!(\"variable `{}` from pattern #1 is \\\n-                                  not bound in pattern #{}\",\n-                                token::get_name(key),\n-                                i + 1));\n+                    resolve_error(self,\n+                                  p.span,\n+                                  ResolutionError::VariableNotBoundInPattern(key,\n+                                                                              i + 1));\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n-                        self.resolve_error(\n-                            binding_i.span,\n-                            &format!(\"variable `{}` is bound with different \\\n-                                      mode in pattern #{} than in pattern #1\",\n-                                    token::get_name(key),\n-                                    i + 1));\n+                        resolve_error(self,\n+                                      binding_i.span,\n+                                      ResolutionError::VariableBoundWithDifferentMode(key,\n+                                                                                       i + 1)\n+                                     );\n                     }\n                   }\n                 }\n             }\n \n             for (&key, &binding) in &map_i {\n                 if !map_0.contains_key(&key) {\n-                    self.resolve_error(\n-                        binding.span,\n-                        &format!(\"variable `{}` from pattern {}{} is \\\n-                                  not bound in pattern {}1\",\n-                                token::get_name(key),\n-                                \"#\", i + 1, \"#\"));\n+                    resolve_error(self,\n+                                  binding.span,\n+                                  ResolutionError::VariableNotBoundInParentPattern(key,\n+                                                                                    i + 1));\n                 }\n             }\n         }\n@@ -2360,14 +2616,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             path.segments.len() > 0 &&\n                             maybe_qself.is_none() &&\n                             path.segments[0].identifier.name == self_type_name;\n-                        let msg = if is_invalid_self_type_name {\n-                            \"use of `Self` outside of an impl or trait\".to_string()\n+                        if is_invalid_self_type_name {\n+                            resolve_error(self,\n+                                          ty.span,\n+                                          ResolutionError::SelfUsedOutsideImplOrTrait);\n                         } else {\n-                            format!(\"use of undeclared {} `{}`\",\n-                                kind, path_names_to_string(path, 0))\n-                        };\n-\n-                        self.resolve_error(ty.span, &msg[..]);\n+                            resolve_error(self,\n+                                          ty.span,\n+                                          ResolutionError::UseOfUndeclared(\n+                                                                    kind,\n+                                                                    &*path_names_to_string(path,\n+                                                                                           0))\n+                                         );\n+                        }\n                     }\n                 }\n             }\n@@ -2405,7 +2666,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     struct or enum variant\",\n-                                   token::get_name(renamed));\n+                                   renamed);\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -2418,17 +2679,17 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n                         }\n                         FoundStructOrEnumVariant(..) => {\n-                            self.resolve_error(\n+                            resolve_error(\n+                                self,\n                                 pattern.span,\n-                                &format!(\"declaration of `{}` shadows an enum \\\n-                                         variant or unit-like struct in \\\n-                                         scope\",\n-                                        token::get_name(renamed)));\n+                                ResolutionError::DeclarationShadowsEnumVariantOrUnitLikeStruct(\n+                                    renamed)\n+                            );\n                         }\n                         FoundConst(def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n                                     constant\",\n-                                   token::get_name(renamed));\n+                                   renamed);\n \n                             self.enforce_default_binding_mode(\n                                 pattern,\n@@ -2441,13 +2702,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             });\n                         }\n                         FoundConst(..) => {\n-                            self.resolve_error(pattern.span,\n-                                                  \"only irrefutable patterns \\\n-                                                   allowed here\");\n+                            resolve_error(\n+                                self,\n+                                pattern.span,\n+                                ResolutionError::OnlyIrrefutablePatternsAllowedHere\n+                            );\n                         }\n                         BareIdentifierPatternUnresolved => {\n                             debug!(\"(resolving pattern) binding `{}`\",\n-                                   token::get_name(renamed));\n+                                   renamed);\n \n                             let def = DefLocal(pattern.id);\n \n@@ -2475,24 +2738,22 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     bindings_list.contains_key(&renamed) {\n                                 // Forbid duplicate bindings in the same\n                                 // parameter list.\n-                                self.resolve_error(pattern.span,\n-                                                   &format!(\"identifier `{}` \\\n-                                                            is bound more \\\n-                                                            than once in \\\n-                                                            this parameter \\\n-                                                            list\",\n-                                                           token::get_ident(\n-                                                               ident))\n-                                                   )\n+                                resolve_error(\n+                                    self,\n+                                    pattern.span,\n+                                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n+                                        &*token::get_ident(ident))\n+                                );\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n                                 // same disjunction, which is an error.\n-                                self.resolve_error(pattern.span,\n-                                    &format!(\"identifier `{}` is bound \\\n-                                             more than once in the same \\\n-                                             pattern\",\n-                                            token::get_ident(ident)));\n+                                resolve_error(\n+                                    self,\n+                                    pattern.span,\n+                                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n+                                        &*token::get_ident(ident))\n+                                );\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -2523,22 +2784,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             DefStatic(..) => {\n-                                self.resolve_error(path.span,\n-                                                   \"static variables cannot be \\\n-                                                    referenced in a pattern, \\\n-                                                    use a `const` instead\");\n+                                resolve_error(&self,\n+                                              path.span,\n+                                              ResolutionError::StaticVariableReference);\n                             }\n                             _ => {\n                                 // If anything ends up here entirely resolved,\n                                 // it's an error. If anything ends up here\n                                 // partially resolved, that's OK, because it may\n                                 // be a `T::CONST` that typeck will resolve.\n                                 if path_res.depth == 0 {\n-                                    self.resolve_error(\n+                                    resolve_error(\n+                                        self,\n                                         path.span,\n-                                        &format!(\"`{}` is not an enum variant, struct or const\",\n-                                                 token::get_ident(\n-                                                     path.segments.last().unwrap().identifier)));\n+                                        ResolutionError::NotAnEnumVariantStructOrConst(\n+                                            &*token::get_ident(\n+                                                path.segments.last().unwrap().identifier)\n+                                            )\n+                                    );\n                                 } else {\n                                     let const_name = path.segments.last().unwrap()\n                                                          .identifier.name;\n@@ -2549,9 +2812,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             }\n                         }\n                     } else {\n-                        self.resolve_error(path.span,\n-                            &format!(\"unresolved enum variant, struct or const `{}`\",\n-                                token::get_ident(path.segments.last().unwrap().identifier)));\n+                        resolve_error(\n+                            self,\n+                            path.span,\n+                            ResolutionError::UnresolvedEnumVariantStructOrConst(\n+                                &*token::get_ident(path.segments.last().unwrap().identifier))\n+                        );\n                     }\n                     visit::walk_path(self, path);\n                 }\n@@ -2583,16 +2849,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 self.record_def(pattern.id, path_res);\n                             }\n                             _ => {\n-                                self.resolve_error(path.span,\n-                                    &format!(\"`{}` is not an associated const\",\n-                                        token::get_ident(\n-                                            path.segments.last().unwrap().identifier)));\n+                                resolve_error(\n+                                    self,\n+                                    path.span,\n+                                    ResolutionError::NotAnAssociatedConst(\n+                                        &*token::get_ident(\n+                                            path.segments.last().unwrap().identifier)\n+                                    )\n+                                );\n                             }\n                         }\n                     } else {\n-                        self.resolve_error(path.span,\n-                            &format!(\"unresolved associated const `{}`\",\n-                                token::get_ident(path.segments.last().unwrap().identifier)));\n+                        resolve_error(\n+                            self,\n+                            path.span,\n+                            ResolutionError::UnresolvedAssociatedConst(\n+                                &*token::get_ident(path.segments.last().unwrap().identifier)\n+                            )\n+                        );\n                     }\n                     visit::walk_pat(self, pattern);\n                 }\n@@ -2605,9 +2879,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         result => {\n                             debug!(\"(resolving pattern) didn't find struct \\\n                                     def: {:?}\", result);\n-                            let msg = format!(\"`{}` does not name a structure\",\n-                                              path_names_to_string(path, 0));\n-                            self.resolve_error(path.span, &msg[..]);\n+                            resolve_error(\n+                                self,\n+                                path.span,\n+                                ResolutionError::DoesNotNameAStruct(\n+                                    &*path_names_to_string(path, 0))\n+                            );\n                         }\n                     }\n                     visit::walk_path(self, path);\n@@ -2634,7 +2911,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Success((target, _)) => {\n                 debug!(\"(resolve bare identifier pattern) succeeded in \\\n                          finding {} at {:?}\",\n-                        token::get_name(name),\n+                        name,\n                         target.bindings.value_def.borrow());\n                 match *target.bindings.value_def.borrow() {\n                     None => {\n@@ -2653,10 +2930,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 return FoundConst(def, LastMod(AllPublic));\n                             }\n                             DefStatic(..) => {\n-                                self.resolve_error(span,\n-                                                   \"static variables cannot be \\\n-                                                    referenced in a pattern, \\\n-                                                    use a `const` instead\");\n+                                resolve_error(self,\n+                                              span,\n+                                              ResolutionError::StaticVariableReference);\n                                 return BareIdentifierPatternUnresolved;\n                             }\n                             _ => {\n@@ -2673,14 +2949,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n-                        self.resolve_error(span, &format!(\"failed to resolve: {}\",\n-                                                         msg));\n+                        resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                     }\n                     None => ()\n                 }\n \n                 debug!(\"(resolve bare identifier pattern) failed to find {}\",\n-                        token::get_name(name));\n+                        name);\n                 return BareIdentifierPatternUnresolved;\n             }\n         }\n@@ -2903,8 +3178,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg));\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -2963,8 +3237,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                 msg));\n+                resolve_error(self, span, ResolutionError::FailedToResolve(&*msg));\n                 return None;\n             }\n \n@@ -3038,13 +3311,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         // found a module instead. Modules don't have defs.\n                         debug!(\"(resolving item path by identifier in lexical \\\n                                  scope) failed to resolve {} after success...\",\n-                                 token::get_name(name));\n+                                 name);\n                         return None;\n                     }\n                     Some(def) => {\n                         debug!(\"(resolving item path in lexical scope) \\\n                                 resolved `{}` to item\",\n-                               token::get_name(name));\n+                               name);\n                         // This lookup is \"all public\" because it only searched\n                         // for one identifier in the current module (couldn't\n                         // have passed through reexports or anything like that.\n@@ -3057,10 +3330,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             Failed(err) => {\n                 debug!(\"(resolving item path by identifier in lexical scope) \\\n-                         failed to resolve {}\", token::get_name(name));\n+                         failed to resolve {}\", name);\n \n                 if let Some((span, msg)) = err {\n-                    self.resolve_error(span, &format!(\"failed to resolve. {}\", msg))\n+                    resolve_error(self, span, ResolutionError::FailedToResolve(&*msg))\n                 }\n \n                 return None;\n@@ -3077,12 +3350,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         rs\n     }\n \n-    fn resolve_error(&self, span: Span, s: &str) {\n-        if self.emit_errors {\n-            self.session.span_err(span, s);\n-        }\n-    }\n-\n     fn find_fallback_in_self_type(&mut self, name: Name) -> FallbackSuggestion {\n         fn extract_path_and_node_id(t: &Ty, allow: FallbackChecks)\n                                                     -> Option<(Path, NodeId, FallbackChecks)> {\n@@ -3268,11 +3535,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     // Check if struct variant\n                     if let DefVariant(_, _, true) = path_res.base_def {\n                         let path_name = path_names_to_string(path, 0);\n-                        self.resolve_error(expr.span,\n-                                &format!(\"`{}` is a struct variant name, but \\\n-                                          this expression \\\n-                                          uses it like a function name\",\n-                                         path_name));\n+\n+                        resolve_error(self,\n+                                      expr.span,\n+                                      ResolutionError::StructVariantUsedAsFunction(&*path_name));\n \n                         let msg = format!(\"did you mean to write: \\\n                                            `{} {{ /* fields */ }}`?\",\n@@ -3309,11 +3575,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     match type_res.map(|r| r.base_def) {\n                         Some(DefTy(struct_id, _))\n                             if self.structs.contains_key(&struct_id) => {\n-                                self.resolve_error(expr.span,\n-                                    &format!(\"`{}` is a structure name, but \\\n-                                                this expression \\\n-                                                uses it like a function name\",\n-                                                path_name));\n+                                resolve_error(\n+                                    self,\n+                                    expr.span,\n+                                    ResolutionError::StructVariantUsedAsFunction(\n+                                        &*path_name)\n+                                );\n \n                                 let msg = format!(\"did you mean to write: \\\n                                                      `{} {{ /* fields */ }}`?\",\n@@ -3340,11 +3607,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                             if method_scope &&\n                                &token::get_name(special_names::self_)[..] == path_name {\n-                                    self.resolve_error(\n-                                        expr.span,\n-                                        \"`self` is not available \\\n-                                         in a static method. Maybe a \\\n-                                         `self` argument is missing?\");\n+                                resolve_error(\n+                                    self,\n+                                    expr.span,\n+                                    ResolutionError::SelfNotAvailableInStaticMethod\n+                                );\n                             } else {\n                                 let last_name = path.segments.last().unwrap().identifier.name;\n                                 let mut msg = match self.find_fallback_in_self_type(last_name) {\n@@ -3368,10 +3635,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     msg = format!(\". Did you mean {}?\", msg)\n                                 }\n \n-                                self.resolve_error(\n-                                    expr.span,\n-                                    &format!(\"unresolved name `{}`{}\",\n-                                             path_name, msg));\n+                                resolve_error(self,\n+                                              expr.span,\n+                                              ResolutionError::UnresolvedName(&*path_name,\n+                                                                               &*msg));\n                             }\n                         }\n                     }\n@@ -3388,9 +3655,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some(definition) => self.record_def(expr.id, definition),\n                     None => {\n                         debug!(\"(resolving expression) didn't find struct def\",);\n-                        let msg = format!(\"`{}` does not name a structure\",\n-                                          path_names_to_string(path, 0));\n-                        self.resolve_error(path.span, &msg[..]);\n+\n+                        resolve_error(self,\n+                                      path.span,\n+                                      ResolutionError::DoesNotNameAStruct(\n+                                                                &*path_names_to_string(path, 0))\n+                                     );\n                     }\n                 }\n \n@@ -3415,10 +3685,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let renamed = mtwt::resolve(label);\n                 match self.search_label(renamed) {\n                     None => {\n-                        self.resolve_error(\n-                            expr.span,\n-                            &format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label)))\n+                        resolve_error(self,\n+                                      expr.span,\n+                                      ResolutionError::UndeclaredLabel(&*token::get_ident(label)))\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -3467,15 +3736,15 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn get_traits_containing_item(&mut self, name: Name) -> Vec<DefId> {\n         debug!(\"(getting traits containing item) looking for '{}'\",\n-               token::get_name(name));\n+               name);\n \n         fn add_trait_info(found_traits: &mut Vec<DefId>,\n                           trait_def_id: DefId,\n                           name: Name) {\n             debug!(\"(adding trait info) found trait {}:{} for method '{}'\",\n                 trait_def_id.krate,\n                 trait_def_id.node,\n-                token::get_name(name));\n+                name);\n             found_traits.push(trait_def_id);\n         }\n \n@@ -3564,10 +3833,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match pat_binding_mode {\n             BindByValue(_) => {}\n             BindByRef(..) => {\n-                self.resolve_error(pat.span,\n-                                   &format!(\"cannot use `ref` binding mode \\\n-                                            with {}\",\n-                                           descr));\n+                resolve_error(self,\n+                              pat.span,\n+                              ResolutionError::CannotUseRefBindingModeWith(descr));\n             }\n         }\n     }\n@@ -3586,7 +3854,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         debug!(\"Children:\");\n         build_reduced_graph::populate_module_if_necessary(self, &module_);\n         for (&name, _) in module_.children.borrow().iter() {\n-            debug!(\"* {}\", token::get_name(name));\n+            debug!(\"* {}\", name);\n         }\n \n         debug!(\"Import resolutions:\");\n@@ -3610,7 +3878,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             }\n \n-            debug!(\"* {}:{}{}\", token::get_name(name), value_repr, type_repr);\n+            debug!(\"* {}:{}{}\", name, value_repr, type_repr);\n         }\n     }\n }"}, {"sha": "e797da7b8f64bf299a85d664e3e494e9687335d3", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -22,6 +22,7 @@ use ResolveResult;\n use Resolver;\n use UseLexicalScopeFlag;\n use {names_to_string, module_to_string};\n+use {resolve_error, ResolutionError};\n \n use build_reduced_graph;\n \n@@ -272,12 +273,14 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         Some((span, msg)) => (span, format!(\". {}\", msg)),\n                         None => (import_directive.span, String::new())\n                     };\n-                    let msg = format!(\"unresolved import `{}`{}\",\n-                                      import_path_to_string(\n-                                          &import_directive.module_path,\n-                                          import_directive.subclass),\n-                                      help);\n-                    self.resolver.resolve_error(span, &msg[..]);\n+                    resolve_error(self.resolver,\n+                                    span,\n+                                    ResolutionError::UnresolvedImport(\n+                                                Some((&*import_path_to_string(\n+                                                        &import_directive.module_path,\n+                                                        import_directive.subclass),\n+                                                      Some(&*help))))\n+                                   );\n                 }\n                 ResolveResult::Indeterminate => break, // Bail out. We'll come around next time.\n                 ResolveResult::Success(()) => () // Good. Continue.\n@@ -394,9 +397,9 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                              -> ResolveResult<()> {\n         debug!(\"(resolving single import) resolving `{}` = `{}::{}` from \\\n                 `{}` id {}, last private {:?}\",\n-               token::get_name(target),\n+               target,\n                module_to_string(&*target_module),\n-               token::get_name(source),\n+               source,\n                module_to_string(module_),\n                directive.id,\n                lp);\n@@ -431,7 +434,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     value_result = BoundResult(target_module.clone(),\n                                                (*child_name_bindings).clone());\n                     if directive.is_public && !child_name_bindings.is_public(ValueNS) {\n-                        let msg = format!(\"`{}` is private\", token::get_name(source));\n+                        let msg = format!(\"`{}` is private\", source);\n                         span_err!(self.resolver.session, directive.span, E0364, \"{}\", &msg);\n                         pub_err = true;\n                     }\n@@ -441,7 +444,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     type_result = BoundResult(target_module.clone(),\n                                               (*child_name_bindings).clone());\n                     if !pub_err && directive.is_public && !child_name_bindings.is_public(TypeNS) {\n-                        let msg = format!(\"`{}` is private\", token::get_name(source));\n+                        let msg = format!(\"`{}` is private\", source);\n                         span_err!(self.resolver.session, directive.span, E0365, \"{}\", &msg);\n                     }\n                 }\n@@ -655,7 +658,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         if value_result.is_unbound() && type_result.is_unbound() {\n             let msg = format!(\"There is no `{}` in `{}`\",\n-                              token::get_name(source),\n+                              source,\n                               module_to_string(&target_module));\n             return ResolveResult::Failed(Some((directive.span, msg)));\n         }\n@@ -736,7 +739,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n         for (ident, target_import_resolution) in import_resolutions.iter() {\n             debug!(\"(resolving glob import) writing module resolution \\\n                     {} into `{}`\",\n-                   token::get_name(*ident),\n+                   *ident,\n                    module_to_string(module_));\n \n             if !target_import_resolution.is_public {\n@@ -842,7 +845,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n \n         debug!(\"(resolving glob import) writing resolution `{}` in `{}` \\\n                to `{}`\",\n-               &token::get_name(name),\n+               name,\n                module_to_string(&*containing_module),\n                module_to_string(module_));\n \n@@ -861,7 +864,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                         let msg = format!(\"a {} named `{}` has already been imported \\\n                                            in this module\",\n                                           namespace_name,\n-                                          &token::get_name(name));\n+                                          name);\n                         span_err!(self.resolver.session, import_directive.span, E0251, \"{}\", msg);\n                     } else {\n                         let target = Target::new(containing_module.clone(),\n@@ -894,7 +897,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                     namespace: Namespace) {\n         let target = import_resolution.target_for_namespace(namespace);\n         debug!(\"check_for_conflicting_import: {}; target exists: {}\",\n-               &token::get_name(name),\n+               name,\n                target.is_some());\n \n         match target {\n@@ -918,13 +921,13 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 span_err!(self.resolver.session, import_span, E0252,\n                           \"a {} named `{}` has already been imported \\\n                            in this module\", ns_word,\n-                                  &token::get_name(name));\n+                                  name);\n                 let use_id = import_resolution.id(namespace);\n                 let item = self.resolver.ast_map.expect_item(use_id);\n                 // item is syntax::ast::Item;\n                 span_note!(self.resolver.session, item.span,\n                             \"previous import of `{}` here\",\n-                            token::get_name(name));\n+                            name);\n             }\n             Some(_) | None => {}\n         }\n@@ -938,7 +941,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                                        namespace: Namespace) {\n         if !name_bindings.defined_in_namespace_with(namespace, DefModifiers::IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n-                              token::get_name(name));\n+                              name);\n             span_err!(self.resolver.session, import_span, E0253, \"{}\", &msg[..]);\n         }\n     }\n@@ -959,7 +962,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     let msg = format!(\"import `{0}` conflicts with imported \\\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n-                                      &token::get_name(name));\n+                                      name);\n                     span_err!(self.resolver.session, import_span, E0254, \"{}\", &msg[..]);\n                 }\n                 Some(_) | None => {}\n@@ -981,7 +984,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                 if let Some(ref value) = *name_bindings.value_def.borrow() {\n                     span_err!(self.resolver.session, import_span, E0255,\n                               \"import `{}` conflicts with value in this module\",\n-                              &token::get_name(name));\n+                              name);\n                     if let Some(span) = value.value_span {\n                         self.resolver.session.span_note(span, \"conflicting value here\");\n                     }\n@@ -1004,7 +1007,7 @@ impl<'a, 'b:'a, 'tcx:'b> ImportResolver<'a, 'b, 'tcx> {\n                     };\n                     span_err!(self.resolver.session, import_span, E0256,\n                               \"import `{}` conflicts with {}\",\n-                              &token::get_name(name), what);\n+                              name, what);\n                     if let Some(span) = ty.type_span {\n                         self.resolver.session.span_note(span, note);\n                     }"}, {"sha": "680999717eae5a2f038d4116d200e34be039332e", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -35,7 +35,6 @@ use session::Session;\n use middle::def;\n use middle::ty::{self, Ty};\n \n-use std::cell::Cell;\n use std::fs::File;\n use std::path::Path;\n \n@@ -76,14 +75,11 @@ impl <'l, 'tcx> DumpCsvVisitor<'l, 'tcx> {\n     pub fn new(tcx: &'l ty::ctxt<'tcx>,\n                analysis: &'l ty::CrateAnalysis,\n                output_file: Box<File>) -> DumpCsvVisitor<'l, 'tcx> {\n-        let span_utils = SpanUtils {\n-            sess: &tcx.sess,\n-            err_count: Cell::new(0)\n-        };\n+        let span_utils = SpanUtils::new(&tcx.sess);\n         DumpCsvVisitor {\n             sess: &tcx.sess,\n             tcx: tcx,\n-            save_ctxt: SaveContext::new(tcx, span_utils.clone()),\n+            save_ctxt: SaveContext::from_span_utils(tcx, span_utils.clone()),\n             analysis: analysis,\n             span: span_utils.clone(),\n             fmt: FmtStrs::new(box Recorder {"}, {"sha": "26da803de6557538a42e487d35f663f7f59e1120", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -163,9 +163,14 @@ pub struct MethodCallData {\n \n \n impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n-    pub fn new(tcx: &'l ty::ctxt<'tcx>,\n-               span_utils: SpanUtils<'l>)\n-               -> SaveContext<'l, 'tcx> {\n+    pub fn new(tcx: &'l ty::ctxt<'tcx>) -> SaveContext <'l, 'tcx> {\n+        let span_utils = SpanUtils::new(&tcx.sess);\n+        SaveContext::from_span_utils(tcx, span_utils)\n+    }\n+\n+    pub fn from_span_utils(tcx: &'l ty::ctxt<'tcx>,\n+                           span_utils: SpanUtils<'l>)\n+                           -> SaveContext<'l, 'tcx> {\n         SaveContext {\n             tcx: tcx,\n             span_utils: span_utils,\n@@ -527,7 +532,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     ref_id: def.def_id(),\n                 })\n             }\n-            def::DefStruct(def_id) | def::DefTy(def_id, _) => {\n+            def::DefStruct(def_id) |\n+            def::DefTy(def_id, _) |\n+            def::DefTrait(def_id) |\n+            def::DefTyParam(_, _, def_id, _) => {\n                 Data::TypeRefData(TypeRefData {\n                     span: sub_span.unwrap(),\n                     ref_id: def_id,\n@@ -540,13 +548,12 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     let ti = self.tcx.impl_or_trait_item(decl_id);\n                     match provenence {\n                         def::FromTrait(def_id) => {\n-                            Some(self.tcx.trait_items(def_id)\n-                                    .iter()\n-                                    .find(|mr| {\n-                                        mr.name() == ti.name()\n-                                    })\n-                                    .unwrap()\n-                                    .def_id())\n+                            self.tcx.trait_items(def_id)\n+                                .iter()\n+                                .find(|mr| {\n+                                    mr.name() == ti.name() && self.trait_method_has_body(mr)\n+                                })\n+                                .map(|mr| mr.def_id())\n                         }\n                         def::FromImpl(def_id) => {\n                             let impl_items = self.tcx.impl_items.borrow();\n@@ -586,6 +593,20 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         }\n     }\n \n+    fn trait_method_has_body(&self, mr: &ty::ImplOrTraitItem) -> bool {\n+        let def_id = mr.def_id();\n+        if def_id.krate != ast::LOCAL_CRATE {\n+            return false;\n+        }\n+\n+        let trait_item = self.tcx.map.expect_trait_item(def_id.node);\n+        if let ast::TraitItem_::MethodTraitItem(_, Some(_)) = trait_item.node {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n                               struct_id: DefId,\n@@ -753,6 +774,6 @@ fn escape(s: String) -> String {\n \n // If the expression is a macro expansion or other generated code, run screaming\n // and don't index.\n-fn generated_code(span: Span) -> bool {\n+pub fn generated_code(span: Span) -> bool {\n     span.expn_id != NO_EXPANSION || span  == DUMMY_SP\n }"}, {"sha": "ee7b1c4ff6e29a5d12a71c28619a8ffa231908a7", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -28,6 +28,13 @@ pub struct SpanUtils<'a> {\n }\n \n impl<'a> SpanUtils<'a> {\n+    pub fn new(sess: &'a Session) -> SpanUtils<'a> {\n+        SpanUtils {\n+            sess: sess,\n+            err_count: Cell::new(0)\n+        }\n+    }\n+\n     // Standard string for extents/location.\n     pub fn extent_str(&self, span: Span) -> String {\n         let lo_loc = self.sess.codemap().lookup_char_pos(span.lo);"}, {"sha": "9042cedccc8571a836648e11159c3b7852c65b75", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -3426,6 +3426,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let def = lookup_full_def(tcx, path.span, id);\n         let struct_id = match def {\n             def::DefVariant(enum_id, variant_id, true) => {\n+                if let &Some(ref base_expr) = base_expr {\n+                    span_err!(tcx.sess, base_expr.span, E0436,\n+                              \"functional record update syntax requires a struct\");\n+                    fcx.write_error(base_expr.id);\n+                }\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n                                           variant_id, &fields[..]);\n                 enum_id"}, {"sha": "2069e3098e6381981da0cdf40b210ecaa4900a44", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -2209,6 +2209,7 @@ register_diagnostics! {\n     E0392, // parameter `{}` is never used\n     E0393, // the type parameter `{}` must be explicitly specified in an object\n            // type because its default value `{}` references the type `Self`\"\n-    E0399  // trait items need to be implemented because the associated\n+    E0399, // trait items need to be implemented because the associated\n            // type `{}` was overridden\n+    E0436  // functional record update requires a struct\n }"}, {"sha": "1eb1556a25d26b0efcb9bf7529458982eb27ffd8", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -701,6 +701,9 @@\n             // Push and pop states are used to add search results to the browser\n             // history.\n             if (browserSupportsHistoryApi()) {\n+                // Store the previous <title> so we can revert back to it later.\n+                var previousTitle = $(document).prop(\"title\");\n+\n                 $(window).on('popstate', function(e) {\n                     var params = getQueryStringParams();\n                     // When browsing back from search results the main page\n@@ -709,6 +712,9 @@\n                         $('#main.content').removeClass('hidden');\n                         $('#search.content').addClass('hidden');\n                     }\n+                    // Revert to the previous title manually since the History\n+                    // API ignores the title parameter.\n+                    $(document).prop(\"title\", previousTitle);\n                     // When browsing forward to search results the previous\n                     // search will be repeated, so the currentResults are\n                     // cleared to ensure the search is successful.\n@@ -951,3 +957,8 @@\n     }());\n \n }());\n+\n+// Sets the focus on the search bar at the top of the page\n+function focusSearchBar() {\n+    document.getElementsByName('search')[0].focus();\n+}"}, {"sha": "2c78b2894311d641d76cea2184585076b3291670", "filename": "src/libstd/fs.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -25,6 +25,7 @@ use io::{self, SeekFrom, Seek, Read, Write};\n use path::{Path, PathBuf};\n use sys::fs as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n+use sys_common::io::read_to_end_uninitialized;\n use vec::Vec;\n \n /// A reference to an open file on the filesystem.\n@@ -328,6 +329,9 @@ impl Read for File {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for File {"}, {"sha": "244747310310170ea1c1b749faf4fa9f7dc360eb", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 612, "deletions": 58, "changes": 670, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -127,14 +127,50 @@ fn read_to_end<R: Read + ?Sized>(r: &mut R, buf: &mut Vec<u8>) -> Result<usize>\n     ret\n }\n \n-/// A trait for objects which are byte-oriented sources.\n+/// The `Read` trait allows for reading bytes from a source.\n ///\n-/// Readers are defined by one method, `read`. Each call to `read` will attempt\n-/// to pull bytes from this source into a provided buffer.\n+/// Implementors of the `Read` trait are sometimes called 'readers'.\n ///\n-/// Readers are intended to be composable with one another. Many objects\n-/// throughout the I/O and related libraries take and provide types which\n-/// implement the `Read` trait.\n+/// Readers are defined by one required method, `read()`. Each call to `read`\n+/// will attempt to pull bytes from this source into a provided buffer. A\n+/// number of other methods are implemented in terms of `read()`, giving\n+/// implementors a number of ways to read bytes while only needing to implement\n+/// a single method.\n+///\n+/// Readers are intended to be composable with one another. Many implementors\n+/// throughout `std::io` take and provide types which implement the `Read`\n+/// trait.\n+///\n+/// # Examples\n+///\n+/// [`File`][file]s implement `Read`:\n+///\n+/// [file]: ../std/fs/struct.File.html\n+///\n+/// ```\n+/// use std::io;\n+/// use std::io::prelude::*;\n+/// use std::fs::File;\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// let mut f = try!(File::open(\"foo.txt\"));\n+/// let mut buffer = [0; 10];\n+///\n+/// // read up to 10 bytes\n+/// try!(f.read(&mut buffer));\n+///\n+/// let mut buffer = vec![0; 10];\n+/// // read the whole file\n+/// try!(f.read_to_end(&mut buffer));\n+///\n+/// // read into a String, so that you don't need to do the conversion.\n+/// let mut buffer = String::new();\n+/// try!(f.read_to_string(&mut buffer));\n+///\n+/// // and more! See the other methods for more details.\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Read {\n     /// Pull some bytes from this source into the specified buffer, returning\n@@ -164,6 +200,27 @@ pub trait Read {\n     /// If this function encounters any form of I/O or other error, an error\n     /// variant will be returned. If an error is returned then it must be\n     /// guaranteed that no bytes were read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = [0; 10];\n+    ///\n+    /// // read 10 bytes\n+    /// try!(f.read(&mut buffer[..]));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read(&mut self, buf: &mut [u8]) -> Result<usize>;\n \n@@ -185,6 +242,27 @@ pub trait Read {\n     /// If any other read error is encountered then this function immediately\n     /// returns. Any bytes which have already been read will be appended to\n     /// `buf`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = Vec::new();\n+    ///\n+    /// // read the whole file\n+    /// try!(f.read_to_end(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_end(&mut self, buf: &mut Vec<u8>) -> Result<usize> {\n         read_to_end(self, buf)\n@@ -200,7 +278,29 @@ pub trait Read {\n     /// If the data in this stream is *not* valid UTF-8 then an error is\n     /// returned and `buf` is unchanged.\n     ///\n-    /// See `read_to_end` for other error semantics.\n+    /// See [`read_to_end()`][readtoend] for other error semantics.\n+    ///\n+    /// [readtoend]: #method.read_to_end\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = String::new();\n+    ///\n+    /// try!(f.read_to_string(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_to_string(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we do *not* call `.read_to_end()` here. We are passing\n@@ -219,6 +319,36 @@ pub trait Read {\n     ///\n     /// The returned adaptor also implements `Read` and will simply borrow this\n     /// current reader.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::Read;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = Vec::new();\n+    /// let mut other_buffer = Vec::new();\n+    ///\n+    /// {\n+    ///     let reference = f.by_ref();\n+    ///\n+    ///     // read at most 5 bytes\n+    ///     try!(reference.take(5).read_to_end(&mut buffer));\n+    ///\n+    /// } // drop our &mut reference so we can use f again\n+    ///\n+    /// // original file still usable, read the rest\n+    /// try!(f.read_to_end(&mut other_buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n \n@@ -228,6 +358,27 @@ pub trait Read {\n     /// R::Err>`.  The yielded item is `Ok` if a byte was successfully read and\n     /// `Err` otherwise for I/O errors. EOF is mapped to returning `None` from\n     /// this iterator.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    ///\n+    /// for byte in f.bytes() {\n+    ///     println!(\"{}\", byte.unwrap());\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn bytes(self) -> Bytes<Self> where Self: Sized {\n         Bytes { inner: self }\n@@ -243,6 +394,28 @@ pub trait Read {\n     ///\n     /// Currently this adaptor will discard intermediate data read, and should\n     /// be avoided if this is not desired.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// #![feature(io)]\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    ///\n+    /// for c in f.chars() {\n+    ///     println!(\"{}\", c.unwrap());\n+    /// }\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n@@ -255,6 +428,31 @@ pub trait Read {\n     /// The returned `Read` instance will first read all bytes from this object\n     /// until EOF is encountered. Afterwards the output is equivalent to the\n     /// output of `next`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f1 = try!(File::open(\"foo.txt\"));\n+    /// let mut f2 = try!(File::open(\"bar.txt\"));\n+    ///\n+    /// let mut handle = f1.chain(f2);\n+    /// let mut buffer = String::new();\n+    ///\n+    /// // read the value into a String. We could use any Read method here,\n+    /// // this is just one example.\n+    /// try!(handle.read_to_string(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chain<R: Read>(self, next: R) -> Chain<Self, R> where Self: Sized {\n         Chain { first: self, second: next, done_first: false }\n@@ -266,6 +464,29 @@ pub trait Read {\n     /// `limit` bytes, after which it will always return EOF (`Ok(0)`). Any\n     /// read errors will not count towards the number of bytes read and future\n     /// calls to `read` may succeed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer = [0; 10];\n+    ///\n+    /// // read at most five bytes\n+    /// let mut handle = f.take(5);\n+    ///\n+    /// try!(handle.read(&mut buffer));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, limit: u64) -> Take<Self> where Self: Sized {\n         Take { inner: self, limit: limit }\n@@ -277,6 +498,31 @@ pub trait Read {\n     /// Whenever the returned `Read` instance is read it will write the read\n     /// data to `out`. The current semantics of this implementation imply that\n     /// a `write` error will not report how much data was initially read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// [`File`][file]s implement `Read`:\n+    ///\n+    /// [file]: ../std/fs/struct.File.html\n+    ///\n+    /// ```\n+    /// #![feature(io)]\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> io::Result<()> {\n+    /// let mut f = try!(File::open(\"foo.txt\"));\n+    /// let mut buffer1 = Vec::with_capacity(10);\n+    /// let mut buffer2 = Vec::with_capacity(10);\n+    ///\n+    /// // write the output to buffer1 as we read\n+    /// let mut handle = f.tee(&mut buffer1);\n+    ///\n+    /// try!(handle.read(&mut buffer2));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n@@ -287,15 +533,34 @@ pub trait Read {\n \n /// A trait for objects which are byte-oriented sinks.\n ///\n-/// The `write` method will attempt to write some data into the object,\n-/// returning how many bytes were successfully written.\n+/// Implementors of the `Write` trait are sometimes called 'writers'.\n+///\n+/// Writers are defined by two required methods, `write()` and `flush()`:\n ///\n-/// The `flush` method is useful for adaptors and explicit buffers themselves\n-/// for ensuring that all buffered data has been pushed out to the \"true sink\".\n+/// * The `write()` method will attempt to write some data into the object,\n+///   returning how many bytes were successfully written.\n ///\n-/// Writers are intended to be composable with one another. Many objects\n-/// throughout the I/O and related libraries take and provide types which\n-/// implement the `Write` trait.\n+/// * The `flush()` method is useful for adaptors and explicit buffers\n+///   themselves for ensuring that all buffered data has been pushed out to the\n+///   'true sink'.\n+///\n+/// Writers are intended to be composable with one another. Many implementors\n+/// throughout `std::io` take and provide types which implement the `Write`\n+/// trait.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::io::prelude::*;\n+/// use std::fs::File;\n+///\n+/// # fn foo() -> std::io::Result<()> {\n+/// let mut buffer = try!(File::create(\"foo.txt\"));\n+///\n+/// try!(buffer.write(b\"some bytes\"));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Write {\n     /// Write a buffer into this object, returning how many bytes were written.\n@@ -322,6 +587,20 @@ pub trait Write {\n     ///\n     /// It is **not** considered an error if the entire buffer could not be\n     /// written to this writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = try!(File::create(\"foo.txt\"));\n+    ///\n+    /// try!(buffer.write(b\"some bytes\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write(&mut self, buf: &[u8]) -> Result<usize>;\n \n@@ -332,6 +611,22 @@ pub trait Write {\n     ///\n     /// It is considered an error if not all bytes could be written due to\n     /// I/O errors or EOF being reached.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::prelude::*;\n+    /// use std::io::BufWriter;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = BufWriter::new(try!(File::create(\"foo.txt\")));\n+    ///\n+    /// try!(buffer.write(b\"some bytes\"));\n+    /// try!(buffer.flush());\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn flush(&mut self) -> Result<()>;\n \n@@ -345,6 +640,20 @@ pub trait Write {\n     /// # Errors\n     ///\n     /// This function will return the first error that `write` returns.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = try!(File::create(\"foo.txt\"));\n+    ///\n+    /// try!(buffer.write_all(b\"some bytes\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_all(&mut self, mut buf: &[u8]) -> Result<()> {\n         while !buf.is_empty() {\n@@ -362,17 +671,41 @@ pub trait Write {\n     /// Writes a formatted string into this writer, returning any error\n     /// encountered.\n     ///\n-    /// This method is primarily used to interface with the `format_args!`\n-    /// macro, but it is rare that this should explicitly be called. The\n-    /// `write!` macro should be favored to invoke this method instead.\n+    /// This method is primarily used to interface with the\n+    /// [`format_args!`][formatargs] macro, but it is rare that this should\n+    /// explicitly be called. The [`write!`][write] macro should be favored to\n+    /// invoke this method instead.\n+    ///\n+    /// [formatargs]: ../std/macro.format_args!.html\n+    /// [write]: ../std/macro.write!.html\n+    ///\n+    /// This function internally uses the [`write_all`][writeall] method on\n+    /// this trait and hence will continuously write data so long as no errors\n+    /// are received. This also means that partial writes are not indicated in\n+    /// this signature.\n     ///\n-    /// This function internally uses the `write_all` method on this trait and\n-    /// hence will continuously write data so long as no errors are received.\n-    /// This also means that partial writes are not indicated in this signature.\n+    /// [writeall]: #method.write_all\n     ///\n     /// # Errors\n     ///\n     /// This function will return any I/O error reported while formatting.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = try!(File::create(\"foo.txt\"));\n+    ///\n+    /// // this call\n+    /// try!(write!(buffer, \"{:.*}\", 2, 1.234567));\n+    /// // turns into this:\n+    /// try!(buffer.write_fmt(format_args!(\"{:.*}\", 2, 1.234567)));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_fmt(&mut self, fmt: fmt::Arguments) -> Result<()> {\n         // Create a shim which translates a Write to a fmt::Write and saves\n@@ -405,6 +738,23 @@ pub trait Write {\n     ///\n     /// The returned adaptor also implements `Write` and will simply borrow this\n     /// current writer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::io::Write;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer = try!(File::create(\"foo.txt\"));\n+    ///\n+    /// let reference = buffer.by_ref();\n+    ///\n+    /// // we can use reference just like our original buffer\n+    /// try!(reference.write_all(b\"some bytes\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn by_ref(&mut self) -> &mut Self where Self: Sized { self }\n \n@@ -416,6 +766,25 @@ pub trait Write {\n     /// implementation do not precisely track where errors happen. For example\n     /// an error on the second call to `write` will not report that the first\n     /// call to `write` succeeded.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(io)]\n+    /// use std::io::prelude::*;\n+    /// use std::fs::File;\n+    ///\n+    /// # fn foo() -> std::io::Result<()> {\n+    /// let mut buffer1 = try!(File::create(\"foo.txt\"));\n+    /// let mut buffer2 = Vec::new();\n+    ///\n+    /// // write the output to buffer1 as we read\n+    /// let mut handle = buffer1.broadcast(&mut buffer2);\n+    ///\n+    /// try!(handle.write(b\"some bytes\"));\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[unstable(feature = \"io\", reason = \"the semantics of a partial read/write \\\n                                          of where errors happen is currently \\\n                                          unclear and may change\")]\n@@ -426,17 +795,38 @@ pub trait Write {\n     }\n }\n \n-/// An object implementing `Seek` internally has some form of cursor which can\n-/// be moved within a stream of bytes.\n+/// The `Seek` trait provides a cursor which can be moved within a stream of\n+/// bytes.\n ///\n /// The stream typically has a fixed size, allowing seeking relative to either\n /// end or the current offset.\n+///\n+/// # Examples\n+///\n+/// [`File`][file]s implement `Seek`:\n+///\n+/// [file]: ../std/fs/struct.File.html\n+///\n+/// ```\n+/// use std::io;\n+/// use std::io::prelude::*;\n+/// use std::fs::File;\n+/// use std::io::SeekFrom;\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// let mut f = try!(File::open(\"foo.txt\"));\n+///\n+/// // move the cursor 42 bytes from the start of the file\n+/// try!(f.seek(SeekFrom::Start(42)));\n+/// # Ok(())\n+/// # }\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Seek {\n-    /// Seek to an offset, in bytes, in a stream\n+    /// Seek to an offset, in bytes, in a stream.\n     ///\n-    /// A seek beyond the end of a stream is allowed, but seeking before offset\n-    /// 0 is an error.\n+    /// A seek beyond the end of a stream is allowed, but implementation\n+    /// defined.\n     ///\n     /// The behavior when seeking past the end of the stream is implementation\n     /// defined.\n@@ -446,7 +836,7 @@ pub trait Seek {\n     ///\n     /// # Errors\n     ///\n-    /// Seeking to a negative offset is considered an error\n+    /// Seeking to a negative offset is considered an error.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn seek(&mut self, pos: SeekFrom) -> Result<u64>;\n }\n@@ -505,59 +895,135 @@ fn read_until<R: BufRead + ?Sized>(r: &mut R, delim: u8, buf: &mut Vec<u8>)\n     }\n }\n \n-/// A `BufRead` is a type of reader which has some form of internal buffering to\n-/// allow certain kinds of reading operations to be more optimized than others.\n+/// A `BufRead` is a type of `Read`er which has an internal buffer, allowing it\n+/// to perform extra ways of reading.\n+///\n+/// For example, reading line-by-line is inefficient without using a buffer, so\n+/// if you want to read by line, you'll need `BufRead`, which includes a\n+/// [`read_line()`][readline] method as well as a [`lines()`][lines] iterator.\n+///\n+/// [readline]: #method.read_line\n+/// [lines]: #method.lines\n+///\n+/// # Examples\n+///\n+/// A locked standard input implements `BufRead`:\n+///\n+/// ```\n+/// use std::io;\n+/// use std::io::prelude::*;\n+///\n+/// let stdin = io::stdin();\n+/// for line in stdin.lock().lines() {\n+///     println!(\"{}\", line.unwrap());\n+/// }\n+/// ```\n+///\n+/// If you have something that implements `Read`, you can use the [`BufReader`\n+/// type][bufreader] to turn it into a `BufRead`.\n+///\n+/// For example, [`File`][file] implements `Read`, but not `BufRead`.\n+/// `BufReader` to the rescue!\n+///\n+/// [bufreader]: struct.BufReader.html\n+/// [file]: ../fs/struct.File.html\n+///\n+/// ```\n+/// use std::io::{self, BufReader};\n+/// use std::io::prelude::*;\n+/// use std::fs::File;\n+///\n+/// # fn foo() -> io::Result<()> {\n+/// let f = try!(File::open(\"foo.txt\"));\n+/// let f = BufReader::new(f);\n ///\n-/// This type extends the `Read` trait with a few methods that are not\n-/// possible to reasonably implement with purely a read interface.\n+/// for line in f.lines() {\n+///     println!(\"{}\", line.unwrap());\n+/// }\n+///\n+/// # Ok(())\n+/// # }\n+/// ```\n ///\n-/// You can use the [`BufReader` wrapper type](struct.BufReader.html) to turn any\n-/// reader into a buffered reader.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait BufRead: Read {\n     /// Fills the internal buffer of this object, returning the buffer contents.\n     ///\n-    /// None of the contents will be \"read\" in the sense that later calling\n-    /// `read` may return the same contents.\n+    /// This function is a lower-level call. It needs to be paired with the\n+    /// [`consume`][consume] method to function properly. When calling this\n+    /// method, none of the contents will be \"read\" in the sense that later\n+    /// calling `read` may return the same contents. As such, `consume` must be\n+    /// called with the number of bytes that are consumed from this buffer to\n+    /// ensure that the bytes are never returned twice.\n     ///\n-    /// The `consume` function must be called with the number of bytes that are\n-    /// consumed from this buffer returned to ensure that the bytes are never\n-    /// returned twice.\n+    /// [consume]: #tymethod.consume\n     ///\n     /// An empty buffer returned indicates that the stream has reached EOF.\n     ///\n     /// # Errors\n     ///\n     /// This function will return an I/O error if the underlying reader was\n     /// read, but returned an error.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`:\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    /// let mut stdin = stdin.lock();\n+    ///\n+    /// // we can't have two `&mut` references to `stdin`, so use a block\n+    /// // to end the borrow early.\n+    /// let length = {\n+    ///     let buffer = stdin.fill_buf().unwrap();\n+    ///\n+    ///     // work with buffer\n+    ///     println!(\"{:?}\", buffer);\n+    ///\n+    ///     buffer.len()\n+    /// };\n+    ///\n+    /// // ensure the bytes we worked with aren't returned again later\n+    /// stdin.consume(length);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn fill_buf(&mut self) -> Result<&[u8]>;\n \n     /// Tells this buffer that `amt` bytes have been consumed from the buffer,\n     /// so they should no longer be returned in calls to `read`.\n     ///\n-    /// This function does not perform any I/O, it simply informs this object\n-    /// that some amount of its buffer, returned from `fill_buf`, has been\n-    /// consumed and should no longer be returned.\n+    /// This function is a lower-level call. It needs to be paired with the\n+    /// [`fill_buf`][fillbuf] method to function properly. This function does\n+    /// not perform any I/O, it simply informs this object that some amount of\n+    /// its buffer, returned from `fill_buf`, has been consumed and should no\n+    /// longer be returned. As such, this function may do odd things if\n+    /// `fill_buf` isn't called before calling it.\n+    ///\n+    /// [fillbuf]: #tymethod.fill_buff\n+    ///\n+    /// The `amt` must be `<=` the number of bytes in the buffer returned by\n+    /// `fill_buf`.\n     ///\n-    /// This function is used to tell the buffer how many bytes you've consumed\n-    /// from the return value of `fill_buf`, and so may do odd things if\n-    /// `fill_buf` isn't called before calling this.\n+    /// # Examples\n     ///\n-    /// The `amt` must be `<=` the number of bytes in the buffer returned by `fill_buf`.\n+    /// Since `consume()` is meant to be used with [`fill_buf()`][fillbuf],\n+    /// that method's example includes an example of `consume()`.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn consume(&mut self, amt: usize);\n \n-    /// Read all bytes until the delimiter `byte` is reached.\n+    /// Read all bytes into `buf` until the delimiter `byte` is reached.\n     ///\n-    /// This function will continue to read (and buffer) bytes from the\n-    /// underlying stream until the delimiter or EOF is found. Once found, all\n-    /// bytes up to, and including, the delimiter (if found) will be appended to\n-    /// `buf`.\n+    /// This function will read bytes from the underlying stream until the\n+    /// delimiter or EOF is found. Once found, all bytes up to, and including,\n+    /// the delimiter (if found) will be appended to `buf`.\n     ///\n-    /// If this buffered reader is currently at EOF, then this function will not\n-    /// place any more bytes into `buf` and will return `Ok(n)` where `n` is the\n-    /// number of bytes which were read.\n+    /// If this reader is currently at EOF then this function will not modify\n+    /// `buf` and will return `Ok(n)` where `n` is the number of bytes which\n+    /// were read.\n     ///\n     /// # Errors\n     ///\n@@ -566,18 +1032,39 @@ pub trait BufRead: Read {\n     ///\n     /// If an I/O error is encountered then all bytes read so far will be\n     /// present in `buf` and its length will have been adjusted appropriately.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`. In this example, we'll\n+    /// read from standard input until we see an `a` byte.\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// fn foo() -> io::Result<()> {\n+    /// let stdin = io::stdin();\n+    /// let mut stdin = stdin.lock();\n+    /// let mut buffer = Vec::new();\n+    ///\n+    /// try!(stdin.read_until(b'a', &mut buffer));\n+    ///\n+    /// println!(\"{:?}\", buffer);\n+    /// # Ok(())\n+    /// # }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_until(&mut self, byte: u8, buf: &mut Vec<u8>) -> Result<usize> {\n         read_until(self, byte, buf)\n     }\n \n-    /// Read all bytes until a newline (the 0xA byte) is reached, and\n-    /// append them to the provided buffer.\n+    /// Read all bytes until a newline (the 0xA byte) is reached, and append\n+    /// them to the provided buffer.\n     ///\n-    /// This function will continue to read (and buffer) bytes from the\n-    /// underlying stream until the newline delimiter (the 0xA byte) or EOF is\n-    /// found. Once found, all bytes up to, and including, the delimiter (if\n-    /// found) will be appended to `buf`.\n+    /// This function will read bytes from the underlying stream until the\n+    /// newline delimiter (the 0xA byte) or EOF is found. Once found, all bytes\n+    /// up to, and including, the delimiter (if found) will be appended to\n+    /// `buf`.\n     ///\n     /// If this reader is currently at EOF then this function will not modify\n     /// `buf` and will return `Ok(n)` where `n` is the number of bytes which\n@@ -589,6 +1076,31 @@ pub trait BufRead: Read {\n     /// return an error if the read bytes are not valid UTF-8. If an I/O error\n     /// is encountered then `buf` may contain some bytes already read in the\n     /// event that all data read so far was valid UTF-8.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`. In this example, we'll\n+    /// read all of the lines from standard input. If we were to do this in\n+    /// an actual project, the [`lines()`][lines] method would be easier, of\n+    /// course.\n+    ///\n+    /// [lines]: #method.lines\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    /// let mut stdin = stdin.lock();\n+    /// let mut buffer = String::new();\n+    ///\n+    /// while stdin.read_line(&mut buffer).unwrap() > 0 {\n+    ///     // work with buffer\n+    ///     println!(\"{:?}\", buffer);\n+    ///\n+    ///     buffer.clear();\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn read_line(&mut self, buf: &mut String) -> Result<usize> {\n         // Note that we are not calling the `.read_until` method here, but\n@@ -606,6 +1118,22 @@ pub trait BufRead: Read {\n     ///\n     /// This function will yield errors whenever `read_until` would have also\n     /// yielded an error.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`. In this example, we'll\n+    /// read some input from standard input, splitting on commas.\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    ///\n+    /// for content in stdin.lock().split(b',') {\n+    ///     println!(\"{:?}\", content.unwrap());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split(self, byte: u8) -> Split<Self> where Self: Sized {\n         Split { buf: self, delim: byte }\n@@ -616,6 +1144,21 @@ pub trait BufRead: Read {\n     /// The iterator returned from this function will yield instances of\n     /// `io::Result<String>`. Each string returned will *not* have a newline\n     /// byte (the 0xA byte) at the end.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A locked standard input implements `BufRead`:\n+    ///\n+    /// ```\n+    /// use std::io;\n+    /// use std::io::prelude::*;\n+    ///\n+    /// let stdin = io::stdin();\n+    ///\n+    /// for line in stdin.lock().lines() {\n+    ///     println!(\"{}\", line.unwrap());\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(self) -> Lines<Self> where Self: Sized {\n         Lines { buf: self }\n@@ -906,6 +1449,8 @@ mod tests {\n     use io::prelude::*;\n     use io;\n     use super::Cursor;\n+    use test;\n+    use super::repeat;\n \n     #[test]\n     fn read_until() {\n@@ -1024,4 +1569,13 @@ mod tests {\n         let mut buf = [0; 1];\n         assert_eq!(0, R.take(0).read(&mut buf).unwrap());\n     }\n+\n+    #[bench]\n+    fn bench_read_to_end(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            let mut lr = repeat(1).take(10000000);\n+            let mut vec = Vec::with_capacity(1024);\n+            super::read_to_end(&mut lr, &mut vec);\n+        });\n+    }\n }"}, {"sha": "d8b7c8a282ca297760d90d2b18ebf655efba77fe", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -18,6 +18,7 @@ use io::lazy::Lazy;\n use io::{self, BufReader, LineWriter};\n use sync::{Arc, Mutex, MutexGuard};\n use sys::stdio;\n+use sys_common::io::{read_to_end_uninitialized};\n use sys_common::remutex::{ReentrantMutex, ReentrantMutexGuard};\n use libc;\n \n@@ -277,6 +278,9 @@ impl<'a> Read for StdinLock<'a> {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n         self.inner.read(buf)\n     }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "fa90670acfbefd399489327c85f51b5d981fc763", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 128, "deletions": 28, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -10,29 +10,116 @@\n \n //! # The Rust Standard Library\n //!\n-//! The Rust Standard Library provides the essential runtime\n-//! functionality for building portable Rust software.\n+//! The Rust Standard Library is the foundation of portable Rust\n+//! software, a set of minimal and battle-tested shared abstractions\n+//! for the [broader Rust ecosystem](https://crates.io). It offers\n+//! core types (e.g. [`Vec`](vec/index.html)\n+//! and [`Option`](option/index.html)), library-defined [operations on\n+//! language primitives](#primitive) (e.g. [`u32`](u32/index.html) and\n+//! [`str`](str/index.html)), [standard macros](#macros),\n+//! [I/O](io/index.html) and [multithreading](thread/index.html), among\n+//! [many other lovely\n+//! things](#what-is-in-the-standard-library-documentation?).\n //!\n-//! The Rust Standard Library is available to all Rust crates by\n-//! default, just as if contained an `extern crate std` import at the\n-//! crate root. Therefore the standard library can be accessed in\n-//! `use` statements through the path `std`, as in `use std::thread`,\n-//! or in expressions through the absolute path `::std`, as in\n-//! `::std::thread::sleep_ms(100)`.\n+//! `std` is available to all Rust crates by default, just as if each\n+//! one contained an `extern crate std` import at the [crate\n+//! root][book-crate-root]. Therefore the standard library can be\n+//! accessed in [`use`][book-use] statements through the path `std`,\n+//! as in [`use std::env`](env/index.html), or in expressions\n+//! through the absolute path `::std`, as in\n+//! [`::std::env::args()`](env/fn.args.html).\n //!\n-//! Furthermore, the standard library defines [The Rust\n-//! Prelude](prelude/index.html), a small collection of items, mostly\n-//! traits, that are imported into and available in every module.\n+//! [book-crate-root]: ../book/crates-and-modules.html#basic-terminology:-crates-and-modules\n+//! [book-use]: ../book/crates-and-modules.html#importing-modules-with-use\n //!\n-//! ## What is in the standard library\n+//! # How to read this documentation\n //!\n-//! The standard library is a set of minimal, battle-tested\n-//! core types and shared abstractions for the [broader Rust\n-//! ecosystem](https://crates.io) to build on.\n+//! If you already know the name of what you are looking for the\n+//! fastest way to find it is to use the <a href=\"#\"\n+//! onclick=\"focusSearchBar();\">search bar</a> at the top of the page.\n //!\n-//! The [primitive types](#primitives), though not defined in the\n-//! standard library, are documented here, as are the predefined\n-//! [macros](#macros).\n+//! Otherwise, you may want to jump to one of these useful sections:\n+//!\n+//! * [`std::*` modules](#modules)\n+//! * [Primitive types](#primitives)\n+//! * [Standard macros](#macros)\n+//! * [The Rust Prelude](prelude/index.html)\n+//!\n+//! If this is your first time, the documentation for the standard\n+//! library is written to be casually perused. Clicking on interesting\n+//! things should generally lead you to interesting places. Still,\n+//! there are important bits you don't want to miss, so read on for a\n+//! tour of the standard library and its documentation!\n+//!\n+//! Once you are familiar with the contents of the standard library\n+//! you may begin to find the verbosity of the prose distracting. At\n+//! this stage in your development you may want to press the **[-]**\n+//! button near the top of the page to collapse it into a more\n+//! skimmable view.\n+//!\n+//! While you are looking at that **[-]** button also notice the\n+//! **[src]** button. Rust's API documentation comes with the source\n+//! code and you are encouraged to read it. The standard library\n+//! source is generally high quality and a peek behind the curtains is\n+//! often enlightening.\n+//!\n+//! # What is in the standard library documentation?\n+//!\n+//! Lots of stuff. Well, broadly four things actually.\n+//!\n+//! First of all, The Rust Standard Library is divided into a number\n+//! of focused modules, [all listed further down this page](#modules).\n+//! These modules are the bedrock upon which all of Rust is forged,\n+//! and they have mighty names like [`std::slice`](slice/index.html)\n+//! and [`std::cmp`](cmp/index.html). Modules' documentation typically\n+//! includes an overview of the module along with examples, and are\n+//! a smart place to start familiarizing yourself with the library.\n+//!\n+//! Second, implicit methods on [primitive\n+//! types](../book/primitive-types.html) are documented here. This can\n+//! be a source of confusion for two reasons:\n+//!\n+//! 1. While primitives are implemented by the compiler, the standard\n+//!    library implements methods directly on the primitive types (and\n+//!    it is the only library that does so), which are [documented in\n+//!    the section on primitives](#primitives).\n+//! 2. The standard library exports many modules *with the same name\n+//!    as primitive types*. These define additional items related\n+//!    to the primitive type, but not the all-important methods.\n+//!\n+//! So for example there is a [page for the primitive type\n+//! `i32`](primitive.i32.html) that lists all the methods that can be\n+//! called on 32-bit integers (mega useful), and there is a [page for\n+//! the module `std::i32`](i32/index.html) that documents the constant\n+//! values `MIN` and `MAX` (rarely useful).\n+//!\n+//! Note the documentation for the primitives\n+//! [`str`](primitive.str.html) and [`[T]`](primitive.slice.html)\n+//! (also called 'slice'). Many method calls on\n+//! [`String`](string/struct.String.html) and\n+//! [`Vec`](vec/struct.Vec.html) are actually calls to methods on\n+//! `str` and `[T]` respectively, via [deref\n+//! coercions](../book/deref-coercions.html). *Accepting that\n+//! primitive types are documented on their own pages will bring you a\n+//! deep inner wisdom. Embrace it now before proceeding.*\n+//!\n+//! Third, the standard library defines [The Rust\n+//! Prelude](prelude/index.html), a small collection of items - mostly\n+//! traits - that are imported into every module of every crate. The\n+//! traits in the prelude are pervasive, making the prelude\n+//! documentation a good entry point to learning about the library.\n+//!\n+//! And finally, the standard library exports a number of standard\n+//! macros, and [lists them on this page](#macros) (technically, not\n+//! all of the standard macros are defined by the standard library -\n+//! some are defined by the compiler - but they are documented here\n+//! the same). Like the prelude, the standard macros are imported by\n+//! default into all crates.\n+//!\n+//! # A Tour of The Rust Standard Library\n+//!\n+//! The rest of this crate documentation is dedicated to pointing\n+//! out notable features of The Rust Standard Library.\n //!\n //! ## Containers and collections\n //!\n@@ -43,17 +130,29 @@\n //! [`Iterator`](iter/trait.Iterator.html), which works with the `for`\n //! loop to access collections.\n //!\n-//! The common container type, `Vec`, a growable vector backed by an array,\n-//! lives in the [`vec`](vec/index.html) module. Contiguous, unsized regions\n-//! of memory, `[T]`, commonly called \"slices\", and their borrowed versions,\n-//! `&[T]`, commonly called \"borrowed slices\", are built-in types for which the\n-//! [`slice`](slice/index.html) module defines many methods.\n+//! The standard library exposes 3 common ways to deal with contiguous\n+//! regions of memory:\n //!\n-//! `&str`, a UTF-8 string, is a built-in type, and the standard library\n-//! defines methods for it on a variety of traits in the\n-//! [`str`](str/index.html) module. Rust strings are immutable;\n-//! use the `String` type defined in [`string`](string/index.html)\n-//! for a mutable string builder.\n+//! * [`Vec<T>`](vec/index.html) - A heap-allocated *vector* that is\n+//! resizable at runtime.\n+//! * [`[T; n]`](primitive.array.html) - An inline *array* with a\n+//! fixed size at compile time.\n+//! * [`[T]`](primitive.slice.html) - A dynamically sized *slice* into\n+//! any other kind of contiguous storage, whether heap-allocated or\n+//! not.\n+//!\n+//! Slices can only be handled through some kind of *pointer*, and as\n+//! such come in many flavours such as:\n+//!\n+//! * `&[T]` - *shared slice*\n+//! * `&mut [T]` - *mutable slice*\n+//! * [`Box<[T]>`](boxed/index.html) - *owned slice*\n+//!\n+//! `str`, a UTF-8 string slice, is a primitive type, and the standard\n+//! library defines [many methods for it](primitive.str.html). Rust\n+//! `str`s are typically accessed as immutable references: `&str`. Use\n+//! the owned `String` type defined in [`string`](string/index.html)\n+//! for building and mutating strings.\n //!\n //! For converting to strings use the [`format!`](fmt/index.html)\n //! macro, and for converting from strings use the\n@@ -88,6 +187,7 @@\n //! [`atomic`](sync/atomic/index.html) and\n //! [`mpsc`](sync/mpsc/index.html), which contains the channel types\n //! for message passing.\n+//!\n \n // Do not remove on snapshot creation. Needed for bootstrap. (Issue #22364)\n #![cfg_attr(stage0, feature(custom_attribute))]"}, {"sha": "66c8403b2685e244775dfdaa777ec38b615ecde7", "filename": "src/libstd/net/tcp.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftcp.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -19,6 +19,7 @@ use io;\n use net::{ToSocketAddrs, SocketAddr, Shutdown};\n use sys_common::net as net_imp;\n use sys_common::{AsInner, FromInner};\n+use sys_common::io::read_to_end_uninitialized;\n use time::Duration;\n \n /// A structure which represents a TCP stream between a local socket and a\n@@ -189,6 +190,9 @@ impl TcpStream {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Read for TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for TcpStream {\n@@ -198,6 +202,9 @@ impl Write for TcpStream {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Read for &'a TcpStream {\n     fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> { self.0.read(buf) }\n+    fn read_to_end(&mut self, buf: &mut Vec<u8>) -> io::Result<usize> {\n+        unsafe { read_to_end_uninitialized(self, buf) }\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Write for &'a TcpStream {"}, {"sha": "275f415c6fc800faafce6e502c2f9a219125d4e0", "filename": "src/libstd/prelude/mod.rs", "status": "modified", "additions": 96, "deletions": 7, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fmod.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -22,18 +22,107 @@\n //! with the `std::` path prefix, as in `use std::vec`, `use std::thread::spawn`,\n //! etc.\n //!\n-//! Additionally, `std` contains a `prelude` module that reexports many of the\n-//! most common traits, types and functions. The contents of the prelude are\n-//! imported into every *module* by default.  Implicitly, all modules behave as if\n-//! they contained the following prologue:\n+//! Additionally, `std` contains a versioned *prelude* that reexports many of the\n+//! most common traits, types and functions. *The contents of the prelude are\n+//! imported into every module by default*.  Implicitly, all modules behave as if\n+//! they contained the following [`use` statement][book-use]:\n+//!\n+//! [book-use]: ../../book/crates-and-modules.html#importing-modules-with-use\n //!\n //! ```ignore\n //! use std::prelude::v1::*;\n //! ```\n //!\n-//! The prelude is primarily concerned with exporting *traits* that are so\n-//! pervasive that it would be obnoxious to import for every use, particularly\n-//! those that define methods on primitive types.\n+//! The prelude is primarily concerned with exporting *traits* that\n+//! are so pervasive that they would be onerous to import for every use,\n+//! particularly those that are commonly mentioned in [generic type\n+//! bounds][book-traits].\n+//!\n+//! The current version of the prelude (version 1) lives in\n+//! [`std::prelude::v1`](v1/index.html), and reexports the following.\n+//!\n+//! * `std::marker::`{\n+//!     [`Copy`](../marker/trait.Copy.html),\n+//!     [`Send`](../marker/trait.Send.html),\n+//!     [`Sized`](../marker/trait.Sized.html),\n+//!     [`Sync`](../marker/trait.Sync.html)\n+//!   }.\n+//!   The marker traits indicate fundamental properties of types.\n+//! * `std::ops::`{\n+//!     [`Drop`](../ops/trait.Drop.html),\n+//!     [`Fn`](../ops/trait.Fn.html),\n+//!     [`FnMut`](../ops/trait.FnMut.html),\n+//!     [`FnOnce`](../ops/trait.FnOnce.html)\n+//!   }.\n+//!   The [destructor][book-dtor] trait and the\n+//!   [closure][book-closures] traits, reexported from the same\n+//!   [module that also defines overloaded\n+//!   operators](../ops/index.html).\n+//! * `std::mem::`[`drop`](../mem/fn.drop.html).\n+//!   A convenience function for explicitly dropping a value.\n+//! * `std::boxed::`[`Box`](../boxed/struct.Box.html).\n+//!   The owned heap pointer.\n+//! * `std::borrow::`[`ToOwned`](../borrow/trait.ToOwned.html).\n+//!   The conversion trait that defines `to_owned`, the generic method\n+//!   for creating an owned type from a borrowed type.\n+//! * `std::clone::`[`Clone`](../clone/trait.Clone.html).\n+//!   The ubiquitous trait that defines `clone`, the method for\n+//!   producing copies of values that are consider expensive to copy.\n+//! * `std::cmp::`{\n+//!     [`PartialEq`](../cmp/trait.PartialEq.html),\n+//!     [`PartialOrd`](../cmp/trait.PartialOrd.html),\n+//!     [`Eq`](../cmp/trait.Eq.html),\n+//!     [`Ord`](../cmp/trait.Ord.html)\n+//!   }.\n+//!   The comparision traits, which implement the comparison operators\n+//!   and are often seen in trait bounds.\n+//! * `std::convert::`{\n+//!     [`AsRef`](../convert/trait.AsRef.html),\n+//!     [`AsMut`](../convert/trait.AsMut.html),\n+//!     [`Into`](../convert/trait.Into.html),\n+//!     [`From`](../convert/trait.From.html)\n+//!   }.\n+//!   Generic conversions, used by savvy API authors to create\n+//!   overloaded methods.\n+//! * `std::default::`[`Default`](../default/trait.Default).\n+//!   Types that have default values.\n+//! * `std::iter::`{\n+//!     [`Iterator`](../iter/trait.Iterator.html),\n+//!     [`Extend`](../iter/trait.Extend.html),\n+//!     [`IntoIterator`](../iter/trait.IntoIterator.html),\n+//!     [`DoubleEndedIterator`](../iter/trait.DoubleEndedIterator.html),\n+//!     [`ExactSizeIterator`](../iter/trait.ExactSizeIterator.html)\n+//!   }.\n+//!   [Iterators][book-iter].\n+//! * `std::option::Option::`{\n+//!     [`self`](../option/enum.Option.html),\n+//!     [`Some`](../option/enum.Option.html),\n+//!     [`None`](../option/enum.Option.html)\n+//!   }.\n+//!   The ubiquitous `Option` type and its two [variants][book-enums],\n+//!   `Some` and `None`.\n+//! * `std::result::Result::`{\n+//!     [`self`](../result/enum.Result.html),\n+//!     [`Some`](../result/enum.Result.html),\n+//!     [`None`](../result/enum.Result.html)\n+//!   }.\n+//!   The ubiquitous `Result` type and its two [variants][book-enums],\n+//!   `Ok` and `Err`.\n+//! * `std::slice::`[`SliceConcatExt`](../slice/trait.SliceConcatExt.html).\n+//!   An unstable extension to slices that shouldn't have to exist.\n+//! * `std::string::`{\n+//!     [`String`](../string/struct.String.html),\n+//!     [`ToString`](../string/trait.ToString.html)\n+//!   }.\n+//!   Heap allocated strings.\n+//! * `std::vec::`[`Vec`](../vec/struct.Vec.html).\n+//!   Heap allocated vectors.\n+//!\n+//! [book-traits]: ../../book/traits.html\n+//! [book-closures]: ../../book/closures.html\n+//! [book-dtor]: ../../book/drop.html\n+//! [book-iter]: ../../book/iterators.html\n+//! [book-enums]: ../../book/enums.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n "}, {"sha": "151d853fc9f7e033576df32ea0a093db9a0412c5", "filename": "src/libstd/sys/common/io.rs", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fio.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -0,0 +1,139 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+use prelude::v1::*;\n+use io;\n+use io::ErrorKind;\n+use io::Read;\n+use slice::from_raw_parts_mut;\n+\n+// Provides read_to_end functionality over an uninitialized buffer.\n+// This function is unsafe because it calls the underlying\n+// read function with a slice into uninitialized memory. The default\n+// implementation of read_to_end for readers will zero out new memory in\n+// the buf before passing it to read, but avoiding this zero can often\n+// lead to a fairly significant performance win.\n+//\n+// Implementations using this method have to adhere to two guarantees:\n+//  *  The implementation of read never reads the buffer provided.\n+//  *  The implementation of read correctly reports how many bytes were written.\n+pub unsafe fn read_to_end_uninitialized(r: &mut Read, buf: &mut Vec<u8>) -> io::Result<usize> {\n+\n+    let start_len = buf.len();\n+    buf.reserve(16);\n+\n+    // Always try to read into the empty space of the vector (from the length to the capacity).\n+    // If the vector ever fills up then we reserve an extra byte which should trigger the normal\n+    // reallocation routines for the vector, which will likely double the size.\n+    //\n+    // This function is similar to the read_to_end function in std::io, but the logic about\n+    // reservations and slicing is different enough that this is duplicated here.\n+    loop {\n+        if buf.len() == buf.capacity() {\n+            buf.reserve(1);\n+        }\n+\n+        let buf_slice = from_raw_parts_mut(buf.as_mut_ptr().offset(buf.len() as isize),\n+                                           buf.capacity() - buf.len());\n+\n+        match r.read(buf_slice) {\n+            Ok(0) => { return Ok(buf.len() - start_len); }\n+            Ok(n) => { let len = buf.len() + n; buf.set_len(len); },\n+            Err(ref e) if e.kind() == ErrorKind::Interrupted => { }\n+            Err(e) => { return Err(e); }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use prelude::v1::*;\n+    use io::prelude::*;\n+    use super::*;\n+    use io;\n+    use io::{ErrorKind, Take, Repeat, repeat};\n+    use test;\n+    use slice::from_raw_parts;\n+\n+    struct ErrorRepeat {\n+        lr: Take<Repeat>\n+    }\n+\n+    fn error_repeat(byte: u8, limit: u64) -> ErrorRepeat {\n+        ErrorRepeat { lr: repeat(byte).take(limit) }\n+    }\n+\n+    impl Read for ErrorRepeat {\n+        fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+            let ret = self.lr.read(buf);\n+            if let Ok(0) = ret {\n+                return Err(io::Error::new(ErrorKind::Other, \"\"))\n+            }\n+            ret\n+        }\n+    }\n+\n+    fn init_vec_data() -> Vec<u8> {\n+        let mut vec = vec![10u8; 200];\n+        unsafe { vec.set_len(0); }\n+        vec\n+    }\n+\n+    fn assert_all_eq(buf: &[u8], value: u8) {\n+        for n in buf {\n+            assert_eq!(*n, value);\n+        }\n+    }\n+\n+    fn validate(buf: &Vec<u8>, good_read_len: usize) {\n+        assert_all_eq(buf, 1u8);\n+        let cap = buf.capacity();\n+        let end_slice = unsafe { from_raw_parts(buf.as_ptr().offset(good_read_len as isize),\n+                                                    cap - good_read_len) };\n+        assert_all_eq(end_slice, 10u8);\n+    }\n+\n+    #[test]\n+    fn read_to_end_uninit_error() {\n+        let mut er = error_repeat(1,100);\n+        let mut vec = init_vec_data();\n+        if let Err(_) = unsafe { read_to_end_uninitialized(&mut er, &mut vec) } {\n+            validate(&vec, 100);\n+        } else {\n+            assert!(false);\n+        }\n+    }\n+\n+    #[test]\n+    fn read_to_end_uninit_zero_len_vec() {\n+        let mut er = repeat(1).take(100);\n+        let mut vec = Vec::new();\n+        let n = unsafe{ read_to_end_uninitialized(&mut er, &mut vec).unwrap() };\n+        assert_all_eq(&vec, 1u8);\n+        assert_eq!(vec.len(), n);\n+    }\n+\n+    #[test]\n+    fn read_to_end_uninit_good() {\n+        let mut er = repeat(1).take(100);\n+        let mut vec = init_vec_data();\n+        let n = unsafe{ read_to_end_uninitialized(&mut er, &mut vec).unwrap() };\n+        validate(&vec, 100);\n+        assert_eq!(vec.len(), n);\n+    }\n+\n+    #[bench]\n+    fn bench_uninitialized(b: &mut test::Bencher) {\n+        b.iter(|| {\n+            let mut lr = repeat(1).take(10000000);\n+            let mut vec = Vec::with_capacity(1024);\n+            unsafe { read_to_end_uninitialized(&mut lr, &mut vec) };\n+        });\n+    }\n+}"}, {"sha": "69c54f989175973ee851e1ef54b212bf245dd233", "filename": "src/libstd/sys/common/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fmod.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -16,6 +16,7 @@ pub mod backtrace;\n pub mod condvar;\n pub mod mutex;\n pub mod net;\n+pub mod io;\n pub mod poison;\n pub mod remutex;\n pub mod rwlock;"}, {"sha": "fbf015169f858b8086be80939a6e60de2633b7bf", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 392, "deletions": 396, "changes": 788, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -308,63 +308,6 @@ impl Level {\n     }\n }\n \n-fn print_maybe_styled(w: &mut EmitterWriter,\n-                      msg: &str,\n-                      color: term::attr::Attr) -> io::Result<()> {\n-    match w.dst {\n-        Terminal(ref mut t) => {\n-            try!(t.attr(color));\n-            // If `msg` ends in a newline, we need to reset the color before\n-            // the newline. We're making the assumption that we end up writing\n-            // to a `LineBufferedWriter`, which means that emitting the reset\n-            // after the newline ends up buffering the reset until we print\n-            // another line or exit. Buffering the reset is a problem if we're\n-            // sharing the terminal with any other programs (e.g. other rustc\n-            // instances via `make -jN`).\n-            //\n-            // Note that if `msg` contains any internal newlines, this will\n-            // result in the `LineBufferedWriter` flushing twice instead of\n-            // once, which still leaves the opportunity for interleaved output\n-            // to be miscolored. We assume this is rare enough that we don't\n-            // have to worry about it.\n-            if msg.ends_with(\"\\n\") {\n-                try!(t.write_all(msg[..msg.len()-1].as_bytes()));\n-                try!(t.reset());\n-                try!(t.write_all(b\"\\n\"));\n-            } else {\n-                try!(t.write_all(msg.as_bytes()));\n-                try!(t.reset());\n-            }\n-            Ok(())\n-        }\n-        Raw(ref mut w) => w.write_all(msg.as_bytes()),\n-    }\n-}\n-\n-fn print_diagnostic(dst: &mut EmitterWriter, topic: &str, lvl: Level,\n-                    msg: &str, code: Option<&str>) -> io::Result<()> {\n-    if !topic.is_empty() {\n-        try!(write!(&mut dst.dst, \"{} \", topic));\n-    }\n-\n-    try!(print_maybe_styled(dst,\n-                            &format!(\"{}: \", lvl.to_string()),\n-                            term::attr::ForegroundColor(lvl.color())));\n-    try!(print_maybe_styled(dst,\n-                            &format!(\"{}\", msg),\n-                            term::attr::Bold));\n-\n-    match code {\n-        Some(code) => {\n-            let style = term::attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n-            try!(print_maybe_styled(dst, &format!(\" [{}]\", code.clone()), style));\n-        }\n-        None => ()\n-    }\n-    try!(write!(&mut dst.dst, \"\\n\"));\n-    Ok(())\n-}\n-\n pub struct EmitterWriter {\n     dst: Destination,\n     registry: Option<diagnostics::registry::Registry>\n@@ -401,6 +344,392 @@ impl EmitterWriter {\n                registry: Option<diagnostics::registry::Registry>) -> EmitterWriter {\n         EmitterWriter { dst: Raw(dst), registry: registry }\n     }\n+\n+    fn print_maybe_styled(&mut self,\n+                          msg: &str,\n+                          color: term::attr::Attr) -> io::Result<()> {\n+        match self.dst {\n+            Terminal(ref mut t) => {\n+                try!(t.attr(color));\n+                // If `msg` ends in a newline, we need to reset the color before\n+                // the newline. We're making the assumption that we end up writing\n+                // to a `LineBufferedWriter`, which means that emitting the reset\n+                // after the newline ends up buffering the reset until we print\n+                // another line or exit. Buffering the reset is a problem if we're\n+                // sharing the terminal with any other programs (e.g. other rustc\n+                // instances via `make -jN`).\n+                //\n+                // Note that if `msg` contains any internal newlines, this will\n+                // result in the `LineBufferedWriter` flushing twice instead of\n+                // once, which still leaves the opportunity for interleaved output\n+                // to be miscolored. We assume this is rare enough that we don't\n+                // have to worry about it.\n+                if msg.ends_with(\"\\n\") {\n+                    try!(t.write_all(msg[..msg.len()-1].as_bytes()));\n+                    try!(t.reset());\n+                    try!(t.write_all(b\"\\n\"));\n+                } else {\n+                    try!(t.write_all(msg.as_bytes()));\n+                    try!(t.reset());\n+                }\n+                Ok(())\n+            }\n+            Raw(ref mut w) => w.write_all(msg.as_bytes()),\n+        }\n+    }\n+\n+    fn print_diagnostic(&mut self, topic: &str, lvl: Level,\n+                        msg: &str, code: Option<&str>) -> io::Result<()> {\n+        if !topic.is_empty() {\n+            try!(write!(&mut self.dst, \"{} \", topic));\n+        }\n+\n+        try!(self.print_maybe_styled(&format!(\"{}: \", lvl.to_string()),\n+                                     term::attr::ForegroundColor(lvl.color())));\n+        try!(self.print_maybe_styled(&format!(\"{}\", msg),\n+                                     term::attr::Bold));\n+\n+        match code {\n+            Some(code) => {\n+                let style = term::attr::ForegroundColor(term::color::BRIGHT_MAGENTA);\n+                try!(self.print_maybe_styled(&format!(\" [{}]\", code.clone()), style));\n+            }\n+            None => ()\n+        }\n+        try!(write!(&mut self.dst, \"\\n\"));\n+        Ok(())\n+    }\n+\n+    fn emit_(&mut self, cm: &codemap::CodeMap, rsp: RenderSpan,\n+             msg: &str, code: Option<&str>, lvl: Level) -> io::Result<()> {\n+        let sp = rsp.span();\n+\n+        // We cannot check equality directly with COMMAND_LINE_SP\n+        // since PartialEq is manually implemented to ignore the ExpnId\n+        let ss = if sp.expn_id == COMMAND_LINE_EXPN {\n+            \"<command line option>\".to_string()\n+        } else if let EndSpan(_) = rsp {\n+            let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n+            cm.span_to_string(span_end)\n+        } else {\n+            cm.span_to_string(sp)\n+        };\n+\n+        try!(self.print_diagnostic(&ss[..], lvl, msg, code));\n+\n+        match rsp {\n+            FullSpan(_) => {\n+                try!(self.highlight_lines(cm, sp, lvl, cm.span_to_lines(sp)));\n+                try!(self.print_macro_backtrace(cm, sp));\n+            }\n+            EndSpan(_) => {\n+                try!(self.end_highlight_lines(cm, sp, lvl, cm.span_to_lines(sp)));\n+                try!(self.print_macro_backtrace(cm, sp));\n+            }\n+            Suggestion(_, ref suggestion) => {\n+                try!(self.highlight_suggestion(cm, sp, suggestion));\n+                try!(self.print_macro_backtrace(cm, sp));\n+            }\n+            FileLine(..) => {\n+                // no source text in this case!\n+            }\n+        }\n+\n+        match code {\n+            Some(code) =>\n+                match self.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n+                    Some(_) => {\n+                        try!(self.print_diagnostic(&ss[..], Help,\n+                                                   &format!(\"run `rustc --explain {}` to see a \\\n+                                                             detailed explanation\", code), None));\n+                    }\n+                    None => ()\n+                },\n+            None => (),\n+        }\n+        Ok(())\n+    }\n+\n+    fn highlight_suggestion(&mut self,\n+                            cm: &codemap::CodeMap,\n+                            sp: Span,\n+                            suggestion: &str)\n+                            -> io::Result<()>\n+    {\n+        let lines = cm.span_to_lines(sp).unwrap();\n+        assert!(!lines.lines.is_empty());\n+\n+        // To build up the result, we want to take the snippet from the first\n+        // line that precedes the span, prepend that with the suggestion, and\n+        // then append the snippet from the last line that trails the span.\n+        let fm = &lines.file;\n+\n+        let first_line = &lines.lines[0];\n+        let prefix = fm.get_line(first_line.line_index)\n+                       .map(|l| &l[..first_line.start_col.0])\n+                       .unwrap_or(\"\");\n+\n+        let last_line = lines.lines.last().unwrap();\n+        let suffix = fm.get_line(last_line.line_index)\n+                       .map(|l| &l[last_line.end_col.0..])\n+                       .unwrap_or(\"\");\n+\n+        let complete = format!(\"{}{}{}\", prefix, suggestion, suffix);\n+\n+        // print the suggestion without any line numbers, but leave\n+        // space for them. This helps with lining up with previous\n+        // snippets from the actual error being reported.\n+        let fm = &*lines.file;\n+        let mut lines = complete.lines();\n+        for (line, line_index) in lines.by_ref().take(MAX_LINES).zip(first_line.line_index..) {\n+            let elided_line_num = format!(\"{}\", line_index+1);\n+            try!(write!(&mut self.dst, \"{0}:{1:2$} {3}\\n\",\n+                        fm.name, \"\", elided_line_num.len(), line));\n+        }\n+\n+        // if we elided some lines, add an ellipsis\n+        if lines.next().is_some() {\n+            let elided_line_num = format!(\"{}\", first_line.line_index + MAX_LINES + 1);\n+            try!(write!(&mut self.dst, \"{0:1$} {0:2$} ...\\n\",\n+                        \"\", fm.name.len(), elided_line_num.len()));\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn highlight_lines(&mut self,\n+                       cm: &codemap::CodeMap,\n+                       sp: Span,\n+                       lvl: Level,\n+                       lines: codemap::FileLinesResult)\n+                       -> io::Result<()>\n+    {\n+        let lines = match lines {\n+            Ok(lines) => lines,\n+            Err(_) => {\n+                try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n+                return Ok(());\n+            }\n+        };\n+\n+        let fm = &*lines.file;\n+\n+        let line_strings: Option<Vec<&str>> =\n+            lines.lines.iter()\n+                       .map(|info| fm.get_line(info.line_index))\n+                       .collect();\n+\n+        let line_strings = match line_strings {\n+            None => { return Ok(()); }\n+            Some(line_strings) => line_strings\n+        };\n+\n+        // Display only the first MAX_LINES lines.\n+        let all_lines = lines.lines.len();\n+        let display_lines = cmp::min(all_lines, MAX_LINES);\n+        let display_line_infos = &lines.lines[..display_lines];\n+        let display_line_strings = &line_strings[..display_lines];\n+\n+        // Calculate the widest number to format evenly and fix #11715\n+        assert!(display_line_infos.len() > 0);\n+        let mut max_line_num = display_line_infos[display_line_infos.len() - 1].line_index + 1;\n+        let mut digits = 0;\n+        while max_line_num > 0 {\n+            max_line_num /= 10;\n+            digits += 1;\n+        }\n+\n+        // Print the offending lines\n+        for (line_info, line) in display_line_infos.iter().zip(display_line_strings) {\n+            try!(write!(&mut self.dst, \"{}:{:>width$} {}\\n\",\n+                        fm.name,\n+                        line_info.line_index + 1,\n+                        line,\n+                        width=digits));\n+        }\n+\n+        // If we elided something, put an ellipsis.\n+        if display_lines < all_lines {\n+            let last_line_index = display_line_infos.last().unwrap().line_index;\n+            let s = format!(\"{}:{} \", fm.name, last_line_index + 1);\n+            try!(write!(&mut self.dst, \"{0:1$}...\\n\", \"\", s.len()));\n+        }\n+\n+        // FIXME (#3260)\n+        // If there's one line at fault we can easily point to the problem\n+        if lines.lines.len() == 1 {\n+            let lo = cm.lookup_char_pos(sp.lo);\n+            let mut digits = 0;\n+            let mut num = (lines.lines[0].line_index + 1) / 10;\n+\n+            // how many digits must be indent past?\n+            while num > 0 { num /= 10; digits += 1; }\n+\n+            let mut s = String::new();\n+            // Skip is the number of characters we need to skip because they are\n+            // part of the 'filename:line ' part of the previous line.\n+            let skip = fm.name.chars().count() + digits + 3;\n+            for _ in 0..skip {\n+                s.push(' ');\n+            }\n+            if let Some(orig) = fm.get_line(lines.lines[0].line_index) {\n+                let mut col = skip;\n+                let mut lastc = ' ';\n+                let mut iter = orig.chars().enumerate();\n+                for (pos, ch) in iter.by_ref() {\n+                    lastc = ch;\n+                    if pos >= lo.col.to_usize() { break; }\n+                    // Whenever a tab occurs on the previous line, we insert one on\n+                    // the error-point-squiggly-line as well (instead of a space).\n+                    // That way the squiggly line will usually appear in the correct\n+                    // position.\n+                    match ch {\n+                        '\\t' => {\n+                            col += 8 - col%8;\n+                            s.push('\\t');\n+                        },\n+                        _ => {\n+                            col += 1;\n+                            s.push(' ');\n+                        },\n+                    }\n+                }\n+\n+                try!(write!(&mut self.dst, \"{}\", s));\n+                let mut s = String::from(\"^\");\n+                let count = match lastc {\n+                    // Most terminals have a tab stop every eight columns by default\n+                    '\\t' => 8 - col%8,\n+                    _ => 1,\n+                };\n+                col += count;\n+                s.extend(::std::iter::repeat('~').take(count));\n+\n+                let hi = cm.lookup_char_pos(sp.hi);\n+                if hi.col != lo.col {\n+                    for (pos, ch) in iter {\n+                        if pos >= hi.col.to_usize() { break; }\n+                        let count = match ch {\n+                            '\\t' => 8 - col%8,\n+                            _ => 1,\n+                        };\n+                        col += count;\n+                        s.extend(::std::iter::repeat('~').take(count));\n+                    }\n+                }\n+\n+                if s.len() > 1 {\n+                    // One extra squiggly is replaced by a \"^\"\n+                    s.pop();\n+                }\n+\n+                try!(self.print_maybe_styled(&format!(\"{}\\n\", s),\n+                                             term::attr::ForegroundColor(lvl.color())));\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Here are the differences between this and the normal `highlight_lines`:\n+    /// `end_highlight_lines` will always put arrow on the last byte of the\n+    /// span (instead of the first byte). Also, when the span is too long (more\n+    /// than 6 lines), `end_highlight_lines` will print the first line, then\n+    /// dot dot dot, then last line, whereas `highlight_lines` prints the first\n+    /// six lines.\n+    #[allow(deprecated)]\n+    fn end_highlight_lines(&mut self,\n+                           cm: &codemap::CodeMap,\n+                           sp: Span,\n+                           lvl: Level,\n+                           lines: codemap::FileLinesResult)\n+                          -> io::Result<()> {\n+        let lines = match lines {\n+            Ok(lines) => lines,\n+            Err(_) => {\n+                try!(write!(&mut self.dst, \"(internal compiler error: unprintable span)\\n\"));\n+                return Ok(());\n+            }\n+        };\n+\n+        let fm = &*lines.file;\n+\n+        let lines = &lines.lines[..];\n+        if lines.len() > MAX_LINES {\n+            if let Some(line) = fm.get_line(lines[0].line_index) {\n+                try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n+                            lines[0].line_index + 1, line));\n+            }\n+            try!(write!(&mut self.dst, \"...\\n\"));\n+            let last_line_index = lines[lines.len() - 1].line_index;\n+            if let Some(last_line) = fm.get_line(last_line_index) {\n+                try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n+                            last_line_index + 1, last_line));\n+            }\n+        } else {\n+            for line_info in lines {\n+                if let Some(line) = fm.get_line(line_info.line_index) {\n+                    try!(write!(&mut self.dst, \"{}:{} {}\\n\", fm.name,\n+                                line_info.line_index + 1, line));\n+                }\n+            }\n+        }\n+        let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n+        let hi = cm.lookup_char_pos(sp.hi);\n+        let skip = last_line_start.chars().count();\n+        let mut s = String::new();\n+        for _ in 0..skip {\n+            s.push(' ');\n+        }\n+        if let Some(orig) = fm.get_line(lines[0].line_index) {\n+            let iter = orig.chars().enumerate();\n+            for (pos, ch) in iter {\n+                // Span seems to use half-opened interval, so subtract 1\n+                if pos >= hi.col.to_usize() - 1 { break; }\n+                // Whenever a tab occurs on the previous line, we insert one on\n+                // the error-point-squiggly-line as well (instead of a space).\n+                // That way the squiggly line will usually appear in the correct\n+                // position.\n+                match ch {\n+                    '\\t' => s.push('\\t'),\n+                    _ => s.push(' '),\n+                }\n+            }\n+        }\n+        s.push('^');\n+        s.push('\\n');\n+        self.print_maybe_styled(&s[..],\n+                                term::attr::ForegroundColor(lvl.color()))\n+    }\n+\n+    fn print_macro_backtrace(&mut self,\n+                             cm: &codemap::CodeMap,\n+                             sp: Span)\n+                             -> io::Result<()> {\n+        let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| -> io::Result<_> {\n+            match expn_info {\n+                Some(ei) => {\n+                    let ss = ei.callee.span.map_or(String::new(),\n+                                                   |span| cm.span_to_string(span));\n+                    let (pre, post) = match ei.callee.format {\n+                        codemap::MacroAttribute => (\"#[\", \"]\"),\n+                        codemap::MacroBang => (\"\", \"!\"),\n+                        codemap::CompilerExpansion => (\"\", \"\"),\n+                    };\n+                    try!(self.print_diagnostic(&ss, Note,\n+                                               &format!(\"in expansion of {}{}{}\",\n+                                                        pre,\n+                                                        ei.callee.name,\n+                                                        post),\n+                                               None));\n+                    let ss = cm.span_to_string(ei.call_site);\n+                    try!(self.print_diagnostic(&ss, Note, \"expansion site\", None));\n+                    Ok(Some(ei.call_site))\n+                }\n+                None => Ok(None)\n+        }\n+        }));\n+        cs.map_or(Ok(()), |call_site| self.print_macro_backtrace(cm, call_site))\n+    }\n }\n \n #[cfg(unix)]\n@@ -442,11 +771,11 @@ impl Emitter for EmitterWriter {\n             cmsp: Option<(&codemap::CodeMap, Span)>,\n             msg: &str, code: Option<&str>, lvl: Level) {\n         let error = match cmsp {\n-            Some((cm, COMMAND_LINE_SP)) => emit(self, cm,\n+            Some((cm, COMMAND_LINE_SP)) => self.emit_(cm,\n                                                 FileLine(COMMAND_LINE_SP),\n                                                 msg, code, lvl),\n-            Some((cm, sp)) => emit(self, cm, FullSpan(sp), msg, code, lvl),\n-            None => print_diagnostic(self, \"\", lvl, msg, code),\n+            Some((cm, sp)) => self.emit_(cm, FullSpan(sp), msg, code, lvl),\n+            None => self.print_diagnostic(\"\", lvl, msg, code),\n         };\n \n         match error {\n@@ -457,346 +786,13 @@ impl Emitter for EmitterWriter {\n \n     fn custom_emit(&mut self, cm: &codemap::CodeMap,\n                    sp: RenderSpan, msg: &str, lvl: Level) {\n-        match emit(self, cm, sp, msg, None, lvl) {\n+        match self.emit_(cm, sp, msg, None, lvl) {\n             Ok(()) => {}\n             Err(e) => panic!(\"failed to print diagnostics: {:?}\", e),\n         }\n     }\n }\n \n-fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n-        msg: &str, code: Option<&str>, lvl: Level) -> io::Result<()> {\n-    let sp = rsp.span();\n-\n-    // We cannot check equality directly with COMMAND_LINE_SP\n-    // since PartialEq is manually implemented to ignore the ExpnId\n-    let ss = if sp.expn_id == COMMAND_LINE_EXPN {\n-        \"<command line option>\".to_string()\n-    } else if let EndSpan(_) = rsp {\n-        let span_end = Span { lo: sp.hi, hi: sp.hi, expn_id: sp.expn_id};\n-        cm.span_to_string(span_end)\n-    } else {\n-        cm.span_to_string(sp)\n-    };\n-\n-    try!(print_diagnostic(dst, &ss[..], lvl, msg, code));\n-\n-    match rsp {\n-        FullSpan(_) => {\n-            try!(highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n-            try!(print_macro_backtrace(dst, cm, sp));\n-        }\n-        EndSpan(_) => {\n-            try!(end_highlight_lines(dst, cm, sp, lvl, cm.span_to_lines(sp)));\n-            try!(print_macro_backtrace(dst, cm, sp));\n-        }\n-        Suggestion(_, ref suggestion) => {\n-            try!(highlight_suggestion(dst, cm, sp, suggestion));\n-            try!(print_macro_backtrace(dst, cm, sp));\n-        }\n-        FileLine(..) => {\n-            // no source text in this case!\n-        }\n-    }\n-\n-    match code {\n-        Some(code) =>\n-            match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n-                Some(_) => {\n-                    try!(print_diagnostic(dst, &ss[..], Help,\n-                                          &format!(\"run `rustc --explain {}` to see a detailed \\\n-                                                   explanation\", code), None));\n-                }\n-                None => ()\n-            },\n-        None => (),\n-    }\n-    Ok(())\n-}\n-\n-fn highlight_suggestion(err: &mut EmitterWriter,\n-                        cm: &codemap::CodeMap,\n-                        sp: Span,\n-                        suggestion: &str)\n-                        -> io::Result<()>\n-{\n-    let lines = cm.span_to_lines(sp).unwrap();\n-    assert!(!lines.lines.is_empty());\n-\n-    // To build up the result, we want to take the snippet from the first\n-    // line that precedes the span, prepend that with the suggestion, and\n-    // then append the snippet from the last line that trails the span.\n-    let fm = &lines.file;\n-\n-    let first_line = &lines.lines[0];\n-    let prefix = fm.get_line(first_line.line_index)\n-                   .map(|l| &l[..first_line.start_col.0])\n-                   .unwrap_or(\"\");\n-\n-    let last_line = lines.lines.last().unwrap();\n-    let suffix = fm.get_line(last_line.line_index)\n-                   .map(|l| &l[last_line.end_col.0..])\n-                   .unwrap_or(\"\");\n-\n-    let complete = format!(\"{}{}{}\", prefix, suggestion, suffix);\n-\n-    // print the suggestion without any line numbers, but leave\n-    // space for them. This helps with lining up with previous\n-    // snippets from the actual error being reported.\n-    let fm = &*lines.file;\n-    let mut lines = complete.lines();\n-    for (line, line_index) in lines.by_ref().take(MAX_LINES).zip(first_line.line_index..) {\n-        let elided_line_num = format!(\"{}\", line_index+1);\n-        try!(write!(&mut err.dst, \"{0}:{1:2$} {3}\\n\",\n-                    fm.name, \"\", elided_line_num.len(), line));\n-    }\n-\n-    // if we elided some lines, add an ellipsis\n-    if lines.next().is_some() {\n-        let elided_line_num = format!(\"{}\", first_line.line_index + MAX_LINES + 1);\n-        try!(write!(&mut err.dst, \"{0:1$} {0:2$} ...\\n\",\n-                    \"\", fm.name.len(), elided_line_num.len()));\n-    }\n-\n-    Ok(())\n-}\n-\n-fn highlight_lines(err: &mut EmitterWriter,\n-                   cm: &codemap::CodeMap,\n-                   sp: Span,\n-                   lvl: Level,\n-                   lines: codemap::FileLinesResult)\n-                   -> io::Result<()>\n-{\n-    let lines = match lines {\n-        Ok(lines) => lines,\n-        Err(_) => {\n-            try!(write!(&mut err.dst, \"(internal compiler error: unprintable span)\\n\"));\n-            return Ok(());\n-        }\n-    };\n-\n-    let fm = &*lines.file;\n-\n-    let line_strings: Option<Vec<&str>> =\n-        lines.lines.iter()\n-                   .map(|info| fm.get_line(info.line_index))\n-                   .collect();\n-\n-    let line_strings = match line_strings {\n-        None => { return Ok(()); }\n-        Some(line_strings) => line_strings\n-    };\n-\n-    // Display only the first MAX_LINES lines.\n-    let all_lines = lines.lines.len();\n-    let display_lines = cmp::min(all_lines, MAX_LINES);\n-    let display_line_infos = &lines.lines[..display_lines];\n-    let display_line_strings = &line_strings[..display_lines];\n-\n-    // Calculate the widest number to format evenly and fix #11715\n-    assert!(display_line_infos.len() > 0);\n-    let mut max_line_num = display_line_infos[display_line_infos.len() - 1].line_index + 1;\n-    let mut digits = 0;\n-    while max_line_num > 0 {\n-        max_line_num /= 10;\n-        digits += 1;\n-    }\n-\n-    // Print the offending lines\n-    for (line_info, line) in display_line_infos.iter().zip(display_line_strings) {\n-        try!(write!(&mut err.dst, \"{}:{:>width$} {}\\n\",\n-                    fm.name,\n-                    line_info.line_index + 1,\n-                    line,\n-                    width=digits));\n-    }\n-\n-    // If we elided something, put an ellipsis.\n-    if display_lines < all_lines {\n-        let last_line_index = display_line_infos.last().unwrap().line_index;\n-        let s = format!(\"{}:{} \", fm.name, last_line_index + 1);\n-        try!(write!(&mut err.dst, \"{0:1$}...\\n\", \"\", s.len()));\n-    }\n-\n-    // FIXME (#3260)\n-    // If there's one line at fault we can easily point to the problem\n-    if lines.lines.len() == 1 {\n-        let lo = cm.lookup_char_pos(sp.lo);\n-        let mut digits = 0;\n-        let mut num = (lines.lines[0].line_index + 1) / 10;\n-\n-        // how many digits must be indent past?\n-        while num > 0 { num /= 10; digits += 1; }\n-\n-        let mut s = String::new();\n-        // Skip is the number of characters we need to skip because they are\n-        // part of the 'filename:line ' part of the previous line.\n-        let skip = fm.name.chars().count() + digits + 3;\n-        for _ in 0..skip {\n-            s.push(' ');\n-        }\n-        if let Some(orig) = fm.get_line(lines.lines[0].line_index) {\n-            let mut col = skip;\n-            let mut lastc = ' ';\n-            let mut iter = orig.chars().enumerate();\n-            for (pos, ch) in iter.by_ref() {\n-                lastc = ch;\n-                if pos >= lo.col.to_usize() { break; }\n-                // Whenever a tab occurs on the previous line, we insert one on\n-                // the error-point-squiggly-line as well (instead of a space).\n-                // That way the squiggly line will usually appear in the correct\n-                // position.\n-                match ch {\n-                    '\\t' => {\n-                        col += 8 - col%8;\n-                        s.push('\\t');\n-                    },\n-                    _ => {\n-                        col += 1;\n-                        s.push(' ');\n-                    },\n-                }\n-            }\n-\n-            try!(write!(&mut err.dst, \"{}\", s));\n-            let mut s = String::from(\"^\");\n-            let count = match lastc {\n-                // Most terminals have a tab stop every eight columns by default\n-                '\\t' => 8 - col%8,\n-                _ => 1,\n-            };\n-            col += count;\n-            s.extend(::std::iter::repeat('~').take(count));\n-\n-            let hi = cm.lookup_char_pos(sp.hi);\n-            if hi.col != lo.col {\n-                for (pos, ch) in iter {\n-                    if pos >= hi.col.to_usize() { break; }\n-                    let count = match ch {\n-                        '\\t' => 8 - col%8,\n-                        _ => 1,\n-                    };\n-                    col += count;\n-                    s.extend(::std::iter::repeat('~').take(count));\n-                }\n-            }\n-\n-            if s.len() > 1 {\n-                // One extra squiggly is replaced by a \"^\"\n-                s.pop();\n-            }\n-\n-            try!(print_maybe_styled(err,\n-                                    &format!(\"{}\\n\", s),\n-                                    term::attr::ForegroundColor(lvl.color())));\n-        }\n-    }\n-    Ok(())\n-}\n-\n-/// Here are the differences between this and the normal `highlight_lines`:\n-/// `end_highlight_lines` will always put arrow on the last byte of the\n-/// span (instead of the first byte). Also, when the span is too long (more\n-/// than 6 lines), `end_highlight_lines` will print the first line, then\n-/// dot dot dot, then last line, whereas `highlight_lines` prints the first\n-/// six lines.\n-#[allow(deprecated)]\n-fn end_highlight_lines(w: &mut EmitterWriter,\n-                          cm: &codemap::CodeMap,\n-                          sp: Span,\n-                          lvl: Level,\n-                          lines: codemap::FileLinesResult)\n-                          -> io::Result<()> {\n-    let lines = match lines {\n-        Ok(lines) => lines,\n-        Err(_) => {\n-            try!(write!(&mut w.dst, \"(internal compiler error: unprintable span)\\n\"));\n-            return Ok(());\n-        }\n-    };\n-\n-    let fm = &*lines.file;\n-\n-    let lines = &lines.lines[..];\n-    if lines.len() > MAX_LINES {\n-        if let Some(line) = fm.get_line(lines[0].line_index) {\n-            try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                        lines[0].line_index + 1, line));\n-        }\n-        try!(write!(&mut w.dst, \"...\\n\"));\n-        let last_line_index = lines[lines.len() - 1].line_index;\n-        if let Some(last_line) = fm.get_line(last_line_index) {\n-            try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                        last_line_index + 1, last_line));\n-        }\n-    } else {\n-        for line_info in lines {\n-            if let Some(line) = fm.get_line(line_info.line_index) {\n-                try!(write!(&mut w.dst, \"{}:{} {}\\n\", fm.name,\n-                            line_info.line_index + 1, line));\n-            }\n-        }\n-    }\n-    let last_line_start = format!(\"{}:{} \", fm.name, lines[lines.len()-1].line_index + 1);\n-    let hi = cm.lookup_char_pos(sp.hi);\n-    let skip = last_line_start.chars().count();\n-    let mut s = String::new();\n-    for _ in 0..skip {\n-        s.push(' ');\n-    }\n-    if let Some(orig) = fm.get_line(lines[0].line_index) {\n-        let iter = orig.chars().enumerate();\n-        for (pos, ch) in iter {\n-            // Span seems to use half-opened interval, so subtract 1\n-            if pos >= hi.col.to_usize() - 1 { break; }\n-            // Whenever a tab occurs on the previous line, we insert one on\n-            // the error-point-squiggly-line as well (instead of a space).\n-            // That way the squiggly line will usually appear in the correct\n-            // position.\n-            match ch {\n-                '\\t' => s.push('\\t'),\n-                _ => s.push(' '),\n-            }\n-        }\n-    }\n-    s.push('^');\n-    s.push('\\n');\n-    print_maybe_styled(w,\n-                       &s[..],\n-                       term::attr::ForegroundColor(lvl.color()))\n-}\n-\n-fn print_macro_backtrace(w: &mut EmitterWriter,\n-                         cm: &codemap::CodeMap,\n-                         sp: Span)\n-                         -> io::Result<()> {\n-    let cs = try!(cm.with_expn_info(sp.expn_id, |expn_info| -> io::Result<_> {\n-        match expn_info {\n-            Some(ei) => {\n-                let ss = ei.callee.span.map_or(String::new(),\n-                                               |span| cm.span_to_string(span));\n-                let (pre, post) = match ei.callee.format {\n-                    codemap::MacroAttribute => (\"#[\", \"]\"),\n-                    codemap::MacroBang => (\"\", \"!\"),\n-                    codemap::CompilerExpansion => (\"\", \"\"),\n-                };\n-                try!(print_diagnostic(w, &ss, Note,\n-                                      &format!(\"in expansion of {}{}{}\",\n-                                               pre,\n-                                               ei.callee.name,\n-                                               post),\n-                                      None));\n-                let ss = cm.span_to_string(ei.call_site);\n-                try!(print_diagnostic(w, &ss, Note, \"expansion site\", None));\n-                Ok(Some(ei.call_site))\n-            }\n-            None => Ok(None)\n-    }\n-    }));\n-    cs.map_or(Ok(()), |call_site| print_macro_backtrace(w, cm, call_site))\n-}\n-\n pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n     M: FnOnce() -> String,\n {\n@@ -808,7 +804,7 @@ pub fn expect<T, M>(diag: &SpanHandler, opt: Option<T>, msg: M) -> T where\n \n #[cfg(test)]\n mod test {\n-    use super::{EmitterWriter, highlight_lines, Level};\n+    use super::{EmitterWriter, Level};\n     use codemap::{mk_sp, CodeMap, BytePos};\n     use std::sync::{Arc, Mutex};\n     use std::io::{self, Write};\n@@ -854,7 +850,7 @@ mod test {\n         println!(\"span_to_lines\");\n         let lines = cm.span_to_lines(sp);\n         println!(\"highlight_lines\");\n-        highlight_lines(&mut ew, &cm, sp, lvl, lines).unwrap();\n+        ew.highlight_lines(&cm, sp, lvl, lines).unwrap();\n         println!(\"done\");\n         let vec = data.lock().unwrap().clone();\n         let vec: &[u8] = &vec;"}, {"sha": "8b7366ebed431e0bc16afe6a99f68a34126c2c67", "filename": "src/rt/arch/aarch64/morestack.S", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Frt%2Farch%2Faarch64%2Fmorestack.S", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Frt%2Farch%2Faarch64%2Fmorestack.S", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Farch%2Faarch64%2Fmorestack.S?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -24,7 +24,7 @@\n #endif\n \n #if !defined(__APPLE__)\n-.type MORESTACK,%function\n+func MORESTACK\n #endif\n \n // FIXME(AARCH64): this might not be perfectly right but works for now\n@@ -33,3 +33,7 @@ MORESTACK:\n \tbl STACK_EXHAUSTED\n \t// the above function ensures that it never returns\n \t.cfi_endproc\n+\n+#if !defined(__APPLE__)\n+endfunc MORESTACK\n+#endif"}, {"sha": "8e530bee39aadc86b45e48352801ac60c9da0a6e", "filename": "src/rustbook/javascript.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Frustbook%2Fjavascript.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Frustbook%2Fjavascript.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fjavascript.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -57,11 +57,13 @@ document.addEventListener(\"DOMContentLoaded\", function(event) {\n       if (i > 0) {\n         var prevNode = toc[i-1].cloneNode(true);\n         prevNode.className = 'left';\n+        prevNode.setAttribute('rel', 'prev');\n         nav.appendChild(prevNode);\n       }\n       if (i < toc.length - 1) {\n         var nextNode = toc[i+1].cloneNode(true);\n         nextNode.className = 'right';\n+        nextNode.setAttribute('rel', 'next');\n         nav.appendChild(nextNode);\n       }\n       document.getElementById('page').appendChild(nav);"}, {"sha": "4d6e6eded211847a415538c4a0b28fc900e30d52", "filename": "src/test/compile-fail/issue-22312.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fissue-22312.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fissue-22312.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22312.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Index;\n+\n+pub trait Array2D: Index<usize> {\n+    fn rows(&self) -> usize;\n+    fn columns(&self) -> usize;\n+    fn get<'a>(&'a self, y: usize, x: usize) -> Option<&'a <Self as Index<usize>>::Output> {\n+        if y >= self.rows() || x >= self.columns() {\n+            return None;\n+        }\n+        let i = y * self.columns() + x;\n+        let indexer = &(*self as &Index<usize, Output = <Self as Index<usize>>::Output>);\n+        //~^ERROR non-scalar cast\n+        Some(indexer.index(i))\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "749b261e38719a89e481a41f2831678df23d217c", "filename": "src/test/compile-fail/issue-23595-1.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23595-1.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::{Index};\n+\n+trait Hierarchy {\n+    type Value;\n+    type ChildKey;\n+    type Children = Index<Self::ChildKey, Output=Hierarchy>;\n+    //~^ ERROR: the value of the associated type `ChildKey`\n+    //~^^ ERROR: the value of the associated type `Children`\n+    //~^^^ ERROR: the value of the associated type `Value`\n+\n+    fn data(&self) -> Option<(Self::Value, Self::Children)>;\n+}\n+\n+fn main() {}"}, {"sha": "78a3f42f1a6a7cdaa6715fbc437aba784ba76a30", "filename": "src/test/compile-fail/issue-23595-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fissue-23595-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fissue-23595-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23595-2.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct C<AType: A> {a:AType}\n+\n+pub trait A {\n+    type B = C<Self::anything_here_kills_it>;\n+    //~^ ERROR: associated type `anything_here_kills_it` not found for `Self`\n+}\n+\n+fn main() {}"}, {"sha": "c63cb5defb7e30cea6a25099421530257781c20d", "filename": "src/test/compile-fail/issue-26948.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fissue-26948.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fissue-26948.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-26948.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    enum Foo { A { x: u32 } }\n+    let orig = Foo::A { x: 5 };\n+    Foo::A { x: 6, ..orig };\n+    //~^ ERROR functional record update syntax requires a struct\n+}"}, {"sha": "bfda113ae8bc9cd019386740b4a36bacd41ffae1", "filename": "src/test/compile-fail/issue-6702.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fissue-6702.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fissue-6702.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6702.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -14,6 +14,6 @@ struct Monster {\n \n \n fn main() {\n-    let _m = Monster(); //~ ERROR `Monster` is a structure name, but\n+    let _m = Monster(); //~ ERROR `Monster` is a struct variant name, but\n     //~^ HELP did you mean to write: `Monster { /* fields */ }`?\n }"}, {"sha": "815f75266322354be33e7e7d0742778020d17d98", "filename": "src/test/compile-fail/ref-suggestion.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fref-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fcompile-fail%2Fref-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fref-suggestion.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = vec![1];\n+    let y = x;\n+    //~^ HELP use a `ref` binding as shown\n+    //~| SUGGESTION let ref y = x;\n+    x; //~ ERROR use of moved value\n+\n+    let x = vec![1];\n+    let mut y = x;\n+    //~^ HELP use a `ref` binding as shown\n+    //~| SUGGESTION let ref mut y = x;\n+    x; //~ ERROR use of moved value\n+\n+    let x = (Some(vec![1]), ());\n+\n+    match x {\n+        (Some(y), ()) => {},\n+        //~^ HELP use a `ref` binding as shown\n+        //~| SUGGESTION (Some(ref y), ()) => {},\n+        _ => {},\n+    }\n+    x; //~ ERROR use of partially moved value\n+}"}, {"sha": "5dd428119569df494efcd103094388c69f207741", "filename": "src/test/debuginfo/gdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgdb-pretty-struct-and-enums-pre-gdb-7-7.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -8,10 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// This test uses only GDB Python API features which should be available in\n-// older versions of GDB too. A more extensive test can be found in\n-// gdb-pretty-struct-and-enums.rs\n-\n // ignore-bitrig\n // ignore-windows failing on win32 bot\n // ignore-freebsd: gdb package too new"}, {"sha": "c70b059d3e787e1586d323ccfeaeb973fc611173", "filename": "src/test/run-pass/issue-20544.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Frun-pass%2Fissue-20544.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Frun-pass%2Fissue-20544.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20544.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(unboxed_closures)]\n+#![feature(core)]\n+\n+struct Fun<F>(F);\n+\n+impl<F, T> FnOnce<(T,)> for Fun<F> where F: Fn(T) -> T {\n+    type Output = T;\n+\n+    extern \"rust-call\" fn call_once(self, (t,): (T,)) -> T {\n+        (self.0)(t)\n+    }\n+}\n+\n+fn main() {\n+    let fun = Fun(|i: isize| i * 2);\n+    println!(\"{}\", fun(3));\n+}"}, {"sha": "c19f3327fbb41302b9aafa4121c77bba50ec1fc7", "filename": "src/test/run-pass/issue-21140.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Frun-pass%2Fissue-21140.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e9bd6cd26a8f9d11188e39c52aafb4436b09990/src%2Ftest%2Frun-pass%2Fissue-21140.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21140.rs?ref=8e9bd6cd26a8f9d11188e39c52aafb4436b09990", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Trait where Self::Out: std::fmt::Display {\n+    type Out;\n+}\n+\n+fn main() {}"}]}