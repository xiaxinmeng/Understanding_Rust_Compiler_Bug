{"sha": "7308f8f3cfbdaf13613278140d256e85ecc1c84c", "node_id": "C_kwDOAAsO6NoAKDczMDhmOGYzY2ZiZGFmMTM2MTMyNzgxNDBkMjU2ZTg1ZWNjMWM4NGM", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-22T05:24:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-06-22T05:25:09Z"}, "message": "ui_test: fix behavior of only-Nbits comments", "tree": {"sha": "4acec423df7190c6e6b5d2b8e85c322bcbf18435", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4acec423df7190c6e6b5d2b8e85c322bcbf18435"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7308f8f3cfbdaf13613278140d256e85ecc1c84c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7308f8f3cfbdaf13613278140d256e85ecc1c84c", "html_url": "https://github.com/rust-lang/rust/commit/7308f8f3cfbdaf13613278140d256e85ecc1c84c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7308f8f3cfbdaf13613278140d256e85ecc1c84c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a1b08e46eb106480cbb0bc0a70521f273f045aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a1b08e46eb106480cbb0bc0a70521f273f045aa", "html_url": "https://github.com/rust-lang/rust/commit/7a1b08e46eb106480cbb0bc0a70521f273f045aa"}], "stats": {"total": 71, "additions": 43, "deletions": 28}, "files": [{"sha": "d50d6a5345739ce6bcfb80012c02f6e0ad33c7bf", "filename": "ui_test/src/comments.rs", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7308f8f3cfbdaf13613278140d256e85ecc1c84c/ui_test%2Fsrc%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7308f8f3cfbdaf13613278140d256e85ecc1c84c/ui_test%2Fsrc%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Fcomments.rs?ref=7308f8f3cfbdaf13613278140d256e85ecc1c84c", "patch": "@@ -15,9 +15,9 @@ pub(crate) struct Comments {\n     /// List of revision names to execute. Can only be speicified once\n     pub revisions: Option<Vec<String>>,\n     /// Don't run this test if any of these filters apply\n-    pub ignore: Vec<String>,\n+    pub ignore: Vec<Condition>,\n     /// Only run this test if all of these filters apply\n-    pub only: Vec<String>,\n+    pub only: Vec<Condition>,\n     /// Generate one .stderr file per bit width, by prepending with `.64bit` and similar\n     pub stderr_per_bitwidth: bool,\n     /// Additional flags to pass to the executable\n@@ -31,6 +31,16 @@ pub(crate) struct Comments {\n     pub error_matches: Vec<ErrorMatch>,\n }\n \n+\n+/// The conditions used for \"ignore\" and \"only\" filters.\n+#[derive(Debug)]\n+pub(crate) enum Condition {\n+    /// The given string must appear in the target.\n+    Target(String),\n+    /// Tests that the bitwidth is the given one.\n+    Bitwidth(u8),\n+}\n+\n #[derive(Debug)]\n pub(crate) struct ErrorMatch {\n     pub matched: String,\n@@ -42,6 +52,17 @@ pub(crate) struct ErrorMatch {\n     pub line: usize,\n }\n \n+impl Condition {\n+    fn parse(c: &str) -> Self {\n+        if let Some(bits) = c.strip_suffix(\"bit\") {\n+            let bits: u8 = bits.parse().expect(\"ignore/only filter ending in 'bit' must be of the form 'Nbit' for some integer N\");\n+            Condition::Bitwidth(bits)\n+        } else {\n+            Condition::Target(c.to_owned())\n+        }\n+    }\n+}\n+\n impl Comments {\n     pub(crate) fn parse_file(path: &Path) -> Self {\n         let content = std::fs::read_to_string(path).unwrap();\n@@ -75,14 +96,14 @@ impl Comments {\n                     .split_once(|c: char| c == ':' || c.is_whitespace())\n                     .map(|(s, _)| s)\n                     .unwrap_or(s);\n-                this.ignore.push(s.to_owned());\n+                this.ignore.push(Condition::parse(s));\n             }\n             if let Some(s) = line.strip_prefix(\"// only-\") {\n                 let s = s\n                     .split_once(|c: char| c == ':' || c.is_whitespace())\n                     .map(|(s, _)| s)\n                     .unwrap_or(s);\n-                this.only.push(s.to_owned());\n+                this.only.push(Condition::parse(s));\n             }\n             if line.starts_with(\"// stderr-per-bitwidth\") {\n                 assert!("}, {"sha": "9706221446806548bc5f6a505dc79292052e03f5", "filename": "ui_test/src/lib.rs", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/7308f8f3cfbdaf13613278140d256e85ecc1c84c/ui_test%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7308f8f3cfbdaf13613278140d256e85ecc1c84c/ui_test%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ui_test%2Fsrc%2Flib.rs?ref=7308f8f3cfbdaf13613278140d256e85ecc1c84c", "patch": "@@ -10,7 +10,7 @@ use comments::ErrorMatch;\n use regex::Regex;\n use rustc_stderr::{Level, Message};\n \n-use crate::comments::Comments;\n+use crate::comments::{Comments, Condition};\n \n mod comments;\n mod rustc_stderr;\n@@ -103,7 +103,7 @@ pub fn run_tests(config: Config) {\n                     }\n                     let comments = Comments::parse_file(&path);\n                     // Ignore file if only/ignore rules do (not) apply\n-                    if ignore_file(&comments, &target) {\n+                    if !test_file_conditions(&comments, &target) {\n                         ignored.fetch_add(1, Ordering::Relaxed);\n                         eprintln!(\n                             \"{} ... {}\",\n@@ -509,42 +509,36 @@ fn check_output(\n \n fn output_path(path: &Path, comments: &Comments, kind: String, target: &str) -> PathBuf {\n     if comments.stderr_per_bitwidth {\n-        return path.with_extension(format!(\"{}.{kind}\", get_pointer_width(target)));\n+        return path.with_extension(format!(\"{}bit.{kind}\", get_pointer_width(target)));\n     }\n     path.with_extension(kind)\n }\n \n-fn ignore_file(comments: &Comments, target: &str) -> bool {\n-    for s in &comments.ignore {\n-        if target.contains(s) {\n-            return true;\n-        }\n-        if get_pointer_width(target) == s {\n-            return true;\n-        }\n+fn test_condition(condition: &Condition, target: &str) -> bool {\n+    match condition {\n+        Condition::Bitwidth(bits) => get_pointer_width(target) == *bits,\n+        Condition::Target(t) => target.contains(t),\n     }\n-    for s in &comments.only {\n-        if !target.contains(s) {\n-            return true;\n-        }\n-        /* FIXME(https://github.com/rust-lang/miri/issues/2206)\n-        if get_pointer_width(target) != s {\n-            return true;\n-        } */\n+}\n+\n+/// Returns whether according to the in-file conditions, this file should be run.\n+fn test_file_conditions(comments: &Comments, target: &str) -> bool {\n+    if comments.ignore.iter().any(|c| test_condition(c, target)) {\n+        return false;\n     }\n-    false\n+    comments.only.iter().all(|c| test_condition(c, target))\n }\n \n // Taken 1:1 from compiletest-rs\n-fn get_pointer_width(triple: &str) -> &'static str {\n+fn get_pointer_width(triple: &str) -> u8 {\n     if (triple.contains(\"64\") && !triple.ends_with(\"gnux32\") && !triple.ends_with(\"gnu_ilp32\"))\n         || triple.starts_with(\"s390x\")\n     {\n-        \"64bit\"\n+        64\n     } else if triple.starts_with(\"avr\") {\n-        \"16bit\"\n+        16\n     } else {\n-        \"32bit\"\n+        32\n     }\n }\n "}]}