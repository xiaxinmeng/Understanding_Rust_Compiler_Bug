{"sha": "48dc0ba307abe4e0abdc16db7ebc5915bf813f01", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4ZGMwYmEzMDdhYmU0ZTBhYmRjMTZkYjdlYmM1OTE1YmY4MTNmMDE=", "commit": {"author": {"name": "ggomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-09-09T14:07:44Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-09-11T09:58:20Z"}, "message": "Improve Copy trait doc", "tree": {"sha": "f80a4554539090c514db681f9158ec02dbc2e463", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f80a4554539090c514db681f9158ec02dbc2e463"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/48dc0ba307abe4e0abdc16db7ebc5915bf813f01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/48dc0ba307abe4e0abdc16db7ebc5915bf813f01", "html_url": "https://github.com/rust-lang/rust/commit/48dc0ba307abe4e0abdc16db7ebc5915bf813f01", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/48dc0ba307abe4e0abdc16db7ebc5915bf813f01/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d289278ee123a67827c2b8bbff053d904d7373a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d289278ee123a67827c2b8bbff053d904d7373a", "html_url": "https://github.com/rust-lang/rust/commit/3d289278ee123a67827c2b8bbff053d904d7373a"}], "stats": {"total": 51, "additions": 35, "deletions": 16}, "files": [{"sha": "c22c9f0d1c717fbd4ed03d693d0cd27d7055d19c", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/48dc0ba307abe4e0abdc16db7ebc5915bf813f01/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48dc0ba307abe4e0abdc16db7ebc5915bf813f01/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=48dc0ba307abe4e0abdc16db7ebc5915bf813f01", "patch": "@@ -126,7 +126,7 @@ pub trait Unsize<T: ?Sized> {\n /// }\n /// ```\n ///\n-/// The `PointList` `struct` cannot implement `Copy`, because `Vec<T>` is not `Copy`. If we\n+/// The `PointList` `struct` cannot implement `Copy`, because [`Vec<T>`] is not `Copy`. If we\n /// attempt to derive a `Copy` implementation, we'll get an error:\n ///\n /// ```text\n@@ -136,10 +136,10 @@ pub trait Unsize<T: ?Sized> {\n /// ## When can my type _not_ be `Copy`?\n ///\n /// Some types can't be copied safely. For example, copying `&mut T` would create an aliased\n-/// mutable reference, and copying `String` would result in two attempts to free the same buffer.\n+/// mutable reference, and copying [`String`] would result in two attempts to free the same buffer.\n ///\n-/// Generalizing the latter case, any type implementing `Drop` can't be `Copy`, because it's\n-/// managing some resource besides its own `size_of::<T>()` bytes.\n+/// Generalizing the latter case, any type implementing [`Drop`] can't be `Copy`, because it's\n+/// managing some resource besides its own [`size_of::<T>()`] bytes.\n ///\n /// ## What if I derive `Copy` on a type that can't?\n ///\n@@ -156,8 +156,7 @@ pub trait Unsize<T: ?Sized> {\n ///\n /// ## Derivable\n ///\n-/// This trait can be used with `#[derive]` if all of its components implement `Copy` and the type\n-/// implements `Clone`. The implementation will copy the bytes of each field using `memcpy`.\n+/// This trait can be used with `#[derive]` if all of its components implement `Copy` and the type.\n ///\n /// ## How can I implement `Copy`?\n ///\n@@ -178,6 +177,11 @@ pub trait Unsize<T: ?Sized> {\n ///\n /// There is a small difference between the two: the `derive` strategy will also place a `Copy`\n /// bound on type parameters, which isn't always desired.\n+///\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`Drop`]: ../../std/ops/trait.Drop.html\n+/// [`size_of::<T>()`]: ../../std/mem/fn.size_of.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"copy\"]\n pub trait Copy : Clone {\n@@ -190,11 +194,11 @@ pub trait Copy : Clone {\n /// thread-safe. In other words, there is no possibility of data races\n /// when passing `&T` references between threads.\n ///\n-/// As one would expect, primitive types like `u8` and `f64` are all\n+/// As one would expect, primitive types like [`u8`] and [`f64`] are all\n /// `Sync`, and so are simple aggregate types containing them (like\n /// tuples, structs and enums). More instances of basic `Sync` types\n /// include \"immutable\" types like `&T` and those with simple\n-/// inherited mutability, such as `Box<T>`, `Vec<T>` and most other\n+/// inherited mutability, such as [`Box<T>`], [`Vec<T>`] and most other\n /// collection types. (Generic parameters need to be `Sync` for their\n /// container to be `Sync`.)\n ///\n@@ -206,27 +210,42 @@ pub trait Copy : Clone {\n /// race.\n ///\n /// Types that are not `Sync` are those that have \"interior\n-/// mutability\" in a non-thread-safe way, such as `Cell` and `RefCell`\n-/// in `std::cell`. These types allow for mutation of their contents\n+/// mutability\" in a non-thread-safe way, such as [`Cell`] and [`RefCell`]\n+/// in [`std::cell`]. These types allow for mutation of their contents\n /// even when in an immutable, aliasable slot, e.g. the contents of\n-/// `&Cell<T>` can be `.set`, and do not ensure data races are\n+/// [`&Cell<T>`][`Cell`] can be [`.set`], and do not ensure data races are\n /// impossible, hence they cannot be `Sync`. A higher level example\n /// of a non-`Sync` type is the reference counted pointer\n-/// `std::rc::Rc`, because any reference `&Rc<T>` can clone a new\n+/// [`std::rc::Rc`][`Rc`], because any reference [`&Rc<T>`][`Rc`] can clone a new\n /// reference, which modifies the reference counts in a non-atomic\n /// way.\n ///\n /// For cases when one does need thread-safe interior mutability,\n-/// types like the atomics in `std::sync` and `Mutex` & `RWLock` in\n-/// the `sync` crate do ensure that any mutation cannot cause data\n+/// types like the atomics in [`std::sync`][`sync`] and [`Mutex`] / [`RwLock`] in\n+/// the [`sync`] crate do ensure that any mutation cannot cause data\n /// races.  Hence these types are `Sync`.\n ///\n-/// Any types with interior mutability must also use the `std::cell::UnsafeCell`\n+/// Any types with interior mutability must also use the [`std::cell::UnsafeCell`]\n /// wrapper around the value(s) which can be mutated when behind a `&`\n /// reference; not doing this is undefined behavior (for example,\n-/// `transmute`-ing from `&T` to `&mut T` is invalid).\n+/// [`transmute`]-ing from `&T` to `&mut T` is invalid).\n ///\n /// This trait is automatically derived when the compiler determines it's appropriate.\n+///\n+/// [`u8`]: ../../std/primitive.u8.html\n+/// [`f64`]: ../../std/primitive.f64.html\n+/// [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+/// [`Box<T>`]: ../../std/boxed/struct.Box.html\n+/// [`Cell`]: ../../std/cell/struct.Cell.html\n+/// [`RefCell`]: ../../std/cell/struct.RefCell.html\n+/// [`std::cell`]: ../../std/cell/index.html\n+/// [`.set`]: ../../std/cell/struct.Cell.html#method.set\n+/// [`Rc`]: ../../std/rc/struct.Rc.html\n+/// [`sync`]: ../../std/sync/index.html\n+/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n+/// [`RwLock`]: ../../std/sync/struct.RwLock.html\n+/// [`std::cell::UnsafeCell`]: ../../std/cell/struct.UnsafeCell.html\n+/// [`transmute`]: ../../std/mem/fn.transmute.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[lang = \"sync\"]\n #[rustc_on_unimplemented = \"`{Self}` cannot be shared between threads safely\"]"}]}