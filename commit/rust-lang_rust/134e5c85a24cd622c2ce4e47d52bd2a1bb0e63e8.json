{"sha": "134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzNGU1Yzg1YTI0Y2Q2MjJjMmNlNGU0N2Q1MmJkMmExYmIwZTYzZTg=", "commit": {"author": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-08-31T23:41:15Z"}, "committer": {"name": "Kevin Cantu", "email": "me@kevincantu.org", "date": "2012-09-01T20:08:20Z"}, "message": "Demode sort.rs", "tree": {"sha": "4dea976727212fafd3e5ee3f7eaad9ae8451547c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4dea976727212fafd3e5ee3f7eaad9ae8451547c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8", "html_url": "https://github.com/rust-lang/rust/commit/134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8/comments", "author": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "killerswan", "id": 195060, "node_id": "MDQ6VXNlcjE5NTA2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/195060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/killerswan", "html_url": "https://github.com/killerswan", "followers_url": "https://api.github.com/users/killerswan/followers", "following_url": "https://api.github.com/users/killerswan/following{/other_user}", "gists_url": "https://api.github.com/users/killerswan/gists{/gist_id}", "starred_url": "https://api.github.com/users/killerswan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/killerswan/subscriptions", "organizations_url": "https://api.github.com/users/killerswan/orgs", "repos_url": "https://api.github.com/users/killerswan/repos", "events_url": "https://api.github.com/users/killerswan/events{/privacy}", "received_events_url": "https://api.github.com/users/killerswan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b06599a7a8001914d64ec191a073684362f5b9b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b06599a7a8001914d64ec191a073684362f5b9b2", "html_url": "https://github.com/rust-lang/rust/commit/b06599a7a8001914d64ec191a073684362f5b9b2"}], "stats": {"total": 28, "additions": 16, "deletions": 12}, "files": [{"sha": "17a448001bd5ce35ecc33c5e313547f61022297d", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8", "patch": "@@ -1499,7 +1499,8 @@ fn print_pkg(s: source, p: package) {\n fn print_source(s: source) {\n     info(s.name + ~\" (\" + s.url + ~\")\");\n \n-    let pks = sort::merge_sort(sys::shape_lt, copy s.packages);\n+    let unsorted_pks = s.packages;  // to prevent illegal borrow?\n+    let pks = sort::merge_sort(sys::shape_lt, unsorted_pks);\n     let l = vec::len(pks);\n \n     print(io::with_str_writer(|writer| {"}, {"sha": "07552a0a94f859d7910ee41ac92ae6818b36da1b", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=134e5c85a24cd622c2ce4e47d52bd2a1bb0e63e8", "patch": "@@ -1,4 +1,7 @@\n //! Sorting methods\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n import vec::{len, push};\n import core::cmp::{Eq, Ord};\n \n@@ -15,12 +18,12 @@ type le<T> = pure fn(v1: &T, v2: &T) -> bool;\n  * Has worst case O(n log n) performance, best case O(n), but\n  * is not space efficient. This is a stable sort.\n  */\n-fn merge_sort<T: copy>(le: le<T>, v: ~[const T]) -> ~[T] {\n+fn merge_sort<T: copy>(le: le<T>, v: &[const T]) -> ~[T] {\n     type slice = (uint, uint);\n \n     return merge_sort_(le, v, (0u, len(v)));\n \n-    fn merge_sort_<T: copy>(le: le<T>, v: ~[const T], slice: slice)\n+    fn merge_sort_<T: copy>(le: le<T>, v: &[const T], slice: slice)\n         -> ~[T] {\n         let begin = slice.first();\n         let end = slice.second();\n@@ -35,7 +38,7 @@ fn merge_sort<T: copy>(le: le<T>, v: ~[const T]) -> ~[T] {\n         return merge(le, merge_sort_(le, v, a), merge_sort_(le, v, b));\n     }\n \n-    fn merge<T: copy>(le: le<T>, a: ~[T], b: ~[T]) -> ~[T] {\n+    fn merge<T: copy>(le: le<T>, a: &[T], b: &[T]) -> ~[T] {\n         let mut rs = ~[];\n         vec::reserve(rs, len(a) + len(b));\n         let a_len = len(a);\n@@ -54,7 +57,7 @@ fn merge_sort<T: copy>(le: le<T>, v: ~[const T]) -> ~[T] {\n     }\n }\n \n-fn part<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n+fn part<T: copy>(compare_func: le<T>, arr: &[mut T], left: uint,\n                 right: uint, pivot: uint) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n@@ -71,7 +74,7 @@ fn part<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n     return storage_index;\n }\n \n-fn qsort<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n+fn qsort<T: copy>(compare_func: le<T>, arr: &[mut T], left: uint,\n              right: uint) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -90,12 +93,12 @@ fn qsort<T: copy>(compare_func: le<T>, arr: ~[mut T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-fn quick_sort<T: copy>(compare_func: le<T>, arr: ~[mut T]) {\n+fn quick_sort<T: copy>(compare_func: le<T>, arr: &[mut T]) {\n     if len::<T>(arr) == 0u { return; }\n     qsort::<T>(compare_func, arr, 0u, len::<T>(arr) - 1u);\n }\n \n-fn qsort3<T: copy Ord Eq>(arr: ~[mut T], left: int, right: int) {\n+fn qsort3<T: copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n     if right <= left { return; }\n     let v: T = arr[right];\n     let mut i: int = left - 1;\n@@ -152,14 +155,14 @@ fn qsort3<T: copy Ord Eq>(arr: ~[mut T], left: int, right: int) {\n  *\n  * This is an unstable sort.\n  */\n-fn quick_sort3<T: copy Ord Eq>(arr: ~[mut T]) {\n+fn quick_sort3<T: copy Ord Eq>(arr: &[mut T]) {\n     if arr.len() <= 1 { return; }\n     qsort3(arr, 0, (arr.len() - 1) as int);\n }\n \n #[cfg(test)]\n mod test_qsort3 {\n-    fn check_sort(v1: ~[mut int], v2: ~[mut int]) {\n+    fn check_sort(v1: &[mut int], v2: &[mut int]) {\n         let len = vec::len::<int>(v1);\n         quick_sort3::<int>(v1);\n         let mut i = 0u;\n@@ -198,7 +201,7 @@ mod test_qsort3 {\n \n #[cfg(test)]\n mod test_qsort {\n-    fn check_sort(v1: ~[mut int], v2: ~[mut int]) {\n+    fn check_sort(v1: &[mut int], v2: &[mut int]) {\n         let len = vec::len::<int>(v1);\n         pure fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(leual, v1);\n@@ -258,7 +261,7 @@ mod test_qsort {\n #[cfg(test)]\n mod tests {\n \n-    fn check_sort(v1: ~[int], v2: ~[int]) {\n+    fn check_sort(v1: &[int], v2: &[int]) {\n         let len = vec::len::<int>(v1);\n         pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n         let f = le;"}]}