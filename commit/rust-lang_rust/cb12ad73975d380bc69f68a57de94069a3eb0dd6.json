{"sha": "cb12ad73975d380bc69f68a57de94069a3eb0dd6", "node_id": "C_kwDOAAsO6NoAKGNiMTJhZDczOTc1ZDM4MGJjNjlmNjhhNTdkZTk0MDY5YTNlYjBkZDY", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-02-18T18:17:43Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-02-18T18:17:43Z"}, "message": "Merge pull request #1359 from bjorn3/fix_llvm14-builtins-abi\n\nFix compiler-builtins 0.1.87 on Windows", "tree": {"sha": "44a5753b19839af18ae605565178286ed5920026", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44a5753b19839af18ae605565178286ed5920026"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb12ad73975d380bc69f68a57de94069a3eb0dd6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJj8RZHCRBK7hj4Ov3rIwAABecIAEyWnnQWB4sclpBe3vqcbkP1\nnlnFktMmWvxYWC6RlimLbZXXM6/j0it2AKAZQrzPPdkQiCdyN/z8mQgt/jR/zaJN\nz8u3QtI5MPdi38dtn1EqLuFF+Jb1LNQNmM0YASKgQAMkAcvnLrAcGpf35BFB2DLh\nSOhgfPsOB22EZbjPa9rh4dNE9CTIQ+hBlPwdheNavvTx/h/VNkmuPIrdxBd9qMYh\noT4YQq7oFAy68MESXfP1Ntr0VszdKc71l+IPIf8PG5qTZtD5aqYt/RpOuE4r3NYR\nMXUbTIjbVc/r4hHTJjoZTqCjshw1Oxs6cBRAo932k3ohXpZqtcUbcpyRWv6JTHM=\n=3lA4\n-----END PGP SIGNATURE-----\n", "payload": "tree 44a5753b19839af18ae605565178286ed5920026\nparent 718574a53e1262c7370106ec606c8fabe0fb6a23\nparent bb933d26dc722315d07d0f048e4185f40d94db8c\nauthor bjorn3 <17426603+bjorn3@users.noreply.github.com> 1676744263 +0100\ncommitter GitHub <noreply@github.com> 1676744263 +0100\n\nMerge pull request #1359 from bjorn3/fix_llvm14-builtins-abi\n\nFix compiler-builtins 0.1.87 on Windows"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb12ad73975d380bc69f68a57de94069a3eb0dd6", "html_url": "https://github.com/rust-lang/rust/commit/cb12ad73975d380bc69f68a57de94069a3eb0dd6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb12ad73975d380bc69f68a57de94069a3eb0dd6/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "718574a53e1262c7370106ec606c8fabe0fb6a23", "url": "https://api.github.com/repos/rust-lang/rust/commits/718574a53e1262c7370106ec606c8fabe0fb6a23", "html_url": "https://github.com/rust-lang/rust/commit/718574a53e1262c7370106ec606c8fabe0fb6a23"}, {"sha": "bb933d26dc722315d07d0f048e4185f40d94db8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bb933d26dc722315d07d0f048e4185f40d94db8c", "html_url": "https://github.com/rust-lang/rust/commit/bb933d26dc722315d07d0f048e4185f40d94db8c"}], "stats": {"total": 389, "additions": 185, "deletions": 204}, "files": [{"sha": "3f9b374be23fa647f9a0f47b2803b3ff6dc9dfcc", "filename": "build_sysroot/Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb12ad73975d380bc69f68a57de94069a3eb0dd6/build_sysroot%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/cb12ad73975d380bc69f68a57de94069a3eb0dd6/build_sysroot%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.lock?ref=cb12ad73975d380bc69f68a57de94069a3eb0dd6", "patch": "@@ -50,9 +50,9 @@ dependencies = [\n \n [[package]]\n name = \"compiler_builtins\"\n-version = \"0.1.86\"\n+version = \"0.1.87\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5dae98c88e576098d7ab13ebcb40cc43e5114b2beafe61a87cda9200649ff205\"\n+checksum = \"f867ce54c09855ccd135ad4a50c777182a0c7af5ff20a8f537617bd648b10d50\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "8219e6b6ccf3bca19d613a2b7331639a30a8d7e1", "filename": "build_sysroot/Cargo.toml", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb12ad73975d380bc69f68a57de94069a3eb0dd6/build_sysroot%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/cb12ad73975d380bc69f68a57de94069a3eb0dd6/build_sysroot%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/build_sysroot%2FCargo.toml?ref=cb12ad73975d380bc69f68a57de94069a3eb0dd6", "patch": "@@ -8,8 +8,7 @@ alloc = { path = \"./sysroot_src/library/alloc\" }\n std = { path = \"./sysroot_src/library/std\", features = [\"panic_unwind\", \"backtrace\"] }\n test = { path = \"./sysroot_src/library/test\" }\n \n-# FIXME allow 0.1.87 and later once #1353 is fixed\n-compiler_builtins = { version = \"=0.1.86\", default-features = false, features = [\"no-asm\"] }\n+compiler_builtins = { version = \"0.1.87\", default-features = false, features = [\"no-asm\"] }\n \n [patch.crates-io]\n rustc-std-workspace-core = { path = \"./sysroot_src/library/rustc-std-workspace-core\" }"}, {"sha": "e34b35d5c4a8c481253e4b51764fdaaf72babc79", "filename": "example/std_example.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb12ad73975d380bc69f68a57de94069a3eb0dd6/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb12ad73975d380bc69f68a57de94069a3eb0dd6/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=cb12ad73975d380bc69f68a57de94069a3eb0dd6", "patch": "@@ -58,8 +58,9 @@ fn main() {\n     assert_eq!(0b0000000000000000000000000010000000000000000000000000000000000000_0000000000000000000000000000000000001000000000000000000010000000u128.trailing_zeros(), 7);\n     assert_eq!(core::intrinsics::saturating_sub(0, -170141183460469231731687303715884105728i128), 170141183460469231731687303715884105727i128);\n \n-    let _d = 0i128.checked_div(2i128);\n-    let _d = 0u128.checked_div(2u128);\n+    std::hint::black_box(std::hint::black_box(7571400400375753350092698930310845914i128) * 10);\n+    assert!(0i128.checked_div(2i128).is_some());\n+    assert!(0u128.checked_div(2u128).is_some());\n     assert_eq!(1u128 + 2, 3);\n \n     assert_eq!(0b100010000000000000000000000000000u128 >> 10, 0b10001000000000000000000u128);"}, {"sha": "c5fa6aaec2bd06f56b64bbb2a281c22e3b537552", "filename": "patches/0029-sysroot-Downgrade-compiler-builtins-to-0.1.86.patch", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/718574a53e1262c7370106ec606c8fabe0fb6a23/patches%2F0029-sysroot-Downgrade-compiler-builtins-to-0.1.86.patch", "raw_url": "https://github.com/rust-lang/rust/raw/718574a53e1262c7370106ec606c8fabe0fb6a23/patches%2F0029-sysroot-Downgrade-compiler-builtins-to-0.1.86.patch", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/patches%2F0029-sysroot-Downgrade-compiler-builtins-to-0.1.86.patch?ref=718574a53e1262c7370106ec606c8fabe0fb6a23", "patch": "@@ -1,26 +0,0 @@\n-From ff23f6113098987318b674088b924e22750be18c Mon Sep 17 00:00:00 2001\n-From: bjorn3 <17426603+bjorn3@users.noreply.github.com>\n-Date: Fri, 17 Feb 2023 18:37:48 +0100\n-Subject: [PATCH] Downgrade compiler-builtins to 0.1.86\n-\n-0.1.87 doesn't work on Windows when using cg_clif\n----\n- library/std/Cargo.toml | 2 +-\n- 1 file changed, 1 insertion(+), 1 deletion(-)\n-\n-diff --git a/library/std/Cargo.toml b/library/std/Cargo.toml\n-index 349cd91..300f812 100644\n---- a/library/std/Cargo.toml\n-+++ b/library/std/Cargo.toml\n-@@ -16,7 +16,7 @@ panic_unwind = { path = \"../panic_unwind\", optional = true }\n- panic_abort = { path = \"../panic_abort\" }\n- core = { path = \"../core\" }\n- libc = { version = \"0.2.138\", default-features = false, features = ['rustc-dep-of-std'] }\n--compiler_builtins = { version = \"0.1.87\" }\n-+compiler_builtins = { version = \"0.1.86\" }\n- profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n- unwind = { path = \"../unwind\" }\n- hashbrown = { version = \"0.12\", default-features = false, features = ['rustc-dep-of-std'] }\n--- \n-2.26.2.7.g19db9cfb68\n-"}, {"sha": "a713fd6814fbfa96ec26fd8ae59e3c257ebd5594", "filename": "src/abi/mod.rs", "status": "modified", "additions": 50, "deletions": 33, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=cb12ad73975d380bc69f68a57de94069a3eb0dd6", "patch": "@@ -4,6 +4,8 @@ mod comments;\n mod pass_mode;\n mod returning;\n \n+use std::borrow::Cow;\n+\n use cranelift_module::ModuleError;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::ty::layout::FnAbiOf;\n@@ -116,7 +118,52 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         params: Vec<AbiParam>,\n         returns: Vec<AbiParam>,\n         args: &[Value],\n-    ) -> &[Value] {\n+    ) -> Cow<'_, [Value]> {\n+        if self.tcx.sess.target.is_like_windows {\n+            let (mut params, mut args): (Vec<_>, Vec<_>) =\n+                params\n+                    .into_iter()\n+                    .zip(args)\n+                    .map(|(param, &arg)| {\n+                        if param.value_type == types::I128 {\n+                            let arg_ptr = Pointer::stack_slot(self.bcx.create_sized_stack_slot(\n+                                StackSlotData { kind: StackSlotKind::ExplicitSlot, size: 16 },\n+                            ));\n+                            arg_ptr.store(self, arg, MemFlags::trusted());\n+                            (AbiParam::new(self.pointer_type), arg_ptr.get_addr(self))\n+                        } else {\n+                            (param, arg)\n+                        }\n+                    })\n+                    .unzip();\n+\n+            let indirect_ret_val = returns.len() == 1 && returns[0].value_type == types::I128;\n+\n+            if indirect_ret_val {\n+                params.insert(0, AbiParam::new(self.pointer_type));\n+                let ret_ptr =\n+                    Pointer::stack_slot(self.bcx.create_sized_stack_slot(StackSlotData {\n+                        kind: StackSlotKind::ExplicitSlot,\n+                        size: 16,\n+                    }));\n+                args.insert(0, ret_ptr.get_addr(self));\n+                self.lib_call_unadjusted(name, params, vec![], &args);\n+                return Cow::Owned(vec![ret_ptr.load(self, types::I128, MemFlags::trusted())]);\n+            } else {\n+                return self.lib_call_unadjusted(name, params, returns, &args);\n+            }\n+        }\n+\n+        self.lib_call_unadjusted(name, params, returns, args)\n+    }\n+\n+    pub(crate) fn lib_call_unadjusted(\n+        &mut self,\n+        name: &str,\n+        params: Vec<AbiParam>,\n+        returns: Vec<AbiParam>,\n+        args: &[Value],\n+    ) -> Cow<'_, [Value]> {\n         let sig = Signature { params, returns, call_conv: self.target_config.default_call_conv };\n         let func_id = self.module.declare_function(name, Linkage::Import, &sig).unwrap();\n         let func_ref = self.module.declare_func_in_func(func_id, &mut self.bcx.func);\n@@ -125,41 +172,11 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         }\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         if self.clif_comments.enabled() {\n-            self.add_comment(call_inst, format!(\"easy_call {}\", name));\n+            self.add_comment(call_inst, format!(\"lib_call {}\", name));\n         }\n         let results = self.bcx.inst_results(call_inst);\n         assert!(results.len() <= 2, \"{}\", results.len());\n-        results\n-    }\n-\n-    pub(crate) fn easy_call(\n-        &mut self,\n-        name: &str,\n-        args: &[CValue<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    ) -> CValue<'tcx> {\n-        let (input_tys, args): (Vec<_>, Vec<_>) = args\n-            .iter()\n-            .map(|arg| {\n-                (AbiParam::new(self.clif_type(arg.layout().ty).unwrap()), arg.load_scalar(self))\n-            })\n-            .unzip();\n-        let return_layout = self.layout_of(return_ty);\n-        let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.iter().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n-        } else {\n-            vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n-        };\n-        let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n-        match *ret_vals {\n-            [] => CValue::by_ref(\n-                Pointer::const_addr(self, i64::from(self.pointer_type.bytes())),\n-                return_layout,\n-            ),\n-            [val] => CValue::by_val(val, return_layout),\n-            [val, extra] => CValue::by_val_pair(val, extra, return_layout),\n-            _ => unreachable!(),\n-        }\n+        Cow::Borrowed(results)\n     }\n }\n "}, {"sha": "032d1151041dbb45b28442075d464a7edae1bb6f", "filename": "src/cast.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=cb12ad73975d380bc69f68a57de94069a3eb0dd6", "patch": "@@ -64,17 +64,12 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = if from_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-\n-            let to_rust_ty = match to_ty {\n-                types::F32 => fx.tcx.types.f32,\n-                types::F64 => fx.tcx.types.f64,\n-                _ => unreachable!(),\n-            };\n-\n-            return fx\n-                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n-                .load_scalar(fx);\n+            return fx.lib_call(\n+                &name,\n+                vec![AbiParam::new(types::I128)],\n+                vec![AbiParam::new(to_ty)],\n+                &[from],\n+            )[0];\n         }\n \n         // int-like -> float\n@@ -101,16 +96,29 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = match from_ty {\n-                types::F32 => fx.tcx.types.f32,\n-                types::F64 => fx.tcx.types.f64,\n-                _ => unreachable!(),\n-            };\n-\n-            let to_rust_ty = if to_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-\n-            fx.easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n-                .load_scalar(fx)\n+            if fx.tcx.sess.target.is_like_windows {\n+                let ret = fx.lib_call(\n+                    &name,\n+                    vec![AbiParam::new(from_ty)],\n+                    vec![AbiParam::new(types::I64X2)],\n+                    &[from],\n+                )[0];\n+                // FIXME use bitcast instead of store to get from i64x2 to i128\n+                let stack_slot = fx.bcx.create_sized_stack_slot(StackSlotData {\n+                    kind: StackSlotKind::ExplicitSlot,\n+                    size: 16,\n+                });\n+                let ret_ptr = Pointer::stack_slot(stack_slot);\n+                ret_ptr.store(fx, ret, MemFlags::trusted());\n+                ret_ptr.load(fx, types::I128, MemFlags::trusted())\n+            } else {\n+                fx.lib_call(\n+                    &name,\n+                    vec![AbiParam::new(from_ty)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &[from],\n+                )[0]\n+            }\n         } else if to_ty == types::I8 || to_ty == types::I16 {\n             // FIXME implement fcvt_to_*int_sat.i8/i16\n             let val = if to_signed {"}, {"sha": "cb048c0ad45bc057da8ac82b2a98a5c462f5ada5", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 28, "deletions": 57, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=cb12ad73975d380bc69f68a57de94069a3eb0dd6", "patch": "@@ -29,39 +29,24 @@ pub(crate) fn maybe_codegen<'tcx>(\n         BinOp::Add | BinOp::Sub if !checked => None,\n         BinOp::Mul if !checked || is_signed => {\n             if !checked {\n-                let val_ty = if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-                if fx.tcx.sess.target.is_like_windows {\n-                    let ret_place = CPlace::new_stack_slot(fx, lhs.layout());\n-                    let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                    let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                    assert!(lhs_extra.is_none());\n-                    assert!(rhs_extra.is_none());\n-                    let args = [\n-                        ret_place.to_ptr().get_addr(fx),\n-                        lhs_ptr.get_addr(fx),\n-                        rhs_ptr.get_addr(fx),\n-                    ];\n-                    fx.lib_call(\n-                        \"__multi3\",\n-                        vec![\n-                            AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                            AbiParam::new(fx.pointer_type),\n-                            AbiParam::new(fx.pointer_type),\n-                        ],\n-                        vec![],\n-                        &args,\n-                    );\n-                    Some(ret_place.to_cvalue(fx))\n-                } else {\n-                    Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n-                }\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let ret_val = fx.lib_call(\n+                    \"__multi3\",\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &args,\n+                )[0];\n+                Some(CValue::by_val(\n+                    ret_val,\n+                    fx.layout_of(if is_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 }),\n+                ))\n             } else {\n                 let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n                 let oflow = CPlace::new_stack_slot(fx, fx.layout_of(fx.tcx.types.i32));\n                 let lhs = lhs.load_scalar(fx);\n                 let rhs = rhs.load_scalar(fx);\n                 let oflow_ptr = oflow.to_ptr().get_addr(fx);\n-                let res = fx.lib_call(\n+                let res = fx.lib_call_unadjusted(\n                     \"__muloti4\",\n                     vec![\n                         AbiParam::new(types::I128),\n@@ -80,29 +65,12 @@ pub(crate) fn maybe_codegen<'tcx>(\n             assert!(checked);\n             let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n             let out_place = CPlace::new_stack_slot(fx, fx.layout_of(out_ty));\n-            let (param_types, args) = if fx.tcx.sess.target.is_like_windows {\n-                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                assert!(lhs_extra.is_none());\n-                assert!(rhs_extra.is_none());\n-                (\n-                    vec![\n-                        AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                        AbiParam::new(fx.pointer_type),\n-                        AbiParam::new(fx.pointer_type),\n-                    ],\n-                    [out_place.to_ptr().get_addr(fx), lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)],\n-                )\n-            } else {\n-                (\n-                    vec![\n-                        AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n-                        AbiParam::new(types::I128),\n-                        AbiParam::new(types::I128),\n-                    ],\n-                    [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)],\n-                )\n-            };\n+            let param_types = vec![\n+                AbiParam::special(fx.pointer_type, ArgumentPurpose::StructReturn),\n+                AbiParam::new(types::I128),\n+                AbiParam::new(types::I128),\n+            ];\n+            let args = [out_place.to_ptr().get_addr(fx), lhs.load_scalar(fx), rhs.load_scalar(fx)];\n             let name = match (bin_op, is_signed) {\n                 (BinOp::Add, false) => \"__rust_u128_addo\",\n                 (BinOp::Add, true) => \"__rust_i128_addo\",\n@@ -125,14 +93,10 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 _ => unreachable!(),\n             };\n             if fx.tcx.sess.target.is_like_windows {\n-                let (lhs_ptr, lhs_extra) = lhs.force_stack(fx);\n-                let (rhs_ptr, rhs_extra) = rhs.force_stack(fx);\n-                assert!(lhs_extra.is_none());\n-                assert!(rhs_extra.is_none());\n-                let args = [lhs_ptr.get_addr(fx), rhs_ptr.get_addr(fx)];\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n                 let ret = fx.lib_call(\n                     name,\n-                    vec![AbiParam::new(fx.pointer_type), AbiParam::new(fx.pointer_type)],\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n                     vec![AbiParam::new(types::I64X2)],\n                     &args,\n                 )[0];\n@@ -141,7 +105,14 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 ret_place.to_ptr().store(fx, ret, MemFlags::trusted());\n                 Some(ret_place.to_cvalue(fx))\n             } else {\n-                Some(fx.easy_call(name, &[lhs, rhs], lhs.layout().ty))\n+                let args = [lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let ret_val = fx.lib_call(\n+                    name,\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &args,\n+                )[0];\n+                Some(CValue::by_val(ret_val, lhs.layout()))\n             }\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {"}, {"sha": "f3b963200a0fb022f34bc48a2307b9c114830ace", "filename": "src/compiler_builtins.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fcompiler_builtins.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fcompiler_builtins.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler_builtins.rs?ref=cb12ad73975d380bc69f68a57de94069a3eb0dd6", "patch": "@@ -39,6 +39,7 @@ builtin_functions! {\n \n     // integers\n     fn __multi3(a: i128, b: i128) -> i128;\n+    fn __muloti4(n: i128, d: i128, oflow: &mut i32) -> i128;\n     fn __udivti3(n: u128, d: u128) -> u128;\n     fn __divti3(n: i128, d: i128) -> i128;\n     fn __umodti3(n: u128, d: u128) -> u128;"}, {"sha": "b369edee8da1b471b76bd19bbcd3f2b53b66bb93", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=cb12ad73975d380bc69f68a57de94069a3eb0dd6", "patch": "@@ -251,41 +251,41 @@ fn codegen_float_intrinsic_call<'tcx>(\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n ) -> bool {\n-    let (name, arg_count, ty) = match intrinsic {\n-        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32),\n-        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64),\n-        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32),\n-        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64),\n-        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32),\n-        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64),\n-        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32), // compiler-builtins\n-        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64), // compiler-builtins\n-        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32),\n-        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64),\n-        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32),\n-        sym::logf64 => (\"log\", 1, fx.tcx.types.f64),\n-        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32),\n-        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64),\n-        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32),\n-        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64),\n-        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32),\n-        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64),\n-        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32),\n-        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64),\n-        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32),\n-        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64),\n-        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32),\n-        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64),\n-        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32),\n-        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64),\n-        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32),\n-        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64),\n-        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32),\n-        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64),\n-        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32),\n-        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64),\n-        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32),\n-        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64),\n+    let (name, arg_count, ty, clif_ty) = match intrinsic {\n+        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64, types::F64),\n+        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64, types::F64),\n+        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64, types::F64),\n+        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32, types::F32), // compiler-builtins\n+        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64, types::F64), // compiler-builtins\n+        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32, types::F32),\n+        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64, types::F64),\n+        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::logf64 => (\"log\", 1, fx.tcx.types.f64, types::F64),\n+        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64, types::F64),\n+        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64, types::F64),\n+        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64, types::F64),\n+        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32, types::F32),\n+        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64, types::F64),\n+        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32, types::F32),\n+        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64, types::F64),\n+        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64, types::F64),\n+        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64, types::F64),\n+        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64, types::F64),\n+        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64, types::F64),\n+        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64, types::F64),\n+        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64, types::F64),\n         _ => return false,\n     };\n \n@@ -296,15 +296,19 @@ fn codegen_float_intrinsic_call<'tcx>(\n     let (a, b, c);\n     let args = match args {\n         [x] => {\n-            a = [codegen_operand(fx, x)];\n+            a = [codegen_operand(fx, x).load_scalar(fx)];\n             &a as &[_]\n         }\n         [x, y] => {\n-            b = [codegen_operand(fx, x), codegen_operand(fx, y)];\n+            b = [codegen_operand(fx, x).load_scalar(fx), codegen_operand(fx, y).load_scalar(fx)];\n             &b\n         }\n         [x, y, z] => {\n-            c = [codegen_operand(fx, x), codegen_operand(fx, y), codegen_operand(fx, z)];\n+            c = [\n+                codegen_operand(fx, x).load_scalar(fx),\n+                codegen_operand(fx, y).load_scalar(fx),\n+                codegen_operand(fx, z).load_scalar(fx),\n+            ];\n             &c\n         }\n         _ => unreachable!(),\n@@ -313,15 +317,10 @@ fn codegen_float_intrinsic_call<'tcx>(\n     let layout = fx.layout_of(ty);\n     let res = match intrinsic {\n         sym::fmaf32 | sym::fmaf64 => {\n-            let a = args[0].load_scalar(fx);\n-            let b = args[1].load_scalar(fx);\n-            let c = args[2].load_scalar(fx);\n-            CValue::by_val(fx.bcx.ins().fma(a, b, c), layout)\n+            CValue::by_val(fx.bcx.ins().fma(args[0], args[1], args[2]), layout)\n         }\n         sym::copysignf32 | sym::copysignf64 => {\n-            let a = args[0].load_scalar(fx);\n-            let b = args[1].load_scalar(fx);\n-            CValue::by_val(fx.bcx.ins().fcopysign(a, b), layout)\n+            CValue::by_val(fx.bcx.ins().fcopysign(args[0], args[1]), layout)\n         }\n         sym::fabsf32\n         | sym::fabsf64\n@@ -331,21 +330,29 @@ fn codegen_float_intrinsic_call<'tcx>(\n         | sym::ceilf64\n         | sym::truncf32\n         | sym::truncf64 => {\n-            let a = args[0].load_scalar(fx);\n-\n             let val = match intrinsic {\n-                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(a),\n-                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(a),\n-                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(a),\n-                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(a),\n+                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(args[0]),\n+                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(args[0]),\n+                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(args[0]),\n+                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(args[0]),\n                 _ => unreachable!(),\n             };\n \n             CValue::by_val(val, layout)\n         }\n+\n         // These intrinsics aren't supported natively by Cranelift.\n         // Lower them to a libcall.\n-        _ => fx.easy_call(name, &args, ty),\n+        sym::powif32 | sym::powif64 => {\n+            let input_tys: Vec<_> = vec![AbiParam::new(clif_ty), AbiParam::new(types::I32)];\n+            let ret_val = fx.lib_call(name, input_tys, vec![AbiParam::new(clif_ty)], &args)[0];\n+            CValue::by_val(ret_val, fx.layout_of(ty))\n+        }\n+        _ => {\n+            let input_tys: Vec<_> = args.iter().map(|_| AbiParam::new(clif_ty)).collect();\n+            let ret_val = fx.lib_call(name, input_tys, vec![AbiParam::new(clif_ty)], &args)[0];\n+            CValue::by_val(ret_val, fx.layout_of(ty))\n+        }\n     };\n \n     ret.write_cvalue(fx, res);"}, {"sha": "51e79f85e02571041c8f1200bb5bac1801ef88c1", "filename": "src/num.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=cb12ad73975d380bc69f68a57de94069a3eb0dd6", "patch": "@@ -347,12 +347,20 @@ pub(crate) fn codegen_float_binop<'tcx>(\n         BinOp::Mul => b.fmul(lhs, rhs),\n         BinOp::Div => b.fdiv(lhs, rhs),\n         BinOp::Rem => {\n-            let name = match in_lhs.layout().ty.kind() {\n-                ty::Float(FloatTy::F32) => \"fmodf\",\n-                ty::Float(FloatTy::F64) => \"fmod\",\n+            let (name, ty) = match in_lhs.layout().ty.kind() {\n+                ty::Float(FloatTy::F32) => (\"fmodf\", types::F32),\n+                ty::Float(FloatTy::F64) => (\"fmod\", types::F64),\n                 _ => bug!(),\n             };\n-            return fx.easy_call(name, &[in_lhs, in_rhs], in_lhs.layout().ty);\n+\n+            let ret_val = fx.lib_call(\n+                name,\n+                vec![AbiParam::new(ty), AbiParam::new(ty)],\n+                vec![AbiParam::new(ty)],\n+                &[lhs, rhs],\n+            )[0];\n+\n+            return CValue::by_val(ret_val, in_lhs.layout());\n         }\n         BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n             let fltcc = match bin_op {"}, {"sha": "b60e56720ed5ed7c1f9cbe989c98dc9e10a608ce", "filename": "src/pointer.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb12ad73975d380bc69f68a57de94069a3eb0dd6/src%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpointer.rs?ref=cb12ad73975d380bc69f68a57de94069a3eb0dd6", "patch": "@@ -30,11 +30,6 @@ impl Pointer {\n         Pointer { base: PointerBase::Stack(stack_slot), offset: Offset32::new(0) }\n     }\n \n-    pub(crate) fn const_addr(fx: &mut FunctionCx<'_, '_, '_>, addr: i64) -> Self {\n-        let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n-        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n-    }\n-\n     pub(crate) fn dangling(align: Align) -> Self {\n         Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }"}]}