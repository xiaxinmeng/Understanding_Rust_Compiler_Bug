{"sha": "20fa4b76235afb6a2ad543781a10a14e8013b143", "node_id": "C_kwDOAAsO6NoAKDIwZmE0Yjc2MjM1YWZiNmEyYWQ1NDM3ODFhMTBhMTRlODAxM2IxNDM", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2022-02-09T04:54:05Z"}, "committer": {"name": "Jubilee Young", "email": "workingjubilee@gmail.com", "date": "2022-02-25T02:04:02Z"}, "message": "Make internal mask implementation safe", "tree": {"sha": "b336c11a27fcf9c6d0148bba5bcbe233fd00f668", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b336c11a27fcf9c6d0148bba5bcbe233fd00f668"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20fa4b76235afb6a2ad543781a10a14e8013b143", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20fa4b76235afb6a2ad543781a10a14e8013b143", "html_url": "https://github.com/rust-lang/rust/commit/20fa4b76235afb6a2ad543781a10a14e8013b143", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20fa4b76235afb6a2ad543781a10a14e8013b143/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "workingjubilee", "id": 46493976, "node_id": "MDQ6VXNlcjQ2NDkzOTc2", "avatar_url": "https://avatars.githubusercontent.com/u/46493976?v=4", "gravatar_id": "", "url": "https://api.github.com/users/workingjubilee", "html_url": "https://github.com/workingjubilee", "followers_url": "https://api.github.com/users/workingjubilee/followers", "following_url": "https://api.github.com/users/workingjubilee/following{/other_user}", "gists_url": "https://api.github.com/users/workingjubilee/gists{/gist_id}", "starred_url": "https://api.github.com/users/workingjubilee/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/workingjubilee/subscriptions", "organizations_url": "https://api.github.com/users/workingjubilee/orgs", "repos_url": "https://api.github.com/users/workingjubilee/repos", "events_url": "https://api.github.com/users/workingjubilee/events{/privacy}", "received_events_url": "https://api.github.com/users/workingjubilee/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11c3eefa3594055192612d0d6f844e764dcbda15", "url": "https://api.github.com/repos/rust-lang/rust/commits/11c3eefa3594055192612d0d6f844e764dcbda15", "html_url": "https://github.com/rust-lang/rust/commit/11c3eefa3594055192612d0d6f844e764dcbda15"}], "stats": {"total": 105, "additions": 75, "deletions": 30}, "files": [{"sha": "7bf2add20364d36f717c5b3ac7d35c07c4c9dd6c", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/20fa4b76235afb6a2ad543781a10a14e8013b143/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20fa4b76235afb6a2ad543781a10a14e8013b143/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=20fa4b76235afb6a2ad543781a10a14e8013b143", "patch": "@@ -1,7 +1,7 @@\n #![allow(unused_imports)]\n use super::MaskElement;\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n use core::marker::PhantomData;\n \n /// A mask where each lane is represented by a single bit.\n@@ -116,13 +116,20 @@ where\n     }\n \n     #[inline]\n-    pub unsafe fn to_bitmask_integer<U>(self) -> U {\n+    pub fn to_bitmask_integer<U>(self) -> U\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: these are the same types\n         unsafe { core::mem::transmute_copy(&self.0) }\n     }\n \n-    // Safety: U must be the integer with the exact number of bits required to hold the bitmask for\n     #[inline]\n-    pub unsafe fn from_bitmask_integer<U>(bitmask: U) -> Self {\n+    pub fn from_bitmask_integer<U>(bitmask: U) -> Self\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: these are the same types\n         unsafe { Self(core::mem::transmute_copy(&bitmask), PhantomData) }\n     }\n "}, {"sha": "848997a07925a92f81d338f1d69a98e0de939709", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/20fa4b76235afb6a2ad543781a10a14e8013b143/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20fa4b76235afb6a2ad543781a10a14e8013b143/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=20fa4b76235afb6a2ad543781a10a14e8013b143", "patch": "@@ -2,7 +2,7 @@\n \n use super::MaskElement;\n use crate::simd::intrinsics;\n-use crate::simd::{LaneCount, Simd, SupportedLaneCount};\n+use crate::simd::{LaneCount, Simd, SupportedLaneCount, ToBitMask};\n \n #[repr(transparent)]\n pub struct Mask<T, const LANES: usize>(Simd<T, LANES>)\n@@ -66,6 +66,23 @@ where\n     }\n }\n \n+// Used for bitmask bit order workaround\n+pub(crate) trait ReverseBits {\n+    fn reverse_bits(self) -> Self;\n+}\n+\n+macro_rules! impl_reverse_bits {\n+    { $($int:ty),* } => {\n+        $(\n+        impl ReverseBits for $int {\n+            fn reverse_bits(self) -> Self { <$int>::reverse_bits(self) }\n+        }\n+        )*\n+    }\n+}\n+\n+impl_reverse_bits! { u8, u16, u32, u64 }\n+\n impl<T, const LANES: usize> Mask<T, LANES>\n where\n     T: MaskElement,\n@@ -110,16 +127,34 @@ where\n     }\n \n     #[inline]\n-    pub unsafe fn to_bitmask_integer<U>(self) -> U {\n-        // Safety: caller must only return bitmask types\n-        unsafe { intrinsics::simd_bitmask(self.0) }\n+    pub(crate) fn to_bitmask_integer<U: ReverseBits>(self) -> U\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // Safety: U is required to be the appropriate bitmask type\n+        let bitmask: U = unsafe { intrinsics::simd_bitmask(self.0) };\n+\n+        // LLVM assumes bit order should match endianness\n+        if cfg!(target_endian = \"big\") {\n+            bitmask.reverse_bits()\n+        } else {\n+            bitmask\n+        }\n     }\n \n-    // Safety: U must be the integer with the exact number of bits required to hold the bitmask for\n-    // this mask\n     #[inline]\n-    pub unsafe fn from_bitmask_integer<U>(bitmask: U) -> Self {\n-        // Safety: caller must only pass bitmask types\n+    pub(crate) fn from_bitmask_integer<U: ReverseBits>(bitmask: U) -> Self\n+    where\n+        super::Mask<T, LANES>: ToBitMask<BitMask = U>,\n+    {\n+        // LLVM assumes bit order should match endianness\n+        let bitmask = if cfg!(target_endian = \"big\") {\n+            bitmask.reverse_bits()\n+        } else {\n+            bitmask\n+        };\n+\n+        // Safety: U is required to be the appropriate bitmask type\n         unsafe {\n             Self::from_int_unchecked(intrinsics::simd_select_bitmask(\n                 bitmask,"}, {"sha": "1c2037764c1e45af1960550df93cc290af05eaee", "filename": "crates/core_simd/src/masks/to_bitmask.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/20fa4b76235afb6a2ad543781a10a14e8013b143/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20fa4b76235afb6a2ad543781a10a14e8013b143/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fto_bitmask.rs?ref=20fa4b76235afb6a2ad543781a10a14e8013b143", "patch": "@@ -1,9 +1,26 @@\n use super::{mask_impl, Mask, MaskElement};\n+use crate::simd::{LaneCount, SupportedLaneCount};\n+\n+mod sealed {\n+    pub trait Sealed {}\n+}\n+pub use sealed::Sealed;\n+\n+impl<T, const LANES: usize> Sealed for Mask<T, LANES>\n+where\n+    T: MaskElement,\n+    LaneCount<LANES>: SupportedLaneCount,\n+{\n+}\n \n /// Converts masks to and from integer bitmasks.\n ///\n /// Each bit of the bitmask corresponds to a mask lane, starting with the LSB.\n-pub trait ToBitMask {\n+///\n+/// # Safety\n+/// This trait is `unsafe` and sealed, since the `BitMask` type must match the number of lanes in\n+/// the mask.\n+pub unsafe trait ToBitMask: Sealed {\n     /// The integer bitmask type.\n     type BitMask;\n \n@@ -14,32 +31,18 @@ pub trait ToBitMask {\n     fn from_bitmask(bitmask: Self::BitMask) -> Self;\n }\n \n-/// Converts masks to and from byte array bitmasks.\n-///\n-/// Each bit of the bitmask corresponds to a mask lane, starting with the LSB of the first byte.\n-pub trait ToBitMaskArray {\n-    /// The length of the bitmask array.\n-    const BYTES: usize;\n-\n-    /// Converts a mask to a bitmask.\n-    fn to_bitmask_array(self) -> [u8; Self::BYTES];\n-\n-    /// Converts a bitmask to a mask.\n-    fn from_bitmask_array(bitmask: [u8; Self::BYTES]) -> Self;\n-}\n-\n macro_rules! impl_integer_intrinsic {\n     { $(unsafe impl ToBitMask<BitMask=$int:ty> for Mask<_, $lanes:literal>)* } => {\n         $(\n-        impl<T: MaskElement> ToBitMask for Mask<T, $lanes> {\n+        unsafe impl<T: MaskElement> ToBitMask for Mask<T, $lanes> {\n             type BitMask = $int;\n \n             fn to_bitmask(self) -> $int {\n-                unsafe { self.0.to_bitmask_integer() }\n+                self.0.to_bitmask_integer()\n             }\n \n             fn from_bitmask(bitmask: $int) -> Self {\n-                unsafe { Self(mask_impl::Mask::from_bitmask_integer(bitmask)) }\n+                Self(mask_impl::Mask::from_bitmask_integer(bitmask))\n             }\n         }\n         )*"}]}