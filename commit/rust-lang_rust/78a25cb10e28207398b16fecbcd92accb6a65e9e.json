{"sha": "78a25cb10e28207398b16fecbcd92accb6a65e9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4YTI1Y2IxMGUyODIwNzM5OGIxNmZlY2JjZDkyYWNjYjZhNjVlOWU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-05-06T11:22:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-06T11:22:05Z"}, "message": "Rollup merge of #71510 - ssomers:btreemap_iter_intertwined, r=Mark-Simulacrum\n\nBtreemap iter intertwined\n\n3 commits:\n\n1. Introduced benchmarks for `BTreeMap::iter()`. Benchmarks named `iter_20` were of the whole iteration process, so I renamed them. Also the benchmarks of `range` that I wrote earlier weren't very good. I included an (awkwardly named) one that compares `iter()` to `range(..)` on the same set, because the contrast is surprising:\n```\n name                                           ns/iter\n btree::map::range_unbounded_unbounded          28,176\n btree::map::range_unbounded_vs_iter            89,369\n```\nBoth dig up the same pair of leaf edges. `range(..)` also checks that some keys are correctly ordered, the only thing `iter()` does more is to copy the map's length.\n\n2. Slightly refactoring the code to what I find more readable (not in chronological order of discovery), boosts performance:\n```\n>cargo-benchcmp.exe benchcmp a1 a2 --threshold 5\n name                                   a1 ns/iter  a2 ns/iter  diff ns/iter   diff %  speedup\n btree::map::find_rand_100              18          17                    -1   -5.56%   x 1.06\n btree::map::first_and_last_10k         64          71                     7   10.94%   x 0.90\n btree::map::iter_0                     2,939       2,209               -730  -24.84%   x 1.33\n btree::map::iter_1                     6,845       2,696             -4,149  -60.61%   x 2.54\n btree::map::iter_100                   8,556       3,672             -4,884  -57.08%   x 2.33\n btree::map::iter_10k                   9,292       5,884             -3,408  -36.68%   x 1.58\n btree::map::iter_1m                    10,268      6,510             -3,758  -36.60%   x 1.58\n btree::map::iteration_mut_100000       478,575     453,050          -25,525   -5.33%   x 1.06\n btree::map::range_unbounded_unbounded  28,176      36,169             7,993   28.37%   x 0.78\n btree::map::range_unbounded_vs_iter    89,369      38,290           -51,079  -57.16%   x 2.33\n btree::set::clone_100_and_remove_all   4,801       4,245               -556  -11.58%   x 1.13\n btree::set::clone_10k_and_remove_all   529,450     496,030          -33,420   -6.31%   x 1.07\n```\nBut you can tell from the `range_unbounded_*` lines that, despite an unwarranted, vengeful attack on the range_unbounded_unbounded benchmark, this change still doesn't allow `iter()` to catch up with `range(..)`.\n\n3. I guess that `range(..)` copes so well because it intertwines the leftmost and rightmost descend towards leaf edges, doing the two root node accesses close together, perhaps exploiting a CPU's internal pipelining? So the third commit distils a version of `range_search` (which we can't use directly because of the `Ord` bound), and we get another boost:\n```\ncargo-benchcmp.exe benchcmp a2 a3 --threshold 5\n name                                   a2 ns/iter  a3 ns/iter  diff ns/iter   diff %  speedup\n btree::map::first_and_last_100         40          43                     3    7.50%   x 0.93\n btree::map::first_and_last_10k         71          64                    -7   -9.86%   x 1.11\n btree::map::iter_0                     2,209       1,719               -490  -22.18%   x 1.29\n btree::map::iter_1                     2,696       2,205               -491  -18.21%   x 1.22\n btree::map::iter_100                   3,672       2,943               -729  -19.85%   x 1.25\n btree::map::iter_10k                   5,884       3,929             -1,955  -33.23%   x 1.50\n btree::map::iter_1m                    6,510       5,532               -978  -15.02%   x 1.18\n btree::map::iteration_mut_100000       453,050     476,667           23,617    5.21%   x 0.95\n btree::map::range_included_excluded    405,075     371,297          -33,778   -8.34%   x 1.09\n btree::map::range_included_included    427,577     397,440          -30,137   -7.05%   x 1.08\n btree::map::range_unbounded_unbounded  36,169      28,175            -7,994  -22.10%   x 1.28\n btree::map::range_unbounded_vs_iter    38,290      30,838            -7,452  -19.46%   x 1.24\n```\nBut I think this is just fake news from the microbenchmarking media. `iter()` is still trying to catch up with `range(..)`. And we can sure do without another function. So I would skip this 3rd commit.\n\nr? @Mark-Simulacrum", "tree": {"sha": "c3f12f254a2ad16a8dec4871970276c9a5986ca1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3f12f254a2ad16a8dec4871970276c9a5986ca1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78a25cb10e28207398b16fecbcd92accb6a65e9e", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJesp3fCRBK7hj4Ov3rIwAAdHIIAHYa162E1LEZh29BBxNij6av\ngZ6sv1Qi197S++rQerTqq7gKWYH99lWkAavV3H2xHNtQy/hkG0NCKfYezG0CzCFB\nnxVskiiN80d7AN1JUUPWNeWU6Yiz8F+DRwJY/Wa1CztqvrNQaCQs55h3BJKEr/FN\nC+mKWbwJb+T8MHmImG6F3tOyoNOSUmIqgcmvmIz7MO1xL241GkXLiDz4RzgJImFv\nLuuyy4HCmAPU6f/UzHrJ0LT8HOmREcdSdx7LjnfUlSmGxn/5smPy9tOUkySeI2lP\nXqgN4zlYxQWGQx/gIWLmK9326tkFYkoHkAiDqxteShCWAGBcvDVF0M0oNO0UME4=\n=TBaR\n-----END PGP SIGNATURE-----\n", "payload": "tree c3f12f254a2ad16a8dec4871970276c9a5986ca1\nparent 8da5869fb738e51438dd1e0697c1b2c84eb11c59\nparent 873022797ae7f09872738c7367d8d658a1a34ad5\nauthor Dylan DPC <dylan.dpc@gmail.com> 1588764125 +0200\ncommitter GitHub <noreply@github.com> 1588764125 +0200\n\nRollup merge of #71510 - ssomers:btreemap_iter_intertwined, r=Mark-Simulacrum\n\nBtreemap iter intertwined\n\n3 commits:\n\n1. Introduced benchmarks for `BTreeMap::iter()`. Benchmarks named `iter_20` were of the whole iteration process, so I renamed them. Also the benchmarks of `range` that I wrote earlier weren't very good. I included an (awkwardly named) one that compares `iter()` to `range(..)` on the same set, because the contrast is surprising:\n```\n name                                           ns/iter\n btree::map::range_unbounded_unbounded          28,176\n btree::map::range_unbounded_vs_iter            89,369\n```\nBoth dig up the same pair of leaf edges. `range(..)` also checks that some keys are correctly ordered, the only thing `iter()` does more is to copy the map's length.\n\n2. Slightly refactoring the code to what I find more readable (not in chronological order of discovery), boosts performance:\n```\n>cargo-benchcmp.exe benchcmp a1 a2 --threshold 5\n name                                   a1 ns/iter  a2 ns/iter  diff ns/iter   diff %  speedup\n btree::map::find_rand_100              18          17                    -1   -5.56%   x 1.06\n btree::map::first_and_last_10k         64          71                     7   10.94%   x 0.90\n btree::map::iter_0                     2,939       2,209               -730  -24.84%   x 1.33\n btree::map::iter_1                     6,845       2,696             -4,149  -60.61%   x 2.54\n btree::map::iter_100                   8,556       3,672             -4,884  -57.08%   x 2.33\n btree::map::iter_10k                   9,292       5,884             -3,408  -36.68%   x 1.58\n btree::map::iter_1m                    10,268      6,510             -3,758  -36.60%   x 1.58\n btree::map::iteration_mut_100000       478,575     453,050          -25,525   -5.33%   x 1.06\n btree::map::range_unbounded_unbounded  28,176      36,169             7,993   28.37%   x 0.78\n btree::map::range_unbounded_vs_iter    89,369      38,290           -51,079  -57.16%   x 2.33\n btree::set::clone_100_and_remove_all   4,801       4,245               -556  -11.58%   x 1.13\n btree::set::clone_10k_and_remove_all   529,450     496,030          -33,420   -6.31%   x 1.07\n```\nBut you can tell from the `range_unbounded_*` lines that, despite an unwarranted, vengeful attack on the range_unbounded_unbounded benchmark, this change still doesn't allow `iter()` to catch up with `range(..)`.\n\n3. I guess that `range(..)` copes so well because it intertwines the leftmost and rightmost descend towards leaf edges, doing the two root node accesses close together, perhaps exploiting a CPU's internal pipelining? So the third commit distils a version of `range_search` (which we can't use directly because of the `Ord` bound), and we get another boost:\n```\ncargo-benchcmp.exe benchcmp a2 a3 --threshold 5\n name                                   a2 ns/iter  a3 ns/iter  diff ns/iter   diff %  speedup\n btree::map::first_and_last_100         40          43                     3    7.50%   x 0.93\n btree::map::first_and_last_10k         71          64                    -7   -9.86%   x 1.11\n btree::map::iter_0                     2,209       1,719               -490  -22.18%   x 1.29\n btree::map::iter_1                     2,696       2,205               -491  -18.21%   x 1.22\n btree::map::iter_100                   3,672       2,943               -729  -19.85%   x 1.25\n btree::map::iter_10k                   5,884       3,929             -1,955  -33.23%   x 1.50\n btree::map::iter_1m                    6,510       5,532               -978  -15.02%   x 1.18\n btree::map::iteration_mut_100000       453,050     476,667           23,617    5.21%   x 0.95\n btree::map::range_included_excluded    405,075     371,297          -33,778   -8.34%   x 1.09\n btree::map::range_included_included    427,577     397,440          -30,137   -7.05%   x 1.08\n btree::map::range_unbounded_unbounded  36,169      28,175            -7,994  -22.10%   x 1.28\n btree::map::range_unbounded_vs_iter    38,290      30,838            -7,452  -19.46%   x 1.24\n```\nBut I think this is just fake news from the microbenchmarking media. `iter()` is still trying to catch up with `range(..)`. And we can sure do without another function. So I would skip this 3rd commit.\n\nr? @Mark-Simulacrum\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78a25cb10e28207398b16fecbcd92accb6a65e9e", "html_url": "https://github.com/rust-lang/rust/commit/78a25cb10e28207398b16fecbcd92accb6a65e9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78a25cb10e28207398b16fecbcd92accb6a65e9e/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8da5869fb738e51438dd1e0697c1b2c84eb11c59", "url": "https://api.github.com/repos/rust-lang/rust/commits/8da5869fb738e51438dd1e0697c1b2c84eb11c59", "html_url": "https://github.com/rust-lang/rust/commit/8da5869fb738e51438dd1e0697c1b2c84eb11c59"}, {"sha": "873022797ae7f09872738c7367d8d658a1a34ad5", "url": "https://api.github.com/repos/rust-lang/rust/commits/873022797ae7f09872738c7367d8d658a1a34ad5", "html_url": "https://github.com/rust-lang/rust/commit/873022797ae7f09872738c7367d8d658a1a34ad5"}], "stats": {"total": 194, "additions": 119, "deletions": 75}, "files": [{"sha": "38d19c59ad186edfbad8b6d8f972320d9df57f22", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 72, "deletions": 46, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/78a25cb10e28207398b16fecbcd92accb6a65e9e/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a25cb10e28207398b16fecbcd92accb6a65e9e/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=78a25cb10e28207398b16fecbcd92accb6a65e9e", "patch": "@@ -1,6 +1,6 @@\n use std::collections::BTreeMap;\n use std::iter::Iterator;\n-use std::ops::Bound::{Excluded, Unbounded};\n+use std::ops::RangeBounds;\n use std::vec::Vec;\n \n use rand::{seq::SliceRandom, thread_rng, Rng};\n@@ -117,7 +117,7 @@ map_find_rand_bench! {find_rand_10_000, 10_000, BTreeMap}\n map_find_seq_bench! {find_seq_100,    100,    BTreeMap}\n map_find_seq_bench! {find_seq_10_000, 10_000, BTreeMap}\n \n-fn bench_iter(b: &mut Bencher, size: i32) {\n+fn bench_iteration(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -133,21 +133,21 @@ fn bench_iter(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_20(b: &mut Bencher) {\n-    bench_iter(b, 20);\n+pub fn iteration_20(b: &mut Bencher) {\n+    bench_iteration(b, 20);\n }\n \n #[bench]\n-pub fn iter_1000(b: &mut Bencher) {\n-    bench_iter(b, 1000);\n+pub fn iteration_1000(b: &mut Bencher) {\n+    bench_iteration(b, 1000);\n }\n \n #[bench]\n-pub fn iter_100000(b: &mut Bencher) {\n-    bench_iter(b, 100000);\n+pub fn iteration_100000(b: &mut Bencher) {\n+    bench_iteration(b, 100000);\n }\n \n-fn bench_iter_mut(b: &mut Bencher, size: i32) {\n+fn bench_iteration_mut(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();\n     let mut rng = thread_rng();\n \n@@ -163,18 +163,18 @@ fn bench_iter_mut(b: &mut Bencher, size: i32) {\n }\n \n #[bench]\n-pub fn iter_mut_20(b: &mut Bencher) {\n-    bench_iter_mut(b, 20);\n+pub fn iteration_mut_20(b: &mut Bencher) {\n+    bench_iteration_mut(b, 20);\n }\n \n #[bench]\n-pub fn iter_mut_1000(b: &mut Bencher) {\n-    bench_iter_mut(b, 1000);\n+pub fn iteration_mut_1000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 1000);\n }\n \n #[bench]\n-pub fn iter_mut_100000(b: &mut Bencher) {\n-    bench_iter_mut(b, 100000);\n+pub fn iteration_mut_100000(b: &mut Bencher) {\n+    bench_iteration_mut(b, 100000);\n }\n \n fn bench_first_and_last(b: &mut Bencher, size: i32) {\n@@ -202,57 +202,83 @@ pub fn first_and_last_10k(b: &mut Bencher) {\n     bench_first_and_last(b, 10_000);\n }\n \n-#[bench]\n-pub fn range_excluded_excluded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n+const BENCH_RANGE_SIZE: i32 = 145;\n+const BENCH_RANGE_COUNT: i32 = BENCH_RANGE_SIZE * (BENCH_RANGE_SIZE - 1) / 2;\n+\n+fn bench_range<F, R>(b: &mut Bencher, f: F)\n+where\n+    F: Fn(i32, i32) -> R,\n+    R: RangeBounds<i32>,\n+{\n+    let map: BTreeMap<_, _> = (0..BENCH_RANGE_SIZE).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            for last in first + 1..size {\n-                black_box(map.range((Excluded(first), Excluded(last))));\n+        let mut c = 0;\n+        for i in 0..BENCH_RANGE_SIZE {\n+            for j in i + 1..BENCH_RANGE_SIZE {\n+                black_box(map.range(f(i, j)));\n+                c += 1;\n             }\n         }\n+        debug_assert_eq!(c, BENCH_RANGE_COUNT);\n     });\n }\n \n #[bench]\n-pub fn range_excluded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range((Excluded(first), Unbounded)));\n-        }\n-    });\n+pub fn range_included_excluded(b: &mut Bencher) {\n+    bench_range(b, |i, j| i..j);\n }\n \n #[bench]\n pub fn range_included_included(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| {\n-        for first in 0..size {\n-            for last in first..size {\n-                black_box(map.range(first..=last));\n-            }\n-        }\n-    });\n+    bench_range(b, |i, j| i..=j);\n }\n \n #[bench]\n pub fn range_included_unbounded(b: &mut Bencher) {\n-    let size = 144;\n+    bench_range(b, |i, _| i..);\n+}\n+\n+#[bench]\n+pub fn range_unbounded_unbounded(b: &mut Bencher) {\n+    bench_range(b, |_, _| ..);\n+}\n+\n+fn bench_iter(b: &mut Bencher, repeats: i32, size: i32) {\n     let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n     b.iter(|| {\n-        for first in 0..size {\n-            black_box(map.range(first..));\n+        for _ in 0..repeats {\n+            black_box(map.iter());\n         }\n     });\n }\n \n+/// Contrast range_unbounded_unbounded with `iter()`.\n #[bench]\n-pub fn range_unbounded_unbounded(b: &mut Bencher) {\n-    let size = 144;\n-    let map: BTreeMap<_, _> = (0..size).map(|i| (i, i)).collect();\n-    b.iter(|| map.range(..));\n+pub fn range_unbounded_vs_iter(b: &mut Bencher) {\n+    bench_iter(b, BENCH_RANGE_COUNT, BENCH_RANGE_SIZE);\n+}\n+\n+#[bench]\n+pub fn iter_0(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 0);\n+}\n+\n+#[bench]\n+pub fn iter_1(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1);\n+}\n+\n+#[bench]\n+pub fn iter_100(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 100);\n+}\n+\n+#[bench]\n+pub fn iter_10k(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 10_000);\n+}\n+\n+#[bench]\n+pub fn iter_1m(b: &mut Bencher) {\n+    bench_iter(b, 1_000, 1_000_000);\n }"}, {"sha": "98a94d695f78444acbdd0e123272c641ba0a0249", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 47, "deletions": 29, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/78a25cb10e28207398b16fecbcd92accb6a65e9e/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78a25cb10e28207398b16fecbcd92accb6a65e9e/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=78a25cb10e28207398b16fecbcd92accb6a65e9e", "patch": "@@ -1540,16 +1540,10 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n \n     fn into_iter(self) -> IntoIter<K, V> {\n         let mut me = ManuallyDrop::new(self);\n-        if let Some(root) = me.root.as_mut() {\n-            let root1 = unsafe { ptr::read(root).into_ref() };\n-            let root2 = unsafe { ptr::read(root).into_ref() };\n-            let len = me.length;\n-\n-            IntoIter {\n-                front: Some(root1.first_leaf_edge()),\n-                back: Some(root2.last_leaf_edge()),\n-                length: len,\n-            }\n+        if let Some(root) = me.root.take() {\n+            let (f, b) = full_range_search(root.into_ref());\n+\n+            IntoIter { front: Some(f), back: Some(b), length: me.length }\n         } else {\n             IntoIter { front: None, back: None, length: 0 }\n         }\n@@ -2037,6 +2031,7 @@ where\n     }\n }\n \n+/// Finds the leaf edges delimiting a specified range in or underneath a node.\n fn range_search<BorrowType, K, V, Q: ?Sized, R: RangeBounds<Q>>(\n     root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n     range: R,\n@@ -2122,6 +2117,33 @@ where\n     }\n }\n \n+/// Equivalent to `range_search(k, v, ..)` without the `Ord` bound.\n+fn full_range_search<BorrowType, K, V>(\n+    root: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+) -> (\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+    Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge>,\n+) {\n+    // We duplicate the root NodeRef here -- we will never access it in a way\n+    // that overlaps references obtained from the root.\n+    let mut min_node = unsafe { ptr::read(&root) };\n+    let mut max_node = root;\n+    loop {\n+        let front = min_node.first_edge();\n+        let back = max_node.last_edge();\n+        match (front.force(), back.force()) {\n+            (Leaf(f), Leaf(b)) => {\n+                return (f, b);\n+            }\n+            (Internal(min_int), Internal(max_int)) => {\n+                min_node = min_int.descend();\n+                max_node = max_int.descend();\n+            }\n+            _ => unreachable!(\"BTreeMap has different depths\"),\n+        };\n+    }\n+}\n+\n impl<K, V> BTreeMap<K, V> {\n     /// Gets an iterator over the entries of the map, sorted by key.\n     ///\n@@ -2146,12 +2168,12 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<'_, K, V> {\n-        Iter {\n-            range: Range {\n-                front: self.root.as_ref().map(|r| r.as_ref().first_leaf_edge()),\n-                back: self.root.as_ref().map(|r| r.as_ref().last_leaf_edge()),\n-            },\n-            length: self.length,\n+        if let Some(root) = &self.root {\n+            let (f, b) = full_range_search(root.as_ref());\n+\n+            Iter { range: Range { front: Some(f), back: Some(b) }, length: self.length }\n+        } else {\n+            Iter { range: Range { front: None, back: None }, length: 0 }\n         }\n     }\n \n@@ -2178,19 +2200,15 @@ impl<K, V> BTreeMap<K, V> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter_mut(&mut self) -> IterMut<'_, K, V> {\n-        IterMut {\n-            range: if let Some(root) = &mut self.root {\n-                let root1 = root.as_mut();\n-                let root2 = unsafe { ptr::read(&root1) };\n-                RangeMut {\n-                    front: Some(root1.first_leaf_edge()),\n-                    back: Some(root2.last_leaf_edge()),\n-                    _marker: PhantomData,\n-                }\n-            } else {\n-                RangeMut { front: None, back: None, _marker: PhantomData }\n-            },\n-            length: self.length,\n+        if let Some(root) = &mut self.root {\n+            let (f, b) = full_range_search(root.as_mut());\n+\n+            IterMut {\n+                range: RangeMut { front: Some(f), back: Some(b), _marker: PhantomData },\n+                length: self.length,\n+            }\n+        } else {\n+            IterMut { range: RangeMut { front: None, back: None, _marker: PhantomData }, length: 0 }\n         }\n     }\n "}]}