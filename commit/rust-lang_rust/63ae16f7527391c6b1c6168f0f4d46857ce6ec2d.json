{"sha": "63ae16f7527391c6b1c6168f0f4d46857ce6ec2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzYWUxNmY3NTI3MzkxYzZiMWM2MTY4ZjBmNGQ0Njg1N2NlNmVjMmQ=", "commit": {"author": {"name": "Ted Horst", "email": "ted.horst@earthlink.net", "date": "2012-02-04T03:50:32Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-04T04:49:14Z"}, "message": "fix formatting", "tree": {"sha": "8bde47bfa0127068e213968945b24e755925a49a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bde47bfa0127068e213968945b24e755925a49a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63ae16f7527391c6b1c6168f0f4d46857ce6ec2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63ae16f7527391c6b1c6168f0f4d46857ce6ec2d", "html_url": "https://github.com/rust-lang/rust/commit/63ae16f7527391c6b1c6168f0f4d46857ce6ec2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63ae16f7527391c6b1c6168f0f4d46857ce6ec2d/comments", "author": {"login": "tedhorst", "id": 113629, "node_id": "MDQ6VXNlcjExMzYyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/113629?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tedhorst", "html_url": "https://github.com/tedhorst", "followers_url": "https://api.github.com/users/tedhorst/followers", "following_url": "https://api.github.com/users/tedhorst/following{/other_user}", "gists_url": "https://api.github.com/users/tedhorst/gists{/gist_id}", "starred_url": "https://api.github.com/users/tedhorst/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tedhorst/subscriptions", "organizations_url": "https://api.github.com/users/tedhorst/orgs", "repos_url": "https://api.github.com/users/tedhorst/repos", "events_url": "https://api.github.com/users/tedhorst/events{/privacy}", "received_events_url": "https://api.github.com/users/tedhorst/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7738ca38b78239d6971af2d3c782bbb88f9a563", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7738ca38b78239d6971af2d3c782bbb88f9a563", "html_url": "https://github.com/rust-lang/rust/commit/e7738ca38b78239d6971af2d3c782bbb88f9a563"}], "stats": {"total": 206, "additions": 103, "deletions": 103}, "files": [{"sha": "310708955217a589367ae98cb0f8cb4e88bc642a", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 103, "deletions": 103, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/63ae16f7527391c6b1c6168f0f4d46857ce6ec2d/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63ae16f7527391c6b1c6168f0f4d46857ce6ec2d/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=63ae16f7527391c6b1c6168f0f4d46857ce6ec2d", "patch": "@@ -1,5 +1,6 @@\n //  based on:\n-//  http://shootout.alioth.debian.org/u64q/program.php?test=mandelbrot&lang=python3&id=2\n+//  http://shootout.alioth.debian.org/\n+//   u64q/program.php?test=mandelbrot&lang=python3&id=2\n //\n //  takes 2 optional numeric args: square image size and yield frequency\n //  in the shootout, they use 16000 as image size\n@@ -14,130 +15,129 @@ type cmplx = {re: f64, im: f64};\n type line = {i: uint, b: [u8]};\n \n impl arith for cmplx {\n-\tfn *(x: cmplx) -> cmplx {\n-\t\t{re: self.re*x.re - self.im*x.im, im: self.re*x.im + self.im*x.re}\n-\t}\n+    fn *(x: cmplx) -> cmplx {\n+        {re: self.re*x.re - self.im*x.im, im: self.re*x.im + self.im*x.re}\n+    }\n \n-\tfn +(x: cmplx) -> cmplx {\n-\t\t{re: self.re + x.re, im: self.im + x.im}\n-\t}\n+    fn +(x: cmplx) -> cmplx {\n+        {re: self.re + x.re, im: self.im + x.im}\n+    }\n }\n \n pure fn cabs(x: cmplx) -> f64\n {\n-\tx.re*x.re + x.im*x.im\n+    x.re*x.re + x.im*x.im\n }\n \n fn mb(x: cmplx) -> bool\n {\n-\tlet z = {re: 0., im: 0.};\n-\tlet i = 0;\n-\tlet in = true;\n-\twhile i < 50 {\n-\t\tz = z*z + x;\n-\t\tif cabs(z) >= 4. {\n-\t\t\tin = false;\n-\t\t\tbreak;\n-\t\t}\n-\t\ti += 1;\n-\t}\n-\tin\n+    let z = {re: 0., im: 0.};\n+    let i = 0;\n+    let in = true;\n+    while i < 50 {\n+        z = z*z + x;\n+        if cabs(z) >= 4. {\n+            in = false;\n+            break;\n+        }\n+        i += 1;\n+    }\n+    in\n }\n \n fn fillbyte(x: cmplx, incr: f64) -> u8 {\n-\tlet rv = 0_u8;\n-\tlet i = 0_u8;\n-\twhile i < 8_u8 {\n-\t\tlet z = {re: x.re + (i as f64)*incr, im: x.im};\n-\t\tif mb(z) {\n-\t\t\trv += 1_u8 << (7_u8 - i);\n-\t\t}\n-\t\ti += 1_u8;\n-\t}\n-\trv\n+    let rv = 0_u8;\n+    let i = 0_u8;\n+    while i < 8_u8 {\n+        let z = {re: x.re + (i as f64)*incr, im: x.im};\n+        if mb(z) {\n+            rv += 1_u8 << (7_u8 - i);\n+        }\n+        i += 1_u8;\n+    }\n+    rv\n }\n \n fn chanmb(i: uint, size: uint, ch: comm::chan<line>) -> ()\n {\n-\tlet crv = [];\n-\tlet incr = 2./(size as f64);\n-\tlet y = incr*(i as f64) - 1.;\n-\tlet xincr = 8.*incr;\n-\tuint::range(0_u, size/8_u) {\n-\t\t|j|\n-\t\tlet x = {re: xincr*(j as f64) - 1.5, im: y};\n-\t\tcrv += [fillbyte(x, incr)];\n-\t};\n-\tcomm::send(ch, {i:i, b:crv});\n+    let crv = [];\n+    let incr = 2./(size as f64);\n+    let y = incr*(i as f64) - 1.;\n+    let xincr = 8.*incr;\n+    uint::range(0_u, size/8_u) {\n+        |j|\n+        let x = {re: xincr*(j as f64) - 1.5, im: y};\n+        crv += [fillbyte(x, incr)];\n+    };\n+    comm::send(ch, {i:i, b:crv});\n }\n \n fn writer(writech: comm::chan<comm::chan<line>>, size: uint)\n {\n-\tlet p: comm::port<line> = comm::port();\n-\tlet ch = comm::chan(p);\n-\tcomm::send(writech, ch);\n-\tlet cout = std::io::stdout();\n-\tcout.write_line(\"P4\");\n-\tcout.write_line(#fmt(\"%u %u\", size, size));\n-\tlet lines = std::map::new_uint_hash();\n-\tlet done = 0_u;\n-\tlet i = 0_u;\n-\twhile i < size {\n-\t\tlet aline = comm::recv(p);\n-\t\tif aline.i == done {\n-\t\t\t#debug(\"W %u\", aline.i);\n-\t\t\tcout.write(aline.b);\n-\t\t\tdone += 1_u;\n-\t\t\tlet prev = done;\n-\t\t\twhile prev <= i {\n-\t\t\t\tif lines.contains_key(prev) {\n-\t\t\t\t\t#debug(\"WS %u\", prev);\n-\t\t\t\t\tcout.write(lines.get(prev));\n-\t\t\t\t\tdone += 1_u;\n-\t\t\t\t\tlines.remove(prev);\n-\t\t\t\t\tprev += 1_u;\n-\t\t\t\t}\n-\t\t\t\telse {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t};\n-\t\t\t\n-\t\t}\n-\t\telse {\n-\t\t\t#debug(\"S %u\", aline.i);\n-\t\t\tlines.insert(aline.i, aline.b);\n-\t\t};\n-\t\ti += 1_u;\n-\t}\n+    let p: comm::port<line> = comm::port();\n+    let ch = comm::chan(p);\n+    comm::send(writech, ch);\n+    let cout = std::io::stdout();\n+    cout.write_line(\"P4\");\n+    cout.write_line(#fmt(\"%u %u\", size, size));\n+    let lines = std::map::new_uint_hash();\n+    let done = 0_u;\n+    let i = 0_u;\n+    while i < size {\n+        let aline = comm::recv(p);\n+        if aline.i == done {\n+            #debug(\"W %u\", aline.i);\n+            cout.write(aline.b);\n+            done += 1_u;\n+            let prev = done;\n+            while prev <= i {\n+                if lines.contains_key(prev) {\n+                    #debug(\"WS %u\", prev);\n+                    cout.write(lines.get(prev));\n+                    done += 1_u;\n+                    lines.remove(prev);\n+                    prev += 1_u;\n+                }\n+                else {\n+                    break\n+                }\n+            };\n+        }\n+        else {\n+            #debug(\"S %u\", aline.i);\n+            lines.insert(aline.i, aline.b);\n+        };\n+        i += 1_u;\n+    }\n }\n \n fn main(argv: [str])\n {\n-\tlet size = if vec::len(argv) < 2_u {\n-\t\t80u\n-\t}\n-\telse {\n-\t\tuint::from_str(argv[1])\n-\t};\n-\tlet yieldevery = if vec::len(argv) < 3_u {\n-\t\t10_u\n-\t}\n-\telse {\n-\t\tuint::from_str(argv[2])\n-\t};\n-\tlet writep = comm::port();\n-\tlet writech = comm::chan(writep);\n-\ttask::spawn {\n-\t\t|| writer(writech, size);\n-\t};\n-\tlet ch = comm::recv(writep);\n-\tuint::range(0_u, size) {\n-\t\t|j| task::spawn {\n-\t\t\t|| chanmb(j, size, ch);\n-\t\t};\n-\t\tif j % yieldevery == 0_u {\n-\t\t\t#debug(\"Y %u\", j);\n-\t\t\ttask::yield();\n-\t\t};\n-\t};\n+    let size = if vec::len(argv) < 2_u {\n+        80u\n+    }\n+    else {\n+        uint::from_str(argv[1])\n+    };\n+    let yieldevery = if vec::len(argv) < 3_u {\n+        10_u\n+    }\n+    else {\n+        uint::from_str(argv[2])\n+    };\n+    let writep = comm::port();\n+    let writech = comm::chan(writep);\n+    task::spawn {\n+        || writer(writech, size);\n+    };\n+    let ch = comm::recv(writep);\n+    uint::range(0_u, size) {\n+        |j| task::spawn {\n+            || chanmb(j, size, ch);\n+        };\n+        if j % yieldevery == 0_u {\n+            #debug(\"Y %u\", j);\n+            task::yield();\n+        };\n+    };\n }"}]}