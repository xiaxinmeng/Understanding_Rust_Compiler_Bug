{"sha": "222349931eec0b0b68b31b2b8b01e162cee23b85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIyMjM0OTkzMWVlYzBiMGI2OGIzMWIyYjhiMDFlMTYyY2VlMjNiODU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-10-19T14:45:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-01T18:08:56Z"}, "message": "apply review feedback nits\n\n- correct indentation\n- rename `from_cause` to `from_obligation_cause`\n- break up `compare_impl_method` into fns\n- delete some blank lines and correct comment", "tree": {"sha": "fede728e910513b80fdfaad4196c604ee230fd0b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fede728e910513b80fdfaad4196c604ee230fd0b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/222349931eec0b0b68b31b2b8b01e162cee23b85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/222349931eec0b0b68b31b2b8b01e162cee23b85", "html_url": "https://github.com/rust-lang/rust/commit/222349931eec0b0b68b31b2b8b01e162cee23b85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/222349931eec0b0b68b31b2b8b01e162cee23b85/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6597528bda5170241a46248d4ec969bd4717a0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6597528bda5170241a46248d4ec969bd4717a0b", "html_url": "https://github.com/rust-lang/rust/commit/b6597528bda5170241a46248d4ec969bd4717a0b"}], "stats": {"total": 754, "additions": 412, "deletions": 342}, "files": [{"sha": "fc91f17b8f634e58f79b4e3f74ed181d900d6f37", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/222349931eec0b0b68b31b2b8b01e162cee23b85/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222349931eec0b0b68b31b2b8b01e162cee23b85/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=222349931eec0b0b68b31b2b8b01e162cee23b85", "patch": "@@ -1172,7 +1172,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.commit_if_ok(|snapshot| {\n             let (ty::OutlivesPredicate(r_a, r_b), skol_map) =\n                 self.skolemize_late_bound_regions(predicate, snapshot);\n-            let origin = SubregionOrigin::from_cause(cause, || RelateRegionParamBound(cause.span));\n+            let origin =\n+                SubregionOrigin::from_obligation_cause(cause,\n+                                                       || RelateRegionParamBound(cause.span));\n             self.sub_regions(origin, r_b, r_a); // `b : a` ==> `a <= b`\n             self.leak_check(false, cause.span, &skol_map, snapshot)?;\n             Ok(self.pop_skolemized(skol_map, snapshot))\n@@ -1809,9 +1811,9 @@ impl<'tcx> SubregionOrigin<'tcx> {\n         }\n     }\n \n-    pub fn from_cause<F>(cause: &traits::ObligationCause<'tcx>,\n-                         default: F)\n-                         -> Self\n+    pub fn from_obligation_cause<F>(cause: &traits::ObligationCause<'tcx>,\n+                                    default: F)\n+                                    -> Self\n         where F: FnOnce() -> Self\n     {\n         match cause.code {"}, {"sha": "a3d974216b6e00d882ed6702d933df405da66960", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/222349931eec0b0b68b31b2b8b01e162cee23b85/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222349931eec0b0b68b31b2b8b01e162cee23b85/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=222349931eec0b0b68b31b2b8b01e162cee23b85", "patch": "@@ -1,4 +1,3 @@\n-\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -185,7 +184,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 // `'a: 'b`.\n \n                 // Ignore `for<'a> T: 'a` -- we might in the future\n-                // consider this as evidence that `Foo: 'static`, but\n+                // consider this as evidence that `T: 'static`, but\n                 // I'm a bit wary of such constructions and so for now\n                 // I want to be conservative. --nmatsakis\n                 let ty_max = data.skip_binder().0;"}, {"sha": "6f450f57275c55034770a5aea0a5712697a9a767", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 403, "deletions": 335, "changes": 738, "blob_url": "https://github.com/rust-lang/rust/blob/222349931eec0b0b68b31b2b8b01e162cee23b85/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222349931eec0b0b68b31b2b8b01e162cee23b85/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=222349931eec0b0b68b31b2b8b01e162cee23b85", "patch": "@@ -15,6 +15,7 @@ use rustc::traits::{self, Reveal};\n use rustc::ty::error::{ExpectedFound, TypeError};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::hir::{ImplItemKind, TraitItem_, Ty_};\n+use rustc::util::common::ErrorReported;\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -45,185 +46,51 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"compare_impl_method(impl_trait_ref={:?})\",\n            impl_trait_ref);\n \n-    debug!(\"compare_impl_method: impl_trait_ref (liberated) = {:?}\",\n-           impl_trait_ref);\n-\n-    let tcx = ccx.tcx;\n-\n-    let trait_to_impl_substs = &impl_trait_ref.substs;\n-\n-    // Try to give more informative error messages about self typing\n-    // mismatches.  Note that any mismatch will also be detected\n-    // below, where we construct a canonical function type that\n-    // includes the self parameter as a normal parameter.  It's just\n-    // that the error messages you get out of this code are a bit more\n-    // inscrutable, particularly for cases where one method has no\n-    // self.\n-    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n-        (&ty::ExplicitSelfCategory::Static, &ty::ExplicitSelfCategory::Static) => {}\n-        (&ty::ExplicitSelfCategory::Static, _) => {\n-            let mut err = struct_span_err!(tcx.sess,\n-                                           impl_m_span,\n-                                           E0185,\n-                                           \"method `{}` has a `{}` declaration in the impl, but \\\n-                                            not in the trait\",\n-                                           trait_m.name,\n-                                           impl_m.explicit_self);\n-            err.span_label(impl_m_span,\n-                           &format!(\"`{}` used in impl\", impl_m.explicit_self));\n-            if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n-                err.span_label(span,\n-                               &format!(\"trait declared without `{}`\", impl_m.explicit_self));\n-            }\n-            err.emit();\n-            return;\n-        }\n-        (_, &ty::ExplicitSelfCategory::Static) => {\n-            let mut err = struct_span_err!(tcx.sess,\n-                                           impl_m_span,\n-                                           E0186,\n-                                           \"method `{}` has a `{}` declaration in the trait, but \\\n-                                            not in the impl\",\n-                                           trait_m.name,\n-                                           trait_m.explicit_self);\n-            err.span_label(impl_m_span,\n-                           &format!(\"expected `{}` in impl\", trait_m.explicit_self));\n-            if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n-                err.span_label(span, &format!(\"`{}` used in trait\", trait_m.explicit_self));\n-            }\n-            err.emit();\n-            return;\n-        }\n-        _ => {\n-            // Let the type checker catch other errors below\n-        }\n+    if let Err(ErrorReported) = compare_self_type(ccx,\n+                                                  impl_m,\n+                                                  impl_m_span,\n+                                                  trait_m) {\n+        return;\n     }\n \n-    let num_impl_m_type_params = impl_m.generics.types.len();\n-    let num_trait_m_type_params = trait_m.generics.types.len();\n-    if num_impl_m_type_params != num_trait_m_type_params {\n-        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n-        let span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n-            ImplItemKind::Method(ref impl_m_sig, _) => {\n-                if impl_m_sig.generics.is_parameterized() {\n-                    impl_m_sig.generics.span\n-                } else {\n-                    impl_m_span\n-                }\n-            }\n-            _ => bug!(\"{:?} is not a method\", impl_m),\n-        };\n-\n-        let mut err = struct_span_err!(tcx.sess,\n-                                       span,\n-                                       E0049,\n-                                       \"method `{}` has {} type parameter{} but its trait \\\n-                                        declaration has {} type parameter{}\",\n-                                       trait_m.name,\n-                                       num_impl_m_type_params,\n-                                       if num_impl_m_type_params == 1 { \"\" } else { \"s\" },\n-                                       num_trait_m_type_params,\n-                                       if num_trait_m_type_params == 1 {\n-                                           \"\"\n-                                       } else {\n-                                           \"s\"\n-                                       });\n-\n-        let mut suffix = None;\n-\n-        if let Some(span) = trait_item_span {\n-            err.span_label(span,\n-                           &format!(\"expected {}\",\n-                                    &if num_trait_m_type_params != 1 {\n-                                        format!(\"{} type parameters\", num_trait_m_type_params)\n-                                    } else {\n-                                        format!(\"{} type parameter\", num_trait_m_type_params)\n-                                    }));\n-        } else {\n-            suffix = Some(format!(\", expected {}\", num_trait_m_type_params));\n-        }\n-\n-        err.span_label(span,\n-                       &format!(\"found {}{}\",\n-                                &if num_impl_m_type_params != 1 {\n-                                    format!(\"{} type parameters\", num_impl_m_type_params)\n-                                } else {\n-                                    format!(\"1 type parameter\")\n-                                },\n-                                suffix.as_ref().map(|s| &s[..]).unwrap_or(\"\")));\n-\n-        err.emit();\n+    if let Err(ErrorReported) = compare_number_of_generics(ccx,\n+                                                           impl_m,\n+                                                           impl_m_span,\n+                                                           trait_m,\n+                                                           trait_item_span) {\n+        return;\n+    }\n \n+    if let Err(ErrorReported) = compare_number_of_method_arguments(ccx,\n+                                                                   impl_m,\n+                                                                   impl_m_span,\n+                                                                   trait_m,\n+                                                                   trait_item_span) {\n         return;\n     }\n \n-    if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n-        let trait_number_args = trait_m.fty.sig.0.inputs.len();\n-        let impl_number_args = impl_m.fty.sig.0.inputs.len();\n-        let trait_m_node_id = tcx.map.as_local_node_id(trait_m.def_id);\n-        let trait_span = if let Some(trait_id) = trait_m_node_id {\n-            match tcx.map.expect_trait_item(trait_id).node {\n-                TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n-                    if let Some(arg) = trait_m_sig.decl.inputs.get(if trait_number_args > 0 {\n-                        trait_number_args - 1\n-                    } else {\n-                        0\n-                    }) {\n-                        Some(arg.pat.span)\n-                    } else {\n-                        trait_item_span\n-                    }\n-                }\n-                _ => bug!(\"{:?} is not a method\", impl_m),\n-            }\n-        } else {\n-            trait_item_span\n-        };\n-        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n-        let impl_span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n-            ImplItemKind::Method(ref impl_m_sig, _) => {\n-                if let Some(arg) = impl_m_sig.decl.inputs.get(if impl_number_args > 0 {\n-                    impl_number_args - 1\n-                } else {\n-                    0\n-                }) {\n-                    arg.pat.span\n-                } else {\n-                    impl_m_span\n-                }\n-            }\n-            _ => bug!(\"{:?} is not a method\", impl_m),\n-        };\n-        let mut err = struct_span_err!(tcx.sess,\n-                                       impl_span,\n-                                       E0050,\n-                                       \"method `{}` has {} parameter{} but the declaration in \\\n-                                        trait `{}` has {}\",\n-                                       trait_m.name,\n-                                       impl_number_args,\n-                                       if impl_number_args == 1 { \"\" } else { \"s\" },\n-                                       tcx.item_path_str(trait_m.def_id),\n-                                       trait_number_args);\n-        if let Some(trait_span) = trait_span {\n-            err.span_label(trait_span,\n-                           &format!(\"trait requires {}\",\n-                                    &if trait_number_args != 1 {\n-                                        format!(\"{} parameters\", trait_number_args)\n-                                    } else {\n-                                        format!(\"{} parameter\", trait_number_args)\n-                                    }));\n-        }\n-        err.span_label(impl_span,\n-                       &format!(\"expected {}, found {}\",\n-                                &if trait_number_args != 1 {\n-                                    format!(\"{} parameters\", trait_number_args)\n-                                } else {\n-                                    format!(\"{} parameter\", trait_number_args)\n-                                },\n-                                impl_number_args));\n-        err.emit();\n+    if let Err(ErrorReported) = compare_predicate_entailment(ccx,\n+                                                             impl_m,\n+                                                             impl_m_span,\n+                                                             impl_m_body_id,\n+                                                             trait_m,\n+                                                             impl_trait_ref,\n+                                                             old_broken_mode) {\n         return;\n     }\n+}\n+\n+fn compare_predicate_entailment<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                          impl_m: &ty::Method<'tcx>,\n+                                          impl_m_span: Span,\n+                                          impl_m_body_id: ast::NodeId,\n+                                          trait_m: &ty::Method<'tcx>,\n+                                          impl_trait_ref: &ty::TraitRef<'tcx>,\n+                                          old_broken_mode: bool)\n+                                          -> Result<(), ErrorReported> {\n+    let tcx = ccx.tcx;\n+\n+    let trait_to_impl_substs = &impl_trait_ref.substs;\n \n     // This code is best explained by example. Consider a trait:\n     //\n@@ -304,46 +171,43 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     debug!(\"compare_impl_method: trait_to_skol_substs={:?}\",\n            trait_to_skol_substs);\n \n-    // Check region bounds. FIXME(@jroesch) refactor this away when removing\n-    // ParamBounds.\n-    if !check_region_bounds_on_impl_method(ccx,\n-                                           impl_m_span,\n-                                           impl_m,\n-                                           &trait_m.generics,\n-                                           &impl_m.generics,\n-                                           trait_to_skol_substs,\n-                                           impl_to_skol_substs) {\n-        return;\n-    }\n-\n-        // Create obligations for each predicate declared by the impl\n-        // definition in the context of the trait's parameter\n-        // environment. We can't just use `impl_env.caller_bounds`,\n-        // however, because we want to replace all late-bound regions with\n-        // region variables.\n-        let impl_predicates = tcx.lookup_predicates(impl_m.predicates.parent.unwrap());\n-        let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n-\n-        debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n-\n-        // This is the only tricky bit of the new way we check implementation methods\n-        // We need to build a set of predicates where only the method-level bounds\n-        // are from the trait and we assume all other bounds from the implementation\n-        // to be previously satisfied.\n-        //\n-        // We then register the obligations from the impl_m and check to see\n-        // if all constraints hold.\n-        hybrid_preds.predicates\n-            .extend(trait_m.predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n-\n-        // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n-        // The key step here is to update the caller_bounds's predicates to be\n-        // the new hybrid bounds we computed.\n-        let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n-        let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n-        let trait_param_env = traits::normalize_param_env_or_error(tcx,\n-                                                                   trait_param_env,\n-                                                                   normalize_cause.clone());\n+    // Check region bounds.\n+    check_region_bounds_on_impl_method(ccx,\n+                                       impl_m_span,\n+                                       impl_m,\n+                                       &trait_m.generics,\n+                                       &impl_m.generics,\n+                                       trait_to_skol_substs,\n+                                       impl_to_skol_substs)?;\n+\n+    // Create obligations for each predicate declared by the impl\n+    // definition in the context of the trait's parameter\n+    // environment. We can't just use `impl_env.caller_bounds`,\n+    // however, because we want to replace all late-bound regions with\n+    // region variables.\n+    let impl_predicates = tcx.lookup_predicates(impl_m.predicates.parent.unwrap());\n+    let mut hybrid_preds = impl_predicates.instantiate(tcx, impl_to_skol_substs);\n+\n+    debug!(\"compare_impl_method: impl_bounds={:?}\", hybrid_preds);\n+\n+    // This is the only tricky bit of the new way we check implementation methods\n+    // We need to build a set of predicates where only the method-level bounds\n+    // are from the trait and we assume all other bounds from the implementation\n+    // to be previously satisfied.\n+    //\n+    // We then register the obligations from the impl_m and check to see\n+    // if all constraints hold.\n+    hybrid_preds.predicates\n+                .extend(trait_m.predicates.instantiate_own(tcx, trait_to_skol_substs).predicates);\n+\n+    // Construct trait parameter environment and then shift it into the skolemized viewpoint.\n+    // The key step here is to update the caller_bounds's predicates to be\n+    // the new hybrid bounds we computed.\n+    let normalize_cause = traits::ObligationCause::misc(impl_m_span, impl_m_body_id);\n+    let trait_param_env = impl_param_env.with_caller_bounds(hybrid_preds.predicates);\n+    let trait_param_env = traits::normalize_param_env_or_error(tcx,\n+                                                               trait_param_env,\n+                                                               normalize_cause.clone());\n \n     tcx.infer_ctxt(None, Some(trait_param_env), Reveal::NotSpecializable).enter(|infcx| {\n         let inh = Inherited::new(ccx, infcx);\n@@ -464,14 +328,14 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 })),\n                                 &terr);\n             diag.emit();\n-            return;\n+            return Err(ErrorReported);\n         }\n \n         // Check that all obligations are satisfied by the implementation's\n         // version.\n         if let Err(ref errors) = fulfillment_cx.borrow_mut().select_all_or_error(&infcx) {\n             infcx.report_fulfillment_errors(errors);\n-            return;\n+            return Err(ErrorReported);\n         }\n \n         // Finally, resolve all regions. This catches wily misuses of\n@@ -490,147 +354,351 @@ pub fn compare_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let fcx = FnCtxt::new(&inh, tcx.types.err, impl_m_body_id);\n             fcx.regionck_item(impl_m_body_id, impl_m_span, &[]);\n         }\n-    });\n \n-    fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                                    span: Span,\n-                                                    impl_m: &ty::Method<'tcx>,\n-                                                    trait_generics: &ty::Generics<'tcx>,\n-                                                    impl_generics: &ty::Generics<'tcx>,\n-                                                    trait_to_skol_substs: &Substs<'tcx>,\n-                                                    impl_to_skol_substs: &Substs<'tcx>)\n-                                                    -> bool {\n-\n-        let trait_params = &trait_generics.regions[..];\n-        let impl_params = &impl_generics.regions[..];\n-\n-        debug!(\"check_region_bounds_on_impl_method: \\\n-               trait_generics={:?} \\\n-               impl_generics={:?} \\\n-               trait_to_skol_substs={:?} \\\n-               impl_to_skol_substs={:?}\",\n-               trait_generics,\n-               impl_generics,\n-               trait_to_skol_substs,\n-               impl_to_skol_substs);\n-\n-        // Must have same number of early-bound lifetime parameters.\n-        // Unfortunately, if the user screws up the bounds, then this\n-        // will change classification between early and late.  E.g.,\n-        // if in trait we have `<'a,'b:'a>`, and in impl we just have\n-        // `<'a,'b>`, then we have 2 early-bound lifetime parameters\n-        // in trait but 0 in the impl. But if we report \"expected 2\n-        // but found 0\" it's confusing, because it looks like there\n-        // are zero. Since I don't quite know how to phrase things at\n-        // the moment, give a kind of vague error message.\n-        if trait_params.len() != impl_params.len() {\n-            struct_span_err!(ccx.tcx.sess,\n-                             span,\n-                             E0195,\n-                             \"lifetime parameters or bounds on method `{}` do not match the \\\n-                              trait declaration\",\n-                             impl_m.name)\n-                .span_label(span, &format!(\"lifetimes do not match trait\"))\n-                .emit();\n-            return false;\n+        Ok(())\n+    })\n+}\n+\n+fn check_region_bounds_on_impl_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                span: Span,\n+                                                impl_m: &ty::Method<'tcx>,\n+                                                trait_generics: &ty::Generics<'tcx>,\n+                                                impl_generics: &ty::Generics<'tcx>,\n+                                                trait_to_skol_substs: &Substs<'tcx>,\n+                                                impl_to_skol_substs: &Substs<'tcx>)\n+                                                -> Result<(), ErrorReported> {\n+    let trait_params = &trait_generics.regions[..];\n+    let impl_params = &impl_generics.regions[..];\n+\n+    debug!(\"check_region_bounds_on_impl_method: \\\n+            trait_generics={:?} \\\n+            impl_generics={:?} \\\n+            trait_to_skol_substs={:?} \\\n+            impl_to_skol_substs={:?}\",\n+           trait_generics,\n+           impl_generics,\n+           trait_to_skol_substs,\n+           impl_to_skol_substs);\n+\n+    // Must have same number of early-bound lifetime parameters.\n+    // Unfortunately, if the user screws up the bounds, then this\n+    // will change classification between early and late.  E.g.,\n+    // if in trait we have `<'a,'b:'a>`, and in impl we just have\n+    // `<'a,'b>`, then we have 2 early-bound lifetime parameters\n+    // in trait but 0 in the impl. But if we report \"expected 2\n+    // but found 0\" it's confusing, because it looks like there\n+    // are zero. Since I don't quite know how to phrase things at\n+    // the moment, give a kind of vague error message.\n+    if trait_params.len() != impl_params.len() {\n+        struct_span_err!(ccx.tcx.sess,\n+                         span,\n+                         E0195,\n+                         \"lifetime parameters or bounds on method `{}` do not match the \\\n+                          trait declaration\",\n+                         impl_m.name)\n+            .span_label(span, &format!(\"lifetimes do not match trait\"))\n+            .emit();\n+        return Err(ErrorReported);\n+    }\n+\n+    return Ok(());\n+}\n+\n+fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n+                                                     terr: &TypeError,\n+                                                     origin: TypeOrigin,\n+                                                     impl_m: &ty::Method,\n+                                                     impl_sig: ty::FnSig<'tcx>,\n+                                                     trait_m: &ty::Method,\n+                                                     trait_sig: ty::FnSig<'tcx>)\n+                                                     -> (Span, Option<Span>) {\n+    let tcx = infcx.tcx;\n+    let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n+    let (impl_m_output, impl_m_iter) = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+        ImplItemKind::Method(ref impl_m_sig, _) => {\n+            (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n+        }\n+        _ => bug!(\"{:?} is not a method\", impl_m),\n+    };\n+\n+    match *terr {\n+        TypeError::Mutability => {\n+            if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n+                let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n+                    TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                        trait_m_sig.decl.inputs.iter()\n+                    }\n+                    _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n+                };\n+\n+                impl_m_iter.zip(trait_m_iter)\n+                           .find(|&(ref impl_arg, ref trait_arg)| {\n+                               match (&impl_arg.ty.node, &trait_arg.ty.node) {\n+                                   (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n+                                   (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) => {\n+                                       impl_mt.mutbl != trait_mt.mutbl\n+                                   }\n+                                   _ => false,\n+                               }\n+                           })\n+                           .map(|(ref impl_arg, ref trait_arg)| {\n+                               match (impl_arg.to_self(), trait_arg.to_self()) {\n+                                   (Some(impl_self), Some(trait_self)) => {\n+                                       (impl_self.span, Some(trait_self.span))\n+                                   }\n+                                   (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n+                                   _ => {\n+                                       bug!(\"impl and trait fns have different first args, impl: \\\n+                                             {:?}, trait: {:?}\",\n+                                            impl_arg,\n+                                            trait_arg)\n+                                   }\n+                               }\n+                           })\n+                           .unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n+            } else {\n+                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+            }\n         }\n+        TypeError::Sorts(ExpectedFound { .. }) => {\n+            if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n+                let (trait_m_output, trait_m_iter) =\n+                    match tcx.map.expect_trait_item(trait_m_node_id).node {\n+                        TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                            (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n+                        }\n+                        _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n+                    };\n \n-        return true;\n+                let impl_iter = impl_sig.inputs.iter();\n+                let trait_iter = trait_sig.inputs.iter();\n+                impl_iter.zip(trait_iter)\n+                         .zip(impl_m_iter)\n+                         .zip(trait_m_iter)\n+                         .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n+                             match infcx.sub_types(true, origin, trait_arg_ty, impl_arg_ty) {\n+                                 Ok(_) => None,\n+                                 Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span))),\n+                             }\n+                         })\n+                         .next()\n+                         .unwrap_or_else(|| {\n+                             if infcx.sub_types(false, origin, impl_sig.output, trait_sig.output)\n+                                     .is_err() {\n+                                         (impl_m_output.span(), Some(trait_m_output.span()))\n+                                     } else {\n+                                         (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                                     }\n+                         })\n+            } else {\n+                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+            }\n+        }\n+        _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id)),\n     }\n+}\n \n-    fn extract_spans_for_error_reporting<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n-                                                         terr: &TypeError,\n-                                                         origin: TypeOrigin,\n-                                                         impl_m: &ty::Method,\n-                                                         impl_sig: ty::FnSig<'tcx>,\n-                                                         trait_m: &ty::Method,\n-                                                         trait_sig: ty::FnSig<'tcx>)\n-                                                         -> (Span, Option<Span>) {\n-        let tcx = infcx.tcx;\n+fn compare_self_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                               impl_m: &ty::Method<'tcx>,\n+                               impl_m_span: Span,\n+                               trait_m: &ty::Method<'tcx>)\n+                               -> Result<(), ErrorReported>\n+{\n+    let tcx = ccx.tcx;\n+    // Try to give more informative error messages about self typing\n+    // mismatches.  Note that any mismatch will also be detected\n+    // below, where we construct a canonical function type that\n+    // includes the self parameter as a normal parameter.  It's just\n+    // that the error messages you get out of this code are a bit more\n+    // inscrutable, particularly for cases where one method has no\n+    // self.\n+    match (&trait_m.explicit_self, &impl_m.explicit_self) {\n+        (&ty::ExplicitSelfCategory::Static, &ty::ExplicitSelfCategory::Static) => {}\n+        (&ty::ExplicitSelfCategory::Static, _) => {\n+            let mut err = struct_span_err!(tcx.sess,\n+                                           impl_m_span,\n+                                           E0185,\n+                                           \"method `{}` has a `{}` declaration in the impl, but \\\n+                                            not in the trait\",\n+                                           trait_m.name,\n+                                           impl_m.explicit_self);\n+            err.span_label(impl_m_span,\n+                           &format!(\"`{}` used in impl\", impl_m.explicit_self));\n+            if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n+                err.span_label(span,\n+                               &format!(\"trait declared without `{}`\", impl_m.explicit_self));\n+            }\n+            err.emit();\n+            return Err(ErrorReported);\n+        }\n+        (_, &ty::ExplicitSelfCategory::Static) => {\n+            let mut err = struct_span_err!(tcx.sess,\n+                                           impl_m_span,\n+                                           E0186,\n+                                           \"method `{}` has a `{}` declaration in the trait, but \\\n+                                            not in the impl\",\n+                                           trait_m.name,\n+                                           trait_m.explicit_self);\n+            err.span_label(impl_m_span,\n+                           &format!(\"expected `{}` in impl\", trait_m.explicit_self));\n+            if let Some(span) = tcx.map.span_if_local(trait_m.def_id) {\n+                err.span_label(span, &format!(\"`{}` used in trait\", trait_m.explicit_self));\n+            }\n+            err.emit();\n+            return Err(ErrorReported);\n+        }\n+        _ => {\n+            // Let the type checker catch other errors below\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn compare_number_of_generics<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                        impl_m: &ty::Method<'tcx>,\n+                                        impl_m_span: Span,\n+                                        trait_m: &ty::Method<'tcx>,\n+                                        trait_item_span: Option<Span>)\n+                                        -> Result<(), ErrorReported> {\n+    let tcx = ccx.tcx;\n+    let num_impl_m_type_params = impl_m.generics.types.len();\n+    let num_trait_m_type_params = trait_m.generics.types.len();\n+    if num_impl_m_type_params != num_trait_m_type_params {\n         let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n-        let (impl_m_output, impl_m_iter) = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+        let span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n             ImplItemKind::Method(ref impl_m_sig, _) => {\n-                (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n+                if impl_m_sig.generics.is_parameterized() {\n+                    impl_m_sig.generics.span\n+                } else {\n+                    impl_m_span\n+                }\n             }\n             _ => bug!(\"{:?} is not a method\", impl_m),\n         };\n \n-        match *terr {\n-            TypeError::Mutability => {\n-                if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n-                    let trait_m_iter = match tcx.map.expect_trait_item(trait_m_node_id).node {\n-                        TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n-                            trait_m_sig.decl.inputs.iter()\n-                        }\n-                        _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n-                    };\n+        let mut err = struct_span_err!(tcx.sess,\n+                                       span,\n+                                       E0049,\n+                                       \"method `{}` has {} type parameter{} but its trait \\\n+                                        declaration has {} type parameter{}\",\n+                                       trait_m.name,\n+                                       num_impl_m_type_params,\n+                                       if num_impl_m_type_params == 1 { \"\" } else { \"s\" },\n+                                       num_trait_m_type_params,\n+                                       if num_trait_m_type_params == 1 {\n+                                           \"\"\n+                                       } else {\n+                                           \"s\"\n+                                       });\n \n-                    impl_m_iter.zip(trait_m_iter)\n-                        .find(|&(ref impl_arg, ref trait_arg)| {\n-                            match (&impl_arg.ty.node, &trait_arg.ty.node) {\n-                                (&Ty_::TyRptr(_, ref impl_mt), &Ty_::TyRptr(_, ref trait_mt)) |\n-                                (&Ty_::TyPtr(ref impl_mt), &Ty_::TyPtr(ref trait_mt)) => {\n-                                    impl_mt.mutbl != trait_mt.mutbl\n-                                }\n-                                _ => false,\n-                            }\n-                        })\n-                        .map(|(ref impl_arg, ref trait_arg)| {\n-                            match (impl_arg.to_self(), trait_arg.to_self()) {\n-                                (Some(impl_self), Some(trait_self)) => {\n-                                    (impl_self.span, Some(trait_self.span))\n-                                }\n-                                (None, None) => (impl_arg.ty.span, Some(trait_arg.ty.span)),\n-                                _ => {\n-                                    bug!(\"impl and trait fns have different first args, impl: \\\n-                                          {:?}, trait: {:?}\",\n-                                         impl_arg,\n-                                         trait_arg)\n-                                }\n-                            }\n-                        })\n-                        .unwrap_or((origin.span(), tcx.map.span_if_local(trait_m.def_id)))\n-                } else {\n-                    (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+        let mut suffix = None;\n+\n+        if let Some(span) = trait_item_span {\n+            err.span_label(span,\n+                           &format!(\"expected {}\",\n+                                    &if num_trait_m_type_params != 1 {\n+                                        format!(\"{} type parameters\", num_trait_m_type_params)\n+                                    } else {\n+                                        format!(\"{} type parameter\", num_trait_m_type_params)\n+                                    }));\n+        } else {\n+            suffix = Some(format!(\", expected {}\", num_trait_m_type_params));\n+        }\n+\n+        err.span_label(span,\n+                       &format!(\"found {}{}\",\n+                                &if num_impl_m_type_params != 1 {\n+                                    format!(\"{} type parameters\", num_impl_m_type_params)\n+                                } else {\n+                                    format!(\"1 type parameter\")\n+                                },\n+                                suffix.as_ref().map(|s| &s[..]).unwrap_or(\"\")));\n+\n+        err.emit();\n+\n+        return Err(ErrorReported);\n+    }\n+\n+    Ok(())\n+}\n+\n+fn compare_number_of_method_arguments<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                impl_m: &ty::Method<'tcx>,\n+                                                impl_m_span: Span,\n+                                                trait_m: &ty::Method<'tcx>,\n+                                                trait_item_span: Option<Span>)\n+                                                -> Result<(), ErrorReported> {\n+    let tcx = ccx.tcx;\n+    if impl_m.fty.sig.0.inputs.len() != trait_m.fty.sig.0.inputs.len() {\n+        let trait_number_args = trait_m.fty.sig.0.inputs.len();\n+        let impl_number_args = impl_m.fty.sig.0.inputs.len();\n+        let trait_m_node_id = tcx.map.as_local_node_id(trait_m.def_id);\n+        let trait_span = if let Some(trait_id) = trait_m_node_id {\n+            match tcx.map.expect_trait_item(trait_id).node {\n+                TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n+                    if let Some(arg) = trait_m_sig.decl.inputs.get(if trait_number_args > 0 {\n+                        trait_number_args - 1\n+                    } else {\n+                        0\n+                    }) {\n+                        Some(arg.pat.span)\n+                    } else {\n+                        trait_item_span\n+                    }\n                 }\n+                _ => bug!(\"{:?} is not a method\", impl_m),\n             }\n-            TypeError::Sorts(ExpectedFound { .. }) => {\n-                if let Some(trait_m_node_id) = tcx.map.as_local_node_id(trait_m.def_id) {\n-                    let (trait_m_output, trait_m_iter) =\n-                        match tcx.map.expect_trait_item(trait_m_node_id).node {\n-                            TraitItem_::MethodTraitItem(ref trait_m_sig, _) => {\n-                                (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n-                            }\n-                            _ => bug!(\"{:?} is not a MethodTraitItem\", trait_m),\n-                        };\n-\n-                    let impl_iter = impl_sig.inputs.iter();\n-                    let trait_iter = trait_sig.inputs.iter();\n-                    impl_iter.zip(trait_iter)\n-                        .zip(impl_m_iter)\n-                        .zip(trait_m_iter)\n-                        .filter_map(|(((impl_arg_ty, trait_arg_ty), impl_arg), trait_arg)| {\n-                            match infcx.sub_types(true, origin, trait_arg_ty, impl_arg_ty) {\n-                                Ok(_) => None,\n-                                Err(_) => Some((impl_arg.ty.span, Some(trait_arg.ty.span))),\n-                            }\n-                        })\n-                        .next()\n-                        .unwrap_or_else(|| {\n-                            if infcx.sub_types(false, origin, impl_sig.output, trait_sig.output)\n-                                .is_err() {\n-                                (impl_m_output.span(), Some(trait_m_output.span()))\n-                            } else {\n-                                (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n-                            }\n-                        })\n+        } else {\n+            trait_item_span\n+        };\n+        let impl_m_node_id = tcx.map.as_local_node_id(impl_m.def_id).unwrap();\n+        let impl_span = match tcx.map.expect_impl_item(impl_m_node_id).node {\n+            ImplItemKind::Method(ref impl_m_sig, _) => {\n+                if let Some(arg) = impl_m_sig.decl.inputs.get(if impl_number_args > 0 {\n+                    impl_number_args - 1\n                 } else {\n-                    (origin.span(), tcx.map.span_if_local(trait_m.def_id))\n+                    0\n+                }) {\n+                    arg.pat.span\n+                } else {\n+                    impl_m_span\n                 }\n             }\n-            _ => (origin.span(), tcx.map.span_if_local(trait_m.def_id)),\n+            _ => bug!(\"{:?} is not a method\", impl_m),\n+        };\n+        let mut err = struct_span_err!(tcx.sess,\n+                                       impl_span,\n+                                       E0050,\n+                                       \"method `{}` has {} parameter{} but the declaration in \\\n+                                        trait `{}` has {}\",\n+                                       trait_m.name,\n+                                       impl_number_args,\n+                                       if impl_number_args == 1 { \"\" } else { \"s\" },\n+                                       tcx.item_path_str(trait_m.def_id),\n+                                       trait_number_args);\n+        if let Some(trait_span) = trait_span {\n+            err.span_label(trait_span,\n+                           &format!(\"trait requires {}\",\n+                                    &if trait_number_args != 1 {\n+                                        format!(\"{} parameters\", trait_number_args)\n+                                    } else {\n+                                        format!(\"{} parameter\", trait_number_args)\n+                                    }));\n         }\n+        err.span_label(impl_span,\n+                       &format!(\"expected {}, found {}\",\n+                                &if trait_number_args != 1 {\n+                                    format!(\"{} parameters\", trait_number_args)\n+                                } else {\n+                                    format!(\"{} parameter\", trait_number_args)\n+                                },\n+                                impl_number_args));\n+        err.emit();\n+        return Err(ErrorReported);\n     }\n+\n+    Ok(())\n }\n \n pub fn compare_const_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,"}, {"sha": "9bfe80dba9db15d6b9f5a3a34d74f304f89937ff", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/222349931eec0b0b68b31b2b8b01e162cee23b85/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/222349931eec0b0b68b31b2b8b01e162cee23b85/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=222349931eec0b0b68b31b2b8b01e162cee23b85", "patch": "@@ -369,7 +369,8 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n                       cause: &traits::ObligationCause<'tcx>,\n                       sup_type: Ty<'tcx>)\n                       -> SubregionOrigin<'tcx> {\n-        SubregionOrigin::from_cause(cause, || infer::RelateParamBound(cause.span, sup_type))\n+        SubregionOrigin::from_obligation_cause(cause,\n+                                               || infer::RelateParamBound(cause.span, sup_type))\n     }\n \n     /// This method populates the region map's `free_region_map`. It walks over the transformed"}]}