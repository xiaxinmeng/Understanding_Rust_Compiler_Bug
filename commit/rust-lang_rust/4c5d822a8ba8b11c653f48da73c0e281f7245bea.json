{"sha": "4c5d822a8ba8b11c653f48da73c0e281f7245bea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjNWQ4MjJhOGJhOGIxMWM2NTNmNDhkYTczYzBlMjgxZjcyNDViZWE=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-10T15:58:37Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-11-18T10:55:58Z"}, "message": "resolve: Check resolution consistency for import paths and multi-segment macro paths", "tree": {"sha": "4bcc0140ad72f6122d759f95d19232d14b3e232e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bcc0140ad72f6122d759f95d19232d14b3e232e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c5d822a8ba8b11c653f48da73c0e281f7245bea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c5d822a8ba8b11c653f48da73c0e281f7245bea", "html_url": "https://github.com/rust-lang/rust/commit/4c5d822a8ba8b11c653f48da73c0e281f7245bea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c5d822a8ba8b11c653f48da73c0e281f7245bea/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07af4ec7a20e272713b86b339b99a3ab8e048218", "url": "https://api.github.com/repos/rust-lang/rust/commits/07af4ec7a20e272713b86b339b99a3ab8e048218", "html_url": "https://github.com/rust-lang/rust/commit/07af4ec7a20e272713b86b339b99a3ab8e048218"}], "stats": {"total": 570, "additions": 368, "deletions": 202}, "files": [{"sha": "2ca1ff784351c1dd21cbdb5ab5271a89bc7e3421", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -330,6 +330,7 @@ impl Def {\n         match *self {\n             Def::AssociatedTy(..) | Def::AssociatedConst(..) | Def::AssociatedExistential(..) |\n             Def::Enum(..) | Def::Existential(..) | Def::Err => \"an\",\n+            Def::Macro(.., macro_kind) => macro_kind.article(),\n             _ => \"a\",\n         }\n     }"}, {"sha": "319d63f66c465e6184f63e8ddc905abbd2ce0767", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -225,8 +225,8 @@ pub struct DefId {\n \n impl fmt::Debug for DefId {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"DefId({:?}/{}:{}\",\n-               self.krate.index(),\n+        write!(f, \"DefId({}/{}:{}\",\n+               self.krate,\n                self.index.address_space().index(),\n                self.index.as_array_index())?;\n "}, {"sha": "ff222397e59acd0385e9163e92700dc5e1319db1", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -1025,6 +1025,18 @@ enum ModuleOrUniformRoot<'a> {\n     UniformRoot(UniformRootKind),\n }\n \n+impl<'a> PartialEq for ModuleOrUniformRoot<'a> {\n+    fn eq(&self, other: &Self) -> bool {\n+        match (*self, *other) {\n+            (ModuleOrUniformRoot::Module(lhs), ModuleOrUniformRoot::Module(rhs)) =>\n+                ptr::eq(lhs, rhs),\n+            (ModuleOrUniformRoot::UniformRoot(lhs), ModuleOrUniformRoot::UniformRoot(rhs)) =>\n+                lhs == rhs,\n+            _ => false,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n enum PathResult<'a> {\n     Module(ModuleOrUniformRoot<'a>),\n@@ -1066,9 +1078,10 @@ pub struct ModuleData<'a> {\n     normal_ancestor_id: DefId,\n \n     resolutions: RefCell<FxHashMap<(Ident, Namespace), &'a RefCell<NameResolution<'a>>>>,\n-    legacy_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n-                                           Option<&'a NameBinding<'a>>)>>,\n-    macro_resolutions: RefCell<Vec<(Vec<Segment>, ParentScope<'a>, Span)>>,\n+    single_segment_macro_resolutions: RefCell<Vec<(Ident, MacroKind, ParentScope<'a>,\n+                                                   Option<&'a NameBinding<'a>>)>>,\n+    multi_segment_macro_resolutions: RefCell<Vec<(Vec<Segment>, Span, MacroKind, ParentScope<'a>,\n+                                                  Option<Def>)>>,\n     builtin_attrs: RefCell<Vec<(Ident, ParentScope<'a>)>>,\n \n     // Macro invocations that can expand into items in this module.\n@@ -1106,8 +1119,8 @@ impl<'a> ModuleData<'a> {\n             kind,\n             normal_ancestor_id,\n             resolutions: Default::default(),\n-            legacy_macro_resolutions: RefCell::new(Vec::new()),\n-            macro_resolutions: RefCell::new(Vec::new()),\n+            single_segment_macro_resolutions: RefCell::new(Vec::new()),\n+            multi_segment_macro_resolutions: RefCell::new(Vec::new()),\n             builtin_attrs: RefCell::new(Vec::new()),\n             unresolved_invocations: Default::default(),\n             no_implicit_prelude: false,\n@@ -1503,6 +1516,9 @@ pub struct Resolver<'a, 'b: 'a> {\n     /// The current self item if inside an ADT (used for better errors).\n     current_self_item: Option<NodeId>,\n \n+    /// FIXME: Refactor things so that this is passed through arguments and not resolver.\n+    last_import_segment: bool,\n+\n     /// The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n@@ -1852,6 +1868,7 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n             current_trait_ref: None,\n             current_self_type: None,\n             current_self_item: None,\n+            last_import_segment: false,\n \n             primitive_type_table: PrimitiveTypeTable::new(),\n \n@@ -1953,27 +1970,23 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         self.arenas.alloc_module(module)\n     }\n \n-    fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>)\n-                  -> bool /* true if an error was reported */ {\n+    fn record_use(&mut self, ident: Ident, ns: Namespace, binding: &'a NameBinding<'a>) {\n         match binding.kind {\n-            NameBindingKind::Import { directive, binding, ref used }\n-                    if !used.get() => {\n+            NameBindingKind::Import { directive, binding, ref used } if !used.get() => {\n                 used.set(true);\n                 directive.used.set(true);\n                 self.used_imports.insert((directive.id, ns));\n                 self.add_to_glob_map(directive.id, ident);\n-                self.record_use(ident, ns, binding)\n+                self.record_use(ident, ns, binding);\n             }\n-            NameBindingKind::Import { .. } => false,\n             NameBindingKind::Ambiguity { kind, b1, b2 } => {\n                 self.ambiguity_errors.push(AmbiguityError {\n                     kind, ident, b1, b2,\n                     misc1: AmbiguityErrorMisc::None,\n                     misc2: AmbiguityErrorMisc::None,\n                 });\n-                true\n             }\n-            _ => false\n+            _ => {}\n         }\n     }\n \n@@ -4801,7 +4814,6 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n \n     fn report_errors(&mut self, krate: &Crate) {\n         self.report_with_use_injections(krate);\n-        let mut reported_spans = FxHashSet::default();\n \n         for &(span_use, span_def) in &self.macro_expanded_macro_export_errors {\n             let msg = \"macro-expanded `macro_export` macros from the current crate \\\n@@ -4815,11 +4827,10 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n \n         for ambiguity_error in &self.ambiguity_errors {\n-            if reported_spans.insert(ambiguity_error.ident.span) {\n-                self.report_ambiguity_error(ambiguity_error);\n-            }\n+            self.report_ambiguity_error(ambiguity_error);\n         }\n \n+        let mut reported_spans = FxHashSet::default();\n         for &PrivacyError(dedup_span, ident, binding) in &self.privacy_errors {\n             if reported_spans.insert(dedup_span) {\n                 span_err!(self.session, ident.span, E0603, \"{} `{}` is private\","}, {"sha": "a795ba0e9d15df1481ec7604120a3aa77bd5639d", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 61, "deletions": 52, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -9,8 +9,9 @@\n // except according to those terms.\n \n use {AmbiguityError, AmbiguityKind, AmbiguityErrorMisc};\n-use {CrateLint, DeterminacyExt, Resolver, ResolutionError, is_known_tool, resolve_error};\n+use {CrateLint, DeterminacyExt, Resolver, ResolutionError};\n use {Module, ModuleKind, NameBinding, NameBindingKind, PathResult, ToNameBinding};\n+use {is_known_tool, names_to_string, resolve_error};\n use ModuleOrUniformRoot;\n use Namespace::{self, *};\n use build_reduced_graph::{BuildReducedGraphVisitor, IsMacroExport};\n@@ -480,29 +481,19 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n         if path.len() > 1 {\n             let def = match self.resolve_path(&path, Some(MacroNS), parent_scope,\n                                               false, path_span, CrateLint::No) {\n-                PathResult::NonModule(path_res) => match path_res.base_def() {\n-                    Def::Err => Err(Determinacy::Determined),\n-                    def @ _ => {\n-                        if path_res.unresolved_segments() > 0 {\n-                            self.found_unresolved_macro = true;\n-                            self.session.span_err(path_span,\n-                                                  \"fail to resolve non-ident macro path\");\n-                            Err(Determinacy::Determined)\n-                        } else {\n-                            Ok(def)\n-                        }\n-                    }\n-                },\n-                PathResult::Module(..) => unreachable!(),\n+                PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n+                    Ok(path_res.base_def())\n+                }\n                 PathResult::Indeterminate if !force => return Err(Determinacy::Undetermined),\n-                _ => {\n+                PathResult::NonModule(..) | PathResult::Indeterminate | PathResult::Failed(..) => {\n                     self.found_unresolved_macro = true;\n                     Err(Determinacy::Determined)\n-                },\n+                }\n+                PathResult::Module(..) => unreachable!(),\n             };\n \n-            parent_scope.module.macro_resolutions.borrow_mut()\n-                .push((path, parent_scope.clone(), path_span));\n+            parent_scope.module.multi_segment_macro_resolutions.borrow_mut()\n+                .push((path, path_span, kind, parent_scope.clone(), def.ok()));\n \n             def\n         } else {\n@@ -515,7 +506,7 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                 Err(Determinacy::Undetermined) => return Err(Determinacy::Undetermined),\n             }\n \n-            parent_scope.module.legacy_macro_resolutions.borrow_mut()\n+            parent_scope.module.single_segment_macro_resolutions.borrow_mut()\n                 .push((path[0].ident, kind, parent_scope.clone(), binding.ok()));\n \n             binding.map(|binding| binding.def_ignoring_ambiguity())\n@@ -922,50 +913,68 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n     pub fn finalize_current_module_macro_resolutions(&mut self) {\n         let module = self.current_module;\n \n+        let check_consistency = |this: &mut Self, path: &[Ident], span,\n+                                 kind: MacroKind, initial_def, def| {\n+            if let Some(initial_def) = initial_def {\n+                if def != initial_def && def != Def::Err && this.ambiguity_errors.is_empty() {\n+                    // Make sure compilation does not succeed if preferred macro resolution\n+                    // has changed after the macro had been expanded. In theory all such\n+                    // situations should be reported as ambiguity errors, so this is a bug.\n+                    span_bug!(span, \"inconsistent resolution for a macro\");\n+                }\n+            } else {\n+                // It's possible that the macro was unresolved (indeterminate) and silently\n+                // expanded into a dummy fragment for recovery during expansion.\n+                // Now, post-expansion, the resolution may succeed, but we can't change the\n+                // past and need to report an error.\n+                // However, non-speculative `resolve_path` can successfully return private items\n+                // even if speculative `resolve_path` returned nothing previously, so we skip this\n+                // less informative error if the privacy error is reported elsewhere.\n+                if this.privacy_errors.is_empty() {\n+                    let msg = format!(\"cannot determine resolution for the {} `{}`\",\n+                                        kind.descr(), names_to_string(path));\n+                    let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n+                    this.session.struct_span_err(span, &msg).note(msg_note).emit();\n+                }\n+            }\n+        };\n+\n         let macro_resolutions =\n-            mem::replace(&mut *module.macro_resolutions.borrow_mut(), Vec::new());\n-        for (mut path, parent_scope, path_span) in macro_resolutions {\n+            mem::replace(&mut *module.multi_segment_macro_resolutions.borrow_mut(), Vec::new());\n+        for (mut path, path_span, kind, parent_scope, initial_def) in macro_resolutions {\n             // FIXME: Path resolution will ICE if segment IDs present.\n             for seg in &mut path { seg.id = None; }\n             match self.resolve_path(&path, Some(MacroNS), &parent_scope,\n                                     true, path_span, CrateLint::No) {\n-                PathResult::NonModule(_) => {},\n-                PathResult::Failed(span, msg, _) => {\n+                PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n+                    let def = path_res.base_def();\n+                    check_consistency(self, &path, path_span, kind, initial_def, def);\n+                }\n+                path_res @ PathResult::NonModule(..) | path_res @  PathResult::Failed(..) => {\n+                    let (span, msg) = if let PathResult::Failed(span, msg, ..) = path_res {\n+                        (span, msg)\n+                    } else {\n+                        (path_span, format!(\"partially resolved path in {} {}\",\n+                                            kind.article(), kind.descr()))\n+                    };\n                     resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 }\n-                _ => unreachable!(),\n+                PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n             }\n         }\n \n-        let legacy_macro_resolutions =\n-            mem::replace(&mut *module.legacy_macro_resolutions.borrow_mut(), Vec::new());\n-        for (ident, kind, parent_scope, initial_binding) in legacy_macro_resolutions {\n-            let binding = self.early_resolve_ident_in_lexical_scope(\n-                ident, MacroNS, Some(kind), false, &parent_scope, true, true, ident.span\n-            );\n-            match binding {\n+        let macro_resolutions =\n+            mem::replace(&mut *module.single_segment_macro_resolutions.borrow_mut(), Vec::new());\n+        for (ident, kind, parent_scope, initial_binding) in macro_resolutions {\n+            match self.early_resolve_ident_in_lexical_scope(ident, MacroNS, Some(kind), false,\n+                                                            &parent_scope, true, true, ident.span) {\n                 Ok(binding) => {\n-                    let def = binding.def_ignoring_ambiguity();\n-                    if let Some(initial_binding) = initial_binding {\n+                    let initial_def = initial_binding.map(|initial_binding| {\n                         self.record_use(ident, MacroNS, initial_binding);\n-                        let initial_def = initial_binding.def_ignoring_ambiguity();\n-                        if self.ambiguity_errors.is_empty() &&\n-                           def != initial_def && def != Def::Err {\n-                            // Make sure compilation does not succeed if preferred macro resolution\n-                            // has changed after the macro had been expanded. In theory all such\n-                            // situations should be reported as ambiguity errors, so this is a bug.\n-                            span_bug!(ident.span, \"inconsistent resolution for a macro\");\n-                        }\n-                    } else {\n-                        // It's possible that the macro was unresolved (indeterminate) and silently\n-                        // expanded into a dummy fragment for recovery during expansion.\n-                        // Now, post-expansion, the resolution may succeed, but we can't change the\n-                        // past and need to report an error.\n-                        let msg = format!(\"cannot determine resolution for the {} `{}`\",\n-                                          kind.descr(), ident);\n-                        let msg_note = \"import resolution is stuck, try simplifying macro imports\";\n-                        self.session.struct_span_err(ident.span, &msg).note(msg_note).emit();\n-                    }\n+                        initial_binding.def_ignoring_ambiguity()\n+                    });\n+                    let def = binding.def_ignoring_ambiguity();\n+                    check_consistency(self, &[ident], ident.span, kind, initial_def, def);\n                 }\n                 Err(..) => {\n                     assert!(initial_binding.is_none());"}, {"sha": "d98562db3ec8cf11bee814fa1e3300af44731bff", "filename": "src/librustc_resolve/resolve_imports.rs", "status": "modified", "additions": 110, "deletions": 68, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibrustc_resolve%2Fresolve_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibrustc_resolve%2Fresolve_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fresolve_imports.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -222,40 +222,47 @@ impl<'a, 'crateloader> Resolver<'a, 'crateloader> {\n             }\n         }\n \n-        if record_used {\n-            if let Some(binding) = resolution.binding {\n-                if let Some(shadowed_glob) = resolution.shadowed_glob {\n-                    // Forbid expanded shadowing to avoid time travel.\n-                    if restricted_shadowing &&\n-                       binding.expansion != Mark::root() &&\n-                       binding.def() != shadowed_glob.def() {\n-                        self.ambiguity_errors.push(AmbiguityError {\n-                            kind: AmbiguityKind::GlobVsExpanded,\n-                            ident,\n-                            b1: binding,\n-                            b2: shadowed_glob,\n-                            misc1: AmbiguityErrorMisc::None,\n-                            misc2: AmbiguityErrorMisc::None,\n-                        });\n-                    }\n-                }\n-                if self.record_use(ident, ns, binding) {\n-                    return Ok(self.dummy_binding);\n-                }\n-                if !self.is_accessible(binding.vis) {\n-                    self.privacy_errors.push(PrivacyError(path_span, ident, binding));\n-                }\n-            }\n-\n-            return resolution.binding.ok_or(DeterminacyExt::Determined);\n-        }\n-\n         let check_usable = |this: &mut Self, binding: &'a NameBinding<'a>| {\n-            // `extern crate` are always usable for backwards compatibility, see issue #37020.\n+            // `extern crate` are always usable for backwards compatibility, see issue #37020,\n+            // remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`.\n             let usable = this.is_accessible(binding.vis) || binding.is_extern_crate();\n             if usable { Ok(binding) } else { Err(DeterminacyExt::Determined) }\n         };\n \n+        if record_used {\n+            return resolution.binding.ok_or(DeterminacyExt::Determined).and_then(|binding| {\n+                if self.last_import_segment && check_usable(self, binding).is_err() {\n+                    Err(DeterminacyExt::Determined)\n+                } else {\n+                    self.record_use(ident, ns, binding);\n+\n+                    if let Some(shadowed_glob) = resolution.shadowed_glob {\n+                        // Forbid expanded shadowing to avoid time travel.\n+                        if restricted_shadowing &&\n+                        binding.expansion != Mark::root() &&\n+                        binding.def() != shadowed_glob.def() {\n+                            self.ambiguity_errors.push(AmbiguityError {\n+                                kind: AmbiguityKind::GlobVsExpanded,\n+                                ident,\n+                                b1: binding,\n+                                b2: shadowed_glob,\n+                                misc1: AmbiguityErrorMisc::None,\n+                                misc2: AmbiguityErrorMisc::None,\n+                            });\n+                        }\n+                    }\n+\n+                    if !self.is_accessible(binding.vis) &&\n+                       // Remove this together with `PUB_USE_OF_PRIVATE_EXTERN_CRATE`\n+                       !(self.last_import_segment && binding.is_extern_crate()) {\n+                        self.privacy_errors.push(PrivacyError(path_span, ident, binding));\n+                    }\n+\n+                    Ok(binding)\n+                }\n+            })\n+        }\n+\n         // Items and single imports are not shadowable, if we have one, then it's determined.\n         if let Some(binding) = resolution.binding {\n             if !binding.is_glob_import() {\n@@ -628,8 +635,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         let mut prev_root_id: NodeId = NodeId::from_u32(0);\n         for i in 0 .. self.determined_imports.len() {\n             let import = self.determined_imports[i];\n-            let error = self.finalize_import(import);\n-            if let Some((span, err, note)) = error {\n+            if let Some((span, err, note)) = self.finalize_import(import) {\n                 errors = true;\n \n                 if let SingleImport { source, ref result, .. } = import.subclass {\n@@ -726,7 +732,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n     /// If successful, the resolved bindings are written into the module.\n     fn resolve_import(&mut self, directive: &'b ImportDirective<'b>) -> bool {\n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               Segment::names_to_string(&directive.module_path[..]),\n+               Segment::names_to_string(&directive.module_path),\n                module_to_string(self.current_module).unwrap_or_else(|| \"???\".to_string()));\n \n         self.current_module = directive.parent_scope.module;\n@@ -737,8 +743,8 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n             let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n-            let result = self.resolve_path(\n-                &directive.module_path[..],\n+            let path_res = self.resolve_path(\n+                &directive.module_path,\n                 None,\n                 &directive.parent_scope,\n                 false,\n@@ -747,10 +753,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             );\n             directive.vis.set(orig_vis);\n \n-            match result {\n+            match path_res {\n                 PathResult::Module(module) => module,\n                 PathResult::Indeterminate => return false,\n-                _ => return true,\n+                PathResult::NonModule(..) | PathResult::Failed(..) => return true,\n             }\n         };\n \n@@ -817,25 +823,37 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n         directive: &'b ImportDirective<'b>\n     ) -> Option<(Span, String, Option<String>)> {\n         self.current_module = directive.parent_scope.module;\n-        let ImportDirective { ref module_path, span, .. } = *directive;\n \n-        let module_result = self.resolve_path(\n-            &module_path,\n-            None,\n-            &directive.parent_scope,\n-            true,\n-            span,\n-            directive.crate_lint(),\n-        );\n-        let module = match module_result {\n-            PathResult::Module(module) => module,\n+        let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+        let path_res = self.resolve_path(&directive.module_path, None, &directive.parent_scope,\n+                                         true, directive.span, directive.crate_lint());\n+        directive.vis.set(orig_vis);\n+        let module = match path_res {\n+            PathResult::Module(module) => {\n+                // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n+                if let Some(initial_module) = directive.imported_module.get() {\n+                    if module != initial_module && self.ambiguity_errors.is_empty() {\n+                        span_bug!(directive.span, \"inconsistent resolution for an import\");\n+                    }\n+                } else {\n+                    if self.privacy_errors.is_empty() {\n+                        let msg = \"cannot determine resolution for the import\";\n+                        let msg_note = \"import resolution is stuck, try simplifying other imports\";\n+                        self.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n+                    }\n+                }\n+\n+                module\n+            }\n             PathResult::Failed(span, msg, false) => {\n+                assert!(directive.imported_module.get().is_none());\n                 resolve_error(self, span, ResolutionError::FailedToResolve(&msg));\n                 return None;\n             }\n             PathResult::Failed(span, msg, true) => {\n+                assert!(directive.imported_module.get().is_none());\n                 return if let Some((suggested_path, note)) = self.make_path_suggestion(\n-                    span, module_path.clone(), &directive.parent_scope\n+                    span, directive.module_path.clone(), &directive.parent_scope\n                 ) {\n                     Some((\n                         span,\n@@ -845,17 +863,22 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                 } else {\n                     Some((span, msg, None))\n                 };\n-            },\n-            _ => return None,\n+            }\n+            PathResult::NonModule(path_res) if path_res.base_def() == Def::Err => {\n+                // The error was already reported earlier.\n+                assert!(directive.imported_module.get().is_none());\n+                return None;\n+            }\n+            PathResult::Indeterminate | PathResult::NonModule(..) => unreachable!(),\n         };\n \n         let (ident, result, type_ns_only) = match directive.subclass {\n             SingleImport { source, ref result, type_ns_only, .. } => (source, result, type_ns_only),\n             GlobImport { is_prelude, ref max_vis } => {\n-                if module_path.len() <= 1 {\n+                if directive.module_path.len() <= 1 {\n                     // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n-                    let mut full_path = module_path.clone();\n+                    let mut full_path = directive.module_path.clone();\n                     full_path.push(Segment::from_ident(keywords::Invalid.ident()));\n                     self.lint_if_path_starts_with_module(\n                         directive.crate_lint(),\n@@ -888,20 +911,39 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n \n         let mut all_ns_err = true;\n         self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n-            if let Ok(binding) = result[ns].get() {\n-                all_ns_err = false;\n-                if this.record_use(ident, ns, binding) {\n-                    if let ModuleOrUniformRoot::Module(module) = module {\n-                        this.resolution(module, ident, ns).borrow_mut().binding =\n-                            Some(this.dummy_binding);\n+            let orig_vis = directive.vis.replace(ty::Visibility::Invisible);\n+            let orig_last_import_segment = mem::replace(&mut this.last_import_segment, true);\n+            let binding = this.resolve_ident_in_module(\n+                module, ident, ns, Some(&directive.parent_scope), true, directive.span\n+            );\n+            this.last_import_segment = orig_last_import_segment;\n+            directive.vis.set(orig_vis);\n+\n+            match binding {\n+                Ok(binding) => {\n+                    // Consistency checks, analogous to `finalize_current_module_macro_resolutions`.\n+                    let initial_def = result[ns].get().map(|initial_binding| {\n+                        all_ns_err = false;\n+                        this.record_use(ident, MacroNS, initial_binding);\n+                        initial_binding.def_ignoring_ambiguity()\n+                    });\n+                    let def = binding.def_ignoring_ambiguity();\n+                    if let Ok(initial_def) = initial_def {\n+                        if def != initial_def && this.ambiguity_errors.is_empty() {\n+                            span_bug!(directive.span, \"inconsistent resolution for an import\");\n+                        }\n+                    } else {\n+                        if def != Def::Err &&\n+                           this.ambiguity_errors.is_empty() && this.privacy_errors.is_empty() {\n+                            let msg = \"cannot determine resolution for the import\";\n+                            let msg_note =\n+                                \"import resolution is stuck, try simplifying other imports\";\n+                            this.session.struct_span_err(directive.span, msg).note(msg_note).emit();\n+                        }\n                     }\n                 }\n-                if ns == TypeNS {\n-                    if let ModuleOrUniformRoot::UniformRoot(..) = module {\n-                        // Make sure single-segment import is resolved non-speculatively\n-                        // at least once to report the feature error.\n-                        this.extern_prelude_get(ident, false, false);\n-                    }\n+                Err(..) => {\n+                    assert!(result[ns].get().is_err());\n                 }\n             }\n         });\n@@ -910,7 +952,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             let mut all_ns_failed = true;\n             self.per_ns(|this, ns| if !type_ns_only || ns == TypeNS {\n                 let binding = this.resolve_ident_in_module(\n-                    module, ident, ns, Some(&directive.parent_scope), true, span\n+                    module, ident, ns, Some(&directive.parent_scope), true, directive.span\n                 );\n                 if binding.is_ok() {\n                     all_ns_failed = false;\n@@ -969,7 +1011,7 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n                         }\n                     }\n                 };\n-                Some((span, msg, None))\n+                Some((directive.span, msg, None))\n             } else {\n                 // `resolve_ident_in_module` reported a privacy error.\n                 self.import_dummy_binding(directive);\n@@ -1018,10 +1060,10 @@ impl<'a, 'b:'a, 'c: 'b> ImportResolver<'a, 'b, 'c> {\n             }\n         }\n \n-        if module_path.len() <= 1 {\n+        if directive.module_path.len() <= 1 {\n             // HACK(eddyb) `lint_if_path_starts_with_module` needs at least\n             // 2 segments, so the `resolve_path` above won't trigger it.\n-            let mut full_path = module_path.clone();\n+            let mut full_path = directive.module_path.clone();\n             full_path.push(Segment::from_ident(ident));\n             self.per_ns(|this, ns| {\n                 if let Ok(binding) = result[ns].get() {"}, {"sha": "bb927b62a181ed779e94b8393c4d2e5e4c88f918", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -595,6 +595,13 @@ impl MacroKind {\n             MacroKind::ProcMacroStub => \"crate-local procedural macro\",\n         }\n     }\n+\n+    pub fn article(self) -> &'static str {\n+        match self {\n+            MacroKind::Attr => \"an\",\n+            _ => \"a\",\n+        }\n+    }\n }\n \n /// An enum representing the different kinds of syntax extensions."}, {"sha": "fcba5cb4f07a16c26f0abd27982edbac959a659f", "filename": "src/test/ui/extern/extern-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fextern%2Fextern-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fextern%2Fextern-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-macro.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     enum Foo {}\n-    let _ = Foo::bar!(); //~ ERROR fail to resolve non-ident macro path\n+    let _ = Foo::bar!(); //~ ERROR failed to resolve. partially resolved path in a macro\n }"}, {"sha": "159fefdd2696b96b57f527ac29c8713a162762ad", "filename": "src/test/ui/extern/extern-macro.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fextern%2Fextern-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fextern%2Fextern-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fextern%2Fextern-macro.stderr?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -1,8 +1,9 @@\n-error: fail to resolve non-ident macro path\n+error[E0433]: failed to resolve. partially resolved path in a macro\n   --> $DIR/extern-macro.rs:15:13\n    |\n-LL |     let _ = Foo::bar!(); //~ ERROR fail to resolve non-ident macro path\n-   |             ^^^^^^^^\n+LL |     let _ = Foo::bar!(); //~ ERROR failed to resolve. partially resolved path in a macro\n+   |             ^^^^^^^^ partially resolved path in a macro\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "d9f99aa0119ce91b8b75879b20c0aa834e834397", "filename": "src/test/ui/macros/macro-path-prelude-fail-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -10,7 +10,7 @@\n \n mod m {\n     fn check() {\n-        Result::Ok!(); //~ ERROR fail to resolve non-ident macro path\n+        Result::Ok!(); //~ ERROR failed to resolve. partially resolved path in a macro\n     }\n }\n "}, {"sha": "31e45b320ad73f13f1c83c30fa1150b060f3e769", "filename": "src/test/ui/macros/macro-path-prelude-fail-2.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-path-prelude-fail-2.stderr?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -1,8 +1,9 @@\n-error: fail to resolve non-ident macro path\n+error[E0433]: failed to resolve. partially resolved path in a macro\n   --> $DIR/macro-path-prelude-fail-2.rs:13:9\n    |\n-LL |         Result::Ok!(); //~ ERROR fail to resolve non-ident macro path\n-   |         ^^^^^^^^^^\n+LL |         Result::Ok!(); //~ ERROR failed to resolve. partially resolved path in a macro\n+   |         ^^^^^^^^^^ partially resolved path in a macro\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "1eb49bd530176ea49eb3908ecc6b4eca3105b0cc", "filename": "src/test/ui/privacy/decl-macro.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -0,0 +1,9 @@\n+#![feature(decl_macro)]\n+\n+mod m {\n+    macro mac() {}\n+}\n+\n+fn main() {\n+    m::mac!(); //~ ERROR macro `mac` is private\n+}"}, {"sha": "c8b043d1b5f31f53e8eec683827db3e72134c369", "filename": "src/test/ui/privacy/decl-macro.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fdecl-macro.stderr?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -0,0 +1,9 @@\n+error[E0603]: macro `mac` is private\n+  --> $DIR/decl-macro.rs:8:8\n+   |\n+LL |     m::mac!(); //~ ERROR macro `mac` is private\n+   |        ^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0603`."}, {"sha": "ba44f20facfd209033fe31766be887bf6f96461c", "filename": "src/test/ui/rfc-2126-extern-absolute-paths/non-existent-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2126-extern-absolute-paths%2Fnon-existent-1.stderr?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -2,7 +2,7 @@ error[E0432]: unresolved import `xcrate`\n   --> $DIR/non-existent-1.rs:13:5\n    |\n LL | use xcrate::S; //~ ERROR unresolved import `xcrate`\n-   |     ^^^^^^ Could not find `xcrate` in `{{root}}`\n+   |     ^^^^^^ Use of undeclared type or module `xcrate`\n \n error: aborting due to previous error\n "}, {"sha": "2853b4b3a5b3f6c9dc4c242df7efe5ab3c95b389", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/block-scoped-shadow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -16,6 +16,6 @@ fn main() {\n     fn std() {}\n     enum std {}\n     use std as foo;\n-    //~^ ERROR `std` import is ambiguous\n-    //~| ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n+    //~| ERROR `std` is ambiguous\n }"}, {"sha": "d0e3d002b0885181907d9f3f0124e7ffe37b797f", "filename": "src/test/ui/rust-2018/uniform-paths-forward-compat/block-scoped-shadow.stderr", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths-forward-compat%2Fblock-scoped-shadow.stderr?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -1,31 +1,39 @@\n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/block-scoped-shadow.rs:18:9\n    |\n-LL | struct std;\n-   | ----------- may refer to `self::std` in the future\n-...\n-LL |     enum std {}\n-   |     ----------- shadowed by block-scoped `std`\n LL |     use std as foo;\n-   |         ^^^ can refer to external crate `::std`\n+   |         ^^^ ambiguous name\n    |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+note: `std` could refer to the enum defined here\n+  --> $DIR/block-scoped-shadow.rs:17:5\n+   |\n+LL |     enum std {}\n+   |     ^^^^^^^^^^^\n+note: `std` could also refer to the struct defined here\n+  --> $DIR/block-scoped-shadow.rs:13:1\n+   |\n+LL | struct std;\n+   | ^^^^^^^^^^^\n+   = help: use `self::std` to refer to the struct unambiguously\n \n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/block-scoped-shadow.rs:18:9\n    |\n-LL | struct std;\n-   | ----------- may refer to `self::std` in the future\n-...\n-LL |     fn std() {}\n-   |     ----------- shadowed by block-scoped `std`\n-LL |     enum std {}\n LL |     use std as foo;\n-   |         ^^^\n+   |         ^^^ ambiguous name\n+   |\n+note: `std` could refer to the function defined here\n+  --> $DIR/block-scoped-shadow.rs:16:5\n    |\n-   = help: write `self::std` explicitly instead\n-   = note: in the future, `#![feature(uniform_paths)]` may become the default\n+LL |     fn std() {}\n+   |     ^^^^^^^^^^^\n+note: `std` could also refer to the unit struct defined here\n+  --> $DIR/block-scoped-shadow.rs:13:1\n+   |\n+LL | struct std;\n+   | ^^^^^^^^^^^\n+   = help: use `self::std` to refer to the unit struct unambiguously\n \n error: aborting due to 2 previous errors\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "3f5897901a056b7cb1714f880ebe41222e7d31f8", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow-nested.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -0,0 +1,20 @@\n+// edition:2018\n+\n+mod my {\n+    pub mod sub {\n+        pub fn bar() {}\n+    }\n+}\n+\n+mod sub {\n+    pub fn bar() {}\n+}\n+\n+fn foo() {\n+    use my::sub;\n+    {\n+        use sub::bar; //~ ERROR `sub` is ambiguous\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "32f5cb30177b7d1c51521445d974e5364aa94cb9", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow-nested.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow-nested.stderr?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -0,0 +1,23 @@\n+error[E0659]: `sub` is ambiguous (name vs any other name during import resolution)\n+  --> $DIR/block-scoped-shadow-nested.rs:16:13\n+   |\n+LL |         use sub::bar; //~ ERROR `sub` is ambiguous\n+   |             ^^^ ambiguous name\n+   |\n+note: `sub` could refer to the module imported here\n+  --> $DIR/block-scoped-shadow-nested.rs:14:9\n+   |\n+LL |     use my::sub;\n+   |         ^^^^^^^\n+note: `sub` could also refer to the module defined here\n+  --> $DIR/block-scoped-shadow-nested.rs:9:1\n+   |\n+LL | / mod sub {\n+LL | |     pub fn bar() {}\n+LL | | }\n+   | |_^\n+   = help: use `self::sub` to refer to the module unambiguously\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "36d996fc4f930753dc4f6e73ffcebfb63bfada25", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -12,20 +12,20 @@\n \n #![feature(uniform_paths)]\n \n-enum Foo { A, B }\n+enum Foo {}\n \n struct std;\n \n fn main() {\n-    enum Foo {}\n+    enum Foo { A, B }\n     use Foo::*;\n-    //~^ ERROR `Foo` import is ambiguous\n+    //~^ ERROR `Foo` is ambiguous\n \n     let _ = (A, B);\n \n     fn std() {}\n     enum std {}\n     use std as foo;\n-    //~^ ERROR `std` import is ambiguous\n-    //~| ERROR `std` import is ambiguous\n+    //~^ ERROR `std` is ambiguous\n+    //~| ERROR `std` is ambiguous\n }"}, {"sha": "a1db1c3e0be6c8f3e93912d6e8c4de168cde6454", "filename": "src/test/ui/rust-2018/uniform-paths/block-scoped-shadow.stderr", "status": "modified", "additions": 40, "deletions": 28, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Fblock-scoped-shadow.stderr?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -1,45 +1,57 @@\n-error: `Foo` import is ambiguous\n+error[E0659]: `Foo` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/block-scoped-shadow.rs:21:9\n    |\n-LL | enum Foo { A, B }\n-   | ----------------- can refer to `self::Foo`\n-...\n-LL |     enum Foo {}\n-   |     ----------- shadowed by block-scoped `Foo`\n LL |     use Foo::*;\n-   |         ^^^\n+   |         ^^^ ambiguous name\n    |\n-   = help: write `self::Foo` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+note: `Foo` could refer to the enum defined here\n+  --> $DIR/block-scoped-shadow.rs:20:5\n+   |\n+LL |     enum Foo { A, B }\n+   |     ^^^^^^^^^^^^^^^^^\n+note: `Foo` could also refer to the enum defined here\n+  --> $DIR/block-scoped-shadow.rs:15:1\n+   |\n+LL | enum Foo {}\n+   | ^^^^^^^^^^^\n+   = help: use `self::Foo` to refer to the enum unambiguously\n \n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/block-scoped-shadow.rs:28:9\n    |\n-LL | struct std;\n-   | ----------- can refer to `self::std`\n-...\n-LL |     enum std {}\n-   |     ----------- shadowed by block-scoped `std`\n LL |     use std as foo;\n-   |         ^^^ can refer to external crate `::std`\n+   |         ^^^ ambiguous name\n    |\n-   = help: write `::std` or `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+note: `std` could refer to the enum defined here\n+  --> $DIR/block-scoped-shadow.rs:27:5\n+   |\n+LL |     enum std {}\n+   |     ^^^^^^^^^^^\n+note: `std` could also refer to the struct defined here\n+  --> $DIR/block-scoped-shadow.rs:17:1\n+   |\n+LL | struct std;\n+   | ^^^^^^^^^^^\n+   = help: use `self::std` to refer to the struct unambiguously\n \n-error: `std` import is ambiguous\n+error[E0659]: `std` is ambiguous (name vs any other name during import resolution)\n   --> $DIR/block-scoped-shadow.rs:28:9\n    |\n-LL | struct std;\n-   | ----------- can refer to `self::std`\n-...\n-LL |     fn std() {}\n-   |     ----------- shadowed by block-scoped `std`\n-LL |     enum std {}\n LL |     use std as foo;\n-   |         ^^^\n+   |         ^^^ ambiguous name\n+   |\n+note: `std` could refer to the function defined here\n+  --> $DIR/block-scoped-shadow.rs:26:5\n    |\n-   = help: write `self::std` explicitly instead\n-   = note: relative `use` paths enabled by `#![feature(uniform_paths)]`\n+LL |     fn std() {}\n+   |     ^^^^^^^^^^^\n+note: `std` could also refer to the unit struct defined here\n+  --> $DIR/block-scoped-shadow.rs:17:1\n+   |\n+LL | struct std;\n+   | ^^^^^^^^^^^\n+   = help: use `self::std` to refer to the unit struct unambiguously\n \n error: aborting due to 3 previous errors\n \n+For more information about this error, try `rustc --explain E0659`."}, {"sha": "0c2da1884b758744e4aff57539597b217d0c5a08", "filename": "src/test/ui/rust-2018/uniform-paths/fn-local-enum.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffn-local-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c5d822a8ba8b11c653f48da73c0e281f7245bea/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffn-local-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frust-2018%2Funiform-paths%2Ffn-local-enum.rs?ref=4c5d822a8ba8b11c653f48da73c0e281f7245bea", "patch": "@@ -0,0 +1,13 @@\n+// compile-pass\n+// edition:2018\n+\n+fn main() {\n+    enum E { A, B, C }\n+\n+    use E::*;\n+    match A {\n+        A => {}\n+        B => {}\n+        C => {}\n+    }\n+}"}]}