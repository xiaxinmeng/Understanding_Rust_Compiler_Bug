{"sha": "1c44f852df205ae6d363cc9a2b12f8093b3ed342", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNDRmODUyZGYyMDVhZTZkMzYzY2M5YTJiMTJmODA5M2IzZWQzNDI=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-18T14:28:33Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-20T13:43:19Z"}, "message": "Remove shared root code and assertions from BTree nodes", "tree": {"sha": "7041fa469421af7caf3df701d8b51b97169c6288", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7041fa469421af7caf3df701d8b51b97169c6288"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c44f852df205ae6d363cc9a2b12f8093b3ed342", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c44f852df205ae6d363cc9a2b12f8093b3ed342", "html_url": "https://github.com/rust-lang/rust/commit/1c44f852df205ae6d363cc9a2b12f8093b3ed342", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c44f852df205ae6d363cc9a2b12f8093b3ed342/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e61f126fb48f3f21cc019b7dc005b5287cef79e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e61f126fb48f3f21cc019b7dc005b5287cef79e5", "html_url": "https://github.com/rust-lang/rust/commit/e61f126fb48f3f21cc019b7dc005b5287cef79e5"}], "stats": {"total": 67, "additions": 8, "deletions": 59}, "files": [{"sha": "5530c9593a51a9a9fe64bc8d522b944450c2b750", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 2, "deletions": 51, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1c44f852df205ae6d363cc9a2b12f8093b3ed342/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c44f852df205ae6d363cc9a2b12f8093b3ed342/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=1c44f852df205ae6d363cc9a2b12f8093b3ed342", "patch": "@@ -111,21 +111,6 @@ impl<K, V> LeafNode<K, V> {\n     }\n }\n \n-impl<K, V> NodeHeader<K, V> {\n-    fn is_shared_root(&self) -> bool {\n-        ptr::eq(self, &EMPTY_ROOT_NODE as *const _ as *const _)\n-    }\n-}\n-\n-// We need to implement Sync here in order to make a static instance.\n-unsafe impl Sync for NodeHeader<(), ()> {}\n-\n-// An empty node used as a placeholder for the root node, to avoid allocations.\n-// We use just a header in order to save space, since no operation on an empty tree will\n-// ever take a pointer past the first key.\n-static EMPTY_ROOT_NODE: NodeHeader<(), ()> =\n-    NodeHeader { parent: ptr::null(), parent_idx: MaybeUninit::uninit(), len: 0 };\n-\n /// The underlying representation of internal nodes. As with `LeafNode`s, these should be hidden\n /// behind `BoxedNode`s to prevent dropping uninitialized keys and values. Any pointer to an\n /// `InternalNode` can be directly casted to a pointer to the underlying `LeafNode` portion of the\n@@ -154,8 +139,8 @@ impl<K, V> InternalNode<K, V> {\n }\n \n /// A managed, non-null pointer to a node. This is either an owned pointer to\n-/// `LeafNode<K, V>`, an owned pointer to `InternalNode<K, V>`, or a (not owned)\n-/// pointer to `NodeHeader<(), ()` (more specifically, the pointer to EMPTY_ROOT_NODE).\n+/// `LeafNode<K, V>` or an owned pointer to `InternalNode<K, V>`.\n+///\n /// All of these types have a `NodeHeader<K, V>` prefix, meaning that they have at\n /// least the same size as `NodeHeader<K, V>` and store the same kinds of data at the same\n /// offsets; and they have a pointer alignment at least as large as `NodeHeader<K, V>`'s.\n@@ -196,20 +181,6 @@ unsafe impl<K: Sync, V: Sync> Sync for Root<K, V> {}\n unsafe impl<K: Send, V: Send> Send for Root<K, V> {}\n \n impl<K, V> Root<K, V> {\n-    /// Whether the instance of `Root` wraps a shared, empty root node. If not,\n-    /// the entire tree is uniquely owned by the owner of the `Root` instance.\n-    pub fn is_shared_root(&self) -> bool {\n-        self.as_ref().is_shared_root()\n-    }\n-\n-    /// Returns a shared tree, wrapping a shared root node that is eternally empty.\n-    pub fn shared_empty_root() -> Self {\n-        Root {\n-            node: unsafe { BoxedNode::from_ptr(NonNull::from(&EMPTY_ROOT_NODE).cast()) },\n-            height: 0,\n-        }\n-    }\n-\n     /// Returns a new owned tree, with its own root node that is initially empty.\n     pub fn new_leaf() -> Self {\n         Root { node: BoxedNode::from_leaf(Box::new(unsafe { LeafNode::new() })), height: 0 }\n@@ -245,7 +216,6 @@ impl<K, V> Root<K, V> {\n     /// Adds a new internal node with a single edge, pointing to the previous root, and make that\n     /// new node the root. This increases the height by 1 and is the opposite of `pop_level`.\n     pub fn push_level(&mut self) -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n-        debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n         new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n@@ -381,19 +351,13 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     /// Unsafe because the node must not be the shared root. For more information,\n     /// see the `NodeRef` comments.\n     unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n-        debug_assert!(!self.is_shared_root());\n         self.node.as_ref()\n     }\n \n     fn as_header(&self) -> &NodeHeader<K, V> {\n         unsafe { &*(self.node.as_ptr() as *const NodeHeader<K, V>) }\n     }\n \n-    /// Returns whether the node is the shared, empty root.\n-    pub fn is_shared_root(&self) -> bool {\n-        self.as_header().is_shared_root()\n-    }\n-\n     /// Borrows a view into the keys stored in the node.\n     /// Unsafe because the caller must ensure that the node is not the shared root.\n     pub unsafe fn keys(&self) -> &[K] {\n@@ -464,7 +428,6 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     pub unsafe fn deallocate_and_ascend(\n         self,\n     ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n-        assert!(!self.is_shared_root());\n         let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n@@ -527,14 +490,12 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n     /// Unsafe because the caller must ensure that the node is not the shared root.\n     unsafe fn into_key_slice(self) -> &'a [K] {\n-        debug_assert!(!self.is_shared_root());\n         // We cannot be the shared root, so `as_leaf` is okay.\n         slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len())\n     }\n \n     /// Unsafe because the caller must ensure that the node is not the shared root.\n     unsafe fn into_val_slice(self) -> &'a [V] {\n-        debug_assert!(!self.is_shared_root());\n         // We cannot be the shared root, so `as_leaf` is okay.\n         slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len())\n     }\n@@ -555,7 +516,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     /// Unsafe because the caller must ensure that the node is not the shared root.\n     unsafe fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        debug_assert!(!self.is_shared_root());\n         // We cannot be the shared root, so `as_leaf_mut` is okay.\n         slice::from_raw_parts_mut(\n             MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n@@ -565,7 +525,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     /// Unsafe because the caller must ensure that the node is not the shared root.\n     unsafe fn into_val_slice_mut(mut self) -> &'a mut [V] {\n-        debug_assert!(!self.is_shared_root());\n         slice::from_raw_parts_mut(\n             MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n             self.len(),\n@@ -574,7 +533,6 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     /// Unsafe because the caller must ensure that the node is not the shared root.\n     unsafe fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n-        debug_assert!(!self.is_shared_root());\n         // We cannot use the getters here, because calling the second one\n         // invalidates the reference returned by the first.\n         // More precisely, it is the call to `len` that is the culprit,\n@@ -592,7 +550,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair the end of the node.\n     pub fn push(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -607,7 +564,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Leaf> {\n     /// Adds a key/value pair to the beginning of the node.\n     pub fn push_front(&mut self, key: K, val: V) {\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -624,7 +580,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         let idx = self.len();\n \n@@ -658,7 +613,6 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     pub fn push_front(&mut self, key: K, val: V, edge: Root<K, V>) {\n         assert!(edge.height == self.height - 1);\n         assert!(self.len() < CAPACITY);\n-        debug_assert!(!self.is_shared_root());\n \n         unsafe {\n             slice_insert(self.keys_mut(), 0, key);\n@@ -904,7 +858,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     fn insert_fit(&mut self, key: K, val: V) -> *mut V {\n         // Necessary for correctness, but in a private module\n         debug_assert!(self.node.len() < CAPACITY);\n-        debug_assert!(!self.node.is_shared_root());\n \n         unsafe {\n             slice_insert(self.node.keys_mut(), self.idx, key);\n@@ -1081,7 +1034,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     /// - All the key/value pairs to the right of this handle are put into a newly\n     ///   allocated node.\n     pub fn split(mut self) -> (NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, K, V, Root<K, V>) {\n-        assert!(!self.node.is_shared_root());\n         unsafe {\n             let mut new_node = Box::new(LeafNode::new());\n \n@@ -1113,7 +1065,6 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::KV>\n     pub fn remove(\n         mut self,\n     ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>, K, V) {\n-        assert!(!self.node.is_shared_root());\n         unsafe {\n             let k = slice_remove(self.node.keys_mut(), self.idx);\n             let v = slice_remove(self.node.vals_mut(), self.idx);"}, {"sha": "f9354263864e5e7eecb799c69d69784c1d3d52f3", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1c44f852df205ae6d363cc9a2b12f8093b3ed342/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c44f852df205ae6d363cc9a2b12f8093b3ed342/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=1c44f852df205ae6d363cc9a2b12f8093b3ed342", "patch": "@@ -72,14 +72,12 @@ where\n     // Using `keys()` is fine here even if BorrowType is mutable, as all we return\n     // is an index -- not a reference.\n     let len = node.len();\n-    if len > 0 {\n-        let keys = unsafe { node.keys() }; // safe because a non-empty node cannot be the shared root\n-        for (i, k) in keys.iter().enumerate() {\n-            match key.cmp(k.borrow()) {\n-                Ordering::Greater => {}\n-                Ordering::Equal => return (i, true),\n-                Ordering::Less => return (i, false),\n-            }\n+    let keys = unsafe { node.keys() }; // safe because a non-empty node cannot be the shared root\n+    for (i, k) in keys.iter().enumerate() {\n+        match key.cmp(k.borrow()) {\n+            Ordering::Greater => {}\n+            Ordering::Equal => return (i, true),\n+            Ordering::Less => return (i, false),\n         }\n     }\n     (len, false)"}]}