{"sha": "7820fb5ca99785c4812ad32be80998a2a4fb4213", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4MjBmYjVjYTk5Nzg1YzQ4MTJhZDMyYmU4MDk5OGEyYTRmYjQyMTM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-10T04:31:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-10T04:31:03Z"}, "message": "auto merge of #9062 : blake2-ppc/rust/vec-iterator, r=alexcrichton\n\nVisit the free functions of std::vec and reimplement or remove some. Most prominently, remove `each_permutation` and replace with two iterators, ElementSwaps and Permutations.\r\n\r\nReplace unzip, unzip_slice with an updated `unzip` that works with an iterator argument.\r\n\r\nReplace each_permutation with a Permutation iterator. The new permutation iterator is more efficient since it uses an algorithm that produces permutations in an order where each is only one element swap apart, including swapping back to the original state with one swap at the end.\r\n\r\nUnify the seldomly used functions `build`, `build_sized`, `build_sized_opt` into just one function `build`.\r\n\r\nRemove `equal_sizes`", "tree": {"sha": "cca8e780bad6ed4c09d5a07b914a7102e64eaa74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cca8e780bad6ed4c09d5a07b914a7102e64eaa74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7820fb5ca99785c4812ad32be80998a2a4fb4213", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7820fb5ca99785c4812ad32be80998a2a4fb4213", "html_url": "https://github.com/rust-lang/rust/commit/7820fb5ca99785c4812ad32be80998a2a4fb4213", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7820fb5ca99785c4812ad32be80998a2a4fb4213/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c7c0b41d7b1a3f240301387fa4152a060d532e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c7c0b41d7b1a3f240301387fa4152a060d532e4", "html_url": "https://github.com/rust-lang/rust/commit/8c7c0b41d7b1a3f240301387fa4152a060d532e4"}, {"sha": "c11ee0fb6719e38820762308d67f70cee000bed8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c11ee0fb6719e38820762308d67f70cee000bed8", "html_url": "https://github.com/rust-lang/rust/commit/c11ee0fb6719e38820762308d67f70cee000bed8"}], "stats": {"total": 542, "additions": 268, "deletions": 274}, "files": [{"sha": "f50108d4eae78e8d5592162c00bb308daa3ab472", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=7820fb5ca99785c4812ad32be80998a2a4fb4213", "patch": "@@ -315,11 +315,8 @@ mod test {\n         use std::vec;\n \n         do 1000.times {\n-            let v: ~[u8] = do vec::build |push| {\n-                do task_rng().gen_uint_range(1, 100).times {\n-                    push(random());\n-                }\n-            };\n+            let times = task_rng().gen_uint_range(1, 100);\n+            let v = vec::from_fn(times, |_| random::<u8>());\n             assert_eq!(v.to_base64(STANDARD).from_base64().unwrap(), v);\n         }\n     }"}, {"sha": "9fc29250ed052f79f8ffa53aacded07236d875cd", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=7820fb5ca99785c4812ad32be80998a2a4fb4213", "patch": "@@ -61,7 +61,6 @@ use middle::typeck::infer::{TypeTrace};\n use util::common::indent;\n \n use std::result;\n-use std::vec;\n use syntax::ast::{Onceness, purity};\n use syntax::ast;\n use syntax::opt_vec;\n@@ -88,7 +87,7 @@ pub trait Combine {\n         // future we could allow type parameters to declare a\n         // variance.\n \n-        if vec::same_length(as_, bs) {\n+        if as_.len() == bs.len() {\n             result::fold_(as_.iter().zip(bs.iter())\n                           .map(|(a, b)| eq_tys(self, *a, *b)))\n                 .then(|| Ok(as_.to_owned()))\n@@ -419,7 +418,7 @@ pub fn super_fn_sigs<C:Combine>(\n     this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n \n     fn argvecs<C:Combine>(this: &C, a_args: &[ty::t], b_args: &[ty::t]) -> cres<~[ty::t]> {\n-        if vec::same_length(a_args, b_args) {\n+        if a_args.len() == b_args.len() {\n             result::collect(a_args.iter().zip(b_args.iter())\n                             .map(|(a, b)| this.args(*a, *b)))\n         } else {"}, {"sha": "c14e49f37e5bf0c436e6aa3ed93d07674b287846", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=7820fb5ca99785c4812ad32be80998a2a4fb4213", "patch": "@@ -373,14 +373,12 @@ impl RegionVarBindings {\n \n     pub fn vars_created_since_snapshot(&mut self, snapshot: uint)\n                                        -> ~[RegionVid] {\n-        do vec::build |push| {\n-            for &elt in self.undo_log.slice_from(snapshot).iter() {\n-                match elt {\n-                    AddVar(vid) => push(vid),\n-                    _ => ()\n-                }\n-            }\n-        }\n+        self.undo_log.slice_from(snapshot).iter()\n+            .filter_map(|&elt| match elt {\n+                AddVar(vid) => Some(vid),\n+                _ => None\n+            })\n+            .collect()\n     }\n \n     pub fn tainted(&mut self, snapshot: uint, r0: Region) -> ~[Region] {"}, {"sha": "e6d80e1443bb92cea18a7f06300aed85418690d2", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=7820fb5ca99785c4812ad32be80998a2a4fb4213", "patch": "@@ -112,7 +112,7 @@ pub fn parse_config_(\n     process_output: Process\n ) -> Result<Config, ~str> {\n     let args = args.tail();\n-    let opts = vec::unzip(opts()).first();\n+    let opts = vec::unzip(opts().move_iter()).first();\n     match getopts::getopts(args, opts) {\n         Ok(matches) => {\n             if matches.free.len() == 1 {"}, {"sha": "a4e841f98f804aeff48c21e36a6013f88b64bdae", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 11, "deletions": 43, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=7820fb5ca99785c4812ad32be80998a2a4fb4213", "patch": "@@ -33,62 +33,30 @@ pub fn capacity<T>(v: @[T]) -> uint {\n /**\n  * Builds a vector by calling a provided function with an argument\n  * function that pushes an element to the back of a vector.\n- * This version takes an initial size for the vector.\n+ * The initial size for the vector may optionally be specified\n  *\n  * # Arguments\n  *\n- * * size - An initial size of the vector to reserve\n+ * * size - An option, maybe containing initial size of the vector to reserve\n  * * builder - A function that will construct the vector. It receives\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n #[inline]\n-pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> @[A] {\n+pub fn build<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> @[A] {\n     let mut vec = @[];\n-    unsafe { raw::reserve(&mut vec, size); }\n+    unsafe { raw::reserve(&mut vec, size.unwrap_or_default(4)); }\n     builder(|x| unsafe { raw::push(&mut vec, x) });\n     vec\n }\n \n-/**\n- * Builds a vector by calling a provided function with an argument\n- * function that pushes an element to the back of a vector.\n- *\n- * # Arguments\n- *\n- * * builder - A function that will construct the vector. It receives\n- *             as an argument a function that will push an element\n- *             onto the vector being constructed.\n- */\n-#[inline]\n-pub fn build<A>(builder: &fn(push: &fn(v: A))) -> @[A] {\n-    build_sized(4, builder)\n-}\n-\n-/**\n- * Builds a vector by calling a provided function with an argument\n- * function that pushes an element to the back of a vector.\n- * This version takes an initial size for the vector.\n- *\n- * # Arguments\n- *\n- * * size - An option, maybe containing initial size of the vector to reserve\n- * * builder - A function that will construct the vector. It receives\n- *             as an argument a function that will push an element\n- *             onto the vector being constructed.\n- */\n-#[inline]\n-pub fn build_sized_opt<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> @[A] {\n-    build_sized(size.unwrap_or_default(4), builder)\n-}\n-\n // Appending\n \n /// Iterates over the `rhs` vector, copying each element and appending it to the\n /// `lhs`. Afterwards, the `lhs` is then returned for use again.\n #[inline]\n pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n-    do build_sized(lhs.len() + rhs.len()) |push| {\n+    do build(Some(lhs.len() + rhs.len())) |push| {\n         for x in lhs.iter() {\n             push((*x).clone());\n         }\n@@ -101,7 +69,7 @@ pub fn append<T:Clone>(lhs: @[T], rhs: &[T]) -> @[T] {\n \n /// Apply a function to each element of a vector and return the results\n pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n-    do build_sized(v.len()) |push| {\n+    do build(Some(v.len())) |push| {\n         for elem in v.iter() {\n             push(f(elem));\n         }\n@@ -115,7 +83,7 @@ pub fn map<T, U>(v: &[T], f: &fn(x: &T) -> U) -> @[U] {\n  * to the value returned by the function `op`.\n  */\n pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> @[T] {\n-    do build_sized(n_elts) |push| {\n+    do build(Some(n_elts)) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts { push(op(i)); i += 1u; }\n     }\n@@ -128,7 +96,7 @@ pub fn from_fn<T>(n_elts: uint, op: &fn(uint) -> T) -> @[T] {\n  * to the value `t`.\n  */\n pub fn from_elem<T:Clone>(n_elts: uint, t: T) -> @[T] {\n-    do build_sized(n_elts) |push| {\n+    do build(Some(n_elts)) |push| {\n         let mut i: uint = 0u;\n         while i < n_elts {\n             push(t.clone());\n@@ -312,7 +280,7 @@ mod test {\n     fn test() {\n         // Some code that could use that, then:\n         fn seq_range(lo: uint, hi: uint) -> @[uint] {\n-            do build |push| {\n+            do build(None) |push| {\n                 for i in range(lo, hi) {\n                     push(i);\n                 }\n@@ -359,15 +327,15 @@ mod test {\n     fn bench_build_sized(b: &mut bh) {\n         let len = 64;\n         do b.iter {\n-            build_sized(len, |push| for i in range(0, 1024) { push(i) });\n+            build(Some(len), |push| for i in range(0, 1024) { push(i) });\n         }\n     }\n \n     #[bench]\n     fn bench_build(b: &mut bh) {\n         do b.iter {\n             for i in range(0, 95) {\n-                build(|push| push(i));\n+                build(None, |push| push(i));\n             }\n         }\n     }"}, {"sha": "e9b704c2686fb227ba9a937aa5c9cc3fb719840b", "filename": "src/libstd/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=7820fb5ca99785c4812ad32be80998a2a4fb4213", "patch": "@@ -777,7 +777,7 @@ impl<T:Reader> ReaderUtil for T {\n     }\n \n     fn read_lines(&self) -> ~[~str] {\n-        do vec::build |push| {\n+        do vec::build(None) |push| {\n             do self.each_line |line| {\n                 push(line.to_owned());\n                 true"}, {"sha": "8c55e13ae581943f3bf8d9c0bff3d6bf369aff8a", "filename": "src/libstd/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=7820fb5ca99785c4812ad32be80998a2a4fb4213", "patch": "@@ -148,7 +148,7 @@ mod test {\n         // Unfortunately this does not actually test the block_on early-break\n         // codepath in select -- racing between the sender and the receiver in\n         // separate tasks is necessary to get around the optimistic check.\n-        let (ports, chans) = unzip(from_fn(num_ports, |_| oneshot::<()>()));\n+        let (ports, chans) = unzip(range(0, num_ports).map(|_| oneshot::<()>()));\n         let mut dead_chans = ~[];\n         let mut ports = ports;\n         for (i, chan) in chans.move_iter().enumerate() {\n@@ -165,7 +165,7 @@ mod test {\n \n         // Same thing with streams instead.\n         // FIXME(#7971): This should be in a macro but borrowck isn't smart enough.\n-        let (ports, chans) = unzip(from_fn(num_ports, |_| stream::<()>()));\n+        let (ports, chans) = unzip(range(0, num_ports).map(|_| stream::<()>()));\n         let mut dead_chans = ~[];\n         let mut ports = ports;\n         for (i, chan) in chans.move_iter().enumerate() {\n@@ -209,7 +209,7 @@ mod test {\n         // Sends 10 buffered packets, and uses select to retrieve them all.\n         // Puts the port in a different spot in the vector each time.\n         do run_in_newsched_task {\n-            let (ports, _) = unzip(from_fn(10, |_| stream()));\n+            let (ports, _) = unzip(range(0u, 10).map(|_| stream::<int>()));\n             let (port, chan) = stream();\n             do 10.times { chan.send(31337); }\n             let mut ports = ports;\n@@ -327,7 +327,7 @@ mod test {\n                     let (p,c) = oneshot();\n                     let c = Cell::new(c);\n                     do task::spawn {\n-                        let (dead_ps, dead_cs) = unzip(from_fn(5, |_| oneshot::<()>()));\n+                        let (dead_ps, dead_cs) = unzip(range(0u, 5).map(|_| oneshot::<()>()));\n                         let mut ports = dead_ps;\n                         select(ports); // should get killed; nothing should leak\n                         c.take().send(()); // must not happen"}, {"sha": "1ff5835188650c157bf16a6e2ed59d60cb6f28b6", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 239, "deletions": 207, "changes": 446, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=7820fb5ca99785c4812ad32be80998a2a4fb4213", "patch": "@@ -10,8 +10,9 @@\n \n /*!\n \n-The `vec` module contains useful code to help work with vector values. Vectors are Rust's list\n-type. Vectors contain zero or more values of homogeneous types:\n+The `vec` module contains useful code to help work with vector values.\n+Vectors are Rust's list type. Vectors contain zero or more values of\n+homogeneous types:\n \n ~~~ {.rust}\n let int_vector = [1,2,3];\n@@ -27,32 +28,72 @@ represents iteration over a vector.\n \n ## Traits\n \n-A number of traits that allow you to accomplish tasks with vectors, like the\n-`MutableVector` and `ImmutableVector` traits.\n+A number of traits add methods that allow you to accomplish tasks with vectors.\n+\n+Traits defined for the `&[T]` type (a vector slice), have methods that can be\n+called on either owned vectors, denoted `~[T]`, or on vector slices themselves.\n+These traits include `ImmutableVector`, and `MutableVector` for the `&mut [T]`\n+case.\n+\n+An example is the method `.slice(a, b)` that returns an immutable \"view\" into\n+a vector or a vector slice from the index interval `[a, b)`:\n+\n+~~~ {.rust}\n+let numbers = [0, 1, 2];\n+let last_numbers = numbers.slice(1, 3);\n+// last_numbers is now &[1, 2]\n+~~~\n+\n+Traits defined for the `~[T]` type, like `OwnedVector`, can only be called\n+on such vectors. These methods deal with adding elements or otherwise changing\n+the allocation of the vector.\n+\n+An example is the method `.push(element)` that will add an element at the end\n+of the vector:\n+\n+~~~ {.rust}\n+let mut numbers = ~[0, 1, 2];\n+numbers.push(7);\n+// numbers is now ~[0, 1, 2, 7];\n+~~~\n \n ## Implementations of other traits\n \n-Vectors are a very useful type, and so there's tons of implementations of\n-traits found elsewhere. Some notable examples:\n+Vectors are a very useful type, and so there's several implementations of\n+traits from other modules. Some notable examples:\n \n * `Clone`\n-* `Iterator`\n-* `Zero`\n+* `Eq`, `Ord`, `TotalEq`, `TotalOrd` -- vectors can be compared,\n+  if the element type defines the corresponding trait.\n \n-## Function definitions\n+## Iteration\n+\n+The method `iter()` returns an iteration value for a vector or a vector slice.\n+The iterator yields borrowed pointers to the vector's elements, so if the element\n+type of the vector is `int`, the element type of the iterator is `&int`.\n \n-There are a number of different functions that take vectors, here are some\n-broad categories:\n+~~~ {.rust}\n+let numbers = [0, 1, 2];\n+for &x in numbers.iter() {\n+    println!(\"{} is a number!\", x);\n+}\n+~~~\n+\n+* `.rev_iter()` returns an iterator with the same values as `.iter()`,\n+  but going in the reverse order, starting with the back element.\n+* `.mut_iter()` returns an iterator that allows modifying each value.\n+* `.move_iter()` converts an owned vector into an iterator that\n+  moves out a value from the vector each iteration.\n+* Further iterators exist that split, chunk or permute the vector.\n+\n+## Function definitions\n \n-* Modifying a vector, like `append` and `grow`.\n-* Searching in a vector, like `bsearch`.\n-* Iterating over vectors, like `each_permutation`.\n-* Functional transformations on vectors, like `map` and `partition`.\n-* Stack/queue operations, like `push`/`pop` and `shift`/`unshift`.\n-* Cons-y operations, like `head` and `tail`.\n-* Zipper operations, like `zip` and `unzip`.\n+There are a number of free functions that create or take vectors, for example:\n \n-And much, much more.\n+* Creating a vector, like `from_elem` and `from_fn`\n+* Creating a vector with a given size: `with_capacity`\n+* Modifying a vector and returning it, like `append`\n+* Operations on paired elements, like `unzip`.\n \n */\n \n@@ -82,11 +123,6 @@ use unstable::raw::{Box, Repr, Slice, Vec};\n use vec;\n use util;\n \n-/// Returns true if two vectors have the same length\n-pub fn same_length<T, U>(xs: &[T], ys: &[U]) -> bool {\n-    xs.len() == ys.len()\n-}\n-\n /**\n  * Creates and initializes an owned vector.\n  *\n@@ -158,54 +194,22 @@ pub fn with_capacity<T>(capacity: uint) -> ~[T] {\n /**\n  * Builds a vector by calling a provided function with an argument\n  * function that pushes an element to the back of a vector.\n- * This version takes an initial capacity for the vector.\n+ * The initial capacity for the vector may optionally be specified.\n  *\n  * # Arguments\n  *\n- * * size - An initial size of the vector to reserve\n+ * * size - An option, maybe containing initial size of the vector to reserve\n  * * builder - A function that will construct the vector. It receives\n  *             as an argument a function that will push an element\n  *             onto the vector being constructed.\n  */\n #[inline]\n-pub fn build_sized<A>(size: uint, builder: &fn(push: &fn(v: A))) -> ~[A] {\n-    let mut vec = with_capacity(size);\n+pub fn build<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> ~[A] {\n+    let mut vec = with_capacity(size.unwrap_or_default(4));\n     builder(|x| vec.push(x));\n     vec\n }\n \n-/**\n- * Builds a vector by calling a provided function with an argument\n- * function that pushes an element to the back of a vector.\n- *\n- * # Arguments\n- *\n- * * builder - A function that will construct the vector. It receives\n- *             as an argument a function that will push an element\n- *             onto the vector being constructed.\n- */\n-#[inline]\n-pub fn build<A>(builder: &fn(push: &fn(v: A))) -> ~[A] {\n-    build_sized(4, builder)\n-}\n-\n-/**\n- * Builds a vector by calling a provided function with an argument\n- * function that pushes an element to the back of a vector.\n- * This version takes an initial size for the vector.\n- *\n- * # Arguments\n- *\n- * * size - An option, maybe containing initial size of the vector to reserve\n- * * builder - A function that will construct the vector. It receives\n- *             as an argument a function that will push an element\n- *             onto the vector being constructed.\n- */\n-#[inline]\n-pub fn build_sized_opt<A>(size: Option<uint>, builder: &fn(push: &fn(v: A))) -> ~[A] {\n-    build_sized(size.unwrap_or_default(4), builder)\n-}\n-\n /// An iterator over the slices of a vector separated by elements that\n /// match a predicate function.\n pub struct SplitIterator<'self, T> {\n@@ -389,93 +393,125 @@ impl<'self,T:Clone> VectorVector<T> for &'self [&'self [T]] {\n     }\n }\n \n-// FIXME: if issue #586 gets implemented, could have a postcondition\n-// saying the two result lists have the same length -- or, could\n-// return a nominal record with a constraint saying that, instead of\n-// returning a tuple (contingent on issue #869)\n /**\n- * Convert a vector of pairs into a pair of vectors, by reference. As unzip().\n- */\n-pub fn unzip_slice<T:Clone,U:Clone>(v: &[(T, U)]) -> (~[T], ~[U]) {\n-    let mut ts = ~[];\n-    let mut us = ~[];\n-    for p in v.iter() {\n-        let (t, u) = (*p).clone();\n-        ts.push(t);\n-        us.push(u);\n-    }\n-    (ts, us)\n-}\n-\n-/**\n- * Convert a vector of pairs into a pair of vectors.\n+ * Convert an iterator of pairs into a pair of vectors.\n  *\n  * Returns a tuple containing two vectors where the i-th element of the first\n- * vector contains the first element of the i-th tuple of the input vector,\n+ * vector contains the first element of the i-th tuple of the input iterator,\n  * and the i-th element of the second vector contains the second element\n- * of the i-th tuple of the input vector.\n+ * of the i-th tuple of the input iterator.\n  */\n-pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n-    let mut ts = ~[];\n-    let mut us = ~[];\n-    for p in v.move_iter() {\n-        let (t, u) = p;\n+pub fn unzip<T, U, V: Iterator<(T, U)>>(mut iter: V) -> (~[T], ~[U]) {\n+    let (lo, _) = iter.size_hint();\n+    let mut ts = with_capacity(lo);\n+    let mut us = with_capacity(lo);\n+    for (t, u) in iter {\n         ts.push(t);\n         us.push(u);\n     }\n     (ts, us)\n }\n \n-/**\n- * Iterate over all permutations of vector `v`.\n- *\n- * Permutations are produced in lexicographic order with respect to the order\n- * of elements in `v` (so if `v` is sorted then the permutations are\n- * lexicographically sorted).\n- *\n- * The total number of permutations produced is `v.len()!`.  If `v` contains\n- * repeated elements, then some permutations are repeated.\n- *\n- * See [Algorithms to generate\n- * permutations](http://en.wikipedia.org/wiki/Permutation).\n- *\n- *  # Arguments\n- *\n- *  * `values` - A vector of values from which the permutations are\n- *  chosen\n- *\n- *  * `fun` - The function to iterate over the combinations\n- */\n-pub fn each_permutation<T:Clone>(values: &[T], fun: &fn(perm : &[T]) -> bool) -> bool {\n-    let length = values.len();\n-    let mut permutation = vec::from_fn(length, |i| values[i].clone());\n-    if length <= 1 {\n-        fun(permutation);\n-        return true;\n-    }\n-    let mut indices = vec::from_fn(length, |i| i);\n-    loop {\n-        if !fun(permutation) { return true; }\n-        // find largest k such that indices[k] < indices[k+1]\n-        // if no such k exists, all permutations have been generated\n-        let mut k = length - 2;\n-        while k > 0 && indices[k] >= indices[k+1] {\n-            k -= 1;\n-        }\n-        if k == 0 && indices[0] > indices[1] { return true; }\n-        // find largest l such that indices[k] < indices[l]\n-        // k+1 is guaranteed to be such\n-        let mut l = length - 1;\n-        while indices[k] >= indices[l] {\n-            l -= 1;\n-        }\n-        // swap indices[k] and indices[l]; sort indices[k+1..]\n-        // (they're just reversed)\n-        indices.swap(k, l);\n-        indices.mut_slice(k+1, length).reverse();\n-        // fixup permutation based on indices\n-        for i in range(k, length) {\n-            permutation[i] = values[indices[i]].clone();\n+/// An Iterator that yields the element swaps needed to produce\n+/// a sequence of all possible permutations for an indexed sequence of\n+/// elements. Each permutation is only a single swap apart.\n+///\n+/// The Steinhaus\u2013Johnson\u2013Trotter algorithm is used.\n+///\n+/// Generates even and odd permutations alternatingly.\n+///\n+/// The last generated swap is always (0, 1), and it returns the\n+/// sequence to its initial order.\n+pub struct ElementSwaps {\n+    priv sdir: ~[SizeDirection],\n+    /// If true, emit the last swap that returns the sequence to initial state\n+    priv emit_reset: bool,\n+}\n+\n+impl ElementSwaps {\n+    /// Create an `ElementSwaps` iterator for a sequence of `length` elements\n+    pub fn new(length: uint) -> ElementSwaps {\n+        // Initialize `sdir` with a direction that position should move in\n+        // (all negative at the beginning) and the `size` of the\n+        // element (equal to the original index).\n+        ElementSwaps{\n+            emit_reset: true,\n+            sdir: range(0, length)\n+                    .map(|i| SizeDirection{ size: i, dir: Neg })\n+                    .to_owned_vec()\n+        }\n+    }\n+}\n+\n+enum Direction { Pos, Neg }\n+\n+/// An Index and Direction together\n+struct SizeDirection {\n+    size: uint,\n+    dir: Direction,\n+}\n+\n+impl Iterator<(uint, uint)> for ElementSwaps {\n+    #[inline]\n+    fn next(&mut self) -> Option<(uint, uint)> {\n+        fn new_pos(i: uint, s: Direction) -> uint {\n+            i + match s { Pos => 1, Neg => -1 }\n+        }\n+\n+        // Find the index of the largest mobile element:\n+        // The direction should point into the vector, and the\n+        // swap should be with a smaller `size` element.\n+        let max = self.sdir.iter().map(|&x| x).enumerate()\n+                           .filter(|&(i, sd)|\n+                                new_pos(i, sd.dir) < self.sdir.len() &&\n+                                self.sdir[new_pos(i, sd.dir)].size < sd.size)\n+                           .max_by(|&(_, sd)| sd.size);\n+        match max {\n+            Some((i, sd)) => {\n+                let j = new_pos(i, sd.dir);\n+                self.sdir.swap(i, j);\n+\n+                // Swap the direction of each larger SizeDirection\n+                for x in self.sdir.mut_iter() {\n+                    if x.size > sd.size {\n+                        x.dir = match x.dir { Pos => Neg, Neg => Pos };\n+                    }\n+                }\n+                Some((i, j))\n+            },\n+            None => if self.emit_reset && self.sdir.len() > 1 {\n+                self.emit_reset = false;\n+                Some((0, 1))\n+            } else {\n+                None\n+            }\n+        }\n+    }\n+}\n+\n+/// An Iterator that uses `ElementSwaps` to iterate through\n+/// all possible permutations of a vector.\n+///\n+/// The first iteration yields a clone of the vector as it is,\n+/// then each successive element is the vector with one\n+/// swap applied.\n+///\n+/// Generates even and odd permutations alternatingly.\n+pub struct Permutations<T> {\n+    priv swaps: ElementSwaps,\n+    priv v: ~[T],\n+}\n+\n+impl<T: Clone> Iterator<~[T]> for Permutations<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<~[T]> {\n+        match self.swaps.next() {\n+            None => None,\n+            Some((a, b)) => {\n+                let elt = self.v.clone();\n+                self.v.swap(a, b);\n+                Some(elt)\n+            }\n         }\n     }\n }\n@@ -1159,6 +1195,7 @@ impl<'self, T: TotalOrd> ImmutableTotalOrdVector<T> for &'self [T] {\n pub trait ImmutableCopyableVector<T> {\n     fn partitioned(&self, f: &fn(&T) -> bool) -> (~[T], ~[T]);\n     unsafe fn unsafe_get(&self, elem: uint) -> T;\n+    fn permutations_iter(self) -> Permutations<T>;\n }\n \n /// Extension methods for vectors\n@@ -1188,6 +1225,16 @@ impl<'self,T:Clone> ImmutableCopyableVector<T> for &'self [T] {\n     unsafe fn unsafe_get(&self, index: uint) -> T {\n         (*self.unsafe_ref(index)).clone()\n     }\n+\n+    /// Create an iterator that yields every possible permutation of the\n+    /// vector in succession.\n+    fn permutations_iter(self) -> Permutations<T> {\n+        Permutations{\n+            swaps: ElementSwaps::new(self.len()),\n+            v: self.to_owned(),\n+        }\n+    }\n+\n }\n \n #[allow(missing_doc)]\n@@ -2865,39 +2912,69 @@ mod tests {\n         assert_eq!(v, ~[1, 3, 5]);\n     }\n \n-    #[test]\n-    fn test_each_permutation() {\n-        let mut results: ~[~[int]];\n-\n-        results = ~[];\n-        do each_permutation([]) |v| { results.push(v.to_owned()); true };\n-        assert_eq!(results, ~[~[]]);\n-\n-        results = ~[];\n-        do each_permutation([7]) |v| { results.push(v.to_owned()); true };\n-        assert_eq!(results, ~[~[7]]);\n-\n-        results = ~[];\n-        do each_permutation([1,1]) |v| { results.push(v.to_owned()); true };\n-        assert_eq!(results, ~[~[1,1],~[1,1]]);\n-\n-        results = ~[];\n-        do each_permutation([5,2,0]) |v| { results.push(v.to_owned()); true };\n-        assert!(results ==\n-            ~[~[5,2,0],~[5,0,2],~[2,5,0],~[2,0,5],~[0,5,2],~[0,2,5]]);\n-    }\n-\n     #[test]\n     fn test_zip_unzip() {\n         let z1 = ~[(1, 4), (2, 5), (3, 6)];\n \n-        let (left, right) = unzip(z1);\n+        let (left, right) = unzip(z1.iter().map(|&x| x));\n \n         assert_eq!((1, 4), (left[0], right[0]));\n         assert_eq!((2, 5), (left[1], right[1]));\n         assert_eq!((3, 6), (left[2], right[2]));\n     }\n \n+    #[test]\n+    fn test_element_swaps() {\n+        let mut v = [1, 2, 3];\n+        for (i, (a, b)) in ElementSwaps::new(v.len()).enumerate() {\n+            v.swap(a, b);\n+            match i {\n+                0 => assert_eq!(v, [1, 3, 2]),\n+                1 => assert_eq!(v, [3, 1, 2]),\n+                2 => assert_eq!(v, [3, 2, 1]),\n+                3 => assert_eq!(v, [2, 3, 1]),\n+                4 => assert_eq!(v, [2, 1, 3]),\n+                5 => assert_eq!(v, [1, 2, 3]),\n+                _ => fail!(),\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_permutations() {\n+        use hashmap;\n+        {\n+            let v: [int, ..0] = [];\n+            let mut it = v.permutations_iter();\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            let v = [~\"Hello\"];\n+            let mut it = v.permutations_iter();\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            let v = [1, 2, 3];\n+            let mut it = v.permutations_iter();\n+            assert_eq!(it.next(), Some(~[1,2,3]));\n+            assert_eq!(it.next(), Some(~[1,3,2]));\n+            assert_eq!(it.next(), Some(~[3,1,2]));\n+            assert_eq!(it.next(), Some(~[3,2,1]));\n+            assert_eq!(it.next(), Some(~[2,3,1]));\n+            assert_eq!(it.next(), Some(~[2,1,3]));\n+            assert_eq!(it.next(), None);\n+        }\n+        {\n+            // check that we have N! unique permutations\n+            let mut set = hashmap::HashSet::new();\n+            let v = ['A', 'B', 'C', 'D', 'E', 'F'];\n+            for perm in v.permutations_iter() {\n+                set.insert(perm);\n+            }\n+            assert_eq!(set.len(), 2 * 3 * 4 * 5 * 6);\n+        }\n+    }\n+\n     #[test]\n     fn test_position_elem() {\n         assert!([].position_elem(&1).is_none());\n@@ -3139,7 +3216,7 @@ mod tests {\n     #[test]\n     #[should_fail]\n     fn test_build_fail() {\n-        do build |push| {\n+        do build(None) |push| {\n             push((~0, @0));\n             push((~0, @0));\n             push((~0, @0));\n@@ -3193,13 +3270,12 @@ mod tests {\n     fn test_permute_fail() {\n         let v = [(~0, @0), (~0, @0), (~0, @0), (~0, @0)];\n         let mut i = 0;\n-        do each_permutation(v) |_elt| {\n+        for _ in v.permutations_iter() {\n             if i == 2 {\n                 fail!()\n             }\n             i += 1;\n-            true\n-        };\n+        }\n     }\n \n     #[test]\n@@ -3511,50 +3587,6 @@ mod tests {\n         assert_eq!(values, [1,4,3,2,5]);\n     }\n \n-    #[test]\n-    fn test_permutations0() {\n-        let values = [];\n-        let mut v : ~[~[int]] = ~[];\n-        do each_permutation(values) |p| {\n-            v.push(p.to_owned());\n-            true\n-        };\n-        assert_eq!(v, ~[~[]]);\n-    }\n-\n-    #[test]\n-    fn test_permutations1() {\n-        let values = [1];\n-        let mut v : ~[~[int]] = ~[];\n-        do each_permutation(values) |p| {\n-            v.push(p.to_owned());\n-            true\n-        };\n-        assert_eq!(v, ~[~[1]]);\n-    }\n-\n-    #[test]\n-    fn test_permutations2() {\n-        let values = [1,2];\n-        let mut v : ~[~[int]] = ~[];\n-        do each_permutation(values) |p| {\n-            v.push(p.to_owned());\n-            true\n-        };\n-        assert_eq!(v, ~[~[1,2],~[2,1]]);\n-    }\n-\n-    #[test]\n-    fn test_permutations3() {\n-        let values = [1,2,3];\n-        let mut v : ~[~[int]] = ~[];\n-        do each_permutation(values) |p| {\n-            v.push(p.to_owned());\n-            true\n-        };\n-        assert_eq!(v, ~[~[1,2,3],~[1,3,2],~[2,1,3],~[2,3,1],~[3,1,2],~[3,2,1]]);\n-    }\n-\n     #[test]\n     fn test_vec_zero() {\n         use num::Zero;"}, {"sha": "8221be1bbcb62110bb3ba753e18171f614403318", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=7820fb5ca99785c4812ad32be80998a2a4fb4213", "patch": "@@ -958,7 +958,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n     // struct_type is definitely not Unknown, since struct_def.fields\n     // must be nonempty to reach here\n     let pattern = if struct_type == Record {\n-        let field_pats = do vec::build |push| {\n+        let field_pats = do vec::build(None) |push| {\n             for (&pat, &(id, _)) in subpats.iter().zip(ident_expr.iter()) {\n                 // id is guaranteed to be Some\n                 push(ast::FieldPat { ident: id.unwrap(), pat: pat })"}, {"sha": "3c4c4889ba2f81c6a6f1c100a7ad405797dea275", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7820fb5ca99785c4812ad32be80998a2a4fb4213/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=7820fb5ca99785c4812ad32be80998a2a4fb4213", "patch": "@@ -66,7 +66,7 @@ impl Drop for AsciiArt {\n fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt {\n     // Use an anonymous function to build a vector of vectors containing\n     // blank characters for each position in our canvas.\n-    let lines = do vec::build_sized(height) |push| {\n+    let lines = do vec::build(Some(height)) |push| {\n             do height.times {\n                 push(vec::from_elem(width, '.'));\n             }"}]}