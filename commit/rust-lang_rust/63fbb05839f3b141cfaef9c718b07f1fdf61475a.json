{"sha": "63fbb05839f3b141cfaef9c718b07f1fdf61475a", "node_id": "C_kwDOAAsO6NoAKDYzZmJiMDU4MzlmM2IxNDFjZmFlZjljNzE4YjA3ZjFmZGY2MTQ3NWE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-04-27T13:10:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-27T13:10:54Z"}, "message": "Rollup merge of #110816 - clubby789:rustc-passes-diagnostics, r=compiler-errors\n\nMigrate `rustc_passes` to translatable diagnostics\n\ncc #100717", "tree": {"sha": "ba7d13e317500fc56d1c92decfb39f81a0e83240", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ba7d13e317500fc56d1c92decfb39f81a0e83240"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63fbb05839f3b141cfaef9c718b07f1fdf61475a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkSnReCRBK7hj4Ov3rIwAAlUYIAHblnarbSWwSNP6Q1Y3s6QRj\n/szoTlWB7/pFcGy9yvJraG6JC3pXeEGoOhXX2Ju1xMMAmBO7Q4MiHbvHhID5YSSa\n6QuWVuWEfD6Vq49hRC2giql+C64E9nq2VOaJt6gIzKCMmA8i0txWgUOG/czjAiL1\n8SGB86BmzByJMdEr5yxPf+RthJKjd+ff/z0Slywnb2//PSRGQLuZbhVP5/xTOKQh\n8CabfQORb+NYuOGz/+pcpizumt7MmWvgLbgj9AYpnkID4XbzIQUFd6GtPXdrmGw2\nf+EsSq2N4pbgaB0zXh6zyyuZNTWgT9CKAGnWFQknFA6FyrlmN7ZWZOvFR7QSbm8=\n=NxR4\n-----END PGP SIGNATURE-----\n", "payload": "tree ba7d13e317500fc56d1c92decfb39f81a0e83240\nparent b1ff6e3e10d3cbb93c6492e7c5f3b61008dea0d9\nparent 6a41cfe0958cce1fa97ebc173d591129add78f79\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1682601054 +0200\ncommitter GitHub <noreply@github.com> 1682601054 +0200\n\nRollup merge of #110816 - clubby789:rustc-passes-diagnostics, r=compiler-errors\n\nMigrate `rustc_passes` to translatable diagnostics\n\ncc #100717\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63fbb05839f3b141cfaef9c718b07f1fdf61475a", "html_url": "https://github.com/rust-lang/rust/commit/63fbb05839f3b141cfaef9c718b07f1fdf61475a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63fbb05839f3b141cfaef9c718b07f1fdf61475a/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1ff6e3e10d3cbb93c6492e7c5f3b61008dea0d9", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ff6e3e10d3cbb93c6492e7c5f3b61008dea0d9", "html_url": "https://github.com/rust-lang/rust/commit/b1ff6e3e10d3cbb93c6492e7c5f3b61008dea0d9"}, {"sha": "6a41cfe0958cce1fa97ebc173d591129add78f79", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a41cfe0958cce1fa97ebc173d591129add78f79", "html_url": "https://github.com/rust-lang/rust/commit/6a41cfe0958cce1fa97ebc173d591129add78f79"}], "stats": {"total": 493, "additions": 313, "deletions": 180}, "files": [{"sha": "406801506013b0174ebe295279fbdaffd4fe4836", "filename": "compiler/rustc_passes/messages.ftl", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fmessages.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fmessages.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fmessages.ftl?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -139,7 +139,6 @@ passes_doc_attr_not_crate_level =\n passes_attr_crate_level =\n     this attribute can only be applied at the crate level\n     .suggestion = to apply to the crate, use an inner attribute\n-    .help = to apply to the crate, use an inner attribute\n     .note = read <https://doc.rust-lang.org/nightly/rustdoc/the-doc-attribute.html#at-the-crate-level> for more information\n \n passes_doc_test_unknown =\n@@ -724,3 +723,45 @@ passes_skipping_const_checks = skipping const checks\n passes_invalid_macro_export_arguments = `{$name}` isn't a valid `#[macro_export]` argument\n \n passes_invalid_macro_export_arguments_too_many_items = `#[macro_export]` can only take 1 or 0 arguments\n+\n+passes_unreachable_due_to_uninhabited = unreachable {$descr}\n+    .label = unreachable {$descr}\n+    .label_orig = any code following this expression is unreachable\n+    .note = this expression has type `{$ty}`, which is uninhabited\n+\n+passes_unused_var_maybe_capture_ref = unused variable: `{$name}`\n+    .help = did you mean to capture by reference instead?\n+\n+passes_unused_capture_maybe_capture_ref = value captured by `{$name}` is never read\n+    .help = did you mean to capture by reference instead?\n+\n+passes_unused_var_remove_field = unused variable: `{$name}`\n+passes_unused_var_remove_field_suggestion = try removing the field\n+\n+passes_unused_var_assigned_only = variable `{$name}` is assigned to, but never used\n+    .note = consider using `_{$name}` instead\n+\n+passes_unnecessary_stable_feature = the feature `{$feature}` has been stable since {$since} and no longer requires an attribute to enable\n+\n+passes_unnecessary_partial_stable_feature = the feature `{$feature}` has been partially stabilized since {$since} and is succeeded by the feature `{$implies}`\n+    .suggestion = if you are using features which are still unstable, change to using `{$implies}`\n+    .suggestion_remove = if you are using features which are now stable, remove this line\n+\n+passes_ineffective_unstable_impl = an `#[unstable]` annotation here has no effect\n+    .note = see issue #55436 <https://github.com/rust-lang/rust/issues/55436> for more information\n+\n+passes_unused_assign = value assigned to `{$name}` is never read\n+    .help = maybe it is overwritten before being read?\n+\n+passes_unused_assign_passed = value passed to `{$name}` is never read\n+    .help = maybe it is overwritten before being read?\n+\n+passes_maybe_string_interpolation = you might have meant to use string interpolation in this string literal\n+passes_string_interpolation_only_works = string interpolation only works in `format!` invocations\n+\n+passes_unused_variable_try_prefix = unused variable: `{$name}`\n+    .label = unused variable\n+    .suggestion = if this is intentional, prefix it with an underscore\n+\n+passes_unused_variable_try_ignore = unused variable: `{$name}`\n+    .suggestion = try ignoring the field"}, {"sha": "3f28ac26f8617c6adb43cee80a7518ea597a8cef", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -29,7 +29,7 @@ use rustc_session::lint::builtin::{\n };\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::{kw, sym, Symbol};\n-use rustc_span::{Span, DUMMY_SP};\n+use rustc_span::{BytePos, Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::infer::{TyCtxtInferExt, ValuePairs};\n use rustc_trait_selection::traits::error_reporting::TypeErrCtxtExt;\n@@ -927,30 +927,18 @@ impl CheckAttrVisitor<'_> {\n         hir_id: HirId,\n     ) -> bool {\n         if hir_id != CRATE_HIR_ID {\n-            self.tcx.struct_span_lint_hir(\n+            // insert a bang between `#` and `[...`\n+            let bang_span = attr.span.lo() + BytePos(1);\n+            let sugg = (attr.style == AttrStyle::Outer\n+                && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID)\n+                .then_some(errors::AttrCrateLevelOnlySugg {\n+                    attr: attr.span.with_lo(bang_span).with_hi(bang_span),\n+                });\n+            self.tcx.emit_spanned_lint(\n                 INVALID_DOC_ATTRIBUTES,\n                 hir_id,\n                 meta.span(),\n-                fluent::passes_attr_crate_level,\n-                |err| {\n-                    if attr.style == AttrStyle::Outer\n-                        && self.tcx.hir().get_parent_item(hir_id) == CRATE_OWNER_ID\n-                    {\n-                        if let Ok(mut src) = self.tcx.sess.source_map().span_to_snippet(attr.span) {\n-                            src.insert(1, '!');\n-                            err.span_suggestion_verbose(\n-                                attr.span,\n-                                fluent::passes_suggestion,\n-                                src,\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        } else {\n-                            err.span_help(attr.span, fluent::passes_help);\n-                        }\n-                    }\n-                    err.note(fluent::passes_note);\n-                    err\n-                },\n+                errors::AttrCrateLevelOnly { sugg },\n             );\n             return false;\n         }"}, {"sha": "99fc69d1bec7b842cc2fd55928e40f57fc03df43", "filename": "compiler/rustc_passes/src/errors.rs", "status": "modified", "additions": 159, "deletions": 1, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Ferrors.rs?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -6,7 +6,8 @@ use std::{\n use crate::fluent_generated as fluent;\n use rustc_ast::Label;\n use rustc_errors::{\n-    error_code, Applicability, DiagnosticSymbolList, ErrorGuaranteed, IntoDiagnostic, MultiSpan,\n+    error_code, AddToDiagnostic, Applicability, Diagnostic, DiagnosticSymbolList, ErrorGuaranteed,\n+    IntoDiagnostic, MultiSpan,\n };\n use rustc_hir::{self as hir, ExprKind, Target};\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n@@ -1555,3 +1556,160 @@ pub struct SkippingConstChecks {\n     #[primary_span]\n     pub span: Span,\n }\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unreachable_due_to_uninhabited)]\n+pub struct UnreachableDueToUninhabited<'desc, 'tcx> {\n+    pub descr: &'desc str,\n+    #[label]\n+    pub expr: Span,\n+    #[label(passes_label_orig)]\n+    #[note]\n+    pub orig: Span,\n+    pub ty: Ty<'tcx>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_var_maybe_capture_ref)]\n+#[help]\n+pub struct UnusedVarMaybeCaptureRef {\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_capture_maybe_capture_ref)]\n+#[help]\n+pub struct UnusedCaptureMaybeCaptureRef {\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_var_remove_field)]\n+pub struct UnusedVarRemoveField {\n+    pub name: String,\n+    #[subdiagnostic]\n+    pub sugg: UnusedVarRemoveFieldSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(\n+    passes_unused_var_remove_field_suggestion,\n+    applicability = \"machine-applicable\"\n+)]\n+pub struct UnusedVarRemoveFieldSugg {\n+    #[suggestion_part(code = \"\")]\n+    pub spans: Vec<Span>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_var_assigned_only)]\n+#[note]\n+pub struct UnusedVarAssignedOnly {\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unnecessary_stable_feature)]\n+pub struct UnnecessaryStableFeature {\n+    pub feature: Symbol,\n+    pub since: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unnecessary_partial_stable_feature)]\n+pub struct UnnecessaryPartialStableFeature {\n+    #[suggestion(code = \"{implies}\", applicability = \"maybe-incorrect\")]\n+    pub span: Span,\n+    #[suggestion(passes_suggestion_remove, code = \"\", applicability = \"maybe-incorrect\")]\n+    pub line: Span,\n+    pub feature: Symbol,\n+    pub since: Symbol,\n+    pub implies: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_ineffective_unstable_impl)]\n+#[note]\n+pub struct IneffectiveUnstableImpl;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_assign)]\n+#[help]\n+pub struct UnusedAssign {\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_assign_passed)]\n+#[help]\n+pub struct UnusedAssignPassed {\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_variable_try_prefix)]\n+pub struct UnusedVariableTryPrefix {\n+    #[label]\n+    pub label: Option<Span>,\n+    #[subdiagnostic]\n+    pub string_interp: Vec<UnusedVariableStringInterp>,\n+    #[subdiagnostic]\n+    pub sugg: UnusedVariableTryPrefixSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(passes_suggestion, applicability = \"machine-applicable\")]\n+pub struct UnusedVariableTryPrefixSugg {\n+    #[suggestion_part(code = \"_{name}\")]\n+    pub spans: Vec<Span>,\n+    pub name: String,\n+}\n+\n+pub struct UnusedVariableStringInterp {\n+    pub lit: Span,\n+    pub lo: Span,\n+    pub hi: Span,\n+}\n+\n+impl AddToDiagnostic for UnusedVariableStringInterp {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut Diagnostic, _: F) {\n+        diag.span_label(self.lit, crate::fluent_generated::passes_maybe_string_interpolation);\n+        diag.multipart_suggestion(\n+            crate::fluent_generated::passes_string_interpolation_only_works,\n+            vec![(self.lo, String::from(\"format!(\")), (self.hi, String::from(\")\"))],\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_unused_variable_try_ignore)]\n+pub struct UnusedVarTryIgnore {\n+    #[subdiagnostic]\n+    pub sugg: UnusedVarTryIgnoreSugg,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[multipart_suggestion(passes_suggestion, applicability = \"machine-applicable\")]\n+pub struct UnusedVarTryIgnoreSugg {\n+    #[suggestion_part(code = \"{name}: _\")]\n+    pub shorthands: Vec<Span>,\n+    #[suggestion_part(code = \"_\")]\n+    pub non_shorthands: Vec<Span>,\n+    pub name: String,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(passes_attr_crate_level)]\n+#[note]\n+pub struct AttrCrateLevelOnly {\n+    #[subdiagnostic]\n+    pub sugg: Option<AttrCrateLevelOnlySugg>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[suggestion(passes_suggestion, applicability = \"maybe-incorrect\", code = \"!\", style = \"verbose\")]\n+pub struct AttrCrateLevelOnlySugg {\n+    #[primary_span]\n+    pub attr: Span,\n+}"}, {"sha": "8b7338e29aa07e0c8c6e7900793807f40bb07fbc", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -12,6 +12,8 @@\n #![feature(min_specialization)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n \n #[macro_use]\n extern crate rustc_middle;"}, {"sha": "6758024419d3119fbcf804588cf855cfec74c04d", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 80, "deletions": 124, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -81,13 +81,13 @@\n //! We generate various special nodes for various, well, special purposes.\n //! These are described in the `Liveness` struct.\n \n+use crate::errors;\n+\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n use rustc_ast::InlineAsmOptions;\n use rustc_data_structures::fx::FxIndexMap;\n-use rustc_errors::Applicability;\n-use rustc_errors::Diagnostic;\n use rustc_hir as hir;\n use rustc_hir::def::*;\n use rustc_hir::def_id::LocalDefId;\n@@ -1297,13 +1297,13 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         self.exit_ln\n     }\n \n-    fn warn_about_unreachable(\n+    fn warn_about_unreachable<'desc>(\n         &mut self,\n         orig_span: Span,\n         orig_ty: Ty<'tcx>,\n         expr_span: Span,\n         expr_id: HirId,\n-        descr: &str,\n+        descr: &'desc str,\n     ) {\n         if !orig_ty.is_never() {\n             // Unreachable code warnings are already emitted during type checking.\n@@ -1316,22 +1316,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             // that we do not emit the same warning twice if the uninhabited type\n             // is indeed `!`.\n \n-            let msg = format!(\"unreachable {}\", descr);\n-            self.ir.tcx.struct_span_lint_hir(\n+            self.ir.tcx.emit_spanned_lint(\n                 lint::builtin::UNREACHABLE_CODE,\n                 expr_id,\n                 expr_span,\n-                &msg,\n-                |diag| {\n-                    diag.span_label(expr_span, &msg)\n-                        .span_label(orig_span, \"any code following this expression is unreachable\")\n-                        .span_note(\n-                            orig_span,\n-                            &format!(\n-                                \"this expression has type `{}`, which is uninhabited\",\n-                                orig_ty\n-                            ),\n-                        )\n+                errors::UnreachableDueToUninhabited {\n+                    expr: expr_span,\n+                    orig: orig_span,\n+                    descr,\n+                    ty: orig_ty,\n                 },\n             );\n         }\n@@ -1483,23 +1476,21 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 if self.used_on_entry(entry_ln, var) {\n                     if !self.live_on_entry(entry_ln, var) {\n                         if let Some(name) = self.should_warn(var) {\n-                            self.ir.tcx.struct_span_lint_hir(\n+                            self.ir.tcx.emit_spanned_lint(\n                                 lint::builtin::UNUSED_ASSIGNMENTS,\n                                 var_hir_id,\n                                 vec![span],\n-                                format!(\"value captured by `{}` is never read\", name),\n-                                |lint| lint.help(\"did you mean to capture by reference instead?\"),\n+                                errors::UnusedCaptureMaybeCaptureRef { name },\n                             );\n                         }\n                     }\n                 } else {\n                     if let Some(name) = self.should_warn(var) {\n-                        self.ir.tcx.struct_span_lint_hir(\n+                        self.ir.tcx.emit_spanned_lint(\n                             lint::builtin::UNUSED_VARIABLES,\n                             var_hir_id,\n                             vec![span],\n-                            format!(\"unused variable: `{}`\", name),\n-                            |lint| lint.help(\"did you mean to capture by reference instead?\"),\n+                            errors::UnusedVarMaybeCaptureRef { name },\n                         );\n                     }\n                 }\n@@ -1514,11 +1505,14 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 Some(entry_ln),\n                 Some(body),\n                 |spans, hir_id, ln, var| {\n-                    if !self.live_on_entry(ln, var) {\n-                        self.report_unused_assign(hir_id, spans, var, |name| {\n-                            format!(\"value passed to `{}` is never read\", name)\n-                        });\n-                    }\n+                    if !self.live_on_entry(ln, var)\n+                        && let Some(name) = self.should_warn(var) {\n+                            self.ir.tcx.emit_spanned_lint(\n+                                lint::builtin::UNUSED_ASSIGNMENTS,\n+                                hir_id,\n+                                spans,\n+                                errors::UnusedAssignPassed { name },\n+                            );                    }\n                 },\n             );\n         }\n@@ -1587,39 +1581,35 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 if ln == self.exit_ln { false } else { self.assigned_on_exit(ln, var) };\n \n             if is_assigned {\n-                self.ir.tcx.struct_span_lint_hir(\n+                self.ir.tcx.emit_spanned_lint(\n                     lint::builtin::UNUSED_VARIABLES,\n                     first_hir_id,\n                     hir_ids_and_spans\n                         .into_iter()\n                         .map(|(_, _, ident_span)| ident_span)\n                         .collect::<Vec<_>>(),\n-                    format!(\"variable `{}` is assigned to, but never used\", name),\n-                    |lint| lint.note(&format!(\"consider using `_{}` instead\", name)),\n+                    errors::UnusedVarAssignedOnly { name },\n                 )\n             } else if can_remove {\n-                self.ir.tcx.struct_span_lint_hir(\n+                let spans = hir_ids_and_spans\n+                    .iter()\n+                    .map(|(_, pat_span, _)| {\n+                        let span = self\n+                            .ir\n+                            .tcx\n+                            .sess\n+                            .source_map()\n+                            .span_extend_to_next_char(*pat_span, ',', true);\n+                        span.with_hi(BytePos(span.hi().0 + 1))\n+                    })\n+                    .collect();\n+                self.ir.tcx.emit_spanned_lint(\n                     lint::builtin::UNUSED_VARIABLES,\n                     first_hir_id,\n                     hir_ids_and_spans.iter().map(|(_, pat_span, _)| *pat_span).collect::<Vec<_>>(),\n-                    format!(\"unused variable: `{}`\", name),\n-                    |lint| {\n-                        lint.multipart_suggestion(\n-                            \"try removing the field\",\n-                            hir_ids_and_spans\n-                                .iter()\n-                                .map(|(_, pat_span, _)| {\n-                                    let span = self\n-                                        .ir\n-                                        .tcx\n-                                        .sess\n-                                        .source_map()\n-                                        .span_extend_to_next_char(*pat_span, ',', true);\n-                                    (span.with_hi(BytePos(span.hi().0 + 1)), String::new())\n-                                })\n-                                .collect(),\n-                            Applicability::MachineApplicable,\n-                        )\n+                    errors::UnusedVarRemoveField {\n+                        name,\n+                        sugg: errors::UnusedVarRemoveFieldSugg { spans },\n                     },\n                 );\n             } else {\n@@ -1633,121 +1623,87 @@ impl<'tcx> Liveness<'_, 'tcx> {\n                 // the field\" message, and suggest `_` for the non-shorthands. If we only\n                 // have non-shorthand, then prefix with an underscore instead.\n                 if !shorthands.is_empty() {\n-                    let shorthands = shorthands\n-                        .into_iter()\n-                        .map(|(_, pat_span, _)| (pat_span, format!(\"{}: _\", name)))\n-                        .chain(\n-                            non_shorthands\n-                                .into_iter()\n-                                .map(|(_, pat_span, _)| (pat_span, \"_\".to_string())),\n-                        )\n-                        .collect::<Vec<_>>();\n+                    let shorthands =\n+                        shorthands.into_iter().map(|(_, pat_span, _)| pat_span).collect();\n+                    let non_shorthands =\n+                        non_shorthands.into_iter().map(|(_, pat_span, _)| pat_span).collect();\n \n-                    self.ir.tcx.struct_span_lint_hir(\n+                    self.ir.tcx.emit_spanned_lint(\n                         lint::builtin::UNUSED_VARIABLES,\n                         first_hir_id,\n                         hir_ids_and_spans\n                             .iter()\n                             .map(|(_, pat_span, _)| *pat_span)\n                             .collect::<Vec<_>>(),\n-                        format!(\"unused variable: `{}`\", name),\n-                        |lint| {\n-                            lint.multipart_suggestion(\n-                                \"try ignoring the field\",\n+                        errors::UnusedVarTryIgnore {\n+                            sugg: errors::UnusedVarTryIgnoreSugg {\n                                 shorthands,\n-                                Applicability::MachineApplicable,\n-                            )\n+                                non_shorthands,\n+                                name,\n+                            },\n                         },\n                     );\n                 } else {\n                     let non_shorthands = non_shorthands\n                         .into_iter()\n-                        .map(|(_, _, ident_span)| (ident_span, format!(\"_{}\", name)))\n+                        .map(|(_, _, ident_span)| ident_span)\n                         .collect::<Vec<_>>();\n-\n-                    self.ir.tcx.struct_span_lint_hir(\n+                    let suggestions = self.string_interp_suggestions(&name, opt_body);\n+                    self.ir.tcx.emit_spanned_lint(\n                         lint::builtin::UNUSED_VARIABLES,\n                         first_hir_id,\n                         hir_ids_and_spans\n                             .iter()\n                             .map(|(_, _, ident_span)| *ident_span)\n                             .collect::<Vec<_>>(),\n-                        format!(\"unused variable: `{}`\", name),\n-                        |lint| {\n-                            if self.has_added_lit_match_name_span(&name, opt_body, lint) {\n-                                lint.span_label(pat.span, \"unused variable\");\n-                            }\n-                            lint.multipart_suggestion(\n-                                \"if this is intentional, prefix it with an underscore\",\n-                                non_shorthands,\n-                                Applicability::MachineApplicable,\n-                            )\n+                        errors::UnusedVariableTryPrefix {\n+                            label: if !suggestions.is_empty() { Some(pat.span) } else { None },\n+                            sugg: errors::UnusedVariableTryPrefixSugg {\n+                                spans: non_shorthands,\n+                                name,\n+                            },\n+                            string_interp: suggestions,\n                         },\n                     );\n                 }\n             }\n         }\n     }\n \n-    fn has_added_lit_match_name_span(\n+    fn string_interp_suggestions(\n         &self,\n         name: &str,\n         opt_body: Option<&hir::Body<'_>>,\n-        err: &mut Diagnostic,\n-    ) -> bool {\n-        let mut has_litstring = false;\n-        let Some(opt_body) = opt_body else {return false;};\n+    ) -> Vec<errors::UnusedVariableStringInterp> {\n+        let mut suggs = Vec::new();\n+        let Some(opt_body) = opt_body else { return suggs; };\n         let mut visitor = CollectLitsVisitor { lit_exprs: vec![] };\n         intravisit::walk_body(&mut visitor, opt_body);\n         for lit_expr in visitor.lit_exprs {\n             let hir::ExprKind::Lit(litx) = &lit_expr.kind else { continue };\n             let rustc_ast::LitKind::Str(syb, _) = litx.node else{ continue; };\n             let name_str: &str = syb.as_str();\n-            let mut name_pa = String::from(\"{\");\n-            name_pa.push_str(&name);\n-            name_pa.push('}');\n+            let name_pa = format!(\"{{{name}}}\");\n             if name_str.contains(&name_pa) {\n-                err.span_label(\n-                    lit_expr.span,\n-                    \"you might have meant to use string interpolation in this string literal\",\n-                );\n-                err.multipart_suggestion(\n-                    \"string interpolation only works in `format!` invocations\",\n-                    vec![\n-                        (lit_expr.span.shrink_to_lo(), \"format!(\".to_string()),\n-                        (lit_expr.span.shrink_to_hi(), \")\".to_string()),\n-                    ],\n-                    Applicability::MachineApplicable,\n-                );\n-                has_litstring = true;\n+                suggs.push(errors::UnusedVariableStringInterp {\n+                    lit: lit_expr.span,\n+                    lo: lit_expr.span.shrink_to_lo(),\n+                    hi: lit_expr.span.shrink_to_hi(),\n+                });\n             }\n         }\n-        has_litstring\n+        suggs\n     }\n \n     fn warn_about_dead_assign(&self, spans: Vec<Span>, hir_id: HirId, ln: LiveNode, var: Variable) {\n-        if !self.live_on_exit(ln, var) {\n-            self.report_unused_assign(hir_id, spans, var, |name| {\n-                format!(\"value assigned to `{}` is never read\", name)\n-            });\n-        }\n-    }\n-\n-    fn report_unused_assign(\n-        &self,\n-        hir_id: HirId,\n-        spans: Vec<Span>,\n-        var: Variable,\n-        message: impl Fn(&str) -> String,\n-    ) {\n-        if let Some(name) = self.should_warn(var) {\n-            self.ir.tcx.struct_span_lint_hir(\n-                lint::builtin::UNUSED_ASSIGNMENTS,\n-                hir_id,\n-                spans,\n-                message(&name),\n-                |lint| lint.help(\"maybe it is overwritten before being read?\"),\n-            )\n-        }\n+        if !self.live_on_exit(ln, var)\n+            && let Some(name) = self.should_warn(var) {\n+                self.ir.tcx.emit_spanned_lint(\n+                    lint::builtin::UNUSED_ASSIGNMENTS,\n+                    hir_id,\n+                    spans,\n+                    errors::UnusedAssign { name },\n+                );\n+            }\n     }\n }"}, {"sha": "9615f283ff423d1819d065e90ff5a3d24f03922f", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 15, "deletions": 27, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -7,7 +7,6 @@ use rustc_attr::{\n     UnstableReason, VERSION_PLACEHOLDER,\n };\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n-use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID};\n@@ -759,12 +758,11 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                         // do not lint when the trait isn't resolved, since resolution error should\n                         // be fixed first\n                         if t.path.res != Res::Err && c.fully_stable {\n-                            self.tcx.struct_span_lint_hir(\n+                            self.tcx.emit_spanned_lint(\n                                 INEFFECTIVE_UNSTABLE_TRAIT_IMPL,\n                                 item.hir_id(),\n                                 span,\n-                                \"an `#[unstable]` annotation here has no effect\",\n-                                |lint| lint.note(\"see issue #55436 <https://github.com/rust-lang/rust/issues/55436> for more information\")\n+                                errors::IneffectiveUnstableImpl,\n                             );\n                         }\n                     }\n@@ -1095,29 +1093,16 @@ fn unnecessary_partially_stable_feature_lint(\n     implies: Symbol,\n     since: Symbol,\n ) {\n-    tcx.struct_span_lint_hir(\n+    tcx.emit_spanned_lint(\n         lint::builtin::STABLE_FEATURES,\n         hir::CRATE_HIR_ID,\n         span,\n-        format!(\n-            \"the feature `{feature}` has been partially stabilized since {since} and is succeeded \\\n-             by the feature `{implies}`\"\n-        ),\n-        |lint| {\n-            lint.span_suggestion(\n-                span,\n-                &format!(\n-                \"if you are using features which are still unstable, change to using `{implies}`\"\n-            ),\n-                implies,\n-                Applicability::MaybeIncorrect,\n-            )\n-            .span_suggestion(\n-                tcx.sess.source_map().span_extend_to_line(span),\n-                \"if you are using features which are now stable, remove this line\",\n-                \"\",\n-                Applicability::MaybeIncorrect,\n-            )\n+        errors::UnnecessaryPartialStableFeature {\n+            span,\n+            line: tcx.sess.source_map().span_extend_to_line(span),\n+            feature,\n+            since,\n+            implies,\n         },\n     );\n }\n@@ -1131,7 +1116,10 @@ fn unnecessary_stable_feature_lint(\n     if since.as_str() == VERSION_PLACEHOLDER {\n         since = rust_version_symbol();\n     }\n-    tcx.struct_span_lint_hir(lint::builtin::STABLE_FEATURES, hir::CRATE_HIR_ID, span, format!(\"the feature `{feature}` has been stable since {since} and no longer requires an attribute to enable\"), |lint| {\n-        lint\n-    });\n+    tcx.emit_spanned_lint(\n+        lint::builtin::STABLE_FEATURES,\n+        hir::CRATE_HIR_ID,\n+        span,\n+        errors::UnnecessaryStableFeature { feature, since },\n+    );\n }"}, {"sha": "b7e8870fdf548a0318078a24e832264f87230932", "filename": "tests/rustdoc-ui/doc_cfg_hide.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/tests%2Frustdoc-ui%2Fdoc_cfg_hide.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/tests%2Frustdoc-ui%2Fdoc_cfg_hide.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Fdoc_cfg_hide.stderr?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -16,7 +16,7 @@ LL | #![deny(warnings)]\n help: to apply to the crate, use an inner attribute\n    |\n LL | #![doc(cfg_hide(doc))]\n-   | ~~~~~~~~~~~~~~~~~~~~~~\n+   |  +\n \n error: `#[doc(cfg_hide(...)]` takes a list of attributes\n   --> $DIR/doc_cfg_hide.rs:4:8"}, {"sha": "c231e43b35caff712fb2a7f91c26ac1e6e7e05e5", "filename": "tests/rustdoc-ui/invalid-doc-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/tests%2Frustdoc-ui%2Finvalid-doc-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/tests%2Frustdoc-ui%2Finvalid-doc-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finvalid-doc-attr.rs?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -5,7 +5,7 @@\n //~^ ERROR can only be applied at the crate level\n //~| WARN is being phased out\n //~| HELP to apply to the crate, use an inner attribute\n-//~| SUGGESTION #![doc(test(no_crate_inject))]\n+//~| SUGGESTION !\n #[doc(inline)]\n //~^ ERROR can only be applied to a `use` item\n //~| WARN is being phased out"}, {"sha": "b23b8ded8674bf1dda2aee60cf47398e66d0f61b", "filename": "tests/rustdoc-ui/invalid-doc-attr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/tests%2Frustdoc-ui%2Finvalid-doc-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/tests%2Frustdoc-ui%2Finvalid-doc-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-ui%2Finvalid-doc-attr.stderr?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -16,7 +16,7 @@ LL | #![deny(warnings)]\n help: to apply to the crate, use an inner attribute\n    |\n LL | #![doc(test(no_crate_inject))]\n-   |\n+   |  +\n \n error: this attribute can only be applied to a `use` item\n   --> $DIR/invalid-doc-attr.rs:9:7"}, {"sha": "c231e43b35caff712fb2a7f91c26ac1e6e7e05e5", "filename": "tests/ui/attributes/invalid-doc-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/tests%2Fui%2Fattributes%2Finvalid-doc-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/tests%2Fui%2Fattributes%2Finvalid-doc-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid-doc-attr.rs?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -5,7 +5,7 @@\n //~^ ERROR can only be applied at the crate level\n //~| WARN is being phased out\n //~| HELP to apply to the crate, use an inner attribute\n-//~| SUGGESTION #![doc(test(no_crate_inject))]\n+//~| SUGGESTION !\n #[doc(inline)]\n //~^ ERROR can only be applied to a `use` item\n //~| WARN is being phased out"}, {"sha": "b23b8ded8674bf1dda2aee60cf47398e66d0f61b", "filename": "tests/ui/attributes/invalid-doc-attr.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63fbb05839f3b141cfaef9c718b07f1fdf61475a/tests%2Fui%2Fattributes%2Finvalid-doc-attr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/63fbb05839f3b141cfaef9c718b07f1fdf61475a/tests%2Fui%2Fattributes%2Finvalid-doc-attr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fattributes%2Finvalid-doc-attr.stderr?ref=63fbb05839f3b141cfaef9c718b07f1fdf61475a", "patch": "@@ -16,7 +16,7 @@ LL | #![deny(warnings)]\n help: to apply to the crate, use an inner attribute\n    |\n LL | #![doc(test(no_crate_inject))]\n-   |\n+   |  +\n \n error: this attribute can only be applied to a `use` item\n   --> $DIR/invalid-doc-attr.rs:9:7"}]}