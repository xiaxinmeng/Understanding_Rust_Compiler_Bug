{"sha": "0f4ef003ac1691d04f0ce519d1d78696689534aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmNGVmMDAzYWMxNjkxZDA0ZjBjZTUxOWQxZDc4Njk2Njg5NTM0YWE=", "commit": {"author": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-05-15T00:56:46Z"}, "committer": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-05-29T20:35:48Z"}, "message": "Pass a `Layout` to `oom`\n\nAs discussed in\nhttps://github.com/rust-lang/rust/issues/49668#issuecomment-384893456\nand subsequent, there are use-cases where the OOM handler needs to know\nthe size of the allocation that failed. The alignment might also be a\ncause for allocation failure, so providing it as well can be useful.", "tree": {"sha": "389cc750501eda02bc699d4ac967f0000a546fa1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/389cc750501eda02bc699d4ac967f0000a546fa1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f4ef003ac1691d04f0ce519d1d78696689534aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f4ef003ac1691d04f0ce519d1d78696689534aa", "html_url": "https://github.com/rust-lang/rust/commit/0f4ef003ac1691d04f0ce519d1d78696689534aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f4ef003ac1691d04f0ce519d1d78696689534aa/comments", "author": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5015fa346c1bf7e295fc16996ed0d3309c84f09a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5015fa346c1bf7e295fc16996ed0d3309c84f09a", "html_url": "https://github.com/rust-lang/rust/commit/5015fa346c1bf7e295fc16996ed0d3309c84f09a"}], "stats": {"total": 273, "additions": 161, "deletions": 112}, "files": [{"sha": "8753c495737c3177cdf3987d052e6f8727971756", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=0f4ef003ac1691d04f0ce519d1d78696689534aa", "patch": "@@ -115,7 +115,7 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n         if !ptr.is_null() {\n             ptr as *mut u8\n         } else {\n-            oom()\n+            oom(layout)\n         }\n     }\n }\n@@ -134,12 +134,13 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n }\n \n #[rustc_allocator_nounwind]\n-pub fn oom() -> ! {\n-    extern {\n+pub fn oom(layout: Layout) -> ! {\n+    #[allow(improper_ctypes)]\n+    extern \"Rust\" {\n         #[lang = \"oom\"]\n-        fn oom_impl() -> !;\n+        fn oom_impl(layout: Layout) -> !;\n     }\n-    unsafe { oom_impl() }\n+    unsafe { oom_impl(layout) }\n }\n \n #[cfg(test)]\n@@ -154,7 +155,7 @@ mod tests {\n         unsafe {\n             let layout = Layout::from_size_align(1024, 1).unwrap();\n             let ptr = Global.alloc_zeroed(layout.clone())\n-                .unwrap_or_else(|_| oom());\n+                .unwrap_or_else(|_| oom(layout));\n \n             let mut i = ptr.cast::<u8>().as_ptr();\n             let end = i.offset(layout.size() as isize);"}, {"sha": "f75132487849fc6ce17e68f8774ae050636515ed", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=0f4ef003ac1691d04f0ce519d1d78696689534aa", "patch": "@@ -553,7 +553,7 @@ impl<T: ?Sized> Arc<T> {\n         let layout = Layout::for_value(&*fake_ptr);\n \n         let mem = Global.alloc(layout)\n-            .unwrap_or_else(|_| oom());\n+            .unwrap_or_else(|_| oom(layout));\n \n         // Initialize the real ArcInner\n         let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut ArcInner<T>;"}, {"sha": "07bb7f1a3ebd8dcfa8d55682d0734abbdd50f151", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 82, "deletions": 74, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=0f4ef003ac1691d04f0ce519d1d78696689534aa", "patch": "@@ -96,14 +96,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 NonNull::<T>::dangling().as_opaque()\n             } else {\n                 let align = mem::align_of::<T>();\n+                let layout = Layout::from_size_align(alloc_size, align).unwrap();\n                 let result = if zeroed {\n-                    a.alloc_zeroed(Layout::from_size_align(alloc_size, align).unwrap())\n+                    a.alloc_zeroed(layout)\n                 } else {\n-                    a.alloc(Layout::from_size_align(alloc_size, align).unwrap())\n+                    a.alloc(layout)\n                 };\n                 match result {\n                     Ok(ptr) => ptr,\n-                    Err(_) => oom(),\n+                    Err(_) => oom(layout),\n                 }\n             };\n \n@@ -318,7 +319,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                                                  new_size);\n                     match ptr_res {\n                         Ok(ptr) => (new_cap, ptr.cast().into()),\n-                        Err(_) => oom(),\n+                        Err(_) => oom(Layout::from_size_align_unchecked(new_size, cur.align())),\n                     }\n                 }\n                 None => {\n@@ -327,7 +328,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     match self.a.alloc_array::<T>(new_cap) {\n                         Ok(ptr) => (new_cap, ptr.into()),\n-                        Err(_) => oom(),\n+                        Err(_) => oom(Layout::array::<T>(new_cap).unwrap()),\n                     }\n                 }\n             };\n@@ -389,37 +390,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n            -> Result<(), CollectionAllocErr> {\n \n-        unsafe {\n-            // NOTE: we don't early branch on ZSTs here because we want this\n-            // to actually catch \"asking for more than usize::MAX\" in that case.\n-            // If we make it past the first branch then we are guaranteed to\n-            // panic.\n-\n-            // Don't actually need any more capacity.\n-            // Wrapping in case they gave a bad `used_cap`.\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-                return Ok(());\n-            }\n-\n-            // Nothing we can really do about these checks :(\n-            let new_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n-            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n-\n-            alloc_guard(new_layout.size())?;\n-\n-            let res = match self.current_layout() {\n-                Some(layout) => {\n-                    debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n-                }\n-                None => self.a.alloc(new_layout),\n-            };\n-\n-            self.ptr = res?.cast().into();\n-            self.cap = new_cap;\n-\n-            Ok(())\n-        }\n+        self.reserve_internal(used_cap, needed_extra_cap, Fallible, Exact)\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n@@ -443,9 +414,9 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// Aborts on OOM\n     pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        match self.try_reserve_exact(used_cap, needed_extra_cap) {\n+        match self.reserve_internal(used_cap, needed_extra_cap, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => oom(),\n+            Err(AllocErr) => unreachable!(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n@@ -467,37 +438,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n     pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n         -> Result<(), CollectionAllocErr> {\n-         unsafe {\n-            // NOTE: we don't early branch on ZSTs here because we want this\n-            // to actually catch \"asking for more than usize::MAX\" in that case.\n-            // If we make it past the first branch then we are guaranteed to\n-            // panic.\n-\n-            // Don't actually need any more capacity.\n-            // Wrapping in case they give a bad `used_cap`\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n-               return Ok(());\n-            }\n-\n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)?;\n-            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n-\n-             // FIXME: may crash and burn on over-reserve\n-            alloc_guard(new_layout.size())?;\n-\n-            let res = match self.current_layout() {\n-                Some(layout) => {\n-                    debug_assert!(new_layout.align() == layout.align());\n-                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n-                }\n-                None => self.a.alloc(new_layout),\n-            };\n-\n-            self.ptr = res?.cast().into();\n-            self.cap = new_cap;\n-\n-            Ok(())\n-        }\n+        self.reserve_internal(used_cap, needed_extra_cap, Fallible, Amortized)\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n@@ -553,12 +494,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # }\n     /// ```\n     pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        match self.try_reserve(used_cap, needed_extra_cap) {\n+        match self.reserve_internal(used_cap, needed_extra_cap, Infallible, Amortized) {\n             Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocErr) => oom(),\n+            Err(AllocErr) => unreachable!(),\n             Ok(()) => { /* yay */ }\n-         }\n-     }\n+        }\n+    }\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n     /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n@@ -670,14 +611,81 @@ impl<T, A: Alloc> RawVec<T, A> {\n                                      old_layout,\n                                      new_size) {\n                     Ok(p) => self.ptr = p.cast().into(),\n-                    Err(_) => oom(),\n+                    Err(_) => oom(Layout::from_size_align_unchecked(new_size, align)),\n                 }\n             }\n             self.cap = amount;\n         }\n     }\n }\n \n+enum Fallibility {\n+    Fallible,\n+    Infallible,\n+}\n+\n+use self::Fallibility::*;\n+\n+enum ReserveStrategy {\n+    Exact,\n+    Amortized,\n+}\n+\n+use self::ReserveStrategy::*;\n+\n+impl<T, A: Alloc> RawVec<T, A> {\n+    fn reserve_internal(\n+        &mut self,\n+        used_cap: usize,\n+        needed_extra_cap: usize,\n+        fallibility: Fallibility,\n+        strategy: ReserveStrategy,\n+    ) -> Result<(), CollectionAllocErr> {\n+        unsafe {\n+            use alloc::AllocErr;\n+\n+            // NOTE: we don't early branch on ZSTs here because we want this\n+            // to actually catch \"asking for more than usize::MAX\" in that case.\n+            // If we make it past the first branch then we are guaranteed to\n+            // panic.\n+\n+            // Don't actually need any more capacity.\n+            // Wrapping in case they gave a bad `used_cap`.\n+            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+                return Ok(());\n+            }\n+\n+            // Nothing we can really do about these checks :(\n+            let new_cap = match strategy {\n+                Exact => used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?,\n+                Amortized => self.amortized_new_size(used_cap, needed_extra_cap)?,\n+            };\n+            let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n+\n+            alloc_guard(new_layout.size())?;\n+\n+            let res = match self.current_layout() {\n+                Some(layout) => {\n+                    debug_assert!(new_layout.align() == layout.align());\n+                    self.a.realloc(NonNull::from(self.ptr).as_opaque(), layout, new_layout.size())\n+                }\n+                None => self.a.alloc(new_layout),\n+            };\n+\n+            match (&res, fallibility) {\n+                (Err(AllocErr), Infallible) => oom(new_layout),\n+                _ => {}\n+            }\n+\n+            self.ptr = res?.cast().into();\n+            self.cap = new_cap;\n+\n+            Ok(())\n+        }\n+    }\n+\n+}\n+\n impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///"}, {"sha": "1648fc6b7ef4b39fc37a940f606b0a31ad32cccd", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=0f4ef003ac1691d04f0ce519d1d78696689534aa", "patch": "@@ -668,7 +668,7 @@ impl<T: ?Sized> Rc<T> {\n         let layout = Layout::for_value(&*fake_ptr);\n \n         let mem = Global.alloc(layout)\n-            .unwrap_or_else(|_| oom());\n+            .unwrap_or_else(|_| oom(layout));\n \n         // Initialize the real RcBox\n         let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut RcBox<T>;"}, {"sha": "0c95ceff2e38d9c06c2514b20eb19f1a029f199d", "filename": "src/libstd/alloc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Flibstd%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Flibstd%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Falloc.rs?ref=0f4ef003ac1691d04f0ce519d1d78696689534aa", "patch": "@@ -13,14 +13,14 @@\n #![unstable(issue = \"32838\", feature = \"allocator_api\")]\n \n #[doc(inline)] #[allow(deprecated)] pub use alloc_crate::alloc::Heap;\n-#[doc(inline)] pub use alloc_crate::alloc::{Global, oom};\n+#[doc(inline)] pub use alloc_crate::alloc::{Global, Layout, oom};\n #[doc(inline)] pub use alloc_system::System;\n #[doc(inline)] pub use core::alloc::*;\n \n #[cfg(not(test))]\n #[doc(hidden)]\n #[lang = \"oom\"]\n-pub extern fn rust_oom() -> ! {\n+pub extern fn rust_oom(_: Layout) -> ! {\n     rtabort!(\"memory allocation failed\");\n }\n "}, {"sha": "935ea4b62b5eb932943e1e74f128c42d2bda7e18", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 29, "deletions": 10, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=0f4ef003ac1691d04f0ce519d1d78696689534aa", "patch": "@@ -11,7 +11,7 @@\n use self::Entry::*;\n use self::VacantEntryState::*;\n \n-use alloc::{CollectionAllocErr, oom};\n+use alloc::CollectionAllocErr;\n use cell::Cell;\n use borrow::Borrow;\n use cmp::max;\n@@ -23,8 +23,10 @@ use mem::{self, replace};\n use ops::{Deref, Index};\n use sys;\n \n-use super::table::{self, Bucket, EmptyBucket, FullBucket, FullBucketMut, RawTable, SafeHash};\n+use super::table::{self, Bucket, EmptyBucket, Fallibility, FullBucket, FullBucketMut, RawTable,\n+                   SafeHash};\n use super::table::BucketState::{Empty, Full};\n+use super::table::Fallibility::{Fallible, Infallible};\n \n const MIN_NONZERO_RAW_CAPACITY: usize = 32;     // must be a power of two\n \n@@ -783,11 +785,11 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn reserve(&mut self, additional: usize) {\n-        match self.try_reserve(additional) {\n+        match self.reserve_internal(additional, Infallible) {\n             Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr) => oom(),\n+            Err(CollectionAllocErr::AllocErr) => unreachable!(),\n             Ok(()) => { /* yay */ }\n-         }\n+        }\n     }\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n@@ -809,17 +811,24 @@ impl<K, V, S> HashMap<K, V, S>\n     /// ```\n     #[unstable(feature = \"try_reserve\", reason = \"new API\", issue=\"48043\")]\n     pub fn try_reserve(&mut self, additional: usize) -> Result<(), CollectionAllocErr> {\n+        self.reserve_internal(additional, Fallible)\n+    }\n+\n+    fn reserve_internal(&mut self, additional: usize, fallibility: Fallibility)\n+        -> Result<(), CollectionAllocErr> {\n+\n         let remaining = self.capacity() - self.len(); // this can't overflow\n         if remaining < additional {\n-            let min_cap = self.len().checked_add(additional)\n+            let min_cap = self.len()\n+                .checked_add(additional)\n                 .ok_or(CollectionAllocErr::CapacityOverflow)?;\n             let raw_cap = self.resize_policy.try_raw_capacity(min_cap)?;\n-            self.try_resize(raw_cap)?;\n+            self.try_resize(raw_cap, fallibility)?;\n         } else if self.table.tag() && remaining <= self.len() {\n             // Probe sequence is too long and table is half full,\n             // resize early to reduce probing length.\n             let new_capacity = self.table.capacity() * 2;\n-            self.try_resize(new_capacity)?;\n+            self.try_resize(new_capacity, fallibility)?;\n         }\n         Ok(())\n     }\n@@ -831,11 +840,21 @@ impl<K, V, S> HashMap<K, V, S>\n     ///   2) Ensure `new_raw_cap` is a power of two or zero.\n     #[inline(never)]\n     #[cold]\n-    fn try_resize(&mut self, new_raw_cap: usize) -> Result<(), CollectionAllocErr> {\n+    fn try_resize(\n+        &mut self,\n+        new_raw_cap: usize,\n+        fallibility: Fallibility,\n+    ) -> Result<(), CollectionAllocErr> {\n         assert!(self.table.size() <= new_raw_cap);\n         assert!(new_raw_cap.is_power_of_two() || new_raw_cap == 0);\n \n-        let mut old_table = replace(&mut self.table, RawTable::try_new(new_raw_cap)?);\n+        let mut old_table = replace(\n+            &mut self.table,\n+            match fallibility {\n+                Infallible => RawTable::new(new_raw_cap),\n+                Fallible => RawTable::try_new(new_raw_cap)?,\n+            }\n+        );\n         let old_size = old_table.size();\n \n         if old_table.size() == 0 {"}, {"sha": "eed2debcaa282cfdc7e369ff198de1f5be5b9497", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=0f4ef003ac1691d04f0ce519d1d78696689534aa", "patch": "@@ -711,11 +711,21 @@ fn test_offset_calculation() {\n     assert_eq!(calculate_offsets(6, 12, 4), (8, 20, false));\n }\n \n+pub(crate) enum Fallibility {\n+    Fallible,\n+    Infallible,\n+}\n+\n+use self::Fallibility::*;\n+\n impl<K, V> RawTable<K, V> {\n     /// Does not initialize the buckets. The caller should ensure they,\n     /// at the very least, set every hash to EMPTY_BUCKET.\n     /// Returns an error if it cannot allocate or capacity overflows.\n-    unsafe fn try_new_uninitialized(capacity: usize) -> Result<RawTable<K, V>, CollectionAllocErr> {\n+    unsafe fn new_uninitialized_internal(\n+        capacity: usize,\n+        fallibility: Fallibility,\n+    ) -> Result<RawTable<K, V>, CollectionAllocErr> {\n         if capacity == 0 {\n             return Ok(RawTable {\n                 size: 0,\n@@ -754,8 +764,12 @@ impl<K, V> RawTable<K, V> {\n             return Err(CollectionAllocErr::CapacityOverflow);\n         }\n \n-        let buffer = Global.alloc(Layout::from_size_align(size, alignment)\n-            .map_err(|_| CollectionAllocErr::CapacityOverflow)?)?;\n+        let layout = Layout::from_size_align(size, alignment)\n+            .map_err(|_| CollectionAllocErr::CapacityOverflow)?;\n+        let buffer = Global.alloc(layout).map_err(|e| match fallibility {\n+            Infallible => oom(layout),\n+            Fallible => e,\n+        })?;\n \n         Ok(RawTable {\n             capacity_mask: capacity.wrapping_sub(1),\n@@ -768,9 +782,9 @@ impl<K, V> RawTable<K, V> {\n     /// Does not initialize the buckets. The caller should ensure they,\n     /// at the very least, set every hash to EMPTY_BUCKET.\n     unsafe fn new_uninitialized(capacity: usize) -> RawTable<K, V> {\n-        match Self::try_new_uninitialized(capacity) {\n+        match Self::new_uninitialized_internal(capacity, Infallible) {\n             Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr) => oom(),\n+            Err(CollectionAllocErr::AllocErr) => unreachable!(),\n             Ok(table) => { table }\n         }\n     }\n@@ -794,22 +808,29 @@ impl<K, V> RawTable<K, V> {\n         }\n     }\n \n-    /// Tries to create a new raw table from a given capacity. If it cannot allocate,\n-    /// it returns with AllocErr.\n-    pub fn try_new(capacity: usize) -> Result<RawTable<K, V>, CollectionAllocErr> {\n+    fn new_internal(\n+        capacity: usize,\n+        fallibility: Fallibility,\n+    ) -> Result<RawTable<K, V>, CollectionAllocErr> {\n         unsafe {\n-            let ret = RawTable::try_new_uninitialized(capacity)?;\n+            let ret = RawTable::new_uninitialized_internal(capacity, fallibility)?;\n             ptr::write_bytes(ret.hashes.ptr(), 0, capacity);\n             Ok(ret)\n         }\n     }\n \n+    /// Tries to create a new raw table from a given capacity. If it cannot allocate,\n+    /// it returns with AllocErr.\n+    pub fn try_new(capacity: usize) -> Result<RawTable<K, V>, CollectionAllocErr> {\n+        Self::new_internal(capacity, Fallible)\n+    }\n+\n     /// Creates a new raw table from a given capacity. All buckets are\n     /// initially empty.\n     pub fn new(capacity: usize) -> RawTable<K, V> {\n-        match Self::try_new(capacity) {\n+        match Self::new_internal(capacity, Infallible) {\n             Err(CollectionAllocErr::CapacityOverflow) => panic!(\"capacity overflow\"),\n-            Err(CollectionAllocErr::AllocErr) => oom(),\n+            Err(CollectionAllocErr::AllocErr) => unreachable!(),\n             Ok(table) => { table }\n         }\n     }"}, {"sha": "f1fdbfc702ddf6dfcb40f4c642dd579488472ba5", "filename": "src/test/run-pass/allocator-alloc-one.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator-alloc-one.rs?ref=0f4ef003ac1691d04f0ce519d1d78696689534aa", "patch": "@@ -10,11 +10,11 @@\n \n #![feature(allocator_api, nonnull)]\n \n-use std::alloc::{Alloc, Global, oom};\n+use std::alloc::{Alloc, Global, Layout, oom};\n \n fn main() {\n     unsafe {\n-        let ptr = Global.alloc_one::<i32>().unwrap_or_else(|_| oom());\n+        let ptr = Global.alloc_one::<i32>().unwrap_or_else(|_| oom(Layout::new::<i32>()));\n         *ptr.as_ptr() = 4;\n         assert_eq!(*ptr.as_ptr(), 4);\n         Global.dealloc_one(ptr);"}, {"sha": "febd249d776af59b730104977085d8e99d719f63", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=0f4ef003ac1691d04f0ce519d1d78696689534aa", "patch": "@@ -50,7 +50,7 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let ret = Global.alloc(layout.clone()).unwrap_or_else(|_| oom());\n+        let ret = Global.alloc(layout).unwrap_or_else(|_| oom(layout));\n \n         if PRINT {\n             println!(\"allocate({:?}) = {:?}\", layout, ret);\n@@ -72,8 +72,8 @@ unsafe fn test_triangle() -> bool {\n             println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let ret = Global.realloc(NonNull::new_unchecked(ptr).as_opaque(), old.clone(), new.size())\n-            .unwrap_or_else(|_| oom());\n+        let ret = Global.realloc(NonNull::new_unchecked(ptr).as_opaque(), old, new.size())\n+            .unwrap_or_else(|_| oom(Layout::from_size_align_unchecked(new.size(), old.align())));\n \n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\","}, {"sha": "745a19dec4d785fc11c7839f23b0950d660b289a", "filename": "src/test/run-pass/regions-mock-codegen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Ftest%2Frun-pass%2Fregions-mock-codegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f4ef003ac1691d04f0ce519d1d78696689534aa/src%2Ftest%2Frun-pass%2Fregions-mock-codegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-codegen.rs?ref=0f4ef003ac1691d04f0ce519d1d78696689534aa", "patch": "@@ -32,8 +32,8 @@ struct Ccx {\n \n fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n-        let ptr = Global.alloc(Layout::new::<Bcx>())\n-            .unwrap_or_else(|_| oom());\n+        let layout = Layout::new::<Bcx>();\n+        let ptr = Global.alloc(layout).unwrap_or_else(|_| oom(layout));\n         &*(ptr.as_ptr() as *const _)\n     }\n }"}]}