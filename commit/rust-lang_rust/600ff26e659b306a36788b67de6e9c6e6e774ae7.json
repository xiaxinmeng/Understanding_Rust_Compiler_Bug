{"sha": "600ff26e659b306a36788b67de6e9c6e6e774ae7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMGZmMjZlNjU5YjMwNmEzNjc4OGI2N2RlNmU5YzZlNmU3NzRhZTc=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-21T11:27:34Z"}, "committer": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2016-03-21T11:27:34Z"}, "message": "Refactor handling of relocations.", "tree": {"sha": "bed7b7c27b02ce198165afdad988d4c1a4e1f61a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bed7b7c27b02ce198165afdad988d4c1a4e1f61a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/600ff26e659b306a36788b67de6e9c6e6e774ae7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/600ff26e659b306a36788b67de6e9c6e6e774ae7", "html_url": "https://github.com/rust-lang/rust/commit/600ff26e659b306a36788b67de6e9c6e6e774ae7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/600ff26e659b306a36788b67de6e9c6e6e774ae7/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b0164b0fa950e384e91c807e79df4b51a4bcd50", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b0164b0fa950e384e91c807e79df4b51a4bcd50", "html_url": "https://github.com/rust-lang/rust/commit/5b0164b0fa950e384e91c807e79df4b51a4bcd50"}], "stats": {"total": 106, "additions": 55, "deletions": 51}, "files": [{"sha": "ebbeff6d95d4123201da7b498d16892dae2209e2", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/600ff26e659b306a36788b67de6e9c6e6e774ae7/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/600ff26e659b306a36788b67de6e9c6e6e774ae7/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=600ff26e659b306a36788b67de6e9c6e6e774ae7", "patch": "@@ -1,4 +1,4 @@\n-#![feature(btree_range, collections_bound, core_intrinsics, rustc_private)]\n+#![feature(btree_range, collections, collections_bound, core_intrinsics, rustc_private)]\n \n // From rustc.\n extern crate arena;"}, {"sha": "cff4cc35c84e0dd6e4a7f66b65bf8f7b6eb7f8cf", "filename": "src/memory.rs", "status": "modified", "additions": 54, "deletions": 50, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/600ff26e659b306a36788b67de6e9c6e6e774ae7/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/600ff26e659b306a36788b67de6e9c6e6e774ae7/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=600ff26e659b306a36788b67de6e9c6e6e774ae7", "patch": "@@ -1,5 +1,5 @@\n-use byteorder::{self, ByteOrder, NativeEndian, ReadBytesExt, WriteBytesExt};\n-use std::collections::{BTreeMap, HashMap};\n+use byteorder::{ByteOrder, NativeEndian, ReadBytesExt, WriteBytesExt};\n+use std::collections::{btree_map, BTreeMap, HashMap};\n use std::collections::Bound::{Included, Excluded};\n use std::mem;\n use std::ptr;\n@@ -94,25 +94,46 @@ impl Memory {\n     }\n \n     fn get_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<&[u8]> {\n-        let alloc = try!(self.get(ptr.alloc_id));\n-        try!(alloc.check_no_relocations(ptr.offset, ptr.offset + size));\n-        Ok(&alloc.bytes[ptr.offset..ptr.offset + size])\n+        try!(self.check_readable_bytes(ptr, size));\n+        try!(self.get(ptr.alloc_id)).checked_slice(ptr.offset, size)\n     }\n \n     fn get_bytes_mut(&mut self, ptr: Pointer, size: usize) -> EvalResult<&mut [u8]> {\n         try!(self.clear_relocations(ptr, size));\n-        let alloc = try!(self.get_mut(ptr.alloc_id));\n-        Ok(&mut alloc.bytes[ptr.offset..ptr.offset + size])\n+        try!(self.get_mut(ptr.alloc_id)).checked_slice_mut(ptr.offset, size)\n     }\n \n-    fn clear_relocations(&mut self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+    fn check_readable_bytes(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+        if try!(self.relocations(ptr, size)).count() == 0 {\n+            // TODO(tsion): Track and check for undef bytes.\n+            Ok(())\n+        } else {\n+            Err(EvalError::ReadPointerAsBytes)\n+        }\n+    }\n+\n+    fn relocations(&self, ptr: Pointer, size: usize)\n+        -> EvalResult<btree_map::Range<usize, AllocId>>\n+    {\n         let start = ptr.offset.saturating_sub(self.pointer_size - 1);\n         let end = ptr.offset + size;\n+        let alloc = try!(self.get(ptr.alloc_id));\n+        Ok(alloc.relocations.range(Included(&start), Excluded(&end)))\n+    }\n+\n+    fn check_relocation_edges(&self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+        let overlapping_start = try!(self.relocations(ptr, 0)).count();\n+        let overlapping_end = try!(self.relocations(ptr.offset(size as isize), 0)).count();\n+        if overlapping_start + overlapping_end == 0 {\n+            Ok(())\n+        } else {\n+            Err(EvalError::ReadPointerAsBytes)\n+        }\n+    }\n+\n+    fn clear_relocations(&mut self, ptr: Pointer, size: usize) -> EvalResult<()> {\n+        let keys: Vec<_> = try!(self.relocations(ptr, size)).map(|(&k, _)| k).collect();\n         let alloc = try!(self.get_mut(ptr.alloc_id));\n-        let keys: Vec<_> = alloc.relocations\n-            .range(Included(&start), Excluded(&end))\n-            .map(|(&k, _)| k)\n-            .collect();\n         for k in keys {\n             alloc.relocations.remove(&k);\n         }\n@@ -131,10 +152,12 @@ impl Memory {\n     }\n \n     pub fn copy(&mut self, src: Pointer, dest: Pointer, size: usize) -> EvalResult<()> {\n+        // TODO(tsion): Track and check for undef bytes.\n+        try!(self.check_relocation_edges(src, size));\n+\n         let src_bytes = {\n-            let alloc = try!(self.get_mut(src.alloc_id));\n-            try!(alloc.check_relocation_edges(src.offset, src.offset + size));\n-            alloc.bytes[src.offset..src.offset + size].as_mut_ptr()\n+            let alloc = try!(self.get(src.alloc_id));\n+            try!(alloc.checked_slice(src.offset, size)).as_ptr()\n         };\n         let dest_bytes = try!(self.get_bytes_mut(dest, size)).as_mut_ptr();\n \n@@ -158,24 +181,22 @@ impl Memory {\n \n     pub fn read_ptr(&self, ptr: Pointer) -> EvalResult<Pointer> {\n         let alloc = try!(self.get(ptr.alloc_id));\n-        try!(alloc.check_relocation_edges(ptr.offset, ptr.offset + self.pointer_size));\n-        let bytes = &alloc.bytes[ptr.offset..ptr.offset + self.pointer_size];\n-        let offset = byteorder::NativeEndian::read_u64(bytes) as usize;\n+        let mut bytes = try!(alloc.checked_slice(ptr.offset, self.pointer_size));\n+        let offset = bytes.read_uint::<NativeEndian>(self.pointer_size).unwrap() as usize;\n \n         match alloc.relocations.get(&ptr.offset) {\n             Some(&alloc_id) => Ok(Pointer { alloc_id: alloc_id, offset: offset }),\n             None => Err(EvalError::ReadBytesAsPointer),\n         }\n     }\n \n-    pub fn write_ptr(&mut self, dest: Pointer, ptr_val: Pointer) -> EvalResult<()> {\n+    pub fn write_ptr(&mut self, dest: Pointer, ptr: Pointer) -> EvalResult<()> {\n         {\n             let size = self.pointer_size;\n-            let bytes = try!(self.get_bytes_mut(dest, size));\n-            byteorder::NativeEndian::write_u64(bytes, ptr_val.offset as u64);\n+            let mut bytes = try!(self.get_bytes_mut(dest, size));\n+            bytes.write_uint::<NativeEndian>(ptr.offset as u64, size).unwrap();\n         }\n-        let alloc = try!(self.get_mut(dest.alloc_id));\n-        alloc.relocations.insert(dest.offset, ptr_val.alloc_id);\n+        try!(self.get_mut(dest.alloc_id)).relocations.insert(dest.offset, ptr.alloc_id);\n         Ok(())\n     }\n \n@@ -243,40 +264,23 @@ impl Memory {\n }\n \n impl Allocation {\n-    fn check_bounds(&self, start: usize, end: usize) -> EvalResult<()> {\n+    fn checked_slice(&self, offset: usize, size: usize) -> EvalResult<&[u8]> {\n+        let start = offset;\n+        let end = start + size;\n         if start <= self.bytes.len() && end <= self.bytes.len() {\n-            Ok(())\n+            Ok(&self.bytes[start..end])\n         } else {\n             Err(EvalError::PointerOutOfBounds)\n         }\n     }\n \n-    fn count_overlapping_relocations(&self, start: usize, end: usize) -> usize {\n-        self.relocations.range(\n-            // FIXME(tsion): Assuming pointer size is 8. Move this method to Memory.\n-            Included(&start.saturating_sub(8 - 1)),\n-            Excluded(&end)\n-        ).count()\n-    }\n-\n-    fn check_relocation_edges(&self, start: usize, end: usize) -> EvalResult<()> {\n-        try!(self.check_bounds(start, end));\n-        let n =\n-            self.count_overlapping_relocations(start, start) +\n-            self.count_overlapping_relocations(end, end);\n-        if n == 0 {\n-            Ok(())\n-        } else {\n-            Err(EvalError::ReadPointerAsBytes)\n-        }\n-    }\n-\n-    fn check_no_relocations(&self, start: usize, end: usize) -> EvalResult<()> {\n-        try!(self.check_bounds(start, end));\n-        if self.count_overlapping_relocations(start, end) == 0 {\n-            Ok(())\n+    fn checked_slice_mut(&mut self, offset: usize, size: usize) -> EvalResult<&mut [u8]> {\n+        let start = offset;\n+        let end = start + size;\n+        if start <= self.bytes.len() && end <= self.bytes.len() {\n+            Ok(&mut self.bytes[start..end])\n         } else {\n-            Err(EvalError::ReadPointerAsBytes)\n+            Err(EvalError::PointerOutOfBounds)\n         }\n     }\n }"}]}