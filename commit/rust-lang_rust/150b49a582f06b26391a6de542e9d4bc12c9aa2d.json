{"sha": "150b49a582f06b26391a6de542e9d4bc12c9aa2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1MGI0OWE1ODJmMDZiMjYzOTFhNmRlNTQyZTlkNGJjMTJjOWFhMmQ=", "commit": {"author": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-03-09T21:25:12Z"}, "committer": {"name": "Andy Russell", "email": "arussell123@gmail.com", "date": "2019-03-15T18:33:41Z"}, "message": "replace ad-hoc namespace enums", "tree": {"sha": "bf48dd29b5f882562e1854c001f75c0dcfd435b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf48dd29b5f882562e1854c001f75c0dcfd435b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/150b49a582f06b26391a6de542e9d4bc12c9aa2d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQFKBAABCAA0FiEELriChyEaiMu0yCg7viIhAz7bw3QFAlyL8A8WHGFydXNzZWxs\nMTIzQGdtYWlsLmNvbQAKCRC+IiEDPtvDdAjfB/9/9iEXfE5DRkAZQtv9WLXAx3Yc\nzrWeJ09V8WE7KqzUYs9T8C3QrrxVqKm6k4K/mHiE/FZ4xvRiLJv9HJk+PUsvf+5Q\nFoGTsTJwytqZWEV5jNRB5qU8siaieplkmZhiuYbeMBLEA9bMWR8HCbO3liZACwr2\nMnULojXXwraoLAOYhMAC9pxLBNng0f95UjzjePKVV/6NLzHkAVxW+i/npRR50FiJ\nuMKBvZbLWfmm1pf4wbtQyHyJdXZM4VBGsqMJnkf5Sb16vk1lTbU/iSps2K2I2XZ7\njFaF3dDBqai514yo2TCl1w0jCbKr97ZfHvaJe/2rB3JapRKzKOZbvdQypmqZ\n=69NH\n-----END PGP SIGNATURE-----", "payload": "tree bf48dd29b5f882562e1854c001f75c0dcfd435b3\nparent 33442b133cef78e8f08271cd863051e0de997b69\nauthor Andy Russell <arussell123@gmail.com> 1552166712 -0500\ncommitter Andy Russell <arussell123@gmail.com> 1552674821 -0400\n\nreplace ad-hoc namespace enums\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/150b49a582f06b26391a6de542e9d4bc12c9aa2d", "html_url": "https://github.com/rust-lang/rust/commit/150b49a582f06b26391a6de542e9d4bc12c9aa2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/150b49a582f06b26391a6de542e9d4bc12c9aa2d/comments", "author": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "euclio", "id": 1372438, "node_id": "MDQ6VXNlcjEzNzI0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1372438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/euclio", "html_url": "https://github.com/euclio", "followers_url": "https://api.github.com/users/euclio/followers", "following_url": "https://api.github.com/users/euclio/following{/other_user}", "gists_url": "https://api.github.com/users/euclio/gists{/gist_id}", "starred_url": "https://api.github.com/users/euclio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/euclio/subscriptions", "organizations_url": "https://api.github.com/users/euclio/orgs", "repos_url": "https://api.github.com/users/euclio/repos", "events_url": "https://api.github.com/users/euclio/events{/privacy}", "received_events_url": "https://api.github.com/users/euclio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33442b133cef78e8f08271cd863051e0de997b69", "url": "https://api.github.com/repos/rust-lang/rust/commits/33442b133cef78e8f08271cd863051e0de997b69", "html_url": "https://github.com/rust-lang/rust/commit/33442b133cef78e8f08271cd863051e0de997b69"}], "stats": {"total": 175, "additions": 72, "deletions": 103}, "files": [{"sha": "b105e0a0b6fccfc0042c875dbe3806b03f50243e", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 67, "deletions": 98, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/150b49a582f06b26391a6de542e9d4bc12c9aa2d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/150b49a582f06b26391a6de542e9d4bc12c9aa2d/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=150b49a582f06b26391a6de542e9d4bc12c9aa2d", "patch": "@@ -1,5 +1,5 @@\n use errors::Applicability;\n-use rustc::hir::def::Def;\n+use rustc::hir::def::{Def, Namespace::{self, *}, PerNS};\n use rustc::hir::def_id::DefId;\n use rustc::hir;\n use rustc::lint as lint;\n@@ -36,46 +36,24 @@ pub fn collect_intra_doc_links(krate: Crate, cx: &DocContext<'_>) -> Crate {\n     }\n }\n \n-#[derive(Debug)]\n-enum PathKind {\n-    /// Either a value or type, but not a macro\n-    Unknown,\n-    /// Macro\n-    Macro,\n-    /// Values, functions, consts, statics (everything in the value namespace)\n-    Value,\n-    /// Types, traits (everything in the type namespace)\n-    Type,\n-}\n-\n struct LinkCollector<'a, 'tcx> {\n     cx: &'a DocContext<'tcx>,\n     mod_ids: Vec<ast::NodeId>,\n-    is_nightly_build: bool,\n-}\n-\n-#[derive(Debug, Copy, Clone)]\n-enum Namespace {\n-    Type,\n-    Value,\n-    Macro,\n }\n \n impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n     fn new(cx: &'a DocContext<'tcx>) -> Self {\n         LinkCollector {\n             cx,\n             mod_ids: Vec::new(),\n-            is_nightly_build: UnstableFeatures::from_environment().is_nightly_build(),\n         }\n     }\n \n-    /// Resolves a given string as a path, along with whether or not it is\n-    /// in the value namespace. Also returns an optional URL fragment in the case\n-    /// of variants and methods.\n+    /// Resolves a string as a path within a particular namespace. Also returns an optional\n+    /// URL fragment in the case of variants and methods.\n     fn resolve(&self,\n                path_str: &str,\n-               is_val: bool,\n+               ns: Namespace,\n                current_item: &Option<String>,\n                parent_id: Option<ast::NodeId>)\n         -> Result<(Def, Option<String>), ()>\n@@ -86,11 +64,11 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n         // path.\n         if let Some(id) = parent_id.or(self.mod_ids.last().cloned()) {\n             // FIXME: `with_scope` requires the `NodeId` of a module.\n-            let result = cx.enter_resolver(|resolver| resolver.with_scope(id,\n-                |resolver| {\n-                    resolver.resolve_str_path_error(DUMMY_SP,\n-                                                    &path_str, is_val)\n-            }));\n+            let result = cx.enter_resolver(|resolver| {\n+                resolver.with_scope(id, |resolver| {\n+                    resolver.resolve_str_path_error(DUMMY_SP, &path_str, ns == ValueNS)\n+                })\n+            });\n \n             if let Ok(result) = result {\n                 // In case this is a trait item, skip the\n@@ -103,16 +81,16 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     _ => return Ok((result.def, None))\n                 };\n \n-                if value != is_val {\n+                if value != (ns == ValueNS) {\n                     return Err(())\n                 }\n-            } else if let Some(prim) = is_primitive(path_str, is_val) {\n+            } else if let Some(prim) = is_primitive(path_str, ns) {\n                 return Ok((prim, Some(path_str.to_owned())))\n             } else {\n                 // If resolution failed, it may still be a method\n                 // because methods are not handled by the resolver\n                 // If so, bail when we're not looking for a value.\n-                if !is_val {\n+                if ns != ValueNS {\n                     return Err(())\n                 }\n             }\n@@ -136,7 +114,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     path = name.clone();\n                 }\n             }\n-            if let Some(prim) = is_primitive(&path, false) {\n+            if let Some(prim) = is_primitive(&path, TypeNS) {\n                 let did = primitive_impl(cx, &path).ok_or(())?;\n                 return cx.tcx.associated_items(did)\n                     .find(|item| item.ident.name == item_name)\n@@ -160,8 +138,8 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                      .find(|item| item.ident.name == item_name);\n                     if let Some(item) = item {\n                         let out = match item.kind {\n-                            ty::AssociatedKind::Method if is_val => \"method\",\n-                            ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n+                            ty::AssociatedKind::Method if ns == ValueNS => \"method\",\n+                            ty::AssociatedKind::Const if ns == ValueNS => \"associatedconstant\",\n                             _ => return Err(())\n                         };\n                         Ok((ty.def, Some(format!(\"{}.{}\", out, item_name))))\n@@ -198,9 +176,9 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                                  .find(|item| item.ident.name == item_name);\n                     if let Some(item) = item {\n                         let kind = match item.kind {\n-                            ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n-                            ty::AssociatedKind::Type if !is_val => \"associatedtype\",\n-                            ty::AssociatedKind::Method if is_val => {\n+                            ty::AssociatedKind::Const if ns == ValueNS => \"associatedconstant\",\n+                            ty::AssociatedKind::Type if ns == TypeNS => \"associatedtype\",\n+                            ty::AssociatedKind::Method if ns == ValueNS => {\n                                 if item.defaultness.has_value() {\n                                     \"method\"\n                                 } else {\n@@ -287,39 +265,35 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n \n         look_for_tests(&cx, &dox, &item, true);\n \n-        if !self.is_nightly_build {\n-            return None;\n-        }\n-\n         for (ori_link, link_range) in markdown_links(&dox) {\n             // Bail early for real links.\n             if ori_link.contains('/') {\n                 continue;\n             }\n             let link = ori_link.replace(\"`\", \"\");\n             let (def, fragment) = {\n-                let mut kind = PathKind::Unknown;\n+                let mut kind = None;\n                 let path_str = if let Some(prefix) =\n                     [\"struct@\", \"enum@\", \"type@\",\n                      \"trait@\", \"union@\"].iter()\n                                       .find(|p| link.starts_with(**p)) {\n-                    kind = PathKind::Type;\n+                    kind = Some(TypeNS);\n                     link.trim_start_matches(prefix)\n                 } else if let Some(prefix) =\n                     [\"const@\", \"static@\",\n                      \"value@\", \"function@\", \"mod@\",\n                      \"fn@\", \"module@\", \"method@\"]\n                         .iter().find(|p| link.starts_with(**p)) {\n-                    kind = PathKind::Value;\n+                    kind = Some(ValueNS);\n                     link.trim_start_matches(prefix)\n                 } else if link.ends_with(\"()\") {\n-                    kind = PathKind::Value;\n+                    kind = Some(ValueNS);\n                     link.trim_end_matches(\"()\")\n                 } else if link.starts_with(\"macro@\") {\n-                    kind = PathKind::Macro;\n+                    kind = Some(MacroNS);\n                     link.trim_start_matches(\"macro@\")\n                 } else if link.ends_with('!') {\n-                    kind = PathKind::Macro;\n+                    kind = Some(MacroNS);\n                     link.trim_end_matches('!')\n                 } else {\n                     &link[..]\n@@ -331,8 +305,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 }\n \n                 match kind {\n-                    PathKind::Value => {\n-                        if let Ok(def) = self.resolve(path_str, true, &current_item, parent_node) {\n+                    Some(ns @ ValueNS) => {\n+                        if let Ok(def) = self.resolve(path_str, ns, &current_item, parent_node) {\n                             def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n@@ -342,66 +316,58 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                             continue;\n                         }\n                     }\n-                    PathKind::Type => {\n-                        if let Ok(def) = self.resolve(path_str, false, &current_item, parent_node) {\n+                    Some(ns @ TypeNS) => {\n+                        if let Ok(def) = self.resolve(path_str, ns, &current_item, parent_node) {\n                             def\n                         } else {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n                             // This could just be a normal link.\n                             continue;\n                         }\n                     }\n-                    PathKind::Unknown => {\n+                    None => {\n                         // Try everything!\n-                        let mut candidates = vec![];\n-\n-                        if let Some(macro_def) = macro_resolve(cx, path_str) {\n-                            candidates.push(((macro_def, None), Namespace::Macro));\n-                        }\n-\n-                        if let Ok(type_def) =\n-                            self.resolve(path_str, false, &current_item, parent_node)\n-                        {\n-                            candidates.push((type_def, Namespace::Type));\n-                        }\n-\n-                        if let Ok(value_def) =\n-                            self.resolve(path_str, true, &current_item, parent_node)\n-                        {\n-                            // Structs, variants, and mods exist in both namespaces, skip them.\n-                            match value_def.0 {\n-                                Def::StructCtor(..)\n-                                | Def::Mod(..)\n-                                | Def::Variant(..)\n-                                | Def::VariantCtor(..)\n-                                | Def::SelfCtor(..) => (),\n-                                _ => candidates.push((value_def, Namespace::Value)),\n-                            }\n-                        }\n+                        let candidates = PerNS {\n+                            macro_ns: macro_resolve(cx, path_str).map(|def| (def, None)),\n+                            type_ns: self\n+                                .resolve(path_str, TypeNS, &current_item, parent_node)\n+                                .ok(),\n+                            value_ns: self\n+                                .resolve(path_str, ValueNS, &current_item, parent_node)\n+                                .ok()\n+                                .and_then(|(def, fragment)| {\n+                                    // Constructors are picked up in the type namespace.\n+                                    match def {\n+                                        Def::StructCtor(..)\n+                                        | Def::VariantCtor(..)\n+                                        | Def::SelfCtor(..) => None,\n+                                        _ => Some((def, fragment))\n+                                    }\n+                                }),\n+                        };\n \n-                        if candidates.len() == 1 {\n-                            candidates.remove(0).0\n-                        } else if candidates.is_empty() {\n+                        if candidates.is_empty() {\n                             resolution_failure(cx, &item.attrs, path_str, &dox, link_range);\n                             // this could just be a normal link\n                             continue;\n-                        } else {\n-                            let candidates = candidates.into_iter().map(|((def, _), ns)| {\n-                                (def, ns)\n-                            }).collect::<Vec<_>>();\n+                        }\n \n+                        let is_unambiguous = candidates.clone().present_items().count() == 1;\n+                        if is_unambiguous {\n+                            candidates.present_items().next().unwrap()\n+                        } else {\n                             ambiguity_error(\n                                 cx,\n                                 &item.attrs,\n                                 path_str,\n                                 &dox,\n                                 link_range,\n-                                &candidates,\n+                                candidates.map(|candidate| candidate.map(|(def, _)| def)),\n                             );\n                             continue;\n                         }\n                     }\n-                    PathKind::Macro => {\n+                    Some(MacroNS) => {\n                         if let Some(def) = macro_resolve(cx, path_str) {\n                             (def, None)\n                         } else {\n@@ -514,13 +480,16 @@ fn ambiguity_error(\n     path_str: &str,\n     dox: &str,\n     link_range: Option<Range<usize>>,\n-    candidates: &[(Def, Namespace)],\n+    candidates: PerNS<Option<Def>>,\n ) {\n     let sp = span_of_attrs(attrs);\n \n     let mut msg = format!(\"`{}` is \", path_str);\n \n-    match candidates {\n+    let candidates = [TypeNS, ValueNS, MacroNS].iter().filter_map(|&ns| {\n+        candidates[ns].map(|def| (def, ns))\n+    }).collect::<Vec<_>>();\n+    match candidates.as_slice() {\n         [(first_def, _), (second_def, _)] => {\n             msg += &format!(\n                 \"both {} {} and {} {}\",\n@@ -568,9 +537,9 @@ fn ambiguity_error(\n                             (Def::Union(..), _) => \"union\",\n                             (Def::Trait(..), _) => \"trait\",\n                             (Def::Mod(..), _) => \"module\",\n-                            (_, Namespace::Type) => \"type\",\n-                            (_, Namespace::Value) => \"value\",\n-                            (_, Namespace::Macro) => \"macro\",\n+                            (_, TypeNS) => \"type\",\n+                            (_, ValueNS) => \"value\",\n+                            (_, MacroNS) => \"macro\",\n                         };\n \n                         // FIXME: if this is an implied shortcut link, it's bad style to suggest `@`\n@@ -646,11 +615,11 @@ const PRIMITIVES: &[(&str, Def)] = &[\n     (\"char\",  Def::PrimTy(hir::PrimTy::Char)),\n ];\n \n-fn is_primitive(path_str: &str, is_val: bool) -> Option<Def> {\n-    if is_val {\n-        None\n-    } else {\n+fn is_primitive(path_str: &str, ns: Namespace) -> Option<Def> {\n+    if ns == TypeNS {\n         PRIMITIVES.iter().find(|x| x.0 == path_str).map(|x| x.1)\n+    } else {\n+        None\n     }\n }\n "}, {"sha": "9793cd06fb0e81195e883e26a15ced87f8d58b2a", "filename": "src/test/rustdoc-ui/intra-links-ambiguity.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/150b49a582f06b26391a6de542e9d4bc12c9aa2d/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/150b49a582f06b26391a6de542e9d4bc12c9aa2d/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fintra-links-ambiguity.stderr?ref=150b49a582f06b26391a6de542e9d4bc12c9aa2d", "patch": "@@ -32,15 +32,11 @@ help: to link to the function, add parentheses\n LL | /// [ambiguous()] is ambiguous.\n    |      ^^^^^^^^^^^\n \n-error: `multi_conflict` is a macro, a struct, and a function\n+error: `multi_conflict` is a struct, a function, and a macro\n   --> $DIR/intra-links-ambiguity.rs:31:6\n    |\n LL | /// [`multi_conflict`] is a three-way conflict.\n    |      ^^^^^^^^^^^^^^^^ ambiguous link\n-help: to link to the macro, prefix with the item type\n-   |\n-LL | /// [`macro@multi_conflict`] is a three-way conflict.\n-   |      ^^^^^^^^^^^^^^^^^^^^^^\n help: to link to the struct, prefix with the item type\n    |\n LL | /// [`struct@multi_conflict`] is a three-way conflict.\n@@ -49,6 +45,10 @@ help: to link to the function, add parentheses\n    |\n LL | /// [`multi_conflict()`] is a three-way conflict.\n    |      ^^^^^^^^^^^^^^^^^^\n+help: to link to the macro, prefix with the item type\n+   |\n+LL | /// [`macro@multi_conflict`] is a three-way conflict.\n+   |      ^^^^^^^^^^^^^^^^^^^^^^\n \n error: `type_and_value` is both a module and a constant\n   --> $DIR/intra-links-ambiguity.rs:33:16"}]}