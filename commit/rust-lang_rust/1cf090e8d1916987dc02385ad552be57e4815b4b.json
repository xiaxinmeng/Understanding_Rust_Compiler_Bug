{"sha": "1cf090e8d1916987dc02385ad552be57e4815b4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjZjA5MGU4ZDE5MTY5ODdkYzAyMzg1YWQ1NTJiZTU3ZTQ4MTViNGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-01T20:53:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-01T20:53:04Z"}, "message": "Auto merge of #69408 - RalfJung:canonical-alloc-id, r=oli-obk\n\nMiri: let machine canonicalize AllocIDs\n\nThis implements the rustc side of the plan I laid out [here](https://github.com/rust-lang/miri/pull/1147#issuecomment-581868901).\n\nMiri PR: https://github.com/rust-lang/miri/pull/1190", "tree": {"sha": "798a3de362f150b73ca900f7f564d0eec562c26e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/798a3de362f150b73ca900f7f564d0eec562c26e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1cf090e8d1916987dc02385ad552be57e4815b4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf090e8d1916987dc02385ad552be57e4815b4b", "html_url": "https://github.com/rust-lang/rust/commit/1cf090e8d1916987dc02385ad552be57e4815b4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1cf090e8d1916987dc02385ad552be57e4815b4b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "beac68a88711a90346ec8b68e3baefbec62b3b0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/beac68a88711a90346ec8b68e3baefbec62b3b0d", "html_url": "https://github.com/rust-lang/rust/commit/beac68a88711a90346ec8b68e3baefbec62b3b0d"}, {"sha": "9b62d60db18415caf3460b894e4f43f51da4f645", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b62d60db18415caf3460b894e4f43f51da4f645", "html_url": "https://github.com/rust-lang/rust/commit/9b62d60db18415caf3460b894e4f43f51da4f645"}], "stats": {"total": 124, "additions": 58, "deletions": 66}, "files": [{"sha": "25727b75faf14af09fcd7e84f6d0a0c8fdb503bc", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1cf090e8d1916987dc02385ad552be57e4815b4b/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf090e8d1916987dc02385ad552be57e4815b4b/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=1cf090e8d1916987dc02385ad552be57e4815b4b", "patch": "@@ -1,7 +1,6 @@\n use rustc::mir;\n use rustc::ty::layout::HasTyCtxt;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc_hir::def_id::DefId;\n+use rustc::ty::{self, Ty};\n use std::borrow::{Borrow, Cow};\n use std::collections::hash_map::Entry;\n use std::hash::Hash;\n@@ -320,13 +319,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         Err(ConstEvalErrKind::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into())\n     }\n \n-    fn find_foreign_static(\n-        _tcx: TyCtxt<'tcx>,\n-        _def_id: DefId,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        throw_unsup!(ReadForeignStatic)\n-    }\n-\n     #[inline(always)]\n     fn init_allocation_extra<'b>(\n         _memory_extra: &MemoryExtra,"}, {"sha": "69c9664b3515696f3d181066114aedc643819383", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 24, "deletions": 19, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1cf090e8d1916987dc02385ad552be57e4815b4b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf090e8d1916987dc02385ad552be57e4815b4b/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=1cf090e8d1916987dc02385ad552be57e4815b4b", "patch": "@@ -6,8 +6,7 @@ use std::borrow::{Borrow, Cow};\n use std::hash::Hash;\n \n use rustc::mir;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc_hir::def_id::DefId;\n+use rustc::ty::{self, Ty};\n use rustc_span::Span;\n \n use super::{\n@@ -123,10 +122,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n-    /// Called before a basic block terminator is executed.\n-    /// You can use this to detect endlessly running programs.\n-    fn before_terminator(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>;\n-\n     /// Entry point to all function calls.\n     ///\n     /// Returns either the mir to use for the call, or `None` if execution should\n@@ -175,18 +170,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx>;\n \n-    /// Called for read access to a foreign static item.\n-    ///\n-    /// This will only be called once per static and machine; the result is cached in\n-    /// the machine memory. (This relies on `AllocMap::get_or` being able to add the\n-    /// owned allocation to the map even when the map is shared.)\n-    ///\n-    /// This allocation will then be fed to `tag_allocation` to initialize the \"extra\" state.\n-    fn find_foreign_static(\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation>>;\n-\n     /// Called for all binary operations where the LHS has pointer type.\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n@@ -204,6 +187,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ) -> InterpResult<'tcx>;\n \n     /// Called to read the specified `local` from the `frame`.\n+    #[inline]\n     fn access_local(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         frame: &Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>,\n@@ -212,14 +196,33 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         frame.locals[local].access()\n     }\n \n+    /// Called before a basic block terminator is executed.\n+    /// You can use this to detect endlessly running programs.\n+    #[inline]\n+    fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n     /// Called before a `Static` value is accessed.\n+    #[inline]\n     fn before_access_static(\n         _memory_extra: &Self::MemoryExtra,\n         _allocation: &Allocation,\n     ) -> InterpResult<'tcx> {\n         Ok(())\n     }\n \n+    /// Called for *every* memory access to determine the real ID of the given allocation.\n+    /// This provides a way for the machine to \"redirect\" certain allocations as it sees fit.\n+    ///\n+    /// This is used by Miri to redirect extern statics to real allocations.\n+    ///\n+    /// This function must be idempotent.\n+    #[inline]\n+    fn canonical_alloc_id(_mem: &Memory<'mir, 'tcx, Self>, id: AllocId) -> AllocId {\n+        id\n+    }\n+\n     /// Called to initialize the \"extra\" state of an allocation and make the pointers\n     /// it contains (in relocations) tagged.  The way we construct allocations is\n     /// to always first construct it without extra and then add the extra.\n@@ -247,6 +250,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Return the \"base\" tag for the given *static* allocation: the one that is used for direct\n     /// accesses to this static/const/fn allocation. If `id` is not a static allocation,\n     /// this will return an unusable tag (i.e., accesses will be UB)!\n+    ///\n+    /// Expects `id` to be already canonical, if needed.\n     fn tag_static_base_pointer(memory_extra: &Self::MemoryExtra, id: AllocId) -> Self::PointerTag;\n \n     /// Executes a retagging operation\n@@ -259,7 +264,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         Ok(())\n     }\n \n-    /// Called immediately before a new stack frame got pushed\n+    /// Called immediately before a new stack frame got pushed.\n     fn stack_push(ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx, Self::FrameExtra>;\n \n     /// Called immediately after a stack frame gets popped"}, {"sha": "6517ae5d0f30f5e59ad97f16a1c8360bd5af4235", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1cf090e8d1916987dc02385ad552be57e4815b4b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf090e8d1916987dc02385ad552be57e4815b4b/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1cf090e8d1916987dc02385ad552be57e4815b4b", "patch": "@@ -150,7 +150,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// through a pointer that was created by the program.\n     #[inline]\n     pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n-        ptr.with_tag(M::tag_static_base_pointer(&self.extra, ptr.alloc_id))\n+        let id = M::canonical_alloc_id(self, ptr.alloc_id);\n+        ptr.with_tag(M::tag_static_base_pointer(&self.extra, id))\n     }\n \n     pub fn create_fn_alloc(\n@@ -421,6 +422,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// The `GlobalAlloc::Memory` branch here is still reachable though; when a static\n     /// contains a reference to memory that was created during its evaluation (i.e., not to\n     /// another static), those inner references only exist in \"resolved\" form.\n+    ///\n+    /// Assumes `id` is already canonical.\n     fn get_static_alloc(\n         memory_extra: &M::MemoryExtra,\n         tcx: TyCtxtAt<'tcx>,\n@@ -434,31 +437,30 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Static(def_id)) => {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n-                    trace!(\"static_alloc: foreign item {:?}\", def_id);\n-                    M::find_foreign_static(tcx.tcx, def_id)?\n-                } else {\n-                    trace!(\"static_alloc: Need to compute {:?}\", def_id);\n-                    let instance = Instance::mono(tcx.tcx, def_id);\n-                    let gid = GlobalId { instance, promoted: None };\n-                    // use the raw query here to break validation cycles. Later uses of the static\n-                    // will call the full query anyway\n-                    let raw_const =\n-                        tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n-                            // no need to report anything, the const_eval call takes care of that\n-                            // for statics\n-                            assert!(tcx.is_static(def_id));\n-                            match err {\n-                                ErrorHandled::Reported => err_inval!(ReferencedConstant),\n-                                ErrorHandled::TooGeneric => err_inval!(TooGeneric),\n-                            }\n-                        })?;\n-                    // Make sure we use the ID of the resolved memory, not the lazy one!\n-                    let id = raw_const.alloc_id;\n-                    let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n-\n-                    M::before_access_static(memory_extra, allocation)?;\n-                    Cow::Borrowed(allocation)\n+                    trace!(\"get_static_alloc: foreign item {:?}\", def_id);\n+                    throw_unsup!(ReadForeignStatic)\n                 }\n+                trace!(\"get_static_alloc: Need to compute {:?}\", def_id);\n+                let instance = Instance::mono(tcx.tcx, def_id);\n+                let gid = GlobalId { instance, promoted: None };\n+                // use the raw query here to break validation cycles. Later uses of the static\n+                // will call the full query anyway\n+                let raw_const =\n+                    tcx.const_eval_raw(ty::ParamEnv::reveal_all().and(gid)).map_err(|err| {\n+                        // no need to report anything, the const_eval call takes care of that\n+                        // for statics\n+                        assert!(tcx.is_static(def_id));\n+                        match err {\n+                            ErrorHandled::Reported => err_inval!(ReferencedConstant),\n+                            ErrorHandled::TooGeneric => err_inval!(TooGeneric),\n+                        }\n+                    })?;\n+                // Make sure we use the ID of the resolved memory, not the lazy one!\n+                let id = raw_const.alloc_id;\n+                let allocation = tcx.alloc_map.lock().unwrap_memory(id);\n+\n+                M::before_access_static(memory_extra, allocation)?;\n+                Cow::Borrowed(allocation)\n             }\n         };\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n@@ -478,6 +480,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n+        let id = M::canonical_alloc_id(self, id);\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n@@ -513,6 +516,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         &mut self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n+        let id = M::canonical_alloc_id(self, id);\n         let tcx = self.tcx;\n         let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n@@ -550,6 +554,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n+        let id = M::canonical_alloc_id(self, id);\n         // # Regular allocations\n         // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n@@ -602,6 +607,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Assumes `id` is already canonical.\n     fn get_fn_alloc(&self, id: AllocId) -> Option<FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"reading fn ptr: {}\", id);\n         if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n@@ -622,7 +628,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         if ptr.offset.bytes() != 0 {\n             throw_unsup!(InvalidFunctionPointer)\n         }\n-        self.get_fn_alloc(ptr.alloc_id).ok_or_else(|| err_unsup!(ExecuteMemory).into())\n+        let id = M::canonical_alloc_id(self, ptr.alloc_id);\n+        self.get_fn_alloc(id).ok_or_else(|| err_unsup!(ExecuteMemory).into())\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {"}, {"sha": "8c1b73510dfe79a0e24cfafe8265542427c7b2b6", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1cf090e8d1916987dc02385ad552be57e4815b4b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1cf090e8d1916987dc02385ad552be57e4815b4b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=1cf090e8d1916987dc02385ad552be57e4815b4b", "patch": "@@ -23,7 +23,6 @@ use rustc::ty::{self, ConstKind, Instance, ParamEnv, Ty, TyCtxt, TypeFoldable};\n use rustc_ast::ast::Mutability;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::HirId;\n use rustc_index::vec::IndexVec;\n use rustc_infer::traits;\n@@ -222,13 +221,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         ));\n     }\n \n-    fn find_foreign_static(\n-        _tcx: TyCtxt<'tcx>,\n-        _def_id: DefId,\n-    ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        throw_unsup!(ReadForeignStatic)\n-    }\n-\n     #[inline(always)]\n     fn init_allocation_extra<'b>(\n         _memory_extra: &(),\n@@ -279,10 +271,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine {\n         Ok(())\n     }\n \n-    fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n-        Ok(())\n-    }\n-\n     #[inline(always)]\n     fn stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n         Ok(())"}]}