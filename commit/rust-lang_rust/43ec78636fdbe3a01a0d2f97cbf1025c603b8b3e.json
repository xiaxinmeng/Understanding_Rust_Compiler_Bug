{"sha": "43ec78636fdbe3a01a0d2f97cbf1025c603b8b3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZWM3ODYzNmZkYmUzYTAxYTBkMmY5N2NiZjEwMjVjNjAzYjhiM2U=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-14T00:58:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-09-14T00:58:09Z"}, "message": "Update manual to cover change to nominal tag items.", "tree": {"sha": "c4b80f80000f35cdd3e9aac408243791e0944786", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4b80f80000f35cdd3e9aac408243791e0944786"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43ec78636fdbe3a01a0d2f97cbf1025c603b8b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43ec78636fdbe3a01a0d2f97cbf1025c603b8b3e", "html_url": "https://github.com/rust-lang/rust/commit/43ec78636fdbe3a01a0d2f97cbf1025c603b8b3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43ec78636fdbe3a01a0d2f97cbf1025c603b8b3e/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc646d01c501f2566fd78057e23c283cfedc0eb0", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc646d01c501f2566fd78057e23c283cfedc0eb0", "html_url": "https://github.com/rust-lang/rust/commit/bc646d01c501f2566fd78057e23c283cfedc0eb0"}], "stats": {"total": 99, "additions": 57, "deletions": 42}, "files": [{"sha": "c8af535b3b5173d6ada6f40fa9ccfa2b70231366", "filename": "doc/rust.texi", "status": "modified", "additions": 57, "deletions": 42, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/43ec78636fdbe3a01a0d2f97cbf1025c603b8b3e/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/43ec78636fdbe3a01a0d2f97cbf1025c603b8b3e/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=43ec78636fdbe3a01a0d2f97cbf1025c603b8b3e", "patch": "@@ -325,11 +325,11 @@ file.\n @sp 1\n @item Structural algebraic data types\n \n-The Rust type system is structural rather than nominal, and contains the\n-standard assortment of useful ``algebraic'' type constructors from functional\n-languages, such as function types, tuples, record types, vectors, and tagged\n-disjoint unions. Structural types may be @emph{pattern-matched} in an\n-@code{alt} statement.\n+The Rust type system is primarily structural, and contains the standard\n+assortment of useful ``algebraic'' type constructors from functional\n+languages, such as function types, tuples, record types, vectors, and\n+nominally-tagged disjoint unions. Such values may be @emph{pattern-matched} in\n+an @code{alt} statement.\n \n @sp 1\n @item Generic code\n@@ -1667,6 +1667,7 @@ are no general parametric types.\n * Ref.Item.Iter::               Items defining iterators.\n * Ref.Item.Obj::                Items defining objects.\n * Ref.Item.Type::               Items defining the types of values and slots.\n+* Ref.Item.Tag::                Items defining the constructors of a tag type.\n @end menu\n \n @node       Ref.Item.Mod\n@@ -1954,10 +1955,50 @@ values that are composite records, each containing two unsigned 8-bit\n integers accessed through the components @code{x} and @code{y}, and laid\n out in memory with the @code{x} component preceding the @code{y} component.\n \n-Some types are @emph{recursive}. A recursive type is one that includes\n-its own definition as a component, by named reference. Recursive types\n-are restricted to occur only within a single crate, and only through a\n-restricted form of @code{tag} type. @xref{Ref.Type.Tag}.\n+@node       Ref.Item.Tag\n+@subsection Ref.Item.Tag\n+@c * Ref.Item.Type::          Items defining the constructors of a tag type.\n+@cindex Tag types\n+\n+A tag item simultaneously declares a new nominal tag type\n+(@pxref{Ref.Type.Tag}) as well as a set of @emph{constructors} that can be\n+used to create or pattern-match values of the corresponding tag type.\n+\n+The constructors of a @code{tag} type may be recursive: that is, each constructor\n+may take an argument that refers, directly or indirectly, to the tag type the constructor\n+is a member of. Such recursion has restrictions:\n+@itemize\n+@item Recursive types can only be introduced through @code{tag} constructors.\n+@item A recursive @code{tag} item must have at least one non-recursive\n+constructor (in order to give the recursion a basis case).\n+@item The recursively argument of recursive tag constructors must be @emph{box}\n+values (in order to bound the in-memory size of the constructor).\n+@item Recursive type definitions can cross module boundaries, but not module\n+@emph{visibility} boundaries, nor crate boundaries (in order to simplify the\n+module system).\n+@end itemize\n+\n+An example of a @code{tag} item and its use:\n+@example\n+tag animal @{\n+  dog();\n+  cat();\n+@}\n+\n+let animal a = dog();\n+a = cat();\n+@end example\n+\n+An example of a @emph{recursive} @code{tag} item and its use:\n+@example\n+tag list[T] @{\n+  nil();\n+  cons(T, @@list[T]);\n+@}\n+\n+let list[int] a = cons(7, cons(13, nil()));\n+@end example\n+\n \n @page\n @node    Ref.Type\n@@ -2240,40 +2281,14 @@ vector is always bounds-checked.\n @cindex Tag types\n @cindex Union types, see @i{Tag types}\n \n-The @code{tag} type-constructor forms new heterogeneous disjoint union\n-types.@footnote{The @code{tag} type is analogous to a @code{data} constructor\n-declaration in ML or a @emph{pick ADT} in Limbo.} A @code{tag} type consists\n-of a number of @emph{variants}, each of which is independently named and takes\n-an optional tuple of arguments.\n-\n-The variants of a @code{tag} type may be recursive: that is, the definition of\n-a @code{tag} type may refer to type definitions that include the defined\n-@code{tag} type itself. Such recursion has restrictions:\n-@itemize\n-@item Recursive types can only be introduced through @code{tag} types.\n-@item A recursive @code{tag} type must have at least one non-recursive\n-variant (in order to give the recursion a basis case).\n-@item The recursively-typed members of recursive variants must be @emph{box}\n-values (in order to bound the in-memory size of the variant).\n-@item Recursive type definitions can cross module boundaries, but not module\n-@emph{visibility} boundaries, nor crate boundaries (in order to simplify the\n-module system).\n-@end itemize\n-\n-An example of a @code{tag} type and its use:\n-@example\n-type animal = tag(dog, cat);\n-let animal a = dog;\n-a = cat;\n-@end example\n-\n-An example of a @emph{recursive} @code{tag} type and its use:\n-@example\n-type list[T] = tag(nil(),\n-                   cons(T, @@list[T]));\n-let list[int] a = cons(7, cons(13, nil()));\n-@end example\n+A @emph{tag type} is a nominal, heterogeneous disjoint union\n+type.@footnote{The @code{tag} type is analogous to a @code{data} constructor\n+declaration in ML or a @emph{pick ADT} in Limbo.} A @code{tag} @emph{item}\n+consists of a number of @emph{constructors}, each of which is independently\n+named and takes an optional tuple of arguments.\n \n+Tag types cannot be denoted @emph{structurally} as types, but must be denoted\n+by named reference to a @emph{tag item} declaration. @xref{Ref.Item.Tag}.\n \n @node       Ref.Type.Fn\n @subsection Ref.Type.Fn"}]}