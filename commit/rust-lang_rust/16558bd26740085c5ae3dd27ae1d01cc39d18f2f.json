{"sha": "16558bd26740085c5ae3dd27ae1d01cc39d18f2f", "node_id": "C_kwDOAAsO6NoAKDE2NTU4YmQyNjc0MDA4NWM1YWUzZGQyN2FlMWQwMWNjMzlkMThmMmY", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-05T19:58:10Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-06T12:25:06Z"}, "message": "Rename `tcx` to `qcx` when it's a `QueryContext`", "tree": {"sha": "881ec6408eb0332d05be13dc64babbcecb248a25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/881ec6408eb0332d05be13dc64babbcecb248a25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/16558bd26740085c5ae3dd27ae1d01cc39d18f2f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgbSfWKRQb2tiqhuHtakDJeupmrF\nChDbM0msU+PXaBOk8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQCUstPNPPUU0FA6a/A2qOZhZEmlCteSW0ZundOJnkbsmwe7M3oBQqifXtOz/jDb3ou\nsXPkoTQFFgmNpjuxmqvA4=\n-----END SSH SIGNATURE-----", "payload": "tree 881ec6408eb0332d05be13dc64babbcecb248a25\nparent 91971f293cba3bcbe20bb93236254cc1550e1049\nauthor Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1667678290 +0100\ncommitter Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1667737506 +0100\n\nRename `tcx` to `qcx` when it's a `QueryContext`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/16558bd26740085c5ae3dd27ae1d01cc39d18f2f", "html_url": "https://github.com/rust-lang/rust/commit/16558bd26740085c5ae3dd27ae1d01cc39d18f2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/16558bd26740085c5ae3dd27ae1d01cc39d18f2f/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91971f293cba3bcbe20bb93236254cc1550e1049", "url": "https://api.github.com/repos/rust-lang/rust/commits/91971f293cba3bcbe20bb93236254cc1550e1049", "html_url": "https://github.com/rust-lang/rust/commit/91971f293cba3bcbe20bb93236254cc1550e1049"}], "stats": {"total": 188, "additions": 94, "deletions": 94}, "files": [{"sha": "e856e39bf212a8cb52d7741b24ec860e889c3ac9", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/16558bd26740085c5ae3dd27ae1d01cc39d18f2f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16558bd26740085c5ae3dd27ae1d01cc39d18f2f/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=16558bd26740085c5ae3dd27ae1d01cc39d18f2f", "patch": "@@ -573,10 +573,10 @@ impl<K: DepKind> DepGraph<K> {\n     /// a node index can be found for that node.\n     pub fn try_mark_green<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Ctxt,\n         dep_node: &DepNode<K>,\n     ) -> Option<(SerializedDepNodeIndex, DepNodeIndex)> {\n-        debug_assert!(!tcx.dep_context().is_eval_always(dep_node.kind));\n+        debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n \n         // Return None if the dep graph is disabled\n         let data = self.data.as_ref()?;\n@@ -592,16 +592,16 @@ impl<K: DepKind> DepGraph<K> {\n                 // in the previous compilation session too, so we can try to\n                 // mark it as green by recursively marking all of its\n                 // dependencies green.\n-                self.try_mark_previous_green(tcx, data, prev_index, &dep_node)\n+                self.try_mark_previous_green(qcx, data, prev_index, &dep_node)\n                     .map(|dep_node_index| (prev_index, dep_node_index))\n             }\n         }\n     }\n \n-    #[instrument(skip(self, tcx, data, parent_dep_node_index), level = \"debug\")]\n+    #[instrument(skip(self, qcx, data, parent_dep_node_index), level = \"debug\")]\n     fn try_mark_parent_green<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Ctxt,\n         data: &DepGraphData<K>,\n         parent_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n@@ -630,14 +630,14 @@ impl<K: DepKind> DepGraph<K> {\n \n         // We don't know the state of this dependency. If it isn't\n         // an eval_always node, let's try to mark it green recursively.\n-        if !tcx.dep_context().is_eval_always(dep_dep_node.kind) {\n+        if !qcx.dep_context().is_eval_always(dep_dep_node.kind) {\n             debug!(\n                 \"state of dependency {:?} ({}) is unknown, trying to mark it green\",\n                 dep_dep_node, dep_dep_node.hash,\n             );\n \n             let node_index =\n-                self.try_mark_previous_green(tcx, data, parent_dep_node_index, dep_dep_node);\n+                self.try_mark_previous_green(qcx, data, parent_dep_node_index, dep_dep_node);\n \n             if node_index.is_some() {\n                 debug!(\"managed to MARK dependency {dep_dep_node:?} as green\",);\n@@ -647,7 +647,7 @@ impl<K: DepKind> DepGraph<K> {\n \n         // We failed to mark it green, so we try to force the query.\n         debug!(\"trying to force dependency {dep_dep_node:?}\");\n-        if !tcx.dep_context().try_force_from_dep_node(*dep_dep_node) {\n+        if !qcx.dep_context().try_force_from_dep_node(*dep_dep_node) {\n             // The DepNode could not be forced.\n             debug!(\"dependency {dep_dep_node:?} could not be forced\");\n             return None;\n@@ -667,7 +667,7 @@ impl<K: DepKind> DepGraph<K> {\n             None => {}\n         }\n \n-        if !tcx.dep_context().sess().has_errors_or_delayed_span_bugs() {\n+        if !qcx.dep_context().sess().has_errors_or_delayed_span_bugs() {\n             panic!(\"try_mark_previous_green() - Forcing the DepNode should have set its color\")\n         }\n \n@@ -686,10 +686,10 @@ impl<K: DepKind> DepGraph<K> {\n     }\n \n     /// Try to mark a dep-node which existed in the previous compilation session as green.\n-    #[instrument(skip(self, tcx, data, prev_dep_node_index), level = \"debug\")]\n+    #[instrument(skip(self, qcx, data, prev_dep_node_index), level = \"debug\")]\n     fn try_mark_previous_green<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Ctxt,\n         data: &DepGraphData<K>,\n         prev_dep_node_index: SerializedDepNodeIndex,\n         dep_node: &DepNode<K>,\n@@ -701,14 +701,14 @@ impl<K: DepKind> DepGraph<K> {\n         }\n \n         // We never try to mark eval_always nodes as green\n-        debug_assert!(!tcx.dep_context().is_eval_always(dep_node.kind));\n+        debug_assert!(!qcx.dep_context().is_eval_always(dep_node.kind));\n \n         debug_assert_eq!(data.previous.index_to_node(prev_dep_node_index), *dep_node);\n \n         let prev_deps = data.previous.edge_targets_from(prev_dep_node_index);\n \n         for &dep_dep_node_index in prev_deps {\n-            self.try_mark_parent_green(tcx, data, dep_dep_node_index, dep_node)?\n+            self.try_mark_parent_green(qcx, data, dep_dep_node_index, dep_node)?\n         }\n \n         // If we got here without hitting a `return` that means that all\n@@ -720,7 +720,7 @@ impl<K: DepKind> DepGraph<K> {\n         // We allocating an entry for the node in the current dependency graph and\n         // adding all the appropriate edges imported from the previous graph\n         let dep_node_index = data.current.promote_node_and_deps_to_current(\n-            tcx.dep_context().profiler(),\n+            qcx.dep_context().profiler(),\n             &data.previous,\n             prev_dep_node_index,\n         );\n@@ -729,7 +729,7 @@ impl<K: DepKind> DepGraph<K> {\n \n         // FIXME: Store the fact that a node has diagnostics in a bit in the dep graph somewhere\n         // Maybe store a list on disk and encode this fact in the DepNodeState\n-        let side_effects = tcx.load_side_effects(prev_dep_node_index);\n+        let side_effects = qcx.load_side_effects(prev_dep_node_index);\n \n         #[cfg(not(parallel_compiler))]\n         debug_assert!(\n@@ -740,7 +740,7 @@ impl<K: DepKind> DepGraph<K> {\n         );\n \n         if !side_effects.is_empty() {\n-            self.emit_side_effects(tcx, data, dep_node_index, side_effects);\n+            self.emit_side_effects(qcx, data, dep_node_index, side_effects);\n         }\n \n         // ... and finally storing a \"Green\" entry in the color map.\n@@ -757,7 +757,7 @@ impl<K: DepKind> DepGraph<K> {\n     #[inline(never)]\n     fn emit_side_effects<Ctxt: QueryContext<DepKind = K>>(\n         &self,\n-        tcx: Ctxt,\n+        qcx: Ctxt,\n         data: &DepGraphData<K>,\n         dep_node_index: DepNodeIndex,\n         side_effects: QuerySideEffects,\n@@ -769,9 +769,9 @@ impl<K: DepKind> DepGraph<K> {\n             // must process side effects\n \n             // Promote the previous diagnostics to the current session.\n-            tcx.store_side_effects(dep_node_index, side_effects.clone());\n+            qcx.store_side_effects(dep_node_index, side_effects.clone());\n \n-            let handle = tcx.dep_context().sess().diagnostic();\n+            let handle = qcx.dep_context().sess().diagnostic();\n \n             for mut diagnostic in side_effects.diagnostics {\n                 handle.emit_diagnostic(&mut diagnostic);"}, {"sha": "bd21b5465e2f4539cd8258b3eaaa9ebfe63c689c", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/16558bd26740085c5ae3dd27ae1d01cc39d18f2f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16558bd26740085c5ae3dd27ae1d01cc39d18f2f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=16558bd26740085c5ae3dd27ae1d01cc39d18f2f", "patch": "@@ -597,7 +597,7 @@ pub(crate) fn report_cycle<'a>(\n }\n \n pub fn print_query_stack<CTX: QueryContext>(\n-    tcx: CTX,\n+    qcx: CTX,\n     mut current_query: Option<QueryJobId>,\n     handler: &Handler,\n     num_frames: Option<usize>,\n@@ -606,7 +606,7 @@ pub fn print_query_stack<CTX: QueryContext>(\n     // a panic hook, which means that the global `Handler` may be in a weird\n     // state if it was responsible for triggering the panic.\n     let mut i = 0;\n-    let query_map = tcx.try_collect_active_jobs();\n+    let query_map = qcx.try_collect_active_jobs();\n \n     while let Some(query) = current_query {\n         if Some(i) == num_frames {"}, {"sha": "6348bc6b3afaf0371744d726d6e21c64f566902d", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 73, "deletions": 73, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/16558bd26740085c5ae3dd27ae1d01cc39d18f2f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/16558bd26740085c5ae3dd27ae1d01cc39d18f2f/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=16558bd26740085c5ae3dd27ae1d01cc39d18f2f", "patch": "@@ -64,7 +64,7 @@ where\n \n     pub fn try_collect_active_jobs<CTX: Copy>(\n         &self,\n-        tcx: CTX,\n+        qcx: CTX,\n         make_query: fn(CTX, K) -> QueryStackFrame,\n         jobs: &mut QueryMap,\n     ) -> Option<()> {\n@@ -76,7 +76,7 @@ where\n             for shard in shards.iter() {\n                 for (k, v) in shard.iter() {\n                     if let QueryResult::Started(ref job) = *v {\n-                        let query = make_query(tcx, k.clone());\n+                        let query = make_query(qcx, k.clone());\n                         jobs.insert(job.id, QueryJobInfo { query, job: job.clone() });\n                     }\n                 }\n@@ -90,7 +90,7 @@ where\n             // really hurt much.)\n             for (k, v) in self.active.try_lock()?.iter() {\n                 if let QueryResult::Started(ref job) = *v {\n-                    let query = make_query(tcx, k.clone());\n+                    let query = make_query(qcx, k.clone());\n                     jobs.insert(job.id, QueryJobInfo { query, job: job.clone() });\n                 }\n             }\n@@ -120,7 +120,7 @@ where\n #[cold]\n #[inline(never)]\n fn mk_cycle<CTX, V, R>(\n-    tcx: CTX,\n+    qcx: CTX,\n     cycle_error: CycleError,\n     handler: HandleCycleError,\n     cache: &dyn crate::query::QueryStorage<Value = V, Stored = R>,\n@@ -130,8 +130,8 @@ where\n     V: std::fmt::Debug + Value<CTX::DepContext>,\n     R: Clone,\n {\n-    let error = report_cycle(tcx.dep_context().sess(), &cycle_error);\n-    let value = handle_cycle_error(*tcx.dep_context(), &cycle_error, error, handler);\n+    let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n+    let value = handle_cycle_error(*qcx.dep_context(), &cycle_error, error, handler);\n     cache.store_nocache(value)\n }\n \n@@ -177,7 +177,7 @@ where\n     /// for some compile-time benchmarks.\n     #[inline(always)]\n     fn try_start<'b, CTX>(\n-        tcx: &'b CTX,\n+        qcx: &'b CTX,\n         state: &'b QueryState<K>,\n         span: Span,\n         key: K,\n@@ -193,8 +193,8 @@ where\n \n         match lock.entry(key) {\n             Entry::Vacant(entry) => {\n-                let id = tcx.next_job_id();\n-                let job = tcx.current_query_job();\n+                let id = qcx.next_job_id();\n+                let job = qcx.current_query_job();\n                 let job = QueryJob::new(id, span, job);\n \n                 let key = entry.key().clone();\n@@ -213,8 +213,8 @@ where\n                         // If we are single-threaded we know that we have cycle error,\n                         // so we just return the error.\n                         return TryGetJob::Cycle(id.find_cycle_in_stack(\n-                            tcx.try_collect_active_jobs().unwrap(),\n-                            &tcx.current_query_job(),\n+                            qcx.try_collect_active_jobs().unwrap(),\n+                            &qcx.current_query_job(),\n                             span,\n                         ));\n                     }\n@@ -223,7 +223,7 @@ where\n                         // For parallel queries, we'll block and wait until the query running\n                         // in another thread has completed. Record how long we wait in the\n                         // self-profiler.\n-                        let query_blocked_prof_timer = tcx.dep_context().profiler().query_blocked();\n+                        let query_blocked_prof_timer = qcx.dep_context().profiler().query_blocked();\n \n                         // Get the latch out\n                         let latch = job.latch();\n@@ -232,7 +232,7 @@ where\n \n                         // With parallel queries we might just have to wait on some other\n                         // thread.\n-                        let result = latch.wait_on(tcx.current_query_job(), span);\n+                        let result = latch.wait_on(qcx.current_query_job(), span);\n \n                         match result {\n                             Ok(()) => TryGetJob::JobCompleted(query_blocked_prof_timer),\n@@ -357,7 +357,7 @@ where\n }\n \n fn try_execute_query<CTX, C>(\n-    tcx: CTX,\n+    qcx: CTX,\n     state: &QueryState<C::Key>,\n     cache: &C,\n     span: Span,\n@@ -371,14 +371,14 @@ where\n     C::Value: Value<CTX::DepContext>,\n     CTX: QueryContext,\n {\n-    match JobOwner::<'_, C::Key>::try_start(&tcx, state, span, key.clone()) {\n+    match JobOwner::<'_, C::Key>::try_start(&qcx, state, span, key.clone()) {\n         TryGetJob::NotYetStarted(job) => {\n-            let (result, dep_node_index) = execute_job(tcx, key, dep_node, query, job.id);\n+            let (result, dep_node_index) = execute_job(qcx, key, dep_node, query, job.id);\n             let result = job.complete(cache, result, dep_node_index);\n             (result, Some(dep_node_index))\n         }\n         TryGetJob::Cycle(error) => {\n-            let result = mk_cycle(tcx, error, query.handle_cycle_error, cache);\n+            let result = mk_cycle(qcx, error, query.handle_cycle_error, cache);\n             (result, None)\n         }\n         #[cfg(parallel_compiler)]\n@@ -387,8 +387,8 @@ where\n                 .lookup(&key, |value, index| (value.clone(), index))\n                 .unwrap_or_else(|_| panic!(\"value must be in cache after waiting\"));\n \n-            if std::intrinsics::unlikely(tcx.dep_context().profiler().enabled()) {\n-                tcx.dep_context().profiler().query_cache_hit(index.into());\n+            if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n+                qcx.dep_context().profiler().query_cache_hit(index.into());\n             }\n             query_blocked_prof_timer.finish_with_query_invocation_id(index.into());\n \n@@ -398,7 +398,7 @@ where\n }\n \n fn execute_job<CTX, K, V>(\n-    tcx: CTX,\n+    qcx: CTX,\n     key: K,\n     mut dep_node_opt: Option<DepNode<CTX::DepKind>>,\n     query: &QueryVTable<CTX, K, V>,\n@@ -409,13 +409,13 @@ where\n     V: Debug,\n     CTX: QueryContext,\n {\n-    let dep_graph = tcx.dep_context().dep_graph();\n+    let dep_graph = qcx.dep_context().dep_graph();\n \n     // Fast path for when incr. comp. is off.\n     if !dep_graph.is_fully_enabled() {\n-        let prof_timer = tcx.dep_context().profiler().query_provider();\n-        let result = tcx.start_query(job_id, query.depth_limit, None, || {\n-            query.compute(*tcx.dep_context(), key)\n+        let prof_timer = qcx.dep_context().profiler().query_provider();\n+        let result = qcx.start_query(job_id, query.depth_limit, None, || {\n+            query.compute(*qcx.dep_context(), key)\n         });\n         let dep_node_index = dep_graph.next_virtual_depnode_index();\n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -425,33 +425,33 @@ where\n     if !query.anon && !query.eval_always {\n         // `to_dep_node` is expensive for some `DepKind`s.\n         let dep_node =\n-            dep_node_opt.get_or_insert_with(|| query.to_dep_node(*tcx.dep_context(), &key));\n+            dep_node_opt.get_or_insert_with(|| query.to_dep_node(*qcx.dep_context(), &key));\n \n         // The diagnostics for this query will be promoted to the current session during\n         // `try_mark_green()`, so we can ignore them here.\n-        if let Some(ret) = tcx.start_query(job_id, false, None, || {\n-            try_load_from_disk_and_cache_in_memory(tcx, &key, &dep_node, query)\n+        if let Some(ret) = qcx.start_query(job_id, false, None, || {\n+            try_load_from_disk_and_cache_in_memory(qcx, &key, &dep_node, query)\n         }) {\n             return ret;\n         }\n     }\n \n-    let prof_timer = tcx.dep_context().profiler().query_provider();\n+    let prof_timer = qcx.dep_context().profiler().query_provider();\n     let diagnostics = Lock::new(ThinVec::new());\n \n     let (result, dep_node_index) =\n-        tcx.start_query(job_id, query.depth_limit, Some(&diagnostics), || {\n+        qcx.start_query(job_id, query.depth_limit, Some(&diagnostics), || {\n             if query.anon {\n-                return dep_graph.with_anon_task(*tcx.dep_context(), query.dep_kind, || {\n-                    query.compute(*tcx.dep_context(), key)\n+                return dep_graph.with_anon_task(*qcx.dep_context(), query.dep_kind, || {\n+                    query.compute(*qcx.dep_context(), key)\n                 });\n             }\n \n             // `to_dep_node` is expensive for some `DepKind`s.\n             let dep_node =\n-                dep_node_opt.unwrap_or_else(|| query.to_dep_node(*tcx.dep_context(), &key));\n+                dep_node_opt.unwrap_or_else(|| query.to_dep_node(*qcx.dep_context(), &key));\n \n-            dep_graph.with_task(dep_node, *tcx.dep_context(), key, query.compute, query.hash_result)\n+            dep_graph.with_task(dep_node, *qcx.dep_context(), key, query.compute, query.hash_result)\n         });\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n@@ -461,17 +461,17 @@ where\n \n     if std::intrinsics::unlikely(!side_effects.is_empty()) {\n         if query.anon {\n-            tcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n+            qcx.store_side_effects_for_anon_node(dep_node_index, side_effects);\n         } else {\n-            tcx.store_side_effects(dep_node_index, side_effects);\n+            qcx.store_side_effects(dep_node_index, side_effects);\n         }\n     }\n \n     (result, dep_node_index)\n }\n \n fn try_load_from_disk_and_cache_in_memory<CTX, K, V>(\n-    tcx: CTX,\n+    qcx: CTX,\n     key: &K,\n     dep_node: &DepNode<CTX::DepKind>,\n     query: &QueryVTable<CTX, K, V>,\n@@ -484,32 +484,32 @@ where\n     // Note this function can be called concurrently from the same query\n     // We must ensure that this is handled correctly.\n \n-    let dep_graph = tcx.dep_context().dep_graph();\n-    let (prev_dep_node_index, dep_node_index) = dep_graph.try_mark_green(tcx, &dep_node)?;\n+    let dep_graph = qcx.dep_context().dep_graph();\n+    let (prev_dep_node_index, dep_node_index) = dep_graph.try_mark_green(qcx, &dep_node)?;\n \n     debug_assert!(dep_graph.is_green(dep_node));\n \n     // First we try to load the result from the on-disk cache.\n     // Some things are never cached on disk.\n     if let Some(try_load_from_disk) = query.try_load_from_disk {\n-        let prof_timer = tcx.dep_context().profiler().incr_cache_loading();\n+        let prof_timer = qcx.dep_context().profiler().incr_cache_loading();\n \n         // The call to `with_query_deserialization` enforces that no new `DepNodes`\n         // are created during deserialization. See the docs of that method for more\n         // details.\n         let result =\n-            dep_graph.with_query_deserialization(|| try_load_from_disk(tcx, prev_dep_node_index));\n+            dep_graph.with_query_deserialization(|| try_load_from_disk(qcx, prev_dep_node_index));\n \n         prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n         if let Some(result) = result {\n             if std::intrinsics::unlikely(\n-                tcx.dep_context().sess().opts.unstable_opts.query_dep_graph,\n+                qcx.dep_context().sess().opts.unstable_opts.query_dep_graph,\n             ) {\n                 dep_graph.mark_debug_loaded_from_disk(*dep_node)\n             }\n \n-            let prev_fingerprint = tcx\n+            let prev_fingerprint = qcx\n                 .dep_context()\n                 .dep_graph()\n                 .prev_fingerprint_of(dep_node)\n@@ -523,9 +523,9 @@ where\n             // give us some coverage of potential bugs though.\n             let try_verify = prev_fingerprint.as_value().1 % 32 == 0;\n             if std::intrinsics::unlikely(\n-                try_verify || tcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n+                try_verify || qcx.dep_context().sess().opts.unstable_opts.incremental_verify_ich,\n             ) {\n-                incremental_verify_ich(*tcx.dep_context(), &result, dep_node, query);\n+                incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n             }\n \n             return Some((result, dep_node_index));\n@@ -534,18 +534,18 @@ where\n         // We always expect to find a cached result for things that\n         // can be forced from `DepNode`.\n         debug_assert!(\n-            !tcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n+            !qcx.dep_context().fingerprint_style(dep_node.kind).reconstructible(),\n             \"missing on-disk cache entry for {:?}\",\n             dep_node\n         );\n     }\n \n     // We could not load a result from the on-disk cache, so\n     // recompute.\n-    let prof_timer = tcx.dep_context().profiler().query_provider();\n+    let prof_timer = qcx.dep_context().profiler().query_provider();\n \n     // The dep-graph for this computation is already in-place.\n-    let result = dep_graph.with_ignore(|| query.compute(*tcx.dep_context(), key.clone()));\n+    let result = dep_graph.with_ignore(|| query.compute(*qcx.dep_context(), key.clone()));\n \n     prof_timer.finish_with_query_invocation_id(dep_node_index.into());\n \n@@ -558,35 +558,35 @@ where\n     //\n     // See issue #82920 for an example of a miscompilation that would get turned into\n     // an ICE by this check\n-    incremental_verify_ich(*tcx.dep_context(), &result, dep_node, query);\n+    incremental_verify_ich(*qcx.dep_context(), &result, dep_node, query);\n \n     Some((result, dep_node_index))\n }\n \n-#[instrument(skip(tcx, result, query), level = \"debug\")]\n+#[instrument(skip(qcx, result, query), level = \"debug\")]\n fn incremental_verify_ich<CTX, K, V: Debug>(\n-    tcx: CTX::DepContext,\n+    qcx: CTX::DepContext,\n     result: &V,\n     dep_node: &DepNode<CTX::DepKind>,\n     query: &QueryVTable<CTX, K, V>,\n ) where\n     CTX: QueryContext,\n {\n     assert!(\n-        tcx.dep_graph().is_green(dep_node),\n+        qcx.dep_graph().is_green(dep_node),\n         \"fingerprint for green query instance not loaded from cache: {:?}\",\n         dep_node,\n     );\n \n     let new_hash = query.hash_result.map_or(Fingerprint::ZERO, |f| {\n-        tcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n+        qcx.with_stable_hashing_context(|mut hcx| f(&mut hcx, result))\n     });\n \n-    let old_hash = tcx.dep_graph().prev_fingerprint_of(dep_node);\n+    let old_hash = qcx.dep_graph().prev_fingerprint_of(dep_node);\n \n     if Some(new_hash) != old_hash {\n         incremental_verify_ich_failed(\n-            tcx.sess(),\n+            qcx.sess(),\n             DebugArg::from(&dep_node),\n             DebugArg::from(&result),\n         );\n@@ -677,7 +677,7 @@ fn incremental_verify_ich_failed(sess: &Session, dep_node: DebugArg<'_>, result:\n /// Note: The optimization is only available during incr. comp.\n #[inline(never)]\n fn ensure_must_run<CTX, K, V>(\n-    tcx: CTX,\n+    qcx: CTX,\n     key: &K,\n     query: &QueryVTable<CTX, K, V>,\n ) -> (bool, Option<DepNode<CTX::DepKind>>)\n@@ -692,10 +692,10 @@ where\n     // Ensuring an anonymous query makes no sense\n     assert!(!query.anon);\n \n-    let dep_node = query.to_dep_node(*tcx.dep_context(), key);\n+    let dep_node = query.to_dep_node(*qcx.dep_context(), key);\n \n-    let dep_graph = tcx.dep_context().dep_graph();\n-    match dep_graph.try_mark_green(tcx, &dep_node) {\n+    let dep_graph = qcx.dep_context().dep_graph();\n+    match dep_graph.try_mark_green(qcx, &dep_node) {\n         None => {\n             // A None return from `try_mark_green` means that this is either\n             // a new dep node or that the dep node has already been marked red.\n@@ -707,7 +707,7 @@ where\n         }\n         Some((_, dep_node_index)) => {\n             dep_graph.read_index(dep_node_index);\n-            tcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n+            qcx.dep_context().profiler().query_cache_hit(dep_node_index.into());\n             (false, None)\n         }\n     }\n@@ -719,16 +719,16 @@ pub enum QueryMode {\n     Ensure,\n }\n \n-pub fn get_query<Q, CTX>(tcx: CTX, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n+pub fn get_query<Q, CTX>(qcx: CTX, span: Span, key: Q::Key, mode: QueryMode) -> Option<Q::Stored>\n where\n     Q: QueryConfig<CTX>,\n     Q::Key: DepNodeParams<CTX::DepContext>,\n     Q::Value: Value<CTX::DepContext>,\n     CTX: QueryContext,\n {\n-    let query = Q::make_vtable(tcx, &key);\n+    let query = Q::make_vtable(qcx, &key);\n     let dep_node = if let QueryMode::Ensure = mode {\n-        let (must_run, dep_node) = ensure_must_run(tcx, &key, &query);\n+        let (must_run, dep_node) = ensure_must_run(qcx, &key, &query);\n         if !must_run {\n             return None;\n         }\n@@ -738,21 +738,21 @@ where\n     };\n \n     let (result, dep_node_index) = try_execute_query(\n-        tcx,\n-        Q::query_state(tcx),\n-        Q::query_cache(tcx),\n+        qcx,\n+        Q::query_state(qcx),\n+        Q::query_cache(qcx),\n         span,\n         key,\n         dep_node,\n         &query,\n     );\n     if let Some(dep_node_index) = dep_node_index {\n-        tcx.dep_context().dep_graph().read_index(dep_node_index)\n+        qcx.dep_context().dep_graph().read_index(dep_node_index)\n     }\n     Some(result)\n }\n \n-pub fn force_query<Q, CTX>(tcx: CTX, key: Q::Key, dep_node: DepNode<CTX::DepKind>)\n+pub fn force_query<Q, CTX>(qcx: CTX, key: Q::Key, dep_node: DepNode<CTX::DepKind>)\n where\n     Q: QueryConfig<CTX>,\n     Q::Key: DepNodeParams<CTX::DepContext>,\n@@ -761,10 +761,10 @@ where\n {\n     // We may be concurrently trying both execute and force a query.\n     // Ensure that only one of them runs the query.\n-    let cache = Q::query_cache(tcx);\n+    let cache = Q::query_cache(qcx);\n     let cached = cache.lookup(&key, |_, index| {\n-        if std::intrinsics::unlikely(tcx.dep_context().profiler().enabled()) {\n-            tcx.dep_context().profiler().query_cache_hit(index.into());\n+        if std::intrinsics::unlikely(qcx.dep_context().profiler().enabled()) {\n+            qcx.dep_context().profiler().query_cache_hit(index.into());\n         }\n     });\n \n@@ -773,9 +773,9 @@ where\n         Err(()) => {}\n     }\n \n-    let query = Q::make_vtable(tcx, &key);\n-    let state = Q::query_state(tcx);\n+    let query = Q::make_vtable(qcx, &key);\n+    let state = Q::query_state(qcx);\n     debug_assert!(!query.anon);\n \n-    try_execute_query(tcx, state, cache, DUMMY_SP, key, Some(dep_node), &query);\n+    try_execute_query(qcx, state, cache, DUMMY_SP, key, Some(dep_node), &query);\n }"}]}