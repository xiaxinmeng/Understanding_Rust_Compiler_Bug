{"sha": "8cc61c816a0f08535f6300af4a5eaf30b8094c57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjYzYxYzgxNmEwZjA4NTM1ZjYzMDBhZjRhNWVhZjMwYjgwOTRjNTc=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-01T21:01:42Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-10-01T21:09:09Z"}, "message": "De-export std::{rope,smallintmap}. Part of #3583.", "tree": {"sha": "45db7a4ab712de5c6ae06771b09c7c047169a197", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/45db7a4ab712de5c6ae06771b09c7c047169a197"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cc61c816a0f08535f6300af4a5eaf30b8094c57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cc61c816a0f08535f6300af4a5eaf30b8094c57", "html_url": "https://github.com/rust-lang/rust/commit/8cc61c816a0f08535f6300af4a5eaf30b8094c57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cc61c816a0f08535f6300af4a5eaf30b8094c57/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ff95e29b3ae9e3de405680ddb6557da72cc25f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ff95e29b3ae9e3de405680ddb6557da72cc25f7", "html_url": "https://github.com/rust-lang/rust/commit/9ff95e29b3ae9e3de405680ddb6557da72cc25f7"}], "stats": {"total": 155, "additions": 74, "deletions": 81}, "files": [{"sha": "47539b2dab67bc3bd6849546c73a07aecdccf483", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 67, "deletions": 72, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/8cc61c816a0f08535f6300af4a5eaf30b8094c57/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc61c816a0f08535f6300af4a5eaf30b8094c57/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=8cc61c816a0f08535f6300af4a5eaf30b8094c57", "patch": "@@ -26,14 +26,14 @@\n #[forbid(deprecated_mode)];\n \n /// The type of ropes.\n-type Rope = node::Root;\n+pub type Rope = node::Root;\n \n /*\n  Section: Creating a rope\n  */\n \n /// Create an empty rope\n-fn empty() -> Rope {\n+pub fn empty() -> Rope {\n    return node::Empty;\n }\n \n@@ -54,7 +54,7 @@ fn empty() -> Rope {\n  * * this operation does not copy the string;\n  * * the function runs in linear time.\n  */\n-fn of_str(str: @~str) -> Rope {\n+pub fn of_str(str: @~str) -> Rope {\n     return of_substr(str, 0u, str::len(*str));\n }\n \n@@ -80,7 +80,7 @@ fn of_str(str: @~str) -> Rope {\n  * * this function does _not_ check the validity of the substring;\n  * * this function fails if `byte_offset` or `byte_len` do not match `str`.\n  */\n-fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> Rope {\n+pub fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> Rope {\n     if byte_len == 0u { return node::Empty; }\n     if byte_offset + byte_len  > str::len(*str) { fail; }\n     return node::Content(node::of_substr(str, byte_offset, byte_len));\n@@ -97,7 +97,7 @@ Section: Adding things to a rope\n  *\n  * * this function executes in near-constant time\n  */\n-fn append_char(rope: Rope, char: char) -> Rope {\n+pub fn append_char(rope: Rope, char: char) -> Rope {\n     return append_str(rope, @str::from_chars(~[char]));\n }\n \n@@ -108,7 +108,7 @@ fn append_char(rope: Rope, char: char) -> Rope {\n  *\n  * * this function executes in near-linear time\n  */\n-fn append_str(rope: Rope, str: @~str) -> Rope {\n+pub fn append_str(rope: Rope, str: @~str) -> Rope {\n     return append_rope(rope, of_str(str))\n }\n \n@@ -118,7 +118,7 @@ fn append_str(rope: Rope, str: @~str) -> Rope {\n  * # Performance note\n  * * this function executes in near-constant time\n  */\n-fn prepend_char(rope: Rope, char: char) -> Rope {\n+pub fn prepend_char(rope: Rope, char: char) -> Rope {\n     return prepend_str(rope, @str::from_chars(~[char]));\n }\n \n@@ -128,12 +128,12 @@ fn prepend_char(rope: Rope, char: char) -> Rope {\n  * # Performance note\n  * * this function executes in near-linear time\n  */\n-fn prepend_str(rope: Rope, str: @~str) -> Rope {\n+pub fn prepend_str(rope: Rope, str: @~str) -> Rope {\n     return append_rope(of_str(str), rope)\n }\n \n /// Concatenate two ropes\n-fn append_rope(left: Rope, right: Rope) -> Rope {\n+pub fn append_rope(left: Rope, right: Rope) -> Rope {\n    match (left) {\n      node::Empty => return right,\n      node::Content(left_content) => {\n@@ -154,7 +154,7 @@ fn append_rope(left: Rope, right: Rope) -> Rope {\n  * rope remains balanced. However, this function does not take any further\n  * measure to ensure that the result is balanced.\n  */\n-fn concat(v: ~[Rope]) -> Rope {\n+pub fn concat(v: ~[Rope]) -> Rope {\n     //Copy `v` into a mut vector\n     let mut len = vec::len(v);\n     if len == 0u { return node::Empty; }\n@@ -197,7 +197,7 @@ Section: Keeping ropes healthy\n  * If you perform numerous rope concatenations, it is generally a good idea\n  * to rebalance your rope at some point, before using it for other purposes.\n  */\n-fn bal(rope:Rope) -> Rope {\n+pub fn bal(rope:Rope) -> Rope {\n     match (rope) {\n       node::Empty => return rope,\n       node::Content(x) => match (node::bal(x)) {\n@@ -225,7 +225,7 @@ Section: Transforming ropes\n  * * this function fails if char_offset/char_len do not represent\n  *   valid positions in rope\n  */\n-fn sub_chars(rope: Rope, char_offset: uint, char_len: uint) -> Rope {\n+pub fn sub_chars(rope: Rope, char_offset: uint, char_len: uint) -> Rope {\n     if char_len == 0u { return node::Empty; }\n     match (rope) {\n       node::Empty => fail,\n@@ -250,7 +250,7 @@ fn sub_chars(rope: Rope, char_offset: uint, char_len: uint) -> Rope {\n  * * this function fails if byte_offset/byte_len do not represent\n  *   valid positions in rope\n  */\n-fn sub_bytes(rope: Rope, byte_offset: uint, byte_len: uint) -> Rope {\n+pub fn sub_bytes(rope: Rope, byte_offset: uint, byte_len: uint) -> Rope {\n     if byte_len == 0u { return node::Empty; }\n     match (rope) {\n       node::Empty => fail,\n@@ -276,7 +276,7 @@ Section: Comparing ropes\n  * A negative value if `left < right`, 0 if eq(left, right) or a positive\n  * value if `left > right`\n  */\n-fn cmp(left: Rope, right: Rope) -> int {\n+pub fn cmp(left: Rope, right: Rope) -> int {\n     match ((left, right)) {\n       (node::Empty, node::Empty) => return 0,\n       (node::Empty, _)     => return -1,\n@@ -291,7 +291,7 @@ fn cmp(left: Rope, right: Rope) -> int {\n  * Returns `true` if both ropes have the same content (regardless of\n  * their structure), `false` otherwise\n  */\n-fn eq(left: Rope, right: Rope) -> bool {\n+pub fn eq(left: Rope, right: Rope) -> bool {\n     return cmp(left, right) == 0;\n }\n \n@@ -306,7 +306,7 @@ fn eq(left: Rope, right: Rope) -> bool {\n  * `true` if `left <= right` in lexicographical order (regardless of their\n  * structure), `false` otherwise\n  */\n-fn le(left: Rope, right: Rope) -> bool {\n+pub fn le(left: Rope, right: Rope) -> bool {\n     return cmp(left, right) <= 0;\n }\n \n@@ -321,7 +321,7 @@ fn le(left: Rope, right: Rope) -> bool {\n  * `true` if `left < right` in lexicographical order (regardless of their\n  * structure), `false` otherwise\n  */\n-fn lt(left: Rope, right: Rope) -> bool {\n+pub fn lt(left: Rope, right: Rope) -> bool {\n     return cmp(left, right) < 0;\n }\n \n@@ -336,7 +336,7 @@ fn lt(left: Rope, right: Rope) -> bool {\n  *  `true` if `left >= right` in lexicographical order (regardless of their\n  * structure), `false` otherwise\n  */\n-fn ge(left: Rope, right: Rope) -> bool {\n+pub fn ge(left: Rope, right: Rope) -> bool {\n     return cmp(left, right) >= 0;\n }\n \n@@ -351,7 +351,7 @@ fn ge(left: Rope, right: Rope) -> bool {\n  * `true` if `left > right` in lexicographical order (regardless of their\n  * structure), `false` otherwise\n  */\n-fn gt(left: Rope, right: Rope) -> bool {\n+pub fn gt(left: Rope, right: Rope) -> bool {\n     return cmp(left, right) > 0;\n }\n \n@@ -379,7 +379,7 @@ Section: Iterating\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-fn loop_chars(rope: Rope, it: fn(char) -> bool) -> bool {\n+pub fn loop_chars(rope: Rope, it: fn(char) -> bool) -> bool {\n    match (rope) {\n       node::Empty => return true,\n       node::Content(x) => return node::loop_chars(x, it)\n@@ -393,7 +393,7 @@ fn loop_chars(rope: Rope, it: fn(char) -> bool) -> bool {\n  * * rope - A rope to traverse. It may be empty\n  * * it - A block to execute with each consecutive character of the rope.\n  */\n-fn iter_chars(rope: Rope, it: fn(char)) {\n+pub fn iter_chars(rope: Rope, it: fn(char)) {\n     do loop_chars(rope) |x| {\n         it(x);\n         true\n@@ -422,17 +422,15 @@ fn iter_chars(rope: Rope, it: fn(char)) {\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-fn loop_leaves(rope: Rope, it: fn(node::Leaf) -> bool) -> bool{\n+pub fn loop_leaves(rope: Rope, it: fn(node::Leaf) -> bool) -> bool{\n    match (rope) {\n       node::Empty => return true,\n       node::Content(x) => return node::loop_leaves(x, it)\n    }\n }\n \n-mod iterator {\n-    #[legacy_exports];\n-    mod leaf {\n-        #[legacy_exports];\n+pub mod iterator {\n+    pub mod leaf {\n         fn start(rope: Rope) -> node::leaf_iterator::T {\n             match (rope) {\n               node::Empty      => return node::leaf_iterator::empty(),\n@@ -443,8 +441,7 @@ mod iterator {\n             return node::leaf_iterator::next(it);\n         }\n     }\n-    mod char {\n-        #[legacy_exports];\n+    pub mod char {\n         fn start(rope: Rope) -> node::char_iterator::T {\n             match (rope) {\n               node::Empty      => return node::char_iterator::empty(),\n@@ -472,7 +469,7 @@ mod iterator {\n  *\n  * Constant time.\n  */\n-fn height(rope: Rope) -> uint {\n+pub fn height(rope: Rope) -> uint {\n    match (rope) {\n       node::Empty      => return 0u,\n       node::Content(x) => return node::height(x)\n@@ -488,7 +485,7 @@ fn height(rope: Rope) -> uint {\n  *\n  * Constant time.\n  */\n-pure fn char_len(rope: Rope) -> uint {\n+pub pure fn char_len(rope: Rope) -> uint {\n    match (rope) {\n      node::Empty            => return 0u,\n      node::Content(x)       => return node::char_len(x)\n@@ -502,7 +499,7 @@ pure fn char_len(rope: Rope) -> uint {\n  *\n  * Constant time.\n  */\n-pure fn byte_len(rope: Rope) -> uint {\n+pub pure fn byte_len(rope: Rope) -> uint {\n    match (rope) {\n      node::Empty            => return 0u,\n      node::Content(x)       => return node::byte_len(x)\n@@ -525,7 +522,7 @@ pure fn byte_len(rope: Rope) -> uint {\n  * This function executes in a time proportional to the height of the\n  * rope + the (bounded) length of the largest leaf.\n  */\n-fn char_at(rope: Rope, pos: uint) -> char {\n+pub fn char_at(rope: Rope, pos: uint) -> char {\n    match (rope) {\n       node::Empty => fail,\n       node::Content(x) => return node::char_at(x, pos)\n@@ -537,10 +534,9 @@ fn char_at(rope: Rope, pos: uint) -> char {\n  Section: Implementation\n */\n mod node {\n-    #[legacy_exports];\n \n     /// Implementation of type `rope`\n-    enum Root {\n+    pub enum Root {\n         /// An empty rope\n         Empty,\n         /// A non-empty rope\n@@ -564,7 +560,7 @@ mod node {\n      *     string can be shared between several ropes, e.g. for indexing\n      *     purposes.\n      */\n-    type Leaf = {\n+    pub type Leaf = {\n         byte_offset: uint,\n         byte_len:    uint,\n         char_len:   uint,\n@@ -588,7 +584,7 @@ mod node {\n      *\n      *     Used for rebalancing and to allocate stacks for traversals.\n      */\n-    type Concat = {\n+    pub type Concat = {\n         //FIXME (#2744): Perhaps a `vec` instead of `left`/`right`\n         left:     @Node,\n         right:    @Node,\n@@ -597,7 +593,7 @@ mod node {\n         height:   uint\n     };\n \n-    enum Node {\n+    pub enum Node {\n         /// A leaf consisting in a `str`\n         Leaf(Leaf),\n         /// The concatenation of two ropes\n@@ -609,14 +605,14 @@ mod node {\n      *\n      * This is not a strict value\n      */\n-    const hint_max_leaf_char_len: uint = 256u;\n+    pub const hint_max_leaf_char_len: uint = 256u;\n \n     /**\n      * The maximal height that _should_ be permitted in a tree.\n      *\n      * This is not a strict value\n      */\n-    const hint_max_node_height:   uint = 16u;\n+    pub const hint_max_node_height:   uint = 16u;\n \n     /**\n      * Adopt a string as a node.\n@@ -628,7 +624,7 @@ mod node {\n      * Performance note: The complexity of this function is linear in\n      * the length of `str`.\n      */\n-    fn of_str(str: @~str) -> @Node {\n+    pub fn of_str(str: @~str) -> @Node {\n         return of_substr(str, 0u, str::len(*str));\n     }\n \n@@ -649,7 +645,7 @@ mod node {\n      * Behavior is undefined if `byte_start` or `byte_len` do not represent\n      * valid positions in `str`\n      */\n-    fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @Node {\n+    pub fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @Node {\n         return of_substr_unsafer(str, byte_start, byte_len,\n                               str::count_chars(*str, byte_start, byte_len));\n     }\n@@ -675,8 +671,8 @@ mod node {\n      * * Behavior is undefined if `char_len` does not accurately represent the\n      *   number of chars between byte_start and byte_start+byte_len\n      */\n-    fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n-                          char_len: uint) -> @Node {\n+    pub fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n+                             char_len: uint) -> @Node {\n         assert(byte_start + byte_len <= str::len(*str));\n         let candidate = @Leaf({\n                 byte_offset: byte_start,\n@@ -733,15 +729,15 @@ mod node {\n         }\n     }\n \n-    pure fn byte_len(node: @Node) -> uint {\n+    pub pure fn byte_len(node: @Node) -> uint {\n         //FIXME (#2744): Could we do this without the pattern-matching?\n         match (*node) {\n           Leaf(y)   => return y.byte_len,\n           Concat(ref y) => return y.byte_len\n         }\n     }\n \n-    pure fn char_len(node: @Node) -> uint {\n+    pub pure fn char_len(node: @Node) -> uint {\n         match (*node) {\n           Leaf(y)   => return y.char_len,\n           Concat(ref y) => return y.char_len\n@@ -756,7 +752,7 @@ mod node {\n      * * forest - The forest. This vector is progressively rewritten during\n      *            execution and should be discarded as meaningless afterwards.\n      */\n-    fn tree_from_forest_destructive(forest: &[mut @Node]) -> @Node {\n+    pub fn tree_from_forest_destructive(forest: &[mut @Node]) -> @Node {\n         let mut i;\n         let mut len = vec::len(forest);\n         while len > 1u {\n@@ -800,7 +796,7 @@ mod node {\n         return forest[0];\n     }\n \n-    fn serialize_node(node: @Node) -> ~str unsafe {\n+    pub fn serialize_node(node: @Node) -> ~str unsafe {\n         let mut buf = vec::to_mut(vec::from_elem(byte_len(node), 0u8));\n         let mut offset = 0u;//Current position in the buffer\n         let it = leaf_iterator::start(node);\n@@ -831,7 +827,7 @@ mod node {\n      *\n      * This function executes in linear time.\n      */\n-    fn flatten(node: @Node) -> @Node unsafe {\n+    pub fn flatten(node: @Node) -> @Node unsafe {\n         match (*node) {\n           Leaf(_) => return node,\n           Concat(ref x) => {\n@@ -860,7 +856,7 @@ mod node {\n      * * `option::some(x)` otherwise, in which case `x` has the same contents\n      *    as `node` bot lower height and/or fragmentation.\n      */\n-    fn bal(node: @Node) -> Option<@Node> {\n+    pub fn bal(node: @Node) -> Option<@Node> {\n         if height(node) < hint_max_node_height { return option::None; }\n         //1. Gather all leaves as a forest\n         let mut forest = ~[];\n@@ -896,7 +892,8 @@ mod node {\n      * This function fails if `byte_offset` or `byte_len` do not represent\n      * valid positions in `node`.\n      */\n-    fn sub_bytes(node: @Node, byte_offset: uint, byte_len: uint) -> @Node {\n+    pub fn sub_bytes(node: @Node, byte_offset: uint,\n+                     byte_len: uint) -> @Node {\n         let mut node        = node;\n         let mut byte_offset = byte_offset;\n         loop {\n@@ -957,7 +954,8 @@ mod node {\n      * This function fails if `char_offset` or `char_len` do not represent\n      * valid positions in `node`.\n      */\n-    fn sub_chars(node: @Node, char_offset: uint, char_len: uint) -> @Node {\n+    pub fn sub_chars(node: @Node, char_offset: uint,\n+                     char_len: uint) -> @Node {\n         let mut node        = node;\n         let mut char_offset = char_offset;\n         loop {\n@@ -1002,7 +1000,7 @@ mod node {\n         };\n     }\n \n-    fn concat2(left: @Node, right: @Node) -> @Node {\n+    pub fn concat2(left: @Node, right: @Node) -> @Node {\n         return @Concat({left    : left,\n                      right   : right,\n              char_len: char_len(left) + char_len(right),\n@@ -1011,14 +1009,14 @@ mod node {\n                     })\n     }\n \n-    fn height(node: @Node) -> uint {\n+    pub fn height(node: @Node) -> uint {\n         match (*node) {\n           Leaf(_)   => return 0u,\n           Concat(ref x) => return x.height\n         }\n     }\n \n-    fn cmp(a: @Node, b: @Node) -> int {\n+    pub fn cmp(a: @Node, b: @Node) -> int {\n         let ita = char_iterator::start(a);\n         let itb = char_iterator::start(b);\n         let mut result = 0;\n@@ -1039,7 +1037,7 @@ mod node {\n         return result;\n     }\n \n-    fn loop_chars(node: @Node, it: fn(char) -> bool) -> bool {\n+    pub fn loop_chars(node: @Node, it: fn(char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n             str::all_between(*leaf.content,\n                              leaf.byte_offset,\n@@ -1061,7 +1059,7 @@ mod node {\n      * `true` If execution proceeded correctly, `false` if it was interrupted,\n      * that is if `it` returned `false` at any point.\n      */\n-    fn loop_leaves(node: @Node, it: fn(Leaf) -> bool) -> bool{\n+    pub fn loop_leaves(node: @Node, it: fn(Leaf) -> bool) -> bool{\n         let mut current = node;\n         loop {\n             match (*current) {\n@@ -1092,7 +1090,7 @@ mod node {\n      * proportional to the height of the rope + the (bounded)\n      * length of the largest leaf.\n      */\n-    fn char_at(node: @Node, pos: uint) -> char {\n+    pub fn char_at(node: @Node, pos: uint) -> char {\n         let mut node    = node;\n         let mut pos     = pos;\n         loop {\n@@ -1107,27 +1105,26 @@ mod node {\n         };\n     }\n \n-    mod leaf_iterator {\n-        #[legacy_exports];\n-        type T = {\n+    pub mod leaf_iterator {\n+        pub type T = {\n             stack:            ~[mut @Node],\n             mut stackpos: int\n         };\n \n-        fn empty() -> T {\n+        pub fn empty() -> T {\n             let stack : ~[mut @Node] = ~[mut];\n             return {stack: move stack, mut stackpos: -1}\n         }\n \n-        fn start(node: @Node) -> T {\n+        pub fn start(node: @Node) -> T {\n             let stack = vec::to_mut(vec::from_elem(height(node)+1u, node));\n             return {\n                 stack:         move stack,\n                 mut stackpos:  0\n             }\n         }\n \n-        fn next(it: &T) -> Option<Leaf> {\n+        pub fn next(it: &T) -> Option<Leaf> {\n             if it.stackpos < 0 { return option::None; }\n             loop {\n                 let current = it.stack[it.stackpos];\n@@ -1145,31 +1142,30 @@ mod node {\n         }\n     }\n \n-    mod char_iterator {\n-        #[legacy_exports];\n-        type T = {\n+    pub mod char_iterator {\n+        pub type T = {\n             leaf_iterator: leaf_iterator::T,\n             mut leaf:  Option<Leaf>,\n             mut leaf_byte_pos: uint\n         };\n \n-        fn start(node: @Node) -> T {\n+        pub fn start(node: @Node) -> T {\n             return {\n                 leaf_iterator: leaf_iterator::start(node),\n                 mut leaf:          option::None,\n                 mut leaf_byte_pos: 0u\n             }\n         }\n \n-        fn empty() -> T {\n+        pub fn empty() -> T {\n             return {\n                 leaf_iterator: leaf_iterator::empty(),\n                 mut leaf:  option::None,\n                 mut leaf_byte_pos: 0u\n             }\n         }\n \n-        fn next(it: &T) -> Option<char> {\n+        pub fn next(it: &T) -> Option<char> {\n             loop {\n                 match (get_current_or_next_leaf(it)) {\n                   option::None => return option::None,\n@@ -1184,7 +1180,7 @@ mod node {\n             };\n         }\n \n-        fn get_current_or_next_leaf(it: &T) -> Option<Leaf> {\n+        pub fn get_current_or_next_leaf(it: &T) -> Option<Leaf> {\n             match ((*it).leaf) {\n               option::Some(_) => return (*it).leaf,\n               option::None => {\n@@ -1201,7 +1197,7 @@ mod node {\n             }\n         }\n \n-        fn get_next_char_in_leaf(it: &T) -> Option<char> {\n+        pub fn get_next_char_in_leaf(it: &T) -> Option<char> {\n             match copy (*it).leaf {\n               option::None => return option::None,\n               option::Some(aleaf) => {\n@@ -1224,7 +1220,6 @@ mod node {\n \n #[cfg(test)]\n mod tests {\n-    #[legacy_exports];\n \n     //Utility function, used for sanity check\n     fn rope_to_string(r: Rope) -> ~str {"}, {"sha": "2e7f47e0af0fcd01a43c7a61ec4e7112f0d28136", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8cc61c816a0f08535f6300af4a5eaf30b8094c57/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cc61c816a0f08535f6300af4a5eaf30b8094c57/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=8cc61c816a0f08535f6300af4a5eaf30b8094c57", "patch": "@@ -13,12 +13,12 @@ use map::Map;\n // requires this to be.\n type SmallIntMap_<T: Copy> = {v: DVec<Option<T>>};\n \n-enum SmallIntMap<T:Copy> {\n+pub enum SmallIntMap<T:Copy> {\n     SmallIntMap_(@SmallIntMap_<T>)\n }\n \n /// Create a smallintmap\n-fn mk<T: Copy>() -> SmallIntMap<T> {\n+pub fn mk<T: Copy>() -> SmallIntMap<T> {\n     let v = DVec();\n     return SmallIntMap_(@{v: move v});\n }\n@@ -28,7 +28,7 @@ fn mk<T: Copy>() -> SmallIntMap<T> {\n  * the specified key then the original value is replaced.\n  */\n #[inline(always)]\n-fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, +val: T) {\n+pub fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, +val: T) {\n     //io::println(fmt!(\"%?\", key));\n     self.v.grow_set_elt(key, &None, Some(val));\n }\n@@ -37,7 +37,7 @@ fn insert<T: Copy>(self: SmallIntMap<T>, key: uint, +val: T) {\n  * Get the value for the specified key. If the key does not exist\n  * in the map then returns none\n  */\n-pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n+pub pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n     if key < self.v.len() { return self.v.get_elt(key); }\n     return None::<T>;\n }\n@@ -49,7 +49,7 @@ pure fn find<T: Copy>(self: SmallIntMap<T>, key: uint) -> Option<T> {\n  *\n  * If the key does not exist in the map\n  */\n-pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n+pub pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n     match find(self, key) {\n       None => {\n         error!(\"smallintmap::get(): key not present\");\n@@ -60,7 +60,7 @@ pure fn get<T: Copy>(self: SmallIntMap<T>, key: uint) -> T {\n }\n \n /// Returns true if the map contains a value for the specified key\n-fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n+pub fn contains_key<T: Copy>(self: SmallIntMap<T>, key: uint) -> bool {\n     return !find(self, key).is_none();\n }\n \n@@ -139,6 +139,6 @@ impl<V: Copy> SmallIntMap<V>: ops::Index<uint, V> {\n }\n \n /// Cast the given smallintmap to a map::map\n-fn as_map<V: Copy>(s: SmallIntMap<V>) -> map::Map<uint, V> {\n+pub fn as_map<V: Copy>(s: SmallIntMap<V>) -> map::Map<uint, V> {\n     s as map::Map::<uint, V>\n }"}, {"sha": "a38d9772b5cfcf1646fa4e28442e053d14527f0f", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cc61c816a0f08535f6300af4a5eaf30b8094c57/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/8cc61c816a0f08535f6300af4a5eaf30b8094c57/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=8cc61c816a0f08535f6300af4a5eaf30b8094c57", "patch": "@@ -87,9 +87,7 @@ mod fun_treemap;\n mod list;\n #[legacy_exports]\n mod map;\n-#[legacy_exports]\n mod rope;\n-#[legacy_exports]\n mod smallintmap;\n mod sort;\n mod treemap;"}]}