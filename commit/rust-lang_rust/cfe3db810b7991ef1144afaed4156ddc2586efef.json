{"sha": "cfe3db810b7991ef1144afaed4156ddc2586efef", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmZTNkYjgxMGI3OTkxZWYxMTQ0YWZhZWQ0MTU2ZGRjMjU4NmVmZWY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-13T02:36:58Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-09-15T08:09:00Z"}, "message": "Reduce the amount of complexity in format!\n\nThis renames the syntax-extension file to format from ifmt, and it also reduces\nthe amount of complexity inside by defining all other macros in terms of\nformat_args!", "tree": {"sha": "070edc52983621820a65909f2b091d8bc152f43b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/070edc52983621820a65909f2b091d8bc152f43b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cfe3db810b7991ef1144afaed4156ddc2586efef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cfe3db810b7991ef1144afaed4156ddc2586efef", "html_url": "https://github.com/rust-lang/rust/commit/cfe3db810b7991ef1144afaed4156ddc2586efef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cfe3db810b7991ef1144afaed4156ddc2586efef/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36872e4180331e4a7f00329abe7972488ce216cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/36872e4180331e4a7f00329abe7972488ce216cf", "html_url": "https://github.com/rust-lang/rust/commit/36872e4180331e4a7f00329abe7972488ce216cf"}], "stats": {"total": 199, "additions": 74, "deletions": 125}, "files": [{"sha": "61024ee834b417335899a1af0e0750b47a0acc3f", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=cfe3db810b7991ef1144afaed4156ddc2586efef", "patch": "@@ -452,6 +452,13 @@ pub fn write(output: &mut io::Writer, args: &Arguments) {\n     unsafe { write_unsafe(output, args.fmt, args.args) }\n }\n \n+/// The `writeln` function takes the same arguments as `write`, except that it\n+/// will also write a newline (`\\n`) character at the end of the format string.\n+pub fn writeln(output: &mut io::Writer, args: &Arguments) {\n+    unsafe { write_unsafe(output, args.fmt, args.args) }\n+    output.write(['\\n' as u8]);\n+}\n+\n /// The `write_unsafe` function takes an output stream, a precompiled format\n /// string, and a list of arguments. The arguments will be formatted according\n /// to the specified format string into the output stream provided."}, {"sha": "2bcfafc3bb483ffb62c4501760f020c26d766ff7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=cfe3db810b7991ef1144afaed4156ddc2586efef", "patch": "@@ -155,14 +155,8 @@ pub fn syntax_expander_table() -> SyntaxEnv {\n                             @SE(IdentTT(ext::tt::macro_rules::add_new_extension, None)));\n     syntax_expanders.insert(intern(&\"fmt\"),\n                             builtin_normal_tt_no_ctxt(ext::fmt::expand_syntax_ext));\n-    syntax_expanders.insert(intern(&\"format\"),\n-                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_format));\n-    syntax_expanders.insert(intern(&\"write\"),\n-                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_write));\n-    syntax_expanders.insert(intern(&\"writeln\"),\n-                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_writeln));\n     syntax_expanders.insert(intern(&\"format_args\"),\n-                            builtin_normal_tt_no_ctxt(ext::ifmt::expand_format_args));\n+                            builtin_normal_tt_no_ctxt(ext::format::expand_args));\n     syntax_expanders.insert(\n         intern(&\"auto_encode\"),\n         @SE(ItemDecorator(ext::auto_encode::expand_auto_encode)));"}, {"sha": "e4c69c1973aaadaa0f2a0118263ebd27d280c365", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=cfe3db810b7991ef1144afaed4156ddc2586efef", "patch": "@@ -715,11 +715,11 @@ pub fn std_macros() -> @str {\n             }\n         })\n     )\n-    macro_rules! error( ($($arg:tt)+) => (log!(1u32, $($arg)+)) )\n-    macro_rules! warn ( ($($arg:tt)+) => (log!(2u32, $($arg)+)) )\n-    macro_rules! info ( ($($arg:tt)+) => (log!(3u32, $($arg)+)) )\n-    macro_rules! debug( ($($arg:tt)+) => (\n-        if cfg!(debug) { log!(4u32, $($arg)+) }\n+    macro_rules! error( ($($arg:tt)*) => (log!(1u32, $($arg)*)) )\n+    macro_rules! warn ( ($($arg:tt)*) => (log!(2u32, $($arg)*)) )\n+    macro_rules! info ( ($($arg:tt)*) => (log!(3u32, $($arg)*)) )\n+    macro_rules! debug( ($($arg:tt)*) => (\n+        if cfg!(debug) { log!(4u32, $($arg)*) }\n     ))\n \n     macro_rules! log2(\n@@ -730,11 +730,11 @@ pub fn std_macros() -> @str {\n             }\n         })\n     )\n-    macro_rules! error2( ($($arg:tt)+) => (log2!(1u32, $($arg)+)) )\n-    macro_rules! warn2 ( ($($arg:tt)+) => (log2!(2u32, $($arg)+)) )\n-    macro_rules! info2 ( ($($arg:tt)+) => (log2!(3u32, $($arg)+)) )\n-    macro_rules! debug2( ($($arg:tt)+) => (\n-        if cfg!(debug) { log2!(4u32, $($arg)+) }\n+    macro_rules! error2( ($($arg:tt)*) => (log2!(1u32, $($arg)*)) )\n+    macro_rules! warn2 ( ($($arg:tt)*) => (log2!(2u32, $($arg)*)) )\n+    macro_rules! info2 ( ($($arg:tt)*) => (log2!(3u32, $($arg)*)) )\n+    macro_rules! debug2( ($($arg:tt)*) => (\n+        if cfg!(debug) { log2!(4u32, $($arg)*) }\n     ))\n \n     macro_rules! fail(\n@@ -753,8 +753,8 @@ pub fn std_macros() -> @str {\n         () => (\n             fail!(\\\"explicit failure\\\")\n         );\n-        ($($arg:tt)+) => (\n-            ::std::sys::FailWithCause::fail_with(format!($($arg)+), file!(), line!())\n+        ($($arg:tt)*) => (\n+            ::std::sys::FailWithCause::fail_with(format!($($arg)*), file!(), line!())\n         )\n     )\n \n@@ -958,17 +958,25 @@ pub fn std_macros() -> @str {\n         )\n     )\n \n+    macro_rules! format(($($arg:tt)*) => (\n+        format_args!(::std::fmt::format, $($arg)*)\n+    ))\n+    macro_rules! write(($dst:expr, $($arg:tt)*) => (\n+        format_args!(|args| { ::std::fmt::write($dst, args) }, $($arg)*)\n+    ))\n+    macro_rules! writeln(($dst:expr, $($arg:tt)*) => (\n+        format_args!(|args| { ::std::fmt::writeln($dst, args) }, $($arg)*)\n+    ))\n     // FIXME(#6846) once stdio is redesigned, this shouldn't perform an\n     //              allocation but should rather delegate to an invocation of\n     //              write! instead of format!\n     macro_rules! print (\n-        ($($arg:tt)+) => (::std::io::print(format!($($arg)+)))\n+        ($($arg:tt)*) => (::std::io::print(format!($($arg)*)))\n     )\n-\n     // FIXME(#6846) once stdio is redesigned, this shouldn't perform an\n     //              allocation but should rather delegate to an io::Writer\n     macro_rules! println (\n-        ($($arg:tt)+) => (::std::io::println(format!($($arg)+)))\n+        ($($arg:tt)*) => (::std::io::println(format!($($arg)*)))\n     )\n \n     // NOTE: use this after a snapshot lands to abstract the details"}, {"sha": "9f4e55b1a92cef6258d983a922d1bea669aca24e", "filename": "src/libsyntax/ext/format.rs", "status": "renamed", "additions": 37, "deletions": 99, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=cfe3db810b7991ef1144afaed4156ddc2586efef", "patch": "@@ -54,21 +54,16 @@ impl Context {\n     /// Parses the arguments from the given list of tokens, returning None if\n     /// there's a parse error so we can continue parsing other fmt! expressions.\n     fn parse_args(&mut self, sp: Span,\n-                  leading_expr: bool,\n-                  tts: &[ast::token_tree]) -> (Option<@ast::Expr>,\n-                                               Option<@ast::Expr>) {\n+                  tts: &[ast::token_tree]) -> (@ast::Expr, Option<@ast::Expr>) {\n         let p = rsparse::new_parser_from_tts(self.ecx.parse_sess(),\n                                              self.ecx.cfg(),\n                                              tts.to_owned());\n-        // If we want a leading expression, parse it here\n-        let extra = if leading_expr {\n-            let e = Some(p.parse_expr());\n-            if !p.eat(&token::COMMA) {\n-                self.ecx.span_err(sp, \"expected token: `,`\");\n-                return (e, None);\n-            }\n-            e\n-        } else { None };\n+        // Parse the leading function expression (maybe a block, maybe a path)\n+        let extra = p.parse_expr();\n+        if !p.eat(&token::COMMA) {\n+            self.ecx.span_err(sp, \"expected token: `,`\");\n+            return (extra, None);\n+        }\n \n         if *p.token == token::EOF {\n             self.ecx.span_err(sp, \"requires at least a format string argument\");\n@@ -547,7 +542,7 @@ impl Context {\n \n     /// Actually builds the expression which the ifmt! block will be expanded\n     /// to\n-    fn to_expr(&self, extra: Option<@ast::Expr>, f: Option<&str>) -> @ast::Expr {\n+    fn to_expr(&self, extra: @ast::Expr) -> @ast::Expr {\n         let mut lets = ~[];\n         let mut locals = ~[];\n         let mut names = vec::from_fn(self.name_positions.len(), |_| None);\n@@ -614,68 +609,33 @@ impl Context {\n                                      self.ecx.expr_ident(e.span, lname)));\n         }\n \n+        // Now create the fmt::Arguments struct with all our locals we created.\n         let args = names.move_iter().map(|a| a.unwrap());\n         let mut args = locals.move_iter().chain(args);\n-\n-        let result = match f {\n-            // Invocation of write!()/format!(), call the function and we're\n-            // done.\n-            Some(f) => {\n-                let mut fmt_args = match extra {\n-                    Some(e) => ~[e], None => ~[]\n-                };\n-                fmt_args.push(self.ecx.expr_ident(self.fmtsp, static_name));\n-                fmt_args.push(self.ecx.expr_vec_slice(self.fmtsp,\n-                                                      args.collect()));\n-\n-                let result = self.ecx.expr_call_global(self.fmtsp, ~[\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(f),\n-                    ], fmt_args);\n-\n-                // sprintf is unsafe, but we just went through a lot of work to\n-                // validate that our call is save, so inject the unsafe block\n-                // for the user.\n-                self.ecx.expr_block(ast::Block {\n-                   view_items: ~[],\n-                   stmts: ~[],\n-                   expr: Some(result),\n-                   id: ast::DUMMY_NODE_ID,\n-                   rules: ast::UnsafeBlock(ast::CompilerGenerated),\n-                   span: self.fmtsp,\n-                })\n-            }\n-\n-            // Invocation of format_args!()\n-            None => {\n-                let fmt = self.ecx.expr_ident(self.fmtsp, static_name);\n-                let args = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n-                let result = self.ecx.expr_call_global(self.fmtsp, ~[\n-                        self.ecx.ident_of(\"std\"),\n-                        self.ecx.ident_of(\"fmt\"),\n-                        self.ecx.ident_of(\"Arguments\"),\n-                        self.ecx.ident_of(\"new\"),\n-                    ], ~[fmt, args]);\n-\n-                // We did all the work of making sure that the arguments\n-                // structure is safe, so we can safely have an unsafe block.\n-                let result = self.ecx.expr_block(ast::Block {\n-                   view_items: ~[],\n-                   stmts: ~[],\n-                   expr: Some(result),\n-                   id: ast::DUMMY_NODE_ID,\n-                   rules: ast::UnsafeBlock(ast::CompilerGenerated),\n-                   span: self.fmtsp,\n-                });\n-                let extra = extra.unwrap();\n-                let resname = self.ecx.ident_of(\"__args\");\n-                lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n-                let res = self.ecx.expr_ident(self.fmtsp, resname);\n-                self.ecx.expr_call(extra.span, extra, ~[\n-                        self.ecx.expr_addr_of(extra.span, res)])\n-            }\n-        };\n+        let fmt = self.ecx.expr_ident(self.fmtsp, static_name);\n+        let args = self.ecx.expr_vec_slice(self.fmtsp, args.collect());\n+        let result = self.ecx.expr_call_global(self.fmtsp, ~[\n+                self.ecx.ident_of(\"std\"),\n+                self.ecx.ident_of(\"fmt\"),\n+                self.ecx.ident_of(\"Arguments\"),\n+                self.ecx.ident_of(\"new\"),\n+            ], ~[fmt, args]);\n+\n+        // We did all the work of making sure that the arguments\n+        // structure is safe, so we can safely have an unsafe block.\n+        let result = self.ecx.expr_block(ast::Block {\n+           view_items: ~[],\n+           stmts: ~[],\n+           expr: Some(result),\n+           id: ast::DUMMY_NODE_ID,\n+           rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+           span: self.fmtsp,\n+        });\n+        let resname = self.ecx.ident_of(\"__args\");\n+        lets.push(self.ecx.stmt_let(self.fmtsp, false, resname, result));\n+        let res = self.ecx.expr_ident(self.fmtsp, resname);\n+        let result = self.ecx.expr_call(extra.span, extra, ~[\n+                            self.ecx.expr_addr_of(extra.span, res)]);\n         self.ecx.expr_block(self.ecx.block(self.fmtsp, lets,\n                                            Some(result)))\n     }\n@@ -740,29 +700,8 @@ impl Context {\n     }\n }\n \n-pub fn expand_format(ecx: @ExtCtxt, sp: Span,\n-                     tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, false, false, Some(\"format_unsafe\"))\n-}\n-\n-pub fn expand_write(ecx: @ExtCtxt, sp: Span,\n-                    tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, true, false, Some(\"write_unsafe\"))\n-}\n-\n-pub fn expand_writeln(ecx: @ExtCtxt, sp: Span,\n-                      tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, true, true, Some(\"write_unsafe\"))\n-}\n-\n-pub fn expand_format_args(ecx: @ExtCtxt, sp: Span,\n-                          tts: &[ast::token_tree]) -> base::MacResult {\n-    expand_ifmt(ecx, sp, tts, true, false, None)\n-}\n-\n-fn expand_ifmt(ecx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n-               leading_arg: bool, append_newline: bool,\n-               function: Option<&str>) -> base::MacResult {\n+pub fn expand_args(ecx: @ExtCtxt, sp: Span,\n+                   tts: &[ast::token_tree]) -> base::MacResult {\n     let mut cx = Context {\n         ecx: ecx,\n         args: ~[],\n@@ -776,14 +715,13 @@ fn expand_ifmt(ecx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n         method_statics: ~[],\n         fmtsp: sp,\n     };\n-    let (extra, efmt) = match cx.parse_args(sp, leading_arg, tts) {\n+    let (extra, efmt) = match cx.parse_args(sp, tts) {\n         (extra, Some(e)) => (extra, e),\n         (_, None) => { return MRExpr(ecx.expr_uint(sp, 2)); }\n     };\n     cx.fmtsp = efmt.span;\n     let fmt = expr_to_str(ecx, efmt,\n                           \"format argument must be a string literal.\");\n-    let fmt = if append_newline { fmt + \"\\n\" } else { fmt.to_owned() };\n \n     let mut err = false;\n     do parse::parse_error::cond.trap(|m| {\n@@ -814,5 +752,5 @@ fn expand_ifmt(ecx: @ExtCtxt, sp: Span, tts: &[ast::token_tree],\n         }\n     }\n \n-    MRExpr(cx.to_expr(extra, function))\n+    MRExpr(cx.to_expr(extra))\n }", "previous_filename": "src/libsyntax/ext/ifmt.rs"}, {"sha": "48270702e0dd51230748db4e9b6c13cc2422a4b6", "filename": "src/libsyntax/syntax.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Flibsyntax%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Flibsyntax%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rs?ref=cfe3db810b7991ef1144afaed4156ddc2586efef", "patch": "@@ -72,7 +72,7 @@ pub mod ext {\n \n     pub mod cfg;\n     pub mod fmt;\n-    pub mod ifmt;\n+    pub mod format;\n     pub mod env;\n     pub mod bytes;\n     pub mod concat_idents;"}, {"sha": "35085feaf1505fccc2171e13ff5770d09089164c", "filename": "src/test/compile-fail/ifmt-bad-arg.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfe3db810b7991ef1144afaed4156ddc2586efef/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fifmt-bad-arg.rs?ref=cfe3db810b7991ef1144afaed4156ddc2586efef", "patch": "@@ -11,7 +11,6 @@\n fn main() {\n     // bad arguments to the format! call\n \n-    format!();                //~ ERROR: requires at least a format string\n     format!(\"{}\");            //~ ERROR: invalid reference to argument\n \n     format!(\"{1}\", 1);        //~ ERROR: invalid reference to argument `1`\n@@ -30,8 +29,6 @@ fn main() {\n     format!(\"{foo}\", foo=1, foo=2);    //~ ERROR: duplicate argument\n     format!(\"#\");                      //~ ERROR: `#` reference used\n     format!(\"\", foo=1, 2);             //~ ERROR: positional arguments cannot follow\n-    format!(\"\" 1);                     //~ ERROR: expected token: `,`\n-    format!(\"\", 1 1);                  //~ ERROR: expected token: `,`\n \n     format!(\"{0, select, a{} a{} other{}}\", \"a\");    //~ ERROR: duplicate selector\n     format!(\"{0, plural, =1{} =1{} other{}}\", 1u);   //~ ERROR: duplicate selector\n@@ -74,4 +71,9 @@ fn main() {\n \n     format!(\"foo } bar\"); //~ ERROR: unmatched `}` found\n     format!(\"foo }\"); //~ ERROR: unmatched `}` found\n+\n+    // FIXME(#5794) the spans on these errors are pretty terrible\n+    //format!();\n+    //format!(\"\" 1);\n+    //format!(\"\", 1 1);\n }"}]}