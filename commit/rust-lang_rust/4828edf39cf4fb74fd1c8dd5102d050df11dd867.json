{"sha": "4828edf39cf4fb74fd1c8dd5102d050df11dd867", "node_id": "C_kwDOAAsO6NoAKDQ4MjhlZGYzOWNmNGZiNzRmZDFjOGRkNTEwMmQwNTBkZjExZGQ4Njc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-06T09:57:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-06T09:57:45Z"}, "message": "Auto merge of #2638 - DrMeepster:windows-condvars, r=RalfJung\n\nImplement condvars for Windows\n\nAdds 3 shims for Windows: `SleepConditionVariableSRW`, `WakeConditionVariable`, `WakeAllConditionVariable` to add support for condvars (which fixes #2628).\n\nSalvaged from what was removed from #2231", "tree": {"sha": "59de30975f35f26a6a6856ba5bb52c5af2feaf4c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59de30975f35f26a6a6856ba5bb52c5af2feaf4c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4828edf39cf4fb74fd1c8dd5102d050df11dd867", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4828edf39cf4fb74fd1c8dd5102d050df11dd867", "html_url": "https://github.com/rust-lang/rust/commit/4828edf39cf4fb74fd1c8dd5102d050df11dd867", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4828edf39cf4fb74fd1c8dd5102d050df11dd867/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42e450d6a0b5442085466bd0a93b2a77190ae0ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/42e450d6a0b5442085466bd0a93b2a77190ae0ce", "html_url": "https://github.com/rust-lang/rust/commit/42e450d6a0b5442085466bd0a93b2a77190ae0ce"}, {"sha": "2eb07a05a3fa1e604f4243ddd5659f294d6b69b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9", "html_url": "https://github.com/rust-lang/rust/commit/2eb07a05a3fa1e604f4243ddd5659f294d6b69b9"}], "stats": {"total": 534, "additions": 504, "deletions": 30}, "files": [{"sha": "ba5ae852c5a960663d694ca6eb9ca0020047730c", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=4828edf39cf4fb74fd1c8dd5102d050df11dd867", "patch": "@@ -116,13 +116,25 @@ struct RwLock {\n \n declare_id!(CondvarId);\n \n+#[derive(Debug, Copy, Clone)]\n+pub enum RwLockMode {\n+    Read,\n+    Write,\n+}\n+\n+#[derive(Debug)]\n+pub enum CondvarLock {\n+    Mutex(MutexId),\n+    RwLock { id: RwLockId, mode: RwLockMode },\n+}\n+\n /// A thread waiting on a conditional variable.\n #[derive(Debug)]\n struct CondvarWaiter {\n     /// The thread that is waiting on this variable.\n     thread: ThreadId,\n-    /// The mutex on which the thread is waiting.\n-    mutex: MutexId,\n+    /// The mutex or rwlock on which the thread is waiting.\n+    lock: CondvarLock,\n }\n \n /// The conditional variable state.\n@@ -569,16 +581,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     }\n \n     /// Mark that the thread is waiting on the conditional variable.\n-    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, mutex: MutexId) {\n+    fn condvar_wait(&mut self, id: CondvarId, thread: ThreadId, lock: CondvarLock) {\n         let this = self.eval_context_mut();\n         let waiters = &mut this.machine.threads.sync.condvars[id].waiters;\n         assert!(waiters.iter().all(|waiter| waiter.thread != thread), \"thread is already waiting\");\n-        waiters.push_back(CondvarWaiter { thread, mutex });\n+        waiters.push_back(CondvarWaiter { thread, lock });\n     }\n \n     /// Wake up some thread (if there is any) sleeping on the conditional\n     /// variable.\n-    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, MutexId)> {\n+    fn condvar_signal(&mut self, id: CondvarId) -> Option<(ThreadId, CondvarLock)> {\n         let this = self.eval_context_mut();\n         let current_thread = this.get_active_thread();\n         let condvar = &mut this.machine.threads.sync.condvars[id];\n@@ -592,7 +604,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             if let Some(data_race) = data_race {\n                 data_race.validate_lock_acquire(&condvar.data_race, waiter.thread);\n             }\n-            (waiter.thread, waiter.mutex)\n+            (waiter.thread, waiter.lock)\n         })\n     }\n "}, {"sha": "a7275646847e29ed42c09ceede08e0cea1f6ccb7", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=4828edf39cf4fb74fd1c8dd5102d050df11dd867", "patch": "@@ -3,6 +3,7 @@ use std::time::SystemTime;\n use rustc_hir::LangItem;\n use rustc_middle::ty::{layout::TyAndLayout, query::TyCtxtAt, Ty};\n \n+use crate::concurrency::sync::CondvarLock;\n use crate::concurrency::thread::{MachineCallback, Time};\n use crate::*;\n \n@@ -696,8 +697,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n-        if let Some((thread, mutex)) = this.condvar_signal(id) {\n-            post_cond_signal(this, thread, mutex)?;\n+        if let Some((thread, lock)) = this.condvar_signal(id) {\n+            if let CondvarLock::Mutex(mutex) = lock {\n+                post_cond_signal(this, thread, mutex)?;\n+            } else {\n+                panic!(\"condvar should not have an rwlock on unix\");\n+            }\n         }\n \n         Ok(0)\n@@ -710,8 +715,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n         let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n \n-        while let Some((thread, mutex)) = this.condvar_signal(id) {\n-            post_cond_signal(this, thread, mutex)?;\n+        while let Some((thread, lock)) = this.condvar_signal(id) {\n+            if let CondvarLock::Mutex(mutex) = lock {\n+                post_cond_signal(this, thread, mutex)?;\n+            } else {\n+                panic!(\"condvar should not have an rwlock on unix\");\n+            }\n         }\n \n         Ok(0)\n@@ -729,7 +738,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id);\n+        this.condvar_wait(id, active_thread, CondvarLock::Mutex(mutex_id));\n \n         Ok(0)\n     }\n@@ -768,7 +777,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         };\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n-        this.condvar_wait(id, active_thread, mutex_id);\n+        this.condvar_wait(id, active_thread, CondvarLock::Mutex(mutex_id));\n \n         // We return success for now and override it in the timeout callback.\n         this.write_scalar(Scalar::from_i32(0), dest)?;"}, {"sha": "e16749c986b168cfb6f77a350e69783271126d12", "filename": "src/tools/miri/src/shims/windows/foreign_items.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fforeign_items.rs?ref=4828edf39cf4fb74fd1c8dd5102d050df11dd867", "patch": "@@ -273,6 +273,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 let result = this.InitOnceComplete(ptr, flags, context)?;\n                 this.write_scalar(result, dest)?;\n             }\n+            \"SleepConditionVariableSRW\" => {\n+                let [condvar, lock, timeout, flags] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                let result = this.SleepConditionVariableSRW(condvar, lock, timeout, flags, dest)?;\n+                this.write_scalar(result, dest)?;\n+            }\n+            \"WakeConditionVariable\" => {\n+                let [condvar] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.WakeConditionVariable(condvar)?;\n+            }\n+            \"WakeAllConditionVariable\" => {\n+                let [condvar] =\n+                    this.check_shim(abi, Abi::System { unwind: false }, link_name, args)?;\n+\n+                this.WakeAllConditionVariable(condvar)?;\n+            }\n \n             // Dynamic symbol loading\n             \"GetProcAddress\" => {"}, {"sha": "8f414d98dba5f70a979aa132a0caac8bbdd979c5", "filename": "src/tools/miri/src/shims/windows/sync.rs", "status": "modified", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fwindows%2Fsync.rs?ref=4828edf39cf4fb74fd1c8dd5102d050df11dd867", "patch": "@@ -3,11 +3,45 @@ use std::time::Duration;\n use rustc_target::abi::Size;\n \n use crate::concurrency::init_once::InitOnceStatus;\n+use crate::concurrency::sync::{CondvarLock, RwLockMode};\n use crate::concurrency::thread::MachineCallback;\n use crate::*;\n \n const SRWLOCK_ID_OFFSET: u64 = 0;\n const INIT_ONCE_ID_OFFSET: u64 = 0;\n+const CONDVAR_ID_OFFSET: u64 = 0;\n+\n+impl<'mir, 'tcx> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+trait EvalContextExtPriv<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Try to reacquire the lock associated with the condition variable after we\n+    /// were signaled.\n+    fn reacquire_cond_lock(\n+        &mut self,\n+        thread: ThreadId,\n+        lock: RwLockId,\n+        mode: RwLockMode,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.unblock_thread(thread);\n+\n+        match mode {\n+            RwLockMode::Read =>\n+                if this.rwlock_is_write_locked(lock) {\n+                    this.rwlock_enqueue_and_block_reader(lock, thread);\n+                } else {\n+                    this.rwlock_reader_lock(lock, thread);\n+                },\n+            RwLockMode::Write =>\n+                if this.rwlock_is_locked(lock) {\n+                    this.rwlock_enqueue_and_block_writer(lock, thread);\n+                } else {\n+                    this.rwlock_writer_lock(lock, thread);\n+                },\n+        }\n+\n+        Ok(())\n+    }\n+}\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n #[allow(non_snake_case)]\n@@ -327,4 +361,131 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         Ok(())\n     }\n+\n+    fn SleepConditionVariableSRW(\n+        &mut self,\n+        condvar_op: &OpTy<'tcx, Provenance>,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+        timeout_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n+        let this = self.eval_context_mut();\n+\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+        let lock_id = this.rwlock_get_or_create_id(lock_op, SRWLOCK_ID_OFFSET)?;\n+        let timeout_ms = this.read_scalar(timeout_op)?.to_u32()?;\n+        let flags = this.read_scalar(flags_op)?.to_u32()?;\n+\n+        let timeout_time = if timeout_ms == this.eval_windows(\"c\", \"INFINITE\")?.to_u32()? {\n+            None\n+        } else {\n+            let duration = Duration::from_millis(timeout_ms.into());\n+            Some(this.machine.clock.now().checked_add(duration).unwrap())\n+        };\n+\n+        let shared_mode = 0x1; // CONDITION_VARIABLE_LOCKMODE_SHARED is not in std\n+        let mode = if flags == 0 {\n+            RwLockMode::Write\n+        } else if flags == shared_mode {\n+            RwLockMode::Read\n+        } else {\n+            throw_unsup_format!(\"unsupported `Flags` {flags} in `SleepConditionVariableSRW`\");\n+        };\n+\n+        let active_thread = this.get_active_thread();\n+\n+        let was_locked = match mode {\n+            RwLockMode::Read => this.rwlock_reader_unlock(lock_id, active_thread),\n+            RwLockMode::Write => this.rwlock_writer_unlock(lock_id, active_thread),\n+        };\n+\n+        if !was_locked {\n+            throw_ub_format!(\n+                \"calling SleepConditionVariableSRW with an SRWLock that is not locked by the current thread\"\n+            );\n+        }\n+\n+        this.block_thread(active_thread);\n+        this.condvar_wait(condvar_id, active_thread, CondvarLock::RwLock { id: lock_id, mode });\n+\n+        if let Some(timeout_time) = timeout_time {\n+            struct Callback<'tcx> {\n+                thread: ThreadId,\n+                condvar_id: CondvarId,\n+                lock_id: RwLockId,\n+                mode: RwLockMode,\n+                dest: PlaceTy<'tcx, Provenance>,\n+            }\n+\n+            impl<'tcx> VisitTags for Callback<'tcx> {\n+                fn visit_tags(&self, visit: &mut dyn FnMut(SbTag)) {\n+                    let Callback { thread: _, condvar_id: _, lock_id: _, mode: _, dest } = self;\n+                    dest.visit_tags(visit);\n+                }\n+            }\n+\n+            impl<'mir, 'tcx: 'mir> MachineCallback<'mir, 'tcx> for Callback<'tcx> {\n+                fn call(&self, this: &mut MiriInterpCx<'mir, 'tcx>) -> InterpResult<'tcx> {\n+                    this.reacquire_cond_lock(self.thread, self.lock_id, self.mode)?;\n+\n+                    this.condvar_remove_waiter(self.condvar_id, self.thread);\n+\n+                    let error_timeout = this.eval_windows(\"c\", \"ERROR_TIMEOUT\")?;\n+                    this.set_last_error(error_timeout)?;\n+                    this.write_scalar(this.eval_windows(\"c\", \"FALSE\")?, &self.dest)?;\n+                    Ok(())\n+                }\n+            }\n+\n+            this.register_timeout_callback(\n+                active_thread,\n+                Time::Monotonic(timeout_time),\n+                Box::new(Callback {\n+                    thread: active_thread,\n+                    condvar_id,\n+                    lock_id,\n+                    mode,\n+                    dest: dest.clone(),\n+                }),\n+            );\n+        }\n+\n+        this.eval_windows(\"c\", \"TRUE\")\n+    }\n+\n+    fn WakeConditionVariable(&mut self, condvar_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+\n+        if let Some((thread, lock)) = this.condvar_signal(condvar_id) {\n+            if let CondvarLock::RwLock { id, mode } = lock {\n+                this.reacquire_cond_lock(thread, id, mode)?;\n+                this.unregister_timeout_callback_if_exists(thread);\n+            } else {\n+                panic!(\"mutexes should not exist on windows\");\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn WakeAllConditionVariable(\n+        &mut self,\n+        condvar_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let condvar_id = this.condvar_get_or_create_id(condvar_op, CONDVAR_ID_OFFSET)?;\n+\n+        while let Some((thread, lock)) = this.condvar_signal(condvar_id) {\n+            if let CondvarLock::RwLock { id, mode } = lock {\n+                this.reacquire_cond_lock(thread, id, mode)?;\n+                this.unregister_timeout_callback_if_exists(thread);\n+            } else {\n+                panic!(\"mutexes should not exist on windows\");\n+            }\n+        }\n+\n+        Ok(())\n+    }\n }"}, {"sha": "19ea6c130bdd8ceb980076b42b5d45736a4c4a20", "filename": "src/tools/miri/tests/pass/concurrency/sync.rs", "status": "modified", "additions": 4, "deletions": 16, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs?ref=4828edf39cf4fb74fd1c8dd5102d050df11dd867", "patch": "@@ -230,20 +230,8 @@ fn main() {\n     check_once();\n     park_timeout();\n     park_unpark();\n-\n-    if !cfg!(windows) {\n-        // ignore-target-windows: Condvars on Windows are not supported yet\n-        check_barriers();\n-        check_conditional_variables_notify_one();\n-        check_conditional_variables_timed_wait_timeout();\n-        check_conditional_variables_timed_wait_notimeout();\n-    } else {\n-        // We need to fake the same output...\n-        for _ in 0..10 {\n-            println!(\"before wait\");\n-        }\n-        for _ in 0..10 {\n-            println!(\"after wait\");\n-        }\n-    }\n+    check_barriers();\n+    check_conditional_variables_notify_one();\n+    check_conditional_variables_timed_wait_timeout();\n+    check_conditional_variables_timed_wait_notimeout();\n }"}, {"sha": "c6cff038f81e0eafa5b993d0d0ab84ddc132f9e4", "filename": "src/tools/miri/tests/pass/concurrency/sync_nopreempt.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync_nopreempt.rs?ref=4828edf39cf4fb74fd1c8dd5102d050df11dd867", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-strict-provenance -Zmiri-preemption-rate=0\n "}, {"sha": "d89320bfe59718988be92feab3da341baadea0ca", "filename": "src/tools/miri/tests/pass/concurrency/windows_condvar_shared.rs", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.rs?ref=4828edf39cf4fb74fd1c8dd5102d050df11dd867", "patch": "@@ -0,0 +1,227 @@\n+//@only-target-windows: Uses win32 api functions\n+// We are making scheduler assumptions here.\n+//@compile-flags: -Zmiri-preemption-rate=0\n+\n+use std::ffi::c_void;\n+use std::ptr::null_mut;\n+use std::thread;\n+\n+#[derive(Copy, Clone)]\n+struct SendPtr<T>(*mut T);\n+\n+unsafe impl<T> Send for SendPtr<T> {}\n+\n+extern \"system\" {\n+    fn SleepConditionVariableSRW(\n+        condvar: *mut *mut c_void,\n+        lock: *mut *mut c_void,\n+        timeout: u32,\n+        flags: u32,\n+    ) -> i32;\n+    fn WakeAllConditionVariable(condvar: *mut *mut c_void);\n+\n+    fn AcquireSRWLockExclusive(lock: *mut *mut c_void);\n+    fn AcquireSRWLockShared(lock: *mut *mut c_void);\n+    fn ReleaseSRWLockExclusive(lock: *mut *mut c_void);\n+    fn ReleaseSRWLockShared(lock: *mut *mut c_void);\n+}\n+\n+const CONDITION_VARIABLE_LOCKMODE_SHARED: u32 = 1;\n+const INFINITE: u32 = u32::MAX;\n+\n+/// threads should be able to reacquire the lock while it is locked by multiple other threads in shared mode\n+fn all_shared() {\n+    println!(\"all_shared\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut handles = Vec::with_capacity(10);\n+\n+    // waiters\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"exclusive waiter {i} locked\");\n+\n+            let r = unsafe {\n+                SleepConditionVariableSRW(\n+                    condvar_ptr.0,\n+                    lock_ptr.0,\n+                    INFINITE,\n+                    CONDITION_VARIABLE_LOCKMODE_SHARED,\n+                )\n+            };\n+            assert_ne!(r, 0);\n+\n+            println!(\"exclusive waiter {i} reacquired lock\");\n+\n+            // unlocking is unnecessary because the lock is never used again\n+        }));\n+    }\n+\n+    // ensures each waiter is waiting by this point\n+    thread::yield_now();\n+\n+    // readers\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} locked\");\n+\n+            // switch to next reader or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} unlocked\");\n+        }));\n+    }\n+\n+    // ensures each reader has acquired the lock\n+    thread::yield_now();\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+// reacquiring a lock should wait until the lock is not exclusively locked\n+fn shared_sleep_and_exclusive_lock() {\n+    println!(\"shared_sleep_and_exclusive_lock\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut waiters = Vec::with_capacity(5);\n+    for i in 0..5 {\n+        waiters.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"shared waiter {i} locked\");\n+\n+            let r = unsafe {\n+                SleepConditionVariableSRW(\n+                    condvar_ptr.0,\n+                    lock_ptr.0,\n+                    INFINITE,\n+                    CONDITION_VARIABLE_LOCKMODE_SHARED,\n+                )\n+            };\n+            assert_ne!(r, 0);\n+\n+            println!(\"shared waiter {i} reacquired lock\");\n+\n+            // unlocking is unnecessary because the lock is never used again\n+        }));\n+    }\n+\n+    // ensures each waiter is waiting by this point\n+    thread::yield_now();\n+\n+    unsafe {\n+        AcquireSRWLockExclusive(lock_ptr.0);\n+    }\n+    println!(\"main locked\");\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    // waiters are now waiting for the lock to be unlocked\n+    thread::yield_now();\n+\n+    unsafe {\n+        ReleaseSRWLockExclusive(lock_ptr.0);\n+    }\n+    println!(\"main unlocked\");\n+\n+    for handle in waiters {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+// threads reacquiring locks should wait for all locks to be released first\n+fn exclusive_sleep_and_shared_lock() {\n+    println!(\"exclusive_sleep_and_shared_lock\");\n+\n+    let mut lock = null_mut();\n+    let mut condvar = null_mut();\n+\n+    let lock_ptr = SendPtr(&mut lock);\n+    let condvar_ptr = SendPtr(&mut condvar);\n+\n+    let mut handles = Vec::with_capacity(10);\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockExclusive(lock_ptr.0);\n+            }\n+\n+            println!(\"exclusive waiter {i} locked\");\n+\n+            let r = unsafe { SleepConditionVariableSRW(condvar_ptr.0, lock_ptr.0, INFINITE, 0) };\n+            assert_ne!(r, 0);\n+\n+            println!(\"exclusive waiter {i} reacquired lock\");\n+\n+            // switch to next waiter or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockExclusive(lock_ptr.0);\n+            }\n+            println!(\"exclusive waiter {i} unlocked\");\n+        }));\n+    }\n+\n+    for i in 0..5 {\n+        handles.push(thread::spawn(move || {\n+            unsafe {\n+                AcquireSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} locked\");\n+\n+            // switch to next reader or main thread\n+            thread::yield_now();\n+\n+            unsafe {\n+                ReleaseSRWLockShared(lock_ptr.0);\n+            }\n+            println!(\"reader {i} unlocked\");\n+        }));\n+    }\n+\n+    // ensures each reader has acquired the lock\n+    thread::yield_now();\n+\n+    unsafe {\n+        WakeAllConditionVariable(condvar_ptr.0);\n+    }\n+\n+    for handle in handles {\n+        handle.join().unwrap();\n+    }\n+}\n+\n+fn main() {\n+    all_shared();\n+    shared_sleep_and_exclusive_lock();\n+    exclusive_sleep_and_shared_lock();\n+}"}, {"sha": "918b54668f201cfafb6aab0df18cdb9041b8bf9f", "filename": "src/tools/miri/tests/pass/concurrency/windows_condvar_shared.stdout", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fwindows_condvar_shared.stdout?ref=4828edf39cf4fb74fd1c8dd5102d050df11dd867", "patch": "@@ -0,0 +1,60 @@\n+all_shared\n+exclusive waiter 0 locked\n+exclusive waiter 1 locked\n+exclusive waiter 2 locked\n+exclusive waiter 3 locked\n+exclusive waiter 4 locked\n+reader 0 locked\n+reader 1 locked\n+reader 2 locked\n+reader 3 locked\n+reader 4 locked\n+exclusive waiter 0 reacquired lock\n+exclusive waiter 1 reacquired lock\n+exclusive waiter 2 reacquired lock\n+exclusive waiter 3 reacquired lock\n+exclusive waiter 4 reacquired lock\n+reader 0 unlocked\n+reader 1 unlocked\n+reader 2 unlocked\n+reader 3 unlocked\n+reader 4 unlocked\n+shared_sleep_and_exclusive_lock\n+shared waiter 0 locked\n+shared waiter 1 locked\n+shared waiter 2 locked\n+shared waiter 3 locked\n+shared waiter 4 locked\n+main locked\n+main unlocked\n+shared waiter 0 reacquired lock\n+shared waiter 1 reacquired lock\n+shared waiter 2 reacquired lock\n+shared waiter 3 reacquired lock\n+shared waiter 4 reacquired lock\n+exclusive_sleep_and_shared_lock\n+exclusive waiter 0 locked\n+exclusive waiter 1 locked\n+exclusive waiter 2 locked\n+exclusive waiter 3 locked\n+exclusive waiter 4 locked\n+reader 0 locked\n+reader 1 locked\n+reader 2 locked\n+reader 3 locked\n+reader 4 locked\n+reader 0 unlocked\n+reader 1 unlocked\n+reader 2 unlocked\n+reader 3 unlocked\n+reader 4 unlocked\n+exclusive waiter 0 reacquired lock\n+exclusive waiter 0 unlocked\n+exclusive waiter 1 reacquired lock\n+exclusive waiter 1 unlocked\n+exclusive waiter 2 reacquired lock\n+exclusive waiter 2 unlocked\n+exclusive waiter 3 reacquired lock\n+exclusive waiter 3 unlocked\n+exclusive waiter 4 reacquired lock\n+exclusive waiter 4 unlocked"}, {"sha": "776bc2057f3501fd9d1773b717bce1e426b8407b", "filename": "src/tools/miri/tests/pass/panic/concurrent-panic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4828edf39cf4fb74fd1c8dd5102d050df11dd867/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpanic%2Fconcurrent-panic.rs?ref=4828edf39cf4fb74fd1c8dd5102d050df11dd867", "patch": "@@ -1,4 +1,3 @@\n-//@ignore-target-windows: Condvars on Windows are not supported yet.\n // We are making scheduler assumptions here.\n //@compile-flags: -Zmiri-preemption-rate=0\n "}]}