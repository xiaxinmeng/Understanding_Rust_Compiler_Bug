{"sha": "e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZmI3MDYyYWEyZDcxMTNjNGZmNGNiNDFhMjdiZmI2Mzc0NjVkNTc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-11T05:14:40Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-07-11T07:21:26Z"}, "message": "Work around stage0 to remove '@' requirements from TLS", "tree": {"sha": "815ebf09d654a97620713af95da1aad34f0830a3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/815ebf09d654a97620713af95da1aad34f0830a3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "html_url": "https://github.com/rust-lang/rust/commit/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb5b9a477ccd2d04f549e1107af350749d414bba", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb5b9a477ccd2d04f549e1107af350749d414bba", "html_url": "https://github.com/rust-lang/rust/commit/cb5b9a477ccd2d04f549e1107af350749d414bba"}], "stats": {"total": 409, "additions": 334, "deletions": 75}, "files": [{"sha": "a117d461cfd5eb984bd0994d1f82ef299e2e2e9f", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "patch": "@@ -66,34 +66,74 @@ pub type Key<'self,T> = &'self fn:Copy(v: T);\n  * Remove a task-local data value from the table, returning the\n  * reference that was originally created to insert it.\n  */\n+#[cfg(stage0)]\n+pub unsafe fn pop<T: 'static>(key: Key<@T>) -> Option<@T> {\n+    local_pop(Handle::new(), key)\n+}\n+/**\n+ * Remove a task-local data value from the table, returning the\n+ * reference that was originally created to insert it.\n+ */\n+#[cfg(not(stage0))]\n pub unsafe fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n     local_pop(Handle::new(), key)\n }\n /**\n  * Retrieve a task-local data value. It will also be kept alive in the\n  * table until explicitly removed.\n  */\n+#[cfg(stage0)]\n+pub unsafe fn get<T: 'static>(key: Key<@T>) -> Option<@T> {\n+    local_get(Handle::new(), key, |loc| loc.map(|&x| *x))\n+}\n+/**\n+ * Retrieve a task-local data value. It will also be kept alive in the\n+ * table until explicitly removed.\n+ */\n+#[cfg(not(stage0))]\n pub unsafe fn get<T: 'static>(key: Key<@T>) -> Option<@T> {\n     local_get(Handle::new(), key, |loc| loc.map(|&x| *x))\n }\n /**\n  * Store a value in task-local data. If this key already has a value,\n  * that value is overwritten (and its destructor is run).\n  */\n+#[cfg(stage0)]\n pub unsafe fn set<T: 'static>(key: Key<@T>, data: @T) {\n     local_set(Handle::new(), key, data)\n }\n+/**\n+ * Store a value in task-local data. If this key already has a value,\n+ * that value is overwritten (and its destructor is run).\n+ */\n+#[cfg(not(stage0))]\n+pub unsafe fn set<T: 'static>(key: Key<T>, data: T) {\n+    local_set(Handle::new(), key, data)\n+}\n /**\n  * Modify a task-local data value. If the function returns 'None', the\n  * data is removed (and its reference dropped).\n  */\n+#[cfg(stage0)]\n pub unsafe fn modify<T: 'static>(key: Key<@T>,\n                                  f: &fn(Option<@T>) -> Option<@T>) {\n     match f(pop(key)) {\n         Some(next) => { set(key, next); }\n         None => {}\n     }\n }\n+/**\n+ * Modify a task-local data value. If the function returns 'None', the\n+ * data is removed (and its reference dropped).\n+ */\n+#[cfg(not(stage0))]\n+pub unsafe fn modify<T: 'static>(key: Key<T>,\n+                                 f: &fn(Option<T>) -> Option<T>) {\n+    match f(pop(key)) {\n+        Some(next) => { set(key, next); }\n+        None => {}\n+    }\n+}\n \n #[test]\n fn test_tls_multitask() {"}, {"sha": "55e633e84969e1a4d23c250957c3c05e03038782", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "patch": "@@ -167,15 +167,15 @@ mod test {\n \n     #[test]\n     fn tls() {\n-        use local_data::*;\n+        use local_data;\n         do run_in_newsched_task() {\n             unsafe {\n                 fn key(_x: @~str) { }\n-                local_data_set(key, @~\"data\");\n-                assert!(*local_data_get(key).get() == ~\"data\");\n+                local_data::set(key, @~\"data\");\n+                assert!(*local_data::get(key).get() == ~\"data\");\n                 fn key2(_x: @~str) { }\n-                local_data_set(key2, @~\"data\");\n-                assert!(*local_data_get(key2).get() == ~\"data\");\n+                local_data::set(key2, @~\"data\");\n+                assert!(*local_data::get(key2).get() == ~\"data\");\n             }\n         }\n     }"}, {"sha": "66a459c23e6e03c8cecc5becbf502e3a721834ea", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 56, "deletions": 70, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "patch": "@@ -13,12 +13,10 @@\n use cast;\n use libc;\n use local_data;\n-use managed::raw::BoxRepr;\n use prelude::*;\n use ptr;\n use sys;\n use task::rt;\n-use unstable::intrinsics;\n use util;\n \n use super::rt::rust_task;\n@@ -50,15 +48,15 @@ impl Handle {\n trait LocalData {}\n impl<T: 'static> LocalData for T {}\n \n-// The task-local-map actuall stores all TLS information. Right now it's a list\n+// The task-local-map actually stores all TLS information. Right now it's a list\n // of triples of (key, value, loans). The key is a code pointer (right now at\n // least), the value is a trait so destruction can work, and the loans value\n // is a count of the number of times the value is currently on loan via\n // `local_data_get`.\n //\n // TLS is designed to be able to store owned data, so `local_data_get` must\n // return a borrowed pointer to this data. In order to have a proper lifetime, a\n-// borrowed pointer is insted yielded to a closure specified to the `get`\n+// borrowed pointer is instead yielded to a closure specified to the `get`\n // function. As a result, it would be unsound to perform `local_data_set` on the\n // same key inside of a `local_data_get`, so we ensure at runtime that this does\n // not happen.\n@@ -68,7 +66,7 @@ impl<T: 'static> LocalData for T {}\n // n.b. If TLS is used heavily in future, this could be made more efficient with\n // a proper map.\n type TaskLocalMap = ~[Option<(*libc::c_void, TLSValue, uint)>];\n-type TLSValue = @LocalData;\n+type TLSValue = ~LocalData:;\n \n fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n     unsafe {\n@@ -136,28 +134,8 @@ unsafe fn key_to_key_value<T: 'static>(key: local_data::Key<T>) -> *libc::c_void\n     return pair.code as *libc::c_void;\n }\n \n-unsafe fn transmute_back<'a, T>(data: &'a TLSValue) -> (*BoxRepr, &'a T) {\n-    // Currently, a TLSValue is an '@Trait' instance which means that its actual\n-    // representation is a pair of (vtable, box). Also, because of issue #7673\n-    // the box actually points to another box which has the data. Hence, to get\n-    // a pointer to the actual value that we're interested in, we decode the\n-    // trait pointer and pass through one layer of boxes to get to the actual\n-    // data we're interested in.\n-    //\n-    // The reference count of the containing @Trait box is already taken care of\n-    // because the TLSValue is owned by the containing TLS map which means that\n-    // the reference count is at least one. Extra protections are then added at\n-    // runtime to ensure that once a loan on a value in TLS has been given out,\n-    // the value isn't modified by another user.\n-    let (_vt, box) = *cast::transmute::<&TLSValue, &(uint, *BoxRepr)>(data);\n-\n-    return (box, cast::transmute(&(*box).data));\n-}\n-\n pub unsafe fn local_pop<T: 'static>(handle: Handle,\n                                     key: local_data::Key<T>) -> Option<T> {\n-    // If you've never seen horrendously unsafe code written in rust before,\n-    // just feel free to look a bit farther...\n     let map = get_local_map(handle);\n     let key_value = key_to_key_value(key);\n \n@@ -175,25 +153,23 @@ pub unsafe fn local_pop<T: 'static>(handle: Handle,\n                     None => libc::abort(),\n                 };\n \n-                // First, via some various cheats/hacks, we extract the value\n-                // contained within the TLS box. This leaves a big chunk of\n-                // memory which needs to be deallocated now.\n-                let (chunk, inside) = transmute_back(&data);\n-                let inside = cast::transmute_mut(inside);\n-                let ret = ptr::read_ptr(inside);\n+                // Move `data` into transmute to get out the memory that it\n+                // owns, we must free it manually later.\n+                let (_vtable, box): (uint, ~~T) = cast::transmute(data);\n+\n+                // Read the box's value (using the compiler's built-in\n+                // auto-deref functionality to obtain a pointer to the base)\n+                let ret = ptr::read_ptr(cast::transmute::<&T, *mut T>(*box));\n \n-                // Forget the trait box because we're about to manually\n-                // deallocate the other box. And for my next trick (kids don't\n-                // try this at home), transmute the chunk of @ memory from the\n-                // @-trait box to a pointer to a zero-sized '@' block which will\n-                // then cause it to get properly deallocated, but it won't touch\n-                // any of the uninitialized memory beyond the end.\n-                cast::forget(data);\n-                let chunk: *mut BoxRepr = cast::transmute(chunk);\n-                (*chunk).header.type_desc =\n-                    cast::transmute(intrinsics::get_tydesc::<()>());\n-                let _: @() = cast::transmute(chunk);\n+                // Finally free the allocated memory. we don't want this to\n+                // actually touch the memory inside because it's all duplicated\n+                // now, so the box is transmuted to a 0-sized type. We also use\n+                // a type which references `T` because currently the layout\n+                // could depend on whether T contains managed pointers or not.\n+                let _: ~~[T, ..0] = cast::transmute(box);\n \n+                // Everything is now deallocated, and we own the value that was\n+                // located inside TLS, so we now return it.\n                 return Some(ret);\n             }\n             _ => {}\n@@ -213,9 +189,17 @@ pub unsafe fn local_get<T: 'static, U>(handle: Handle,\n     for map.mut_iter().advance |entry| {\n         match *entry {\n             Some((k, ref data, ref mut loans)) if k == key_value => {\n+                let ret;\n                 *loans = *loans + 1;\n-                let (_, val) = transmute_back(data);\n-                let ret = f(Some(val));\n+                // data was created with `~~T as ~LocalData`, so we extract\n+                // pointer part of the trait, (as ~~T), and then use compiler\n+                // coercions to achieve a '&' pointer\n+                match *cast::transmute::<&TLSValue, &(uint, ~~T)>(data) {\n+                    (_vtable, ref box) => {\n+                        let value: &T = **box;\n+                        ret = f(Some(value));\n+                    }\n+                }\n                 *loans = *loans - 1;\n                 return ret;\n             }\n@@ -225,44 +209,46 @@ pub unsafe fn local_get<T: 'static, U>(handle: Handle,\n     return f(None);\n }\n \n-// FIXME(#7673): This shouldn't require '@', it should use '~'\n pub unsafe fn local_set<T: 'static>(handle: Handle,\n-                                    key: local_data::Key<@T>,\n-                                    data: @T) {\n+                                    key: local_data::Key<T>,\n+                                    data: T) {\n     let map = get_local_map(handle);\n     let keyval = key_to_key_value(key);\n \n     // When the task-local map is destroyed, all the data needs to be cleaned\n-    // up. For this reason we can't do some clever tricks to store '@T' as a\n+    // up. For this reason we can't do some clever tricks to store '~T' as a\n     // '*c_void' or something like that. To solve the problem, we cast\n     // everything to a trait (LocalData) which is then stored inside the map.\n     // Upon destruction of the map, all the objects will be destroyed and the\n     // traits have enough information about them to destroy themselves.\n-    let data = @data as @LocalData;\n-\n-    // First, try to insert it if we already have it.\n-    for map.mut_iter().advance |entry| {\n-        match *entry {\n-            Some((key, ref mut value, loans)) if key == keyval => {\n-                if loans != 0 {\n-                    fail!(\"TLS value has been loaned via get already\");\n+    //\n+    // FIXME(#7673): This should be \"~data as ~LocalData\" (without the colon at\n+    //               the end, and only one sigil)\n+    let data = ~~data as ~LocalData:;\n+\n+    fn insertion_position(map: &mut TaskLocalMap,\n+                          key: *libc::c_void) -> Option<uint> {\n+        // First see if the map contains this key already\n+        let curspot = map.iter().position(|entry| {\n+            match *entry {\n+                Some((ekey, _, loans)) if key == ekey => {\n+                    if loans != 0 {\n+                        fail!(\"TLS value has been loaned via get already\");\n+                    }\n+                    true\n                 }\n-                util::replace(value, data);\n-                return;\n+                _ => false,\n             }\n-            _ => {}\n+        });\n+        // If it doesn't contain the key, just find a slot that's None\n+        match curspot {\n+            Some(i) => Some(i),\n+            None => map.iter().position(|entry| entry.is_none())\n         }\n     }\n-    // Next, search for an open spot\n-    for map.mut_iter().advance |entry| {\n-        match *entry {\n-            Some(*) => {}\n-            None => {\n-                *entry = Some((keyval, data, 0));\n-                return;\n-            }\n-        }\n+\n+    match insertion_position(map, keyval) {\n+        Some(i) => { map[i] = Some((keyval, data, 0)); }\n+        None => { map.push(Some((keyval, data, 0))); }\n     }\n-    // Finally push it on the end of the list\n-    map.push(Some((keyval, data, 0)));\n }"}, {"sha": "fe80ec06c69d01ff997f85a17ecb29907fdd2876", "filename": "src/libstd/task/local_data_priv_stage0.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/src%2Flibstd%2Ftask%2Flocal_data_priv_stage0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/src%2Flibstd%2Ftask%2Flocal_data_priv_stage0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv_stage0.rs?ref=e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "patch": "@@ -0,0 +1,229 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[allow(missing_doc)];\n+\n+use cast;\n+use cmp::Eq;\n+use libc;\n+use local_data;\n+use prelude::*;\n+use sys;\n+use task::rt;\n+\n+use super::rt::rust_task;\n+use rt::task::{Task, LocalStorage};\n+\n+pub enum Handle {\n+    OldHandle(*rust_task),\n+    NewHandle(*mut LocalStorage)\n+}\n+\n+impl Handle {\n+    pub fn new() -> Handle {\n+        use rt::{context, OldTaskContext};\n+        use rt::local::Local;\n+        unsafe {\n+            match context() {\n+                OldTaskContext => {\n+                    OldHandle(rt::rust_get_task())\n+                }\n+                _ => {\n+                    let task = Local::unsafe_borrow::<Task>();\n+                    NewHandle(&mut (*task).storage)\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub trait LocalData { }\n+impl<T: 'static> LocalData for @T { }\n+\n+impl Eq for @LocalData {\n+    fn eq(&self, other: &@LocalData) -> bool {\n+        unsafe {\n+            let ptr_a: &(uint, uint) = cast::transmute(self);\n+            let ptr_b: &(uint, uint) = cast::transmute(other);\n+            return ptr_a == ptr_b;\n+        }\n+    }\n+    fn ne(&self, other: &@LocalData) -> bool { !(*self).eq(other) }\n+}\n+\n+// If TLS is used heavily in future, this could be made more efficient with a\n+// proper map.\n+type TaskLocalElement = (*libc::c_void, *libc::c_void, @LocalData);\n+// Has to be a pointer at outermost layer; the foreign call returns void *.\n+type TaskLocalMap = ~[Option<TaskLocalElement>];\n+\n+fn cleanup_task_local_map(map_ptr: *libc::c_void) {\n+    unsafe {\n+        assert!(!map_ptr.is_null());\n+        // Get and keep the single reference that was created at the\n+        // beginning.\n+        let _map: TaskLocalMap = cast::transmute(map_ptr);\n+        // All local_data will be destroyed along with the map.\n+    }\n+}\n+\n+// Gets the map from the runtime. Lazily initialises if not done so already.\n+unsafe fn get_local_map(handle: Handle) -> &mut TaskLocalMap {\n+    match handle {\n+        OldHandle(task) => get_task_local_map(task),\n+        NewHandle(local_storage) => get_newsched_local_map(local_storage)\n+    }\n+}\n+\n+unsafe fn get_task_local_map(task: *rust_task) -> &mut TaskLocalMap {\n+\n+    extern fn cleanup_task_local_map_extern_cb(map_ptr: *libc::c_void) {\n+        cleanup_task_local_map(map_ptr);\n+    }\n+\n+    // Relies on the runtime initialising the pointer to null.\n+    // Note: the map is an owned pointer and is \"owned\" by TLS. It is moved\n+    // into the tls slot for this task, and then mutable loans are taken from\n+    // this slot to modify the map.\n+    let map_ptr = rt::rust_get_task_local_data(task);\n+    if (*map_ptr).is_null() {\n+        // First time TLS is used, create a new map and set up the necessary\n+        // TLS information for its safe destruction\n+        let map: TaskLocalMap = ~[];\n+        *map_ptr = cast::transmute(map);\n+        rt::rust_task_local_data_atexit(task, cleanup_task_local_map_extern_cb);\n+    }\n+    return cast::transmute(map_ptr);\n+}\n+\n+unsafe fn get_newsched_local_map(local: *mut LocalStorage) -> &mut TaskLocalMap {\n+    // This is based on the same idea as the oldsched code above.\n+    match &mut *local {\n+        // If the at_exit function is already set, then we just need to take a\n+        // loan out on the TLS map stored inside\n+        &LocalStorage(ref mut map_ptr, Some(_)) => {\n+            assert!(map_ptr.is_not_null());\n+            return cast::transmute(map_ptr);\n+        }\n+        // If this is the first time we've accessed TLS, perform similar\n+        // actions to the oldsched way of doing things.\n+        &LocalStorage(ref mut map_ptr, ref mut at_exit) => {\n+            assert!(map_ptr.is_null());\n+            assert!(at_exit.is_none());\n+            let map: TaskLocalMap = ~[];\n+            *map_ptr = cast::transmute(map);\n+            *at_exit = Some(cleanup_task_local_map);\n+            return cast::transmute(map_ptr);\n+        }\n+    }\n+}\n+\n+unsafe fn key_to_key_value<T: 'static>(key: local_data::Key<@T>) -> *libc::c_void {\n+    let pair: sys::Closure = cast::transmute(key);\n+    return pair.code as *libc::c_void;\n+}\n+\n+// If returning Some(..), returns with @T with the map's reference. Careful!\n+unsafe fn local_data_lookup<T: 'static>(\n+    map: &mut TaskLocalMap, key: local_data::Key<@T>)\n+    -> Option<(uint, *libc::c_void)> {\n+\n+    let key_value = key_to_key_value(key);\n+    for map.iter().enumerate().advance |(i, entry)| {\n+        match *entry {\n+            Some((k, data, _)) if k == key_value => { return Some((i, data)); }\n+            _ => {}\n+        }\n+    }\n+    return None;\n+}\n+\n+unsafe fn local_get_helper<T: 'static>(\n+    handle: Handle, key: local_data::Key<@T>,\n+    do_pop: bool) -> Option<@T> {\n+\n+    let map = get_local_map(handle);\n+    // Interpreturn our findings from the map\n+    do local_data_lookup(map, key).map |result| {\n+        // A reference count magically appears on 'data' out of thin air. It\n+        // was referenced in the local_data box, though, not here, so before\n+        // overwriting the local_data_box we need to give an extra reference.\n+        // We must also give an extra reference when not removing.\n+        let (index, data_ptr) = *result;\n+        let data: @T = cast::transmute(data_ptr);\n+        cast::bump_box_refcount(data);\n+        if do_pop {\n+            map[index] = None;\n+        }\n+        data\n+    }\n+}\n+\n+\n+pub unsafe fn local_pop<T: 'static>(\n+    handle: Handle,\n+    key: local_data::Key<@T>) -> Option<@T> {\n+\n+    local_get_helper(handle, key, true)\n+}\n+\n+pub unsafe fn local_get<T: 'static, U>(\n+    handle: Handle,\n+    key: local_data::Key<@T>,\n+    f: &fn(Option<&@T>) -> U) -> U {\n+\n+    match local_get_helper(handle, key, false) {\n+        Some(ref x) => f(Some(x)),\n+        None => f(None)\n+    }\n+}\n+\n+pub unsafe fn local_set<T: 'static>(\n+    handle: Handle, key: local_data::Key<@T>, data: @T) {\n+\n+    let map = get_local_map(handle);\n+    // Store key+data as *voids. Data is invisibly referenced once; key isn't.\n+    let keyval = key_to_key_value(key);\n+    // We keep the data in two forms: one as an unsafe pointer, so we can get\n+    // it back by casting; another in an existential box, so the reference we\n+    // own on it can be dropped when the box is destroyed. The unsafe pointer\n+    // does not have a reference associated with it, so it may become invalid\n+    // when the box is destroyed.\n+    let data_ptr = *cast::transmute::<&@T, &*libc::c_void>(&data);\n+    let data_box = @data as @LocalData;\n+    // Construct new entry to store in the map.\n+    let new_entry = Some((keyval, data_ptr, data_box));\n+    // Find a place to put it.\n+    match local_data_lookup(map, key) {\n+        Some((index, _old_data_ptr)) => {\n+            // Key already had a value set, _old_data_ptr, whose reference\n+            // will get dropped when the local_data box is overwritten.\n+            map[index] = new_entry;\n+        }\n+        None => {\n+            // Find an empty slot. If not, grow the vector.\n+            match map.iter().position(|x| x.is_none()) {\n+                Some(empty_index) => { map[empty_index] = new_entry; }\n+                None => { map.push(new_entry); }\n+            }\n+        }\n+    }\n+}\n+\n+pub unsafe fn local_modify<T: 'static>(\n+    handle: Handle, key: local_data::Key<@T>,\n+    modify_fn: &fn(Option<@T>) -> Option<@T>) {\n+\n+    // Could be more efficient by doing the lookup work, but this is easy.\n+    let newdata = modify_fn(local_pop(handle, key));\n+    if newdata.is_some() {\n+        local_set(handle, key, newdata.unwrap());\n+    }\n+}"}, {"sha": "b012a834ed041f6e8a024b40dcd5e5554b93b15d", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3fb7062aa2d7113c4ff4cb41a27bfb637465d57/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=e3fb7062aa2d7113c4ff4cb41a27bfb637465d57", "patch": "@@ -54,6 +54,10 @@ use util;\n #[cfg(test)] use ptr;\n #[cfg(test)] use task;\n \n+#[cfg(stage0)]\n+#[path=\"local_data_priv_stage0.rs\"]\n+mod local_data_priv;\n+#[cfg(not(stage0))]\n mod local_data_priv;\n pub mod rt;\n pub mod spawn;"}]}