{"sha": "ab2534974caf39e69b401442ff1a9077b94c46c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiMjUzNDk3NGNhZjM5ZTY5YjQwMTQ0MmZmMWE5MDc3Yjk0YzQ2YzE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-09T06:21:45Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-02-13T04:10:50Z"}, "message": "Adjust borrow checker algorithm to address #4856 unsoundness,\nand then adjust code to match. rs=unsound (will review post-landing)", "tree": {"sha": "31c4921f9e3a47dc1e31127d5cc770f199332105", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31c4921f9e3a47dc1e31127d5cc770f199332105"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ab2534974caf39e69b401442ff1a9077b94c46c1", "comment_count": 7, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ab2534974caf39e69b401442ff1a9077b94c46c1", "html_url": "https://github.com/rust-lang/rust/commit/ab2534974caf39e69b401442ff1a9077b94c46c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ab2534974caf39e69b401442ff1a9077b94c46c1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91c59f5c9a6d1fe72a18768b074fcb16542e0ca1", "url": "https://api.github.com/repos/rust-lang/rust/commits/91c59f5c9a6d1fe72a18768b074fcb16542e0ca1", "html_url": "https://github.com/rust-lang/rust/commit/91c59f5c9a6d1fe72a18768b074fcb16542e0ca1"}], "stats": {"total": 1615, "additions": 1043, "deletions": 572}, "files": [{"sha": "f8793f7e2aeae0a2ed1f9e18c41cbab08c60a3c8", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -383,7 +383,9 @@ pub mod linear {\n                 },\n             };\n \n-            self.value_for_bucket(idx)\n+            unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+                ::cast::transmute_region(self.value_for_bucket(idx))\n+            }\n         }\n \n         /// Return the value corresponding to the key in the map, or create,\n@@ -412,7 +414,9 @@ pub mod linear {\n                 },\n             };\n \n-            self.value_for_bucket(idx)\n+            unsafe { // FIXME(#4903)---requires flow-sensitive borrow checker\n+                ::cast::transmute_region(self.value_for_bucket(idx))\n+            }\n         }\n \n         fn consume(&mut self, f: fn(K, V)) {"}, {"sha": "038f61350b2ae60d4f04def911c6a4938b80123d", "filename": "src/libcore/private.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -256,15 +256,15 @@ pub unsafe fn shared_mutable_state<T: Owned>(data: T) ->\n }\n \n #[inline(always)]\n-pub unsafe fn get_shared_mutable_state<T: Owned>(rc: &a/SharedMutableState<T>)\n-        -> &a/mut T {\n+pub unsafe fn get_shared_mutable_state<T: Owned>(\n+    rc: *SharedMutableState<T>) -> *mut T\n+{\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         assert ptr.count > 0;\n-        // Cast us back into the correct region\n-        let r = cast::transmute_region(option::get_ref(&ptr.data));\n+        let r = cast::transmute(option::get_ref(&ptr.data));\n         cast::forget(move ptr);\n-        return cast::transmute_mut(r);\n+        return r;\n     }\n }\n #[inline(always)]\n@@ -376,15 +376,17 @@ impl<T: Owned> Exclusive<T> {\n     // the exclusive. Supporting that is a work in progress.\n     #[inline(always)]\n     unsafe fn with<U>(f: fn(x: &mut T) -> U) -> U {\n-        let rec = unsafe { get_shared_mutable_state(&self.x) };\n-        do rec.lock.lock {\n-            if rec.failed {\n-                die!(~\"Poisoned exclusive - another task failed inside!\");\n+        unsafe {\n+            let rec = get_shared_mutable_state(&self.x);\n+            do (*rec).lock.lock {\n+                if (*rec).failed {\n+                    die!(~\"Poisoned exclusive - another task failed inside!\");\n+                }\n+                (*rec).failed = true;\n+                let result = f(&mut (*rec).data);\n+                (*rec).failed = false;\n+                move result\n             }\n-            rec.failed = true;\n-            let result = f(&mut rec.data);\n-            rec.failed = false;\n-            move result\n         }\n     }\n "}, {"sha": "6665ab6c6f7ed39298885aa0cd37879fdce9776f", "filename": "src/libcore/str.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -2071,17 +2071,19 @@ pub mod raw {\n \n     /// Appends a byte to a string. (Not UTF-8 safe).\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n-        reserve_at_least(&mut *s, s.len() + 1);\n+        let new_len = s.len() + 1;\n+        reserve_at_least(&mut *s, new_len);\n         do as_buf(*s) |buf, len| {\n             let buf: *mut u8 = ::cast::reinterpret_cast(&buf);\n             *ptr::mut_offset(buf, len) = b;\n         }\n-        set_len(&mut *s, s.len() + 1);\n+        set_len(&mut *s, new_len);\n     }\n \n     /// Appends a vector of bytes to a string. (Not UTF-8 safe).\n     unsafe fn push_bytes(s: &mut ~str, bytes: &[u8]) {\n-        reserve_at_least(&mut *s, s.len() + bytes.len());\n+        let new_len = s.len() + bytes.len();\n+        reserve_at_least(&mut *s, new_len);\n         for vec::each(bytes) |byte| { push_byte(&mut *s, *byte); }\n     }\n "}, {"sha": "16cad87c0603ac1af56d78835b2691f69f27dd24", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -623,13 +623,15 @@ unsafe fn push_fast<T>(v: &mut ~[T], initval: T) {\n \n #[inline(never)]\n fn push_slow<T>(v: &mut ~[T], initval: T) {\n-    reserve_at_least(&mut *v, v.len() + 1u);\n+    let new_len = v.len() + 1;\n+    reserve_at_least(&mut *v, new_len);\n     unsafe { push_fast(v, initval) }\n }\n \n #[inline(always)]\n pub fn push_all<T: Copy>(v: &mut ~[T], rhs: &[const T]) {\n-    reserve(&mut *v, v.len() + rhs.len());\n+    let new_len = v.len() + rhs.len();\n+    reserve(&mut *v, new_len);\n \n     for uint::range(0u, rhs.len()) |i| {\n         push(&mut *v, unsafe { raw::get(rhs, i) })\n@@ -638,7 +640,8 @@ pub fn push_all<T: Copy>(v: &mut ~[T], rhs: &[const T]) {\n \n #[inline(always)]\n pub fn push_all_move<T>(v: &mut ~[T], mut rhs: ~[T]) {\n-    reserve(&mut *v, v.len() + rhs.len());\n+    let new_len = v.len() + rhs.len();\n+    reserve(&mut *v, new_len);\n     unsafe {\n         do as_mut_buf(rhs) |p, len| {\n             for uint::range(0, len) |i| {\n@@ -663,9 +666,9 @@ pub fn truncate<T>(v: &mut ~[T], newlen: uint) {\n                 let mut dropped = rusti::init();\n                 dropped <-> *ptr::mut_offset(p, i);\n             }\n-            raw::set_len(&mut *v, newlen);\n         }\n     }\n+    unsafe { raw::set_len(&mut *v, newlen); }\n }\n \n /**\n@@ -740,7 +743,8 @@ pub pure fn append_mut<T: Copy>(lhs: ~[mut T], rhs: &[const T]) -> ~[mut T] {\n  * * initval - The value for the new elements\n  */\n pub fn grow<T: Copy>(v: &mut ~[T], n: uint, initval: &T) {\n-    reserve_at_least(&mut *v, v.len() + n);\n+    let new_len = v.len() + n;\n+    reserve_at_least(&mut *v, new_len);\n     let mut i: uint = 0u;\n \n     while i < n {\n@@ -763,7 +767,8 @@ pub fn grow<T: Copy>(v: &mut ~[T], n: uint, initval: &T) {\n  *             value\n  */\n pub fn grow_fn<T>(v: &mut ~[T], n: uint, op: iter::InitOp<T>) {\n-    reserve_at_least(&mut *v, v.len() + n);\n+    let new_len = v.len() + n;\n+    reserve_at_least(&mut *v, new_len);\n     let mut i: uint = 0u;\n     while i < n {\n         v.push(op(i));"}, {"sha": "b6b94faa3db7e5bf7126058cfc202febe603e57b", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -305,22 +305,31 @@ impl CheckLoanCtxt {\n             return;\n         }\n \n-        match (old_loan.mutbl, new_loan.mutbl) {\n-            (m_const, _) | (_, m_const) | (m_imm, m_imm) => {\n-                /*ok*/\n+        match (old_loan.kind, new_loan.kind) {\n+            (PartialFreeze, PartialTake) | (PartialTake, PartialFreeze) |\n+            (TotalFreeze, PartialFreeze) | (PartialFreeze, TotalFreeze) |\n+            (Immobile, _) | (_, Immobile) |\n+            (PartialFreeze, PartialFreeze) |\n+            (PartialTake, PartialTake) |\n+            (TotalFreeze, TotalFreeze) => {\n+                /* ok */\n             }\n \n-            (m_mutbl, m_mutbl) | (m_mutbl, m_imm) | (m_imm, m_mutbl) => {\n+            (PartialTake, TotalFreeze) | (TotalFreeze, PartialTake) |\n+            (TotalTake, TotalFreeze) | (TotalFreeze, TotalTake) |\n+            (TotalTake, PartialFreeze) | (PartialFreeze, TotalTake) |\n+            (TotalTake, PartialTake) | (PartialTake, TotalTake) |\n+            (TotalTake, TotalTake) => {\n                 self.bccx.span_err(\n                     new_loan.cmt.span,\n                     fmt!(\"loan of %s as %s \\\n                           conflicts with prior loan\",\n                          self.bccx.cmt_to_str(new_loan.cmt),\n-                         self.bccx.mut_to_str(new_loan.mutbl)));\n+                         self.bccx.loan_kind_to_str(new_loan.kind)));\n                 self.bccx.span_note(\n                     old_loan.cmt.span,\n                     fmt!(\"prior loan as %s granted here\",\n-                         self.bccx.mut_to_str(old_loan.mutbl)));\n+                         self.bccx.loan_kind_to_str(old_loan.kind)));\n             }\n         }\n     }\n@@ -348,13 +357,13 @@ impl CheckLoanCtxt {\n             // are only assigned once\n         } else {\n             match cmt.mutbl {\n-              m_mutbl => { /*ok*/ }\n-              m_const | m_imm => {\n-                self.bccx.span_err(\n-                    ex.span,\n-                    at.ing_form(self.bccx.cmt_to_str(cmt)));\n-                return;\n-              }\n+                McDeclared | McInherited => { /*ok*/ }\n+                McReadOnly | McImmutable => {\n+                    self.bccx.span_err(\n+                        ex.span,\n+                        at.ing_form(self.bccx.cmt_to_str(cmt)));\n+                    return;\n+                }\n             }\n         }\n \n@@ -428,19 +437,20 @@ impl CheckLoanCtxt {\n                                                   cmt: cmt,\n                                                   lp: @loan_path) {\n         for self.walk_loans_of(ex.id, lp) |loan| {\n-            match loan.mutbl {\n-              m_const => { /*ok*/ }\n-              m_mutbl | m_imm => {\n-                self.bccx.span_err(\n-                    ex.span,\n-                    fmt!(\"%s prohibited due to outstanding loan\",\n-                         at.ing_form(self.bccx.cmt_to_str(cmt))));\n-                self.bccx.span_note(\n-                    loan.cmt.span,\n-                    fmt!(\"loan of %s granted here\",\n-                         self.bccx.cmt_to_str(loan.cmt)));\n-                return;\n-              }\n+            match loan.kind {\n+                Immobile => { /* ok */ }\n+                TotalFreeze | PartialFreeze |\n+                TotalTake | PartialTake => {\n+                    self.bccx.span_err(\n+                        ex.span,\n+                        fmt!(\"%s prohibited due to outstanding loan\",\n+                             at.ing_form(self.bccx.cmt_to_str(cmt))));\n+                    self.bccx.span_note(\n+                        loan.cmt.span,\n+                        fmt!(\"loan of %s granted here\",\n+                             self.bccx.cmt_to_str(loan.cmt)));\n+                    return;\n+                }\n             }\n         }\n "}, {"sha": "65518398eb75230611395c272df5287af9a73792", "filename": "src/librustc/middle/borrowck/gather_loans.rs", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -20,7 +20,10 @@ use core::prelude::*;\n \n use middle::borrowck::preserve::{PreserveCondition, PcOk, PcIfPure};\n use middle::borrowck::{Loan, bckerr, bckres, BorrowckCtxt, err_mutbl};\n+use middle::borrowck::{LoanKind, TotalFreeze, PartialFreeze,\n+                       TotalTake, PartialTake, Immobile};\n use middle::borrowck::{req_maps};\n+use middle::borrowck::loan;\n use middle::mem_categorization::{cat_binding, cat_discr, cmt, comp_variant};\n use middle::mem_categorization::{mem_categorization_ctxt};\n use middle::mem_categorization::{opt_deref_kind};\n@@ -340,13 +343,22 @@ impl GatherLoanCtxt {\n     fn guarantee_valid(@mut self,\n                        cmt: cmt,\n                        req_mutbl: ast::mutability,\n-                       scope_r: ty::Region) {\n+                       scope_r: ty::Region)\n+    {\n+\n+        let loan_kind = match req_mutbl {\n+            m_mutbl => TotalTake,\n+            m_imm => TotalFreeze,\n+            m_const => Immobile\n+        };\n \n         self.bccx.stats.guaranteed_paths += 1;\n \n-        debug!(\"guarantee_valid(cmt=%s, req_mutbl=%s, scope_r=%s)\",\n+        debug!(\"guarantee_valid(cmt=%s, req_mutbl=%?, \\\n+                loan_kind=%?, scope_r=%s)\",\n                self.bccx.cmt_to_repr(cmt),\n-               self.bccx.mut_to_str(req_mutbl),\n+               req_mutbl,\n+               loan_kind,\n                region_to_str(self.tcx(), scope_r));\n         let _i = indenter();\n \n@@ -362,10 +374,10 @@ impl GatherLoanCtxt {\n           // it within that scope, the loan will be detected and an\n           // error will be reported.\n           Some(_) => {\n-              match self.bccx.loan(cmt, scope_r, req_mutbl) {\n+              match loan::loan(self.bccx, cmt, scope_r, loan_kind) {\n                   Err(ref e) => { self.bccx.report((*e)); }\n                   Ok(move loans) => {\n-                      self.add_loans(cmt, req_mutbl, scope_r, move loans);\n+                      self.add_loans(cmt, loan_kind, scope_r, move loans);\n                   }\n               }\n           }\n@@ -378,7 +390,7 @@ impl GatherLoanCtxt {\n           // pointer is desired, that is ok as long as we are pure)\n           None => {\n             let result: bckres<PreserveCondition> = {\n-                do self.check_mutbl(req_mutbl, cmt).chain |pc1| {\n+                do self.check_mutbl(loan_kind, cmt).chain |pc1| {\n                     do self.bccx.preserve(cmt, scope_r,\n                                           self.item_ub,\n                                           self.root_ub).chain |pc2| {\n@@ -446,37 +458,41 @@ impl GatherLoanCtxt {\n     // reqires an immutable pointer, but `f` lives in (aliased)\n     // mutable memory.\n     fn check_mutbl(@mut self,\n-                   req_mutbl: ast::mutability,\n+                   loan_kind: LoanKind,\n                    cmt: cmt)\n                 -> bckres<PreserveCondition> {\n-        debug!(\"check_mutbl(req_mutbl=%?, cmt.mutbl=%?)\",\n-               req_mutbl, cmt.mutbl);\n+        debug!(\"check_mutbl(loan_kind=%?, cmt.mutbl=%?)\",\n+               loan_kind, cmt.mutbl);\n \n-        if req_mutbl == m_const || req_mutbl == cmt.mutbl {\n-            debug!(\"required is const or they are the same\");\n-            Ok(PcOk)\n-        } else {\n-            let e = bckerr { cmt: cmt, code: err_mutbl(req_mutbl) };\n-            if req_mutbl == m_imm {\n-                // if this is an @mut box, then it's generally OK to borrow as\n-                // &imm; this will result in a write guard\n-                if cmt.cat.is_mutable_box() {\n+        match loan_kind {\n+            Immobile => Ok(PcOk),\n+\n+            TotalTake | PartialTake => {\n+                if cmt.mutbl.is_mutable() {\n                     Ok(PcOk)\n                 } else {\n-                    // you can treat mutable things as imm if you are pure\n-                    debug!(\"imm required, must be pure\");\n+                    Err(bckerr { cmt: cmt, code: err_mutbl(loan_kind) })\n+                }\n+            }\n \n+            TotalFreeze | PartialFreeze => {\n+                if cmt.mutbl.is_immutable() {\n+                    Ok(PcOk)\n+                } else if cmt.cat.is_mutable_box() {\n+                    Ok(PcOk)\n+                } else {\n+                    // Eventually:\n+                    let e = bckerr {cmt: cmt,\n+                                    code: err_mutbl(loan_kind)};\n                     Ok(PcIfPure(e))\n                 }\n-            } else {\n-                Err(e)\n             }\n         }\n     }\n \n     fn add_loans(@mut self,\n                  cmt: cmt,\n-                 req_mutbl: ast::mutability,\n+                 loan_kind: LoanKind,\n                  scope_r: ty::Region,\n                  +loans: ~[Loan]) {\n         if loans.len() == 0 {\n@@ -526,7 +542,7 @@ impl GatherLoanCtxt {\n \n         self.add_loans_to_scope_id(scope_id, move loans);\n \n-        if req_mutbl == m_imm && cmt.mutbl != m_imm {\n+        if loan_kind.is_freeze() && !cmt.mutbl.is_immutable() {\n             self.bccx.stats.loaned_paths_imm += 1;\n \n             if self.tcx().sess.borrowck_note_loan() {\n@@ -542,7 +558,9 @@ impl GatherLoanCtxt {\n     fn add_loans_to_scope_id(@mut self,\n                              scope_id: ast::node_id,\n                              +loans: ~[Loan]) {\n-        debug!(\"adding %u loans to scope_id %?\", loans.len(), scope_id);\n+        debug!(\"adding %u loans to scope_id %?: %s\",\n+               loans.len(), scope_id,\n+               str::connect(loans.map(|l| self.bccx.loan_to_repr(l)), \", \"));\n         match self.req_maps.req_loan_map.find(&scope_id) {\n             Some(req_loans) => {\n                 req_loans.push_all(loans);"}, {"sha": "3b6d735ae781fac22fadc55cd6d86d7a040c91b0", "filename": "src/librustc/middle/borrowck/loan.rs", "status": "modified", "additions": 79, "deletions": 113, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Floan.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -44,6 +44,8 @@ FIXME #4730 --- much more needed, don't have time to write this all up now\n use core::prelude::*;\n \n use middle::borrowck::{Loan, bckerr, bckres, BorrowckCtxt, err_mutbl};\n+use middle::borrowck::{LoanKind, TotalFreeze, PartialFreeze,\n+                       TotalTake, PartialTake, Immobile};\n use middle::borrowck::{err_out_of_scope};\n use middle::mem_categorization::{cat_arg, cat_binding, cat_discr, cat_comp};\n use middle::mem_categorization::{cat_deref, cat_discr, cat_local, cat_self};\n@@ -57,27 +59,26 @@ use core::result::{Err, Ok, Result};\n use syntax::ast::{m_const, m_imm, m_mutbl};\n use syntax::ast;\n \n-impl BorrowckCtxt {\n-    fn loan(&self,\n+pub fn loan(bccx: @BorrowckCtxt,\n             cmt: cmt,\n             scope_region: ty::Region,\n-            mutbl: ast::mutability) -> bckres<~[Loan]> {\n-        let mut lc = LoanContext {\n-            bccx: self,\n-            scope_region: scope_region,\n-            loans: ~[]\n-        };\n-        match lc.loan(cmt, mutbl, true) {\n-            Err(ref e) => return Err((*e)),\n-            Ok(()) => {}\n-        }\n-        // XXX: Workaround for borrow check bug.\n-        Ok(copy lc.loans)\n+            loan_kind: LoanKind) -> bckres<~[Loan]>\n+{\n+    let mut lc = LoanContext {\n+        bccx: bccx,\n+        scope_region: scope_region,\n+        loans: ~[]\n+    };\n+    match lc.loan(cmt, loan_kind, true) {\n+        Err(ref e) => return Err((*e)),\n+        Ok(()) => {}\n     }\n+    // XXX: Workaround for borrow check bug.\n+    Ok(copy lc.loans)\n }\n \n struct LoanContext {\n-    bccx: &BorrowckCtxt,\n+    bccx: @BorrowckCtxt,\n \n     // the region scope for which we must preserve the memory\n     scope_region: ty::Region,\n@@ -87,12 +88,13 @@ struct LoanContext {\n }\n \n impl LoanContext {\n-    fn tcx(&mut self) -> ty::ctxt { self.bccx.tcx }\n+    fn tcx(&self) -> ty::ctxt { self.bccx.tcx }\n \n     fn loan(&mut self,\n             cmt: cmt,\n-            req_mutbl: ast::mutability,\n-            owns_lent_data: bool) -> bckres<()> {\n+            loan_kind: LoanKind,\n+            owns_lent_data: bool) -> bckres<()>\n+    {\n         /*!\n          *\n          * The main routine.\n@@ -107,9 +109,9 @@ impl LoanContext {\n          *                     discussion in `issue_loan()`.\n          */\n \n-        debug!(\"loan(%s, %s)\",\n+        debug!(\"loan(%s, %?)\",\n                self.bccx.cmt_to_repr(cmt),\n-               self.bccx.mut_to_str(req_mutbl));\n+               loan_kind);\n         let _i = indenter();\n \n         // see stable() above; should only be called when `cmt` is lendable\n@@ -127,15 +129,16 @@ impl LoanContext {\n                 ~\"rvalue with a non-none lp\");\n           }\n           cat_local(local_id) | cat_arg(local_id) | cat_self(local_id) => {\n-            let local_scope_id = self.tcx().region_map.get(&local_id);\n-            self.issue_loan(cmt, ty::re_scope(local_scope_id), req_mutbl,\n+              // FIXME(#4903)\n+            let local_scope_id = self.bccx.tcx.region_map.get(&local_id);\n+            self.issue_loan(cmt, ty::re_scope(local_scope_id), loan_kind,\n                             owns_lent_data)\n           }\n           cat_stack_upvar(cmt) => {\n-            self.loan(cmt, req_mutbl, owns_lent_data)\n+            self.loan(cmt, loan_kind, owns_lent_data)\n           }\n           cat_discr(base, _) => {\n-            self.loan(base, req_mutbl, owns_lent_data)\n+            self.loan(base, loan_kind, owns_lent_data)\n           }\n           cat_comp(cmt_base, comp_field(_, m)) |\n           cat_comp(cmt_base, comp_index(_, m)) => {\n@@ -145,41 +148,41 @@ impl LoanContext {\n             // that case, it must also be embedded in an immutable\n             // location, or else the whole structure could be\n             // overwritten and the component along with it.\n-            self.loan_stable_comp(cmt, cmt_base, req_mutbl, m,\n+            self.loan_stable_comp(cmt, cmt_base, loan_kind, m,\n                                   owns_lent_data)\n           }\n           cat_comp(cmt_base, comp_tuple) |\n           cat_comp(cmt_base, comp_anon_field) => {\n             // As above.\n-            self.loan_stable_comp(cmt, cmt_base, req_mutbl, m_imm,\n+            self.loan_stable_comp(cmt, cmt_base, loan_kind, m_imm,\n                                   owns_lent_data)\n           }\n           cat_comp(cmt_base, comp_variant(enum_did)) => {\n             // For enums, the memory is unstable if there are multiple\n             // variants, because if the enum value is overwritten then\n             // the memory changes type.\n             if ty::enum_is_univariant(self.bccx.tcx, enum_did) {\n-                self.loan_stable_comp(cmt, cmt_base, req_mutbl, m_imm,\n+                self.loan_stable_comp(cmt, cmt_base, loan_kind, m_imm,\n                                       owns_lent_data)\n             } else {\n-                self.loan_unstable_deref(cmt, cmt_base, req_mutbl,\n+                self.loan_unstable_deref(cmt, cmt_base, loan_kind,\n                                          owns_lent_data)\n             }\n           }\n           cat_deref(cmt_base, _, uniq_ptr) => {\n             // For unique pointers, the memory being pointed out is\n             // unstable because if the unique pointer is overwritten\n             // then the memory is freed.\n-            self.loan_unstable_deref(cmt, cmt_base, req_mutbl,\n+            self.loan_unstable_deref(cmt, cmt_base, loan_kind,\n                                      owns_lent_data)\n           }\n           cat_deref(cmt_base, _, region_ptr(ast::m_mutbl, region)) => {\n             // Mutable data can be loaned out as immutable or const. We must\n             // loan out the base as well as the main memory. For example,\n             // if someone borrows `*b`, we want to borrow `b` as immutable\n             // as well.\n-            do self.loan(cmt_base, m_imm, false).chain |_| {\n-                self.issue_loan(cmt, region, m_const, owns_lent_data)\n+            do self.loan(cmt_base, TotalFreeze, false).chain |_| {\n+                self.issue_loan(cmt, region, loan_kind, owns_lent_data)\n             }\n           }\n           cat_deref(_, _, unsafe_ptr) |\n@@ -199,66 +202,38 @@ impl LoanContext {\n     fn loan_stable_comp(&mut self,\n                         cmt: cmt,\n                         cmt_base: cmt,\n-                        req_mutbl: ast::mutability,\n+                        loan_kind: LoanKind,\n                         comp_mutbl: ast::mutability,\n-                        owns_lent_data: bool) -> bckres<()> {\n-        // Determine the mutability that the base component must have,\n-        // given the required mutability of the pointer (`req_mutbl`)\n-        // and the declared mutability of the component (`comp_mutbl`).\n-        // This is surprisingly subtle.\n-        //\n-        // Note that the *declared* mutability of the component is not\n-        // necessarily the same as cmt.mutbl, since a component\n-        // declared as immutable but embedded in a mutable context\n-        // becomes mutable.  It's best to think of comp_mutbl as being\n-        // either MUTABLE or DEFAULT, not MUTABLE or IMMUTABLE.  We\n-        // should really patch up the AST to reflect this distinction.\n-        //\n-        // Let's consider the cases below:\n-        //\n-        // 1. mut required, mut declared: In this case, the base\n-        //    component must merely be const.  The reason is that it\n-        //    does not matter if the base component is borrowed as\n-        //    mutable or immutable, as the mutability of the base\n-        //    component is overridden in the field declaration itself\n-        //    (see `compile-fail/borrowck-mut-field-imm-base.rs`)\n-        //\n-        // 2. mut required, imm declared: This would only be legal if\n-        //    the component is embeded in a mutable context.  However,\n-        //    we detect mismatches between the mutability of the value\n-        //    as a whole and the required mutability in `issue_loan()`\n-        //    above.  In any case, presuming that the component IS\n-        //    embedded in a mutable context, both the component and\n-        //    the base must be loaned as MUTABLE.  This is to ensure\n-        //    that there is no loan of the base as IMMUTABLE, which\n-        //    would imply that the component must be IMMUTABLE too\n-        //    (see `compile-fail/borrowck-imm-field-imm-base.rs`).\n-        //\n-        // 3. mut required, const declared: this shouldn't really be\n-        //    possible, since I don't think you can declare a const\n-        //    field, but I guess if we DID permit such a declaration\n-        //    it would be equivalent to the case above?\n-        //\n-        // 4. imm required, * declared: In this case, the base must be\n-        //    immutable.  This is true regardless of what was declared\n-        //    for this subcomponent, this if the base is mutable, the\n-        //    subcomponent must be mutable.\n-        //    (see `compile-fail/borrowck-imm-field-mut-base.rs`).\n-        //\n-        // 5. const required, * declared: In this case, the base need\n-        //    only be const, since we don't ultimately care whether\n-        //    the subcomponent is mutable or not.\n-        let base_mutbl = match (req_mutbl, comp_mutbl) {\n-            (m_mutbl, m_mutbl) => m_const, // (1)\n-            (m_mutbl, _) => m_mutbl,       // (2, 3)\n-            (m_imm, _) => m_imm,           // (4)\n-            (m_const, _) => m_const        // (5)\n+                        owns_lent_data: bool) -> bckres<()>\n+    {\n+        let base_kind = match (comp_mutbl, loan_kind) {\n+            // Declared as \"immutable\" means: inherited mutability and\n+            // hence mutable iff parent is mutable.  So propagate\n+            // mutability on up.\n+            (m_imm, TotalFreeze) | (m_imm, PartialFreeze) => PartialFreeze,\n+            (m_imm, TotalTake) | (m_imm, PartialTake) => PartialTake,\n+\n+            // Declared as \"mutable\" means: always mutable no matter\n+            // what the mutability of the base is.  So that means we\n+            // can weaken the condition on the base to PartialFreeze.\n+            // This implies that the user could freeze the base, but\n+            // that is ok since the even with an &T base, the mut\n+            // field will still be considered mutable.\n+            (_, TotalTake) | (_, PartialTake) |\n+            (_, TotalFreeze) | (_, PartialFreeze) => {\n+                PartialFreeze\n+            }\n+\n+            // If we just need to guarantee the value won't be moved,\n+            // it doesn't matter what mutability the component was\n+            // declared with.\n+            (_, Immobile) => Immobile,\n         };\n \n-        do self.loan(cmt_base, base_mutbl, owns_lent_data).chain |_ok| {\n+        do self.loan(cmt_base, base_kind, owns_lent_data).chain |_ok| {\n             // can use static for the scope because the base\n             // determines the lifetime, ultimately\n-            self.issue_loan(cmt, ty::re_static, req_mutbl,\n+            self.issue_loan(cmt, ty::re_static, loan_kind,\n                             owns_lent_data)\n         }\n     }\n@@ -269,23 +244,23 @@ impl LoanContext {\n     fn loan_unstable_deref(&mut self,\n                            cmt: cmt,\n                            cmt_base: cmt,\n-                           req_mutbl: ast::mutability,\n+                           loan_kind: LoanKind,\n                            owns_lent_data: bool) -> bckres<()> {\n         // Variant components: the base must be immutable, because\n         // if it is overwritten, the types of the embedded data\n         // could change.\n-        do self.loan(cmt_base, m_imm, owns_lent_data).chain |_| {\n+        do self.loan(cmt_base, PartialFreeze, owns_lent_data).chain |_| {\n             // can use static, as in loan_stable_comp()\n-            self.issue_loan(cmt, ty::re_static, req_mutbl,\n+            self.issue_loan(cmt, ty::re_static, loan_kind,\n                             owns_lent_data)\n         }\n     }\n \n     fn issue_loan(&mut self,\n-                  cmt: cmt,\n-                  scope_ub: ty::Region,\n-                  req_mutbl: ast::mutability,\n-                  owns_lent_data: bool) -> bckres<()> {\n+                  +cmt: cmt,\n+                  +scope_ub: ty::Region,\n+                  +loan_kind: LoanKind,\n+                  +owns_lent_data: bool) -> bckres<()> {\n         // Subtle: the `scope_ub` is the maximal lifetime of `cmt`.\n         // Therefore, if `cmt` owns the data being lent, then the\n         // scope of the loan must be less than `scope_ub`, or else the\n@@ -297,34 +272,25 @@ impl LoanContext {\n         // reborrowed.\n \n         if !owns_lent_data ||\n-            self.bccx.is_subregion_of(/*bad*/copy self.scope_region,\n-                                      scope_ub) {\n-            match req_mutbl {\n-                m_mutbl => {\n-                    // We do not allow non-mutable data to be loaned\n-                    // out as mutable under any circumstances.\n-                    if cmt.mutbl != m_mutbl {\n-                        return Err(bckerr {\n-                            cmt:cmt,\n-                            code:err_mutbl(req_mutbl)\n-                        });\n-                    }\n-                }\n-                m_const | m_imm => {\n-                    // However, mutable data can be loaned out as\n-                    // immutable (and any data as const).  The\n-                    // `check_loans` pass will then guarantee that no\n-                    // writes occur for the duration of the loan.\n-                }\n+            self.bccx.is_subregion_of(self.scope_region, scope_ub)\n+        {\n+            if loan_kind.is_take() && !cmt.mutbl.is_mutable() {\n+                // We do not allow non-mutable data to be \"taken\"\n+                // under any circumstances.\n+                return Err(bckerr {\n+                    cmt:cmt,\n+                    code:err_mutbl(loan_kind)\n+                });\n             }\n \n             self.loans.push(Loan {\n                 // Note: cmt.lp must be Some(_) because otherwise this\n                 // loan process does not apply at all.\n                 lp: cmt.lp.get(),\n                 cmt: cmt,\n-                mutbl: req_mutbl\n+                kind: loan_kind\n             });\n+\n             return Ok(());\n         } else {\n             // The loan being requested lives longer than the data"}, {"sha": "dd8f889a057321f0afac56c3d4ed90ad39c9e667", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -368,7 +368,7 @@ pub enum bckerr_code {\n     err_mut_uniq,\n     err_mut_variant,\n     err_root_not_permitted,\n-    err_mutbl(ast::mutability),\n+    err_mutbl(LoanKind),\n     err_out_of_root_scope(ty::Region, ty::Region), // superscope, subscope\n     err_out_of_scope(ty::Region, ty::Region) // superscope, subscope\n }\n@@ -390,8 +390,19 @@ pub enum MoveError {\n // shorthand for something that fails with `bckerr` or succeeds with `T`\n pub type bckres<T> = Result<T, bckerr>;\n \n+#[deriving_eq]\n+pub enum LoanKind {\n+    TotalFreeze,   // Entire path is frozen   (borrowed as &T)\n+    PartialFreeze, // Some subpath is frozen  (borrowed as &T)\n+    TotalTake,     // Entire path is \"taken\"  (borrowed as &mut T)\n+    PartialTake,   // Some subpath is \"taken\" (borrowed as &mut T)\n+    Immobile       // Path cannot be moved    (borrowed as &const T)\n+}\n+\n /// a complete record of a loan that was granted\n-pub struct Loan {lp: @loan_path, cmt: cmt, mutbl: ast::mutability}\n+pub struct Loan {lp: @loan_path,\n+                 cmt: cmt,\n+                 kind: LoanKind}\n \n /// maps computed by `gather_loans` that are then used by `check_loans`\n ///\n@@ -420,6 +431,22 @@ pub fn save_and_restore_managed<T:Copy,U>(save_and_restore_t: @mut T,\n     move u\n }\n \n+impl LoanKind {\n+    fn is_freeze(&self) -> bool {\n+        match *self {\n+            TotalFreeze | PartialFreeze => true,\n+            _ => false\n+        }\n+    }\n+\n+    fn is_take(&self) -> bool {\n+        match *self {\n+            TotalTake | PartialTake => true,\n+            _ => false\n+        }\n+    }\n+}\n+\n /// Creates and returns a new root_map\n \n pub impl root_map_key : to_bytes::IterBytes {\n@@ -520,9 +547,9 @@ pub impl BorrowckCtxt {\n \n     fn bckerr_to_str(&self, err: bckerr) -> ~str {\n         match err.code {\n-            err_mutbl(req) => {\n+            err_mutbl(lk) => {\n                 fmt!(\"creating %s alias to %s\",\n-                     self.mut_to_str(req),\n+                     self.loan_kind_to_str(lk),\n                      self.cmt_to_str(err.cmt))\n             }\n             err_mut_uniq => {\n@@ -599,9 +626,17 @@ pub impl BorrowckCtxt {\n         mc.mut_to_str(mutbl)\n     }\n \n+    fn loan_kind_to_str(&self, lk: LoanKind) -> ~str {\n+        match lk {\n+            TotalFreeze | PartialFreeze => ~\"immutable\",\n+            TotalTake | PartialTake => ~\"mutable\",\n+            Immobile => ~\"read-only\"\n+        }\n+    }\n+\n     fn loan_to_repr(&self, loan: &Loan) -> ~str {\n-        fmt!(\"Loan(lp=%?, cmt=%s, mutbl=%?)\",\n-             loan.lp, self.cmt_to_repr(loan.cmt), loan.mutbl)\n+        fmt!(\"Loan(lp=%?, cmt=%s, kind=%?)\",\n+             loan.lp, self.cmt_to_repr(loan.cmt), loan.kind)\n     }\n }\n "}, {"sha": "a123793e20b29722d36b73973051278d0664d27a", "filename": "src/librustc/middle/borrowck/preserve.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fpreserve.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -190,10 +190,10 @@ impl PreserveCtxt {\n             // otherwise we have no guarantee the pointer will stay\n             // live, so we must root the pointer (i.e., inc the ref\n             // count) for the duration of the loan.\n-            debug!(\"base.mutbl = %?\", self.bccx.mut_to_str(base.mutbl));\n+            debug!(\"base.mutbl = %?\", base.mutbl);\n             if cmt.cat.derefs_through_mutable_box() {\n                 self.attempt_root(cmt, base, derefs)\n-            } else if base.mutbl == m_imm {\n+            } else if base.mutbl.is_immutable() {\n                 let non_rooting_ctxt = PreserveCtxt {\n                     root_managed_data: false,\n                     ..*self\n@@ -293,14 +293,11 @@ impl PreserveCtxt {\n           // the base is preserved, but if we are not mutable then\n           // purity is required\n           Ok(PcOk) => {\n-            match cmt_base.mutbl {\n-              m_mutbl | m_const => {\n-                Ok(PcIfPure(bckerr {cmt:cmt, code:code}))\n+              if !cmt_base.mutbl.is_immutable() {\n+                  Ok(PcIfPure(bckerr {cmt:cmt, code:code}))\n+              } else {\n+                  Ok(PcOk)\n               }\n-              m_imm => {\n-                Ok(PcOk)\n-              }\n-            }\n           }\n \n           // the base requires purity too, that's fine"}, {"sha": "c4612e760241751b464924d042537dc63b672a76", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 136, "deletions": 59, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -108,19 +108,27 @@ pub enum special_kind {\n     sk_heap_upvar\n }\n \n+#[deriving_eq]\n+pub enum MutabilityCategory {\n+    McImmutable, // Immutable.\n+    McReadOnly,  // Read-only (`const`)\n+    McDeclared,  // Directly declared as mutable.\n+    McInherited  // Inherited from the fact that owner is mutable.\n+}\n+\n // a complete categorization of a value indicating where it originated\n // and how it is located, as well as the mutability of the memory in\n // which the value is stored.\n //\n // note: cmt stands for \"categorized mutable type\".\n #[deriving_eq]\n pub struct cmt_ {\n-    id: ast::node_id,        // id of expr/pat producing this value\n-    span: span,              // span of same expr/pat\n-    cat: categorization,     // categorization of expr\n-    lp: Option<@loan_path>,  // loan path for expr, if any\n-    mutbl: ast::mutability,  // mutability of expr as lvalue\n-    ty: ty::t                // type of the expr\n+    id: ast::node_id,          // id of expr/pat producing this value\n+    span: span,                // span of same expr/pat\n+    cat: categorization,       // categorization of expr\n+    lp: Option<@loan_path>,    // loan path for expr, if any\n+    mutbl: MutabilityCategory, // mutability of expr as lvalue\n+    ty: ty::t                  // type of the expr\n }\n \n pub type cmt = @cmt_;\n@@ -298,8 +306,55 @@ pub struct mem_categorization_ctxt {\n     method_map: typeck::method_map,\n }\n \n-pub impl &mem_categorization_ctxt {\n-    fn cat_expr(expr: @ast::expr) -> cmt {\n+impl ToStr for MutabilityCategory {\n+    pure fn to_str(&self) -> ~str {\n+        fmt!(\"%?\", *self)\n+    }\n+}\n+\n+impl MutabilityCategory {\n+    static fn from_mutbl(m: ast::mutability) -> MutabilityCategory {\n+        match m {\n+            m_imm => McImmutable,\n+            m_const => McReadOnly,\n+            m_mutbl => McDeclared\n+        }\n+    }\n+\n+    fn inherit(&self) -> MutabilityCategory {\n+        match *self {\n+            McImmutable => McImmutable,\n+            McReadOnly => McReadOnly,\n+            McDeclared => McInherited,\n+            McInherited => McInherited\n+        }\n+    }\n+\n+    fn is_mutable(&self) -> bool {\n+        match *self {\n+            McImmutable | McReadOnly => false,\n+            McDeclared | McInherited => true\n+        }\n+    }\n+\n+    fn is_immutable(&self) -> bool {\n+        match *self {\n+            McImmutable => true,\n+            McReadOnly | McDeclared | McInherited => false\n+        }\n+    }\n+\n+    fn to_user_str(&self) -> ~str {\n+        match *self {\n+            McDeclared | McInherited => ~\"mutable\",\n+            McImmutable => ~\"immutable\",\n+            McReadOnly => ~\"const\"\n+        }\n+    }\n+}\n+\n+pub impl mem_categorization_ctxt {\n+    fn cat_expr(&self, expr: @ast::expr) -> cmt {\n         match self.tcx.adjustments.find(&expr.id) {\n             None => {\n                 // No adjustments.\n@@ -323,7 +378,8 @@ pub impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_expr_autoderefd(expr: @ast::expr,\n+    fn cat_expr_autoderefd(&self,\n+                           expr: @ast::expr,\n                            adjustment: &ty::AutoAdjustment) -> cmt {\n         let mut cmt = self.cat_expr_unadjusted(expr);\n         for uint::range(1, adjustment.autoderefs+1) |deref| {\n@@ -332,7 +388,7 @@ pub impl &mem_categorization_ctxt {\n         return cmt;\n     }\n \n-    fn cat_expr_unadjusted(expr: @ast::expr) -> cmt {\n+    fn cat_expr_unadjusted(&self, expr: @ast::expr) -> cmt {\n         debug!(\"cat_expr: id=%d expr=%s\",\n                expr.id, pprust::expr_to_str(expr, self.tcx.sess.intr()));\n \n@@ -392,7 +448,8 @@ pub impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_def(id: ast::node_id,\n+    fn cat_def(&self,\n+               id: ast::node_id,\n                span: span,\n                expr_ty: ty::t,\n                def: ast::def) -> cmt {\n@@ -409,7 +466,7 @@ pub impl &mem_categorization_ctxt {\n                 span:span,\n                 cat:cat_special(sk_static_item),\n                 lp:None,\n-                mutbl:m_imm,\n+                mutbl: McImmutable,\n                 ty:expr_ty\n             }\n           }\n@@ -420,7 +477,7 @@ pub impl &mem_categorization_ctxt {\n \n             // m: mutability of the argument\n             // lp: loan path, must be none for aliasable things\n-            let m = if mutbl {m_mutbl} else {m_imm};\n+            let m = if mutbl {McDeclared} else {McImmutable};\n             let lp = match ty::resolved_mode(self.tcx, mode) {\n                 ast::by_copy => Some(@lp_arg(vid)),\n                 ast::by_ref => None,\n@@ -438,7 +495,7 @@ pub impl &mem_categorization_ctxt {\n                 span:span,\n                 cat:cat_arg(vid),\n                 lp:lp,\n-                mutbl:m,\n+                mutbl: m,\n                 ty:expr_ty\n             }\n           }\n@@ -458,7 +515,7 @@ pub impl &mem_categorization_ctxt {\n                 span:span,\n                 cat:cat,\n                 lp:loan_path,\n-                mutbl:m_imm,\n+                mutbl: McImmutable,\n                 ty:expr_ty\n             }\n           }\n@@ -485,15 +542,15 @@ pub impl &mem_categorization_ctxt {\n                         span:span,\n                         cat:cat_special(sk_heap_upvar),\n                         lp:None,\n-                        mutbl:m_imm,\n+                        mutbl:McImmutable,\n                         ty:expr_ty\n                     }\n                 }\n             }\n           }\n \n           ast::def_local(vid, mutbl) => {\n-            let m = if mutbl {m_mutbl} else {m_imm};\n+            let m = if mutbl {McDeclared} else {McImmutable};\n             @cmt_ {\n                 id:id,\n                 span:span,\n@@ -511,33 +568,34 @@ pub impl &mem_categorization_ctxt {\n                 span:span,\n                 cat:cat_local(vid),\n                 lp:Some(@lp_local(vid)),\n-                mutbl:m_imm,\n+                mutbl:McImmutable,\n                 ty:expr_ty\n             }\n           }\n         }\n     }\n \n-    fn cat_variant<N: ast_node>(arg: N,\n+    fn cat_variant<N: ast_node>(&self,\n+                                arg: N,\n                                 enum_did: ast::def_id,\n                                 cmt: cmt) -> cmt {\n         @cmt_ {\n             id: arg.id(),\n             span: arg.span(),\n             cat: cat_comp(cmt, comp_variant(enum_did)),\n             lp: cmt.lp.map(|l| @lp_comp(*l, comp_variant(enum_did)) ),\n-            mutbl: cmt.mutbl, // imm iff in an immutable context\n+            mutbl: cmt.mutbl.inherit(),\n             ty: self.tcx.ty(arg)\n         }\n     }\n \n-    fn cat_rvalue<N: ast_node>(elt: N, expr_ty: ty::t) -> cmt {\n+    fn cat_rvalue<N: ast_node>(&self, elt: N, expr_ty: ty::t) -> cmt {\n         @cmt_ {\n             id:elt.id(),\n             span:elt.span(),\n             cat:cat_rvalue,\n             lp:None,\n-            mutbl:m_imm,\n+            mutbl:McImmutable,\n             ty:expr_ty\n         }\n     }\n@@ -546,17 +604,21 @@ pub impl &mem_categorization_ctxt {\n     /// component is inherited from the base it is a part of. For\n     /// example, a record field is mutable if it is declared mutable\n     /// or if the container is mutable.\n-    fn inherited_mutability(base_m: ast::mutability,\n-                          comp_m: ast::mutability) -> ast::mutability {\n+    fn inherited_mutability(&self,\n+                            base_m: MutabilityCategory,\n+                            comp_m: ast::mutability) -> MutabilityCategory\n+    {\n         match comp_m {\n-          m_imm => {base_m}  // imm: as mutable as the container\n-          m_mutbl | m_const => {comp_m}\n+            m_imm => base_m.inherit(),\n+            m_const => McReadOnly,\n+            m_mutbl => McDeclared\n         }\n     }\n \n     /// The `field_id` parameter is the ID of the enclosing expression or\n     /// pattern. It is used to determine which variant of an enum is in use.\n-    fn cat_field<N:ast_node>(node: N,\n+    fn cat_field<N:ast_node>(&self,\n+                             node: N,\n                              base_cmt: cmt,\n                              f_name: ast::ident,\n                              field_id: ast::node_id) -> cmt {\n@@ -584,7 +646,8 @@ pub impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_deref_fn<N:ast_node>(node: N,\n+    fn cat_deref_fn<N:ast_node>(&self,\n+                                node: N,\n                                 base_cmt: cmt,\n                                 deref_cnt: uint) -> cmt\n     {\n@@ -594,11 +657,13 @@ pub impl &mem_categorization_ctxt {\n         // know what type lies at the other end, so we just call it\n         // `()` (the empty tuple).\n \n-        let mt = ty::mt {ty: ty::mk_tup(self.tcx, ~[]), mutbl: m_imm};\n+        let mt = ty::mt {ty: ty::mk_tup(self.tcx, ~[]),\n+                         mutbl: m_imm};\n         return self.cat_deref_common(node, base_cmt, deref_cnt, mt);\n     }\n \n-    fn cat_deref<N:ast_node>(node: N,\n+    fn cat_deref<N:ast_node>(&self,\n+                             node: N,\n                              base_cmt: cmt,\n                              deref_cnt: uint) -> cmt\n     {\n@@ -615,7 +680,8 @@ pub impl &mem_categorization_ctxt {\n         return self.cat_deref_common(node, base_cmt, deref_cnt, mt);\n     }\n \n-    fn cat_deref_common<N:ast_node>(node: N,\n+    fn cat_deref_common<N:ast_node>(&self,\n+                                    node: N,\n                                     base_cmt: cmt,\n                                     deref_cnt: uint,\n                                     mt: ty::mt) -> cmt\n@@ -644,7 +710,7 @@ pub impl &mem_categorization_ctxt {\n                         self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n                     }\n                     gc_ptr(*) | region_ptr(_, _) | unsafe_ptr => {\n-                        mt.mutbl\n+                        MutabilityCategory::from_mutbl(mt.mutbl)\n                     }\n                 };\n \n@@ -673,7 +739,9 @@ pub impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_index<N: ast_node>(elt: N, base_cmt: cmt) -> cmt {\n+    fn cat_index<N: ast_node>(&self,\n+                              elt: N,\n+                              base_cmt: cmt) -> cmt {\n         let mt = match ty::index(self.tcx, base_cmt.ty) {\n           Some(mt) => mt,\n           None => {\n@@ -700,7 +768,7 @@ pub impl &mem_categorization_ctxt {\n                 self.inherited_mutability(base_cmt.mutbl, mt.mutbl)\n               }\n               gc_ptr(_) | region_ptr(_, _) | unsafe_ptr => {\n-                mt.mutbl\n+                MutabilityCategory::from_mutbl(mt.mutbl)\n               }\n             };\n \n@@ -714,68 +782,77 @@ pub impl &mem_categorization_ctxt {\n                 ty:mt.ty\n             };\n \n-            comp(elt, deref_cmt, base_cmt.ty, m, mt.ty)\n+            comp(elt, deref_cmt, base_cmt.ty, m, mt)\n           }\n \n           deref_comp(_) => {\n             // fixed-length vectors have no deref\n             let m = self.inherited_mutability(base_cmt.mutbl, mt.mutbl);\n-            comp(elt, base_cmt, base_cmt.ty, m, mt.ty)\n+            comp(elt, base_cmt, base_cmt.ty, m, mt)\n           }\n         };\n \n         fn comp<N: ast_node>(elt: N, of_cmt: cmt,\n-                             vect: ty::t, mutbl: ast::mutability,\n-                             ty: ty::t) -> cmt\n+                             vect: ty::t, mutbl: MutabilityCategory,\n+                             mt: ty::mt) -> cmt\n         {\n-            let comp = comp_index(vect, mutbl);\n+            let comp = comp_index(vect, mt.mutbl);\n             let index_lp = of_cmt.lp.map(|lp| @lp_comp(*lp, comp) );\n             @cmt_ {\n                 id:elt.id(),\n                 span:elt.span(),\n                 cat:cat_comp(of_cmt, comp),\n                 lp:index_lp,\n                 mutbl:mutbl,\n-                ty:ty\n+                ty:mt.ty\n             }\n         }\n     }\n \n-    fn cat_tuple_elt<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n+    fn cat_tuple_elt<N: ast_node>(&self,\n+                                  elt: N,\n+                                  cmt: cmt) -> cmt {\n         @cmt_ {\n             id: elt.id(),\n             span: elt.span(),\n             cat: cat_comp(cmt, comp_tuple),\n             lp: cmt.lp.map(|l| @lp_comp(*l, comp_tuple) ),\n-            mutbl: cmt.mutbl, // imm iff in an immutable context\n+            mutbl: cmt.mutbl.inherit(),\n             ty: self.tcx.ty(elt)\n         }\n     }\n \n-    fn cat_anon_struct_field<N: ast_node>(elt: N, cmt: cmt) -> cmt {\n+    fn cat_anon_struct_field<N: ast_node>(&self,\n+                                          elt: N,\n+                                          cmt: cmt) -> cmt {\n         @cmt_ {\n             id: elt.id(),\n             span: elt.span(),\n             cat: cat_comp(cmt, comp_anon_field),\n             lp: cmt.lp.map(|l| @lp_comp(*l, comp_anon_field)),\n-            mutbl: cmt.mutbl, // imm iff in an immutable context\n+            mutbl: cmt.mutbl.inherit(),\n             ty: self.tcx.ty(elt)\n         }\n     }\n \n-    fn cat_method_ref(expr: @ast::expr, expr_ty: ty::t) -> cmt {\n+    fn cat_method_ref(&self,\n+                      expr: @ast::expr,\n+                      expr_ty: ty::t) -> cmt {\n         @cmt_ {\n             id:expr.id,\n             span:expr.span,\n             cat:cat_special(sk_method),\n             lp:None,\n-            mutbl:m_imm,\n+            mutbl:McImmutable,\n             ty:expr_ty\n         }\n     }\n \n-    fn cat_pattern(cmt: cmt, pat: @ast::pat, op: fn(cmt, @ast::pat)) {\n-\n+    fn cat_pattern(&self,\n+                   cmt: cmt,\n+                   pat: @ast::pat,\n+                   op: fn(cmt, @ast::pat))\n+    {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n         //\n@@ -901,7 +978,7 @@ pub impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn cat_to_repr(cat: categorization) -> ~str {\n+    fn cat_to_repr(&self, cat: categorization) -> ~str {\n         match cat {\n           cat_special(sk_method) => ~\"method\",\n           cat_special(sk_static_item) => ~\"static_item\",\n@@ -924,15 +1001,15 @@ pub impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn mut_to_str(mutbl: ast::mutability) -> ~str {\n+    fn mut_to_str(&self, mutbl: ast::mutability) -> ~str {\n         match mutbl {\n           m_mutbl => ~\"mutable\",\n           m_const => ~\"const\",\n           m_imm => ~\"immutable\"\n         }\n     }\n \n-    fn ptr_sigil(ptr: ptr_kind) -> ~str {\n+    fn ptr_sigil(&self, ptr: ptr_kind) -> ~str {\n         match ptr {\n           uniq_ptr => ~\"~\",\n           gc_ptr(_) => ~\"@\",\n@@ -941,7 +1018,7 @@ pub impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn comp_to_repr(comp: comp_kind) -> ~str {\n+    fn comp_to_repr(&self, comp: comp_kind) -> ~str {\n         match comp {\n           comp_field(fld, _) => self.tcx.sess.str_of(fld),\n           comp_index(*) => ~\"[]\",\n@@ -951,7 +1028,7 @@ pub impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn lp_to_str(lp: @loan_path) -> ~str {\n+    fn lp_to_str(&self, lp: @loan_path) -> ~str {\n         match *lp {\n           lp_local(node_id) => {\n             fmt!(\"local(%d)\", node_id)\n@@ -971,17 +1048,17 @@ pub impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn cmt_to_repr(cmt: cmt) -> ~str {\n-        fmt!(\"{%s id:%d m:%s lp:%s ty:%s}\",\n+    fn cmt_to_repr(&self, cmt: cmt) -> ~str {\n+        fmt!(\"{%s id:%d m:%? lp:%s ty:%s}\",\n              self.cat_to_repr(cmt.cat),\n              cmt.id,\n-             self.mut_to_str(cmt.mutbl),\n+             cmt.mutbl,\n              cmt.lp.map_default(~\"none\", |p| self.lp_to_str(*p) ),\n              ty_to_str(self.tcx, cmt.ty))\n     }\n \n-    fn cmt_to_str(cmt: cmt) -> ~str {\n-        let mut_str = self.mut_to_str(cmt.mutbl);\n+    fn cmt_to_str(&self, cmt: cmt) -> ~str {\n+        let mut_str = cmt.mutbl.to_user_str();\n         match cmt.cat {\n           cat_special(sk_method) => ~\"method\",\n           cat_special(sk_static_item) => ~\"static item\",\n@@ -1016,7 +1093,7 @@ pub impl &mem_categorization_ctxt {\n         }\n     }\n \n-    fn region_to_str(r: ty::Region) -> ~str {\n+    fn region_to_str(&self, r: ty::Region) -> ~str {\n         region_to_str(self.tcx, r)\n     }\n }"}, {"sha": "83fcc17583703f877b996b0ba5b88d773061449e", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 93, "deletions": 75, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -116,26 +116,26 @@ pub impl Reflector {\n     fn bracketed(&mut self,\n                  bracket_name: ~str,\n                  +extra: ~[ValueRef],\n-                 inner: &fn()) {\n+                 inner: &fn(&mut Reflector)) {\n         // XXX: Bad copy.\n         self.visit(~\"enter_\" + bracket_name, copy extra);\n-        inner();\n+        inner(self);\n         self.visit(~\"leave_\" + bracket_name, extra);\n     }\n \n     fn vstore_name_and_extra(&mut self,\n                              t: ty::t,\n-                             vstore: ty::vstore,\n-                             f: fn(+s: ~str,+v: ~[ValueRef])) {\n+                             vstore: ty::vstore) -> (~str, ~[ValueRef])\n+    {\n         match vstore {\n-          ty::vstore_fixed(n) => {\n-            let extra = vec::append(~[self.c_uint(n)],\n-                                    self.c_size_and_align(t));\n-            f(~\"fixed\", extra)\n-          }\n-          ty::vstore_slice(_) => f(~\"slice\", ~[]),\n-          ty::vstore_uniq => f(~\"uniq\", ~[]),\n-          ty::vstore_box => f(~\"box\", ~[])\n+            ty::vstore_fixed(n) => {\n+                let extra = vec::append(~[self.c_uint(n)],\n+                                        self.c_size_and_align(t));\n+                (~\"fixed\", extra)\n+            }\n+            ty::vstore_slice(_) => (~\"slice\", ~[]),\n+            ty::vstore_uniq => (~\"uniq\", ~[]),\n+            ty::vstore_box => (~\"box\", ~[])\n         }\n     }\n \n@@ -168,47 +168,60 @@ pub impl Reflector {\n           ty::ty_float(ast::ty_f32) => self.leaf(~\"f32\"),\n           ty::ty_float(ast::ty_f64) => self.leaf(~\"f64\"),\n \n-          ty::ty_unboxed_vec(mt) => self.visit(~\"vec\", self.c_mt(mt)),\n+          ty::ty_unboxed_vec(mt) => {\n+              let values = self.c_mt(mt);\n+              self.visit(~\"vec\", values)\n+          }\n+\n           ty::ty_estr(vst) => {\n-            do self.vstore_name_and_extra(t, vst) |name, extra| {\n-                self.visit(~\"estr_\" + name, extra)\n-            }\n+              let (name, extra) = self.vstore_name_and_extra(t, vst);\n+              self.visit(~\"estr_\" + name, extra)\n           }\n           ty::ty_evec(mt, vst) => {\n-            do self.vstore_name_and_extra(t, vst) |name, extra| {\n-                self.visit(~\"evec_\" + name, extra +\n-                           self.c_mt(mt))\n-            }\n+              let (name, extra) = self.vstore_name_and_extra(t, vst);\n+              let extra = extra + self.c_mt(mt);\n+              self.visit(~\"evec_\" + name, extra)\n+          }\n+          ty::ty_box(mt) => {\n+              let extra = self.c_mt(mt);\n+              self.visit(~\"box\", extra)\n+          }\n+          ty::ty_uniq(mt) => {\n+              let extra = self.c_mt(mt);\n+              self.visit(~\"uniq\", extra)\n+          }\n+          ty::ty_ptr(mt) => {\n+              let extra = self.c_mt(mt);\n+              self.visit(~\"ptr\", extra)\n+          }\n+          ty::ty_rptr(_, mt) => {\n+              let extra = self.c_mt(mt);\n+              self.visit(~\"rptr\", extra)\n           }\n-          ty::ty_box(mt) => self.visit(~\"box\", self.c_mt(mt)),\n-          ty::ty_uniq(mt) => self.visit(~\"uniq\", self.c_mt(mt)),\n-          ty::ty_ptr(mt) => self.visit(~\"ptr\", self.c_mt(mt)),\n-          ty::ty_rptr(_, mt) => self.visit(~\"rptr\", self.c_mt(mt)),\n \n           ty::ty_rec(fields) => {\n-            do self.bracketed(~\"rec\",\n-                              ~[self.c_uint(vec::len(fields))]\n-                              + self.c_size_and_align(t)) {\n+              let extra = ~[self.c_uint(vec::len(fields))]\n+                  + self.c_size_and_align(t);\n+              do self.bracketed(~\"rec\", extra) |this| {\n                 for fields.eachi |i, field| {\n-                    self.visit(~\"rec_field\",\n-                               ~[self.c_uint(i),\n-                                 self.c_slice(\n-                                     bcx.ccx().sess.str_of(field.ident))]\n-                               + self.c_mt(field.mt));\n+                    let extra = ~[this.c_uint(i),\n+                                  this.c_slice(\n+                                      bcx.ccx().sess.str_of(field.ident))]\n+                        + this.c_mt(field.mt);\n+                    this.visit(~\"rec_field\", extra);\n                 }\n             }\n           }\n \n           ty::ty_tup(tys) => {\n-            do self.bracketed(~\"tup\",\n-                              ~[self.c_uint(vec::len(tys))]\n-                              + self.c_size_and_align(t)) {\n-                for tys.eachi |i, t| {\n-                    self.visit(~\"tup_field\",\n-                               ~[self.c_uint(i),\n-                                 self.c_tydesc(*t)]);\n-                }\n-            }\n+              let extra = ~[self.c_uint(vec::len(tys))]\n+                  + self.c_size_and_align(t);\n+              do self.bracketed(~\"tup\", extra) |this| {\n+                  for tys.eachi |i, t| {\n+                      let extra = ~[this.c_uint(i), this.c_tydesc(*t)];\n+                      this.visit(~\"tup_field\", extra);\n+                  }\n+              }\n           }\n \n           // FIXME (#2594): fetch constants out of intrinsic\n@@ -242,20 +255,21 @@ pub impl Reflector {\n           }\n \n           ty::ty_struct(did, ref substs) => {\n-            let bcx = self.bcx;\n-            let tcx = bcx.ccx().tcx;\n-            let fields = ty::struct_fields(tcx, did, substs);\n+              let bcx = self.bcx;\n+              let tcx = bcx.ccx().tcx;\n+              let fields = ty::struct_fields(tcx, did, substs);\n \n-            do self.bracketed(~\"class\", ~[self.c_uint(fields.len())]\n-                              + self.c_size_and_align(t)) {\n-                for fields.eachi |i, field| {\n-                    self.visit(~\"class_field\",\n-                               ~[self.c_uint(i),\n-                                 self.c_slice(\n-                                     bcx.ccx().sess.str_of(field.ident))]\n-                               + self.c_mt(field.mt));\n-                }\n-            }\n+              let extra = ~[self.c_uint(fields.len())]\n+                  + self.c_size_and_align(t);\n+              do self.bracketed(~\"class\", extra) |this| {\n+                  for fields.eachi |i, field| {\n+                      let extra = ~[this.c_uint(i),\n+                                    this.c_slice(\n+                                        bcx.ccx().sess.str_of(field.ident))]\n+                          + this.c_mt(field.mt);\n+                      this.visit(~\"class_field\", extra);\n+                  }\n+              }\n           }\n \n           // FIXME (#2595): visiting all the variants in turn is probably\n@@ -267,20 +281,20 @@ pub impl Reflector {\n             let tcx = bcx.ccx().tcx;\n             let variants = ty::substd_enum_variants(tcx, did, substs);\n \n-            do self.bracketed(~\"enum\",\n-                              ~[self.c_uint(vec::len(variants))]\n-                              + self.c_size_and_align(t)) {\n+            let extra = ~[self.c_uint(vec::len(variants))]\n+                + self.c_size_and_align(t);\n+            do self.bracketed(~\"enum\", extra) |this| {\n                 for variants.eachi |i, v| {\n-                    do self.bracketed(~\"enum_variant\",\n-                                      ~[self.c_uint(i),\n-                                        self.c_int(v.disr_val),\n-                                        self.c_uint(vec::len(v.args)),\n-                                        self.c_slice(\n-                                            bcx.ccx().sess.str_of(v.name))]) {\n+                    let extra1 = ~[this.c_uint(i),\n+                                   this.c_int(v.disr_val),\n+                                   this.c_uint(vec::len(v.args)),\n+                                   this.c_slice(\n+                                       bcx.ccx().sess.str_of(v.name))];\n+                    do this.bracketed(~\"enum_variant\", extra1) |this| {\n                         for v.args.eachi |j, a| {\n-                            self.visit(~\"enum_variant_field\",\n-                                       ~[self.c_uint(j),\n-                                         self.c_tydesc(*a)]);\n+                            let extra = ~[this.c_uint(j),\n+                                          this.c_tydesc(*a)];\n+                            this.visit(~\"enum_variant_field\", extra);\n                         }\n                     }\n                 }\n@@ -291,13 +305,17 @@ pub impl Reflector {\n           ty::ty_trait(_, _, _) => self.leaf(~\"trait\"),\n           ty::ty_infer(_) => self.leaf(~\"infer\"),\n           ty::ty_err => self.leaf(~\"err\"),\n-          ty::ty_param(p) => self.visit(~\"param\", ~[self.c_uint(p.idx)]),\n+          ty::ty_param(p) => {\n+              let extra = ~[self.c_uint(p.idx)];\n+              self.visit(~\"param\", extra)\n+          }\n           ty::ty_self => self.leaf(~\"self\"),\n           ty::ty_type => self.leaf(~\"type\"),\n           ty::ty_opaque_box => self.leaf(~\"opaque_box\"),\n           ty::ty_opaque_closure_ptr(ck) => {\n-            let ckval = ast_sigil_constant(ck);\n-            self.visit(~\"closure_ptr\", ~[self.c_uint(ckval)])\n+              let ckval = ast_sigil_constant(ck);\n+              let extra = ~[self.c_uint(ckval)];\n+              self.visit(~\"closure_ptr\", extra)\n           }\n         }\n     }\n@@ -312,14 +330,14 @@ pub impl Reflector {\n                     ast::by_copy => 5u\n                 }\n             };\n-            self.visit(~\"fn_input\",\n-                       ~[self.c_uint(i),\n+            let extra = ~[self.c_uint(i),\n                          self.c_uint(modeval),\n-                         self.c_tydesc(arg.ty)]);\n+                         self.c_tydesc(arg.ty)];\n+            self.visit(~\"fn_input\", extra);\n         }\n-        self.visit(~\"fn_output\",\n-                   ~[self.c_uint(retval),\n-                     self.c_tydesc(sig.output)]);\n+        let extra = ~[self.c_uint(retval),\n+                      self.c_tydesc(sig.output)];\n+        self.visit(~\"fn_output\", extra);\n     }\n }\n "}, {"sha": "d60360f554671177aac0a4e2b5f90d065b369bac", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -1934,7 +1934,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         }\n         cache.insert(ty_id, TC_NONE);\n \n-        debug!(\"computing contents of %s\", ty_to_str(cx, ty));\n         let _i = indenter();\n \n         let mut result = match get(ty).sty {\n@@ -2085,8 +2084,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             result = result + TC_BIG;\n         }\n \n-        debug!(\"result = %s\", result.to_str());\n-\n         cache.insert(ty_id, result);\n         return result;\n     }"}, {"sha": "709864c0d13e2c59083c3fbca7aec32c889e2223", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -118,11 +118,10 @@ pub impl CombineFields {\n         // A remains a subtype of B.  Actually, there are other options,\n         // but that's the route we choose to take.\n \n-        self.infcx.unify(&node_a, &node_b, |new_root, new_rank| {\n-            self.set_var_to_merged_bounds(new_root,\n-                                          &a_bounds, &b_bounds,\n-                                          new_rank)\n-        })\n+        let (new_root, new_rank) = self.infcx.unify(&node_a, &node_b);\n+        self.set_var_to_merged_bounds(new_root,\n+                                      &a_bounds, &b_bounds,\n+                                      new_rank)\n     }\n \n     /// make variable a subtype of T"}, {"sha": "230bfe693e093c8c14c0a64008015a39423af575", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 59, "deletions": 53, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -832,7 +832,7 @@ pub impl RegionVarBindings {\n           (re_infer(ReVar(*)), _) | (_, re_infer(ReVar(*))) => {\n             self.combine_vars(\n                 self.lubs, a, b, span,\n-                |old_r, new_r| self.make_subregion(span, old_r, new_r))\n+                |this, old_r, new_r| this.make_subregion(span, old_r, new_r))\n           }\n \n           _ => {\n@@ -859,7 +859,7 @@ pub impl RegionVarBindings {\n           (re_infer(ReVar(*)), _) | (_, re_infer(ReVar(*))) => {\n             self.combine_vars(\n                 self.glbs, a, b, span,\n-                |old_r, new_r| self.make_subregion(span, new_r, old_r))\n+                |this, old_r, new_r| this.make_subregion(span, new_r, old_r))\n           }\n \n           _ => {\n@@ -915,7 +915,9 @@ pub impl RegionVarBindings {\n                     a: Region,\n                     b: Region,\n                     span: span,\n-                    relate: &fn(old_r: Region, new_r: Region) -> cres<()>)\n+                    relate: &fn(self: &mut RegionVarBindings,\n+                                old_r: Region,\n+                                new_r: Region) -> cres<()>)\n                  -> cres<Region> {\n         let vars = TwoRegions { a: a, b: b };\n         match combines.find(&vars) {\n@@ -926,8 +928,8 @@ pub impl RegionVarBindings {\n             if self.in_snapshot() {\n                 self.undo_log.push(AddCombination(combines, vars));\n             }\n-            do relate(a, re_infer(ReVar(c))).then {\n-                do relate(b, re_infer(ReVar(c))).then {\n+            do relate(self, a, re_infer(ReVar(c))).then {\n+                do relate(self, b, re_infer(ReVar(c))).then {\n                     debug!(\"combine_vars() c=%?\", c);\n                     Ok(re_infer(ReVar(c)))\n                 }\n@@ -1035,7 +1037,8 @@ pub impl RegionVarBindings {\n     */\n     fn resolve_regions(&mut self) {\n         debug!(\"RegionVarBindings: resolve_regions()\");\n-        self.values.put_back(self.infer_variable_values());\n+        let v = self.infer_variable_values();\n+        self.values.put_back(v);\n     }\n }\n \n@@ -1220,7 +1223,7 @@ impl RegionVarBindings {\n         let mut graph = self.construct_graph();\n         self.expansion(&mut graph);\n         self.contraction(&mut graph);\n-        self.extract_values_and_report_conflicts(&mut graph)\n+        self.extract_values_and_report_conflicts(&graph)\n     }\n \n     fn construct_graph(&mut self) -> Graph {\n@@ -1257,14 +1260,14 @@ impl RegionVarBindings {\n \n         for uint::range(0, num_edges) |edge_idx| {\n             match graph.edges[edge_idx].constraint {\n-              ConstrainVarSubVar(copy a_id, copy b_id) => {\n+              ConstrainVarSubVar(a_id, b_id) => {\n                 insert_edge(&mut graph, a_id, Outgoing, edge_idx);\n                 insert_edge(&mut graph, b_id, Incoming, edge_idx);\n               }\n-              ConstrainRegSubVar(_, copy b_id) => {\n+              ConstrainRegSubVar(_, b_id) => {\n                 insert_edge(&mut graph, b_id, Incoming, edge_idx);\n               }\n-              ConstrainVarSubReg(copy a_id, _) => {\n+              ConstrainVarSubReg(a_id, _) => {\n                 insert_edge(&mut graph, a_id, Outgoing, edge_idx);\n               }\n             }\n@@ -1285,17 +1288,17 @@ impl RegionVarBindings {\n     }\n \n     fn expansion(&mut self, graph: &mut Graph) {\n-        do self.iterate_until_fixed_point(~\"Expansion\", graph) |edge| {\n+        do iterate_until_fixed_point(~\"Expansion\", graph) |nodes, edge| {\n             match edge.constraint {\n-              ConstrainRegSubVar(copy a_region, copy b_vid) => {\n-                let b_node = &mut graph.nodes[*b_vid];\n+              ConstrainRegSubVar(a_region, b_vid) => {\n+                let b_node = &mut nodes[*b_vid];\n                 self.expand_node(a_region, b_vid, b_node)\n               }\n-              ConstrainVarSubVar(copy a_vid, copy b_vid) => {\n-                match graph.nodes[*a_vid].value {\n+              ConstrainVarSubVar(a_vid, b_vid) => {\n+                match nodes[*a_vid].value {\n                   NoValue | ErrorValue => false,\n-                  Value(copy a_region) => {\n-                    let b_node = &mut graph.nodes[*b_vid];\n+                  Value(a_region) => {\n+                    let b_node = &mut nodes[*b_vid];\n                     self.expand_node(a_region, b_vid, b_node)\n                   }\n                 }\n@@ -1325,7 +1328,7 @@ impl RegionVarBindings {\n             return true;\n           }\n \n-          Value(copy cur_region) => {\n+          Value(cur_region) => {\n             let lub = self.lub_concrete_regions(a_region, cur_region);\n             if lub == cur_region {\n                 return false;\n@@ -1345,23 +1348,23 @@ impl RegionVarBindings {\n     }\n \n     fn contraction(&mut self, graph: &mut Graph) {\n-        do self.iterate_until_fixed_point(~\"Contraction\", graph) |edge| {\n+        do iterate_until_fixed_point(~\"Contraction\", graph) |nodes, edge| {\n             match edge.constraint {\n               ConstrainRegSubVar(*) => {\n                 // This is an expansion constraint.  Ignore.\n                 false\n               }\n-              ConstrainVarSubVar(copy a_vid, copy b_vid) => {\n-                match graph.nodes[*b_vid].value {\n+              ConstrainVarSubVar(a_vid, b_vid) => {\n+                match nodes[*b_vid].value {\n                   NoValue | ErrorValue => false,\n-                  Value(copy b_region) => {\n-                    let a_node = &mut graph.nodes[*a_vid];\n+                  Value(b_region) => {\n+                    let a_node = &mut nodes[*a_vid];\n                     self.contract_node(a_vid, a_node, b_region)\n                   }\n                 }\n               }\n-              ConstrainVarSubReg(copy a_vid, copy b_region) => {\n-                let a_node = &mut graph.nodes[*a_vid];\n+              ConstrainVarSubReg(a_vid, b_region) => {\n+                let a_node = &mut nodes[*a_vid];\n                 self.contract_node(a_vid, a_node, b_region)\n               }\n             }\n@@ -1387,7 +1390,7 @@ impl RegionVarBindings {\n                 false // no change\n             }\n \n-            Value(copy a_region) => {\n+            Value(a_region) => {\n                 match a_node.classification {\n                     Expanding => {\n                         check_node(self, a_vid, a_node, a_region, b_region)\n@@ -1438,29 +1441,10 @@ impl RegionVarBindings {\n         }\n     }\n \n-    fn iterate_until_fixed_point(&mut self,\n-                                 tag: ~str,\n-                                 graph: &mut Graph,\n-                                 body: &fn(edge: &GraphEdge) -> bool) {\n-        let mut iteration = 0;\n-        let mut changed = true;\n-        let num_edges = graph.edges.len();\n-        while changed {\n-            changed = false;\n-            iteration += 1;\n-            debug!(\"---- %s Iteration #%u\", tag, iteration);\n-            for uint::range(0, num_edges) |edge_idx| {\n-                changed |= body(&graph.edges[edge_idx]);\n-                debug!(\" >> Change after edge #%?: %?\",\n-                       edge_idx, graph.edges[edge_idx]);\n-            }\n-        }\n-        debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n-    }\n-\n-    fn extract_values_and_report_conflicts(&mut self,\n-                                           graph: &mut Graph)\n-                                        -> ~[GraphNodeValue] {\n+    fn extract_values_and_report_conflicts(\n+        &mut self,\n+        graph: &Graph) -> ~[GraphNodeValue]\n+    {\n         let dup_map = TwoRegionsMap();\n         graph.nodes.mapi(|idx, node| {\n             match node.value {\n@@ -1525,7 +1509,7 @@ impl RegionVarBindings {\n     }\n \n     fn report_error_for_expanding_node(&mut self,\n-                                       graph: &mut Graph,\n+                                       graph: &Graph,\n                                        dup_map: TwoRegionsMap,\n                                        node_idx: RegionVid) {\n         // Errors in expanding nodes result from a lower-bound that is\n@@ -1578,7 +1562,7 @@ impl RegionVarBindings {\n     }\n \n     fn report_error_for_contracting_node(&mut self,\n-                                         graph: &mut Graph,\n+                                         graph: &Graph,\n                                          dup_map: TwoRegionsMap,\n                                          node_idx: RegionVid) {\n         // Errors in contracting nodes result from two upper-bounds\n@@ -1632,7 +1616,7 @@ impl RegionVarBindings {\n     }\n \n     fn collect_concrete_regions(&mut self,\n-                                graph: &mut Graph,\n+                                graph: &Graph,\n                                 orig_node_idx: RegionVid,\n                                 dir: Direction)\n                              -> ~[SpannedRegion] {\n@@ -1676,7 +1660,7 @@ impl RegionVarBindings {\n     }\n \n     fn each_edge(&mut self,\n-                 graph: &mut Graph,\n+                 graph: &Graph,\n                  node_idx: RegionVid,\n                  dir: Direction,\n                  op: fn(edge: &GraphEdge) -> bool) {\n@@ -1690,3 +1674,25 @@ impl RegionVarBindings {\n         }\n     }\n }\n+\n+fn iterate_until_fixed_point(\n+    tag: ~str,\n+    graph: &mut Graph,\n+    body: &fn(nodes: &mut [GraphNode], edge: &GraphEdge) -> bool)\n+{\n+    let mut iteration = 0;\n+    let mut changed = true;\n+    let num_edges = graph.edges.len();\n+    while changed {\n+        changed = false;\n+        iteration += 1;\n+        debug!(\"---- %s Iteration #%u\", tag, iteration);\n+        for uint::range(0, num_edges) |edge_idx| {\n+            changed |= body(graph.nodes, &graph.edges[edge_idx]);\n+            debug!(\" >> Change after edge #%?: %?\",\n+                   edge_idx, graph.edges[edge_idx]);\n+        }\n+    }\n+    debug!(\"---- %s Complete after %u iteration(s)\", tag, iteration);\n+}\n+"}, {"sha": "69e4f373f97425f6535f566384503e973c9e7192", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -43,37 +43,49 @@ pub trait UnifyVid<T> {\n }\n \n pub impl InferCtxt {\n-    fn get<T:Copy, V:Copy Eq Vid UnifyVid<T>>(&mut self,\n-                                              +vid: V)\n-                                           -> Node<V, T> {\n+    fn get<T:Copy, V:Copy+Eq+Vid+UnifyVid<T>>(\n+        &mut self,\n+        +vid: V) -> Node<V, T>\n+    {\n         /*!\n          *\n          * Find the root node for `vid`. This uses the standard\n          * union-find algorithm with path compression:\n          * http://en.wikipedia.org/wiki/Disjoint-set_data_structure\n          */\n \n+        let tcx = self.tcx;\n         let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-        let vid_u = vid.to_uint();\n-        match vb.vals.find(vid_u) {\n-          None => {\n-            self.tcx.sess.bug(fmt!(\"failed lookup of vid `%u`\", vid_u));\n-          }\n-          Some(ref var_val) => {\n-            match (*var_val) {\n-              Redirect(vid) => {\n-                let node: Node<V,T> = self.get(vid);\n-                if node.root != vid {\n-                    // Path compression\n-                    vb.vals.insert(vid.to_uint(), Redirect(node.root));\n+        return helper(tcx, vb, vid);\n+\n+        fn helper<T:Copy, V:Copy+Eq+Vid>(\n+            tcx: ty::ctxt,\n+            vb: &mut ValsAndBindings<V,T>,\n+            vid: V) -> Node<V, T>\n+        {\n+            let vid_u = vid.to_uint();\n+            match vb.vals.find(vid_u) {\n+                None => {\n+                    tcx.sess.bug(fmt!(\n+                        \"failed lookup of vid `%u`\", vid_u));\n+                }\n+                Some(ref var_val) => {\n+                    match *var_val {\n+                        Redirect(vid) => {\n+                            let node: Node<V,T> = helper(tcx, vb, vid);\n+                            if node.root != vid {\n+                                // Path compression\n+                                vb.vals.insert(vid.to_uint(),\n+                                               Redirect(node.root));\n+                            }\n+                            node\n+                        }\n+                        Root(ref pt, rk) => {\n+                            Node {root: vid, possible_types: *pt, rank: rk}\n+                        }\n+                    }\n                 }\n-                node\n-              }\n-              Root(ref pt, rk) => {\n-                Node {root: vid, possible_types: *pt, rank: rk}\n-              }\n             }\n-          }\n         }\n     }\n \n@@ -86,21 +98,22 @@ pub impl InferCtxt {\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n          */\n \n-        let vb = UnifyVid::appropriate_vals_and_bindings(self);\n-        let old_v = vb.vals.get(vid.to_uint());\n-        vb.bindings.push((vid, old_v));\n-        vb.vals.insert(vid.to_uint(), new_v);\n+        debug!(\"Updating variable %s to %s\",\n+               vid.to_str(), new_v.inf_str(self));\n \n-        debug!(\"Updating variable %s from %s to %s\",\n-               vid.to_str(), old_v.inf_str(self), new_v.inf_str(self));\n+        { // FIXME(#4903)---borrow checker is not flow sensitive\n+            let vb = UnifyVid::appropriate_vals_and_bindings(self);\n+            let old_v = vb.vals.get(vid.to_uint());\n+            vb.bindings.push((vid, old_v));\n+            vb.vals.insert(vid.to_uint(), new_v);\n+        }\n     }\n \n-    fn unify<T:Copy InferStr, V:Copy Vid ToStr UnifyVid<T>, R>(\n-            &mut self,\n-            node_a: &Node<V, T>,\n-            node_b: &Node<V, T>,\n-            op: &fn(new_root: V, new_rank: uint) -> R\n-    ) -> R {\n+    fn unify<T:Copy InferStr, V:Copy Vid ToStr UnifyVid<T>>(\n+        &mut self,\n+        node_a: &Node<V, T>,\n+        node_b: &Node<V, T>) -> (V, uint)\n+    {\n         // Rank optimization: if you don't know what it is, check\n         // out <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n \n@@ -113,17 +126,17 @@ pub impl InferCtxt {\n             // a has greater rank, so a should become b's parent,\n             // i.e., b should redirect to a.\n             self.set(node_b.root, Redirect(node_a.root));\n-            op(node_a.root, node_a.rank)\n+            (node_a.root, node_a.rank)\n         } else if node_a.rank < node_b.rank {\n             // b has greater rank, so a should redirect to b.\n             self.set(node_a.root, Redirect(node_b.root));\n-            op(node_b.root, node_b.rank)\n+            (node_b.root, node_b.rank)\n         } else {\n             // If equal, redirect one to the other and increment the\n             // other's rank.\n             assert node_a.rank == node_b.rank;\n             self.set(node_b.root, Redirect(node_a.root));\n-            op(node_a.root, node_a.rank + 1)\n+            (node_a.root, node_a.rank + 1)\n         }\n     }\n \n@@ -183,9 +196,8 @@ pub impl InferCtxt {\n             }\n         };\n \n-        self.unify(&node_a, &node_b, |new_root, new_rank| {\n-            self.set(new_root, Root(combined, new_rank));\n-        });\n+        let (new_root, new_rank) = self.unify(&node_a, &node_b);\n+        self.set(new_root, Root(combined, new_rank));\n         return uok();\n     }\n "}, {"sha": "ff28d2cbebf6f1c9af79c0241bc152cdedff1a7d", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 50, "deletions": 35, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -184,25 +184,30 @@ impl<T: Owned> &MutexARC<T> {\n      */\n     #[inline(always)]\n     unsafe fn access<U>(blk: fn(x: &mut T) -> U) -> U {\n-        let state = unsafe { get_shared_mutable_state(&self.x) };\n-        // Borrowck would complain about this if the function were not already\n-        // unsafe. See borrow_rwlock, far below.\n-        do (&state.lock).lock {\n-            check_poison(true, state.failed);\n-            let _z = PoisonOnFail(&mut state.failed);\n-            blk(&mut state.data)\n+        unsafe {\n+            let state = get_shared_mutable_state(&self.x);\n+            // Borrowck would complain about this if the function were\n+            // not already unsafe. See borrow_rwlock, far below.\n+            do (&(*state).lock).lock {\n+                check_poison(true, (*state).failed);\n+                let _z = PoisonOnFail(&mut (*state).failed);\n+                blk(&mut (*state).data)\n+            }\n         }\n     }\n     /// As access(), but with a condvar, as sync::mutex.lock_cond().\n     #[inline(always)]\n     unsafe fn access_cond<U>(blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n-        let state = unsafe { get_shared_mutable_state(&self.x) };\n-        do (&state.lock).lock_cond |cond| {\n-            check_poison(true, state.failed);\n-            let _z = PoisonOnFail(&mut state.failed);\n-            blk(&mut state.data,\n-                &Condvar { is_mutex: true, failed: &mut state.failed,\n-                           cond: cond })\n+        unsafe {\n+            let state = get_shared_mutable_state(&self.x);\n+            do (&(*state).lock).lock_cond |cond| {\n+                check_poison(true, (*state).failed);\n+                let _z = PoisonOnFail(&mut (*state).failed);\n+                blk(&mut (*state).data,\n+                    &Condvar {is_mutex: true,\n+                              failed: &mut (*state).failed,\n+                              cond: cond })\n+            }\n         }\n     }\n }\n@@ -285,8 +290,10 @@ pub fn RWARC<T: Const Owned>(user_data: T) -> RWARC<T> {\n  * Create a reader/writer ARC with the supplied data and a specified number\n  * of condvars (as sync::rwlock_with_condvars).\n  */\n-pub fn rw_arc_with_condvars<T: Const Owned>(user_data: T,\n-                                       num_condvars: uint) -> RWARC<T> {\n+pub fn rw_arc_with_condvars<T: Const Owned>(\n+    user_data: T,\n+    num_condvars: uint) -> RWARC<T>\n+{\n     let data =\n         RWARCInner { lock: rwlock_with_condvars(num_condvars),\n                      failed: false, data: move user_data };\n@@ -315,23 +322,28 @@ impl<T: Const Owned> &RWARC<T> {\n      */\n     #[inline(always)]\n     fn write<U>(blk: fn(x: &mut T) -> U) -> U {\n-        let state = unsafe { get_shared_mutable_state(&self.x) };\n-        do borrow_rwlock(state).write {\n-            check_poison(false, state.failed);\n-            let _z = PoisonOnFail(&mut state.failed);\n-            blk(&mut state.data)\n+        unsafe {\n+            let state = get_shared_mutable_state(&self.x);\n+            do (*borrow_rwlock(state)).write {\n+                check_poison(false, (*state).failed);\n+                let _z = PoisonOnFail(&mut (*state).failed);\n+                blk(&mut (*state).data)\n+            }\n         }\n     }\n     /// As write(), but with a condvar, as sync::rwlock.write_cond().\n     #[inline(always)]\n     fn write_cond<U>(blk: fn(x: &x/mut T, c: &c/Condvar) -> U) -> U {\n-        let state = unsafe { get_shared_mutable_state(&self.x) };\n-        do borrow_rwlock(state).write_cond |cond| {\n-            check_poison(false, state.failed);\n-            let _z = PoisonOnFail(&mut state.failed);\n-            blk(&mut state.data,\n-                &Condvar { is_mutex: false, failed: &mut state.failed,\n-                           cond: cond })\n+        unsafe {\n+            let state = get_shared_mutable_state(&self.x);\n+            do (*borrow_rwlock(state)).write_cond |cond| {\n+                check_poison(false, (*state).failed);\n+                let _z = PoisonOnFail(&mut (*state).failed);\n+                blk(&mut (*state).data,\n+                    &Condvar {is_mutex: false,\n+                              failed: &mut (*state).failed,\n+                              cond: cond})\n+            }\n         }\n     }\n     /**\n@@ -369,11 +381,14 @@ impl<T: Const Owned> &RWARC<T> {\n      * ~~~\n      */\n     fn write_downgrade<U>(blk: fn(v: RWWriteMode<T>) -> U) -> U {\n-        let state = unsafe { get_shared_mutable_state(&self.x) };\n-        do borrow_rwlock(state).write_downgrade |write_mode| {\n-            check_poison(false, state.failed);\n-            blk(RWWriteMode((&mut state.data, move write_mode,\n-                              PoisonOnFail(&mut state.failed))))\n+        unsafe {\n+            let state = get_shared_mutable_state(&self.x);\n+            do (*borrow_rwlock(state)).write_downgrade |write_mode| {\n+                check_poison(false, (*state).failed);\n+                blk(RWWriteMode((&mut (*state).data,\n+                                 move write_mode,\n+                                 PoisonOnFail(&mut (*state).failed))))\n+            }\n         }\n     }\n \n@@ -417,8 +432,8 @@ pub fn unwrap_rw_arc<T: Const Owned>(arc: RWARC<T>) -> T {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T: Const Owned>(state: &r/mut RWARCInner<T>) -> &r/RWlock {\n-    unsafe { cast::transmute(&mut state.lock) }\n+fn borrow_rwlock<T: Const Owned>(state: *const RWARCInner<T>) -> *RWlock {\n+    unsafe { cast::transmute(&const (*state).lock) }\n }\n \n // FIXME (#3154) ice with struct/&<T> prevents these from being structs."}, {"sha": "a64aa5e9687429b3ba21d3efa8d3191b5b44858e", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -81,7 +81,8 @@ impl <T: Ord> PriorityQueue<T> {\n     /// Push an item onto the queue\n     fn push(&mut self, item: T) {\n         self.data.push(item);\n-        self.siftup(0, self.len() - 1);\n+        let new_len = self.len() - 1;\n+        self.siftup(0, new_len);\n     }\n \n     /// Optimized version of a push followed by a pop\n@@ -179,7 +180,8 @@ impl <T: Ord> PriorityQueue<T> {\n     }\n \n     priv fn siftdown(&mut self, pos: uint) {\n-        self.siftdown_range(pos, self.len());\n+        let len = self.len();\n+        self.siftdown_range(pos, len);\n     }\n }\n "}, {"sha": "2e5cd8956cd9d5a452b81557b22d11aed4f1647a", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -134,10 +134,11 @@ pub impl<V> SmallIntMap<V> {\n pub impl<V: Copy> SmallIntMap<V> {\n     fn update_with_key(&mut self, key: uint, val: V,\n                        ff: fn(uint, V, V) -> V) -> bool {\n-        match self.find(&key) {\n-          None => self.insert(key, val),\n-          Some(orig) => self.insert(key, ff(key, copy *orig, val)),\n-        }\n+        let new_val = match self.find(&key) {\n+            None => val,\n+            Some(orig) => ff(key, *orig, val)\n+        };\n+        self.insert(key, new_val)\n     }\n \n     fn update(&mut self, key: uint, newval: V, ff: fn(V, V) -> V) -> bool {"}, {"sha": "2fdaeb545a286dc003e1260d33ee4297f43d73ce", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -673,45 +673,45 @@ fn remove<K: Ord, V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n             }\n         };\n \n-        if this {\n-            *node = None;\n-            return true;\n-        }\n+        if !this {\n+            let left_level = save.left.map_default(0, |x| x.level);\n+            let right_level = save.right.map_default(0, |x| x.level);\n \n-        let left_level = save.left.map_default(0, |x| x.level);\n-        let right_level = save.right.map_default(0, |x| x.level);\n+            // re-balance, if necessary\n+            if left_level < save.level - 1 || right_level < save.level - 1 {\n+                save.level -= 1;\n \n-        // re-balance, if necessary\n-        if left_level < save.level - 1 || right_level < save.level - 1 {\n-            save.level -= 1;\n+                if right_level > save.level {\n+                    do save.right.mutate |mut x| { x.level = save.level; x }\n+                }\n \n-            if right_level > save.level {\n-                do save.right.mutate |mut x| { x.level = save.level; x }\n-            }\n+                skew(save);\n \n-            skew(save);\n+                match save.right {\n+                    Some(ref mut right) => {\n+                        skew(right);\n+                        match right.right {\n+                            Some(ref mut x) => { skew(x) },\n+                            None => ()\n+                        }\n+                    }\n+                    None => ()\n+                }\n \n-            match save.right {\n-              Some(ref mut right) => {\n-                skew(right);\n-                match right.right {\n-                  Some(ref mut x) => { skew(x) },\n-                  None => ()\n+                split(save);\n+                match save.right {\n+                    Some(ref mut x) => { split(x) },\n+                    None => ()\n                 }\n-              }\n-              None => ()\n             }\n \n-            split(save);\n-            match save.right {\n-              Some(ref mut x) => { split(x) },\n-              None => ()\n-            }\n+            return removed;\n         }\n-\n-        removed\n       }\n     }\n+\n+    *node = None;\n+    return true;\n }\n \n #[cfg(test)]"}, {"sha": "47b6b4de64281a5039bdd2d11a2e2f251804a249", "filename": "src/test/compile-fail/borrowck-borrow-from-owned-ptr.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-owned-ptr.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+  bar1: Bar,\n+  bar2: Bar\n+}\n+\n+struct Bar {\n+  int1: int,\n+  int2: int,\n+}\n+\n+fn make_foo() -> ~Foo { die!() }\n+\n+fn borrow_same_field_twice_mut_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_same_field_twice_mut_imm() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1;\n+    let _bar2 = &foo.bar1;  //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_same_field_twice_imm_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_same_field_twice_imm_imm() {\n+    let mut foo = make_foo();\n+    let _bar1 = &foo.bar1;\n+    let _bar2 = &foo.bar1;\n+}\n+\n+fn borrow_both_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1;\n+    let _bar2 = &mut foo.bar2;\n+}\n+\n+fn borrow_both_mut_pattern() {\n+    let mut foo = make_foo();\n+    match *foo {\n+        Foo { bar1: ref mut _bar1, bar2: ref mut _bar2 } => {}\n+    }\n+}\n+\n+fn borrow_var_and_pattern() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1;\n+    match *foo {\n+        Foo { bar1: ref mut _bar1, bar2: _ } => {}\n+        //~^ ERROR conflicts with prior loan\n+    }\n+}\n+\n+fn borrow_mut_and_base_imm() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &foo.bar1; //~ ERROR conflicts with prior loan\n+    let _foo2 = &*foo; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_mut_and_base_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_mut_and_base_mut2() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_imm_and_base_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_imm_and_base_mut2() {\n+    let mut foo = make_foo();\n+    let _bar1 = &foo.bar1.int1;\n+    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_imm_and_base_imm() {\n+    let mut foo = make_foo();\n+    let _bar1 = &foo.bar1.int1;\n+    let _foo1 = &foo.bar1;\n+    let _foo2 = &*foo;\n+}\n+\n+fn borrow_mut_and_imm() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1;\n+    let _foo1 = &foo.bar2;\n+}\n+\n+fn borrow_mut_from_imm() {\n+    let foo = make_foo();\n+    let _bar1 = &mut foo.bar1; //~ ERROR illegal borrow\n+}\n+\n+fn borrow_long_path_both_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &mut foo.bar2.int2;\n+}\n+\n+fn main() {}"}, {"sha": "30757cc6e7798902e144a195e75d50401d128177", "filename": "src/test/compile-fail/borrowck-borrow-from-stack-variable.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-from-stack-variable.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -0,0 +1,124 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+  bar1: Bar,\n+  bar2: Bar\n+}\n+\n+struct Bar {\n+  int1: int,\n+  int2: int,\n+}\n+\n+fn make_foo() -> Foo { die!() }\n+\n+fn borrow_same_field_twice_mut_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_same_field_twice_mut_imm() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1;\n+    let _bar2 = &foo.bar1;  //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_same_field_twice_imm_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_same_field_twice_imm_imm() {\n+    let mut foo = make_foo();\n+    let _bar1 = &foo.bar1;\n+    let _bar2 = &foo.bar1;\n+}\n+\n+fn borrow_both_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1;\n+    let _bar2 = &mut foo.bar2;\n+}\n+\n+fn borrow_both_mut_pattern() {\n+    let mut foo = make_foo();\n+    match foo {\n+        Foo { bar1: ref mut _bar1, bar2: ref mut _bar2 } => {}\n+    }\n+}\n+\n+fn borrow_var_and_pattern() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1;\n+    match foo {\n+        Foo { bar1: ref mut _bar1, bar2: _ } => {}\n+        //~^ ERROR conflicts with prior loan\n+    }\n+}\n+\n+fn borrow_mut_and_base_imm() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &foo.bar1; //~ ERROR conflicts with prior loan\n+    let _foo2 = &foo; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_mut_and_base_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_mut_and_base_mut2() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo2 = &mut foo; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_imm_and_base_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_imm_and_base_mut2() {\n+    let mut foo = make_foo();\n+    let _bar1 = &foo.bar1.int1;\n+    let _foo2 = &mut foo; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_imm_and_base_imm() {\n+    let mut foo = make_foo();\n+    let _bar1 = &foo.bar1.int1;\n+    let _foo1 = &foo.bar1;\n+    let _foo2 = &foo;\n+}\n+\n+fn borrow_mut_and_imm() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1;\n+    let _foo1 = &foo.bar2;\n+}\n+\n+fn borrow_mut_from_imm() {\n+    let foo = make_foo();\n+    let _bar1 = &mut foo.bar1; //~ ERROR illegal borrow\n+}\n+\n+fn borrow_long_path_both_mut() {\n+    let mut foo = make_foo();\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &mut foo.bar2.int2;\n+}\n+\n+fn main() {}"}, {"sha": "7b5d9829f5f56c8b3e6c7ee50d457ec33bf4f159", "filename": "src/test/compile-fail/borrowck-confuse-region.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/91c59f5c9a6d1fe72a18768b074fcb16542e0ca1/src%2Ftest%2Fcompile-fail%2Fborrowck-confuse-region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c59f5c9a6d1fe72a18768b074fcb16542e0ca1/src%2Ftest%2Fcompile-fail%2Fborrowck-confuse-region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-confuse-region.rs?ref=91c59f5c9a6d1fe72a18768b074fcb16542e0ca1", "patch": "@@ -1,26 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Here we are checking that a reasonable error msg is provided.\n-//\n-// The current message is not ideal, but we used to say \"borrowed\n-// pointer has lifetime &, but the borrowed value only has lifetime &\"\n-// which is definitely no good.\n-\n-\n-fn get() -> &int {\n-    //~^ NOTE borrowed pointer must be valid for the anonymous lifetime #1 defined on\n-    //~^^ NOTE ...but borrowed value is only valid for the block at\n-    let x = 3;\n-    return &x;\n-    //~^ ERROR illegal borrow\n-}\n-\n-fn main() {}"}, {"sha": "5c3fe229602545b11ad96af01b01660e945453cf", "filename": "src/test/compile-fail/borrowck-imm-field-mut-base.rs", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/91c59f5c9a6d1fe72a18768b074fcb16542e0ca1/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-mut-base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c59f5c9a6d1fe72a18768b074fcb16542e0ca1/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-mut-base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-imm-field-mut-base.rs?ref=91c59f5c9a6d1fe72a18768b074fcb16542e0ca1", "patch": "@@ -1,30 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct Foo {\n-    mut x: uint\n-}\n-\n-struct Bar {\n-    foo: Foo\n-}\n-\n-fn main() {\n-    let mut b = Bar { foo: Foo { x: 3 } };\n-    let p = &b.foo.x;\n-    let q = &mut b.foo; //~ ERROR loan of mutable field as mutable conflicts with prior loan\n-    //~^ ERROR loan of mutable local variable as mutable conflicts with prior loan\n-    let r = &mut b; //~ ERROR loan of mutable local variable as mutable conflicts with prior loan\n-    //~^ ERROR loan of mutable local variable as mutable conflicts with prior loan\n-    io::println(fmt!(\"*p = %u\", *p));\n-    q.x += 1;\n-    r.foo.x += 1;\n-    io::println(fmt!(\"*p = %u\", *p));\n-}"}, {"sha": "1dcf8268440eb1037a13f3c138133d1cb2efc55d", "filename": "src/test/compile-fail/borrowck-insert-during-each.rs", "status": "renamed", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-insert-during-each.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -8,20 +8,27 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use core::hashmap::linear::LinearSet;\n+\n struct Foo {\n-    x: uint\n+  n: LinearSet<int>,\n+}\n+\n+impl Foo {\n+  fn foo(&mut self, fun: fn(&int)) {\n+    for self.n.each |f| {\n+      fun(f);\n+    }\n+  }\n }\n \n-struct Bar {\n-    foo: Foo\n+fn bar(f: &mut Foo) {\n+  do f.foo |a| { //~ NOTE prior loan as mutable granted here\n+    f.n.insert(*a); //~ ERROR conflicts with prior loan\n+  }\n }\n \n fn main() {\n-    let mut b = Bar { foo: Foo { x: 3 } };\n-    let p = &b; //~ NOTE prior loan as immutable granted here\n-    let q = &mut b.foo.x; //~ ERROR loan of mutable local variable as mutable conflicts with prior loan\n-    let r = &p.foo.x;\n-    io::println(fmt!(\"*r = %u\", *r));\n-    *q += 1;\n-    io::println(fmt!(\"*r = %u\", *r));\n+  let mut f = Foo { n: LinearSet::new() };\n+  bar(&mut f);\n }\n\\ No newline at end of file", "previous_filename": "src/test/compile-fail/borrowck-imm-field-imm-base.rs"}, {"sha": "60f817dee0c54b011474a06b11d5928e8fb61274", "filename": "src/test/compile-fail/borrowck-reborrow-from-mut.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ab2534974caf39e69b401442ff1a9077b94c46c1/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-reborrow-from-mut.rs?ref=ab2534974caf39e69b401442ff1a9077b94c46c1", "patch": "@@ -0,0 +1,106 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+  bar1: Bar,\n+  bar2: Bar\n+}\n+\n+struct Bar {\n+  int1: int,\n+  int2: int,\n+}\n+\n+fn borrow_same_field_twice_mut_mut(foo: &mut Foo) {\n+    let _bar1 = &mut foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_same_field_twice_mut_imm(foo: &mut Foo) {\n+    let _bar1 = &mut foo.bar1;\n+    let _bar2 = &foo.bar1;  //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_same_field_twice_imm_mut(foo: &mut Foo) {\n+    let _bar1 = &foo.bar1;\n+    let _bar2 = &mut foo.bar1;  //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_same_field_twice_imm_imm(foo: &mut Foo) {\n+    let _bar1 = &foo.bar1;\n+    let _bar2 = &foo.bar1;\n+}\n+\n+fn borrow_both_mut(foo: &mut Foo) {\n+    let _bar1 = &mut foo.bar1;\n+    let _bar2 = &mut foo.bar2;\n+}\n+\n+fn borrow_both_mut_pattern(foo: &mut Foo) {\n+    match *foo {\n+        Foo { bar1: ref mut _bar1, bar2: ref mut _bar2 } => {}\n+    }\n+}\n+\n+fn borrow_var_and_pattern(foo: &mut Foo) {\n+    let _bar1 = &mut foo.bar1;\n+    match *foo {\n+        Foo { bar1: ref mut _bar1, bar2: _ } => {}\n+        //~^ ERROR conflicts with prior loan\n+    }\n+}\n+\n+fn borrow_mut_and_base_imm(foo: &mut Foo) {\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &foo.bar1; //~ ERROR conflicts with prior loan\n+    let _foo2 = &*foo; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_mut_and_base_mut(foo: &mut Foo) {\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_mut_and_base_mut2(foo: &mut Foo) {\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_imm_and_base_mut(foo: &mut Foo) {\n+    let _bar1 = &foo.bar1.int1;\n+    let _foo1 = &mut foo.bar1; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_imm_and_base_mut2(foo: &mut Foo) {\n+    let _bar1 = &foo.bar1.int1;\n+    let _foo2 = &mut *foo; //~ ERROR conflicts with prior loan\n+}\n+\n+fn borrow_imm_and_base_imm(foo: &mut Foo) {\n+    let _bar1 = &foo.bar1.int1;\n+    let _foo1 = &foo.bar1;\n+    let _foo2 = &*foo;\n+}\n+\n+fn borrow_mut_and_imm(foo: &mut Foo) {\n+    let _bar1 = &mut foo.bar1;\n+    let _foo1 = &foo.bar2;\n+}\n+\n+fn borrow_mut_from_imm(foo: &Foo) {\n+    let _bar1 = &mut foo.bar1; //~ ERROR illegal borrow\n+}\n+\n+fn borrow_long_path_both_mut(foo: &mut Foo) {\n+    let _bar1 = &mut foo.bar1.int1;\n+    let _foo1 = &mut foo.bar2.int2;\n+}\n+\n+fn main() {}"}]}