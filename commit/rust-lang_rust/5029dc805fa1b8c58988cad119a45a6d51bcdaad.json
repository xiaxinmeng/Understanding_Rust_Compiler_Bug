{"sha": "5029dc805fa1b8c58988cad119a45a6d51bcdaad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMjlkYzgwNWZhMWI4YzU4OTg4Y2FkMTE5YTQ1YTZkNTFiY2RhYWQ=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-02-08T15:24:23Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-31T15:05:42Z"}, "message": "New Lint: excessive_for_each", "tree": {"sha": "facbd86cfb2d7a52ff816ba909c6d454e03470fb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/facbd86cfb2d7a52ff816ba909c6d454e03470fb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5029dc805fa1b8c58988cad119a45a6d51bcdaad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5029dc805fa1b8c58988cad119a45a6d51bcdaad", "html_url": "https://github.com/rust-lang/rust/commit/5029dc805fa1b8c58988cad119a45a6d51bcdaad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5029dc805fa1b8c58988cad119a45a6d51bcdaad/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd", "html_url": "https://github.com/rust-lang/rust/commit/2e33bf634780ca3e36d88e14b4aa7352b2d8e2dd"}], "stats": {"total": 401, "additions": 401, "deletions": 0}, "files": [{"sha": "c35ab6c94bf9b64fea824b718341817e4a4818e9", "filename": "CHANGELOG.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5029dc805fa1b8c58988cad119a45a6d51bcdaad/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/5029dc805fa1b8c58988cad119a45a6d51bcdaad/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=5029dc805fa1b8c58988cad119a45a6d51bcdaad", "patch": "@@ -2192,6 +2192,7 @@ Released 2018-09-13\n [`eq_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#eq_op\n [`erasing_op`]: https://rust-lang.github.io/rust-clippy/master/index.html#erasing_op\n [`eval_order_dependence`]: https://rust-lang.github.io/rust-clippy/master/index.html#eval_order_dependence\n+[`excessive_for_each`]: https://rust-lang.github.io/rust-clippy/master/index.html#excessive_for_each\n [`excessive_precision`]: https://rust-lang.github.io/rust-clippy/master/index.html#excessive_precision\n [`exhaustive_enums`]: https://rust-lang.github.io/rust-clippy/master/index.html#exhaustive_enums\n [`exhaustive_structs`]: https://rust-lang.github.io/rust-clippy/master/index.html#exhaustive_structs"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "clippy_lints/src/iter_for_each.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5029dc805fa1b8c58988cad119a45a6d51bcdaad/clippy_lints%2Fsrc%2Fiter_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029dc805fa1b8c58988cad119a45a6d51bcdaad/clippy_lints%2Fsrc%2Fiter_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fiter_for_each.rs?ref=5029dc805fa1b8c58988cad119a45a6d51bcdaad"}, {"sha": "8fb3bfdafc9a910e702f60c90d793186dfc51726", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5029dc805fa1b8c58988cad119a45a6d51bcdaad/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029dc805fa1b8c58988cad119a45a6d51bcdaad/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=5029dc805fa1b8c58988cad119a45a6d51bcdaad", "patch": "@@ -781,6 +781,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &methods::CLONE_DOUBLE_REF,\n         &methods::CLONE_ON_COPY,\n         &methods::CLONE_ON_REF_PTR,\n+        &methods::EXCESSIVE_FOR_EACH,\n         &methods::EXPECT_FUN_CALL,\n         &methods::EXPECT_USED,\n         &methods::FILETYPE_IS_FILE,\n@@ -1581,6 +1582,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::CHARS_NEXT_CMP),\n         LintId::of(&methods::CLONE_DOUBLE_REF),\n         LintId::of(&methods::CLONE_ON_COPY),\n+        LintId::of(&methods::EXCESSIVE_FOR_EACH),\n         LintId::of(&methods::EXPECT_FUN_CALL),\n         LintId::of(&methods::FILTER_MAP_IDENTITY),\n         LintId::of(&methods::FILTER_NEXT),\n@@ -1797,6 +1799,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&methods::BYTES_NTH),\n         LintId::of(&methods::CHARS_LAST_CMP),\n         LintId::of(&methods::CHARS_NEXT_CMP),\n+        LintId::of(&methods::EXCESSIVE_FOR_EACH),\n         LintId::of(&methods::FROM_ITER_INSTEAD_OF_COLLECT),\n         LintId::of(&methods::INTO_ITER_ON_REF),\n         LintId::of(&methods::ITER_CLONED_COLLECT),"}, {"sha": "36f92d5b95f9eab88479a1512846555d0c5931d5", "filename": "clippy_lints/src/methods/excessive_for_each.rs", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/5029dc805fa1b8c58988cad119a45a6d51bcdaad/clippy_lints%2Fsrc%2Fmethods%2Fexcessive_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029dc805fa1b8c58988cad119a45a6d51bcdaad/clippy_lints%2Fsrc%2Fmethods%2Fexcessive_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexcessive_for_each.rs?ref=5029dc805fa1b8c58988cad119a45a6d51bcdaad", "patch": "@@ -0,0 +1,149 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{\n+    intravisit::{walk_expr, NestedVisitorMap, Visitor},\n+    Expr, ExprKind,\n+};\n+use rustc_lint::LateContext;\n+use rustc_middle::{hir::map::Map, ty, ty::Ty};\n+use rustc_span::source_map::Span;\n+\n+use crate::utils::{match_trait_method, match_type, paths, snippet, span_lint_and_then};\n+\n+use if_chain::if_chain;\n+\n+pub(super) fn lint(cx: &LateContext<'_>, expr: &'tcx Expr<'_>, args: &[&[Expr<'_>]]) {\n+    if args.len() < 2 {\n+        return;\n+    }\n+\n+    let for_each_args = args[0];\n+    if for_each_args.len() < 2 {\n+        return;\n+    }\n+    let for_each_receiver = &for_each_args[0];\n+    let for_each_arg = &for_each_args[1];\n+    let iter_receiver = &args[1][0];\n+\n+    if_chain! {\n+        if match_trait_method(cx, expr, &paths::ITERATOR);\n+        if !match_trait_method(cx, for_each_receiver, &paths::ITERATOR);\n+        if is_target_ty(cx, cx.typeck_results().expr_ty(iter_receiver));\n+        if let ExprKind::Closure(_, _, body_id, ..) = for_each_arg.kind;\n+        then {\n+            let body = cx.tcx.hir().body(body_id);\n+            let mut ret_span_collector = RetSpanCollector::new();\n+            ret_span_collector.visit_expr(&body.value);\n+\n+            let label = \"'outer\";\n+            let loop_label = if ret_span_collector.need_label {\n+                format!(\"{}: \", label)\n+            } else {\n+                \"\".to_string()\n+            };\n+            let sugg =\n+                format!(\"{}for {} in {} {{ .. }}\", loop_label, snippet(cx, body.params[0].pat.span, \"\"), snippet(cx, for_each_receiver.span, \"\"));\n+\n+            let mut notes = vec![];\n+            for (span, need_label) in ret_span_collector.spans {\n+                let cont_label = if need_label {\n+                    format!(\" {}\", label)\n+                } else {\n+                    \"\".to_string()\n+                };\n+                let note = format!(\"change `return` to `continue{}` in the loop body\", cont_label);\n+                notes.push((span, note));\n+            }\n+\n+            span_lint_and_then(cx,\n+                      super::EXCESSIVE_FOR_EACH,\n+                      expr.span,\n+                      \"excessive use of `for_each`\",\n+                      |diag| {\n+                          diag.span_suggestion(expr.span, \"try\", sugg, Applicability::HasPlaceholders);\n+                          for note in notes {\n+                              diag.span_note(note.0, &note.1);\n+                          }\n+                      }\n+                );\n+        }\n+    }\n+}\n+\n+type PathSegment = &'static [&'static str];\n+\n+const TARGET_ITER_RECEIVER_TY: &[PathSegment] = &[\n+    &paths::VEC,\n+    &paths::VEC_DEQUE,\n+    &paths::LINKED_LIST,\n+    &paths::HASHMAP,\n+    &paths::BTREEMAP,\n+    &paths::HASHSET,\n+    &paths::BTREESET,\n+    &paths::BINARY_HEAP,\n+];\n+\n+fn is_target_ty(cx: &LateContext<'_>, expr_ty: Ty<'_>) -> bool {\n+    let expr_ty = expr_ty.peel_refs();\n+    for target in TARGET_ITER_RECEIVER_TY {\n+        if match_type(cx, expr_ty, target) {\n+            return true;\n+        }\n+    }\n+\n+    if_chain! {\n+        if matches!(expr_ty.kind(), ty::Slice(_) | ty::Array(..));\n+        then {\n+            return true;\n+        }\n+    }\n+\n+    false\n+}\n+\n+/// Collect spans of `return` in the closure body.\n+struct RetSpanCollector {\n+    spans: Vec<(Span, bool)>,\n+    loop_depth: u16,\n+    need_label: bool,\n+}\n+\n+impl RetSpanCollector {\n+    fn new() -> Self {\n+        Self {\n+            spans: Vec::new(),\n+            loop_depth: 0,\n+            need_label: false,\n+        }\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for RetSpanCollector {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_expr(&mut self, expr: &Expr<'_>) {\n+        match expr.kind {\n+            ExprKind::Ret(..) => {\n+                if self.loop_depth > 0 && !self.need_label {\n+                    self.need_label = true\n+                }\n+\n+                self.spans.push((expr.span, self.loop_depth > 0))\n+            },\n+\n+            ExprKind::Loop(..) => {\n+                self.loop_depth += 1;\n+                walk_expr(self, expr);\n+                self.loop_depth -= 1;\n+                return;\n+            },\n+\n+            _ => {},\n+        }\n+\n+        walk_expr(self, expr);\n+    }\n+\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}, {"sha": "058140fddb8031cc0235021facf6458deda573fb", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5029dc805fa1b8c58988cad119a45a6d51bcdaad/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029dc805fa1b8c58988cad119a45a6d51bcdaad/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=5029dc805fa1b8c58988cad119a45a6d51bcdaad", "patch": "@@ -974,6 +974,33 @@ declare_clippy_lint! {\n     \"using `.skip(x).next()` on an iterator\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for use of `obj.method().for_each(closure)` if obj doesn't\n+    /// implelement `Iterator` and `method()` returns `Impl Iterator` type.\n+    ///\n+    /// **Why is this bad?** Excessive use of `for_each` reduces redability, using `for` loop is\n+    /// clearer and more concise.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let v = vec![0, 1, 2];\n+    /// v.iter().for_each(|elem| println!(\"{}\", elem));\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let v = vec![0, 1, 2];\n+    /// for elem in v.iter() {\n+    ///     println!(\"{}\", elem);\n+    /// }\n+    /// ```\n+    pub EXCESSIVE_FOR_EACH,\n+    style,\n+    \"using `.iter().for_each(|x| {..})` when using `for` loop would work instead\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `.get().unwrap()` (or\n     /// `.get_mut().unwrap`) on a standard library type which implements `Index`\n@@ -1661,6 +1688,7 @@ impl_lint_pass!(Methods => [\n     ITER_NTH_ZERO,\n     BYTES_NTH,\n     ITER_SKIP_NEXT,\n+    EXCESSIVE_FOR_EACH,\n     GET_UNWRAP,\n     STRING_EXTEND_CHARS,\n     ITER_CLONED_COLLECT,\n@@ -1807,6 +1835,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             [\"to_os_string\", ..] => implicit_clone::check(cx, expr, sym::OsStr),\n             [\"to_path_buf\", ..] => implicit_clone::check(cx, expr, sym::Path),\n             [\"to_vec\", ..] => implicit_clone::check(cx, expr, sym::slice),\n+            [\"for_each\", ..] => excessive_for_each::lint(cx, expr, &arg_lists),\n             _ => {},\n         }\n "}, {"sha": "12c87782d97b938abcfd188c0a829626f387c828", "filename": "tests/ui/excessive_for_each.rs", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/5029dc805fa1b8c58988cad119a45a6d51bcdaad/tests%2Fui%2Fexcessive_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5029dc805fa1b8c58988cad119a45a6d51bcdaad/tests%2Fui%2Fexcessive_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_for_each.rs?ref=5029dc805fa1b8c58988cad119a45a6d51bcdaad", "patch": "@@ -0,0 +1,96 @@\n+#![warn(clippy::excessive_for_each)]\n+#![allow(clippy::needless_return)]\n+\n+use std::collections::*;\n+\n+fn main() {\n+    // Should trigger this lint: Vec.\n+    let vec: Vec<i32> = Vec::new();\n+    vec.iter().for_each(|v| println!(\"{}\", v));\n+\n+    // Should trigger this lint: &Vec.\n+    let vec_ref = &vec;\n+    vec_ref.iter().for_each(|v| println!(\"{}\", v));\n+\n+    // Should trigger this lint: VecDeque.\n+    let vec_deq: VecDeque<i32> = VecDeque::new();\n+    vec_deq.iter().for_each(|v| println!(\"{}\", v));\n+\n+    // Should trigger this lint: LinkedList.\n+    let list: LinkedList<i32> = LinkedList::new();\n+    list.iter().for_each(|v| println!(\"{}\", v));\n+\n+    // Should trigger this lint: HashMap.\n+    let mut hash_map: HashMap<i32, i32> = HashMap::new();\n+    hash_map.iter().for_each(|(k, v)| println!(\"{}: {}\", k, v));\n+    hash_map.iter_mut().for_each(|(k, v)| println!(\"{}: {}\", k, v));\n+    hash_map.keys().for_each(|k| println!(\"{}\", k));\n+    hash_map.values().for_each(|v| println!(\"{}\", v));\n+\n+    // Should trigger this lint: HashSet.\n+    let hash_set: HashSet<i32> = HashSet::new();\n+    hash_set.iter().for_each(|v| println!(\"{}\", v));\n+\n+    // Should trigger this lint: BTreeSet.\n+    let btree_set: BTreeSet<i32> = BTreeSet::new();\n+    btree_set.iter().for_each(|v| println!(\"{}\", v));\n+\n+    // Should trigger this lint: BinaryHeap.\n+    let binary_heap: BinaryHeap<i32> = BinaryHeap::new();\n+    binary_heap.iter().for_each(|v| println!(\"{}\", v));\n+\n+    // Should trigger this lint: Array.\n+    let s = [1, 2, 3];\n+    s.iter().for_each(|v| println!(\"{}\", v));\n+\n+    // Should trigger this lint. Slice.\n+    vec.as_slice().iter().for_each(|v| println!(\"{}\", v));\n+\n+    // Should trigger this lint with notes that say \"change `return` to `continue`\".\n+    vec.iter().for_each(|v| {\n+        if *v == 10 {\n+            return;\n+        } else {\n+            println!(\"{}\", v);\n+        }\n+    });\n+\n+    // Should trigger this lint with notes that say \"change `return` to `continue 'outer`\".\n+    vec.iter().for_each(|v| {\n+        for i in 0..*v {\n+            if i == 10 {\n+                return;\n+            } else {\n+                println!(\"{}\", v);\n+            }\n+        }\n+        if *v == 20 {\n+            return;\n+        } else {\n+            println!(\"{}\", v);\n+        }\n+    });\n+\n+    // Should NOT trigger this lint in case `for_each` follows long iterator chain.\n+    vec.iter().chain(vec.iter()).for_each(|v| println!(\"{}\", v));\n+\n+    // Should NOT trigger this lint in case a `for_each` argument is not closure.\n+    fn print(x: &i32) {\n+        println!(\"{}\", x);\n+    }\n+    vec.iter().for_each(print);\n+\n+    // Should NOT trigger this lint in case the receiver of `iter` is a user defined type.\n+    let my_collection = MyCollection { v: vec![] };\n+    my_collection.iter().for_each(|v| println!(\"{}\", v));\n+}\n+\n+struct MyCollection {\n+    v: Vec<i32>,\n+}\n+\n+impl MyCollection {\n+    fn iter(&self) -> impl Iterator<Item = &i32> {\n+        self.v.iter()\n+    }\n+}"}, {"sha": "026b14a58991a231587a7f2343811276861f261f", "filename": "tests/ui/excessive_for_each.stderr", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/5029dc805fa1b8c58988cad119a45a6d51bcdaad/tests%2Fui%2Fexcessive_for_each.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5029dc805fa1b8c58988cad119a45a6d51bcdaad/tests%2Fui%2Fexcessive_for_each.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexcessive_for_each.stderr?ref=5029dc805fa1b8c58988cad119a45a6d51bcdaad", "patch": "@@ -0,0 +1,123 @@\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:9:5\n+   |\n+LL |     vec.iter().for_each(|v| println!(\"{}\", v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for v in vec.iter() { .. }`\n+   |\n+   = note: `-D clippy::excessive-for-each` implied by `-D warnings`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:13:5\n+   |\n+LL |     vec_ref.iter().for_each(|v| println!(\"{}\", v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for v in vec_ref.iter() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:17:5\n+   |\n+LL |     vec_deq.iter().for_each(|v| println!(\"{}\", v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for v in vec_deq.iter() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:21:5\n+   |\n+LL |     list.iter().for_each(|v| println!(\"{}\", v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for v in list.iter() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:25:5\n+   |\n+LL |     hash_map.iter().for_each(|(k, v)| println!(\"{}: {}\", k, v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for (k, v) in hash_map.iter() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:26:5\n+   |\n+LL |     hash_map.iter_mut().for_each(|(k, v)| println!(\"{}: {}\", k, v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for (k, v) in hash_map.iter_mut() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:27:5\n+   |\n+LL |     hash_map.keys().for_each(|k| println!(\"{}\", k));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for k in hash_map.keys() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:28:5\n+   |\n+LL |     hash_map.values().for_each(|v| println!(\"{}\", v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for v in hash_map.values() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:32:5\n+   |\n+LL |     hash_set.iter().for_each(|v| println!(\"{}\", v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for v in hash_set.iter() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:36:5\n+   |\n+LL |     btree_set.iter().for_each(|v| println!(\"{}\", v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for v in btree_set.iter() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:40:5\n+   |\n+LL |     binary_heap.iter().for_each(|v| println!(\"{}\", v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for v in binary_heap.iter() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:44:5\n+   |\n+LL |     s.iter().for_each(|v| println!(\"{}\", v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for v in s.iter() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:47:5\n+   |\n+LL |     vec.as_slice().iter().for_each(|v| println!(\"{}\", v));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `for v in vec.as_slice().iter() { .. }`\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:50:5\n+   |\n+LL | /     vec.iter().for_each(|v| {\n+LL | |         if *v == 10 {\n+LL | |             return;\n+LL | |         } else {\n+LL | |             println!(\"{}\", v);\n+LL | |         }\n+LL | |     });\n+   | |______^ help: try: `for v in vec.iter() { .. }`\n+   |\n+note: change `return` to `continue` in the loop body\n+  --> $DIR/excessive_for_each.rs:52:13\n+   |\n+LL |             return;\n+   |             ^^^^^^\n+\n+error: excessive use of `for_each`\n+  --> $DIR/excessive_for_each.rs:59:5\n+   |\n+LL | /     vec.iter().for_each(|v| {\n+LL | |         for i in 0..*v {\n+LL | |             if i == 10 {\n+LL | |                 return;\n+...  |\n+LL | |         }\n+LL | |     });\n+   | |______^ help: try: `'outer: for v in vec.iter() { .. }`\n+   |\n+note: change `return` to `continue 'outer` in the loop body\n+  --> $DIR/excessive_for_each.rs:62:17\n+   |\n+LL |                 return;\n+   |                 ^^^^^^\n+note: change `return` to `continue` in the loop body\n+  --> $DIR/excessive_for_each.rs:68:13\n+   |\n+LL |             return;\n+   |             ^^^^^^\n+\n+error: aborting due to 15 previous errors\n+"}]}