{"sha": "7b36047239f50df16e6dbd1ab0ca8575e7db1a55", "node_id": "C_kwDOAAsO6NoAKDdiMzYwNDcyMzlmNTBkZjE2ZTZkYmQxYWIwY2E4NTc1ZTdkYjFhNTU", "commit": {"author": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2022-07-06T00:42:39Z"}, "committer": {"name": "Eric Huss", "email": "eric@huss.org", "date": "2022-08-12T04:48:39Z"}, "message": "Make Node::ExprField a child of Node::Expr.\n\nThis was incorrectly inserting the ExprField as a sibling of the struct\nexpression.\n\nThis required adjusting various parts which were looking at parent node\nof a field expression to find the struct.", "tree": {"sha": "ae336c76d2a17514dba4530659057041068282ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae336c76d2a17514dba4530659057041068282ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b36047239f50df16e6dbd1ab0ca8575e7db1a55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b36047239f50df16e6dbd1ab0ca8575e7db1a55", "html_url": "https://github.com/rust-lang/rust/commit/7b36047239f50df16e6dbd1ab0ca8575e7db1a55", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/comments", "author": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ehuss", "id": 43198, "node_id": "MDQ6VXNlcjQzMTk4", "avatar_url": "https://avatars.githubusercontent.com/u/43198?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ehuss", "html_url": "https://github.com/ehuss", "followers_url": "https://api.github.com/users/ehuss/followers", "following_url": "https://api.github.com/users/ehuss/following{/other_user}", "gists_url": "https://api.github.com/users/ehuss/gists{/gist_id}", "starred_url": "https://api.github.com/users/ehuss/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ehuss/subscriptions", "organizations_url": "https://api.github.com/users/ehuss/orgs", "repos_url": "https://api.github.com/users/ehuss/repos", "events_url": "https://api.github.com/users/ehuss/events{/privacy}", "received_events_url": "https://api.github.com/users/ehuss/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcd5177fd43d5fdd9b89a7700fe3c283a9a52a48", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd5177fd43d5fdd9b89a7700fe3c283a9a52a48", "html_url": "https://github.com/rust-lang/rust/commit/dcd5177fd43d5fdd9b89a7700fe3c283a9a52a48"}], "stats": {"total": 287, "additions": 139, "deletions": 148}, "files": [{"sha": "2b7431f0990570a004902099db789a36f65cd989", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=7b36047239f50df16e6dbd1ab0ca8575e7db1a55", "patch": "@@ -226,17 +226,19 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_expr(&mut self, expr: &'hir Expr<'hir>) {\n         self.insert(expr.span, expr.hir_id, Node::Expr(expr));\n-        if let ExprKind::Struct(_, fields, _) = expr.kind {\n-            for field in fields {\n-                self.insert(field.span, field.hir_id, Node::ExprField(field));\n-            }\n-        }\n \n         self.with_parent(expr.hir_id, |this| {\n             intravisit::walk_expr(this, expr);\n         });\n     }\n \n+    fn visit_expr_field(&mut self, field: &'hir ExprField<'hir>) {\n+        self.insert(field.span, field.hir_id, Node::ExprField(field));\n+        self.with_parent(field.hir_id, |this| {\n+            intravisit::walk_expr_field(this, field);\n+        });\n+    }\n+\n     fn visit_stmt(&mut self, stmt: &'hir Stmt<'hir>) {\n         self.insert(stmt.span, stmt.hir_id, Node::Stmt(stmt));\n "}, {"sha": "cafd2c6e679949d5150102e02e452d706a408e35", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 47, "deletions": 51, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=7b36047239f50df16e6dbd1ab0ca8575e7db1a55", "patch": "@@ -125,45 +125,51 @@ fn lint_overflowing_range_endpoint<'tcx>(\n     lit_val: u128,\n     max: u128,\n     expr: &'tcx hir::Expr<'tcx>,\n-    parent_expr: &'tcx hir::Expr<'tcx>,\n     ty: &str,\n ) -> bool {\n     // We only want to handle exclusive (`..`) ranges,\n     // which are represented as `ExprKind::Struct`.\n+    let par_id = cx.tcx.hir().get_parent_node(expr.hir_id);\n+    let Node::ExprField(field) = cx.tcx.hir().get(par_id) else { return false };\n+    let field_par_id = cx.tcx.hir().get_parent_node(field.hir_id);\n+    let Node::Expr(struct_expr) = cx.tcx.hir().get(field_par_id) else { return false };\n+    if !is_range_literal(struct_expr) {\n+        return false;\n+    };\n+    let ExprKind::Struct(_, eps, _) = &struct_expr.kind else { return false };\n+    if eps.len() != 2 {\n+        return false;\n+    }\n+\n     let mut overwritten = false;\n-    if let ExprKind::Struct(_, eps, _) = &parent_expr.kind {\n-        if eps.len() != 2 {\n-            return false;\n-        }\n-        // We can suggest using an inclusive range\n-        // (`..=`) instead only if it is the `end` that is\n-        // overflowing and only by 1.\n-        if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n-            cx.struct_span_lint(OVERFLOWING_LITERALS, parent_expr.span, |lint| {\n-                let mut err = lint.build(fluent::lint::range_endpoint_out_of_range);\n-                err.set_arg(\"ty\", ty);\n-                if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n-                    use ast::{LitIntType, LitKind};\n-                    // We need to preserve the literal's suffix,\n-                    // as it may determine typing information.\n-                    let suffix = match lit.node {\n-                        LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n-                        LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n-                        LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n-                        _ => bug!(),\n-                    };\n-                    let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n-                    err.span_suggestion(\n-                        parent_expr.span,\n-                        fluent::lint::suggestion,\n-                        suggestion,\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n-                    overwritten = true;\n-                }\n-            });\n-        }\n+    // We can suggest using an inclusive range\n+    // (`..=`) instead only if it is the `end` that is\n+    // overflowing and only by 1.\n+    if eps[1].expr.hir_id == expr.hir_id && lit_val - 1 == max {\n+        cx.struct_span_lint(OVERFLOWING_LITERALS, struct_expr.span, |lint| {\n+            let mut err = lint.build(fluent::lint::range_endpoint_out_of_range);\n+            err.set_arg(\"ty\", ty);\n+            if let Ok(start) = cx.sess().source_map().span_to_snippet(eps[0].span) {\n+                use ast::{LitIntType, LitKind};\n+                // We need to preserve the literal's suffix,\n+                // as it may determine typing information.\n+                let suffix = match lit.node {\n+                    LitKind::Int(_, LitIntType::Signed(s)) => s.name_str(),\n+                    LitKind::Int(_, LitIntType::Unsigned(s)) => s.name_str(),\n+                    LitKind::Int(_, LitIntType::Unsuffixed) => \"\",\n+                    _ => bug!(),\n+                };\n+                let suggestion = format!(\"{}..={}{}\", start, lit_val - 1, suffix);\n+                err.span_suggestion(\n+                    struct_expr.span,\n+                    fluent::lint::suggestion,\n+                    suggestion,\n+                    Applicability::MachineApplicable,\n+                );\n+                err.emit();\n+                overwritten = true;\n+            }\n+        });\n     }\n     overwritten\n }\n@@ -339,16 +345,9 @@ fn lint_int_literal<'tcx>(\n             return;\n         }\n \n-        let par_id = cx.tcx.hir().get_parent_node(e.hir_id);\n-        if let Node::Expr(par_e) = cx.tcx.hir().get(par_id) {\n-            if let hir::ExprKind::Struct(..) = par_e.kind {\n-                if is_range_literal(par_e)\n-                    && lint_overflowing_range_endpoint(cx, lit, v, max, e, par_e, t.name_str())\n-                {\n-                    // The overflowing literal lint was overridden.\n-                    return;\n-                }\n-            }\n+        if lint_overflowing_range_endpoint(cx, lit, v, max, e, t.name_str()) {\n+            // The overflowing literal lint was overridden.\n+            return;\n         }\n \n         cx.struct_span_lint(OVERFLOWING_LITERALS, e.span, |lint| {\n@@ -408,16 +407,13 @@ fn lint_uint_literal<'tcx>(\n                         return;\n                     }\n                 }\n-                hir::ExprKind::Struct(..) if is_range_literal(par_e) => {\n-                    let t = t.name_str();\n-                    if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, par_e, t) {\n-                        // The overflowing literal lint was overridden.\n-                        return;\n-                    }\n-                }\n                 _ => {}\n             }\n         }\n+        if lint_overflowing_range_endpoint(cx, lit, lit_val, max, e, t.name_str()) {\n+            // The overflowing literal lint was overridden.\n+            return;\n+        }\n         if let Some(repr_str) = get_bin_hex_repr(cx, lit) {\n             report_bin_hex_error(\n                 cx,"}, {"sha": "07046f3f0326b119185f836728bd3bf49df39873", "filename": "compiler/rustc_typeck/src/check/demand.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdemand.rs?ref=7b36047239f50df16e6dbd1ab0ca8575e7db1a55", "patch": "@@ -638,11 +638,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }?;\n \n         match hir.find(hir.get_parent_node(expr.hir_id))? {\n-            Node::Expr(hir::Expr { kind: hir::ExprKind::Struct(_, fields, ..), .. }) => {\n-                for field in *fields {\n-                    if field.ident.name == local.name && field.is_shorthand {\n-                        return Some(local.name);\n-                    }\n+            Node::ExprField(field) => {\n+                if field.ident.name == local.name && field.is_shorthand {\n+                    return Some(local.name);\n                 }\n             }\n             _ => {}\n@@ -1073,21 +1071,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         let mut sugg = vec![];\n \n-        if let Some(hir::Node::Expr(hir::Expr {\n-            kind: hir::ExprKind::Struct(_, fields, _), ..\n-        })) = self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n+        if let Some(hir::Node::ExprField(field)) =\n+            self.tcx.hir().find(self.tcx.hir().get_parent_node(expr.hir_id))\n         {\n             // `expr` is a literal field for a struct, only suggest if appropriate\n-            match (*fields)\n-                .iter()\n-                .find(|field| field.expr.hir_id == expr.hir_id && field.is_shorthand)\n-            {\n+            if field.is_shorthand {\n                 // This is a field literal\n-                Some(field) => {\n-                    sugg.push((field.ident.span.shrink_to_lo(), format!(\"{}: \", field.ident)));\n-                }\n+                sugg.push((field.ident.span.shrink_to_lo(), format!(\"{}: \", field.ident)));\n+            } else {\n                 // Likely a field was meant, but this field wasn't found. Do not suggest anything.\n-                None => return false,\n+                return false;\n             }\n         };\n "}, {"sha": "9b54b033c88afd1d2d64813ee1a1cfa078198e39", "filename": "src/test/ui/lint/lint-attr-everywhere-early.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-early.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-early.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-early.stderr?ref=7b36047239f50df16e6dbd1ab0ca8575e7db1a55", "patch": "@@ -25,7 +25,7 @@ help: remove these parentheses\n    |\n LL - type BareFnPtr = fn(#[deny(unused_parens)](i32));\n LL + type BareFnPtr = fn(#[deny(unused_parens)]i32);\n-   | \n+   |\n \n error: type `ITEM_OUTER` should have an upper camel case name\n   --> $DIR/lint-attr-everywhere-early.rs:30:8\n@@ -198,7 +198,7 @@ help: remove these parentheses\n    |\n LL -     type assoc_type = (i32);\n LL +     type assoc_type = i32;\n-   | \n+   |\n \n error: unnecessary parentheses around type\n   --> $DIR/lint-attr-everywhere-early.rs:87:31\n@@ -215,7 +215,7 @@ help: remove these parentheses\n    |\n LL -     #[deny(unused_parens)]f1: (i32),\n LL +     #[deny(unused_parens)]f1: i32,\n-   | \n+   |\n \n error: unnecessary parentheses around type\n   --> $DIR/lint-attr-everywhere-early.rs:89:42\n@@ -232,7 +232,7 @@ help: remove these parentheses\n    |\n LL - struct StructTuple(#[deny(unused_parens)](i32));\n LL + struct StructTuple(#[deny(unused_parens)]i32);\n-   | \n+   |\n \n error: variant `VARIANT_CAMEL` should have an upper camel case name\n   --> $DIR/lint-attr-everywhere-early.rs:93:5\n@@ -261,7 +261,7 @@ help: remove these parentheses\n    |\n LL -     fn foreign_denied_from_inner(x: (i32));\n LL +     fn foreign_denied_from_inner(x: i32);\n-   | \n+   |\n \n error: unnecessary parentheses around type\n   --> $DIR/lint-attr-everywhere-early.rs:104:37\n@@ -278,7 +278,7 @@ help: remove these parentheses\n    |\n LL -     fn foreign_denied_from_outer(x: (i32));\n LL +     fn foreign_denied_from_outer(x: i32);\n-   | \n+   |\n \n error: unnecessary parentheses around type\n   --> $DIR/lint-attr-everywhere-early.rs:107:43\n@@ -295,7 +295,7 @@ help: remove these parentheses\n    |\n LL - fn function(#[deny(unused_parens)] param: (i32)) {}\n LL + fn function(#[deny(unused_parens)] param: i32) {}\n-   | \n+   |\n \n error: type parameter `foo` should have an upper camel case name\n   --> $DIR/lint-attr-everywhere-early.rs:109:42\n@@ -324,7 +324,7 @@ help: remove these parentheses\n    |\n LL -     let x = (1);\n LL +     let x = 1;\n-   | \n+   |\n \n error: unnecessary parentheses around type\n   --> $DIR/lint-attr-everywhere-early.rs:121:50\n@@ -341,7 +341,7 @@ help: remove these parentheses\n    |\n LL -     let closure = |#[deny(unused_parens)] param: (i32)| {};\n LL +     let closure = |#[deny(unused_parens)] param: i32| {};\n-   | \n+   |\n \n error: unnecessary parentheses around block return value\n   --> $DIR/lint-attr-everywhere-early.rs:125:46\n@@ -358,7 +358,7 @@ help: remove these parentheses\n    |\n LL -     let f = Match{#[deny(unused_parens)]f1: {(123)}};\n LL +     let f = Match{#[deny(unused_parens)]f1: {123}};\n-   | \n+   |\n \n error: usage of an `unsafe` block\n   --> $DIR/lint-attr-everywhere-early.rs:132:13"}, {"sha": "977843997c6dca6ff2a4dcb96e8f502581747161", "filename": "src/test/ui/lint/lint-attr-everywhere-late.stderr", "status": "modified", "additions": 66, "deletions": 66, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-late.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b36047239f50df16e6dbd1ab0ca8575e7db1a55/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-late.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-attr-everywhere-late.stderr?ref=7b36047239f50df16e6dbd1ab0ca8575e7db1a55", "patch": "@@ -142,35 +142,6 @@ note: the lint level is defined here\n LL |     #[deny(missing_docs)]\n    |            ^^^^^^^^^^^^\n \n-error: types that do not implement `Drop` can still have drop glue, consider instead using `std::mem::needs_drop` to detect whether a type is trivially dropped\n-  --> $DIR/lint-attr-everywhere-late.rs:93:38\n-   |\n-LL |     fn denied_from_inner(_x: Box<dyn Drop>) {}\n-   |                                      ^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:91:13\n-   |\n-LL |     #![deny(dyn_drop)]\n-   |             ^^^^^^^^\n-\n-error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n-  --> $DIR/lint-attr-everywhere-late.rs:96:21\n-   |\n-LL |     fn assoc_fn() { discriminant::<i32>(&123); }\n-   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:95:12\n-   |\n-LL |     #[deny(enum_intrinsics_non_enums)]\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n-  --> $DIR/lint-attr-everywhere-late.rs:96:41\n-   |\n-LL |     fn assoc_fn() { discriminant::<i32>(&123); }\n-   |                                         ^^^^\n-\n error: missing documentation for a variant\n   --> $DIR/lint-attr-everywhere-late.rs:112:5\n    |\n@@ -217,6 +188,60 @@ LL |     #[deny(clashing_extern_declarations)]\n    = note: expected `unsafe extern \"C\" fn()`\n               found `unsafe extern \"C\" fn(i32)`\n \n+error: types that do not implement `Drop` can still have drop glue, consider instead using `std::mem::needs_drop` to detect whether a type is trivially dropped\n+  --> $DIR/lint-attr-everywhere-late.rs:93:38\n+   |\n+LL |     fn denied_from_inner(_x: Box<dyn Drop>) {}\n+   |                                      ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:91:13\n+   |\n+LL |     #![deny(dyn_drop)]\n+   |             ^^^^^^^^\n+\n+error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n+  --> $DIR/lint-attr-everywhere-late.rs:96:21\n+   |\n+LL |     fn assoc_fn() { discriminant::<i32>(&123); }\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:95:12\n+   |\n+LL |     #[deny(enum_intrinsics_non_enums)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^\n+note: the argument to `discriminant` should be a reference to an enum, but it was passed a reference to a `i32`, which is not an enum.\n+  --> $DIR/lint-attr-everywhere-late.rs:96:41\n+   |\n+LL |     fn assoc_fn() { discriminant::<i32>(&123); }\n+   |                                         ^^^^\n+\n+error: literal out of range for `u8`\n+  --> $DIR/lint-attr-everywhere-late.rs:98:59\n+   |\n+LL |     #[deny(overflowing_literals)] const ASSOC_CONST: u8 = 1000;\n+   |                                                           ^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:98:12\n+   |\n+LL |     #[deny(overflowing_literals)] const ASSOC_CONST: u8 = 1000;\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   = note: the literal `1000` does not fit into the type `u8` whose range is `0..=255`\n+\n+error: variable `PARAM` should have a snake case name\n+  --> $DIR/lint-attr-everywhere-late.rs:131:37\n+   |\n+LL | fn function(#[deny(non_snake_case)] PARAM: i32) {}\n+   |                                     ^^^^^ help: convert the identifier to snake case: `param`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:131:20\n+   |\n+LL | fn function(#[deny(non_snake_case)] PARAM: i32) {}\n+   |                    ^^^^^^^^^^^^^^\n+\n error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n   --> $DIR/lint-attr-everywhere-late.rs:139:13\n    |\n@@ -234,6 +259,18 @@ note: the argument to `discriminant` should be a reference to an enum, but it wa\n LL |     let _ = discriminant::<i32>(&123);\n    |                                 ^^^^\n \n+error: variable `PARAM` should have a snake case name\n+  --> $DIR/lint-attr-everywhere-late.rs:145:44\n+   |\n+LL |     let closure = |#[deny(non_snake_case)] PARAM: i32| {};\n+   |                                            ^^^^^ help: convert the identifier to snake case: `param`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/lint-attr-everywhere-late.rs:145:27\n+   |\n+LL |     let closure = |#[deny(non_snake_case)] PARAM: i32| {};\n+   |                           ^^^^^^^^^^^^^^\n+\n error: the return value of `mem::discriminant` is unspecified when called with a non-enum type\n   --> $DIR/lint-attr-everywhere-late.rs:155:13\n    |\n@@ -387,42 +424,5 @@ note: the argument to `discriminant` should be a reference to an enum, but it wa\n LL |     TupleStruct(#[deny(enum_intrinsics_non_enums)] discriminant::<i32>(&123));\n    |                                                                        ^^^^\n \n-error: literal out of range for `u8`\n-  --> $DIR/lint-attr-everywhere-late.rs:98:59\n-   |\n-LL |     #[deny(overflowing_literals)] const ASSOC_CONST: u8 = 1000;\n-   |                                                           ^^^^\n-   |\n-note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:98:12\n-   |\n-LL |     #[deny(overflowing_literals)] const ASSOC_CONST: u8 = 1000;\n-   |            ^^^^^^^^^^^^^^^^^^^^\n-   = note: the literal `1000` does not fit into the type `u8` whose range is `0..=255`\n-\n-error: variable `PARAM` should have a snake case name\n-  --> $DIR/lint-attr-everywhere-late.rs:131:37\n-   |\n-LL | fn function(#[deny(non_snake_case)] PARAM: i32) {}\n-   |                                     ^^^^^ help: convert the identifier to snake case: `param`\n-   |\n-note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:131:20\n-   |\n-LL | fn function(#[deny(non_snake_case)] PARAM: i32) {}\n-   |                    ^^^^^^^^^^^^^^\n-\n-error: variable `PARAM` should have a snake case name\n-  --> $DIR/lint-attr-everywhere-late.rs:145:44\n-   |\n-LL |     let closure = |#[deny(non_snake_case)] PARAM: i32| {};\n-   |                                            ^^^^^ help: convert the identifier to snake case: `param`\n-   |\n-note: the lint level is defined here\n-  --> $DIR/lint-attr-everywhere-late.rs:145:27\n-   |\n-LL |     let closure = |#[deny(non_snake_case)] PARAM: i32| {};\n-   |                           ^^^^^^^^^^^^^^\n-\n error: aborting due to 31 previous errors\n "}]}