{"sha": "a9bea1f52b09a66a04548b8e2b959245562db229", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5YmVhMWY1MmIwOWE2NmEwNDU0OGI4ZTJiOTU5MjQ1NTYyZGIyMjk=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-12T17:11:13Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-05-12T19:22:38Z"}, "message": "Rustup to *1.10.0-nightly (22ac88f1a 2016-05-11)*", "tree": {"sha": "a756f10633dcec21e3f3a1d72e4b13fe99b4be07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a756f10633dcec21e3f3a1d72e4b13fe99b4be07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9bea1f52b09a66a04548b8e2b959245562db229", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v2\n\niQIcBAABCAAGBQJXNNgAAAoJEF5CfHlMukXoIicP/2n5GEcTlLMYpBlKoBfB7gSp\neVXVQElbMqNKH6uy6Qo7FTPgp5VZbVJB0Zqj9TIcz/LOebH8XP/Vti4nH68dccLo\nFp6JLSObSRcuOfo/f+YHbdODuxwUzMlgXUf99FMpWNPjT5kDPIYkmLPm6eYpcE76\nVPi+1dbUYFe2CR4ok3R/RS/clEcJn3fBZIEO0ghckSHwZbzuT38pAFy4kqge23re\npoWHSPz1NV/jrxoMONSAXO+WpG2Yqq+MxryKwBt9lhgiOYMTAwxsGG31jRkIHeqB\nvnIAZ0dD+7s1d6Mk0/TI0oXnp6FrolHYlG0P60HQ/fUKS2U7HoJJmc7Mwcv1gYnk\nSWkITFTMdQbl6gYKc9sbs2Gon8uHWWRvoqrO4J8heewCaC8tglOWEHVABqYLG5xU\nY66buV7o1I84jSOl16tChicvwIORttKrLM14Bl/0umCiJyqKpDWsh/0OY5tyf//a\nfzHwpWgkgbzuwgZgbI3p6C1ue+hg4wcHLNwHM+1dD3XZ3oBy/iz5iJpW6YtuiLk0\netECnY7uRs8n962TWtrUi08MkgG3/9U3yFUEbDYmqVvp+S8p2tqjGIuUQe1QNMtn\nrMHZ5vxaT0P+eDqTfeh2K1vVBNijOy6dtBsO+adNXpMlVHYTsbmkoDSqNiKmdN98\n5c3t8kO4Hc5IXE786H72\n=PLdw\n-----END PGP SIGNATURE-----", "payload": "tree a756f10633dcec21e3f3a1d72e4b13fe99b4be07\nparent fe6ad91767ef531b49690d88871c09b43cfb13ed\nauthor mcarton <cartonmartin+git@gmail.com> 1463073073 +0200\ncommitter mcarton <cartonmartin+git@gmail.com> 1463080958 +0200\n\nRustup to *1.10.0-nightly (22ac88f1a 2016-05-11)*\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9bea1f52b09a66a04548b8e2b959245562db229", "html_url": "https://github.com/rust-lang/rust/commit/a9bea1f52b09a66a04548b8e2b959245562db229", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9bea1f52b09a66a04548b8e2b959245562db229/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe6ad91767ef531b49690d88871c09b43cfb13ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe6ad91767ef531b49690d88871c09b43cfb13ed", "html_url": "https://github.com/rust-lang/rust/commit/fe6ad91767ef531b49690d88871c09b43cfb13ed"}], "stats": {"total": 83, "additions": 40, "deletions": 43}, "files": [{"sha": "0cf62633de4e070274f367de195c8e383f9cc118", "filename": "src/attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fattrs.rs?ref=a9bea1f52b09a66a04548b8e2b959245562db229", "patch": "@@ -130,7 +130,7 @@ fn is_relevant_expr(expr: &Expr) -> bool {\n         ExprRet(None) | ExprBreak(_) => false,\n         ExprCall(ref path_expr, _) => {\n             if let ExprPath(_, ref path) = path_expr.node {\n-                !match_path(path, &paths::BEGIN_UNWIND)\n+                !match_path(path, &paths::BEGIN_PANIC)\n             } else {\n                 true\n             }"}, {"sha": "8ae0d2c97c50f5eb5d2b1fcf689bf503a41183e1", "filename": "src/cyclomatic_complexity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcyclomatic_complexity.rs?ref=a9bea1f52b09a66a04548b8e2b959245562db229", "patch": "@@ -58,7 +58,7 @@ impl CyclomaticComplexity {\n             divergence: 0,\n             short_circuits: 0,\n             returns: 0,\n-            tcx: cx.tcx,\n+            tcx: &cx.tcx,\n         };\n         helper.visit_block(block);\n         let CCHelper { match_arms, divergence, short_circuits, returns, .. } = helper;\n@@ -117,15 +117,15 @@ impl LateLintPass for CyclomaticComplexity {\n     }\n }\n \n-struct CCHelper<'a, 'tcx: 'a> {\n+struct CCHelper<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     match_arms: u64,\n     divergence: u64,\n     returns: u64,\n     short_circuits: u64, // && and ||\n-    tcx: &'a ty::TyCtxt<'tcx>,\n+    tcx: &'a ty::TyCtxt<'a, 'gcx, 'tcx>,\n }\n \n-impl<'a, 'b, 'tcx> Visitor<'a> for CCHelper<'b, 'tcx> {\n+impl<'a, 'b, 'tcx, 'gcx> Visitor<'a> for CCHelper<'b, 'gcx, 'tcx> {\n     fn visit_expr(&mut self, e: &'a Expr) {\n         match e.node {\n             ExprMatch(_, ref arms, _) => {"}, {"sha": "f08522953aa641599dd697e74dfb0d9716e7fae2", "filename": "src/derive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fderive.rs?ref=a9bea1f52b09a66a04548b8e2b959245562db229", "patch": "@@ -86,15 +86,15 @@ impl LateLintPass for Derive {\n }\n \n /// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n-fn check_hash_peq<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>, hash_is_automatically_derived: bool) {\n+fn check_hash_peq<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>, hash_is_automatically_derived: bool) {\n     if_let_chain! {[\n         match_path(&trait_ref.path, &paths::HASH),\n         let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n     ], {\n         let peq_trait_def = cx.tcx.lookup_trait_def(peq_trait_def_id);\n \n         // Look for the PartialEq implementations for `ty`\n-        peq_trait_def.for_each_relevant_impl(&cx.tcx, ty, |impl_id| {\n+        peq_trait_def.for_each_relevant_impl(cx.tcx, ty, |impl_id| {\n             let peq_is_automatically_derived = cx.tcx.get_attrs(impl_id).iter().any(is_automatically_derived);\n \n             if peq_is_automatically_derived == hash_is_automatically_derived {\n@@ -131,9 +131,9 @@ fn check_hash_peq<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &\n fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n     if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n         let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n-        let subst_ty = ty.subst(cx.tcx, &parameter_environment.free_substs);\n+        let subst_ty = ty.subst(cx.tcx, parameter_environment.free_substs);\n \n-        if subst_ty.moves_by_default(&parameter_environment, item.span) {\n+        if subst_ty.moves_by_default(cx.tcx.global_tcx(), &parameter_environment, item.span) {\n             return; // ty is not Copy\n         }\n "}, {"sha": "b5172269a1e96bc806bf789967550d9092b046fd", "filename": "src/escape.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fescape.rs?ref=a9bea1f52b09a66a04548b8e2b959245562db229", "patch": "@@ -1,11 +1,9 @@\n use rustc::hir::*;\n use rustc::hir::intravisit as visit;\n use rustc::hir::map::Node::{NodeExpr, NodeStmt};\n-use rustc::infer;\n use rustc::lint::*;\n use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt, Categorization};\n-use rustc::traits::ProjectionMode;\n use rustc::ty::adjustment::AutoAdjustment;\n use rustc::ty;\n use rustc::util::nodemap::NodeSet;\n@@ -42,7 +40,7 @@ fn is_non_trait_box(ty: ty::Ty) -> bool {\n }\n \n struct EscapeDelegate<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>,\n+    tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     set: NodeSet,\n }\n \n@@ -55,15 +53,18 @@ impl LintPass for EscapePass {\n impl LateLintPass for EscapePass {\n     fn check_fn(&mut self, cx: &LateContext, _: visit::FnKind, decl: &FnDecl, body: &Block, _: Span, id: NodeId) {\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n-        let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, Some(param_env), ProjectionMode::Any);\n+\n+        let infcx = cx.tcx.borrowck_fake_infer_ctxt(param_env);\n         let mut v = EscapeDelegate {\n-            cx: cx,\n+            tcx: cx.tcx,\n             set: NodeSet(),\n         };\n+\n         {\n             let mut vis = ExprUseVisitor::new(&mut v, &infcx);\n             vis.walk_fn(decl, body);\n         }\n+\n         for node in v.set {\n             span_lint(cx,\n                       BOXED_LOCAL,\n@@ -75,7 +76,6 @@ impl LateLintPass for EscapePass {\n \n impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     fn consume(&mut self, _: NodeId, _: Span, cmt: cmt<'tcx>, mode: ConsumeMode) {\n-\n         if let Categorization::Local(lid) = cmt.cat {\n             if self.set.contains(&lid) {\n                 if let Move(DirectRefMove) = mode {\n@@ -87,7 +87,7 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     }\n     fn matched_pat(&mut self, _: &Pat, _: cmt<'tcx>, _: MatchMode) {}\n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: cmt<'tcx>, _: ConsumeMode) {\n-        let map = &self.cx.tcx.map;\n+        let map = &self.tcx.map;\n         if map.is_argument(consume_pat.id) {\n             // Skip closure arguments\n             if let Some(NodeExpr(..)) = map.find(map.get_parent_node(consume_pat.id)) {\n@@ -132,8 +132,7 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n \n         if let Categorization::Local(lid) = cmt.cat {\n             if self.set.contains(&lid) {\n-                if let Some(&AutoAdjustment::AdjustDerefRef(adj)) = self.cx\n-                                                                        .tcx\n+                if let Some(&AutoAdjustment::AdjustDerefRef(adj)) = self.tcx\n                                                                         .tables\n                                                                         .borrow()\n                                                                         .adjustments\n@@ -148,13 +147,11 @@ impl<'a, 'tcx: 'a> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                     }\n                 } else if LoanCause::AddrOf == loan_cause {\n                     // &x\n-                    if let Some(&AutoAdjustment::AdjustDerefRef(adj)) = self.cx\n-                                                                            .tcx\n+                    if let Some(&AutoAdjustment::AdjustDerefRef(adj)) = self.tcx\n                                                                             .tables\n                                                                             .borrow()\n                                                                             .adjustments\n-                                                                            .get(&self.cx\n-                                                                                      .tcx\n+                                                                            .get(&self.tcx\n                                                                                       .map\n                                                                                       .get_parent_node(borrow_id)) {\n                         if adj.autoderefs <= 1 {"}, {"sha": "c4ea1868d33d0ee5fd2c0384bd90d2226bf6969f", "filename": "src/methods.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=a9bea1f52b09a66a04548b8e2b959245562db229", "patch": "@@ -560,7 +560,7 @@ fn lint_clone_on_copy(cx: &LateContext, expr: &Expr) {\n     let parent = cx.tcx.map.get_parent(expr.id);\n     let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, parent);\n \n-    if !ty.moves_by_default(&parameter_environment, expr.span) {\n+    if !ty.moves_by_default(cx.tcx.global_tcx(), &parameter_environment, expr.span) {\n         span_lint(cx, CLONE_ON_COPY, expr.span, \"using `clone` on a `Copy` type\");\n     }\n }\n@@ -1044,5 +1044,5 @@ fn is_bool(ty: &Ty) -> bool {\n \n fn is_copy<'a, 'ctx>(cx: &LateContext<'a, 'ctx>, ty: ty::Ty<'ctx>, item: &Item) -> bool {\n     let env = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n-    !ty.subst(cx.tcx, &env.free_substs).moves_by_default(&env, item.span)\n+    !ty.subst(cx.tcx, env.free_substs).moves_by_default(cx.tcx.global_tcx(), &env, item.span)\n }"}, {"sha": "d744d2a6308ae13812bff8d45cd0832ac9cdd5b4", "filename": "src/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpanic.rs?ref=a9bea1f52b09a66a04548b8e2b959245562db229", "patch": "@@ -33,7 +33,7 @@ impl LateLintPass for PanicPass {\n             let ExprCall(ref fun, ref params) = ex.node,\n             params.len() == 2,\n             let ExprPath(None, ref path) = fun.node,\n-            match_path(path, &paths::BEGIN_UNWIND),\n+            match_path(path, &paths::BEGIN_PANIC),\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,"}, {"sha": "0a0c7252eb7696bf1285f16fa7f82e059638c95f", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=a9bea1f52b09a66a04548b8e2b959245562db229", "patch": "@@ -105,7 +105,7 @@ declare_lint! {\n fn check_let_unit(cx: &LateContext, decl: &Decl) {\n     if let DeclLocal(ref local) = decl.node {\n         let bindtype = &cx.tcx.pat_ty(&local.pat).sty;\n-        if *bindtype == ty::TyTuple(vec![]) {\n+        if *bindtype == ty::TyTuple(&[]) {\n             if in_external_macro(cx, decl.span) || in_macro(cx, local.pat.span) {\n                 return;\n             }\n@@ -162,7 +162,7 @@ impl LateLintPass for UnitCmp {\n         if let ExprBinary(ref cmp, ref left, _) = expr.node {\n             let op = cmp.node;\n             let sty = &cx.tcx.expr_ty(left).sty;\n-            if *sty == ty::TyTuple(vec![]) && op.is_comparison() {\n+            if *sty == ty::TyTuple(&[]) && op.is_comparison() {\n                 let result = match op {\n                     BiEq | BiLe | BiGe => \"true\",\n                     _ => \"false\","}, {"sha": "10bfe56e925e3218b47ebcf07a45da8a9b534393", "filename": "src/utils/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=a9bea1f52b09a66a04548b8e2b959245562db229", "patch": "@@ -2,7 +2,6 @@ use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::Node;\n-use rustc::infer;\n use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::middle::cstore;\n use rustc::session::Session;\n@@ -274,15 +273,15 @@ pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>,\n     cx.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n \n     let ty = cx.tcx.erase_regions(&ty);\n-    let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, None, ProjectionMode::Any);\n-    let obligation = traits::predicate_for_trait_def(cx.tcx,\n-                                                     traits::ObligationCause::dummy(),\n-                                                     trait_id,\n-                                                     0,\n-                                                     ty,\n-                                                     ty_params);\n-\n-    traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n+    cx.tcx.infer_ctxt(None, None, ProjectionMode::Any).enter(|infcx| {\n+        let obligation = cx.tcx.predicate_for_trait_def(traits::ObligationCause::dummy(),\n+                                                        trait_id,\n+                                                        0,\n+                                                        ty,\n+                                                        ty_params);\n+\n+        traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n+    })\n }\n \n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n@@ -795,7 +794,7 @@ pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n /// Convenience function to get the return type of a function or `None` if the function diverges.\n pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Option<ty::Ty<'tcx>> {\n     let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_item);\n-    let fn_sig = cx.tcx.node_id_to_type(fn_item).fn_sig().subst(cx.tcx, &parameter_env.free_substs);\n+    let fn_sig = cx.tcx.node_id_to_type(fn_item).fn_sig().subst(cx.tcx, parameter_env.free_substs);\n     let fn_sig = cx.tcx.liberate_late_bound_regions(parameter_env.free_id_outlive, &fn_sig);\n     if let ty::FnConverging(ret_ty) = fn_sig.output {\n         Some(ret_ty)\n@@ -809,10 +808,11 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Optio\n // not for type parameters.\n pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty<'tcx>, parameter_item: NodeId) -> bool {\n     let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, parameter_item);\n-    let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, Some(parameter_env), ProjectionMode::Any);\n-    let new_a = a.subst(infcx.tcx, &infcx.parameter_environment.free_substs);\n-    let new_b = b.subst(infcx.tcx, &infcx.parameter_environment.free_substs);\n-    infcx.can_equate(&new_a, &new_b).is_ok()\n+    cx.tcx.infer_ctxt(None, Some(parameter_env), ProjectionMode::Any).enter(|infcx| {\n+        let new_a = a.subst(infcx.tcx, infcx.parameter_environment.free_substs);\n+        let new_b = b.subst(infcx.tcx, infcx.parameter_environment.free_substs);\n+        infcx.can_equate(&new_a, &new_b).is_ok()\n+    })\n }\n \n /// Recover the essential nodes of a desugared for loop:"}, {"sha": "3db1e1c557293bc543eb875805180952740f70bf", "filename": "src/utils/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9bea1f52b09a66a04548b8e2b959245562db229/src%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fpaths.rs?ref=a9bea1f52b09a66a04548b8e2b959245562db229", "patch": "@@ -1,6 +1,6 @@\n //! This module contains paths to types and functions Clippy needs to know about.\n \n-pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n+pub const BEGIN_PANIC: [&'static str; 3] = [\"std\", \"rt\", \"begin_panic\"];\n pub const BINARY_HEAP: [&'static str; 3] = [\"collections\", \"binary_heap\", \"BinaryHeap\"];\n pub const BOX: [&'static str; 3] = [\"std\", \"boxed\", \"Box\"];\n pub const BOX_NEW: [&'static str; 4] = [\"std\", \"boxed\", \"Box\", \"new\"];"}]}