{"sha": "c358476c1bcb195ad4808605626856691282190d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNTg0NzZjMWJjYjE5NWFkNDgwODYwNTYyNjg1NjY5MTI4MjE5MGQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-08-14T20:56:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-14T20:56:20Z"}, "message": "Rollup merge of #63075 - RalfJung:deref-checks, r=oli-obk\n\nMiri: Check that a ptr is aligned and inbounds already when evaluating `*`\n\nThis syncs Miri with what the Nomicon and the Reference say, and resolves https://github.com/rust-lang/miri/issues/447.\n\nAlso this would not have worked without https://github.com/rust-lang/rust/pull/62982 due to new cycles. ;)\n\nr? @oli-obk", "tree": {"sha": "6a6e5271ef57a646a2fc1fbe17796d2c8c096506", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6a6e5271ef57a646a2fc1fbe17796d2c8c096506"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c358476c1bcb195ad4808605626856691282190d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdVHV0CRBK7hj4Ov3rIwAAdHIIAJ0ZLtT8IHJUIkY8xQOQQ4c4\naXkzhIYzjWTnjaMyp3SZOmEBLU78EIN8caeuMPAB+mAqEDvT3ZkymP7KCkLgtnf2\nfry6kiLX2rbJbUFsJqRLSlJB8+DzqBcKfmCRYYKRdwHEFbayyGK1ORGKP9Bxd2Mz\n2p/E2dhKScGL4v4qWTTworpkd+Z1nEo3FUklEgcIZU3789yp4UsuT2ERLRQUnwCg\nR2KYRG7PnoVSfJYj8DhddS3GZlFI0xc8WLmEs/eQNtZhBqEwlAXs7/u3ArBFHXCW\n1RIJw0oNV/XFzMx5zt4DxbVv0zNGNJ0zzsQ+7T+3HDBe19kwgkbM/xTc9Q6jQXs=\n=NCFy\n-----END PGP SIGNATURE-----\n", "payload": "tree 6a6e5271ef57a646a2fc1fbe17796d2c8c096506\nparent 7178cf5f970a4f32afd260dda4f87223d8a9ba96\nparent 647c0e06365aa4570870e78d3b29c2a8fffc0089\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1565816180 +0200\ncommitter GitHub <noreply@github.com> 1565816180 +0200\n\nRollup merge of #63075 - RalfJung:deref-checks, r=oli-obk\n\nMiri: Check that a ptr is aligned and inbounds already when evaluating `*`\n\nThis syncs Miri with what the Nomicon and the Reference say, and resolves https://github.com/rust-lang/miri/issues/447.\n\nAlso this would not have worked without https://github.com/rust-lang/rust/pull/62982 due to new cycles. ;)\n\nr? @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c358476c1bcb195ad4808605626856691282190d", "html_url": "https://github.com/rust-lang/rust/commit/c358476c1bcb195ad4808605626856691282190d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c358476c1bcb195ad4808605626856691282190d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7178cf5f970a4f32afd260dda4f87223d8a9ba96", "url": "https://api.github.com/repos/rust-lang/rust/commits/7178cf5f970a4f32afd260dda4f87223d8a9ba96", "html_url": "https://github.com/rust-lang/rust/commit/7178cf5f970a4f32afd260dda4f87223d8a9ba96"}, {"sha": "647c0e06365aa4570870e78d3b29c2a8fffc0089", "url": "https://api.github.com/repos/rust-lang/rust/commits/647c0e06365aa4570870e78d3b29c2a8fffc0089", "html_url": "https://github.com/rust-lang/rust/commit/647c0e06365aa4570870e78d3b29c2a8fffc0089"}], "stats": {"total": 91, "additions": 66, "deletions": 25}, "files": [{"sha": "b55e6bc54bc5ff25b0576695a41c82ac3afed240", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c358476c1bcb195ad4808605626856691282190d/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c358476c1bcb195ad4808605626856691282190d/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=c358476c1bcb195ad4808605626856691282190d", "patch": "@@ -189,8 +189,11 @@ impl<'tcx, Tag> Pointer<Tag> {\n         Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n     }\n \n+    /// Test if the pointer is \"inbounds\" of an allocation of the given size.\n+    /// A pointer is \"inbounds\" even if its offset is equal to the size; this is\n+    /// a \"one-past-the-end\" pointer.\n     #[inline(always)]\n-    pub fn check_in_alloc(\n+    pub fn check_inbounds_alloc(\n         self,\n         allocation_size: Size,\n         msg: CheckInAllocMsg,"}, {"sha": "6771d7661e3a4cf54e8893aed2554f9b9e349f64", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c358476c1bcb195ad4808605626856691282190d/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c358476c1bcb195ad4808605626856691282190d/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c358476c1bcb195ad4808605626856691282190d", "patch": "@@ -368,7 +368,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n                 let end_ptr = ptr.offset(size, self)?;\n-                end_ptr.check_in_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n+                end_ptr.check_inbounds_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n@@ -400,7 +400,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> bool {\n         let (size, _align) = self.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n             .expect(\"alloc info with MaybeDead cannot fail\");\n-        ptr.check_in_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n+        ptr.check_inbounds_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n     }\n }\n "}, {"sha": "139a92c7b11908af303d47b5471a2adf909a212d", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c358476c1bcb195ad4808605626856691282190d/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c358476c1bcb195ad4808605626856691282190d/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=c358476c1bcb195ad4808605626856691282190d", "patch": "@@ -246,7 +246,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(None);\n         }\n \n-        let ptr = match self.check_mplace_access(mplace, None)? {\n+        let ptr = match self.check_mplace_access(mplace, None)\n+            .expect(\"places should be checked on creation\")\n+        {\n             Some(ptr) => ptr,\n             None => return Ok(Some(ImmTy { // zero-sized type\n                 imm: Scalar::zst().into(),"}, {"sha": "16686c3800f87d95972c7a7855060e3a16200621", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/c358476c1bcb195ad4808605626856691282190d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c358476c1bcb195ad4808605626856691282190d/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=c358476c1bcb195ad4808605626856691282190d", "patch": "@@ -277,6 +277,10 @@ where\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n+    ///\n+    /// Only call this if you are sure the place is \"valid\" (aligned and inbounds), or do not\n+    /// want to ever use the place for memory access!\n+    /// Generally prefer `deref_operand`.\n     pub fn ref_to_mplace(\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n@@ -304,7 +308,8 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n-        self.ref_to_mplace(val)\n+        let place = self.ref_to_mplace(val)?;\n+        self.mplace_access_checked(place)\n     }\n \n     /// Check if the given place is good for memory access with the given\n@@ -327,6 +332,23 @@ where\n         self.memory.check_ptr_access(place.ptr, size, place.align)\n     }\n \n+    /// Return the \"access-checked\" version of this `MPlace`, where for non-ZST\n+    /// this is definitely a `Pointer`.\n+    pub fn mplace_access_checked(\n+        &self,\n+        mut place: MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let (size, align) = self.size_and_align_of_mplace(place)?\n+            .unwrap_or((place.layout.size, place.layout.align.abi));\n+        assert!(place.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n+        place.mplace.align = align; // maximally strict checking\n+        // When dereferencing a pointer, it must be non-NULL, aligned, and live.\n+        if let Some(ptr) = self.check_mplace_access(place, Some(size))? {\n+            place.mplace.ptr = ptr.into();\n+        }\n+        Ok(place)\n+    }\n+\n     /// Force `place.ptr` to a `Pointer`.\n     /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n     pub fn force_mplace_ptr(\n@@ -750,7 +772,9 @@ where\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n \n-        let ptr = match self.check_mplace_access(dest, None)? {\n+        let ptr = match self.check_mplace_access(dest, None)\n+            .expect(\"places should be checked on creation\")\n+        {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access\n         };\n@@ -853,8 +877,10 @@ where\n         });\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n \n-        let src = self.check_mplace_access(src, Some(size))?;\n-        let dest = self.check_mplace_access(dest, Some(size))?;\n+        let src = self.check_mplace_access(src, Some(size))\n+            .expect(\"places should be checked on creation\");\n+        let dest = self.check_mplace_access(dest, Some(size))\n+            .expect(\"places should be checked on creation\");\n         let (src_ptr, dest_ptr) = match (src, dest) {\n             (Some(src_ptr), Some(dest_ptr)) => (src_ptr, dest_ptr),\n             (None, None) => return Ok(()), // zero-sized copy"}, {"sha": "e55827837fa1ec0515da4386be3a909e2053ec03", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c358476c1bcb195ad4808605626856691282190d/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c358476c1bcb195ad4808605626856691282190d/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=c358476c1bcb195ad4808605626856691282190d", "patch": "@@ -240,8 +240,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n-                let val = self.force_allocation(src)?;\n-                self.write_immediate(val.to_ref(), dest)?;\n+                let place = self.force_allocation(src)?;\n+                if place.layout.size.bytes() > 0 {\n+                    // definitely not a ZST\n+                    assert!(place.ptr.is_ptr(), \"non-ZST places should be normalized to `Pointer`\");\n+                }\n+                self.write_immediate(place.to_ref(), dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, _) => {"}, {"sha": "431ff356ade197a7f21854a5b36620b1b305461a", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c358476c1bcb195ad4808605626856691282190d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c358476c1bcb195ad4808605626856691282190d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=c358476c1bcb195ad4808605626856691282190d", "patch": "@@ -11,10 +11,11 @@ const NON_NULL_PTR: NonNull<u8> = unsafe { mem::transmute(&1) };\n const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n+#[deny(const_err)] // this triggers a `const_err` so validation does not even happen\n const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n-//~^ ERROR it is undefined behavior to use this value\n-    let ptr: &(u8, u8, u8) = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n-    let out_of_bounds_ptr = &ptr.2; // use address-of-field for pointer arithmetic\n+    let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n+    // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n+    let out_of_bounds_ptr = &ptr[255]; //~ ERROR any use of this value will cause an error\n     mem::transmute(out_of_bounds_ptr)\n } };\n "}, {"sha": "7b3c97e5fbf9608cd92b40be8cd3bd410445e293", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c358476c1bcb195ad4808605626856691282190d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c358476c1bcb195ad4808605626856691282190d/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=c358476c1bcb195ad4808605626856691282190d", "patch": "@@ -6,53 +6,58 @@ LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:14:1\n+error: any use of this value will cause an error\n+  --> $DIR/ub-nonnull.rs:18:29\n    |\n LL | / const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n-LL | |\n-LL | |     let ptr: &(u8, u8, u8) = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n-LL | |     let out_of_bounds_ptr = &ptr.2; // use address-of-field for pointer arithmetic\n+LL | |     let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n+LL | |     // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n+LL | |     let out_of_bounds_ptr = &ptr[255];\n+   | |                             ^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of allocation 6 which has size 1\n LL | |     mem::transmute(out_of_bounds_ptr)\n LL | | } };\n-   | |____^ type validation failed: encountered a potentially NULL pointer, but expected something that cannot possibly fail to be greater or equal to 1\n+   | |____-\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+note: lint level defined here\n+  --> $DIR/ub-nonnull.rs:14:8\n+   |\n+LL | #[deny(const_err)] // this triggers a `const_err` so validation does not even happen\n+   |        ^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:21:1\n+  --> $DIR/ub-nonnull.rs:22:1\n    |\n LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:23:1\n+  --> $DIR/ub-nonnull.rs:24:1\n    |\n LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:30:1\n+  --> $DIR/ub-nonnull.rs:31:1\n    |\n LL | const UNINIT: NonZeroU8 = unsafe { Transmute { uninit: () }.out };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:38:1\n+  --> $DIR/ub-nonnull.rs:39:1\n    |\n LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something in the range 10..=30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:44:1\n+  --> $DIR/ub-nonnull.rs:45:1\n    |\n LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 20, but expected something less or equal to 10, or greater or equal to 30"}]}