{"sha": "64651138524b45a7e18bec7dcaf143c7fa4f2794", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NjUxMTM4NTI0YjQ1YTdlMThiZWM3ZGNhZjE0M2M3ZmE0ZjI3OTQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-03-22T09:01:46Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2020-04-04T03:49:20Z"}, "message": "typeck/type_of: simplify checking of opaque types with multipler defining uses.", "tree": {"sha": "0b03690c8acbb82b0641acc66097fa19da754a5d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b03690c8acbb82b0641acc66097fa19da754a5d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64651138524b45a7e18bec7dcaf143c7fa4f2794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64651138524b45a7e18bec7dcaf143c7fa4f2794", "html_url": "https://github.com/rust-lang/rust/commit/64651138524b45a7e18bec7dcaf143c7fa4f2794", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64651138524b45a7e18bec7dcaf143c7fa4f2794/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6fe99c798cb65280a9a56f442b371adcb7b8aa2", "html_url": "https://github.com/rust-lang/rust/commit/f6fe99c798cb65280a9a56f442b371adcb7b8aa2"}], "stats": {"total": 175, "additions": 53, "deletions": 122}, "files": [{"sha": "9b182333907974f1986a917972ceac97af694667", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/64651138524b45a7e18bec7dcaf143c7fa4f2794/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64651138524b45a7e18bec7dcaf143c7fa4f2794/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=64651138524b45a7e18bec7dcaf143c7fa4f2794", "patch": "@@ -1077,48 +1077,42 @@ impl<'tcx> Generics {\n         false\n     }\n \n+    pub fn param_at(&'tcx self, param_index: usize, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n+        if let Some(index) = param_index.checked_sub(self.parent_count) {\n+            &self.params[index]\n+        } else {\n+            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n+                .param_at(param_index, tcx)\n+        }\n+    }\n+\n     pub fn region_param(\n         &'tcx self,\n         param: &EarlyBoundRegion,\n         tcx: TyCtxt<'tcx>,\n     ) -> &'tcx GenericParamDef {\n-        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n-            let param = &self.params[index as usize];\n-            match param.kind {\n-                GenericParamDefKind::Lifetime => param,\n-                _ => bug!(\"expected lifetime parameter, but found another generic parameter\"),\n-            }\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n-                .region_param(param, tcx)\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Lifetime => param,\n+            _ => bug!(\"expected lifetime parameter, but found another generic parameter\"),\n         }\n     }\n \n     /// Returns the `GenericParamDef` associated with this `ParamTy`.\n     pub fn type_param(&'tcx self, param: &ParamTy, tcx: TyCtxt<'tcx>) -> &'tcx GenericParamDef {\n-        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n-            let param = &self.params[index as usize];\n-            match param.kind {\n-                GenericParamDefKind::Type { .. } => param,\n-                _ => bug!(\"expected type parameter, but found another generic parameter\"),\n-            }\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count > 0 but no parent?\"))\n-                .type_param(param, tcx)\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Type { .. } => param,\n+            _ => bug!(\"expected type parameter, but found another generic parameter\"),\n         }\n     }\n \n     /// Returns the `ConstParameterDef` associated with this `ParamConst`.\n     pub fn const_param(&'tcx self, param: &ParamConst, tcx: TyCtxt<'tcx>) -> &GenericParamDef {\n-        if let Some(index) = param.index.checked_sub(self.parent_count as u32) {\n-            let param = &self.params[index as usize];\n-            match param.kind {\n-                GenericParamDefKind::Const => param,\n-                _ => bug!(\"expected const parameter, but found another generic parameter\"),\n-            }\n-        } else {\n-            tcx.generics_of(self.parent.expect(\"parent_count>0 but no parent?\"))\n-                .const_param(param, tcx)\n+        let param = self.param_at(param.index as usize, tcx);\n+        match param.kind {\n+            GenericParamDefKind::Const => param,\n+            _ => bug!(\"expected const parameter, but found another generic parameter\"),\n         }\n     }\n }"}, {"sha": "acf593c291274924af4d9fcc748fecee4ca4478d", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 29, "deletions": 92, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/64651138524b45a7e18bec7dcaf143c7fa4f2794/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64651138524b45a7e18bec7dcaf143c7fa4f2794/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=64651138524b45a7e18bec7dcaf143c7fa4f2794", "patch": "@@ -1,4 +1,4 @@\n-use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{struct_span_err, Applicability, StashKey};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -7,7 +7,7 @@ use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::Node;\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, Subst};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable};\n use rustc_session::parse::feature_err;\n@@ -369,13 +369,8 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     struct ConstraintLocator<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        // (first found type span, actual type, mapping from the opaque type's generic\n-        // parameters to the concrete type's generic parameters)\n-        //\n-        // The mapping is an index for each use site of a generic parameter in the concrete type\n-        //\n-        // The indices index into the generic parameters on the opaque type.\n-        found: Option<(Span, Ty<'tcx>, Vec<usize>)>,\n+        // (first found type span, actual type)\n+        found: Option<(Span, Ty<'tcx>)>,\n     }\n \n     impl ConstraintLocator<'_> {\n@@ -407,14 +402,15 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n                 // FIXME(oli-obk): trace the actual span from inference to improve errors.\n                 let span = self.tcx.def_span(def_id);\n-                // used to quickly look up the position of a generic parameter\n-                let mut index_map: FxHashMap<ty::ParamTy, usize> = FxHashMap::default();\n-                // Skipping binder is ok, since we only use this to find generic parameters and\n-                // their positions.\n-                for (idx, subst) in substs.iter().enumerate() {\n-                    if let GenericArgKind::Type(ty) = subst.unpack() {\n+\n+                let opaque_generics = self.tcx.generics_of(self.def_id);\n+                let mut used_params: FxHashSet<ty::ParamTy> = FxHashSet::default();\n+                let mut has_errors = false;\n+                for (i, arg) in substs.iter().enumerate() {\n+                    // FIXME(eddyb) enforce lifetime and const param 1:1 mapping.\n+                    if let GenericArgKind::Type(ty) = arg.unpack() {\n                         if let ty::Param(p) = ty.kind {\n-                            if index_map.insert(p, idx).is_some() {\n+                            if !used_params.insert(p) {\n                                 // There was already an entry for `p`, meaning a generic parameter\n                                 // was used twice.\n                                 self.tcx.sess.span_err(\n@@ -428,62 +424,28 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                                 return;\n                             }\n                         } else {\n-                            self.tcx.sess.delay_span_bug(\n+                            let param = opaque_generics.param_at(i, self.tcx);\n+                            self.tcx.sess.span_err(\n                                 span,\n                                 &format!(\n-                                    \"non-defining opaque ty use in defining scope: {:?}, {:?}\",\n-                                    concrete_type, substs,\n+                                    \"defining opaque type use does not fully define opaque type: \\\n+                                     generic parameter `{}` is specified as concrete {} `{}`\",\n+                                    param.name,\n+                                    param.kind.descr(),\n+                                    arg,\n                                 ),\n                             );\n+                            has_errors = true;\n                         }\n                     }\n                 }\n-                // Compute the index within the opaque type for each generic parameter used in\n-                // the concrete type.\n-                let indices = concrete_type\n-                    .subst(self.tcx, substs)\n-                    .walk()\n-                    .filter_map(|t| match &t.kind {\n-                        ty::Param(p) => Some(*index_map.get(p).unwrap()),\n-                        _ => None,\n-                    })\n-                    .collect();\n-                let is_param = |ty: Ty<'_>| match ty.kind {\n-                    ty::Param(_) => true,\n-                    _ => false,\n-                };\n-                let bad_substs: Vec<_> = substs\n-                    .iter()\n-                    .enumerate()\n-                    .filter_map(|(i, k)| {\n-                        if let GenericArgKind::Type(ty) = k.unpack() { Some((i, ty)) } else { None }\n-                    })\n-                    .filter(|(_, ty)| !is_param(ty))\n-                    .collect();\n-                if !bad_substs.is_empty() {\n-                    let identity_substs = InternalSubsts::identity_for_item(self.tcx, self.def_id);\n-                    for (i, bad_subst) in bad_substs {\n-                        self.tcx.sess.span_err(\n-                            span,\n-                            &format!(\n-                                \"defining opaque type use does not fully define opaque type: \\\n-                            generic parameter `{}` is specified as concrete type `{}`\",\n-                                identity_substs.type_at(i),\n-                                bad_subst\n-                            ),\n-                        );\n-                    }\n-                } else if let Some((prev_span, prev_ty, ref prev_indices)) = self.found {\n-                    let mut ty = concrete_type.walk().fuse();\n-                    let mut p_ty = prev_ty.walk().fuse();\n-                    let iter_eq = (&mut ty).zip(&mut p_ty).all(|(t, p)| match (&t.kind, &p.kind) {\n-                        // Type parameters are equal to any other type parameter for the purpose of\n-                        // concrete type equality, as it is possible to obtain the same type just\n-                        // by passing matching parameters to a function.\n-                        (ty::Param(_), ty::Param(_)) => true,\n-                        _ => t == p,\n-                    });\n-                    if !iter_eq || ty.next().is_some() || p_ty.next().is_some() {\n+\n+                if has_errors {\n+                    return;\n+                }\n+\n+                if let Some((prev_span, prev_ty)) = self.found {\n+                    if *concrete_type != prev_ty {\n                         debug!(\"find_opaque_ty_constraints: span={:?}\", span);\n                         // Found different concrete types for the opaque type.\n                         let mut err = self.tcx.sess.struct_span_err(\n@@ -496,34 +458,9 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                         );\n                         err.span_note(prev_span, \"previous use here\");\n                         err.emit();\n-                    } else if indices != *prev_indices {\n-                        // Found \"same\" concrete types, but the generic parameter order differs.\n-                        let mut err = self.tcx.sess.struct_span_err(\n-                            span,\n-                            \"concrete type's generic parameters differ from previous defining use\",\n-                        );\n-                        use std::fmt::Write;\n-                        let mut s = String::new();\n-                        write!(s, \"expected [\").unwrap();\n-                        let list = |s: &mut String, indices: &Vec<usize>| {\n-                            let mut indices = indices.iter().cloned();\n-                            if let Some(first) = indices.next() {\n-                                write!(s, \"`{}`\", substs[first]).unwrap();\n-                                for i in indices {\n-                                    write!(s, \", `{}`\", substs[i]).unwrap();\n-                                }\n-                            }\n-                        };\n-                        list(&mut s, prev_indices);\n-                        write!(s, \"], got [\").unwrap();\n-                        list(&mut s, &indices);\n-                        write!(s, \"]\").unwrap();\n-                        err.span_label(span, s);\n-                        err.span_note(prev_span, \"previous use here\");\n-                        err.emit();\n                     }\n                 } else {\n-                    self.found = Some((span, concrete_type, indices));\n+                    self.found = Some((span, concrete_type));\n                 }\n             } else {\n                 debug!(\n@@ -606,7 +543,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     }\n \n     match locator.found {\n-        Some((_, ty, _)) => ty,\n+        Some((_, ty)) => ty,\n         None => {\n             let span = tcx.def_span(def_id);\n             tcx.sess.span_err(span, \"could not find defining uses\");"}, {"sha": "ec9f40851c5f5439727f35c3ae160f7c2bbdb4f9", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/64651138524b45a7e18bec7dcaf143c7fa4f2794/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64651138524b45a7e18bec7dcaf143c7fa4f2794/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.rs?ref=64651138524b45a7e18bec7dcaf143c7fa4f2794", "patch": "@@ -17,6 +17,6 @@ fn two<T: Debug, U>(t: T, _: U) -> Two<T, U> {\n }\n \n fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n-//~^ concrete type's generic parameters differ from previous defining use\n+//~^ concrete type differs from previous defining opaque type use\n     u\n }"}, {"sha": "51bee41aba36990e4ddedee16a50884f457ae49e", "filename": "src/test/ui/type-alias-impl-trait/generic_duplicate_param_use3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/64651138524b45a7e18bec7dcaf143c7fa4f2794/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/64651138524b45a7e18bec7dcaf143c7fa4f2794/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_duplicate_param_use3.stderr?ref=64651138524b45a7e18bec7dcaf143c7fa4f2794", "patch": "@@ -7,14 +7,14 @@ LL | |     t\n LL | | }\n    | |_^\n \n-error: concrete type's generic parameters differ from previous defining use\n+error: concrete type differs from previous defining opaque type use\n   --> $DIR/generic_duplicate_param_use3.rs:19:1\n    |\n LL | / fn three<T, U: Debug>(_: T, u: U) -> Two<T, U> {\n LL | |\n LL | |     u\n LL | | }\n-   | |_^ expected [`T`], got [`U`]\n+   | |_^ expected `T`, got `U`\n    |\n note: previous use here\n   --> $DIR/generic_duplicate_param_use3.rs:15:1"}]}