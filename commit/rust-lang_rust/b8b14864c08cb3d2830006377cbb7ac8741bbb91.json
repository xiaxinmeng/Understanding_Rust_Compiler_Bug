{"sha": "b8b14864c08cb3d2830006377cbb7ac8741bbb91", "node_id": "C_kwDOAAsO6NoAKGI4YjE0ODY0YzA4Y2IzZDI4MzAwMDYzNzdjYmI3YWM4NzQxYmJiOTE", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-08-01T14:26:18Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-08-01T14:26:18Z"}, "message": "Forward `ArrayChunks::next{,_back}` to `try_{for_each,rfold}`\n\n(suggested in the review of the previous attempt to add `ArrayChunks`)", "tree": {"sha": "d0306510484250cf3acbdc60c9bc4a165ac180ba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d0306510484250cf3acbdc60c9bc4a165ac180ba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8b14864c08cb3d2830006377cbb7ac8741bbb91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8b14864c08cb3d2830006377cbb7ac8741bbb91", "html_url": "https://github.com/rust-lang/rust/commit/b8b14864c08cb3d2830006377cbb7ac8741bbb91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8b14864c08cb3d2830006377cbb7ac8741bbb91/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef72349e38635bc329a94b1e95648562e59ab7d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef72349e38635bc329a94b1e95648562e59ab7d2", "html_url": "https://github.com/rust-lang/rust/commit/ef72349e38635bc329a94b1e95648562e59ab7d2"}], "stats": {"total": 44, "additions": 2, "deletions": 42}, "files": [{"sha": "e25a6f9754b2dd2adbe2f0530fb88025e6b038a8", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/b8b14864c08cb3d2830006377cbb7ac8741bbb91/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8b14864c08cb3d2830006377cbb7ac8741bbb91/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=b8b14864c08cb3d2830006377cbb7ac8741bbb91", "patch": "@@ -48,33 +48,7 @@ where\n \n     #[inline]\n     fn next(&mut self) -> Option<Self::Item> {\n-        let mut array = MaybeUninit::uninit_array();\n-        // SAFETY: `array` will still be valid if `guard` is dropped.\n-        let mut guard = unsafe { FrontGuard::new(&mut array) };\n-\n-        for slot in array.iter_mut() {\n-            match self.iter.next() {\n-                Some(item) => {\n-                    slot.write(item);\n-                    guard.init += 1;\n-                }\n-                None => {\n-                    if guard.init > 0 {\n-                        let init = guard.init;\n-                        mem::forget(guard);\n-                        self.remainder = {\n-                            // SAFETY: `array` was initialized with `init` elements.\n-                            Some(unsafe { array::IntoIter::new_unchecked(array, 0..init) })\n-                        };\n-                    }\n-                    return None;\n-                }\n-            }\n-        }\n-\n-        mem::forget(guard);\n-        // SAFETY: All elements of the array were populated in the loop above.\n-        Some(unsafe { MaybeUninit::array_assume_init(array) })\n+        self.try_for_each(ControlFlow::Break).break_value()\n     }\n \n     #[inline]\n@@ -194,21 +168,7 @@ where\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<Self::Item> {\n-        // We are iterating from the back we need to first handle the remainder.\n-        self.next_back_remainder()?;\n-\n-        let mut array = MaybeUninit::uninit_array();\n-        // SAFETY: `array` will still be valid if `guard` is dropped.\n-        let mut guard = unsafe { BackGuard::new(&mut array) };\n-\n-        for slot in array.iter_mut().rev() {\n-            slot.write(self.iter.next_back()?);\n-            guard.uninit -= 1;\n-        }\n-\n-        mem::forget(guard);\n-        // SAFETY: All elements of the array were populated in the loop above.\n-        Some(unsafe { MaybeUninit::array_assume_init(array) })\n+        self.try_rfold((), |(), x| ControlFlow::Break(x)).break_value()\n     }\n \n     fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R"}]}