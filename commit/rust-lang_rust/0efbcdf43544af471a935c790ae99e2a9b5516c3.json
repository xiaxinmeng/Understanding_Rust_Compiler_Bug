{"sha": "0efbcdf43544af471a935c790ae99e2a9b5516c3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlZmJjZGY0MzU0NGFmNDcxYTkzNWM3OTBhZTk5ZTJhOWI1NTE2YzM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-28T14:34:28Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-05-28T14:34:28Z"}, "message": "remove old parsing methods", "tree": {"sha": "4d9d65e4888cacf5fd7fbc359233afb8fe5395ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d9d65e4888cacf5fd7fbc359233afb8fe5395ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0efbcdf43544af471a935c790ae99e2a9b5516c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0efbcdf43544af471a935c790ae99e2a9b5516c3", "html_url": "https://github.com/rust-lang/rust/commit/0efbcdf43544af471a935c790ae99e2a9b5516c3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0efbcdf43544af471a935c790ae99e2a9b5516c3/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "310bfe57bd1ea3cd5e22d434ae9d709265af5463", "url": "https://api.github.com/repos/rust-lang/rust/commits/310bfe57bd1ea3cd5e22d434ae9d709265af5463", "html_url": "https://github.com/rust-lang/rust/commit/310bfe57bd1ea3cd5e22d434ae9d709265af5463"}], "stats": {"total": 116, "additions": 54, "deletions": 62}, "files": [{"sha": "319110b6a7bd6add47ab6f2872bf5565ecc6bdc4", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=0efbcdf43544af471a935c790ae99e2a9b5516c3", "patch": "@@ -80,7 +80,9 @@ fn test_doc_comment_none() {\n         // non-doc\n         mod foo {}\n         \"#,\n-    );\n+    )\n+    .ok()\n+    .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n     assert!(module.doc_comment_text().is_none());\n }\n@@ -93,7 +95,9 @@ fn test_doc_comment_of_items() {\n         // non-doc\n         mod foo {}\n         \"#,\n-    );\n+    )\n+    .ok()\n+    .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n     assert_eq!(\"doc\", module.doc_comment_text().unwrap());\n }\n@@ -110,7 +114,9 @@ fn test_doc_comment_preserves_indents() {\n         /// ```\n         mod foo {}\n         \"#,\n-    );\n+    )\n+    .ok()\n+    .unwrap();\n     let module = file.syntax().descendants().find_map(Module::cast).unwrap();\n     assert_eq!(\"doc1\\n```\\nfn foo() {\\n    // ...\\n}\\n```\", module.doc_comment_text().unwrap());\n }\n@@ -133,7 +139,9 @@ where\n    for<'a> F: Fn(&'a str)\n {}\n         \"#,\n-    );\n+    )\n+    .ok()\n+    .unwrap();\n     let where_clause = file.syntax().descendants().find_map(WhereClause::cast).unwrap();\n \n     let mut predicates = where_clause.predicates();"}, {"sha": "6a9905bd14f8653468ce985a2797041e40187488", "filename": "crates/ra_syntax/src/fuzz.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ffuzz.rs?ref=0efbcdf43544af471a935c790ae99e2a9b5516c3", "patch": "@@ -5,12 +5,11 @@ use std::str::{self, FromStr};\n fn check_file_invariants(file: &SourceFile) {\n     let root = file.syntax();\n     validation::validate_block_structure(root);\n-    let _ = file.errors();\n }\n \n pub fn check_parser(text: &str) {\n     let file = SourceFile::parse(text);\n-    check_file_invariants(&file);\n+    check_file_invariants(&file.tree);\n }\n \n #[derive(Debug, Clone)]\n@@ -44,16 +43,18 @@ impl CheckReparse {\n     }\n \n     pub fn run(&self) {\n-        let file = SourceFile::parse(&self.text);\n-        let new_file = file.reparse(&self.edit);\n-        check_file_invariants(&new_file);\n-        assert_eq!(&new_file.syntax().text().to_string(), &self.edited_text);\n+        let parse = SourceFile::parse(&self.text);\n+        let new_parse = parse.reparse(&self.edit);\n+        check_file_invariants(&new_parse.tree);\n+        assert_eq!(&new_parse.tree.syntax().text().to_string(), &self.edited_text);\n         let full_reparse = SourceFile::parse(&self.edited_text);\n-        for (a, b) in new_file.syntax().descendants().zip(full_reparse.syntax().descendants()) {\n+        for (a, b) in\n+            new_parse.tree.syntax().descendants().zip(full_reparse.tree.syntax().descendants())\n+        {\n             if (a.kind(), a.range()) != (b.kind(), b.range()) {\n-                eprint!(\"original:\\n{}\", file.syntax().debug_dump());\n-                eprint!(\"reparsed:\\n{}\", new_file.syntax().debug_dump());\n-                eprint!(\"full reparse:\\n{}\", full_reparse.syntax().debug_dump());\n+                eprint!(\"original:\\n{}\", parse.tree.syntax().debug_dump());\n+                eprint!(\"reparsed:\\n{}\", new_parse.tree.syntax().debug_dump());\n+                eprint!(\"full reparse:\\n{}\", full_reparse.tree.syntax().debug_dump());\n                 assert_eq!(\n                     format!(\"{:?}\", a),\n                     format!(\"{:?}\", b),"}, {"sha": "930a643b745b077ffd7b5a5a9188c77fb0d2377b", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 25, "deletions": 30, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=0efbcdf43544af471a935c790ae99e2a9b5516c3", "patch": "@@ -69,13 +69,32 @@ impl Parse {\n         }\n     }\n \n+    pub fn reparse(&self, edit: &AtomTextEdit) -> Parse {\n+        self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n+    }\n+\n     pub fn debug_dump(&self) -> String {\n         let mut buf = self.tree.syntax().debug_dump();\n         for err in self.errors.iter() {\n             writeln!(buf, \"err: `{}`\", err).unwrap();\n         }\n         buf\n     }\n+\n+    fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<Parse> {\n+        // FIXME: validation errors are not handled here\n+        parsing::incremental_reparse(self.tree.syntax(), edit, self.errors.to_vec()).map(\n+            |(green_node, errors, _reparsed_range)| Parse {\n+                tree: SourceFile::new(green_node),\n+                errors: Arc::new(errors),\n+            },\n+        )\n+    }\n+\n+    fn full_reparse(&self, edit: &AtomTextEdit) -> Parse {\n+        let text = edit.apply(self.tree.syntax().text().to_string());\n+        SourceFile::parse(&text)\n+    }\n }\n \n /// `SourceFile` represents a parse tree for a single Rust file.\n@@ -91,37 +110,12 @@ impl SourceFile {\n         TreeArc::cast(root)\n     }\n \n-    pub fn parse2(text: &str) -> Parse {\n+    pub fn parse(text: &str) -> Parse {\n         let (green, mut errors) = parsing::parse_text(text);\n         let tree = SourceFile::new(green);\n         errors.extend(validation::validate(&tree));\n         Parse { tree, errors: Arc::new(errors) }\n     }\n-\n-    pub fn parse(text: &str) -> TreeArc<SourceFile> {\n-        let (green, _errors) = parsing::parse_text(text);\n-        SourceFile::new(green)\n-    }\n-\n-    pub fn reparse(&self, edit: &AtomTextEdit) -> TreeArc<SourceFile> {\n-        self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n-    }\n-\n-    pub fn incremental_reparse(&self, edit: &AtomTextEdit) -> Option<TreeArc<SourceFile>> {\n-        parsing::incremental_reparse(self.syntax(), edit, self.errors())\n-            .map(|(green_node, _errors, _reparsed_range)| SourceFile::new(green_node))\n-    }\n-\n-    fn full_reparse(&self, edit: &AtomTextEdit) -> TreeArc<SourceFile> {\n-        let text = edit.apply(self.syntax().text().to_string());\n-        SourceFile::parse(&text)\n-    }\n-\n-    pub fn errors(&self) -> Vec<SyntaxError> {\n-        let mut errors = self.syntax.root_data().to_vec();\n-        errors.extend(validation::validate(self));\n-        errors\n-    }\n }\n \n /// This test does not assert anything and instead just shows off the crate's\n@@ -137,14 +131,15 @@ fn api_walkthrough() {\n     \";\n     // `SourceFile` is the main entry point.\n     //\n-    // Note how `parse` does not return a `Result`: even completely invalid\n-    // source code might be parsed.\n-    let file = SourceFile::parse(source_code);\n+    // The `parse` method returns a `Parse` -- a pair of syntax tree and a list\n+    // of errors. That is, syntax tree is constructed even in presence of errors.\n+    let parse = SourceFile::parse(source_code);\n+    assert!(parse.errors.is_empty());\n \n     // Due to the way ownership is set up, owned syntax Nodes always live behind\n     // a `TreeArc` smart pointer. `TreeArc` is roughly an `std::sync::Arc` which\n     // points to the whole file instead of an individual node.\n-    let file: TreeArc<SourceFile> = file;\n+    let file: TreeArc<SourceFile> = parse.tree;\n \n     // `SourceFile` is the root of the syntax tree. We can iterate file's items:\n     let mut func = None;"}, {"sha": "cf27a339343cd6009a0430e0fa98aa534394979f", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=0efbcdf43544af471a935c790ae99e2a9b5516c3", "patch": "@@ -178,12 +178,12 @@ mod tests {\n         let edit = AtomTextEdit::replace(range, replace_with.to_owned());\n         let after = edit.apply(before.clone());\n \n-        let fully_reparsed = SourceFile::parse2(&after);\n+        let fully_reparsed = SourceFile::parse(&after);\n         let incrementally_reparsed = {\n             let f = SourceFile::parse(&before);\n             let edit = AtomTextEdit { delete: range, insert: replace_with.to_string() };\n             let (green, new_errors, range) =\n-                incremental_reparse(f.syntax(), &edit, f.errors()).unwrap();\n+                incremental_reparse(f.tree.syntax(), &edit, f.errors.to_vec()).unwrap();\n             assert_eq!(range.len(), reparsed_len.into(), \"reparsed fragment has wrong length\");\n             Parse { tree: SourceFile::new(green), errors: Arc::new(new_errors) }\n         };"}, {"sha": "10cddb852833bf47ac8b85c68dd40d3975c894fd", "filename": "crates/ra_syntax/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fptr.rs?ref=0efbcdf43544af471a935c790ae99e2a9b5516c3", "patch": "@@ -76,7 +76,7 @@ impl<N: AstNode> From<AstPtr<N>> for SyntaxNodePtr {\n fn test_local_syntax_ptr() {\n     use crate::{ast, AstNode, SourceFile};\n \n-    let file = SourceFile::parse(\"struct Foo { f: u32, }\");\n+    let file = SourceFile::parse(\"struct Foo { f: u32, }\").ok().unwrap();\n     let field = file.syntax().descendants().find_map(ast::NamedFieldDef::cast).unwrap();\n     let ptr = SyntaxNodePtr::new(field.syntax());\n     let field_syntax = ptr.to_node(file.syntax());"}, {"sha": "4105b52209490e55ca0be8fbf4dae1d7c3406a8c", "filename": "crates/ra_syntax/src/syntax_node.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_node.rs?ref=0efbcdf43544af471a935c790ae99e2a9b5516c3", "patch": "@@ -280,16 +280,6 @@ impl SyntaxNode {\n         buf\n     }\n \n-    pub(crate) fn root_data(&self) -> &[SyntaxError] {\n-        match self.0.root_data() {\n-            None => &[],\n-            Some(data) => {\n-                let data: &Vec<SyntaxError> = std::any::Any::downcast_ref(data).unwrap();\n-                data.as_slice()\n-            }\n-        }\n-    }\n-\n     pub(crate) fn replace_with(&self, replacement: GreenNode) -> GreenNode {\n         self.0.replace_with(replacement)\n     }"}, {"sha": "f31e12588e4405de73a4bda4c0a8cbe3f4e3fd93", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0efbcdf43544af471a935c790ae99e2a9b5516c3/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=0efbcdf43544af471a935c790ae99e2a9b5516c3", "patch": "@@ -21,7 +21,7 @@ fn lexer_tests() {\n #[test]\n fn parser_tests() {\n     dir_tests(&test_data_dir(), &[\"parser/inline/ok\", \"parser/ok\"], |text, path| {\n-        let parse = SourceFile::parse2(text);\n+        let parse = SourceFile::parse(text);\n         let errors = parse.errors.as_slice();\n         assert_eq!(\n             errors,\n@@ -32,7 +32,7 @@ fn parser_tests() {\n         parse.debug_dump()\n     });\n     dir_tests(&test_data_dir(), &[\"parser/err\", \"parser/inline/err\"], |text, path| {\n-        let parse = SourceFile::parse2(text);\n+        let parse = SourceFile::parse(text);\n         let errors = parse.errors.as_slice();\n         assert!(!errors.is_empty(), \"There should be errors in the file {:?}\", path.display());\n         parse.debug_dump()\n@@ -78,9 +78,7 @@ fn self_hosting_parsing() {\n     {\n         count += 1;\n         let text = read_text(entry.path());\n-        let node = SourceFile::parse(&text);\n-        let errors = node.errors();\n-        assert_eq!(&*errors, &[], \"There should be no errors in the file {:?}\", entry);\n+        SourceFile::parse(&text).ok().expect(\"There should be no errors in the file\");\n     }\n     assert!(\n         count > 30,"}]}