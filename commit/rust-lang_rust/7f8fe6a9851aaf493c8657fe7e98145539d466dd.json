{"sha": "7f8fe6a9851aaf493c8657fe7e98145539d466dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmOGZlNmE5ODUxYWFmNDkzYzg2NTdmZTdlOTgxNDU1MzlkNDY2ZGQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-22T07:17:33Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-06-22T07:19:08Z"}, "message": "also use relator in interpreter assignment sanity check", "tree": {"sha": "9c0fae265c0ebf1c8a44a7ceb6039470b8342056", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c0fae265c0ebf1c8a44a7ceb6039470b8342056"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f8fe6a9851aaf493c8657fe7e98145539d466dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f8fe6a9851aaf493c8657fe7e98145539d466dd", "html_url": "https://github.com/rust-lang/rust/commit/7f8fe6a9851aaf493c8657fe7e98145539d466dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f8fe6a9851aaf493c8657fe7e98145539d466dd/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7754322bcc2852814592c47c3b76c53fefe95a4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7754322bcc2852814592c47c3b76c53fefe95a4f", "html_url": "https://github.com/rust-lang/rust/commit/7754322bcc2852814592c47c3b76c53fefe95a4f"}], "stats": {"total": 212, "additions": 109, "deletions": 103}, "files": [{"sha": "b673738cec580472e5f801776e26df58721fe7ef", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7f8fe6a9851aaf493c8657fe7e98145539d466dd/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8fe6a9851aaf493c8657fe7e98145539d466dd/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7f8fe6a9851aaf493c8657fe7e98145539d466dd", "patch": "@@ -15,7 +15,7 @@ use rustc_middle::mir::interpret::{\n };\n use rustc_middle::ty::layout::{self, TyAndLayout};\n use rustc_middle::ty::{\n-    self, fold::BottomUpFolder, query::TyCtxtAt, subst::SubstsRef, Ty, TyCtxt, TypeFoldable,\n+    self, query::TyCtxtAt, subst::SubstsRef, ParamEnv, Ty, TyCtxt, TypeFoldable,\n };\n use rustc_span::{source_map::DUMMY_SP, Span};\n use rustc_target::abi::{Align, HasDataLayout, LayoutOf, Size, TargetDataLayout};\n@@ -24,6 +24,7 @@ use super::{\n     Immediate, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Memory, OpTy, Operand, Place, PlaceTy,\n     ScalarMaybeUninit, StackPopJump,\n };\n+use crate::transform::validate::equal_up_to_regions;\n use crate::util::storage::AlwaysLiveLocals;\n \n pub struct InterpCx<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -220,6 +221,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx,\n /// This test should be symmetric, as it is primarily about layout compatibility.\n pub(super) fn mir_assign_valid_types<'tcx>(\n     tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     src: TyAndLayout<'tcx>,\n     dest: TyAndLayout<'tcx>,\n ) -> bool {\n@@ -234,36 +236,23 @@ pub(super) fn mir_assign_valid_types<'tcx>(\n         return false;\n     }\n \n-    // Type-changing assignments can happen for (at least) two reasons:\n-    // 1. `&mut T` -> `&T` gets optimized from a reborrow to a mere assignment.\n-    // 2. Subtyping is used. While all normal lifetimes are erased, higher-ranked types\n-    //    with their late-bound lifetimes are still around and can lead to type differences.\n-    // Normalize both of them away.\n-    // Also see the related but slightly different pre-monomorphization method in `transform/validate.rs`.\n-    let normalize = |ty: Ty<'tcx>| {\n-        ty.fold_with(&mut BottomUpFolder {\n-            tcx,\n-            // Normalize all references to immutable.\n-            ty_op: |ty| match ty.kind {\n-                ty::Ref(_, pointee, _) => tcx.mk_imm_ref(tcx.lifetimes.re_erased, pointee),\n-                _ => ty,\n-            },\n-            // We just erase all late-bound lifetimes, but this is not fully correct (FIXME):\n-            // lifetimes in invariant positions could matter (e.g. through associated types).\n-            // We rely on the fact that layout was confirmed to be equal above.\n-            lt_op: |_| tcx.lifetimes.re_erased,\n-            // Leave consts unchanged.\n-            ct_op: |ct| ct,\n-        })\n-    };\n-    normalize(src.ty) == normalize(dest.ty)\n+    // Type-changing assignments can happen when subtyping is used. While\n+    // all normal lifetimes are erased, higher-ranked types with their\n+    // late-bound lifetimes are still around and can lead to type\n+    // differences. So we compare ignoring lifetimes.\n+    //\n+    // Note that this is not fully correct (FIXME):\n+    // lifetimes in invariant positions could matter (e.g. through associated types).\n+    // We rely on the fact that layout was confirmed to be equal above.\n+    equal_up_to_regions(tcx, param_env, src.ty, dest.ty)\n }\n \n /// Use the already known layout if given (but sanity check in debug mode),\n /// or compute the layout.\n #[cfg_attr(not(debug_assertions), inline(always))]\n pub(super) fn from_known_layout<'tcx>(\n     tcx: TyCtxtAt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n     known_layout: Option<TyAndLayout<'tcx>>,\n     compute: impl FnOnce() -> InterpResult<'tcx, TyAndLayout<'tcx>>,\n ) -> InterpResult<'tcx, TyAndLayout<'tcx>> {\n@@ -272,7 +261,7 @@ pub(super) fn from_known_layout<'tcx>(\n         Some(known_layout) => {\n             if cfg!(debug_assertions) {\n                 let check_layout = compute()?;\n-                if !mir_assign_valid_types(tcx.tcx, check_layout, known_layout) {\n+                if !mir_assign_valid_types(tcx.tcx, param_env, check_layout, known_layout) {\n                     span_bug!(\n                         tcx.span,\n                         \"expected type differs from actual type.\\nexpected: {:?}\\nactual: {:?}\",\n@@ -476,7 +465,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // have to support that case (mostly by skipping all caching).\n         match frame.locals.get(local).and_then(|state| state.layout.get()) {\n             None => {\n-                let layout = from_known_layout(self.tcx, layout, || {\n+                let layout = from_known_layout(self.tcx, self.param_env, layout, || {\n                     let local_ty = frame.body.local_decls[local].ty;\n                     let local_ty =\n                         self.subst_from_frame_and_normalize_erasing_regions(frame, local_ty);"}, {"sha": "27fa9b2c17c57b80a1a1b1f34921d579e2b770b4", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f8fe6a9851aaf493c8657fe7e98145539d466dd/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8fe6a9851aaf493c8657fe7e98145539d466dd/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=7f8fe6a9851aaf493c8657fe7e98145539d466dd", "patch": "@@ -472,6 +472,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n             *self.tcx,\n+            self.param_env,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n                 place.ty(&self.frame().body.local_decls, *self.tcx).ty\n             ))?,\n@@ -554,7 +555,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // documentation).\n         let val_val = M::adjust_global_const(self, val_val)?;\n         // Other cases need layout.\n-        let layout = from_known_layout(self.tcx, layout, || self.layout_of(val.ty))?;\n+        let layout =\n+            from_known_layout(self.tcx, self.param_env, layout, || self.layout_of(val.ty))?;\n         let op = match val_val {\n             ConstValue::ByRef { alloc, offset } => {\n                 let id = self.tcx.create_memory_alloc(alloc);"}, {"sha": "98a1cea97e2208c25e7ff0af91aae14dba470ff4", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f8fe6a9851aaf493c8657fe7e98145539d466dd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8fe6a9851aaf493c8657fe7e98145539d466dd/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=7f8fe6a9851aaf493c8657fe7e98145539d466dd", "patch": "@@ -652,6 +652,7 @@ where\n         // Sanity-check the type we ended up with.\n         debug_assert!(mir_assign_valid_types(\n             *self.tcx,\n+            self.param_env,\n             self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n                 place.ty(&self.frame().body.local_decls, *self.tcx).ty\n             ))?,\n@@ -855,7 +856,7 @@ where\n     ) -> InterpResult<'tcx> {\n         // We do NOT compare the types for equality, because well-typed code can\n         // actually \"transmute\" `&mut T` to `&T` in an assignment without a cast.\n-        if !mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n+        if !mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n             span_bug!(\n                 self.cur_span(),\n                 \"type mismatch when copying!\\nsrc: {:?},\\ndest: {:?}\",\n@@ -912,7 +913,7 @@ where\n         src: OpTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx> {\n-        if mir_assign_valid_types(*self.tcx, src.layout, dest.layout) {\n+        if mir_assign_valid_types(*self.tcx, self.param_env, src.layout, dest.layout) {\n             // Fast path: Just use normal `copy_op`\n             return self.copy_op(src, dest);\n         }"}, {"sha": "5f0edd64c47e16fc933f53e6ce311ca590b84546", "filename": "src/librustc_mir/transform/validate.rs", "status": "modified", "additions": 88, "deletions": 74, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/7f8fe6a9851aaf493c8657fe7e98145539d466dd/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f8fe6a9851aaf493c8657fe7e98145539d466dd/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fvalidate.rs?ref=7f8fe6a9851aaf493c8657fe7e98145539d466dd", "patch": "@@ -32,6 +32,93 @@ impl<'tcx> MirPass<'tcx> for Validator {\n     }\n }\n \n+/// Returns whether the two types are equal up to lifetimes.\n+/// All lifetimes, including higher-ranked ones, get ignored for this comparison.\n+/// (This is unlike the `erasing_regions` methods, which keep higher-ranked lifetimes for soundness reasons.)\n+///\n+/// The point of this function is to approximate \"equal up to subtyping\".  However,\n+/// the approximation is incorrect as variance is ignored.\n+pub fn equal_up_to_regions(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    src: Ty<'tcx>,\n+    dest: Ty<'tcx>,\n+) -> bool {\n+    struct LifetimeIgnoreRelation<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    }\n+\n+    impl TypeRelation<'tcx> for LifetimeIgnoreRelation<'tcx> {\n+        fn tcx(&self) -> TyCtxt<'tcx> {\n+            self.tcx\n+        }\n+\n+        fn param_env(&self) -> ty::ParamEnv<'tcx> {\n+            self.param_env\n+        }\n+\n+        fn tag(&self) -> &'static str {\n+            \"librustc_mir::transform::validate\"\n+        }\n+\n+        fn a_is_expected(&self) -> bool {\n+            true\n+        }\n+\n+        fn relate_with_variance<T: Relate<'tcx>>(\n+            &mut self,\n+            _: ty::Variance,\n+            a: &T,\n+            b: &T,\n+        ) -> RelateResult<'tcx, T> {\n+            // Ignore variance, require types to be exactly the same.\n+            self.relate(a, b)\n+        }\n+\n+        fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n+            if a == b {\n+                // Short-circuit.\n+                return Ok(a);\n+            }\n+            ty::relate::super_relate_tys(self, a, b)\n+        }\n+\n+        fn regions(\n+            &mut self,\n+            a: ty::Region<'tcx>,\n+            _b: ty::Region<'tcx>,\n+        ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n+            // Ignore regions.\n+            Ok(a)\n+        }\n+\n+        fn consts(\n+            &mut self,\n+            a: &'tcx ty::Const<'tcx>,\n+            b: &'tcx ty::Const<'tcx>,\n+        ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n+            ty::relate::super_relate_consts(self, a, b)\n+        }\n+\n+        fn binders<T>(\n+            &mut self,\n+            a: &ty::Binder<T>,\n+            b: &ty::Binder<T>,\n+        ) -> RelateResult<'tcx, ty::Binder<T>>\n+        where\n+            T: Relate<'tcx>,\n+        {\n+            self.relate(a.skip_binder(), b.skip_binder())?;\n+            Ok(a.clone())\n+        }\n+    }\n+\n+    // Instantiate and run relation.\n+    let mut relator: LifetimeIgnoreRelation<'tcx> = LifetimeIgnoreRelation { tcx: tcx, param_env };\n+    relator.relate(&src, &dest).is_ok()\n+}\n+\n struct TypeChecker<'a, 'tcx> {\n     when: &'a str,\n     source: MirSource<'tcx>,\n@@ -108,80 +195,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // all normal lifetimes are erased, higher-ranked types with their\n         // late-bound lifetimes are still around and can lead to type\n         // differences. So we compare ignoring lifetimes.\n-        struct LifetimeIgnoreRelation<'tcx> {\n-            tcx: TyCtxt<'tcx>,\n-            param_env: ty::ParamEnv<'tcx>,\n-        }\n-\n-        impl TypeRelation<'tcx> for LifetimeIgnoreRelation<'tcx> {\n-            fn tcx(&self) -> TyCtxt<'tcx> {\n-                self.tcx\n-            }\n-\n-            fn param_env(&self) -> ty::ParamEnv<'tcx> {\n-                self.param_env\n-            }\n-\n-            fn tag(&self) -> &'static str {\n-                \"librustc_mir::transform::validate\"\n-            }\n-\n-            fn a_is_expected(&self) -> bool {\n-                true\n-            }\n-\n-            fn relate_with_variance<T: Relate<'tcx>>(\n-                &mut self,\n-                _: ty::Variance,\n-                a: &T,\n-                b: &T,\n-            ) -> RelateResult<'tcx, T> {\n-                // Ignore variance, require types to be exactly the same.\n-                self.relate(a, b)\n-            }\n-\n-            fn tys(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) -> RelateResult<'tcx, Ty<'tcx>> {\n-                if a == b {\n-                    // Short-circuit.\n-                    return Ok(a);\n-                }\n-                ty::relate::super_relate_tys(self, a, b)\n-            }\n-\n-            fn regions(\n-                &mut self,\n-                a: ty::Region<'tcx>,\n-                _b: ty::Region<'tcx>,\n-            ) -> RelateResult<'tcx, ty::Region<'tcx>> {\n-                // Ignore regions.\n-                Ok(a)\n-            }\n-\n-            fn consts(\n-                &mut self,\n-                a: &'tcx ty::Const<'tcx>,\n-                b: &'tcx ty::Const<'tcx>,\n-            ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-                ty::relate::super_relate_consts(self, a, b)\n-            }\n-\n-            fn binders<T>(\n-                &mut self,\n-                a: &ty::Binder<T>,\n-                b: &ty::Binder<T>,\n-            ) -> RelateResult<'tcx, ty::Binder<T>>\n-            where\n-                T: Relate<'tcx>,\n-            {\n-                self.relate(a.skip_binder(), b.skip_binder())?;\n-                Ok(a.clone())\n-            }\n-        }\n-\n-        // Instantiate and run relation.\n-        let mut relator: LifetimeIgnoreRelation<'tcx> =\n-            LifetimeIgnoreRelation { tcx: self.tcx, param_env };\n-        relator.relate(&src, &dest).is_ok()\n+        equal_up_to_regions(self.tcx, param_env, src, dest)\n     }\n }\n "}]}