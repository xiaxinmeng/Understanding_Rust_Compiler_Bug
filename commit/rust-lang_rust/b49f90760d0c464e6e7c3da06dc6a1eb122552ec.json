{"sha": "b49f90760d0c464e6e7c3da06dc6a1eb122552ec", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0OWY5MDc2MGQwYzQ2NGU2ZTdjM2RhMDZkYzZhMWViMTIyNTUyZWM=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-26T18:13:30Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-27T00:46:33Z"}, "message": "Pass more things through `PatCtxt`\n\nThis is even a perf improvement on the match-heavy benchmarks.", "tree": {"sha": "c15a11cb8324e4ed7842ae52be640632dd103eb8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c15a11cb8324e4ed7842ae52be640632dd103eb8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b49f90760d0c464e6e7c3da06dc6a1eb122552ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b49f90760d0c464e6e7c3da06dc6a1eb122552ec", "html_url": "https://github.com/rust-lang/rust/commit/b49f90760d0c464e6e7c3da06dc6a1eb122552ec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b49f90760d0c464e6e7c3da06dc6a1eb122552ec/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdafd1e1bda60f19c41540302da9543069cc1f66", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdafd1e1bda60f19c41540302da9543069cc1f66", "html_url": "https://github.com/rust-lang/rust/commit/cdafd1e1bda60f19c41540302da9543069cc1f66"}], "stats": {"total": 203, "additions": 75, "deletions": 128}, "files": [{"sha": "850ce1847dbaa616f1782c9726501d624ba59097", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 75, "deletions": 128, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/b49f90760d0c464e6e7c3da06dc6a1eb122552ec/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b49f90760d0c464e6e7c3da06dc6a1eb122552ec/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=b49f90760d0c464e6e7c3da06dc6a1eb122552ec", "patch": "@@ -417,7 +417,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n     /// This is roughly the inverse of `Constructor::apply`.\n     fn specialize_constructor(\n         &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n         is_my_head_ctor: bool,\n@@ -428,7 +428,7 @@ impl<'p, 'tcx> PatStack<'p, 'tcx> {\n         // Note that this shortcut is also necessary for correctness: a pattern should always be\n         // specializable with its own constructor, even in cases where we refuse to inspect values like\n         // opaque constants.\n-        if !is_my_head_ctor && !ctor.is_covered_by(cx, self.head_ctor(cx), self.head().ty) {\n+        if !is_my_head_ctor && !ctor.is_covered_by(pcx, self.head_ctor(pcx.cx)) {\n             return None;\n         }\n         let new_fields = ctor_wild_subpatterns.replace_with_pattern_arguments(self.head());\n@@ -593,7 +593,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n     /// This computes `S(constructor, self)`. See top of the file for explanations.\n     fn specialize_constructor(\n         &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n         constructor: &Constructor<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Matrix<'p, 'tcx> {\n@@ -616,7 +616,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                     .iter()\n                     .filter_map(|&i| {\n                         self.patterns[i].specialize_constructor(\n-                            cx,\n+                            pcx,\n                             constructor,\n                             ctor_wild_subpatterns,\n                             false,\n@@ -632,7 +632,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                         cache: SpecializationCache::Incompatible\n                     }\n                     .specialize_constructor(\n-                        cx,\n+                        pcx,\n                         constructor,\n                         ctor_wild_subpatterns\n                     )\n@@ -643,7 +643,7 @@ impl<'p, 'tcx> Matrix<'p, 'tcx> {\n                 .patterns\n                 .iter()\n                 .filter_map(|r| {\n-                    r.specialize_constructor(cx, constructor, ctor_wild_subpatterns, false)\n+                    r.specialize_constructor(pcx, constructor, ctor_wild_subpatterns, false)\n                 })\n                 .collect(),\n         }\n@@ -914,19 +914,15 @@ impl Slice {\n     /// but the first and last can be added/removed, so any\n     /// witness of length \u22652 (say, `[false, false, true]`) can be\n     /// turned to a witness from any other length \u22652.\n-    fn split<'p, 'tcx>(\n-        self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        matrix: &Matrix<'p, 'tcx>,\n-    ) -> SmallVec<[Constructor<'tcx>; 1]> {\n+    fn split<'p, 'tcx>(self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Constructor<'tcx>; 1]> {\n         let (array_len, self_prefix, self_suffix) = match self {\n             Slice { array_len, kind: VarLen(self_prefix, self_suffix) } => {\n                 (array_len, self_prefix, self_suffix)\n             }\n             _ => return smallvec![Slice(self)],\n         };\n \n-        let head_ctors = matrix.head_ctors(cx).filter(|c| !c.is_wildcard());\n+        let head_ctors = pcx.matrix.head_ctors(pcx.cx).filter(|c| !c.is_wildcard());\n \n         let mut max_prefix_len = self_prefix;\n         let mut max_suffix_len = self_suffix;\n@@ -1136,24 +1132,18 @@ impl<'tcx> Constructor<'tcx> {\n     ///\n     /// `hir_id` is `None` when we're evaluating the wildcard pattern. In that case we do not want\n     /// to lint for overlapping ranges.\n-    fn split<'p>(\n-        &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        pcx: PatCtxt<'tcx>,\n-        matrix: &Matrix<'p, 'tcx>,\n-        hir_id: Option<HirId>,\n-    ) -> SmallVec<[Self; 1]> {\n-        debug!(\"Constructor::split({:#?}, {:#?})\", self, matrix);\n+    fn split<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, hir_id: Option<HirId>) -> SmallVec<[Self; 1]> {\n+        debug!(\"Constructor::split({:#?}, {:#?})\", self, pcx.matrix);\n \n         match self {\n             // Fast-track if the range is trivial. In particular, we don't do the overlapping\n             // ranges check.\n             IntRange(ctor_range)\n-                if ctor_range.treat_exhaustively(cx.tcx) && !ctor_range.is_singleton() =>\n+                if ctor_range.treat_exhaustively(pcx.cx.tcx) && !ctor_range.is_singleton() =>\n             {\n-                ctor_range.split(cx, pcx, matrix, hir_id)\n+                ctor_range.split(pcx, hir_id)\n             }\n-            Slice(slice @ Slice { kind: VarLen(..), .. }) => slice.split(cx, matrix),\n+            Slice(slice @ Slice { kind: VarLen(..), .. }) => slice.split(pcx),\n             // Any other constructor can be used unchanged.\n             _ => smallvec![self.clone()],\n         }\n@@ -1162,12 +1152,7 @@ impl<'tcx> Constructor<'tcx> {\n     /// Returns whether `self` is covered by `other`, ie whether `self` is a subset of `other`. For\n     /// the simple cases, this is simply checking for equality. For the \"grouped\" constructors,\n     /// this checks for inclusion.\n-    fn is_covered_by<'p>(\n-        &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        other: &Constructor<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> bool {\n+    fn is_covered_by<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, other: &Constructor<'tcx>) -> bool {\n         match (self, other) {\n             // Wildcards cover anything\n             (_, Wildcard) => true,\n@@ -1178,7 +1163,7 @@ impl<'tcx> Constructor<'tcx> {\n             (Variant(self_id), Variant(other_id)) => self_id == other_id,\n \n             (IntRange(self_range), IntRange(other_range)) => {\n-                if self_range.intersection(cx.tcx, other_range).is_some() {\n+                if self_range.intersection(pcx.cx.tcx, other_range).is_some() {\n                     // Constructor splitting should ensure that all intersections we encounter\n                     // are actually inclusions.\n                     assert!(self_range.is_subrange(other_range));\n@@ -1192,8 +1177,8 @@ impl<'tcx> Constructor<'tcx> {\n                 FloatRange(other_from, other_to, other_end),\n             ) => {\n                 match (\n-                    compare_const_vals(cx.tcx, self_to, other_to, cx.param_env, ty),\n-                    compare_const_vals(cx.tcx, self_from, other_from, cx.param_env, ty),\n+                    compare_const_vals(pcx.cx.tcx, self_to, other_to, pcx.cx.param_env, pcx.ty),\n+                    compare_const_vals(pcx.cx.tcx, self_from, other_from, pcx.cx.param_env, pcx.ty),\n                 ) {\n                     (Some(to), Some(from)) => {\n                         (from == Ordering::Greater || from == Ordering::Equal)\n@@ -1205,7 +1190,8 @@ impl<'tcx> Constructor<'tcx> {\n             }\n             (Str(self_val), Str(other_val)) => {\n                 // FIXME: there's probably a more direct way of comparing for equality\n-                match compare_const_vals(cx.tcx, self_val, other_val, cx.param_env, ty) {\n+                match compare_const_vals(pcx.cx.tcx, self_val, other_val, pcx.cx.param_env, pcx.ty)\n+                {\n                     Some(comparison) => comparison == Ordering::Equal,\n                     None => false,\n                 }\n@@ -1239,23 +1225,18 @@ impl<'tcx> Constructor<'tcx> {\n     /// `ty`: `Option<bool>`\n     /// `pats`: `[false]`\n     /// returns `Some(false)`\n-    fn apply<'p>(\n-        &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        ty: Ty<'tcx>,\n-        fields: Fields<'p, 'tcx>,\n-    ) -> Pat<'tcx> {\n+    fn apply<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>, fields: Fields<'p, 'tcx>) -> Pat<'tcx> {\n         let mut subpatterns = fields.all_patterns();\n \n         let pat = match self {\n-            Single | Variant(_) => match ty.kind() {\n+            Single | Variant(_) => match pcx.ty.kind() {\n                 ty::Adt(..) | ty::Tuple(..) => {\n                     let subpatterns = subpatterns\n                         .enumerate()\n                         .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n                         .collect();\n \n-                    if let ty::Adt(adt, substs) = ty.kind() {\n+                    if let ty::Adt(adt, substs) = pcx.ty.kind() {\n                         if adt.is_enum() {\n                             PatKind::Variant {\n                                 adt_def: adt,\n@@ -1271,7 +1252,7 @@ impl<'tcx> Constructor<'tcx> {\n                     }\n                 }\n                 ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n-                ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+                ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, pcx.ty),\n                 _ => PatKind::Wild,\n             },\n             Slice(slice) => match slice.pattern_kind() {\n@@ -1295,19 +1276,19 @@ impl<'tcx> Constructor<'tcx> {\n                     } else {\n                         subpatterns.collect()\n                     };\n-                    let wild = Pat::wildcard_from_ty(ty);\n+                    let wild = Pat::wildcard_from_ty(pcx.ty);\n                     PatKind::Slice { prefix, slice: Some(wild), suffix }\n                 }\n             },\n             &Str(value) => PatKind::Constant { value },\n             &FloatRange(lo, hi, end) => PatKind::Range(PatRange { lo, hi, end }),\n-            IntRange(range) => return range.to_pat(cx.tcx),\n+            IntRange(range) => return range.to_pat(pcx.cx.tcx),\n             NonExhaustive => PatKind::Wild,\n             Opaque => bug!(\"we should not try to apply an opaque constructor\"),\n             Wildcard => bug!(\"we should not try to apply a wildcard constructor\"),\n         };\n \n-        Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }\n+        Pat { ty: pcx.ty, span: DUMMY_SP, kind: Box::new(pat) }\n     }\n }\n \n@@ -1385,11 +1366,9 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n     }\n \n     /// Creates a new list of wildcard fields for a given constructor.\n-    fn wildcards(\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        constructor: &Constructor<'tcx>,\n-        ty: Ty<'tcx>,\n-    ) -> Self {\n+    fn wildcards(pcx: PatCtxt<'_, 'p, 'tcx>, constructor: &Constructor<'tcx>) -> Self {\n+        let ty = pcx.ty;\n+        let cx = pcx.cx;\n         let wildcard_from_ty = |ty| &*cx.pattern_arena.alloc(Pat::wildcard_from_ty(ty));\n \n         let ret = match constructor {\n@@ -1628,16 +1607,15 @@ impl<'tcx> Usefulness<'tcx> {\n \n     fn apply_constructor<'p>(\n         self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n-        ty: Ty<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => UsefulWithWitness(\n                 witnesses\n                     .into_iter()\n-                    .map(|witness| witness.apply_constructor(cx, &ctor, ty, ctor_wild_subpatterns))\n+                    .map(|witness| witness.apply_constructor(pcx, &ctor, ctor_wild_subpatterns))\n                     .collect(),\n             ),\n             x => x,\n@@ -1646,13 +1624,12 @@ impl<'tcx> Usefulness<'tcx> {\n \n     fn apply_wildcard<'p>(\n         self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        pcx: PatCtxt<'tcx>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n         missing_ctors: MissingConstructors<'tcx>,\n     ) -> Self {\n         match self {\n             UsefulWithWitness(witnesses) => {\n-                let new_patterns = missing_ctors.report_patterns(cx, pcx);\n+                let new_patterns = missing_ctors.report_patterns(pcx);\n                 UsefulWithWitness(\n                     witnesses\n                         .into_iter()\n@@ -1677,9 +1654,14 @@ crate enum WitnessPreference {\n     LeaveOutWitness,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-struct PatCtxt<'tcx> {\n+#[derive(Copy, Clone)]\n+struct PatCtxt<'a, 'p, 'tcx> {\n+    cx: &'a MatchCheckCtxt<'p, 'tcx>,\n+    /// Current state of the matrix.\n+    matrix: &'a Matrix<'p, 'tcx>,\n+    /// Type of the current column under investigation.\n     ty: Ty<'tcx>,\n+    /// Span of the current pattern under investigation.\n     span: Span,\n }\n \n@@ -1740,17 +1722,16 @@ impl<'tcx> Witness<'tcx> {\n     /// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n     fn apply_constructor<'p>(\n         mut self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n         ctor: &Constructor<'tcx>,\n-        ty: Ty<'tcx>,\n         ctor_wild_subpatterns: &Fields<'p, 'tcx>,\n     ) -> Self {\n         let pat = {\n             let len = self.0.len();\n             let arity = ctor_wild_subpatterns.len();\n             let pats = self.0.drain((len - arity)..).rev();\n-            let fields = ctor_wild_subpatterns.replace_fields(cx, pats);\n-            ctor.apply(cx, ty, fields)\n+            let fields = ctor_wild_subpatterns.replace_fields(pcx.cx, pats);\n+            ctor.apply(pcx, fields)\n         };\n \n         self.0.push(pat);\n@@ -1768,11 +1749,9 @@ impl<'tcx> Witness<'tcx> {\n /// `Option<!>`, we do not include `Some(_)` in the returned list of constructors.\n /// Invariant: this returns an empty `Vec` if and only if the type is uninhabited (as determined by\n /// `cx.is_uninhabited()`).\n-fn all_constructors<'a, 'tcx>(\n-    cx: &MatchCheckCtxt<'a, 'tcx>,\n-    pcx: PatCtxt<'tcx>,\n-) -> Vec<Constructor<'tcx>> {\n+fn all_constructors<'p, 'tcx>(pcx: PatCtxt<'_, 'p, 'tcx>) -> Vec<Constructor<'tcx>> {\n     debug!(\"all_constructors({:?})\", pcx.ty);\n+    let cx = pcx.cx;\n     let make_range = |start, end| {\n         IntRange(\n             // `unwrap()` is ok because we know the type is an integer.\n@@ -2122,9 +2101,7 @@ impl<'tcx> IntRange<'tcx> {\n     /// merging operation depicted above.)\n     fn split<'p>(\n         &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        pcx: PatCtxt<'tcx>,\n-        matrix: &Matrix<'p, 'tcx>,\n+        pcx: PatCtxt<'_, 'p, 'tcx>,\n         hir_id: Option<HirId>,\n     ) -> SmallVec<[Constructor<'tcx>; 1]> {\n         let ty = pcx.ty;\n@@ -2152,14 +2129,15 @@ impl<'tcx> IntRange<'tcx> {\n         // Collect the span and range of all the intersecting ranges to lint on likely\n         // incorrect range patterns. (#63987)\n         let mut overlaps = vec![];\n-        let row_len = matrix.patterns.get(0).map(|r| r.len()).unwrap_or(0);\n+        let row_len = pcx.matrix.patterns.get(0).map(|r| r.len()).unwrap_or(0);\n         // `borders` is the set of borders between equivalence classes: each equivalence\n         // class lies between 2 borders.\n-        let row_borders = matrix\n-            .head_ctors(cx)\n+        let row_borders = pcx\n+            .matrix\n+            .head_ctors(pcx.cx)\n             .filter_map(|ctor| IntRange::from_ctor(ctor))\n             .filter_map(|range| {\n-                let intersection = self.intersection(cx.tcx, &range);\n+                let intersection = self.intersection(pcx.cx.tcx, &range);\n                 let should_lint = self.suspicious_intersection(&range);\n                 if let (Some(range), 1, true) = (&intersection, row_len, should_lint) {\n                     // FIXME: for now, only check for overlapping ranges on simple range\n@@ -2179,7 +2157,7 @@ impl<'tcx> IntRange<'tcx> {\n         let mut borders: Vec<_> = row_borders.chain(self_borders).collect();\n         borders.sort_unstable();\n \n-        self.lint_overlapping_patterns(cx.tcx, hir_id, ty, overlaps);\n+        self.lint_overlapping_patterns(pcx.cx.tcx, hir_id, ty, overlaps);\n \n         // We're going to iterate through every adjacent pair of borders, making sure that\n         // each represents an interval of nonnegative length, and convert each such\n@@ -2249,15 +2227,10 @@ struct MissingConstructors<'tcx> {\n }\n \n impl<'tcx> MissingConstructors<'tcx> {\n-    fn new<'p>(\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        pcx: PatCtxt<'tcx>,\n-        matrix: &Matrix<'p, 'tcx>,\n-        is_top_level: bool,\n-    ) -> Self {\n+    fn new<'p>(pcx: PatCtxt<'_, 'p, 'tcx>, is_top_level: bool) -> Self {\n         let used_ctors: Vec<Constructor<'_>> =\n-            matrix.head_ctors(cx).cloned().filter(|c| !c.is_wildcard()).collect();\n-        let all_ctors = all_constructors(cx, pcx);\n+            pcx.matrix.head_ctors(pcx.cx).cloned().filter(|c| !c.is_wildcard()).collect();\n+        let all_ctors = all_constructors(pcx);\n \n         MissingConstructors { all_ctors, used_ctors, is_top_level }\n     }\n@@ -2277,11 +2250,7 @@ impl<'tcx> MissingConstructors<'tcx> {\n \n     /// List the patterns corresponding to the missing constructors. In some cases, instead of\n     /// listing all constructors of a given type, we prefer to simply report a wildcard.\n-    fn report_patterns<'p>(\n-        &self,\n-        cx: &MatchCheckCtxt<'p, 'tcx>,\n-        pcx: PatCtxt<'tcx>,\n-    ) -> SmallVec<[Pat<'tcx>; 1]> {\n+    fn report_patterns<'p>(&self, pcx: PatCtxt<'_, 'p, 'tcx>) -> SmallVec<[Pat<'tcx>; 1]> {\n         // There are 2 ways we can report a witness here.\n         // Commonly, we can report all the \"free\"\n         // constructors as witnesses, e.g., if we have:\n@@ -2321,8 +2290,8 @@ impl<'tcx> MissingConstructors<'tcx> {\n             // `Option::Some`, we get the pattern `Some(_)`.\n             self.iter()\n                 .map(|missing_ctor| {\n-                    let fields = Fields::wildcards(cx, &missing_ctor, pcx.ty);\n-                    missing_ctor.apply(cx, pcx.ty, fields)\n+                    let fields = Fields::wildcards(pcx, &missing_ctor);\n+                    missing_ctor.apply(pcx, fields)\n                 })\n                 .collect()\n         }\n@@ -2440,28 +2409,17 @@ crate fn is_useful<'p, 'tcx>(\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476).\n     let ty = matrix.heads().next().map(|r| r.ty).unwrap_or(v.head().ty);\n-    let pcx = PatCtxt { ty, span: v.head().span };\n+    let pcx = PatCtxt { cx, matrix, ty, span: v.head().span };\n \n-    debug!(\"is_useful_expand_first_col: pcx={:#?}, expanding {:#?}\", pcx, v.head());\n+    debug!(\"is_useful_expand_first_col: ty={:#?}, expanding {:#?}\", pcx.ty, v.head());\n \n     let constructor = v.head_ctor(cx);\n     let ret = if !constructor.is_wildcard() {\n         debug!(\"is_useful - expanding constructor: {:#?}\", constructor);\n         constructor\n-            .split(cx, pcx, matrix, Some(hir_id))\n+            .split(pcx, Some(hir_id))\n             .into_iter()\n-            .map(|c| {\n-                is_useful_specialized(\n-                    cx,\n-                    matrix,\n-                    v,\n-                    c,\n-                    pcx.ty,\n-                    witness_preference,\n-                    hir_id,\n-                    is_under_guard,\n-                )\n-            })\n+            .map(|c| is_useful_specialized(pcx, v, c, witness_preference, hir_id, is_under_guard))\n             .find(|result| result.is_useful())\n             .unwrap_or(NotUseful)\n     } else {\n@@ -2478,39 +2436,30 @@ crate fn is_useful<'p, 'tcx>(\n         // Missing constructors are those that are not matched by any non-wildcard patterns in the\n         // current column. We only fully construct them on-demand, because they're rarely used and\n         // can be big.\n-        let missing_ctors = MissingConstructors::new(cx, pcx, matrix, is_top_level);\n+        let missing_ctors = MissingConstructors::new(pcx, is_top_level);\n \n         debug!(\"is_useful_missing_ctors.empty()={:#?}\", missing_ctors.is_empty(),);\n \n         if missing_ctors.is_empty() {\n             let (all_ctors, _) = missing_ctors.into_inner();\n             all_ctors\n                 .into_iter()\n-                .flat_map(|ctor| ctor.split(cx, pcx, matrix, None))\n+                .flat_map(|ctor| ctor.split(pcx, None))\n                 .map(|c| {\n-                    is_useful_specialized(\n-                        cx,\n-                        matrix,\n-                        v,\n-                        c,\n-                        pcx.ty,\n-                        witness_preference,\n-                        hir_id,\n-                        is_under_guard,\n-                    )\n+                    is_useful_specialized(pcx, v, c, witness_preference, hir_id, is_under_guard)\n                 })\n                 .find(|result| result.is_useful())\n                 .unwrap_or(NotUseful)\n         } else {\n             let ctor_wild_subpatterns = Fields::empty();\n-            let matrix = matrix.specialize_constructor(cx, &constructor, &ctor_wild_subpatterns);\n+            let matrix = matrix.specialize_constructor(pcx, &constructor, &ctor_wild_subpatterns);\n             // Unwrap is ok: v can always be specialized with its own constructor.\n             let v =\n-                v.specialize_constructor(cx, &constructor, &ctor_wild_subpatterns, true).unwrap();\n+                v.specialize_constructor(pcx, &constructor, &ctor_wild_subpatterns, true).unwrap();\n             let usefulness =\n                 is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n \n-            usefulness.apply_wildcard(cx, pcx, missing_ctors)\n+            usefulness.apply_wildcard(pcx, missing_ctors)\n         }\n     };\n     debug!(\"is_useful::returns({:#?}, {:#?}) = {:?}\", matrix, v, ret);\n@@ -2520,23 +2469,21 @@ crate fn is_useful<'p, 'tcx>(\n /// A shorthand for the `U(S(c, P), S(c, q))` operation from the paper. I.e., `is_useful` applied\n /// to the specialised version of both the pattern matrix `P` and the new pattern `q`.\n fn is_useful_specialized<'p, 'tcx>(\n-    cx: &MatchCheckCtxt<'p, 'tcx>,\n-    matrix: &Matrix<'p, 'tcx>,\n+    pcx: PatCtxt<'_, 'p, 'tcx>,\n     v: &PatStack<'p, 'tcx>,\n     ctor: Constructor<'tcx>,\n-    ty: Ty<'tcx>,\n     witness_preference: WitnessPreference,\n     hir_id: HirId,\n     is_under_guard: bool,\n ) -> Usefulness<'tcx> {\n-    debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, ty);\n+    debug!(\"is_useful_specialized({:#?}, {:#?}, {:?})\", v, ctor, pcx.ty);\n \n     // We cache the result of `Fields::wildcards` because it is used a lot.\n-    let ctor_wild_subpatterns = Fields::wildcards(cx, &ctor, ty);\n-    let matrix = matrix.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns);\n-    v.specialize_constructor(cx, &ctor, &ctor_wild_subpatterns, true)\n-        .map(|v| is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n-        .map(|u| u.apply_constructor(cx, &ctor, ty, &ctor_wild_subpatterns))\n+    let ctor_wild_subpatterns = Fields::wildcards(pcx, &ctor);\n+    let matrix = pcx.matrix.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns);\n+    v.specialize_constructor(pcx, &ctor, &ctor_wild_subpatterns, true)\n+        .map(|v| is_useful(pcx.cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false))\n+        .map(|u| u.apply_constructor(pcx, &ctor, &ctor_wild_subpatterns))\n         .unwrap_or(NotUseful)\n }\n "}]}