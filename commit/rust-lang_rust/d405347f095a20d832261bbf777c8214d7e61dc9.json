{"sha": "d405347f095a20d832261bbf777c8214d7e61dc9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ0MDUzNDdmMDk1YTIwZDgzMjI2MWJiZjc3N2M4MjE0ZDdlNjFkYzk=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-05-18T18:40:37Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-07-30T08:50:34Z"}, "message": "adds `slice::array_chunks`", "tree": {"sha": "f2721cf70d1d0ffb0930316045e0b16c475a8cba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2721cf70d1d0ffb0930316045e0b16c475a8cba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d405347f095a20d832261bbf777c8214d7e61dc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d405347f095a20d832261bbf777c8214d7e61dc9", "html_url": "https://github.com/rust-lang/rust/commit/d405347f095a20d832261bbf777c8214d7e61dc9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d405347f095a20d832261bbf777c8214d7e61dc9/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "870b7cbb11d799bcabc6eb5a919a27821c981bc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/870b7cbb11d799bcabc6eb5a919a27821c981bc1", "html_url": "https://github.com/rust-lang/rust/commit/870b7cbb11d799bcabc6eb5a919a27821c981bc1"}], "stats": {"total": 180, "additions": 180, "deletions": 0}, "files": [{"sha": "a7d24492facd1d24f48c9570d713ce07b629128a", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/d405347f095a20d832261bbf777c8214d7e61dc9/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d405347f095a20d832261bbf777c8214d7e61dc9/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=d405347f095a20d832261bbf777c8214d7e61dc9", "patch": "@@ -841,6 +841,41 @@ impl<T> [T] {\n         ChunksExactMut { v: fst, rem: snd, chunk_size }\n     }\n \n+    /// Returns an iterator over `N` elements of the slice at a time, starting at the\n+    /// beginning of the slice.\n+    ///\n+    /// The chunks are slices and do not overlap. If `N` does not divide the length of the\n+    /// slice, then the last up to `N-1` elements will be omitted and can be retrieved\n+    /// from the `remainder` function of the iterator.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `N` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(array_chunks)]\n+    /// let slice = ['l', 'o', 'r', 'e', 'm'];\n+    /// let mut iter = slice.array_chunks();\n+    /// assert_eq!(iter.next().unwrap(), &['l', 'o']);\n+    /// assert_eq!(iter.next().unwrap(), &['r', 'e']);\n+    /// assert!(iter.next().is_none());\n+    /// assert_eq!(iter.remainder(), &['m']);\n+    /// ```\n+    ///\n+    /// [`chunks`]: #method.chunks\n+    /// [`rchunks_exact`]: #method.rchunks_exact\n+    #[unstable(feature = \"array_chunks\", issue = \"none\")]\n+    #[inline]\n+    pub fn array_chunks<const N: usize>(&self) -> ArrayChunks<'_, T, N> {\n+        assert_ne!(N, 0);\n+        let rem = self.len() % N;\n+        let len = self.len() - rem;\n+        let (fst, snd) = self.split_at(len);\n+        ArrayChunks { v: fst, rem: snd }\n+    }\n+\n     /// Returns an iterator over `chunk_size` elements of the slice at a time, starting at the end\n     /// of the slice.\n     ///\n@@ -5432,6 +5467,151 @@ unsafe impl<'a, T> TrustedRandomAccess for ChunksExactMut<'a, T> {\n     }\n }\n \n+/// An iterator over a slice in (non-overlapping) chunks (`N` elements at a\n+/// time), starting at the beginning of the slice.\n+///\n+/// When the slice len is not evenly divided by the chunk size, the last\n+/// up to `chunk_size-1` elements will be omitted but can be retrieved from\n+/// the [`remainder`] function from the iterator.\n+///\n+/// This struct is created by the [`array_chunks`] method on [slices].\n+///\n+/// [`array_chunks`]: ../../std/primitive.slice.html#method.array_chunks\n+/// [`remainder`]: ../../std/slice/struct.ArrayChunks.html#method.remainder\n+/// [slices]: ../../std/primitive.slice.html\n+#[derive(Debug)]\n+#[unstable(feature = \"array_chunks\", issue = \"none\")]\n+pub struct ArrayChunks<'a, T: 'a, const N: usize> {\n+    v: &'a [T],\n+    rem: &'a [T],\n+}\n+\n+impl<'a, T, const N: usize> ArrayChunks<'a, T, N> {\n+    /// Returns the remainder of the original slice that is not going to be\n+    /// returned by the iterator. The returned slice has at most `chunk_size-1`\n+    /// elements.\n+    #[unstable(feature = \"array_chunks\", issue = \"none\")]\n+    pub fn remainder(&self) -> &'a [T] {\n+        self.rem\n+    }\n+}\n+\n+// FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n+#[unstable(feature = \"array_chunks\", issue = \"none\")]\n+impl<T, const N: usize> Clone for ArrayChunks<'_, T, N> {\n+    fn clone(&self) -> Self {\n+        ArrayChunks { v: self.v, rem: self.rem }\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"none\")]\n+impl<'a, T, const N: usize> Iterator for ArrayChunks<'a, T, N> {\n+    type Item = &'a [T; N];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a [T; N]> {\n+        if self.v.len() < N {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(N);\n+            self.v = snd;\n+            // SAFETY: This is safe as fst is exactly N elements long.\n+            let ptr = fst.as_ptr() as *const [T; N];\n+            unsafe { Some(&*ptr) }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let n = self.v.len() / N;\n+        (n, Some(n))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.len()\n+    }\n+\n+    #[inline]\n+    fn nth(&mut self, n: usize) -> Option<Self::Item> {\n+        let (start, overflow) = n.overflowing_mul(N);\n+        if start >= self.v.len() || overflow {\n+            self.v = &[];\n+            None\n+        } else {\n+            let (_, snd) = self.v.split_at(start);\n+            self.v = snd;\n+            self.next()\n+        }\n+    }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<Self::Item> {\n+        self.next_back()\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"none\")]\n+impl<'a, T, const N: usize> DoubleEndedIterator for ArrayChunks<'a, T, N> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a [T; N]> {\n+        if self.v.len() < N {\n+            None\n+        } else {\n+            let (fst, snd) = self.v.split_at(self.v.len() - N);\n+            self.v = fst;\n+            // SAFETY: This is safe as snd is exactly N elements long.\n+            let ptr = snd.as_ptr() as *const [T; N];\n+            unsafe { Some(&*ptr) }\n+        }\n+    }\n+\n+    #[inline]\n+    fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n+        let len = self.len();\n+        if n >= len {\n+            self.v = &[];\n+            None\n+        } else {\n+            let start = (len - 1 - n) * N;\n+            let end = start + N;\n+            let nth_back = &self.v[start..end];\n+            self.v = &self.v[..start];\n+            // SAFETY: This is safe as snd is exactly N elements long.\n+            let ptr = nth_back.as_ptr() as *const [T; N];\n+            unsafe { Some(&*ptr) }\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"none\")]\n+impl<T, const N: usize> ExactSizeIterator for ArrayChunks<'_, T, N> {\n+    fn is_empty(&self) -> bool {\n+        self.v.is_empty()\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<T, const N: usize> TrustedLen for ArrayChunks<'_, T, N> {}\n+\n+#[unstable(feature = \"array_chunks\", issue = \"none\")]\n+impl<T, const N: usize> FusedIterator for ArrayChunks<'_, T, N> {}\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"array_chunks\", issue = \"none\")]\n+unsafe impl<'a, T, const N: usize> TrustedRandomAccess for ArrayChunks<'a, T, N> {\n+    unsafe fn get_unchecked(&mut self, i: usize) -> &'a [T; N] {\n+        let start = i * N;\n+        // SAFETY: This is safe as `i` must be less than `self.size_hint`.\n+        let segment = unsafe { from_raw_parts(self.v.as_ptr().add(start), N) };\n+        // SAFETY: This is safe as segment is exactly `N` elements long.\n+        unsafe { &*(segment.as_ptr() as *const [T; N]) }\n+    }\n+    fn may_have_side_effect() -> bool {\n+        false\n+    }\n+}\n+\n /// An iterator over a slice in (non-overlapping) chunks (`chunk_size` elements at a\n /// time), starting at the end of the slice.\n ///"}]}