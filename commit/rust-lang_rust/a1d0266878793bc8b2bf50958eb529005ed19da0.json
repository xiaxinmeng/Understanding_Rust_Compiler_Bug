{"sha": "a1d0266878793bc8b2bf50958eb529005ed19da0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZDAyNjY4Nzg3OTNiYzhiMmJmNTA5NThlYjUyOTAwNWVkMTlkYTA=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-05-25T16:11:27Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2019-06-13T20:05:21Z"}, "message": "Generate MIR thats easier for llvm for str matches\n\nLLVM appears to prefer (spend less time optimizing) long if chains if\nit receives them in approzimately source order.\nThis fixes a ~10% regression for optimized builds of the encoding benchmark\non perf.rlo due to the changes to decision tree construction.", "tree": {"sha": "38782c0bb77042320e4751ca62a51e51328a0174", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/38782c0bb77042320e4751ca62a51e51328a0174"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1d0266878793bc8b2bf50958eb529005ed19da0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1d0266878793bc8b2bf50958eb529005ed19da0", "html_url": "https://github.com/rust-lang/rust/commit/a1d0266878793bc8b2bf50958eb529005ed19da0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1d0266878793bc8b2bf50958eb529005ed19da0/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef1fc86b521f457f736a8e110c851133cd953149", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef1fc86b521f457f736a8e110c851133cd953149", "html_url": "https://github.com/rust-lang/rust/commit/ef1fc86b521f457f736a8e110c851133cd953149"}], "stats": {"total": 150, "additions": 82, "deletions": 68}, "files": [{"sha": "db4f9e55df6641667b1ec59f07dbd7234df0f508", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 42, "deletions": 35, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/a1d0266878793bc8b2bf50958eb529005ed19da0/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1d0266878793bc8b2bf50958eb529005ed19da0/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=a1d0266878793bc8b2bf50958eb529005ed19da0", "patch": "@@ -1198,51 +1198,58 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         debug!(\"tested_candidates: {}\", total_candidate_count - candidates.len());\n         debug!(\"untested_candidates: {}\", candidates.len());\n \n-        // For each outcome of test, process the candidates that still\n-        // apply. Collect a list of blocks where control flow will\n-        // branch if one of the `target_candidate` sets is not\n-        // exhaustive.\n-        if !candidates.is_empty() {\n-            let remainder_start = &mut None;\n-            self.match_candidates(\n-                span,\n-                remainder_start,\n-                otherwise_block,\n-                candidates,\n-                fake_borrows,\n-            );\n-            otherwise_block = Some(remainder_start.unwrap());\n-        };\n-        let target_blocks: Vec<_> = target_candidates.into_iter().map(|mut candidates| {\n-            if candidates.len() != 0 {\n-                let candidate_start = &mut None;\n-                self.match_candidates(\n+        // HACK(matthewjasper) This is a closure so that we can let the test\n+        // create its blocks before the rest of the match. This currently\n+        // improves the speed of llvm when optimizing long string literal\n+        // matches\n+        let make_target_blocks = move |this: &mut Self| -> Vec<BasicBlock> {\n+            // For each outcome of test, process the candidates that still\n+            // apply. Collect a list of blocks where control flow will\n+            // branch if one of the `target_candidate` sets is not\n+            // exhaustive.\n+            if !candidates.is_empty() {\n+                let remainder_start = &mut None;\n+                this.match_candidates(\n                     span,\n-                    candidate_start,\n+                    remainder_start,\n                     otherwise_block,\n-                    &mut *candidates,\n+                    candidates,\n                     fake_borrows,\n                 );\n-                candidate_start.unwrap()\n-            } else {\n-                *otherwise_block.get_or_insert_with(|| {\n-                    let unreachable = self.cfg.start_new_block();\n-                    let source_info = self.source_info(span);\n-                    self.cfg.terminate(\n-                        unreachable,\n-                        source_info,\n-                        TerminatorKind::Unreachable,\n+                otherwise_block = Some(remainder_start.unwrap());\n+            };\n+\n+            target_candidates.into_iter().map(|mut candidates| {\n+                if candidates.len() != 0 {\n+                    let candidate_start = &mut None;\n+                    this.match_candidates(\n+                        span,\n+                        candidate_start,\n+                        otherwise_block,\n+                        &mut *candidates,\n+                        fake_borrows,\n                     );\n-                    unreachable\n-                })\n-            }\n-        }).collect();\n+                    candidate_start.unwrap()\n+                } else {\n+                    *otherwise_block.get_or_insert_with(|| {\n+                        let unreachable = this.cfg.start_new_block();\n+                        let source_info = this.source_info(span);\n+                        this.cfg.terminate(\n+                            unreachable,\n+                            source_info,\n+                            TerminatorKind::Unreachable,\n+                        );\n+                        unreachable\n+                    })\n+                }\n+            }).collect()\n+        };\n \n         self.perform_test(\n             block,\n             &match_place,\n             &test,\n-            target_blocks,\n+            make_target_blocks,\n         );\n     }\n "}, {"sha": "f93ca4b31b3a800a218bcd0cc5cf2dbc579a4f53", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 40, "deletions": 33, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a1d0266878793bc8b2bf50958eb529005ed19da0/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1d0266878793bc8b2bf50958eb529005ed19da0/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=a1d0266878793bc8b2bf50958eb529005ed19da0", "patch": "@@ -168,7 +168,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         block: BasicBlock,\n         place: &Place<'tcx>,\n         test: &Test<'tcx>,\n-        target_blocks: Vec<BasicBlock>,\n+        make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n     ) {\n         debug!(\"perform_test({:?}, {:?}: {:?}, {:?})\",\n                block,\n@@ -179,6 +179,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let source_info = self.source_info(test.span);\n         match test.kind {\n             TestKind::Switch { adt_def, ref variants } => {\n+                let target_blocks = make_target_blocks(self);\n                 // Variants is a BitVec of indexes into adt_def.variants.\n                 let num_enum_variants = adt_def.variants.len();\n                 let used_variants = variants.count();\n@@ -223,6 +224,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             TestKind::SwitchInt { switch_ty, ref options, indices: _ } => {\n+                let target_blocks = make_target_blocks(self);\n                 let terminator = if switch_ty.sty == ty::Bool {\n                     assert!(options.len() > 0 && options.len() <= 2);\n                     if let [first_bb, second_bb] = *target_blocks {\n@@ -254,38 +256,38 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             TestKind::Eq { value, ty } => {\n-                if let [success, fail] = *target_blocks {\n-                    if !ty.is_scalar() {\n-                        // Use `PartialEq::eq` instead of `BinOp::Eq`\n-                        // (the binop can only handle primitives)\n-                        self.non_scalar_compare(\n-                            block,\n-                            success,\n-                            fail,\n-                            source_info,\n-                            value,\n-                            place,\n-                            ty,\n-                        );\n-                    } else {\n+                if !ty.is_scalar() {\n+                    // Use `PartialEq::eq` instead of `BinOp::Eq`\n+                    // (the binop can only handle primitives)\n+                    self.non_scalar_compare(\n+                        block,\n+                        make_target_blocks,\n+                        source_info,\n+                        value,\n+                        place,\n+                        ty,\n+                    );\n+                } else {\n+                    if let [success, fail] = *make_target_blocks(self) {\n                         let val = Operand::Copy(place.clone());\n                         let expect = self.literal_operand(test.span, ty, value);\n                         self.compare(block, success, fail, source_info, BinOp::Eq, expect, val);\n+                    } else {\n+                        bug!(\"`TestKind::Eq` should have two target blocks\");\n                     }\n-                } else {\n-                    bug!(\"`TestKind::Eq` should have two target blocks\")\n-                };\n+                }\n             }\n \n             TestKind::Range(PatternRange { ref lo, ref hi, ty, ref end }) => {\n+                let lower_bound_success = self.cfg.start_new_block();\n+                let target_blocks = make_target_blocks(self);\n+\n                 // Test `val` by computing `lo <= val && val <= hi`, using primitive comparisons.\n                 let lo = self.literal_operand(test.span, ty, lo);\n                 let hi = self.literal_operand(test.span, ty, hi);\n                 let val = Operand::Copy(place.clone());\n \n                 if let [success, fail] = *target_blocks {\n-                    let lower_bound_success = self.cfg.start_new_block();\n-\n                     self.compare(\n                         block,\n                         lower_bound_success,\n@@ -306,6 +308,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n \n             TestKind::Len { len, op } => {\n+                let target_blocks = make_target_blocks(self);\n+\n                 let usize_ty = self.hir.usize_ty();\n                 let actual = self.temp(usize_ty, test.span);\n \n@@ -374,8 +378,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     fn non_scalar_compare(\n         &mut self,\n         block: BasicBlock,\n-        success_block: BasicBlock,\n-        fail_block: BasicBlock,\n+        make_target_blocks: impl FnOnce(&mut Self) -> Vec<BasicBlock>,\n         source_info: SourceInfo,\n         value: &'tcx ty::Const<'tcx>,\n         place: &Place<'tcx>,\n@@ -461,17 +464,21 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             from_hir_call: false,\n         });\n \n-        // check the result\n-        self.cfg.terminate(\n-            eq_block,\n-            source_info,\n-            TerminatorKind::if_(\n-                self.hir.tcx(),\n-                Operand::Move(eq_result),\n-                success_block,\n-                fail_block,\n-            ),\n-        );\n+        if let [success_block, fail_block] = *make_target_blocks(self) {\n+            // check the result\n+            self.cfg.terminate(\n+                eq_block,\n+                source_info,\n+                TerminatorKind::if_(\n+                    self.hir.tcx(),\n+                    Operand::Move(eq_result),\n+                    success_block,\n+                    fail_block,\n+                ),\n+            );\n+        } else {\n+            bug!(\"`TestKind::Eq` should have two target blocks\")\n+        }\n     }\n \n     /// Given that we are performing `test` against `test_place`, this job"}]}