{"sha": "e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU2NjZmZTg5ZGQ3ZGUzNjRmYmMyZGQ1YjJmYzk5MzQxYWNlYjcyNzY=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-10T19:14:14Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-09-10T19:38:52Z"}, "message": "Make more moves explicit in libcore", "tree": {"sha": "4e5b99d6a75c4e7a3f00d70a11f1f4ec165d0beb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e5b99d6a75c4e7a3f00d70a11f1f4ec165d0beb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "html_url": "https://github.com/rust-lang/rust/commit/e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ff268e2d53806dc5c6e95a070953440f92fa7b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff268e2d53806dc5c6e95a070953440f92fa7b8", "html_url": "https://github.com/rust-lang/rust/commit/1ff268e2d53806dc5c6e95a070953440f92fa7b8"}], "stats": {"total": 154, "additions": 77, "deletions": 77}, "files": [{"sha": "bfc5da6521430f92872f9cdd554237003b4a53f6", "filename": "src/libcore/at_vec.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fat_vec.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -50,7 +50,7 @@ pure fn capacity<T>(&&v: @[const T]) -> uint {\n pure fn build_sized<A>(size: uint, builder: fn(push: pure fn(+A))) -> @[A] {\n     let mut vec = @[];\n     unsafe { unsafe::reserve(vec, size); }\n-    builder(|+x| unsafe { unsafe::push(vec, x) });\n+    builder(|+x| unsafe { unsafe::push(vec, move x) });\n     return vec;\n }\n \n@@ -163,10 +163,10 @@ mod unsafe {\n         let repr: **VecRepr = ::unsafe::reinterpret_cast(&addr_of(v));\n         let fill = (**repr).fill;\n         if (**repr).alloc > fill {\n-            push_fast(v, initval);\n+            push_fast(v, move initval);\n         }\n         else {\n-            push_slow(v, initval);\n+            push_slow(v, move initval);\n         }\n     }\n     // This doesn't bother to make sure we have space.\n@@ -182,7 +182,7 @@ mod unsafe {\n \n     unsafe fn push_slow<T>(&v: @[const T], +initval: T) {\n         reserve_at_least(v, v.len() + 1u);\n-        push_fast(v, initval);\n+        push_fast(v, move initval);\n     }\n \n     /**"}, {"sha": "c85557c6cd8ca508dce5e7b2eccf7d908e5813aa", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -76,7 +76,7 @@ fn Port<T: Send>() -> Port<T> {\n impl<T: Send> Port<T> {\n \n     fn chan() -> Chan<T> { Chan(self) }\n-    fn send(+v: T) { self.chan().send(v) }\n+    fn send(+v: T) { self.chan().send(move v) }\n     fn recv() -> T { recv(self) }\n     fn peek() -> bool { peek(self) }\n \n@@ -85,7 +85,7 @@ impl<T: Send> Port<T> {\n impl<T: Send> Chan<T> {\n \n     fn chan() -> Chan<T> { self }\n-    fn send(+v: T) { send(self, v) }\n+    fn send(+v: T) { send(self, move v) }\n     fn recv() -> T { recv_chan(self) }\n     fn peek() -> bool { peek_chan(self) }\n \n@@ -103,17 +103,17 @@ struct PortPtr<T:Send> {\n       do task::unkillable {\n         // Once the port is detached it's guaranteed not to receive further\n         // messages\n-        let yield = 0u;\n+        let yield = 0;\n         let yieldp = ptr::addr_of(yield);\n         rustrt::rust_port_begin_detach(self.po, yieldp);\n-        if yield != 0u {\n+        if yield != 0 {\n             // Need to wait for the port to be detached\n             task::yield();\n         }\n         rustrt::rust_port_end_detach(self.po);\n \n         // Drain the port so that all the still-enqueued items get dropped\n-        while rustrt::rust_port_size(self.po) > 0u as size_t {\n+        while rustrt::rust_port_size(self.po) > 0 as size_t {\n             recv_::<T>(self.po);\n         }\n         rustrt::del_port(self.po);\n@@ -179,7 +179,7 @@ fn send<T: Send>(ch: Chan<T>, +data: T) {\n     let Chan_(p) = ch;\n     let data_ptr = ptr::addr_of(data) as *();\n     let res = rustrt::rust_port_id_send(p, data_ptr);\n-    if res != 0u unsafe {\n+    if res != 0 unsafe {\n         // Data sent successfully\n         unsafe::forget(data);\n     }\n@@ -206,35 +206,35 @@ fn peek_chan<T: Send>(ch: comm::Chan<T>) -> bool {\n \n /// Receive on a raw port pointer\n fn recv_<T: Send>(p: *rust_port) -> T {\n-    let yield = 0u;\n+    let yield = 0;\n     let yieldp = ptr::addr_of(yield);\n     let mut res;\n     res = rusti::init::<T>();\n     rustrt::port_recv(ptr::addr_of(res) as *uint, p, yieldp);\n \n-    if yield != 0u {\n+    if yield != 0 {\n         // Data isn't available yet, so res has not been initialized.\n         task::yield();\n     } else {\n         // In the absence of compiler-generated preemption points\n         // this is a good place to yield\n         task::yield();\n     }\n-    return res;\n+    move res\n }\n \n fn peek_(p: *rust_port) -> bool {\n     // Yield here before we check to see if someone sent us a message\n-    // FIXME #524, if the compilergenerates yields, we don't need this\n+    // FIXME #524, if the compiler generates yields, we don't need this\n     task::yield();\n-    rustrt::rust_port_size(p) != 0u as libc::size_t\n+    rustrt::rust_port_size(p) != 0 as libc::size_t\n }\n \n /// Receive on one of two ports\n fn select2<A: Send, B: Send>(p_a: Port<A>, p_b: Port<B>)\n     -> Either<A, B> {\n     let ports = ~[(**p_a).po, (**p_b).po];\n-    let yield = 0u, yieldp = ptr::addr_of(yield);\n+    let yield = 0, yieldp = ptr::addr_of(yield);\n \n     let mut resport: *rust_port;\n     resport = rusti::init::<*rust_port>();\n@@ -243,7 +243,7 @@ fn select2<A: Send, B: Send>(p_a: Port<A>, p_b: Port<B>)\n                                  n_ports as size_t, yieldp);\n     }\n \n-    if yield != 0u {\n+    if yield != 0 {\n         // Wait for data\n         task::yield();\n     } else {\n@@ -380,16 +380,16 @@ fn test_select2_rendezvous() {\n     let ch_a = Chan(po_a);\n     let ch_b = Chan(po_b);\n \n-    for iter::repeat(10u) {\n+    for iter::repeat(10) {\n         do task::spawn {\n-            for iter::repeat(10u) { task::yield() }\n+            for iter::repeat(10) { task::yield() }\n             send(ch_a, ~\"a\");\n         };\n \n         assert select2(po_a, po_b) == either::Left(~\"a\");\n \n         do task::spawn {\n-            for iter::repeat(10u) { task::yield() }\n+            for iter::repeat(10) { task::yield() }\n             send(ch_b, ~\"b\");\n         };\n \n@@ -404,7 +404,7 @@ fn test_select2_stress() {\n     let ch_a = Chan(po_a);\n     let ch_b = Chan(po_b);\n \n-    let msgs = 100u;\n+    let msgs = 100;\n     let times = 4u;\n \n     for iter::repeat(times) {\n@@ -490,7 +490,7 @@ fn test_listen() {\n #[test]\n #[ignore(cfg(windows))]\n fn test_port_detach_fail() {\n-    for iter::repeat(100u) {\n+    for iter::repeat(100) {\n         do task::spawn_unlinked {\n             let po = Port();\n             let ch = po.chan();"}, {"sha": "a7acceb1fe32b22b6c59a8ad7329ff193d99e1ab", "filename": "src/libcore/dlist.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdlist.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -80,7 +80,7 @@ impl<T> DListNode<T> {\n \n /// Creates a new dlist node with the given data.\n pure fn new_dlist_node<T>(+data: T) -> DListNode<T> {\n-    DListNode(@{data: data, mut linked: false,\n+    DListNode(@{data: move data, mut linked: false,\n                  mut prev: None, mut next: None})\n }\n \n@@ -92,7 +92,7 @@ pure fn DList<T>() -> DList<T> {\n /// Creates a new dlist with a single element\n pure fn from_elem<T>(+data: T) -> DList<T> {\n     let list = DList();\n-    unchecked { list.push(data); }\n+    unchecked { list.push(move data); }\n     list\n }\n \n@@ -115,7 +115,7 @@ fn concat<T>(lists: DList<DList<T>>) -> DList<T> {\n \n priv impl<T> DList<T> {\n     pure fn new_link(-data: T) -> DListLink<T> {\n-        Some(DListNode(@{data: data, mut linked: true,\n+        Some(DListNode(@{data: move data, mut linked: true,\n                           mut prev: None, mut next: None}))\n     }\n     pure fn assert_mine(nobe: DListNode<T>) {\n@@ -442,7 +442,7 @@ impl<T: Copy> DList<T> {\n                 v[index] = data;\n             }\n         }\n-        v\n+        move v\n     }\n }\n "}, {"sha": "35424a38fd8222f628a09b6af6fd061baabc5e00", "filename": "src/libcore/dvec.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdvec.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -64,18 +64,18 @@ fn DVec<A>() -> DVec<A> {\n \n /// Creates a new dvec with a single element\n fn from_elem<A>(+e: A) -> DVec<A> {\n-    DVec_({mut data: ~[mut e]})\n+    DVec_({mut data: ~[mut move e]})\n }\n \n /// Creates a new dvec with the contents of a vector\n fn from_vec<A>(+v: ~[mut A]) -> DVec<A> {\n-    DVec_({mut data: v})\n+    DVec_({mut data: move v})\n }\n \n /// Consumes the vector and returns its contents\n fn unwrap<A>(+d: DVec<A>) -> ~[mut A] {\n     let DVec_({data: v}) <- d;\n-    return v;\n+    move v\n }\n \n priv impl<A> DVec<A> {\n@@ -149,7 +149,7 @@ impl<A> DVec<A> {\n             let mut v <- v;\n             let result = vec::pop(v);\n             self.give_back(v);\n-            result\n+            move result\n         }\n     }\n \n@@ -161,7 +161,7 @@ impl<A> DVec<A> {\n             let data_ptr: *() = unsafe::reinterpret_cast(&data);\n             if data_ptr.is_null() { fail ~\"Recursive use of dvec\"; }\n             log(error, ~\"a\");\n-            self.data <- ~[mut t];\n+            self.data <- ~[mut move t];\n             vec::push_all_move(self.data, data);\n             log(error, ~\"b\");\n         }\n@@ -170,16 +170,16 @@ impl<A> DVec<A> {\n     /// Append a single item to the end of the list\n     fn push(+t: A) {\n         self.check_not_borrowed();\n-        vec::push(self.data, t);\n+        vec::push(self.data, move t);\n     }\n \n     /// Remove and return the first element\n     fn shift() -> A {\n         do self.check_out |v| {\n-            let mut v = vec::from_mut(v);\n+            let mut v = vec::from_mut(move v);\n             let result = vec::shift(v);\n-            self.give_back(vec::to_mut(v));\n-            result\n+            self.give_back(vec::to_mut(move v));\n+            move result\n         }\n     }\n \n@@ -196,7 +196,7 @@ impl<A> DVec<A> {\n         do self.check_out |v| {\n             let result = op(v);\n             self.give_back(v);\n-            result\n+            move result\n         }\n     }\n \n@@ -205,7 +205,7 @@ impl<A> DVec<A> {\n         do self.check_out |v| {\n             let result = op(v);\n             self.give_back(v);\n-            result\n+            move result\n         }\n     }\n }\n@@ -231,7 +231,7 @@ impl<A: Copy> DVec<A> {\n                 vec::push(v, ts[i]);\n                 i += 1u;\n             }\n-            v\n+            move v\n         }\n     }\n \n@@ -270,7 +270,7 @@ impl<A: Copy> DVec<A> {\n             do self.check_out |v| {\n                 let w = vec::from_mut(copy v);\n                 self.give_back(v);\n-                w\n+                move w\n             }\n         }\n     }\n@@ -297,7 +297,7 @@ impl<A: Copy> DVec<A> {\n         do self.swap |v| {\n             let mut v <- v;\n             vec::grow_set(v, idx, initval, val);\n-            v\n+            move v\n         }\n     }\n \n@@ -317,13 +317,13 @@ impl<A: Copy> DVec<A> {\n     /// Iterates over the elements in reverse order\n     #[inline(always)]\n     fn reach(f: fn(A) -> bool) {\n-        do self.swap |v| { vec::reach(v, f); v }\n+        do self.swap |v| { vec::reach(v, f); move v }\n     }\n \n     /// Iterates over the elements and indices in reverse order\n     #[inline(always)]\n     fn reachi(f: fn(uint, A) -> bool) {\n-        do self.swap |v| { vec::reachi(v, f); v }\n+        do self.swap |v| { vec::reachi(v, f); move v }\n     }\n }\n "}, {"sha": "b97fd24494038b755a5087f16a95457aa4d5082f", "filename": "src/libcore/either.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Feither.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Feither.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Feither.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -39,7 +39,7 @@ fn lefts<T: Copy, U>(eithers: &[Either<T, U>]) -> ~[T] {\n           _ => { /* fallthrough */ }\n         }\n     }\n-    return result;\n+    move result\n }\n \n fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n@@ -52,7 +52,7 @@ fn rights<T, U: Copy>(eithers: &[Either<T, U>]) -> ~[U] {\n           _ => { /* fallthrough */ }\n         }\n     }\n-    return result;\n+    move result\n }\n \n fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n@@ -72,7 +72,7 @@ fn partition<T: Copy, U: Copy>(eithers: &[Either<T, U>])\n           Right(r) => vec::push(rights, r)\n         }\n     }\n-    return {lefts: lefts, rights: rights};\n+    return {lefts: move lefts, rights: move rights};\n }\n \n pure fn flip<T: Copy, U: Copy>(eith: &Either<T, U>) -> Either<U, T> {\n@@ -114,15 +114,15 @@ pure fn unwrap_left<T,U>(+eith: Either<T,U>) -> T {\n     //! Retrieves the value in the left branch. Fails if the either is Right.\n \n     match move eith {\n-        Left(move x) => x, Right(_) => fail ~\"either::unwrap_left Right\"\n+        Left(move x) => move x, Right(_) => fail ~\"either::unwrap_left Right\"\n     }\n }\n \n pure fn unwrap_right<T,U>(+eith: Either<T,U>) -> U {\n     //! Retrieves the value in the right branch. Fails if the either is Left.\n \n     match move eith {\n-        Right(move x) => x, Left(_) => fail ~\"either::unwrap_right Left\"\n+        Right(move x) => move x, Left(_) => fail ~\"either::unwrap_right Left\"\n     }\n }\n "}, {"sha": "9fdfd7b102e8cd118e76af30a7c30b2c0d936bc3", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -201,7 +201,7 @@ fn SipState(key0: u64, key1: u64) -> SipState {\n         mut ntail : 0u,\n     };\n     (&state).reset();\n-    return state;\n+    move state\n }\n \n \n@@ -368,7 +368,7 @@ impl &SipState : Streaming {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n         for vec::each(r) |b| { s += uint::to_str(b as uint, 16u); }\n-        return s;\n+        move s\n     }\n \n     #[inline(always)]"}, {"sha": "55a13fab8e40fb04adf2dc9cc8645453568dc511", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -16,7 +16,7 @@ impl<A> IMPL_T<A>: iter::ExtendedIter<A> {\n     pure fn all(blk: fn(A) -> bool) -> bool { iter::all(self, blk) }\n     pure fn any(blk: fn(A) -> bool) -> bool { iter::any(self, blk) }\n     pure fn foldl<B>(+b0: B, blk: fn(B, A) -> B) -> B {\n-        iter::foldl(self, b0, blk)\n+        iter::foldl(self, move b0, blk)\n     }\n }\n "}, {"sha": "854e75d283844ad537cee340f1c01823938678dc", "filename": "src/libcore/iter-trait/dvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fiter-trait%2Fdvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait%2Fdvec.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -7,7 +7,7 @@ type IMPL_T<A> = dvec::DVec<A>;\n  * Attempts to access this dvec during iteration will fail.\n  */\n pure fn EACH<A>(self: IMPL_T<A>, f: fn(A) -> bool) {\n-    unsafe { self.swap(|v| { vec::each(v, f); v }) }\n+    unsafe { self.swap(|v| { vec::each(v, f); move v }) }\n }\n \n pure fn SIZE_HINT<A>(self: IMPL_T<A>) -> Option<uint> {"}, {"sha": "e9d6784136f5d79af92f0ccbf616f9fa6797d2a8", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -117,7 +117,7 @@ pure fn foldl<A,B,IA:BaseIter<A>>(self: IA, +b0: B, blk: fn(B, A) -> B) -> B {\n     for self.each |a| {\n         b = blk(b, a);\n     }\n-    return b;\n+    move b\n }\n \n pure fn to_vec<A:Copy,IA:BaseIter<A>>(self: IA) -> ~[A] {"}, {"sha": "833a4cd8b1a6d10793580c77a9e8d035b3bb3d44", "filename": "src/libcore/option.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -74,7 +74,7 @@ pure fn map_consume<T, U>(+opt: Option<T>, f: fn(+T) -> U) -> Option<U> {\n      * As `map`, but consumes the option and gives `f` ownership to avoid\n      * copying.\n      */\n-    if opt.is_some() { Some(f(option::unwrap(opt))) } else { None }\n+    if opt.is_some() { Some(f(option::unwrap(move opt))) } else { None }\n }\n \n pure fn chain<T, U>(opt: Option<T>, f: fn(T) -> Option<U>) -> Option<U> {\n@@ -101,8 +101,8 @@ pure fn or<T>(+opta: Option<T>, +optb: Option<T>) -> Option<T> {\n      * Returns the leftmost some() value, or none if both are none.\n      */\n     match opta {\n-        Some(_) => opta,\n-        _ => optb\n+        Some(_) => move opta,\n+        _ => move optb\n     }\n }\n \n@@ -112,7 +112,7 @@ pure fn while_some<T>(+x: Option<T>, blk: fn(+T) -> Option<T>) {\n \n     let mut opt <- x;\n     while opt.is_some() {\n-        opt = blk(unwrap(opt));\n+        opt = blk(unwrap(move opt));\n     }\n }\n \n@@ -137,15 +137,15 @@ pure fn get_default<T: Copy>(opt: Option<T>, def: T) -> T {\n pure fn map_default<T, U>(opt: Option<T>, +def: U, f: fn(T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n-    match opt { None => def, Some(t) => f(t) }\n+    match opt { None => move def, Some(t) => f(t) }\n }\n \n // This should replace map_default.\n pure fn map_default_ref<T, U>(opt: &Option<T>, +def: U,\n                               f: fn(x: &T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n-    match *opt { None => def, Some(ref t) => f(t) }\n+    match *opt { None => move def, Some(ref t) => f(t) }\n }\n \n // This should change to by-copy mode; use iter_ref below for by reference\n@@ -169,7 +169,7 @@ pure fn unwrap<T>(+opt: Option<T>) -> T {\n      * of option types without copying them.\n      */\n     match move opt {\n-        Some(move x) => x,\n+        Some(move x) => move x,\n         None => fail ~\"option::unwrap none\"\n     }\n }\n@@ -184,7 +184,7 @@ fn swap_unwrap<T>(opt: &mut Option<T>) -> T {\n pure fn unwrap_expect<T>(+opt: Option<T>, reason: &str) -> T {\n     //! As unwrap, but with a specified failure message.\n     if opt.is_none() { fail reason.to_unique(); }\n-    unwrap(opt)\n+    unwrap(move opt)\n }\n \n // Some of these should change to be &Option<T>, some should not. See below.\n@@ -196,7 +196,7 @@ impl<T> Option<T> {\n     pure fn chain<U>(f: fn(T) -> Option<U>) -> Option<U> { chain(self, f) }\n     /// Applies a function to the contained value or returns a default\n     pure fn map_default<U>(+def: U, f: fn(T) -> U) -> U\n-        { map_default(self, def, f) }\n+        { map_default(self, move def, f) }\n     /// Performs an operation on the contained value or does nothing\n     pure fn iter(f: fn(T)) { iter(self, f) }\n     /// Returns true if the option equals `none`\n@@ -217,7 +217,7 @@ impl<T> &Option<T> {\n     }\n     /// Applies a function to the contained value or returns a default\n     pure fn map_default_ref<U>(+def: U, f: fn(x: &T) -> U) -> U\n-        { map_default_ref(self, def, f) }\n+        { map_default_ref(self, move def, f) }\n     /// Performs an operation on the contained value by reference\n     pure fn iter_ref(f: fn(x: &T)) { iter_ref(self, f) }\n     /// Maps a `some` value from one type to another by reference"}, {"sha": "7330d3520f6cef6b5badda3ab55f35a7dee45838", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -277,7 +277,7 @@ fn map_vec<T,U:Copy,V:Copy>(\n           Err(u) => return Err(u)\n         }\n     }\n-    return Ok(vs);\n+    return Ok(move vs);\n }\n \n fn map_opt<T,U:Copy,V:Copy>(\n@@ -316,7 +316,7 @@ fn map_vec2<S,T,U:Copy,V:Copy>(ss: &[S], ts: &[T],\n         }\n         i += 1u;\n     }\n-    return Ok(vs);\n+    return Ok(move vs);\n }\n \n /**\n@@ -343,15 +343,15 @@ fn iter_vec2<S,T,U:Copy>(ss: &[S], ts: &[T],\n /// Unwraps a result, assuming it is an `ok(T)`\n fn unwrap<T, U>(+res: Result<T, U>) -> T {\n     match move res {\n-      Ok(move t) => t,\n+      Ok(move t) => move t,\n       Err(_) => fail ~\"unwrap called on an err result\"\n     }\n }\n \n /// Unwraps a result, assuming it is an `err(U)`\n fn unwrap_err<T, U>(+res: Result<T, U>) -> U {\n     match move res {\n-      Err(move u) => u,\n+      Err(move u) => move u,\n       Ok(_) => fail ~\"unwrap called on an ok result\"\n     }\n }"}, {"sha": "182a592dad2f9c6bdec657f6647b7246d69f0ceb", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -152,7 +152,7 @@ mod linear {\n             for uint::range(0, old_capacity) |i| {\n                 let mut bucket = None;\n                 bucket <-> old_buckets[i];\n-                self.insert_opt_bucket(bucket);\n+                self.insert_opt_bucket(move bucket);\n             }\n         }\n \n@@ -161,7 +161,7 @@ mod linear {\n               Some(Bucket {hash: move hash,\n                            key: move key,\n                            value: move value}) => {\n-                self.insert_internal(hash, key, value);\n+                self.insert_internal(hash, move key, move value);\n               }\n               None => {}\n             }\n@@ -213,7 +213,7 @@ mod linear {\n             }\n \n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n-            self.insert_internal(hash, k, v)\n+            self.insert_internal(hash, move k, move v)\n         }\n \n         fn remove(&mut self, k: &K) -> bool {\n@@ -247,7 +247,7 @@ mod linear {\n             while self.buckets[idx].is_some() {\n                 let mut bucket = None;\n                 bucket <-> self.buckets[idx];\n-                self.insert_opt_bucket(bucket);\n+                self.insert_opt_bucket(move bucket);\n                 idx = self.next_bucket(idx, len_buckets);\n             }\n             self.size -= 1;"}, {"sha": "21a29a6b07d320794be7d0d33b44fa03a3c5559b", "filename": "src/libcore/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fto_str.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -72,7 +72,7 @@ impl<A: ToStr> ~[A]: ToStr {\n             str::push_str(acc, elt.to_str());\n         }\n         str::push_char(acc, ']');\n-        acc\n+        move acc\n     }\n }\n "}, {"sha": "2672c5057799f296a209e5cf9f868117073c3f24", "filename": "src/libcore/tuple.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftuple.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -55,13 +55,13 @@ impl<A: Copy, B: Copy> (&[A], &[B]): ExtendedTupleOps<A,B> {\n impl<A: Copy, B: Copy> (~[A], ~[B]): ExtendedTupleOps<A,B> {\n \n     fn zip() -> ~[(A, B)] {\n-        // XXX: Bad copy\n+        // FIXME #2543: Bad copy\n         let (a, b) = copy self;\n-        vec::zip(a, b)\n+        vec::zip(move a, move b)\n     }\n \n     fn map<C>(f: fn(A, B) -> C) -> ~[C] {\n-        // XXX: Bad copy\n+        // FIXME #2543: Bad copy\n         let (a, b) = copy self;\n         vec::map2(a, b, f)\n     }"}, {"sha": "cc3d6dded6fb304d2d03c44e89f4472a36ed9591", "filename": "src/libcore/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e666fe89dd7de364fbc2dd5b2fc99341aceb7276/src%2Flibcore%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Futil.rs?ref=e666fe89dd7de364fbc2dd5b2fc99341aceb7276", "patch": "@@ -9,7 +9,7 @@ use cmp::Eq;\n  */\n \n /// The identity function.\n-pure fn id<T>(+x: T) -> T { x }\n+pure fn id<T>(+x: T) -> T { move x }\n \n /// Ignores a value.\n pure fn ignore<T>(+_x: T) { }\n@@ -47,9 +47,9 @@ fn swap<T>(x: &mut T, y: &mut T) {\n  */\n #[inline(always)]\n fn replace<T>(dest: &mut T, +src: T) -> T {\n-    let mut tmp = src;\n+    let mut tmp <- src;\n     swap(dest, &mut tmp);\n-    tmp\n+    move tmp\n }\n \n /// A non-copyable dummy type."}]}