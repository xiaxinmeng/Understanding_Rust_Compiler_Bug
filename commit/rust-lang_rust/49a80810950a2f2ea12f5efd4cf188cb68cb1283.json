{"sha": "49a80810950a2f2ea12f5efd4cf188cb68cb1283", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YTgwODEwOTUwYTJmMmVhMTJmNWVmZDRjZjE4OGNiNjhjYjEyODM=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-03-27T05:46:25Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2014-04-06T22:40:01Z"}, "message": "De-~[] Mem{Reader,Writer}", "tree": {"sha": "093ff0d95856e003e28560bc224cac574a003461", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/093ff0d95856e003e28560bc224cac574a003461"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49a80810950a2f2ea12f5efd4cf188cb68cb1283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49a80810950a2f2ea12f5efd4cf188cb68cb1283", "html_url": "https://github.com/rust-lang/rust/commit/49a80810950a2f2ea12f5efd4cf188cb68cb1283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49a80810950a2f2ea12f5efd4cf188cb68cb1283/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0e60b72ee3f5fb07b01143d82362cb42307f32d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0e60b72ee3f5fb07b01143d82362cb42307f32d", "html_url": "https://github.com/rust-lang/rust/commit/d0e60b72ee3f5fb07b01143d82362cb42307f32d"}], "stats": {"total": 131, "additions": 66, "deletions": 65}, "files": [{"sha": "4f7583f0855afe6ffe92e0d2870667eb905844d1", "filename": "src/doc/complement-cheatsheet.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Fdoc%2Fcomplement-cheatsheet.md", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Fdoc%2Fcomplement-cheatsheet.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-cheatsheet.md?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -96,7 +96,7 @@ Use the [`lines`](http://static.rust-lang.org/doc/master/std/io/trait.Buffer.htm\n use std::io::BufferedReader;\n # use std::io::MemReader;\n \n-# let reader = MemReader::new(~[]);\n+# let reader = MemReader::new(vec!());\n \n let mut reader = BufferedReader::new(reader);\n for line in reader.lines() {"}, {"sha": "025dc2a25754bc4c560b3f049fb50a69266f4b5a", "filename": "src/librand/reader.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrand%2Freader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrand%2Freader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Freader.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -23,7 +23,7 @@ use Rng;\n /// use rand::{reader, Rng};\n /// use std::io::MemReader;\n ///\n-/// let mut rng = reader::ReaderRng::new(MemReader::new(~[1,2,3,4,5,6,7,8]));\n+/// let mut rng = reader::ReaderRng::new(MemReader::new(vec!(1,2,3,4,5,6,7,8)));\n /// println!(\"{:x}\", rng.gen::<uint>());\n /// ```\n pub struct ReaderRng<R> {\n@@ -80,7 +80,7 @@ mod test {\n         // transmute from the target to avoid endianness concerns.\n         let v = ~[1u64, 2u64, 3u64];\n         let bytes: ~[u8] = unsafe {cast::transmute(v)};\n-        let mut rng = ReaderRng::new(MemReader::new(bytes));\n+        let mut rng = ReaderRng::new(MemReader::new(bytes.move_iter().collect()));\n \n         assert_eq!(rng.next_u64(), 1);\n         assert_eq!(rng.next_u64(), 2);\n@@ -91,7 +91,7 @@ mod test {\n         // transmute from the target to avoid endianness concerns.\n         let v = ~[1u32, 2u32, 3u32];\n         let bytes: ~[u8] = unsafe {cast::transmute(v)};\n-        let mut rng = ReaderRng::new(MemReader::new(bytes));\n+        let mut rng = ReaderRng::new(MemReader::new(bytes.move_iter().collect()));\n \n         assert_eq!(rng.next_u32(), 1);\n         assert_eq!(rng.next_u32(), 2);\n@@ -102,7 +102,7 @@ mod test {\n         let v = [1u8, 2, 3, 4, 5, 6, 7, 8];\n         let mut w = [0u8, .. 8];\n \n-        let mut rng = ReaderRng::new(MemReader::new(v.to_owned()));\n+        let mut rng = ReaderRng::new(MemReader::new(Vec::from_slice(v)));\n         rng.fill_bytes(w);\n \n         assert!(v == w);\n@@ -111,7 +111,7 @@ mod test {\n     #[test]\n     #[should_fail]\n     fn test_reader_rng_insufficient_bytes() {\n-        let mut rng = ReaderRng::new(MemReader::new(~[]));\n+        let mut rng = ReaderRng::new(MemReader::new(vec!()));\n         let mut v = [0u8, .. 3];\n         rng.fill_bytes(v);\n     }"}, {"sha": "0668abea2b12f1c1e7dfd4bbf24af1410ee8114a", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -681,7 +681,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = source_name(input);\n-    let src = sess.codemap().get_filemap(src_name).src.as_bytes().to_owned();\n+    let src = Vec::from_slice(sess.codemap().get_filemap(src_name).src.as_bytes());\n     let mut rdr = MemReader::new(src);\n \n     match ppm {"}, {"sha": "a9cc45d2b13d5a8b581e514b159f4e89602ab576", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -741,7 +741,7 @@ impl<'a> Liveness<'a> {\n             self.write_vars(wr, ln, |idx| self.users.get(idx).writer);\n             write!(wr, \"  precedes {}]\", self.successors.get(ln.get()).to_str());\n         }\n-        str::from_utf8_owned(wr.unwrap()).unwrap()\n+        str::from_utf8(wr.unwrap().as_slice()).unwrap().to_owned()\n     }\n \n     fn init_empty(&mut self, ln: LiveNode, succ_ln: LiveNode) {"}, {"sha": "1f080f35dfbe84311b8ce3dcb20ef476fa676818", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -34,7 +34,7 @@ pub fn highlight(src: &str, class: Option<&str>) -> ~str {\n          lexer::new_string_reader(&sess.span_diagnostic, fm),\n          class,\n          &mut out).unwrap();\n-    str::from_utf8_lossy(out.unwrap()).into_owned()\n+    str::from_utf8_lossy(out.unwrap().as_slice()).into_owned()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "3ed4ece514ad0c6d629a5744ddb09ef74e27370b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -312,7 +312,7 @@ pub fn run(mut krate: clean::Crate, dst: Path) -> io::IoResult<()> {\n         }\n         try!(write!(&mut w, \"\\\\};\"));\n \n-        str::from_utf8_owned(w.unwrap()).unwrap()\n+        str::from_utf8(w.unwrap().as_slice()).unwrap().to_owned()\n     };\n \n     // Write out the shared files. Note that these are shared among all rustdoc"}, {"sha": "2c44bb3ed33067d64579bf4b7e579e994128124a", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -388,7 +388,7 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n             let mut encoder = json::Encoder::new(&mut w as &mut io::Writer);\n             krate.encode(&mut encoder).unwrap();\n         }\n-        str::from_utf8_owned(w.unwrap()).unwrap()\n+        str::from_utf8(w.unwrap().as_slice()).unwrap().to_owned()\n     };\n     let crate_json = match json::from_str(crate_json_str) {\n         Ok(j) => j,"}, {"sha": "aff4b07f755b0a609b69b4cd0e5ce23343ff7213", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -309,7 +309,7 @@ impl<'a> Encoder<'a> {\n     }\n \n     /// Encode the specified struct into a json [u8]\n-    pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> ~[u8]  {\n+    pub fn buffer_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> Vec<u8>  {\n        //Serialize the object in a string using a writer\n         let mut m = MemWriter::new();\n         {\n@@ -322,8 +322,8 @@ impl<'a> Encoder<'a> {\n \n     /// Encode the specified struct into a json str\n     pub fn str_encode<T:Encodable<Encoder<'a>, io::IoError>>(to_encode_object: &T) -> ~str  {\n-        let buff:~[u8] = Encoder::buffer_encode(to_encode_object);\n-        str::from_utf8_owned(buff).unwrap()\n+        let buff = Encoder::buffer_encode(to_encode_object);\n+        str::from_utf8(buff.as_slice()).unwrap().to_owned()\n     }\n }\n \n@@ -484,7 +484,7 @@ impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n         let mut check_encoder = Encoder::new(&mut buf);\n         try!(f(&mut check_encoder));\n         let buf = buf.unwrap();\n-        let out = from_utf8(buf).unwrap();\n+        let out = from_utf8(buf.as_slice()).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' &&\n             out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n@@ -715,7 +715,7 @@ impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n         let mut check_encoder = PrettyEncoder::new(&mut buf);\n         try!(f(&mut check_encoder));\n         let buf = buf.unwrap();\n-        let out = from_utf8(buf).unwrap();\n+        let out = from_utf8(buf.as_slice()).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' &&\n             out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.wr, \"\\\"\")); }\n@@ -763,7 +763,7 @@ impl Json {\n     pub fn to_pretty_str(&self) -> ~str {\n         let mut s = MemWriter::new();\n         self.to_pretty_writer(&mut s as &mut io::Writer).unwrap();\n-        str::from_utf8_owned(s.unwrap()).unwrap()\n+        str::from_utf8(s.unwrap().as_slice()).unwrap().to_owned()\n     }\n \n      /// If the Json value is an Object, returns the value associated with the provided key.\n@@ -1927,7 +1927,7 @@ mod tests {\n \n         let mut m = MemWriter::new();\n         f(&mut m as &mut io::Writer);\n-        str::from_utf8_owned(m.unwrap()).unwrap()\n+        str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned()\n     }\n \n     #[test]\n@@ -2528,7 +2528,7 @@ mod tests {\n             hm.encode(&mut encoder).unwrap();\n         }\n         let bytes = mem_buf.unwrap();\n-        let json_str = from_utf8(bytes).unwrap();\n+        let json_str = from_utf8(bytes.as_slice()).unwrap();\n         match from_str(json_str) {\n             Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -2548,7 +2548,7 @@ mod tests {\n             hm.encode(&mut encoder).unwrap();\n         }\n         let bytes = mem_buf.unwrap();\n-        let json_str = from_utf8(bytes).unwrap();\n+        let json_str = from_utf8(bytes.as_slice()).unwrap();\n         match from_str(json_str) {\n             Err(_) => fail!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go"}, {"sha": "6514743c42e67fdbb285a67ac4155d0f39a0a90a", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -490,7 +490,7 @@ use repr;\n use result::{Ok, Err};\n use str::StrSlice;\n use str;\n-use slice::ImmutableVector;\n+use slice::{Vector, ImmutableVector};\n use slice;\n \n pub use self::num::radix;\n@@ -795,7 +795,7 @@ pub fn format(args: &Arguments) -> ~str {\n pub unsafe fn format_unsafe(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n     let mut output = MemWriter::new();\n     write_unsafe(&mut output as &mut io::Writer, fmt, args).unwrap();\n-    return str::from_utf8_owned(output.unwrap()).unwrap();\n+    return str::from_utf8(output.unwrap().as_slice()).unwrap().to_owned();\n }\n \n impl<'a> Formatter<'a> {"}, {"sha": "c9d412973ec7ea517ed44796a361ed7730453665", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -405,7 +405,7 @@ mod test {\n \n     #[test]\n     fn test_buffered_reader() {\n-        let inner = MemReader::new(~[0, 1, 2, 3, 4]);\n+        let inner = MemReader::new(vec!(0, 1, 2, 3, 4));\n         let mut reader = BufferedReader::with_capacity(2, inner);\n \n         let mut buf = [0, 0, 0];\n@@ -502,7 +502,7 @@ mod test {\n \n     #[test]\n     fn test_read_until() {\n-        let inner = MemReader::new(~[0, 1, 2, 1, 0]);\n+        let inner = MemReader::new(vec!(0, 1, 2, 1, 0));\n         let mut reader = BufferedReader::with_capacity(2, inner);\n         assert_eq!(reader.read_until(0), Ok(vec!(0)));\n         assert_eq!(reader.read_until(2), Ok(vec!(1, 2)));\n@@ -533,7 +533,7 @@ mod test {\n \n     #[test]\n     fn test_read_line() {\n-        let in_buf = MemReader::new(bytes!(\"a\\nb\\nc\").to_owned());\n+        let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         assert_eq!(reader.read_line(), Ok(~\"a\\n\"));\n         assert_eq!(reader.read_line(), Ok(~\"b\\n\"));\n@@ -543,7 +543,7 @@ mod test {\n \n     #[test]\n     fn test_lines() {\n-        let in_buf = MemReader::new(bytes!(\"a\\nb\\nc\").to_owned());\n+        let in_buf = MemReader::new(Vec::from_slice(bytes!(\"a\\nb\\nc\")));\n         let mut reader = BufferedReader::with_capacity(2, in_buf);\n         let mut it = reader.lines();\n         assert_eq!(it.next(), Some(Ok(~\"a\\n\")));"}, {"sha": "f87f4a69f17a6d32e1f7beb1bbbf485f2991990b", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -267,7 +267,7 @@ mod test {\n \n     #[test]\n     fn read_byte() {\n-        let mut reader = MemReader::new(~[10]);\n+        let mut reader = MemReader::new(vec!(10));\n         let byte = reader.read_byte();\n         assert!(byte == Ok(10));\n     }\n@@ -321,7 +321,7 @@ mod test {\n \n     #[test]\n     fn read_bytes() {\n-        let mut reader = MemReader::new(~[10, 11, 12, 13]);\n+        let mut reader = MemReader::new(vec!(10, 11, 12, 13));\n         let bytes = reader.read_exact(4).unwrap();\n         assert!(bytes == vec!(10, 11, 12, 13));\n     }\n@@ -337,13 +337,13 @@ mod test {\n \n     #[test]\n     fn read_bytes_eof() {\n-        let mut reader = MemReader::new(~[10, 11]);\n+        let mut reader = MemReader::new(vec!(10, 11));\n         assert!(reader.read_exact(4).is_err());\n     }\n \n     #[test]\n     fn push_exact() {\n-        let mut reader = MemReader::new(~[10, 11, 12, 13]);\n+        let mut reader = MemReader::new(vec!(10, 11, 12, 13));\n         let mut buf = vec!(8, 9);\n         reader.push_exact(&mut buf, 4).unwrap();\n         assert!(buf == vec!(8, 9, 10, 11, 12, 13));\n@@ -361,7 +361,7 @@ mod test {\n \n     #[test]\n     fn push_exact_eof() {\n-        let mut reader = MemReader::new(~[10, 11]);\n+        let mut reader = MemReader::new(vec!(10, 11));\n         let mut buf = vec!(8, 9);\n         assert!(reader.push_exact(&mut buf, 4).is_err());\n         assert!(buf == vec!(8, 9, 10, 11));"}, {"sha": "1cf6ed9a5d97dd9d4d6b7652451f803d24187ff6", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -18,6 +18,7 @@ use io;\n use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use slice;\n use slice::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n+use vec::Vec;\n \n fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n     // compute offset as signed and clamp to prevent overflow\n@@ -49,10 +50,10 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n /// let mut w = MemWriter::new();\n /// w.write([0, 1, 2]);\n ///\n-/// assert_eq!(w.unwrap(), ~[0, 1, 2]);\n+/// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n /// ```\n pub struct MemWriter {\n-    buf: ~[u8],\n+    buf: Vec<u8>,\n     pos: uint,\n }\n \n@@ -64,7 +65,7 @@ impl MemWriter {\n     /// Create a new `MemWriter`, allocating at least `n` bytes for\n     /// the internal buffer.\n     pub fn with_capacity(n: uint) -> MemWriter {\n-        MemWriter { buf: slice::with_capacity(n), pos: 0 }\n+        MemWriter { buf: Vec::with_capacity(n), pos: 0 }\n     }\n \n     /// Acquires an immutable reference to the underlying buffer of this\n@@ -75,7 +76,7 @@ impl MemWriter {\n     pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n \n     /// Unwraps this `MemWriter`, returning the underlying buffer\n-    pub fn unwrap(self) -> ~[u8] { self.buf }\n+    pub fn unwrap(self) -> Vec<u8> { self.buf }\n }\n \n impl Writer for MemWriter {\n@@ -127,19 +128,19 @@ impl Seek for MemWriter {\n /// # #[allow(unused_must_use)];\n /// use std::io::MemReader;\n ///\n-/// let mut r = MemReader::new(~[0, 1, 2]);\n+/// let mut r = MemReader::new(vec!(0, 1, 2));\n ///\n /// assert_eq!(r.read_to_end().unwrap(), vec!(0, 1, 2));\n /// ```\n pub struct MemReader {\n-    buf: ~[u8],\n+    buf: Vec<u8>,\n     pos: uint\n }\n \n impl MemReader {\n     /// Creates a new `MemReader` which will read the buffer given. The buffer\n     /// can be re-acquired through `unwrap`\n-    pub fn new(buf: ~[u8]) -> MemReader {\n+    pub fn new(buf: Vec<u8>) -> MemReader {\n         MemReader {\n             buf: buf,\n             pos: 0\n@@ -159,7 +160,7 @@ impl MemReader {\n     pub fn get_ref<'a>(&'a self) -> &'a [u8] { self.buf.as_slice() }\n \n     /// Unwraps this `MemReader`, returning the underlying buffer\n-    pub fn unwrap(self) -> ~[u8] { self.buf }\n+    pub fn unwrap(self) -> Vec<u8> { self.buf }\n }\n \n impl Reader for MemReader {\n@@ -425,7 +426,7 @@ mod test {\n \n     #[test]\n     fn test_mem_reader() {\n-        let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         let mut buf = [];\n         assert_eq!(reader.read(buf), Ok(0));\n         assert_eq!(reader.tell(), Ok(0));\n@@ -440,7 +441,7 @@ mod test {\n         assert_eq!(reader.read(buf), Ok(3));\n         assert_eq!(buf.slice(0, 3), &[5, 6, 7]);\n         assert!(reader.read(buf).is_err());\n-        let mut reader = MemReader::new(~[0, 1, 2, 3, 4, 5, 6, 7]);\n+        let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n         assert!(reader.read(buf).is_err());\n@@ -525,7 +526,7 @@ mod test {\n         r.seek(10, SeekSet).unwrap();\n         assert!(r.read(&mut []).is_err());\n \n-        let mut r = MemReader::new(~[10]);\n+        let mut r = MemReader::new(vec!(10));\n         r.seek(10, SeekSet).unwrap();\n         assert!(r.read(&mut []).is_err());\n \n@@ -545,7 +546,7 @@ mod test {\n         let mut r = BufReader::new(buf);\n         assert!(r.seek(-1, SeekSet).is_err());\n \n-        let mut r = MemReader::new(~[10]);\n+        let mut r = MemReader::new(vec!(10));\n         assert!(r.seek(-1, SeekSet).is_err());\n \n         let mut r = MemWriter::new();\n@@ -558,7 +559,7 @@ mod test {\n \n     #[test]\n     fn io_fill() {\n-        let mut r = MemReader::new(~[1, 2, 3, 4, 5, 6, 7, 8]);\n+        let mut r = MemReader::new(vec!(1, 2, 3, 4, 5, 6, 7, 8));\n         let mut buf = [0, ..3];\n         assert_eq!(r.fill(buf), Ok(()));\n         assert_eq!(buf.as_slice(), &[1, 2, 3]);"}, {"sha": "a69f6c10abf8ed03c99f1497bcf7e0caf0948e5e", "filename": "src/libstd/io/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Fio%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Fio%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fresult.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -87,7 +87,7 @@ mod test {\n         let mut writer: io::IoResult<MemWriter> = Ok(MemWriter::new());\n         writer.write([0, 1, 2]).unwrap();\n         writer.flush().unwrap();\n-        assert_eq!(writer.unwrap().unwrap(), ~[0, 1, 2]);\n+        assert_eq!(writer.unwrap().unwrap(), vec!(0, 1, 2));\n     }\n \n     #[test]\n@@ -108,7 +108,7 @@ mod test {\n     #[test]\n     fn test_option_reader() {\n         let mut reader: io::IoResult<MemReader> =\n-            Ok(MemReader::new(~[0, 1, 2, 3]));\n+            Ok(MemReader::new(vec!(0, 1, 2, 3)));\n         let mut buf = [0, 0];\n         reader.read(buf).unwrap();\n         assert_eq!(buf.as_slice(), &[0, 1]);"}, {"sha": "d8c87e6c63450595eb922e4ebf957df41eca24c8", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -204,7 +204,7 @@ mod test {\n \n     #[test]\n     fn test_limit_reader_unlimited() {\n-        let mut r = MemReader::new(~[0, 1, 2]);\n+        let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 4);\n             assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n@@ -213,7 +213,7 @@ mod test {\n \n     #[test]\n     fn test_limit_reader_limited() {\n-        let mut r = MemReader::new(~[0, 1, 2]);\n+        let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 2);\n             assert_eq!(vec!(0, 1), r.read_to_end().unwrap());\n@@ -223,7 +223,7 @@ mod test {\n \n     #[test]\n     fn test_limit_reader_limit() {\n-        let r = MemReader::new(~[0, 1, 2]);\n+        let r = MemReader::new(vec!(0, 1, 2));\n         let mut r = LimitReader::new(r, 3);\n         assert_eq!(3, r.limit());\n         assert_eq!(0, r.read_byte().unwrap());\n@@ -285,26 +285,26 @@ mod test {\n \n     #[test]\n     fn test_chained_reader() {\n-        let rs = ~[MemReader::new(~[0, 1]), MemReader::new(~[]),\n-                   MemReader::new(~[2, 3])];\n+        let rs = ~[MemReader::new(vec!(0, 1)), MemReader::new(vec!()),\n+                   MemReader::new(vec!(2, 3))];\n         let mut r = ChainedReader::new(rs.move_iter());\n         assert_eq!(vec!(0, 1, 2, 3), r.read_to_end().unwrap());\n     }\n \n     #[test]\n     fn test_tee_reader() {\n-        let mut r = TeeReader::new(MemReader::new(~[0, 1, 2]),\n+        let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n                                    MemWriter::new());\n         assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n         let (_, w) = r.unwrap();\n-        assert_eq!(~[0, 1, 2], w.unwrap());\n+        assert_eq!(vec!(0, 1, 2), w.unwrap());\n     }\n \n     #[test]\n     fn test_copy() {\n-        let mut r = MemReader::new(~[0, 1, 2, 3, 4]);\n+        let mut r = MemReader::new(vec!(0, 1, 2, 3, 4));\n         let mut w = MemWriter::new();\n         copy(&mut r, &mut w).unwrap();\n-        assert_eq!(~[0, 1, 2, 3, 4], w.unwrap());\n+        assert_eq!(vec!(0, 1, 2, 3, 4), w.unwrap());\n     }\n }"}, {"sha": "66f88522d5ff610dfc206056999a3aa3e440caf7", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -28,7 +28,7 @@ use reflect::{MovePtr, align};\n use result::{Ok, Err};\n use str::StrSlice;\n use to_str::ToStr;\n-use slice::OwnedVector;\n+use slice::{Vector, OwnedVector};\n use intrinsics::{Disr, Opaque, TyDesc, TyVisitor, get_tydesc, visit_tydesc};\n use raw;\n \n@@ -617,7 +617,7 @@ pub fn repr_to_str<T>(t: &T) -> ~str {\n \n     let mut result = io::MemWriter::new();\n     write_repr(&mut result as &mut io::Writer, t).unwrap();\n-    str::from_utf8_owned(result.unwrap()).unwrap()\n+    str::from_utf8(result.unwrap().as_slice()).unwrap().to_owned()\n }\n \n #[cfg(test)]\n@@ -635,7 +635,7 @@ fn test_repr() {\n     fn exact_test<T>(t: &T, e:&str) {\n         let mut m = io::MemWriter::new();\n         write_repr(&mut m as &mut io::Writer, t).unwrap();\n-        let s = str::from_utf8_owned(m.unwrap()).unwrap();\n+        let s = str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned();\n         assert_eq!(s.as_slice(), e);\n     }\n "}, {"sha": "bf8c15c20abbd0e09641bb0cf0321fb515891e39", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -756,7 +756,7 @@ mod test {\n     macro_rules! t( ($a:expr, $b:expr) => ({\n         let mut m = MemWriter::new();\n         super::demangle(&mut m, $a).unwrap();\n-        assert_eq!(str::from_utf8_owned(m.unwrap()).unwrap(), $b.to_owned());\n+        assert_eq!(str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned(), $b.to_owned());\n     }) )\n \n     #[test]"}, {"sha": "d04aa4082c45c4e533a5a4870a38986f30527a3b", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -1015,7 +1015,7 @@ mod tests {\n             use std::io::MemWriter;\n             let mut m = MemWriter::new();\n             write_boxplot(&mut m as &mut io::Writer, s, 30).unwrap();\n-            let out = str::from_utf8_owned(m.unwrap()).unwrap();\n+            let out = str::from_utf8(m.unwrap().as_slice()).unwrap().to_owned();\n             assert_eq!(out, expected);\n         }\n "}, {"sha": "cd8e36b3c93acd83fd0fa027913498cd724b21b7", "filename": "src/liburl/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Fliburl%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Fliburl%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliburl%2Flib.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -460,7 +460,7 @@ pub fn query_to_str(query: &Query) -> ~str {\n         write!(&mut writer, \"{}={}\", encode_component(*k),\n                encode_component(*v));\n     }\n-    str::from_utf8_lossy(writer.unwrap()).into_owned()\n+    str::from_utf8_lossy(writer.unwrap().as_slice()).into_owned()\n }\n \n /**"}, {"sha": "af1958127f97488b699e01a1a2b4c25ab02d4abb", "filename": "src/libworkcache/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibworkcache%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Flibworkcache%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibworkcache%2Flib.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -256,7 +256,7 @@ fn json_encode<'a, T:Encodable<json::Encoder<'a>, io::IoError>>(t: &T) -> ~str {\n     let mut writer = MemWriter::new();\n     let mut encoder = json::Encoder::new(&mut writer as &mut io::Writer);\n     let _ = t.encode(&mut encoder);\n-    str::from_utf8_owned(writer.unwrap()).unwrap()\n+    str::from_utf8(writer.unwrap().as_slice()).unwrap().to_owned()\n }\n \n // FIXME(#5121)"}, {"sha": "4c367b8539490ce9acffa3fa0ca1f910e4d45e0d", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -154,7 +154,7 @@ fn main() {\n \n     let rdr = if os::getenv(\"RUST_BENCH\").is_some() {\n         let foo = include_bin!(\"shootout-k-nucleotide.data\");\n-        ~MemReader::new(foo.to_owned()) as ~Reader\n+        ~MemReader::new(Vec::from_slice(foo)) as ~Reader\n     } else {\n         ~stdio::stdin() as ~Reader\n     };"}, {"sha": "1676463e544dbec8d98db0af06ce2df5e0baa08c", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49a80810950a2f2ea12f5efd4cf188cb68cb1283/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=49a80810950a2f2ea12f5efd4cf188cb68cb1283", "patch": "@@ -174,7 +174,7 @@ fn test_write() {\n         writeln!(w, \"{foo}\", foo=\"bar\");\n     }\n \n-    let s = str::from_utf8_owned(buf.unwrap()).unwrap();\n+    let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_owned();\n     t!(s, \"34helloline\\nbar\\n\");\n }\n \n@@ -198,7 +198,7 @@ fn test_format_args() {\n         format_args!(|args| { fmt::write(w, args); }, \"test\");\n         format_args!(|args| { fmt::write(w, args); }, \"{test}\", test=3);\n     }\n-    let s = str::from_utf8_owned(buf.unwrap()).unwrap();\n+    let s = str::from_utf8(buf.unwrap().as_slice()).unwrap().to_owned();\n     t!(s, \"1test3\");\n \n     let s = format_args!(fmt::format, \"hello {}\", \"world\");"}]}