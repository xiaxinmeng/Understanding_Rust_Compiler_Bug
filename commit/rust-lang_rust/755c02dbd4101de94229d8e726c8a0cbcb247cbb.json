{"sha": "755c02dbd4101de94229d8e726c8a0cbcb247cbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1NWMwMmRiZDQxMDFkZTk0MjI5ZDhlNzI2YzhhMGNiY2IyNDdjYmI=", "commit": {"author": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-09-18T20:42:35Z"}, "committer": {"name": "QuietMisdreavus", "email": "grey@quietmisdreavus.net", "date": "2018-09-20T10:54:30Z"}, "message": "filter collected trait impls against items in the crate", "tree": {"sha": "1f8af00ab6f6723eb7d7e7f63bc9bea55adb6262", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f8af00ab6f6723eb7d7e7f63bc9bea55adb6262"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/755c02dbd4101de94229d8e726c8a0cbcb247cbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/755c02dbd4101de94229d8e726c8a0cbcb247cbb", "html_url": "https://github.com/rust-lang/rust/commit/755c02dbd4101de94229d8e726c8a0cbcb247cbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/755c02dbd4101de94229d8e726c8a0cbcb247cbb/comments", "author": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "committer": {"login": "QuietMisdreavus", "id": 5217170, "node_id": "MDQ6VXNlcjUyMTcxNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/5217170?v=4", "gravatar_id": "", "url": "https://api.github.com/users/QuietMisdreavus", "html_url": "https://github.com/QuietMisdreavus", "followers_url": "https://api.github.com/users/QuietMisdreavus/followers", "following_url": "https://api.github.com/users/QuietMisdreavus/following{/other_user}", "gists_url": "https://api.github.com/users/QuietMisdreavus/gists{/gist_id}", "starred_url": "https://api.github.com/users/QuietMisdreavus/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/QuietMisdreavus/subscriptions", "organizations_url": "https://api.github.com/users/QuietMisdreavus/orgs", "repos_url": "https://api.github.com/users/QuietMisdreavus/repos", "events_url": "https://api.github.com/users/QuietMisdreavus/events{/privacy}", "received_events_url": "https://api.github.com/users/QuietMisdreavus/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "354507e61f303d6c86fa0f832e1081d40c2d89c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/354507e61f303d6c86fa0f832e1081d40c2d89c2", "html_url": "https://github.com/rust-lang/rust/commit/354507e61f303d6c86fa0f832e1081d40c2d89c2"}], "stats": {"total": 209, "additions": 149, "deletions": 60}, "files": [{"sha": "70e1a9b0ebc9d9f40f0414bbdb366df3275a21c5", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 149, "deletions": 60, "changes": 209, "blob_url": "https://github.com/rust-lang/rust/blob/755c02dbd4101de94229d8e726c8a0cbcb247cbb/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/755c02dbd4101de94229d8e726c8a0cbcb247cbb/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=755c02dbd4101de94229d8e726c8a0cbcb247cbb", "patch": "@@ -10,6 +10,9 @@\n \n use clean::*;\n \n+use rustc::util::nodemap::FxHashSet;\n+use rustc::hir::def_id::DefId;\n+\n use super::Pass;\n use core::DocContext;\n use fold::DocFolder;\n@@ -22,71 +25,118 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext) -> Crate {\n     let mut synth = SyntheticImplCollector::new(cx);\n     let mut krate = synth.fold_crate(krate);\n \n-    if let Some(ref mut it) = krate.module {\n-        if let ModuleItem(Module { ref mut items, .. }) = it.inner {\n-            items.extend(synth.impls);\n+    let prims: FxHashSet<PrimitiveType> =\n+        krate.primitives.iter().map(|p| p.1).collect();\n \n-            for &cnum in cx.tcx.crates().iter() {\n-                for &did in cx.tcx.all_trait_implementations(cnum).iter() {\n-                    inline::build_impl(cx, did, items);\n-                }\n-            }\n+    let crate_items = {\n+        let mut coll = ItemCollector::new();\n+        krate = coll.fold_crate(krate);\n+        coll.items\n+    };\n \n-            // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n-            // doesn't work with it anyway, so pull them from the HIR map instead\n-            for &trait_did in cx.all_traits.iter() {\n-                for &impl_node in cx.tcx.hir.trait_impls(trait_did) {\n-                    let impl_did = cx.tcx.hir.local_def_id(impl_node);\n-                    inline::build_impl(cx, impl_did, items);\n-                }\n-            }\n+    let mut new_items = Vec::new();\n+\n+    for &cnum in cx.tcx.crates().iter() {\n+        for &did in cx.tcx.all_trait_implementations(cnum).iter() {\n+            inline::build_impl(cx, did, &mut new_items);\n+        }\n+    }\n \n-            // Also try to inline primitive impls from other crates.\n-            let lang_items = cx.tcx.lang_items();\n-            let primitive_impls = [\n-                lang_items.isize_impl(),\n-                lang_items.i8_impl(),\n-                lang_items.i16_impl(),\n-                lang_items.i32_impl(),\n-                lang_items.i64_impl(),\n-                lang_items.i128_impl(),\n-                lang_items.usize_impl(),\n-                lang_items.u8_impl(),\n-                lang_items.u16_impl(),\n-                lang_items.u32_impl(),\n-                lang_items.u64_impl(),\n-                lang_items.u128_impl(),\n-                lang_items.f32_impl(),\n-                lang_items.f64_impl(),\n-                lang_items.f32_runtime_impl(),\n-                lang_items.f64_runtime_impl(),\n-                lang_items.char_impl(),\n-                lang_items.str_impl(),\n-                lang_items.slice_impl(),\n-                lang_items.slice_u8_impl(),\n-                lang_items.str_alloc_impl(),\n-                lang_items.slice_alloc_impl(),\n-                lang_items.slice_u8_alloc_impl(),\n-                lang_items.const_ptr_impl(),\n-                lang_items.mut_ptr_impl(),\n-            ];\n-\n-            for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n-                if !def_id.is_local() {\n-                    inline::build_impl(cx, def_id, items);\n-\n-                    let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n-                    let blanket_impls = get_blanket_impls_with_def_id(cx, def_id);\n-                    let mut renderinfo = cx.renderinfo.borrow_mut();\n-\n-                    let new_impls: Vec<Item> = auto_impls.into_iter()\n-                        .chain(blanket_impls.into_iter())\n-                        .filter(|i| renderinfo.inlined.insert(i.def_id))\n-                        .collect();\n-\n-                    items.extend(new_impls);\n+    // Also try to inline primitive impls from other crates.\n+    let lang_items = cx.tcx.lang_items();\n+    let primitive_impls = [\n+        lang_items.isize_impl(),\n+        lang_items.i8_impl(),\n+        lang_items.i16_impl(),\n+        lang_items.i32_impl(),\n+        lang_items.i64_impl(),\n+        lang_items.i128_impl(),\n+        lang_items.usize_impl(),\n+        lang_items.u8_impl(),\n+        lang_items.u16_impl(),\n+        lang_items.u32_impl(),\n+        lang_items.u64_impl(),\n+        lang_items.u128_impl(),\n+        lang_items.f32_impl(),\n+        lang_items.f64_impl(),\n+        lang_items.f32_runtime_impl(),\n+        lang_items.f64_runtime_impl(),\n+        lang_items.char_impl(),\n+        lang_items.str_impl(),\n+        lang_items.slice_impl(),\n+        lang_items.slice_u8_impl(),\n+        lang_items.str_alloc_impl(),\n+        lang_items.slice_alloc_impl(),\n+        lang_items.slice_u8_alloc_impl(),\n+        lang_items.const_ptr_impl(),\n+        lang_items.mut_ptr_impl(),\n+    ];\n+\n+    for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {\n+        if !def_id.is_local() {\n+            inline::build_impl(cx, def_id, &mut new_items);\n+\n+            let auto_impls = get_auto_traits_with_def_id(cx, def_id);\n+            let blanket_impls = get_blanket_impls_with_def_id(cx, def_id);\n+            let mut renderinfo = cx.renderinfo.borrow_mut();\n+\n+            let new_impls: Vec<Item> = auto_impls.into_iter()\n+                .chain(blanket_impls.into_iter())\n+                .filter(|i| renderinfo.inlined.insert(i.def_id))\n+                .collect();\n+\n+            new_items.extend(new_impls);\n+        }\n+    }\n+\n+    let mut cleaner = BadImplStripper {\n+        prims,\n+        items: crate_items,\n+    };\n+\n+    // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n+    for it in &new_items {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = it.inner {\n+            if cleaner.keep_item(for_) && trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n+                let target = items.iter().filter_map(|item| {\n+                    match item.inner {\n+                        TypedefItem(ref t, true) => Some(&t.type_),\n+                        _ => None,\n+                    }\n+                }).next().expect(\"Deref impl without Target type\");\n+\n+                if let Some(prim) = target.primitive_type() {\n+                    cleaner.prims.insert(prim);\n+                } else if let Some(did) = target.def_id() {\n+                    cleaner.items.insert(did);\n                 }\n             }\n+        }\n+    }\n+\n+    new_items.retain(|it| {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = it.inner {\n+            cleaner.keep_item(for_) ||\n+                trait_.as_ref().map_or(false, |t| cleaner.keep_item(t)) ||\n+                blanket_impl.is_some()\n+        } else {\n+            true\n+        }\n+    });\n+\n+    // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n+    // doesn't work with it anyway, so pull them from the HIR map instead\n+    for &trait_did in cx.all_traits.iter() {\n+        for &impl_node in cx.tcx.hir.trait_impls(trait_did) {\n+            let impl_did = cx.tcx.hir.local_def_id(impl_node);\n+            inline::build_impl(cx, impl_did, &mut new_items);\n+        }\n+    }\n+\n+    if let Some(ref mut it) = krate.module {\n+        if let ModuleItem(Module { ref mut items, .. }) = it.inner {\n+            items.extend(synth.impls);\n+            items.extend(new_items);\n         } else {\n             panic!(\"collect-trait-impls can't run\");\n         }\n@@ -128,3 +178,42 @@ impl<'a, 'tcx, 'rcx, 'cstore> DocFolder for SyntheticImplCollector<'a, 'tcx, 'rc\n         self.fold_item_recur(i)\n     }\n }\n+\n+#[derive(Default)]\n+struct ItemCollector {\n+    items: FxHashSet<DefId>,\n+}\n+\n+impl ItemCollector {\n+    fn new() -> Self {\n+        Self::default()\n+    }\n+}\n+\n+impl DocFolder for ItemCollector {\n+    fn fold_item(&mut self, i: Item) -> Option<Item> {\n+        self.items.insert(i.def_id);\n+\n+        self.fold_item_recur(i)\n+    }\n+}\n+\n+struct BadImplStripper {\n+    prims: FxHashSet<PrimitiveType>,\n+    items: FxHashSet<DefId>,\n+}\n+\n+impl BadImplStripper {\n+    fn keep_item(&self, ty: &Type) -> bool {\n+        if let Generic(_) = ty {\n+            // keep impls made on generics\n+            true\n+        } else if let Some(prim) = ty.primitive_type() {\n+            self.prims.contains(&prim)\n+        } else if let Some(did) = ty.def_id() {\n+            self.items.contains(&did)\n+        } else {\n+            false\n+        }\n+    }\n+}"}]}