{"sha": "ede29581d2eb856dfae5c37deee396235f3cf6a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVkZTI5NTgxZDJlYjg1NmRmYWU1YzM3ZGVlZTM5NjIzNWYzY2Y2YTA=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-24T10:56:02Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2016-05-24T10:56:02Z"}, "message": "`mir::dataflow::sanity_check`: extract an `fn each_block` to simplify presentation.\n\nAs a drive-by: unified pair of match arms that flowed to `bug!`, and\nreplaced `bug!` invocation with a diagnostic `span_err` invocation.", "tree": {"sha": "39d7bb7ac3ffb8472f33f17ad9544e031150c012", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39d7bb7ac3ffb8472f33f17ad9544e031150c012"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ede29581d2eb856dfae5c37deee396235f3cf6a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ede29581d2eb856dfae5c37deee396235f3cf6a0", "html_url": "https://github.com/rust-lang/rust/commit/ede29581d2eb856dfae5c37deee396235f3cf6a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ede29581d2eb856dfae5c37deee396235f3cf6a0/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8c6d1c70889d07b39076b025885ce4c00de4e8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8c6d1c70889d07b39076b025885ce4c00de4e8c", "html_url": "https://github.com/rust-lang/rust/commit/b8c6d1c70889d07b39076b025885ce4c00de4e8c"}], "stats": {"total": 162, "additions": 86, "deletions": 76}, "files": [{"sha": "932975b88084b6e87e451a27ce7d93c5655088fb", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/sanity_check.rs", "status": "modified", "additions": 86, "deletions": 76, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/ede29581d2eb856dfae5c37deee396235f3cf6a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ede29581d2eb856dfae5c37deee396235f3cf6a0/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fsanity_check.rs?ref=ede29581d2eb856dfae5c37deee396235f3cf6a0", "patch": "@@ -51,92 +51,102 @@ pub fn sanity_check_via_rustc_peek<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let blocks = mir.all_basic_blocks();\n     'next_block: for bb in blocks {\n-        let bb_data = mir.basic_block_data(bb);\n-        let &repr::BasicBlockData { ref statements,\n-                                    ref terminator,\n-                                    is_cleanup: _ } = bb_data;\n-\n-        let (args, span) = match is_rustc_peek(tcx, terminator) {\n-            Some(args_and_span) => args_and_span,\n-            None => continue,\n-        };\n-        assert!(args.len() == 1);\n-        let peek_arg_lval = match args[0] {\n-            repr::Operand::Consume(ref lval @ repr::Lvalue::Temp(_)) => {\n-                lval\n-            }\n-            repr::Operand::Consume(_) => {\n-                bug!(\"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n-            }\n-            repr::Operand::Constant(_) => {\n-                bug!(\"dataflow::sanity_check cannot feed a constant to rustc_peek.\");\n-            }\n-        };\n+        each_block(tcx, mir, flow_ctxt, results, bb);\n+    }\n+}\n \n-        let mut entry = results.0.sets.on_entry_set_for(bb.index()).to_owned();\n-        let mut gen = results.0.sets.gen_set_for(bb.index()).to_owned();\n-        let mut kill = results.0.sets.kill_set_for(bb.index()).to_owned();\n+fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                           mir: &Mir<'tcx>,\n+                           flow_ctxt: &O::Ctxt,\n+                           results: &DataflowResults<O>,\n+                           bb: repr::BasicBlock) where\n+    O: BitDenotation<Bit=MovePath<'tcx>, Idx=MovePathIndex>, O::Ctxt: HasMoveData<'tcx>\n+{\n+    let bb_data = mir.basic_block_data(bb);\n+    let &repr::BasicBlockData { ref statements,\n+                                ref terminator,\n+                                is_cleanup: _ } = bb_data;\n+\n+    let (args, span) = match is_rustc_peek(tcx, terminator) {\n+        Some(args_and_span) => args_and_span,\n+        None => return,\n+    };\n+    assert!(args.len() == 1);\n+    let peek_arg_lval = match args[0] {\n+        repr::Operand::Consume(ref lval @ repr::Lvalue::Temp(_)) => {\n+            lval\n+        }\n+        repr::Operand::Consume(_) |\n+        repr::Operand::Constant(_) => {\n+            tcx.sess.diagnostic().span_err(\n+                span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n+            return;\n+        }\n+    };\n \n-        let move_data = flow_ctxt.move_data();\n+    let mut entry = results.0.sets.on_entry_set_for(bb.index()).to_owned();\n+    let mut gen = results.0.sets.gen_set_for(bb.index()).to_owned();\n+    let mut kill = results.0.sets.kill_set_for(bb.index()).to_owned();\n \n-        // Emulate effect of all statements in the block up to (but\n-        // not including) the borrow within `peek_arg_lval`. Do *not*\n-        // include call to `peek_arg_lval` itself (since we are\n-        // peeking the state of the argument at time immediate\n-        // preceding Call to `rustc_peek`).\n+    let move_data = flow_ctxt.move_data();\n \n-        let mut sets = super::BlockSets { on_entry: &mut entry,\n-                                          gen_set: &mut gen,\n-                                          kill_set: &mut kill };\n+    // Emulate effect of all statements in the block up to (but not\n+    // including) the borrow within `peek_arg_lval`. Do *not* include\n+    // call to `peek_arg_lval` itself (since we are peeking the state\n+    // of the argument at time immediate preceding Call to\n+    // `rustc_peek`).\n \n-        for (j, stmt) in statements.iter().enumerate() {\n-            debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n-            let (lvalue, rvalue) = match stmt.kind {\n-                repr::StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                    (lvalue, rvalue)\n-                }\n-            };\n-\n-            if lvalue == peek_arg_lval {\n-                if let repr::Rvalue::Ref(_,\n-                                         repr::BorrowKind::Shared,\n-                                         ref peeking_at_lval) = *rvalue {\n-                    // Okay, our search is over.\n-                    let peek_mpi = move_data.rev_lookup.find(peeking_at_lval);\n-                    let bit_state = sets.on_entry.contains(&peek_mpi);\n-                    debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n-                           lvalue, peeking_at_lval, bit_state);\n-                    if !bit_state {\n-                        tcx.sess.span_err(span, &format!(\"rustc_peek: bit not set\"));\n-                    }\n-                    continue 'next_block;\n-                } else {\n-                    // Our search should have been over, but the input\n-                    // does not match expectations of `rustc_peek` for\n-                    // this sanity_check.\n-                    tcx.sess.span_err(span, &format!(\"rustc_peek: argument expression \\\n-                                                      must be immediate borrow of form `&expr`\"));\n-                }\n-            }\n+    let mut sets = super::BlockSets { on_entry: &mut entry,\n+                                      gen_set: &mut gen,\n+                                      kill_set: &mut kill };\n \n-            let lhs_mpi = move_data.rev_lookup.find(lvalue);\n+    for (j, stmt) in statements.iter().enumerate() {\n+        debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n+        let (lvalue, rvalue) = match stmt.kind {\n+            repr::StatementKind::Assign(ref lvalue, ref rvalue) => {\n+                (lvalue, rvalue)\n+            }\n+        };\n \n-            debug!(\"rustc_peek: computing effect on lvalue: {:?} ({:?}) in stmt: {:?}\",\n-                   lvalue, lhs_mpi, stmt);\n-            // reset GEN and KILL sets before emulating their effect.\n-            for e in sets.gen_set.words_mut() { *e = 0; }\n-            for e in sets.kill_set.words_mut() { *e = 0; }\n-            results.0.operator.statement_effect(flow_ctxt, &mut sets, bb, j);\n-            sets.on_entry.union(sets.gen_set);\n-            sets.on_entry.subtract(sets.kill_set);\n+        if lvalue == peek_arg_lval {\n+            if let repr::Rvalue::Ref(_,\n+                                     repr::BorrowKind::Shared,\n+                                     ref peeking_at_lval) = *rvalue {\n+                // Okay, our search is over.\n+                let peek_mpi = move_data.rev_lookup.find(peeking_at_lval);\n+                let bit_state = sets.on_entry.contains(&peek_mpi);\n+                debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n+                       lvalue, peeking_at_lval, bit_state);\n+                if !bit_state {\n+                    tcx.sess.span_err(span, &format!(\"rustc_peek: bit not set\"));\n+                }\n+                return;\n+            } else {\n+                // Our search should have been over, but the input\n+                // does not match expectations of `rustc_peek` for\n+                // this sanity_check.\n+                let msg = &format!(\"rustc_peek: argument expression \\\n+                                    must be immediate borrow of form `&expr`\");\n+                tcx.sess.span_err(span, msg);\n+            }\n         }\n-\n-        tcx.sess.span_err(span, &format!(\"rustc_peek: MIR did not match \\\n-                                          anticipated pattern; note that \\\n-                                          rustc_peek expects input of \\\n-                                          form `&expr`\"));\n+        \n+        let lhs_mpi = move_data.rev_lookup.find(lvalue);\n+\n+        debug!(\"rustc_peek: computing effect on lvalue: {:?} ({:?}) in stmt: {:?}\",\n+               lvalue, lhs_mpi, stmt);\n+        // reset GEN and KILL sets before emulating their effect.\n+        for e in sets.gen_set.words_mut() { *e = 0; }\n+        for e in sets.kill_set.words_mut() { *e = 0; }\n+        results.0.operator.statement_effect(flow_ctxt, &mut sets, bb, j);\n+        sets.on_entry.union(sets.gen_set);\n+        sets.on_entry.subtract(sets.kill_set);\n     }\n \n+    tcx.sess.span_err(span, &format!(\"rustc_peek: MIR did not match \\\n+                                      anticipated pattern; note that \\\n+                                      rustc_peek expects input of \\\n+                                      form `&expr`\"));\n }\n \n fn is_rustc_peek<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}]}