{"sha": "ad2de8b4ee099916113b7b3577ac86857b1568be", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMmRlOGI0ZWUwOTk5MTYxMTNiN2IzNTc3YWM4Njg1N2IxNTY4YmU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-13T14:14:22Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T07:06:28Z"}, "message": "miri/CTFE refactor\n\n* Value gets renamed to Operand, so that now interpret::{Place, Operand} are the\n  \"dynamic\" versions of mir::{Place, Operand}.\n* Operand and Place share the data for their \"stuff is in memory\"-base in a new\n  type, MemPlace.  This also makes it possible to give some more precise types\n  in other areas.  Both Operand and MemPlace have methods available to project\n  into fields (and other kinds of projections) without causing further\n  allocations.\n* The type for \"a Scalar or a ScalarPair\" is called Value, and again used to\n  give some more precise types.\n* All of these have versions with an attached layout, so that we can more often\n  drag the layout along instead of recomputing it.  This lets us get rid of\n  `PlaceExtra::Downcast`.  MPlaceTy and PlaceTy can only be constructed\n  in place.rs, making sure the layout is handled properly.\n  (The same should eventually be done for ValTy and OpTy.)\n* All the high-level functions to write typed memory take a Place, and live in\n  place.rs.  All the high-level typed functions to read typed memory take an\n  Operand, and live in operands.rs.", "tree": {"sha": "d646959a7529e9b5aa0d49f3b069f46eb0f8ae92", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d646959a7529e9b5aa0d49f3b069f46eb0f8ae92"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad2de8b4ee099916113b7b3577ac86857b1568be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad2de8b4ee099916113b7b3577ac86857b1568be", "html_url": "https://github.com/rust-lang/rust/commit/ad2de8b4ee099916113b7b3577ac86857b1568be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad2de8b4ee099916113b7b3577ac86857b1568be/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d4f5f7974f75635c88af31013ae7cc0ed1927ef", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d4f5f7974f75635c88af31013ae7cc0ed1927ef", "html_url": "https://github.com/rust-lang/rust/commit/7d4f5f7974f75635c88af31013ae7cc0ed1927ef"}], "stats": {"total": 3932, "additions": 1997, "deletions": 1935}, "files": [{"sha": "90081d5b85ef9ec7186ee1931cb16f398a482140", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -632,7 +632,7 @@ define_dep_nodes!( <'tcx>\n     // queries). Making them anonymous avoids hashing the result, which\n     // may save a bit of time.\n     [anon] EraseRegionsTy { ty: Ty<'tcx> },\n-    [anon] ConstValueToAllocation { val: &'tcx ty::Const<'tcx> },\n+    [anon] ConstToAllocation { val: &'tcx ty::Const<'tcx> },\n \n     [input] Freevars(DefId),\n     [input] MaybeUnusedTraitImport(DefId),"}, {"sha": "46f4ed4ec478b1b7ba1eed0182eae1cb3b11cb4a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -397,12 +397,6 @@ impl_stable_hash_for!(enum mir::interpret::ScalarMaybeUndef {\n     Undef\n });\n \n-impl_stable_hash_for!(enum mir::interpret::Value {\n-    Scalar(v),\n-    ScalarPair(a, b),\n-    ByRef(ptr, align)\n-});\n-\n impl_stable_hash_for!(struct mir::interpret::Pointer {\n     alloc_id,\n     offset"}, {"sha": "50b8c271233e38017bbcc03a465598179de4c3e1", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -13,7 +13,7 @@ pub use self::error::{\n     FrameInfo, ConstEvalResult,\n };\n \n-pub use self::value::{Scalar, Value, ConstValue, ScalarMaybeUndef};\n+pub use self::value::{Scalar, ConstValue, ScalarMaybeUndef};\n \n use std::fmt;\n use mir;\n@@ -135,7 +135,7 @@ impl<'tcx> Pointer {\n         Pointer { alloc_id, offset }\n     }\n \n-    pub(crate) fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n+    pub fn wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n         Pointer::new(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().wrapping_signed_offset(self.offset.bytes(), i)),\n@@ -147,7 +147,7 @@ impl<'tcx> Pointer {\n         (Pointer::new(self.alloc_id, Size::from_bytes(res)), over)\n     }\n \n-    pub(crate) fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n         Ok(Pointer::new(\n             self.alloc_id,\n             Size::from_bytes(cx.data_layout().signed_offset(self.offset.bytes(), i)?),"}, {"sha": "3f8130ec04ca9e64b92297d7b738da64393db0f9", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 77, "deletions": 123, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1,21 +1,22 @@\n #![allow(unknown_lints)]\n \n-use ty::layout::{Align, HasDataLayout, Size};\n-use ty;\n+use ty::layout::{HasDataLayout, Size};\n use ty::subst::Substs;\n use hir::def_id::DefId;\n \n use super::{EvalResult, Pointer, PointerArithmetic, Allocation};\n \n /// Represents a constant value in Rust. Scalar and ScalarPair are optimizations which\n-/// matches Value's optimizations for easy conversions between these two types\n+/// matches the LocalValue optimizations for easy conversions between Value and ConstValue.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, RustcEncodable, RustcDecodable, Hash)]\n pub enum ConstValue<'tcx> {\n     /// Never returned from the `const_eval` query, but the HIR contains these frequently in order\n     /// to allow HIR creation to happen for everything before needing to be able to run constant\n     /// evaluation\n     Unevaluated(DefId, &'tcx Substs<'tcx>),\n     /// Used only for types with layout::abi::Scalar ABI and ZSTs\n+    ///\n+    /// Not using the enum `Value` to encode that this must not be `Undef`\n     Scalar(Scalar),\n     /// Used only for types with layout::abi::ScalarPair\n     ///\n@@ -26,25 +27,6 @@ pub enum ConstValue<'tcx> {\n }\n \n impl<'tcx> ConstValue<'tcx> {\n-    #[inline]\n-    pub fn from_byval_value(val: Value) -> EvalResult<'static, Self> {\n-        Ok(match val {\n-            Value::ByRef(..) => bug!(),\n-            Value::ScalarPair(a, b) => ConstValue::ScalarPair(a.unwrap_or_err()?, b),\n-            Value::Scalar(val) => ConstValue::Scalar(val.unwrap_or_err()?),\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn to_byval_value(&self) -> Option<Value> {\n-        match *self {\n-            ConstValue::Unevaluated(..) |\n-            ConstValue::ByRef(..) => None,\n-            ConstValue::ScalarPair(a, b) => Some(Value::ScalarPair(a.into(), b)),\n-            ConstValue::Scalar(val) => Some(Value::Scalar(val.into())),\n-        }\n-    }\n-\n     #[inline]\n     pub fn try_to_scalar(&self) -> Option<Scalar> {\n         match *self {\n@@ -56,58 +38,44 @@ impl<'tcx> ConstValue<'tcx> {\n     }\n \n     #[inline]\n-    pub fn to_bits(&self, size: Size) -> Option<u128> {\n+    pub fn try_to_bits(&self, size: Size) -> Option<u128> {\n         self.try_to_scalar()?.to_bits(size).ok()\n     }\n \n     #[inline]\n-    pub fn to_ptr(&self) -> Option<Pointer> {\n+    pub fn try_to_ptr(&self) -> Option<Pointer> {\n         self.try_to_scalar()?.to_ptr().ok()\n     }\n-}\n-\n-/// A `Value` represents a single self-contained Rust value.\n-///\n-/// A `Value` can either refer to a block of memory inside an allocation (`ByRef`) or to a primitive\n-/// value held directly, outside of any allocation (`Scalar`).  For `ByRef`-values, we remember\n-/// whether the pointer is supposed to be aligned or not (also see Place).\n-///\n-/// For optimization of a few very common cases, there is also a representation for a pair of\n-/// primitive values (`ScalarPair`). It allows Miri to avoid making allocations for checked binary\n-/// operations and fat pointers. This idea was taken from rustc's codegen.\n-#[derive(Clone, Copy, Debug, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum Value {\n-    ByRef(Scalar, Align),\n-    Scalar(ScalarMaybeUndef),\n-    ScalarPair(ScalarMaybeUndef, ScalarMaybeUndef),\n-}\n \n-impl<'tcx> ty::TypeFoldable<'tcx> for Value {\n-    fn super_fold_with<'gcx: 'tcx, F: ty::fold::TypeFolder<'gcx, 'tcx>>(&self, _: &mut F) -> Self {\n-        *self\n+    pub fn new_slice(\n+        val: Scalar,\n+        len: u64,\n+        cx: impl HasDataLayout\n+    ) -> Self {\n+        ConstValue::ScalarPair(val, Scalar::Bits {\n+            bits: len as u128,\n+            size: cx.data_layout().pointer_size.bytes() as u8,\n+        }.into())\n     }\n-    fn super_visit_with<V: ty::fold::TypeVisitor<'tcx>>(&self, _: &mut V) -> bool {\n-        false\n+\n+    pub fn new_dyn_trait(val: Scalar, vtable: Pointer) -> Self {\n+        ConstValue::ScalarPair(val, Scalar::Ptr(vtable).into())\n     }\n }\n \n impl<'tcx> Scalar {\n-    pub fn ptr_null<C: HasDataLayout>(cx: C) -> Self {\n+    pub fn ptr_null(cx: impl HasDataLayout) -> Self {\n         Scalar::Bits {\n             bits: 0,\n             size: cx.data_layout().pointer_size.bytes() as u8,\n         }\n     }\n \n-    pub fn to_value_with_len<C: HasDataLayout>(self, len: u64, cx: C) -> Value {\n-        ScalarMaybeUndef::Scalar(self).to_value_with_len(len, cx)\n-    }\n-\n-    pub fn to_value_with_vtable(self, vtable: Pointer) -> Value {\n-        ScalarMaybeUndef::Scalar(self).to_value_with_vtable(vtable)\n+    pub fn zst() -> Self {\n+        Scalar::Bits { bits: 0, size: 0 }\n     }\n \n-    pub fn ptr_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_signed_offset(self, i: i64, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -121,7 +89,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    pub fn ptr_offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n+    pub fn ptr_offset(self, i: Size, cx: impl HasDataLayout) -> EvalResult<'tcx, Self> {\n         let layout = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -135,7 +103,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    pub fn ptr_wrapping_signed_offset<C: HasDataLayout>(self, i: i64, cx: C) -> Self {\n+    pub fn ptr_wrapping_signed_offset(self, i: i64, cx: impl HasDataLayout) -> Self {\n         let layout = cx.data_layout();\n         match self {\n             Scalar::Bits { bits, size } => {\n@@ -149,7 +117,7 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    pub fn is_null_ptr<C: HasDataLayout>(self, cx: C) -> bool {\n+    pub fn is_null_ptr(self, cx: impl HasDataLayout) -> bool {\n         match self {\n             Scalar::Bits { bits, size } =>  {\n                 assert_eq!(size as u64, cx.data_layout().pointer_size.bytes());\n@@ -159,8 +127,52 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    pub fn to_value(self) -> Value {\n-        Value::Scalar(ScalarMaybeUndef::Scalar(self))\n+    pub fn from_bool(b: bool) -> Self {\n+        Scalar::Bits { bits: b as u128, size: 1 }\n+    }\n+\n+    pub fn from_char(c: char) -> Self {\n+        Scalar::Bits { bits: c as u128, size: 4 }\n+    }\n+\n+    pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n+        match self {\n+            Scalar::Bits { bits, size } => {\n+                assert_eq!(target_size.bytes(), size as u64);\n+                assert_ne!(size, 0, \"to_bits cannot be used with zsts\");\n+                Ok(bits)\n+            }\n+            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n+        }\n+    }\n+\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+        match self {\n+            Scalar::Bits {..} => err!(ReadBytesAsPointer),\n+            Scalar::Ptr(p) => Ok(p),\n+        }\n+    }\n+\n+    pub fn is_bits(self) -> bool {\n+        match self {\n+            Scalar::Bits { .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_ptr(self) -> bool {\n+        match self {\n+            Scalar::Ptr(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n+        match self {\n+            Scalar::Bits { bits: 0, size: 1 } => Ok(false),\n+            Scalar::Bits { bits: 1, size: 1 } => Ok(true),\n+            _ => err!(InvalidBool),\n+        }\n     }\n }\n \n@@ -202,81 +214,23 @@ impl From<Scalar> for ScalarMaybeUndef {\n     }\n }\n \n-impl ScalarMaybeUndef {\n-    pub fn unwrap_or_err(self) -> EvalResult<'static, Scalar> {\n+impl<'tcx> ScalarMaybeUndef {\n+    pub fn not_undef(self) -> EvalResult<'static, Scalar> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n             ScalarMaybeUndef::Undef => err!(ReadUndefBytes),\n         }\n     }\n \n-    pub fn to_value_with_len<C: HasDataLayout>(self, len: u64, cx: C) -> Value {\n-        Value::ScalarPair(self, Scalar::Bits {\n-            bits: len as u128,\n-            size: cx.data_layout().pointer_size.bytes() as u8,\n-        }.into())\n-    }\n-\n-    pub fn to_value_with_vtable(self, vtable: Pointer) -> Value {\n-        Value::ScalarPair(self, Scalar::Ptr(vtable).into())\n-    }\n-\n-    pub fn ptr_offset<C: HasDataLayout>(self, i: Size, cx: C) -> EvalResult<'tcx, Self> {\n-        match self {\n-            ScalarMaybeUndef::Scalar(scalar) => {\n-                scalar.ptr_offset(i, cx).map(ScalarMaybeUndef::Scalar)\n-            },\n-            ScalarMaybeUndef::Undef => Ok(ScalarMaybeUndef::Undef)\n-        }\n-    }\n-}\n-\n-impl<'tcx> Scalar {\n-    pub fn from_bool(b: bool) -> Self {\n-        Scalar::Bits { bits: b as u128, size: 1 }\n-    }\n-\n-    pub fn from_char(c: char) -> Self {\n-        Scalar::Bits { bits: c as u128, size: 4 }\n-    }\n-\n-    pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n-        match self {\n-            Scalar::Bits { bits, size } => {\n-                assert_eq!(target_size.bytes(), size as u64);\n-                assert_ne!(size, 0, \"to_bits cannot be used with zsts\");\n-                Ok(bits)\n-            }\n-            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n-        }\n-    }\n-\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n-        match self {\n-            Scalar::Bits {..} => err!(ReadBytesAsPointer),\n-            Scalar::Ptr(p) => Ok(p),\n-        }\n-    }\n-\n-    pub fn is_bits(self) -> bool {\n-        match self {\n-            Scalar::Bits { .. } => true,\n-            _ => false,\n-        }\n+        self.not_undef()?.to_ptr()\n     }\n \n-    pub fn is_ptr(self) -> bool {\n-        match self {\n-            Scalar::Ptr(_) => true,\n-            _ => false,\n-        }\n+    pub fn to_bits(self, target_size: Size) -> EvalResult<'tcx, u128> {\n+        self.not_undef()?.to_bits(target_size)\n     }\n \n     pub fn to_bool(self) -> EvalResult<'tcx, bool> {\n-        match self {\n-            Scalar::Bits { bits: 0, size: 1 } => Ok(false),\n-            Scalar::Bits { bits: 1, size: 1 } => Ok(true),\n-            _ => err!(InvalidBool),\n-        }\n+        self.not_undef()?.to_bool()\n     }\n }"}, {"sha": "e958ca9b9bb023b90a6a36a78d4b7fb17a7ee39b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -17,7 +17,7 @@ use hir::def::CtorKind;\n use hir::def_id::DefId;\n use hir::{self, HirId, InlineAsm};\n use middle::region;\n-use mir::interpret::{EvalErrorKind, Scalar, Value, ScalarMaybeUndef};\n+use mir::interpret::{EvalErrorKind, Scalar, ScalarMaybeUndef, ConstValue};\n use mir::visit::MirVisitable;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n@@ -1469,14 +1469,14 @@ impl<'tcx> TerminatorKind<'tcx> {\n                     .iter()\n                     .map(|&u| {\n                         let mut s = String::new();\n-                        print_miri_value(\n-                            Scalar::Bits {\n-                                bits: u,\n-                                size: size.bytes() as u8,\n-                            }.to_value(),\n-                            switch_ty,\n-                            &mut s,\n-                        ).unwrap();\n+                        let c = ty::Const {\n+                            val: ConstValue::Scalar(Scalar::Bits {\n+                                    bits: u,\n+                                    size: size.bytes() as u8,\n+                                }.into()),\n+                            ty: switch_ty,\n+                        };\n+                        fmt_const_val(&mut s, &c).unwrap();\n                         s.into()\n                     })\n                     .chain(iter::once(String::from(\"otherwise\").into()))\n@@ -2220,18 +2220,12 @@ impl<'tcx> Debug for Constant<'tcx> {\n }\n \n /// Write a `ConstValue` in a way closer to the original source code than the `Debug` output.\n-pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ty::Const) -> fmt::Result {\n-    if let Some(value) = const_val.to_byval_value() {\n-        print_miri_value(value, const_val.ty, fmt)\n-    } else {\n-        write!(fmt, \"{:?}:{}\", const_val.val, const_val.ty)\n-    }\n-}\n-\n-pub fn print_miri_value<'tcx, W: Write>(value: Value, ty: Ty<'tcx>, f: &mut W) -> fmt::Result {\n+pub fn fmt_const_val(f: &mut impl Write, const_val: &ty::Const) -> fmt::Result {\n     use ty::TypeVariants::*;\n+    let value = const_val.val;\n+    let ty = const_val.ty;\n     // print some primitives\n-    if let Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits, .. })) = value {\n+    if let ConstValue::Scalar(Scalar::Bits { bits, .. }) = value {\n         match ty.sty {\n             TyBool if bits == 0 => return write!(f, \"false\"),\n             TyBool if bits == 1 => return write!(f, \"true\"),\n@@ -2258,8 +2252,8 @@ pub fn print_miri_value<'tcx, W: Write>(value: Value, ty: Ty<'tcx>, f: &mut W) -\n         return write!(f, \"{}\", item_path_str(did));\n     }\n     // print string literals\n-    if let Value::ScalarPair(ptr, len) = value {\n-        if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = ptr {\n+    if let ConstValue::ScalarPair(ptr, len) = value {\n+        if let Scalar::Ptr(ptr) = ptr {\n             if let ScalarMaybeUndef::Scalar(Scalar::Bits { bits: len, .. }) = len {\n                 if let TyRef(_, &ty::TyS { sty: TyStr, .. }, _) = ty.sty {\n                     return ty::tls::with(|tcx| {"}, {"sha": "b5093d0a1fc951f9cb059da4e5cb55ab1eeb915a", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -198,9 +198,9 @@ impl<'tcx> QueryDescription<'tcx> for queries::super_predicates_of<'tcx> {\n     }\n }\n \n-impl<'tcx> QueryDescription<'tcx> for queries::const_value_to_allocation<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::const_to_allocation<'tcx> {\n     fn describe(_tcx: TyCtxt, val: &'tcx ty::Const<'tcx>) -> String {\n-        format!(\"converting value `{:?}` to an allocation\", val)\n+        format!(\"converting constant `{:?}` to an allocation\", val)\n     }\n }\n "}, {"sha": "c1372293a1b68a2d152619a3392e4bd04974ce40", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -287,8 +287,8 @@ define_queries! { <'tcx>\n         [] fn const_eval: const_eval_dep_node(ty::ParamEnvAnd<'tcx, GlobalId<'tcx>>)\n             -> ConstEvalResult<'tcx>,\n \n-        /// Converts a constant value to an constant allocation\n-        [] fn const_value_to_allocation: const_value_to_allocation(\n+        /// Converts a constant value to a constant allocation\n+        [] fn const_to_allocation: const_to_allocation(\n             &'tcx ty::Const<'tcx>\n         ) -> &'tcx Allocation,\n     },\n@@ -706,10 +706,10 @@ fn erase_regions_ty<'tcx>(ty: Ty<'tcx>) -> DepConstructor<'tcx> {\n     DepConstructor::EraseRegionsTy { ty }\n }\n \n-fn const_value_to_allocation<'tcx>(\n+fn const_to_allocation<'tcx>(\n     val: &'tcx ty::Const<'tcx>,\n ) -> DepConstructor<'tcx> {\n-    DepConstructor::ConstValueToAllocation { val }\n+    DepConstructor::ConstToAllocation { val }\n }\n \n fn type_param_predicates<'tcx>((item_id, param_id): (DefId, DefId)) -> DepConstructor<'tcx> {"}, {"sha": "8473e4af40e3b9944063eb63234bebcc93bdb8d4", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1062,7 +1062,7 @@ pub fn force_from_dep_node<'a, 'gcx, 'lcx>(tcx: TyCtxt<'a, 'gcx, 'lcx>,\n         DepKind::FulfillObligation |\n         DepKind::VtableMethods |\n         DepKind::EraseRegionsTy |\n-        DepKind::ConstValueToAllocation |\n+        DepKind::ConstToAllocation |\n         DepKind::NormalizeProjectionTy |\n         DepKind::NormalizeTyAfterErasingRegions |\n         DepKind::ImpliedOutlivesBounds |"}, {"sha": "7c0857cd2f99885d8d2e0ab1956400a6a9e702db", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -20,7 +20,7 @@ use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n use ty::{Slice, TyS, ParamEnvAnd, ParamEnv};\n use util::captures::Captures;\n-use mir::interpret::{Scalar, Pointer, Value};\n+use mir::interpret::{Scalar, Pointer};\n \n use std::iter;\n use std::cmp::Ordering;\n@@ -1973,17 +1973,12 @@ impl<'tcx> Const<'tcx> {\n         }\n         let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).ok()?.size;\n-        self.val.to_bits(size)\n+        self.val.try_to_bits(size)\n     }\n \n     #[inline]\n     pub fn to_ptr(&self) -> Option<Pointer> {\n-        self.val.to_ptr()\n-    }\n-\n-    #[inline]\n-    pub fn to_byval_value(&self) -> Option<Value> {\n-        self.val.to_byval_value()\n+        self.val.try_to_ptr()\n     }\n \n     #[inline]\n@@ -1995,7 +1990,7 @@ impl<'tcx> Const<'tcx> {\n         assert_eq!(self.ty, ty.value);\n         let ty = tcx.lift_to_global(&ty).unwrap();\n         let size = tcx.layout_of(ty).ok()?.size;\n-        self.val.to_bits(size)\n+        self.val.try_to_bits(size)\n     }\n \n     #[inline]"}, {"sha": "c79a1a4bd04c6608bdbf6fcf5c07dbc721c6a48c", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1359,6 +1359,7 @@ fn describe_enum_variant(\n     // If this is not a univariant enum, there is also the discriminant field.\n     let (discr_offset, discr_arg) = match discriminant_info {\n         RegularDiscriminant(_) => {\n+            // We have the layout of an enum variant, we need the layout of the outer enum\n             let enum_layout = cx.layout_of(layout.ty);\n             (Some(enum_layout.fields.offset(0)),\n              Some((\"RUST$ENUM$DISR\".to_string(), enum_layout.field(cx, 0).ty)))"}, {"sha": "6774ce818c1f6d694a804febcb8d3571785b8caf", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n use llvm;\n-use rustc::mir::interpret::ConstEvalErr;\n-use rustc_mir::interpret::{read_target_uint, const_val_field};\n+use rustc::mir::interpret::{ConstEvalErr, read_target_uint};\n+use rustc_mir::interpret::{const_field};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -186,7 +186,7 @@ impl FunctionCx<'a, 'll, 'tcx> {\n                     ref other => bug!(\"invalid simd shuffle type: {}\", other),\n                 };\n                 let values: Result<Vec<_>, Lrc<_>> = (0..fields).map(|field| {\n-                    let field = const_val_field(\n+                    let field = const_field(\n                         bx.tcx(),\n                         ty::ParamEnv::reveal_all(),\n                         self.instance,"}, {"sha": "bcbf6d167dfef0dd89fa247cecae08dbdb6dd374", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1615,20 +1615,19 @@ fn validate_const<'a, 'tcx>(\n ) {\n     let mut ecx = ::rustc_mir::interpret::mk_eval_cx(tcx, gid.instance, param_env).unwrap();\n     let result = (|| {\n-        let val = ecx.const_to_value(constant.val)?;\n         use rustc_target::abi::LayoutOf;\n+        use rustc_mir::interpret::OpTy;\n+\n+        let op = ecx.const_value_to_op(constant.val)?;\n         let layout = ecx.layout_of(constant.ty)?;\n-        let place = ecx.allocate_place_for_value(val, layout, None)?;\n-        let ptr = place.to_ptr()?;\n-        let mut todo = vec![(ptr, layout.ty, String::new())];\n+        let place = ecx.allocate_op(OpTy { op, layout })?.into();\n+\n+        let mut todo = vec![(place, String::new())];\n         let mut seen = FxHashSet();\n-        seen.insert((ptr, layout.ty));\n-        while let Some((ptr, ty, path)) = todo.pop() {\n-            let layout = ecx.layout_of(ty)?;\n-            ecx.validate_ptr_target(\n-                ptr,\n-                layout.align,\n-                layout,\n+        seen.insert(place);\n+        while let Some((place, path)) = todo.pop() {\n+            ecx.validate_mplace(\n+                place,\n                 path,\n                 &mut seen,\n                 &mut todo,"}, {"sha": "79483e454ecea3c1c08c0800e0742d3089c55776", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -167,8 +167,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n             LitKind::Str(ref s, _) => {\n                 let s = s.as_str();\n                 let id = self.tcx.allocate_bytes(s.as_bytes());\n-                let value = Scalar::Ptr(id.into()).to_value_with_len(s.len() as u64, self.tcx);\n-                ConstValue::from_byval_value(value).unwrap()\n+                ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, self.tcx)\n             },\n             LitKind::ByteStr(ref data) => {\n                 let id = self.tcx.allocate_bytes(data);"}, {"sha": "dda589fd20d8a19f335ae8cce35d0ea425863539", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -16,7 +16,7 @@ mod check_match;\n pub use self::check_match::check_crate;\n pub(crate) use self::check_match::check_match;\n \n-use interpret::{const_val_field, const_variant_index, self};\n+use interpret::{const_field, const_variant_index, self};\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue};\n@@ -795,7 +795,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         debug!(\"const_to_pat: cv={:#?}\", cv);\n         let adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n-            let val = const_val_field(\n+            let val = const_field(\n                 self.tcx, self.param_env, instance,\n                 variant_opt, field, cv,\n             ).expect(\"field access failed\");\n@@ -1106,8 +1106,8 @@ pub fn compare_const_vals<'a, 'tcx>(\n                         len_b,\n                     ),\n                 ) if ptr_a.offset.bytes() == 0 && ptr_b.offset.bytes() == 0 => {\n-                    let len_a = len_a.unwrap_or_err().ok();\n-                    let len_b = len_b.unwrap_or_err().ok();\n+                    let len_a = len_a.not_undef().ok();\n+                    let len_b = len_b.not_undef().ok();\n                     if len_a.is_none() || len_b.is_none() {\n                         tcx.sess.struct_err(\"str slice len is undef\").delay_as_bug();\n                     }\n@@ -1153,8 +1153,7 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n         LitKind::Str(ref s, _) => {\n             let s = s.as_str();\n             let id = tcx.allocate_bytes(s.as_bytes());\n-            let value = Scalar::Ptr(id.into()).to_value_with_len(s.len() as u64, tcx);\n-            ConstValue::from_byval_value(value).unwrap()\n+            ConstValue::new_slice(Scalar::Ptr(id.into()), s.len() as u64, tcx)\n         },\n         LitKind::ByteStr(ref data) => {\n             let id = tcx.allocate_bytes(data);"}, {"sha": "036b84ee1fb7b35888634c164eb722dc480d2d9c", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 148, "deletions": 52, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1,87 +1,82 @@\n-use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{self, LayoutOf, TyLayout};\n+use rustc::ty::{self, Ty, TypeAndMut};\n+use rustc::ty::layout::{self, TyLayout};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n \n use rustc_apfloat::ieee::{Single, Double};\n-use super::{EvalContext, Machine};\n-use rustc::mir::interpret::{Scalar, EvalResult, Pointer, PointerArithmetic, Value, EvalErrorKind};\n+use rustc::mir::interpret::{Scalar, EvalResult, Pointer, PointerArithmetic, EvalErrorKind};\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n-use interpret::eval_context::ValTy;\n-use interpret::Place;\n+\n+use super::{EvalContext, Machine, PlaceTy, OpTy, Value};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n+        match ty.sty {\n+            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n+            ty::TyRef(_, ty, _) => !self.type_is_sized(ty),\n+            ty::TyAdt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n+            _ => false,\n+        }\n+    }\n+\n     crate fn cast(\n         &mut self,\n-        src: ValTy<'tcx>,\n+        src: OpTy<'tcx>,\n         kind: CastKind,\n-        dest_ty: Ty<'tcx>,\n-        dest: Place,\n+        dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        let src_layout = self.layout_of(src.ty)?;\n-        let dst_layout = self.layout_of(dest_ty)?;\n+        let src_layout = src.layout;\n+        let dst_layout = dest.layout;\n         use rustc::mir::CastKind::*;\n         match kind {\n             Unsize => {\n-                self.unsize_into(src.value, src_layout, dest, dst_layout)?;\n+                self.unsize_into(src, dest)?;\n             }\n \n             Misc => {\n-                if self.type_is_fat_ptr(src.ty) {\n-                    match (src.value, self.type_is_fat_ptr(dest_ty)) {\n-                        (Value::ByRef { .. }, _) |\n+                let src = self.read_value(src)?;\n+                if self.type_is_fat_ptr(src_layout.ty) {\n+                    match (src.value, self.type_is_fat_ptr(dest.layout.ty)) {\n                         // pointers to extern types\n                         (Value::Scalar(_),_) |\n                         // slices and trait objects to other slices/trait objects\n                         (Value::ScalarPair(..), true) => {\n-                            let valty = ValTy {\n-                                value: src.value,\n-                                ty: dest_ty,\n-                            };\n-                            self.write_value(valty, dest)?;\n+                            // No change to value\n+                            self.write_value(src.value, dest)?;\n                         }\n                         // slices and trait objects to thin pointers (dropping the metadata)\n                         (Value::ScalarPair(data, _), false) => {\n-                            let valty = ValTy {\n-                                value: Value::Scalar(data),\n-                                ty: dest_ty,\n-                            };\n-                            self.write_value(valty, dest)?;\n+                            self.write_scalar(data, dest)?;\n                         }\n                     }\n                 } else {\n-                    let src_layout = self.layout_of(src.ty)?;\n                     match src_layout.variants {\n                         layout::Variants::Single { index } => {\n-                            if let Some(def) = src.ty.ty_adt_def() {\n+                            if let Some(def) = src_layout.ty.ty_adt_def() {\n                                 let discr_val = def\n                                     .discriminant_for_variant(*self.tcx, index)\n                                     .val;\n                                 return self.write_scalar(\n-                                    dest,\n                                     Scalar::Bits {\n                                         bits: discr_val,\n                                         size: dst_layout.size.bytes() as u8,\n                                     },\n-                                    dest_ty);\n+                                    dest);\n                             }\n                         }\n                         layout::Variants::Tagged { .. } |\n                         layout::Variants::NicheFilling { .. } => {},\n                     }\n \n-                    let src_val = self.value_to_scalar(src)?;\n-                    let dest_val = self.cast_scalar(src_val, src_layout, dst_layout)?;\n-                    let valty = ValTy {\n-                        value: Value::Scalar(dest_val.into()),\n-                        ty: dest_ty,\n-                    };\n-                    self.write_value(valty, dest)?;\n+                    let src = src.to_scalar()?;\n+                    let dest_val = self.cast_scalar(src, src_layout, dest.layout)?;\n+                    self.write_scalar(dest_val, dest)?;\n                 }\n             }\n \n             ReifyFnPointer => {\n-                match src.ty.sty {\n+                // The src operand does not matter, just its type\n+                match src_layout.ty.sty {\n                     ty::TyFnDef(def_id, substs) => {\n                         if self.tcx.has_attr(def_id, \"rustc_args_required_const\") {\n                             bug!(\"reifying a fn ptr that requires \\\n@@ -94,29 +89,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             substs,\n                         ).ok_or_else(|| EvalErrorKind::TooGeneric.into());\n                         let fn_ptr = self.memory.create_fn_alloc(instance?);\n-                        let valty = ValTy {\n-                            value: Value::Scalar(Scalar::Ptr(fn_ptr.into()).into()),\n-                            ty: dest_ty,\n-                        };\n-                        self.write_value(valty, dest)?;\n+                        self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n                     ref other => bug!(\"reify fn pointer on {:?}\", other),\n                 }\n             }\n \n             UnsafeFnPointer => {\n-                match dest_ty.sty {\n+                let src = self.read_value(src)?;\n+                match dest.layout.ty.sty {\n                     ty::TyFnPtr(_) => {\n-                        let mut src = src;\n-                        src.ty = dest_ty;\n-                        self.write_value(src, dest)?;\n+                        // No change to value\n+                        self.write_value(*src, dest)?;\n                     }\n                     ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n                 }\n             }\n \n             ClosureFnPointer => {\n-                match src.ty.sty {\n+                // The src operand does not matter, just its type\n+                match src_layout.ty.sty {\n                     ty::TyClosure(def_id, substs) => {\n                         let substs = self.tcx.subst_and_normalize_erasing_regions(\n                             self.substs(),\n@@ -130,11 +122,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             ty::ClosureKind::FnOnce,\n                         );\n                         let fn_ptr = self.memory.create_fn_alloc(instance);\n-                        let valty = ValTy {\n-                            value: Value::Scalar(Scalar::Ptr(fn_ptr.into()).into()),\n-                            ty: dest_ty,\n-                        };\n-                        self.write_value(valty, dest)?;\n+                        let val = Value::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n+                        self.write_value(val, dest)?;\n                     }\n                     ref other => bug!(\"closure fn pointer on {:?}\", other),\n                 }\n@@ -292,4 +281,111 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             _ => err!(Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }\n     }\n+\n+    fn unsize_into_ptr(\n+        &mut self,\n+        src: OpTy<'tcx>,\n+        dest: PlaceTy<'tcx>,\n+        // The pointee types\n+        sty: Ty<'tcx>,\n+        dty: Ty<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        // A<Struct> -> A<Trait> conversion\n+        let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n+\n+        match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n+            (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n+                let ptr = self.read_value(src)?.to_scalar_ptr()?;\n+                // u64 cast is from usize to u64, which is always good\n+                let val = Value::new_slice(ptr, length.unwrap_usize(self.tcx.tcx), self.tcx.tcx);\n+                self.write_value(val, dest)\n+            }\n+            (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n+                // For now, upcasts are limited to changes in marker\n+                // traits, and hence never actually require an actual\n+                // change to the vtable.\n+                self.copy_op(src, dest)\n+            }\n+            (_, &ty::TyDynamic(ref data, _)) => {\n+                // Initial cast from sized to dyn trait\n+                let trait_ref = data.principal().unwrap().with_self_ty(\n+                    *self.tcx,\n+                    src_pointee_ty,\n+                );\n+                let trait_ref = self.tcx.erase_regions(&trait_ref);\n+                let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n+                let ptr = self.read_value(src)?.to_scalar_ptr()?;\n+                let val = Value::new_dyn_trait(ptr, vtable);\n+                self.write_value(val, dest)\n+            }\n+\n+            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src.layout.ty, dest.layout.ty),\n+        }\n+    }\n+\n+    fn unsize_into(\n+        &mut self,\n+        src: OpTy<'tcx>,\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        match (&src.layout.ty.sty, &dest.layout.ty.sty) {\n+            (&ty::TyRef(_, s, _), &ty::TyRef(_, d, _)) |\n+            (&ty::TyRef(_, s, _), &ty::TyRawPtr(TypeAndMut { ty: d, .. })) |\n+            (&ty::TyRawPtr(TypeAndMut { ty: s, .. }),\n+             &ty::TyRawPtr(TypeAndMut { ty: d, .. })) => {\n+                self.unsize_into_ptr(src, dest, s, d)\n+            }\n+            (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n+                assert_eq!(def_a, def_b);\n+                if def_a.is_box() || def_b.is_box() {\n+                    if !def_a.is_box() || !def_b.is_box() {\n+                        bug!(\"invalid unsizing between {:?} -> {:?}\", src.layout, dest.layout);\n+                    }\n+                    return self.unsize_into_ptr(\n+                        src,\n+                        dest,\n+                        src.layout.ty.boxed_ty(),\n+                        dest.layout.ty.boxed_ty(),\n+                    );\n+                }\n+\n+                // unsizing of generic struct with pointer fields\n+                // Example: `Arc<T>` -> `Arc<Trait>`\n+                // here we need to increase the size of every &T thin ptr field to a fat ptr\n+                for i in 0..src.layout.fields.count() {\n+                    let dst_field = self.place_field(dest, i as u64)?;\n+                    if dst_field.layout.is_zst() {\n+                        continue;\n+                    }\n+                    let src_field = match src.try_as_mplace() {\n+                        Ok(mplace) => {\n+                            let src_field = self.mplace_field(mplace, i as u64)?;\n+                            src_field.into()\n+                        }\n+                        Err(..) => {\n+                            let src_field_layout = src.layout.field(&self, i)?;\n+                            // this must be a field covering the entire thing\n+                            assert_eq!(src.layout.fields.offset(i).bytes(), 0);\n+                            assert_eq!(src_field_layout.size, src.layout.size);\n+                            // just sawp out the layout\n+                            OpTy { op: src.op, layout: src_field_layout }\n+                        }\n+                    };\n+                    if src_field.layout.ty == dst_field.layout.ty {\n+                        self.copy_op(src_field, dst_field)?;\n+                    } else {\n+                        self.unsize_into(src_field, dst_field)?;\n+                    }\n+                }\n+                Ok(())\n+            }\n+            _ => {\n+                bug!(\n+                    \"unsize_into: invalid conversion: {:?} -> {:?}\",\n+                    src.layout,\n+                    dest.layout\n+                )\n+            }\n+        }\n+    }\n }"}, {"sha": "d98f98bca60fd1439308e627940fae98446f0f6e", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 104, "deletions": 111, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -2,22 +2,25 @@ use std::fmt;\n use std::error::Error;\n \n use rustc::hir;\n-use rustc::mir::interpret::{ConstEvalErr, ScalarMaybeUndef};\n+use rustc::mir::interpret::ConstEvalErr;\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt, Ty, Instance};\n-use rustc::ty::layout::{self, LayoutOf, Primitive, TyLayout};\n+use rustc::ty::{self, TyCtxt, Instance};\n+use rustc::ty::layout::{LayoutOf, Primitive, TyLayout};\n use rustc::ty::subst::Subst;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use syntax::ast::Mutability;\n use syntax::source_map::Span;\n use syntax::source_map::DUMMY_SP;\n \n use rustc::mir::interpret::{\n     EvalResult, EvalError, EvalErrorKind, GlobalId,\n-    Value, Scalar, AllocId, Allocation, ConstValue,\n+    Scalar, AllocId, Allocation, ConstValue,\n+};\n+use super::{\n+    Place, PlaceExtra, PlaceTy, MemPlace, OpTy, Operand, Value,\n+    EvalContext, StackPopCleanup, Memory, MemoryKind\n };\n-use super::{Place, EvalContext, StackPopCleanup, ValTy, Memory, MemoryKind};\n \n pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -35,7 +38,7 @@ pub fn mk_borrowck_eval_cx<'a, 'mir, 'tcx>(\n         instance,\n         span,\n         mir,\n-        return_place: Place::undef(),\n+        return_place: Place::null(tcx),\n         return_to_block: StackPopCleanup::None,\n         stmt: 0,\n     });\n@@ -56,7 +59,7 @@ pub fn mk_eval_cx<'a, 'tcx>(\n         instance,\n         mir.span,\n         mir,\n-        Place::undef(),\n+        Place::null(tcx),\n         StackPopCleanup::None,\n     )?;\n     Ok(ecx)\n@@ -67,47 +70,59 @@ pub fn eval_promoted<'a, 'mir, 'tcx>(\n     cid: GlobalId<'tcx>,\n     mir: &'mir mir::Mir<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Value, Scalar, TyLayout<'tcx>)> {\n+) -> EvalResult<'tcx, OpTy<'tcx>> {\n     ecx.with_fresh_body(|ecx| {\n         eval_body_using_ecx(ecx, cid, Some(mir), param_env)\n     })\n }\n \n-pub fn value_to_const_value<'tcx>(\n+pub fn op_to_const<'tcx>(\n     ecx: &EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n-    val: Value,\n-    layout: TyLayout<'tcx>,\n+    op: OpTy<'tcx>,\n+    normalize: bool,\n ) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n-    match (val, &layout.abi) {\n-        (Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size: 0, ..})), _) if layout.is_zst() => {},\n-        (Value::ByRef(..), _) |\n-        (Value::Scalar(_), &layout::Abi::Scalar(_)) |\n-        (Value::ScalarPair(..), &layout::Abi::ScalarPair(..)) => {},\n-        _ => bug!(\"bad value/layout combo: {:#?}, {:#?}\", val, layout),\n-    }\n-    let val = match val {\n-        Value::Scalar(val) => ConstValue::Scalar(val.unwrap_or_err()?),\n-        Value::ScalarPair(a, b) => ConstValue::ScalarPair(a.unwrap_or_err()?, b),\n-        Value::ByRef(ptr, align) => {\n-            let ptr = ptr.to_ptr().unwrap();\n+    let normalized_op = if normalize {\n+        ecx.try_read_value(op)?\n+    } else {\n+        match op.op {\n+            Operand::Indirect(mplace) => Err(mplace),\n+            Operand::Immediate(val) => Ok(val)\n+        }\n+    };\n+    let val = match normalized_op {\n+        Err(MemPlace { ptr, align, extra }) => {\n+            // extract alloc-offset pair\n+            assert_eq!(extra, PlaceExtra::None);\n+            let ptr = ptr.to_ptr()?;\n             let alloc = ecx.memory.get(ptr.alloc_id)?;\n             assert!(alloc.align.abi() >= align.abi());\n-            assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= layout.size.bytes());\n+            assert!(alloc.bytes.len() as u64 - ptr.offset.bytes() >= op.layout.size.bytes());\n             let mut alloc = alloc.clone();\n             alloc.align = align;\n             let alloc = ecx.tcx.intern_const_alloc(alloc);\n             ConstValue::ByRef(alloc, ptr.offset)\n-        }\n+        },\n+        Ok(Value::Scalar(x)) =>\n+            ConstValue::Scalar(x.not_undef()?),\n+        Ok(Value::ScalarPair(a, b)) =>\n+            ConstValue::ScalarPair(a.not_undef()?, b),\n     };\n-    Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, layout.ty))\n+    Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, op.layout.ty))\n+}\n+pub fn const_to_op<'tcx>(\n+    ecx: &mut EvalContext<'_, '_, 'tcx, CompileTimeEvaluator>,\n+    cnst: &'tcx ty::Const<'tcx>,\n+) -> EvalResult<'tcx, OpTy<'tcx>> {\n+    let op = ecx.const_value_to_op(cnst.val)?;\n+    Ok(OpTy { op, layout: ecx.layout_of(cnst.ty)? })\n }\n \n fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> (EvalResult<'tcx, (Value, Scalar, TyLayout<'tcx>)>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n+) -> (EvalResult<'tcx, OpTy<'tcx>>, EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>) {\n     debug!(\"eval_body_and_ecx: {:?}, {:?}\", cid, param_env);\n     // we start out with the best span we have\n     // and try improving it down the road when more information is available\n@@ -118,12 +133,13 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     (r, ecx)\n }\n \n+// Returns a pointer to where the result lives\n fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     ecx: &mut EvalContext<'a, 'mir, 'tcx, CompileTimeEvaluator>,\n     cid: GlobalId<'tcx>,\n     mir: Option<&'mir mir::Mir<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n-) -> EvalResult<'tcx, (Value, Scalar, TyLayout<'tcx>)> {\n+) -> EvalResult<'tcx, OpTy<'tcx>> {\n     debug!(\"eval_body: {:?}, {:?}\", cid, param_env);\n     let tcx = ecx.tcx.tcx;\n     let mut mir = match mir {\n@@ -135,11 +151,7 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n     }\n     let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n     assert!(!layout.is_unsized());\n-    let ptr = ecx.memory.allocate(\n-        layout.size,\n-        layout.align,\n-        MemoryKind::Stack,\n-    )?;\n+    let ret = ecx.allocate(layout, MemoryKind::Stack)?;\n     let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n     let is_static = tcx.is_static(cid.instance.def_id());\n     let mutability = if is_static == Some(hir::Mutability::MutMutable) || internally_mutable {\n@@ -156,19 +168,14 @@ fn eval_body_using_ecx<'a, 'mir, 'tcx>(\n         cid.instance,\n         mir.span,\n         mir,\n-        Place::from_ptr(ptr, layout.align),\n+        Place::Ptr(*ret),\n         cleanup,\n     )?;\n \n+    // The main interpreter loop.\n     while ecx.step()? {}\n-    let ptr = ptr.into();\n-    // always try to read the value and report errors\n-    let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n-        Some(val) if is_static.is_none() && cid.promoted.is_none() => val,\n-        // point at the allocation\n-        _ => Value::ByRef(ptr, layout.align),\n-    };\n-    Ok((value, ptr, layout))\n+\n+    Ok(ret.into())\n }\n \n #[derive(Debug, Clone, Eq, PartialEq, Hash)]\n@@ -222,14 +229,14 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Place, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n+        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        args: &[OpTy<'tcx>],\n         span: Span,\n-        sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool> {\n         debug!(\"eval_fn_call: {:?}\", instance);\n         if !ecx.tcx.is_const_fn(instance.def_id()) {\n             let def_id = instance.def_id();\n+            // Some fn calls are actually BinOp intrinsics\n             let (op, oflo) = if let Some(op) = ecx.tcx.is_binop_lang_item(def_id) {\n                 op\n             } else {\n@@ -238,11 +245,12 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 );\n             };\n             let (dest, bb) = destination.expect(\"128 lowerings can't diverge\");\n-            let dest_ty = sig.output();\n+            let l = ecx.read_value(args[0])?;\n+            let r = ecx.read_value(args[0])?;\n             if oflo {\n-                ecx.intrinsic_with_overflow(op, args[0], args[1], dest, dest_ty)?;\n+                ecx.binop_with_overflow(op, l, r, dest)?;\n             } else {\n-                ecx.intrinsic_overflowing(op, args[0], args[1], dest, dest_ty)?;\n+                ecx.binop_ignore_overflow(op, l, r, dest)?;\n             }\n             ecx.goto_block(bb);\n             return Ok(true);\n@@ -260,8 +268,8 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n             }\n         };\n         let (return_place, return_to_block) = match destination {\n-            Some((place, block)) => (place, StackPopCleanup::Goto(block)),\n-            None => (Place::undef(), StackPopCleanup::None),\n+            Some((place, block)) => (*place, StackPopCleanup::Goto(block)),\n+            None => (Place::null(&ecx), StackPopCleanup::None),\n         };\n \n         ecx.push_stack_frame(\n@@ -279,9 +287,8 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     fn call_intrinsic<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[ValTy<'tcx>],\n-        dest: Place,\n-        dest_layout: layout::TyLayout<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: PlaceTy<'tcx>,\n         target: mir::BasicBlock,\n     ) -> EvalResult<'tcx> {\n         let substs = instance.substs;\n@@ -293,34 +300,34 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 let elem_align = ecx.layout_of(elem_ty)?.align.abi();\n                 let align_val = Scalar::Bits {\n                     bits: elem_align as u128,\n-                    size: dest_layout.size.bytes() as u8,\n+                    size: dest.layout.size.bytes() as u8,\n                 };\n-                ecx.write_scalar(dest, align_val, dest_layout.ty)?;\n+                ecx.write_scalar(align_val, dest)?;\n             }\n \n             \"size_of\" => {\n                 let ty = substs.type_at(0);\n                 let size = ecx.layout_of(ty)?.size.bytes() as u128;\n                 let size_val = Scalar::Bits {\n                     bits: size,\n-                    size: dest_layout.size.bytes() as u8,\n+                    size: dest.layout.size.bytes() as u8,\n                 };\n-                ecx.write_scalar(dest, size_val, dest_layout.ty)?;\n+                ecx.write_scalar(size_val, dest)?;\n             }\n \n             \"type_id\" => {\n                 let ty = substs.type_at(0);\n                 let type_id = ecx.tcx.type_id_hash(ty) as u128;\n                 let id_val = Scalar::Bits {\n                     bits: type_id,\n-                    size: dest_layout.size.bytes() as u8,\n+                    size: dest.layout.size.bytes() as u8,\n                 };\n-                ecx.write_scalar(dest, id_val, dest_layout.ty)?;\n+                ecx.write_scalar(id_val, dest)?;\n             }\n             \"ctpop\" | \"cttz\" | \"cttz_nonzero\" | \"ctlz\" | \"ctlz_nonzero\" | \"bswap\" => {\n                 let ty = substs.type_at(0);\n                 let layout_of = ecx.layout_of(ty)?;\n-                let bits = ecx.value_to_scalar(args[0])?.to_bits(layout_of.size)?;\n+                let bits = ecx.read_scalar(args[0])?.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n                     _ => Err(::rustc::mir::interpret::EvalErrorKind::TypeNotPrimitive(ty))?,\n@@ -333,7 +340,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n                 } else {\n                     numeric_intrinsic(intrinsic_name, bits, kind)?\n                 };\n-                ecx.write_scalar(dest, out_val, ty)?;\n+                ecx.write_scalar(out_val, dest)?;\n             }\n \n             name => return Err(\n@@ -353,9 +360,9 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         left: Scalar,\n-        _left_ty: Ty<'tcx>,\n+        _left_layout: TyLayout<'tcx>,\n         right: Scalar,\n-        _right_ty: Ty<'tcx>,\n+        _right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Option<(Scalar, bool)>> {\n         if left.is_bits() && right.is_bits() {\n             Ok(None)\n@@ -387,8 +394,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n \n     fn box_alloc<'a>(\n         _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        _ty: Ty<'tcx>,\n-        _dest: Place,\n+        _dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n@@ -406,38 +412,30 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n     }\n }\n \n-pub fn const_val_field<'a, 'tcx>(\n+/// Project to a field of a (variant of a) const\n+pub fn const_field<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     instance: ty::Instance<'tcx>,\n     variant: Option<usize>,\n     field: mir::Field,\n     value: &'tcx ty::Const<'tcx>,\n ) -> ::rustc::mir::interpret::ConstEvalResult<'tcx> {\n-    trace!(\"const_val_field: {:?}, {:?}, {:?}\", instance, field, value);\n+    trace!(\"const_field: {:?}, {:?}, {:?}\", instance, field, value);\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n     let result = (|| {\n-        let ty = value.ty;\n-        let value = ecx.const_to_value(value.val)?;\n-        let layout = ecx.layout_of(ty)?;\n-        let place = ecx.allocate_place_for_value(value, layout, variant)?;\n-        let (place, layout) = ecx.place_field(place, field, layout)?;\n-        let (ptr, align) = place.to_ptr_align();\n-        let mut new_value = Value::ByRef(ptr.unwrap_or_err()?, align);\n-        new_value = ecx.try_read_by_ref(new_value, layout.ty)?;\n-        use rustc_data_structures::indexed_vec::Idx;\n-        match (value, new_value) {\n-            (Value::Scalar(_), Value::ByRef(..)) |\n-            (Value::ScalarPair(..), Value::ByRef(..)) |\n-            (Value::Scalar(_), Value::ScalarPair(..)) => bug!(\n-                \"field {} of {:?} yielded {:?}\",\n-                field.index(),\n-                value,\n-                new_value,\n-            ),\n-            _ => {},\n-        }\n-        value_to_const_value(&ecx, new_value, layout)\n+        // get the operand again\n+        let op = const_to_op(&mut ecx, value)?;\n+        // downcast\n+        let down = match variant {\n+            None => op,\n+            Some(variant) => ecx.operand_downcast(op, variant)?\n+        };\n+        // then project\n+        let field = ecx.operand_field(down, field.index() as u64)?;\n+        // and finally move back to the const world, always normalizing because\n+        // this is not called for statics.\n+        op_to_const(&ecx, field, true)\n     })();\n     result.map_err(|err| {\n         let (trace, span) = ecx.generate_stacktrace(None);\n@@ -457,21 +455,11 @@ pub fn const_variant_index<'a, 'tcx>(\n ) -> EvalResult<'tcx, usize> {\n     trace!(\"const_variant_index: {:?}, {:?}\", instance, val);\n     let mut ecx = mk_eval_cx(tcx, instance, param_env).unwrap();\n-    let value = ecx.const_to_value(val.val)?;\n-    let layout = ecx.layout_of(val.ty)?;\n-    let (ptr, align) = match value {\n-        Value::ScalarPair(..) | Value::Scalar(_) => {\n-            let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?.into();\n-            ecx.write_value_to_ptr(value, ptr, layout.align, val.ty)?;\n-            (ptr, layout.align)\n-        },\n-        Value::ByRef(ptr, align) => (ptr, align),\n-    };\n-    let place = Place::from_scalar_ptr(ptr.into(), align);\n-    ecx.read_discriminant_as_variant_index(place, layout)\n+    let op = const_to_op(&mut ecx, val)?;\n+    ecx.read_discriminant_as_variant_index(op)\n }\n \n-pub fn const_value_to_allocation_provider<'a, 'tcx>(\n+pub fn const_to_allocation_provider<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     val: &'tcx ty::Const<'tcx>,\n ) -> &'tcx Allocation {\n@@ -488,11 +476,11 @@ pub fn const_value_to_allocation_provider<'a, 'tcx>(\n             ty::ParamEnv::reveal_all(),\n             CompileTimeEvaluator,\n             ());\n-        let value = ecx.const_to_value(val.val)?;\n-        let layout = ecx.layout_of(val.ty)?;\n-        let ptr = ecx.memory.allocate(layout.size, layout.align, MemoryKind::Stack)?;\n-        ecx.write_value_to_ptr(value, ptr.into(), layout.align, val.ty)?;\n-        let alloc = ecx.memory.get(ptr.alloc_id)?;\n+        let op = const_to_op(&mut ecx, val)?;\n+        // Make a new allocation, copy things there\n+        let ptr = ecx.allocate(op.layout, MemoryKind::Stack)?;\n+        ecx.copy_op(op, ptr.into())?;\n+        let alloc = ecx.memory.get(ptr.to_ptr()?.alloc_id)?;\n         Ok(tcx.intern_const_alloc(alloc.clone()))\n     };\n     result().expect(\"unable to convert ConstValue to Allocation\")\n@@ -534,11 +522,16 @@ pub fn const_eval_provider<'a, 'tcx>(\n     };\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n-    res.and_then(|(mut val, _, layout)| {\n-        if tcx.is_static(def_id).is_none() && cid.promoted.is_none() {\n-            val = ecx.try_read_by_ref(val, layout.ty)?;\n+    res.and_then(|op| {\n+        let normalize = tcx.is_static(def_id).is_none() && cid.promoted.is_none();\n+        if !normalize {\n+            // Sanity check: These must always be a MemPlace\n+            match op.op {\n+                Operand::Indirect(_) => { /* all is good */ },\n+                Operand::Immediate(_) => bug!(\"const eval gave us an Immediate\"),\n+            }\n         }\n-        value_to_const_value(&ecx, val, layout)\n+        op_to_const(&ecx, op, normalize)\n     }).map_err(|err| {\n         let (trace, span) = ecx.generate_stacktrace(None);\n         let err = ConstEvalErr {"}, {"sha": "cede6d4b22b0d8d6c1ade9bd0784c0c9419ac1fe", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 229, "deletions": 277, "changes": 506, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -6,24 +6,27 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::def::Def;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::mir;\n-use rustc::ty::layout::{self, Size, Align, HasDataLayout, LayoutOf, TyLayout, Primitive};\n+use rustc::ty::layout::{\n+    self, Size, Align, HasDataLayout, LayoutOf, TyLayout, Primitive\n+};\n use rustc::ty::subst::{Subst, Substs};\n-use rustc::ty::{self, Ty, TyCtxt, TypeAndMut};\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::query::TyCtxtAt;\n use rustc_data_structures::fx::{FxHashSet, FxHasher};\n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::mir::interpret::{\n-    GlobalId, Value, Scalar, FrameInfo, AllocType,\n-    EvalResult, EvalErrorKind, Pointer,\n+    GlobalId, Scalar, FrameInfo, AllocType,\n+    EvalResult, EvalErrorKind,\n     ScalarMaybeUndef,\n };\n \n use syntax::source_map::{self, Span};\n use syntax::ast::Mutability;\n \n-use super::{Place, PlaceExtra, Memory,\n-            HasMemory, MemoryKind,\n-            Machine, LocalValue};\n+use super::{\n+    Value, ValTy, Operand, MemPlace, MPlaceTy, Place,\n+    Memory, Machine\n+};\n \n macro_rules! validation_failure{\n     ($what:expr, $where:expr, $details:expr) => {{\n@@ -167,6 +170,33 @@ impl<'mir, 'tcx: 'mir> Hash for Frame<'mir, 'tcx> {\n     }\n }\n \n+// State of a local variable\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n+pub enum LocalValue {\n+    Dead,\n+    // Mostly for convenience, we re-use the `Operand` type here.\n+    // This is an optimization over just always having a pointer here;\n+    // we can thus avoid doing an allocation when the local just stores\n+    // immediate values *and* never has its address taken.\n+    Live(Operand),\n+}\n+\n+impl<'tcx> LocalValue {\n+    pub fn access(&self) -> EvalResult<'tcx, &Operand> {\n+        match self {\n+            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Live(ref val) => Ok(val),\n+        }\n+    }\n+\n+    pub fn access_mut(&mut self) -> EvalResult<'tcx, &mut Operand> {\n+        match self {\n+            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Live(ref mut val) => Ok(val),\n+        }\n+    }\n+}\n+\n /// The virtual machine state during const-evaluation at a given point in time.\n type EvalSnapshot<'a, 'mir, 'tcx, M>\n     = (M, Vec<Frame<'mir, 'tcx>>, Memory<'a, 'mir, 'tcx, M>);\n@@ -248,25 +278,6 @@ pub enum StackPopCleanup {\n     None,\n }\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct TyAndPacked<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub packed: bool,\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub struct ValTy<'tcx> {\n-    pub value: Value,\n-    pub ty: Ty<'tcx>,\n-}\n-\n-impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n-    type Target = Value;\n-    fn deref(&self) -> &Value {\n-        &self.value\n-    }\n-}\n-\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for &'a EvalContext<'a, 'mir, 'tcx, M> {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n@@ -348,12 +359,6 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         r\n     }\n \n-    pub fn alloc_ptr(&mut self, layout: TyLayout<'tcx>) -> EvalResult<'tcx, Pointer> {\n-        assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n-\n-        self.memory.allocate(layout.size, layout.align, MemoryKind::Stack)\n-    }\n-\n     pub fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M> {\n         &self.memory\n     }\n@@ -372,6 +377,30 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.stack.len() - 1\n     }\n \n+    /// Mark a storage as live, killing the previous content and returning it.\n+    /// Remember to deallocate that!\n+    pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, LocalValue> {\n+        trace!(\"{:?} is now live\", local);\n+\n+        let layout = self.layout_of_local(self.cur_frame(), local)?;\n+        let init = LocalValue::Live(self.uninit_operand(layout)?);\n+        // StorageLive *always* kills the value that's currently stored\n+        Ok(mem::replace(&mut self.frame_mut().locals[local], init))\n+    }\n+\n+    /// Returns the old value of the local.\n+    /// Remember to deallocate that!\n+    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue {\n+        trace!(\"{:?} is now dead\", local);\n+\n+        mem::replace(&mut self.frame_mut().locals[local], LocalValue::Dead)\n+    }\n+\n+    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n+        let ptr = self.memory.allocate_bytes(s.as_bytes());\n+        Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n+    }\n+\n     pub(super) fn resolve(&self, def_id: DefId, substs: &'tcx Substs<'tcx>) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         trace!(\"resolve: {:?}, {:#?}\", def_id, substs);\n         trace!(\"substs: {:#?}\", self.substs());\n@@ -420,41 +449,55 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted)\n     }\n \n+    pub fn layout_of_local(\n+        &self,\n+        frame: usize,\n+        local: mir::Local\n+    ) -> EvalResult<'tcx, TyLayout<'tcx>> {\n+        let local_ty = self.stack[frame].mir.local_decls[local].ty;\n+        let local_ty = self.monomorphize(\n+            local_ty,\n+            self.stack[frame].instance.substs\n+        );\n+        self.layout_of(local_ty)\n+    }\n+\n     /// Return the size and alignment of the value at the given type.\n     /// Note that the value does not matter if the type is sized. For unsized types,\n     /// the value has to be a fat pointer, and we only care about the \"extra\" data in it.\n     pub fn size_and_align_of_dst(\n         &self,\n-        ty: Ty<'tcx>,\n-        value: Value,\n+        val: ValTy<'tcx>,\n     ) -> EvalResult<'tcx, (Size, Align)> {\n-        let layout = self.layout_of(ty)?;\n-        if !layout.is_unsized() {\n-            Ok(layout.size_and_align())\n+        if !val.layout.is_unsized() {\n+            Ok(val.layout.size_and_align())\n         } else {\n-            match ty.sty {\n+            match val.layout.ty.sty {\n                 ty::TyAdt(..) | ty::TyTuple(..) => {\n                     // First get the size of all statically known fields.\n                     // Don't use type_of::sizing_type_of because that expects t to be sized,\n                     // and it also rounds up to alignment, which we want to avoid,\n                     // as the unsized field's alignment could be smaller.\n-                    assert!(!ty.is_simd());\n-                    debug!(\"DST {} layout: {:?}\", ty, layout);\n+                    assert!(!val.layout.ty.is_simd());\n+                    debug!(\"DST layout: {:?}\", val.layout);\n \n-                    let sized_size = layout.fields.offset(layout.fields.count() - 1);\n-                    let sized_align = layout.align;\n+                    let sized_size = val.layout.fields.offset(val.layout.fields.count() - 1);\n+                    let sized_align = val.layout.align;\n                     debug!(\n                         \"DST {} statically sized prefix size: {:?} align: {:?}\",\n-                        ty,\n+                        val.layout.ty,\n                         sized_size,\n                         sized_align\n                     );\n \n                     // Recurse to get the size of the dynamically sized field (must be\n                     // the last field).\n-                    let field_ty = layout.field(self, layout.fields.count() - 1)?.ty;\n+                    let field_layout = val.layout.field(self, val.layout.fields.count() - 1)?;\n                     let (unsized_size, unsized_align) =\n-                        self.size_and_align_of_dst(field_ty, value)?;\n+                        self.size_and_align_of_dst(ValTy {\n+                            value: val.value,\n+                            layout: field_layout\n+                        })?;\n \n                     // FIXME (#26403, #27023): We should be adding padding\n                     // to `sized_size` (to accommodate the `unsized_align`\n@@ -484,18 +527,18 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                     Ok((size.abi_align(align), align))\n                 }\n                 ty::TyDynamic(..) => {\n-                    let (_, vtable) = self.into_ptr_vtable_pair(value)?;\n+                    let (_, vtable) = val.to_scalar_dyn_trait()?;\n                     // the second entry in the vtable is the dynamic size of the object.\n                     self.read_size_and_align_from_vtable(vtable)\n                 }\n \n                 ty::TySlice(_) | ty::TyStr => {\n-                    let (elem_size, align) = layout.field(self, 0)?.size_and_align();\n-                    let (_, len) = self.into_slice(value)?;\n+                    let (elem_size, align) = val.layout.field(self, 0)?.size_and_align();\n+                    let (_, len) = val.to_scalar_slice(self)?;\n                     Ok((elem_size * len, align))\n                 }\n \n-                _ => bug!(\"size_of_val::<{:?}>\", ty),\n+                _ => bug!(\"size_of_val::<{:?}>\", val.layout.ty),\n             }\n         }\n     }\n@@ -526,10 +569,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n         // don't allocate at all for trivial constants\n         if mir.local_decls.len() > 1 {\n-            let mut locals = IndexVec::from_elem(LocalValue::Dead, &mir.local_decls);\n-            for (local, decl) in locals.iter_mut().zip(mir.local_decls.iter()) {\n-                *local = LocalValue::Live(self.init_value(decl.ty)?);\n-            }\n+            // We put some marker value into the locals that we later want to initialize.\n+            // This can be anything except for LocalValue::Dead -- because *that* is the\n+            // value we use for things that we know are initially dead.\n+            let dummy =\n+                LocalValue::Live(Operand::Immediate(Value::Scalar(ScalarMaybeUndef::Undef)));\n+            self.frame_mut().locals = IndexVec::from_elem(dummy, &mir.local_decls);\n+            // Now mark those locals as dead that we do not want to initialize\n             match self.tcx.describe_def(instance.def_id()) {\n                 // statics and constants don't have `Storage*` statements, no need to look for them\n                 Some(Def::Static(..)) | Some(Def::Const(..)) | Some(Def::AssociatedConst(..)) => {},\n@@ -540,14 +586,22 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             use rustc::mir::StatementKind::{StorageDead, StorageLive};\n                             match stmt.kind {\n                                 StorageLive(local) |\n-                                StorageDead(local) => locals[local] = LocalValue::Dead,\n+                                StorageDead(local) => {\n+                                    // Worst case we are overwriting a dummy, no deallocation needed\n+                                    self.storage_dead(local);\n+                                }\n                                 _ => {}\n                             }\n                         }\n                     }\n                 },\n             }\n-            self.frame_mut().locals = locals;\n+            // Finally, properly initialize all those that still have the dummy value\n+            for local in mir.local_decls.indices() {\n+                if self.frame().locals[local] == dummy {\n+                    self.storage_live(local)?;\n+                }\n+            }\n         }\n \n         self.memory.cur_frame = self.cur_frame();\n@@ -571,10 +625,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n         match frame.return_to_block {\n             StackPopCleanup::MarkStatic(mutable) => {\n-                if let Place::Ptr { ptr, .. } = frame.return_place {\n+                if let Place::Ptr(MemPlace { ptr, .. }) = frame.return_place {\n                     // FIXME: to_ptr()? might be too extreme here, static zsts might reach this under certain conditions\n                     self.memory.mark_static_initialized(\n-                        ptr.unwrap_or_err()?.to_ptr()?.alloc_id,\n+                        ptr.to_ptr()?.alloc_id,\n                         mutable,\n                     )?\n                 } else {\n@@ -592,18 +646,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         Ok(())\n     }\n \n-    pub(super) fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n-        match ty.sty {\n-            ty::TyRawPtr(ty::TypeAndMut { ty, .. }) |\n-            ty::TyRef(_, ty, _) => !self.type_is_sized(ty),\n-            ty::TyAdt(def, _) if def.is_box() => !self.type_is_sized(ty.boxed_ty()),\n-            _ => false,\n-        }\n-    }\n-\n-    pub fn read_global_as_value(&mut self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, Value> {\n-        let cv = self.const_eval(gid)?;\n-        self.const_to_value(cv.val)\n+    crate fn deallocate_local(&mut self, local: LocalValue) -> EvalResult<'tcx> {\n+        // FIXME: should we tell the user that there was a local which was never written to?\n+        if let LocalValue::Live(Operand::Indirect(MemPlace { ptr, .. })) = local {\n+            trace!(\"deallocating local\");\n+            let ptr = ptr.to_ptr()?;\n+            self.memory.dump_alloc(ptr.alloc_id);\n+            self.memory.deallocate_local(ptr)?;\n+        };\n+        Ok(())\n     }\n \n     pub fn const_eval(&self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, &'tcx ty::Const<'tcx>> {\n@@ -704,62 +755,56 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n     /// This function checks the memory where `ptr` points to.\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n-    pub fn validate_ptr_target(\n+    pub fn validate_mplace(\n         &self,\n-        ptr: Pointer,\n-        ptr_align: Align,\n-        mut layout: TyLayout<'tcx>,\n+        dest: MPlaceTy<'tcx>,\n         path: String,\n-        seen: &mut FxHashSet<(Pointer, Ty<'tcx>)>,\n-        todo: &mut Vec<(Pointer, Ty<'tcx>, String)>,\n+        seen: &mut FxHashSet<(MPlaceTy<'tcx>)>,\n+        todo: &mut Vec<(MPlaceTy<'tcx>, String)>,\n     ) -> EvalResult<'tcx> {\n-        self.memory.dump_alloc(ptr.alloc_id);\n-        trace!(\"validate_ptr_target: {:?}, {:#?}\", ptr, layout);\n+        self.memory.dump_alloc(dest.to_ptr()?.alloc_id);\n+        trace!(\"validate_mplace: {:?}, {:#?}\", *dest, dest.layout);\n \n-        let variant;\n-        match layout.variants {\n+        // Find the right variant\n+        let (variant, dest) = match dest.layout.variants {\n             layout::Variants::NicheFilling { niche: ref tag, .. } |\n             layout::Variants::Tagged { ref tag, .. } => {\n                 let size = tag.value.size(self);\n-                let (tag_value, tag_layout) = self.read_field(\n-                    Value::ByRef(ptr.into(), ptr_align),\n-                    None,\n-                    mir::Field::new(0),\n-                    layout,\n-                )?;\n-                let tag_value = self.value_to_scalar(ValTy {\n-                    value: tag_value,\n-                    ty: tag_layout.ty\n-                })?;\n+                // we first read the tag value as scalar, to be able to validate it\n+                let tag_mplace = self.mplace_field(dest, 0)?;\n+                let tag_value = self.read_scalar(tag_mplace.into())?;\n                 let path = format!(\"{}.TAG\", path);\n                 self.validate_scalar(\n-                    ScalarMaybeUndef::Scalar(tag_value), size, tag, &path, tag_layout.ty\n-                )?;\n-                let variant_index = self.read_discriminant_as_variant_index(\n-                    Place::from_ptr(ptr, ptr_align),\n-                    layout,\n+                    tag_value, size, tag, &path, tag_mplace.layout.ty\n                 )?;\n-                variant = variant_index;\n-                layout = layout.for_variant(self, variant_index);\n-                trace!(\"variant layout: {:#?}\", layout);\n+                // then we read it again to get the index, to continue\n+                let variant = self.read_discriminant_as_variant_index(dest.into())?;\n+                let dest = self.mplace_downcast(dest, variant)?;\n+                trace!(\"variant layout: {:#?}\", dest.layout);\n+                (variant, dest)\n             },\n-            layout::Variants::Single { index } => variant = index,\n-        }\n-        match layout.fields {\n+            layout::Variants::Single { index } => {\n+                (index, dest)\n+            }\n+        };\n+\n+        // Validate all fields\n+        match dest.layout.fields {\n             // primitives are unions with zero fields\n             layout::FieldPlacement::Union(0) => {\n-                match layout.abi {\n+                match dest.layout.abi {\n                     // nothing to do, whatever the pointer points to, it is never going to be read\n                     layout::Abi::Uninhabited => validation_failure!(\"a value of an uninhabited type\", path),\n                     // check that the scalar is a valid pointer or that its bit range matches the\n                     // expectation.\n-                    layout::Abi::Scalar(ref scalar) => {\n-                        let size = scalar.value.size(self);\n-                        let value = self.memory.read_scalar(ptr, ptr_align, size)?;\n-                        self.validate_scalar(value, size, scalar, &path, layout.ty)?;\n-                        if scalar.value == Primitive::Pointer {\n+                    layout::Abi::Scalar(ref scalar_layout) => {\n+                        let size = scalar_layout.value.size(self);\n+                        let value = self.read_value(dest.into())?;\n+                        let scalar = value.to_scalar_or_undef();\n+                        self.validate_scalar(scalar, size, scalar_layout, &path, dest.layout.ty)?;\n+                        if scalar_layout.value == Primitive::Pointer {\n                             // ignore integer pointers, we can't reason about the final hardware\n-                            if let Scalar::Ptr(ptr) = value.unwrap_or_err()? {\n+                            if let Scalar::Ptr(ptr) = scalar.not_undef()? {\n                                 let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n                                 if let Some(AllocType::Static(did)) = alloc_kind {\n                                     // statics from other crates are already checked\n@@ -768,17 +813,19 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                         return Ok(());\n                                     }\n                                 }\n-                                if let Some(tam) = layout.ty.builtin_deref(false) {\n+                                if value.layout.ty.builtin_deref(false).is_some() {\n+                                    trace!(\"Recursing below ptr {:#?}\", value);\n+                                    let ptr_place = self.ref_to_mplace(value)?;\n                                     // we have not encountered this pointer+layout combination before\n-                                    if seen.insert((ptr, tam.ty)) {\n-                                        todo.push((ptr, tam.ty, format!(\"(*{})\", path)))\n+                                    if seen.insert(ptr_place) {\n+                                        todo.push((ptr_place, format!(\"(*{})\", path)))\n                                     }\n                                 }\n                             }\n                         }\n                         Ok(())\n                     },\n-                    _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", layout.abi),\n+                    _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", dest.layout.abi),\n                 }\n             }\n             layout::FieldPlacement::Union(_) => {\n@@ -787,52 +834,63 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n                 Ok(())\n             },\n-            layout::FieldPlacement::Array { stride, count } => {\n-                let elem_layout = layout.field(self, 0)?;\n+            layout::FieldPlacement::Array { count, .. } => {\n                 for i in 0..count {\n                     let mut path = path.clone();\n-                    self.write_field_name(&mut path, layout.ty, i as usize, variant).unwrap();\n-                    self.validate_ptr_target(ptr.offset(stride * i, self)?, ptr_align, elem_layout, path, seen, todo)?;\n+                    self.dump_field_name(&mut path, dest.layout.ty, i as usize, variant).unwrap();\n+                    let field = self.mplace_field(dest, i)?;\n+                    self.validate_mplace(field, path, seen, todo)?;\n                 }\n                 Ok(())\n             },\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n-\n-                // check length field and vtable field\n-                match layout.ty.builtin_deref(false).map(|tam| &tam.ty.sty) {\n+                // fat pointers need special treatment\n+                match dest.layout.ty.builtin_deref(false).map(|tam| &tam.ty.sty) {\n                     | Some(ty::TyStr)\n                     | Some(ty::TySlice(_)) => {\n-                        let (len, len_layout) = self.read_field(\n-                            Value::ByRef(ptr.into(), ptr_align),\n-                            None,\n-                            mir::Field::new(1),\n-                            layout,\n-                        )?;\n-                        let len = self.value_to_scalar(ValTy { value: len, ty: len_layout.ty })?;\n-                        if len.to_bits(len_layout.size).is_err() {\n-                            return validation_failure!(\"length is not a valid integer\", path);\n+                        // check the length\n+                        let len_mplace = self.mplace_field(dest, 1)?;\n+                        let len = self.read_scalar(len_mplace.into())?;\n+                        let len = match len.to_bits(len_mplace.layout.size) {\n+                            Err(_) => return validation_failure!(\"length is not a valid integer\", path),\n+                            Ok(len) => len as u64,\n+                        };\n+                        // get the fat ptr\n+                        let ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n+                        let mut path = path.clone();\n+                        self.dump_field_name(&mut path, dest.layout.ty, 0, variant).unwrap();\n+                        // check all fields\n+                        for i in 0..len {\n+                            let mut path = path.clone();\n+                            self.dump_field_name(&mut path, ptr.layout.ty, i as usize, 0).unwrap();\n+                            let field = self.mplace_field(ptr, i)?;\n+                            self.validate_mplace(field, path, seen, todo)?;\n                         }\n+                        // FIXME: For a TyStr, check that this is valid UTF-8\n                     },\n                     Some(ty::TyDynamic(..)) => {\n-                        let (vtable, vtable_layout) = self.read_field(\n-                            Value::ByRef(ptr.into(), ptr_align),\n-                            None,\n-                            mir::Field::new(1),\n-                            layout,\n-                        )?;\n-                        let vtable = self.value_to_scalar(ValTy { value: vtable, ty: vtable_layout.ty })?;\n+                        let vtable_mplace = self.mplace_field(dest, 1)?;\n+                        let vtable = self.read_scalar(vtable_mplace.into())?;\n                         if vtable.to_ptr().is_err() {\n                             return validation_failure!(\"vtable address is not a pointer\", path);\n                         }\n-                    }\n-                    _ => {},\n-                }\n-                for (i, &offset) in offsets.iter().enumerate() {\n-                    let field_layout = layout.field(self, i)?;\n-                    let mut path = path.clone();\n-                    self.write_field_name(&mut path, layout.ty, i, variant).unwrap();\n-                    self.validate_ptr_target(ptr.offset(offset, self)?, ptr_align, field_layout, path, seen, todo)?;\n+                        // get the fat ptr\n+                        let _ptr = self.ref_to_mplace(self.read_value(dest.into())?)?;\n+                        // FIXME: What can we verify about this?\n+                    },\n+                    Some(ty) =>\n+                        bug!(\"Unexpected fat pointer target type {:?}\", ty),\n+                    None => {\n+                        // Not a pointer, perform regular aggregate handling below\n+                        for i in 0..offsets.len() {\n+                            let mut path = path.clone();\n+                            self.dump_field_name(&mut path, dest.layout.ty, i, variant).unwrap();\n+                            let field = self.mplace_field(dest, i as u64)?;\n+                            self.validate_mplace(field, path, seen, todo)?;\n+                        }\n+                    },\n                 }\n+\n                 Ok(())\n             }\n         }\n@@ -858,132 +916,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         }\n     }\n \n-    fn unsize_into_ptr(\n-        &mut self,\n-        src: Value,\n-        src_ty: Ty<'tcx>,\n-        dest: Place,\n-        dest_ty: Ty<'tcx>,\n-        sty: Ty<'tcx>,\n-        dty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        // A<Struct> -> A<Trait> conversion\n-        let (src_pointee_ty, dest_pointee_ty) = self.tcx.struct_lockstep_tails(sty, dty);\n-\n-        match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n-            (&ty::TyArray(_, length), &ty::TySlice(_)) => {\n-                let ptr = self.into_ptr(src)?;\n-                // u64 cast is from usize to u64, which is always good\n-                let valty = ValTy {\n-                    value: ptr.to_value_with_len(length.unwrap_usize(self.tcx.tcx), self.tcx.tcx),\n-                    ty: dest_ty,\n-                };\n-                self.write_value(valty, dest)\n-            }\n-            (&ty::TyDynamic(..), &ty::TyDynamic(..)) => {\n-                // For now, upcasts are limited to changes in marker\n-                // traits, and hence never actually require an actual\n-                // change to the vtable.\n-                let valty = ValTy {\n-                    value: src,\n-                    ty: dest_ty,\n-                };\n-                self.write_value(valty, dest)\n-            }\n-            (_, &ty::TyDynamic(ref data, _)) => {\n-                let trait_ref = data.principal().unwrap().with_self_ty(\n-                    *self.tcx,\n-                    src_pointee_ty,\n-                );\n-                let trait_ref = self.tcx.erase_regions(&trait_ref);\n-                let vtable = self.get_vtable(src_pointee_ty, trait_ref)?;\n-                let ptr = self.into_ptr(src)?;\n-                let valty = ValTy {\n-                    value: ptr.to_value_with_vtable(vtable),\n-                    ty: dest_ty,\n-                };\n-                self.write_value(valty, dest)\n-            }\n-\n-            _ => bug!(\"invalid unsizing {:?} -> {:?}\", src_ty, dest_ty),\n-        }\n-    }\n-\n-    crate fn unsize_into(\n-        &mut self,\n-        src: Value,\n-        src_layout: TyLayout<'tcx>,\n-        dst: Place,\n-        dst_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        match (&src_layout.ty.sty, &dst_layout.ty.sty) {\n-            (&ty::TyRef(_, s, _), &ty::TyRef(_, d, _)) |\n-            (&ty::TyRef(_, s, _), &ty::TyRawPtr(TypeAndMut { ty: d, .. })) |\n-            (&ty::TyRawPtr(TypeAndMut { ty: s, .. }),\n-             &ty::TyRawPtr(TypeAndMut { ty: d, .. })) => {\n-                self.unsize_into_ptr(src, src_layout.ty, dst, dst_layout.ty, s, d)\n-            }\n-            (&ty::TyAdt(def_a, _), &ty::TyAdt(def_b, _)) => {\n-                assert_eq!(def_a, def_b);\n-                if def_a.is_box() || def_b.is_box() {\n-                    if !def_a.is_box() || !def_b.is_box() {\n-                        bug!(\"invalid unsizing between {:?} -> {:?}\", src_layout, dst_layout);\n-                    }\n-                    return self.unsize_into_ptr(\n-                        src,\n-                        src_layout.ty,\n-                        dst,\n-                        dst_layout.ty,\n-                        src_layout.ty.boxed_ty(),\n-                        dst_layout.ty.boxed_ty(),\n-                    );\n-                }\n-\n-                // unsizing of generic struct with pointer fields\n-                // Example: `Arc<T>` -> `Arc<Trait>`\n-                // here we need to increase the size of every &T thin ptr field to a fat ptr\n-                for i in 0..src_layout.fields.count() {\n-                    let (dst_f_place, dst_field) =\n-                        self.place_field(dst, mir::Field::new(i), dst_layout)?;\n-                    if dst_field.is_zst() {\n-                        continue;\n-                    }\n-                    let (src_f_value, src_field) = match src {\n-                        Value::ByRef(ptr, align) => {\n-                            let src_place = Place::from_scalar_ptr(ptr.into(), align);\n-                            let (src_f_place, src_field) =\n-                                self.place_field(src_place, mir::Field::new(i), src_layout)?;\n-                            (self.read_place(src_f_place)?, src_field)\n-                        }\n-                        Value::Scalar(_) | Value::ScalarPair(..) => {\n-                            let src_field = src_layout.field(&self, i)?;\n-                            assert_eq!(src_layout.fields.offset(i).bytes(), 0);\n-                            assert_eq!(src_field.size, src_layout.size);\n-                            (src, src_field)\n-                        }\n-                    };\n-                    if src_field.ty == dst_field.ty {\n-                        self.write_value(ValTy {\n-                            value: src_f_value,\n-                            ty: src_field.ty,\n-                        }, dst_f_place)?;\n-                    } else {\n-                        self.unsize_into(src_f_value, src_field, dst_f_place, dst_field)?;\n-                    }\n-                }\n-                Ok(())\n-            }\n-            _ => {\n-                bug!(\n-                    \"unsize_into: invalid conversion: {:?} -> {:?}\",\n-                    src_layout,\n-                    dst_layout\n-                )\n-            }\n-        }\n-    }\n-\n-    pub fn dump_local(&self, place: Place) {\n+    pub fn dump_place(&self, place: Place) {\n         // Debug output\n         if !log_enabled!(::log::Level::Trace) {\n             return;\n@@ -1005,22 +938,23 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                             panic!(\"Failed to access local: {:?}\", err);\n                         }\n                     }\n-                    Ok(Value::ByRef(ptr, align)) => {\n+                    Ok(Operand::Indirect(mplace)) => {\n+                        let (ptr, align) = mplace.to_scalar_ptr_align();\n                         match ptr {\n                             Scalar::Ptr(ptr) => {\n                                 write!(msg, \" by align({}) ref:\", align.abi()).unwrap();\n                                 allocs.push(ptr.alloc_id);\n                             }\n-                            ptr => write!(msg, \" integral by ref: {:?}\", ptr).unwrap(),\n+                            ptr => write!(msg, \" by integral ref: {:?}\", ptr).unwrap(),\n                         }\n                     }\n-                    Ok(Value::Scalar(val)) => {\n+                    Ok(Operand::Immediate(Value::Scalar(val))) => {\n                         write!(msg, \" {:?}\", val).unwrap();\n                         if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n-                    Ok(Value::ScalarPair(val1, val2)) => {\n+                    Ok(Operand::Immediate(Value::ScalarPair(val1, val2))) => {\n                         write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n                         if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val1 {\n                             allocs.push(ptr.alloc_id);\n@@ -1034,9 +968,10 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 trace!(\"{}\", msg);\n                 self.memory.dump_allocs(allocs);\n             }\n-            Place::Ptr { ptr, align, .. } => {\n+            Place::Ptr(mplace) => {\n+                let (ptr, align) = mplace.to_scalar_ptr_align();\n                 match ptr {\n-                    ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) => {\n+                    Scalar::Ptr(ptr) => {\n                         trace!(\"by align({}) ref:\", align.abi());\n                         self.memory.dump_alloc(ptr.alloc_id);\n                     }\n@@ -1092,7 +1027,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n         super::truncate(value, ty)\n     }\n \n-    fn write_field_name(&self, s: &mut String, ty: Ty<'tcx>, i: usize, variant: usize) -> ::std::fmt::Result {\n+    fn dump_field_name(&self, s: &mut String, ty: Ty<'tcx>, i: usize, variant: usize) -> ::std::fmt::Result {\n         match ty.sty {\n             ty::TyBool |\n             ty::TyChar |\n@@ -1154,8 +1089,25 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n \n             ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n             ty::TyInfer(_) | ty::TyError => {\n-                bug!(\"write_field_name: unexpected type `{}`\", ty)\n+                bug!(\"dump_field_name: unexpected type `{}`\", ty)\n             }\n         }\n     }\n }\n+\n+pub fn sign_extend(value: u128, layout: TyLayout<'_>) -> u128 {\n+    let size = layout.size.bits();\n+    assert!(layout.abi.is_signed());\n+    // sign extend\n+    let shift = 128 - size;\n+    // shift the unsigned value to the left\n+    // and back to the right as signed (essentially fills with FF on the left)\n+    (((value << shift) as i128) >> shift) as u128\n+}\n+\n+pub fn truncate(value: u128, layout: TyLayout<'_>) -> u128 {\n+    let size = layout.size.bits();\n+    let shift = 128 - size;\n+    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+    (value << shift) >> shift\n+}"}, {"sha": "84556c7249dbde9f6f2ea5795f63a706426037df", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -5,10 +5,10 @@\n use std::hash::Hash;\n \n use rustc::mir::interpret::{AllocId, EvalResult, Scalar, Pointer, AccessKind, GlobalId};\n-use super::{EvalContext, Place, ValTy, Memory};\n+use super::{EvalContext, PlaceTy, OpTy, Memory};\n \n use rustc::mir;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, layout::TyLayout};\n use rustc::ty::layout::Size;\n use syntax::source_map::Span;\n use syntax::ast::Mutability;\n@@ -31,19 +31,17 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n     fn eval_fn_call<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Place, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n+        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        args: &[OpTy<'tcx>],\n         span: Span,\n-        sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx, bool>;\n \n     /// directly process an intrinsic without pushing a stack frame.\n     fn call_intrinsic<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n-        args: &[ValTy<'tcx>],\n-        dest: Place,\n-        dest_layout: ty::layout::TyLayout<'tcx>,\n+        args: &[OpTy<'tcx>],\n+        dest: PlaceTy<'tcx>,\n         target: mir::BasicBlock,\n     ) -> EvalResult<'tcx>;\n \n@@ -57,9 +55,9 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n         ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: Scalar,\n-        left_ty: Ty<'tcx>,\n+        left_layout: TyLayout<'tcx>,\n         right: Scalar,\n-        right_ty: Ty<'tcx>,\n+        right_layout: TyLayout<'tcx>,\n     ) -> EvalResult<'tcx, Option<(Scalar, bool)>>;\n \n     /// Called when trying to mark machine defined `MemoryKinds` as static\n@@ -81,8 +79,7 @@ pub trait Machine<'mir, 'tcx>: Clone + Eq + Hash {\n     /// Returns a pointer to the allocated memory\n     fn box_alloc<'a>(\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n-        ty: Ty<'tcx>,\n-        dest: Place,\n+        dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx>;\n \n     /// Called when trying to access a global declared with a `linkage` attribute"}, {"sha": "461b98e4ff39e1b8dbfb82726a6d8078ecbb30ff", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 6, "deletions": 59, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -7,7 +7,7 @@ use rustc::ty::Instance;\n use rustc::ty::ParamEnv;\n use rustc::ty::query::TyCtxtAt;\n use rustc::ty::layout::{self, Align, TargetDataLayout, Size};\n-use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, Value, ScalarMaybeUndef,\n+use rustc::mir::interpret::{Pointer, AllocId, Allocation, AccessKind, ScalarMaybeUndef,\n                             EvalResult, Scalar, EvalErrorKind, GlobalId, AllocType};\n pub use rustc::mir::interpret::{write_target_uint, write_target_int, read_target_uint};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap, FxHasher};\n@@ -301,6 +301,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Check if the pointer is \"in-bounds\". Notice that a pointer pointing at the end\n+    /// of an allocation (i.e., at the first *inaccessible* location) *is* considered\n+    /// in-bounds!  This follows C's/LLVM's rules.\n     pub fn check_bounds(&self, ptr: Pointer, access: bool) -> EvalResult<'tcx> {\n         let alloc = self.get(ptr.alloc_id)?;\n         let allocation_size = alloc.bytes.len() as u64;\n@@ -331,7 +334,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n             assert!(self.tcx.is_static(def_id).is_some());\n             EvalErrorKind::ReferencedConstant(err).into()\n         }).map(|val| {\n-            self.tcx.const_value_to_allocation(val)\n+            self.tcx.const_to_allocation(val)\n         })\n     }\n \n@@ -828,6 +831,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         {\n             let dst = self.get_bytes_mut(ptr, type_size, ptr_align.min(type_align))?;\n+            // TODO: Why do we still need `signed` here? We do NOT have it for loading!\n             if signed {\n                 write_target_int(endianness, dst, bytes as i128).unwrap();\n             } else {\n@@ -992,63 +996,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n pub trait HasMemory<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'mir, 'tcx>> {\n     fn memory_mut(&mut self) -> &mut Memory<'a, 'mir, 'tcx, M>;\n     fn memory(&self) -> &Memory<'a, 'mir, 'tcx, M>;\n-\n-    /// Convert the value into a pointer (or a pointer-sized integer).  If the value is a ByRef,\n-    /// this may have to perform a load.\n-    fn into_ptr(\n-        &self,\n-        value: Value,\n-    ) -> EvalResult<'tcx, ScalarMaybeUndef> {\n-        Ok(match value {\n-            Value::ByRef(ptr, align) => {\n-                self.memory().read_ptr_sized(ptr.to_ptr()?, align)?\n-            }\n-            Value::Scalar(ptr) |\n-            Value::ScalarPair(ptr, _) => ptr,\n-        }.into())\n-    }\n-\n-    fn into_ptr_vtable_pair(\n-        &self,\n-        value: Value,\n-    ) -> EvalResult<'tcx, (ScalarMaybeUndef, Pointer)> {\n-        match value {\n-            Value::ByRef(ref_ptr, align) => {\n-                let mem = self.memory();\n-                let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n-                let vtable = mem.read_ptr_sized(\n-                    ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n-                    align\n-                )?.unwrap_or_err()?.to_ptr()?;\n-                Ok((ptr, vtable))\n-            }\n-\n-            Value::ScalarPair(ptr, vtable) => Ok((ptr, vtable.unwrap_or_err()?.to_ptr()?)),\n-            _ => bug!(\"expected ptr and vtable, got {:?}\", value),\n-        }\n-    }\n-\n-    fn into_slice(\n-        &self,\n-        value: Value,\n-    ) -> EvalResult<'tcx, (ScalarMaybeUndef, u64)> {\n-        match value {\n-            Value::ByRef(ref_ptr, align) => {\n-                let mem = self.memory();\n-                let ptr = mem.read_ptr_sized(ref_ptr.to_ptr()?, align)?.into();\n-                let len = mem.read_ptr_sized(\n-                    ref_ptr.ptr_offset(mem.pointer_size(), &mem.tcx.data_layout)?.to_ptr()?,\n-                    align\n-                )?.unwrap_or_err()?.to_bits(mem.pointer_size())? as u64;\n-                Ok((ptr, len))\n-            }\n-            Value::ScalarPair(ptr, val) => {\n-                let len = val.unwrap_or_err()?.to_bits(self.memory().pointer_size())?;\n-                Ok((ptr, len as u64))\n-            }\n-            Value::Scalar(_) => bug!(\"expected ptr and length, got {:?}\", value),\n-        }\n-    }\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> HasMemory<'a, 'mir, 'tcx, M> for Memory<'a, 'mir, 'tcx, M> {"}, {"sha": "452708179009ec0e7e6345a7250ebdf74cce6b48", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1,23 +1,23 @@\n //! An interpreter for MIR used in CTFE and by miri\n \n mod cast;\n-mod const_eval;\n mod eval_context;\n mod place;\n+mod operand;\n mod machine;\n mod memory;\n mod operator;\n mod step;\n mod terminator;\n mod traits;\n-mod value;\n+mod const_eval;\n \n pub use self::eval_context::{\n     EvalContext, Frame, StackPopCleanup,\n-    TyAndPacked, ValTy,\n+    sign_extend, truncate, LocalValue,\n };\n \n-pub use self::place::{Place, PlaceExtra};\n+pub use self::place::{Place, PlaceExtra, PlaceTy, MemPlace, MPlaceTy};\n \n pub use self::memory::{Memory, MemoryKind, HasMemory};\n \n@@ -26,34 +26,13 @@ pub use self::const_eval::{\n     mk_borrowck_eval_cx,\n     mk_eval_cx,\n     CompileTimeEvaluator,\n-    const_value_to_allocation_provider,\n+    const_to_allocation_provider,\n     const_eval_provider,\n-    const_val_field,\n+    const_field,\n     const_variant_index,\n-    value_to_const_value,\n+    op_to_const,\n };\n \n pub use self::machine::Machine;\n \n-pub use self::memory::{write_target_uint, write_target_int, read_target_uint};\n-\n-use self::value::LocalValue;\n-\n-use rustc::ty::layout::TyLayout;\n-\n-pub fn sign_extend(value: u128, layout: TyLayout<'_>) -> u128 {\n-    let size = layout.size.bits();\n-    assert!(layout.abi.is_signed());\n-    // sign extend\n-    let shift = 128 - size;\n-    // shift the unsigned value to the left\n-    // and back to the right as signed (essentially fills with FF on the left)\n-    (((value << shift) as i128) >> shift) as u128\n-}\n-\n-pub fn truncate(value: u128, layout: TyLayout<'_>) -> u128 {\n-    let size = layout.size.bits();\n-    let shift = 128 - size;\n-    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n-    (value << shift) >> shift\n-}\n+pub use self::operand::{Value, ValTy, Operand, OpTy};"}, {"sha": "ed2a9f06a91571a4280a1998bc912b9a348ceb4a", "filename": "src/librustc_mir/interpret/operand.rs", "status": "added", "additions": 572, "deletions": 0, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -0,0 +1,572 @@\n+//! Functions concerning immediate values and operands, and reading from operands.\n+//! All high-level functions to read from memory work on operands as sources.\n+\n+use std::convert::TryInto;\n+\n+use rustc::mir;\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, HasDataLayout, IntegerExt};\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+use rustc::mir::interpret::{\n+    GlobalId, ConstValue, Scalar, EvalResult, Pointer, ScalarMaybeUndef, EvalErrorKind\n+};\n+use super::{EvalContext, Machine, MemPlace, MPlaceTy, PlaceExtra, MemoryKind};\n+\n+/// A `Value` represents a single immediate self-contained Rust value.\n+///\n+/// For optimization of a few very common cases, there is also a representation for a pair of\n+/// primitive values (`ScalarPair`). It allows Miri to avoid making allocations for checked binary\n+/// operations and fat pointers. This idea was taken from rustc's codegen.\n+/// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n+/// defined on `Value`, and do not have to work with a `Place`.\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Value {\n+    Scalar(ScalarMaybeUndef),\n+    ScalarPair(ScalarMaybeUndef, ScalarMaybeUndef),\n+}\n+\n+impl<'tcx> Value {\n+    pub fn new_slice(\n+        val: Scalar,\n+        len: u64,\n+        cx: impl HasDataLayout\n+    ) -> Self {\n+        Value::ScalarPair(val.into(), Scalar::Bits {\n+            bits: len as u128,\n+            size: cx.data_layout().pointer_size.bytes() as u8,\n+        }.into())\n+    }\n+\n+    pub fn new_dyn_trait(val: Scalar, vtable: Pointer) -> Self {\n+        Value::ScalarPair(val.into(), Scalar::Ptr(vtable).into())\n+    }\n+\n+    pub fn to_scalar_or_undef(self) -> ScalarMaybeUndef {\n+        match self {\n+            Value::Scalar(val) => val,\n+            Value::ScalarPair(..) => bug!(\"Got a fat pointer where a scalar was expected\"),\n+        }\n+    }\n+\n+    pub fn to_scalar(self) -> EvalResult<'tcx, Scalar> {\n+        self.to_scalar_or_undef().not_undef()\n+    }\n+\n+    /// Convert the value into a pointer (or a pointer-sized integer).\n+    pub fn to_scalar_ptr(self) -> EvalResult<'tcx, Scalar> {\n+        match self {\n+            Value::Scalar(ptr) |\n+            Value::ScalarPair(ptr, _) => ptr.not_undef(),\n+        }\n+    }\n+\n+    pub fn to_scalar_dyn_trait(self) -> EvalResult<'tcx, (Scalar, Pointer)> {\n+        match self {\n+            Value::ScalarPair(ptr, vtable) =>\n+                Ok((ptr.not_undef()?, vtable.to_ptr()?)),\n+            _ => bug!(\"expected ptr and vtable, got {:?}\", self),\n+        }\n+    }\n+\n+    pub fn to_scalar_slice(self, cx: impl HasDataLayout) -> EvalResult<'tcx, (Scalar, u64)> {\n+        match self {\n+            Value::ScalarPair(ptr, val) => {\n+                let len = val.to_bits(cx.data_layout().pointer_size)?;\n+                Ok((ptr.not_undef()?, len as u64))\n+            }\n+            _ => bug!(\"expected ptr and length, got {:?}\", self),\n+        }\n+    }\n+}\n+\n+// ScalarPair needs a type to interpret, so we often have a value and a type together\n+// as input for binary and cast operations.\n+#[derive(Copy, Clone, Debug)]\n+pub struct ValTy<'tcx> {\n+    pub value: Value,\n+    pub layout: TyLayout<'tcx>,\n+}\n+\n+impl<'tcx> ::std::ops::Deref for ValTy<'tcx> {\n+    type Target = Value;\n+    fn deref(&self) -> &Value {\n+        &self.value\n+    }\n+}\n+\n+/// An `Operand` is the result of computing a `mir::Operand`. It can be immediate,\n+/// or still in memory.  The latter is an optimization, to delay reading that chunk of\n+/// memory and to avoid having to store arbitrary-sized data here.\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub enum Operand {\n+    Immediate(Value),\n+    Indirect(MemPlace),\n+}\n+\n+impl Operand {\n+    #[inline]\n+    pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n+        Operand::Indirect(MemPlace::from_ptr(ptr, align))\n+    }\n+\n+    #[inline]\n+    pub fn from_scalar_value(val: Scalar) -> Self {\n+        Operand::Immediate(Value::Scalar(val.into()))\n+    }\n+\n+    #[inline]\n+    pub fn to_mem_place(self) -> MemPlace {\n+        match self {\n+            Operand::Indirect(mplace) => mplace,\n+            _ => bug!(\"to_mem_place: expected Operand::Indirect, got {:?}\", self),\n+\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_immediate(self) -> Value {\n+        match self {\n+            Operand::Immediate(val) => val,\n+            _ => bug!(\"to_immediate: expected Operand::Immediate, got {:?}\", self),\n+\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub struct OpTy<'tcx> {\n+    pub op: Operand,\n+    pub layout: TyLayout<'tcx>,\n+}\n+\n+impl<'tcx> ::std::ops::Deref for OpTy<'tcx> {\n+    type Target = Operand;\n+    fn deref(&self) -> &Operand {\n+        &self.op\n+    }\n+}\n+\n+impl<'tcx> From<MPlaceTy<'tcx>> for OpTy<'tcx> {\n+    fn from(mplace: MPlaceTy<'tcx>) -> Self {\n+        OpTy {\n+            op: Operand::Indirect(*mplace),\n+            layout: mplace.layout\n+        }\n+    }\n+}\n+\n+impl<'tcx> From<ValTy<'tcx>> for OpTy<'tcx> {\n+    fn from(val: ValTy<'tcx>) -> Self {\n+        OpTy {\n+            op: Operand::Immediate(val.value),\n+            layout: val.layout\n+        }\n+    }\n+}\n+\n+impl<'tcx> OpTy<'tcx> {\n+    #[inline]\n+    pub fn from_ptr(ptr: Pointer, align: Align, layout: TyLayout<'tcx>) -> Self {\n+        OpTy { op: Operand::from_ptr(ptr, align), layout }\n+    }\n+\n+    #[inline]\n+    pub fn from_aligned_ptr(ptr: Pointer, layout: TyLayout<'tcx>) -> Self {\n+        OpTy { op: Operand::from_ptr(ptr, layout.align), layout }\n+    }\n+\n+    #[inline]\n+    pub fn from_scalar_value(val: Scalar, layout: TyLayout<'tcx>) -> Self {\n+        OpTy { op: Operand::Immediate(Value::Scalar(val.into())), layout }\n+    }\n+}\n+\n+impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+    /// Try reading a value in memory; this is interesting particularily for ScalarPair.\n+    /// Return None if the layout does not permit loading this as a value.\n+    fn try_read_value_from_ptr(\n+        &self,\n+        ptr: Scalar,\n+        ptr_align: Align,\n+        layout: TyLayout<'tcx>,\n+    ) -> EvalResult<'tcx, Option<Value>> {\n+        self.memory.check_align(ptr, ptr_align)?;\n+\n+        if layout.size.bytes() == 0 {\n+            return Ok(Some(Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits: 0, size: 0 }))));\n+        }\n+\n+        let ptr = ptr.to_ptr()?;\n+\n+        match layout.abi {\n+            layout::Abi::Scalar(..) => {\n+                let scalar = self.memory.read_scalar(ptr, ptr_align, layout.size)?;\n+                Ok(Some(Value::Scalar(scalar)))\n+            }\n+            layout::Abi::ScalarPair(ref a, ref b) => {\n+                let (a, b) = (&a.value, &b.value);\n+                let (a_size, b_size) = (a.size(self), b.size(self));\n+                let a_ptr = ptr;\n+                let b_offset = a_size.abi_align(b.align(self));\n+                assert!(b_offset.bytes() > 0); // we later use the offset to test which field to use\n+                let b_ptr = ptr.offset(b_offset, self)?.into();\n+                let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n+                let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n+                Ok(Some(Value::ScalarPair(a_val, b_val)))\n+            }\n+            _ => Ok(None),\n+        }\n+    }\n+\n+    /// Try returning an immediate value for the operand.\n+    /// If the layout does not permit loading this as a value, return where in memory\n+    /// we can find the data.\n+    /// Note that for a given layout, this operation will either always fail or always\n+    /// succeed!  Whether it succeeds depends on whether the layout can be represented\n+    /// in a `Value`, not on which data is stored there currently.\n+    pub(super) fn try_read_value(\n+        &self,\n+        OpTy { op: src, layout } : OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, Result<Value, MemPlace>> {\n+        match src {\n+            Operand::Indirect(mplace) => {\n+                if mplace.extra == PlaceExtra::None {\n+                    if let Some(val) =\n+                        self.try_read_value_from_ptr(mplace.ptr, mplace.align, layout)?\n+                    {\n+                        return Ok(Ok(val));\n+                    }\n+                }\n+                Ok(Err(mplace))\n+            },\n+            Operand::Immediate(val) => Ok(Ok(val)),\n+        }\n+    }\n+\n+    /// Read a value from a place, asserting that that is possible with the given layout.\n+    #[inline(always)]\n+    pub fn read_value(&self, op: OpTy<'tcx>) -> EvalResult<'tcx, ValTy<'tcx>> {\n+        if let Ok(value) = self.try_read_value(op)? {\n+            Ok(ValTy { value, layout: op.layout })\n+        } else {\n+            bug!(\"primitive read failed for type: {:?}\", op.layout.ty);\n+        }\n+    }\n+\n+    /// Read a scalar from a place\n+    pub fn read_scalar(&self, op : OpTy<'tcx>) -> EvalResult<'tcx, ScalarMaybeUndef> {\n+        match *self.read_value(op)? {\n+            Value::ScalarPair(..) => bug!(\"got ScalarPair for type: {:?}\", op.layout.ty),\n+            Value::Scalar(val) => Ok(val),\n+        }\n+    }\n+\n+    pub fn uninit_operand(&mut self, layout: TyLayout<'tcx>) -> EvalResult<'tcx, Operand> {\n+        // FIXME: Aren't we supposed to also be immediate for a ZST?\n+        // This decides which types we will use the Immediate optimization for, and hence should\n+        // match what `try_read_value` and `eval_place_to_op` support.\n+        Ok(match layout.abi {\n+            layout::Abi::Scalar(..) =>\n+                Operand::Immediate(Value::Scalar(ScalarMaybeUndef::Undef)),\n+            layout::Abi::ScalarPair(..) =>\n+                Operand::Immediate(Value::ScalarPair(\n+                    ScalarMaybeUndef::Undef,\n+                    ScalarMaybeUndef::Undef,\n+                )),\n+            _ => {\n+                trace!(\"Forcing allocation for local of type {:?}\", layout.ty);\n+                Operand::Indirect(\n+                    *self.allocate(layout, MemoryKind::Stack)?\n+                )\n+            }\n+        })\n+    }\n+\n+    /// Projection functions\n+    pub fn operand_field(\n+        &self,\n+        op: OpTy<'tcx>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        let base = match op.try_as_mplace() {\n+            Ok(mplace) => {\n+                // The easy case\n+                let field = self.mplace_field(mplace, field)?;\n+                return Ok(field.into());\n+            },\n+            Err(value) => value\n+        };\n+\n+        let field = field.try_into().unwrap();\n+        let field_layout = op.layout.field(self, field)?;\n+        if field_layout.size.bytes() == 0 {\n+            let val = Value::Scalar(Scalar::zst().into());\n+            return Ok(OpTy { op: Operand::Immediate(val), layout: field_layout });\n+        }\n+        let offset = op.layout.fields.offset(field);\n+        let value = match base {\n+            // the field covers the entire type\n+            _ if offset.bytes() == 0 && field_layout.size == op.layout.size => base,\n+            // extract fields from types with `ScalarPair` ABI\n+            Value::ScalarPair(a, b) => {\n+                let val = if offset.bytes() == 0 { a } else { b };\n+                Value::Scalar(val)\n+            },\n+            Value::Scalar(val) =>\n+                bug!(\"field access on non aggregate {:#?}, {:#?}\", val, op.layout),\n+        };\n+        Ok(OpTy { op: Operand::Immediate(value), layout: field_layout })\n+    }\n+\n+    pub(super) fn operand_downcast(\n+        &self,\n+        op: OpTy<'tcx>,\n+        variant: usize,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        // Downcasts only change the layout\n+        Ok(match op.try_as_mplace() {\n+            Ok(mplace) => {\n+                self.mplace_downcast(mplace, variant)?.into()\n+            },\n+            Err(..) => {\n+                let layout = op.layout.for_variant(self, variant);\n+                OpTy { layout, ..op }\n+            }\n+        })\n+    }\n+\n+    // Take an operand, representing a pointer, and dereference it -- that\n+    // will always be a MemPlace.\n+    pub(super) fn deref_operand(\n+        &self,\n+        src: OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        let val = self.read_value(src)?;\n+        trace!(\"deref to {} on {:?}\", val.layout.ty, val);\n+        Ok(self.ref_to_mplace(val)?)\n+    }\n+\n+    pub fn operand_projection(\n+        &self,\n+        base: OpTy<'tcx>,\n+        proj_elem: &mir::PlaceElem<'tcx>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        use rustc::mir::ProjectionElem::*;\n+        Ok(match *proj_elem {\n+            Field(field, _) => self.operand_field(base, field.index() as u64)?,\n+            Downcast(_, variant) => self.operand_downcast(base, variant)?,\n+            Deref => self.deref_operand(base)?.into(),\n+            // The rest should only occur as mplace, we do not use Immediates for types\n+            // allowing such operations.  This matches place_projection forcing an allocation.\n+            Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n+                let mplace = base.to_mem_place();\n+                self.mplace_projection(mplace, proj_elem)?.into()\n+            }\n+        })\n+    }\n+\n+    // Evaluate a place with the goal of reading from it.  This lets us sometimes\n+    // avoid allocations.\n+    fn eval_place_to_op(\n+        &mut self,\n+        mir_place: &mir::Place<'tcx>,\n+    ) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        use rustc::mir::Place::*;\n+        Ok(match *mir_place {\n+            Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n+            Local(local) => {\n+                let op = *self.frame().locals[local].access()?;\n+                OpTy { op, layout: self.layout_of_local(self.cur_frame(), local)? }\n+            },\n+\n+            Projection(ref proj) => {\n+                let op = self.eval_place_to_op(&proj.base)?;\n+                self.operand_projection(op, &proj.elem)?\n+            }\n+\n+            // Everything else is an mplace, so we just call `eval_place`.\n+            // Note that getting an mplace for a static aways requires `&mut`,\n+            // so this does not \"cost\" us anything in terms if mutability.\n+            Promoted(_) | Static(_) => {\n+                let place = self.eval_place(mir_place)?;\n+                place.to_mem_place().into()\n+            }\n+        })\n+    }\n+\n+    /// Evaluate the operand, returning a place where you can then find the data.\n+    pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        use rustc::mir::Operand::*;\n+        match *op {\n+            // FIXME: do some more logic on `move` to invalidate the old location\n+            Copy(ref place) |\n+            Move(ref place) =>\n+                self.eval_place_to_op(place),\n+\n+            Constant(ref constant) => {\n+                let ty = self.monomorphize(op.ty(self.mir(), *self.tcx), self.substs());\n+                let layout = self.layout_of(ty)?;\n+                let op = self.const_value_to_op(constant.literal.val)?;\n+                Ok(OpTy { op, layout })\n+            }\n+        }\n+    }\n+\n+    /// Evaluate a bunch of operands at once\n+    pub(crate) fn eval_operands(\n+        &mut self,\n+        ops: &[mir::Operand<'tcx>],\n+    ) -> EvalResult<'tcx, Vec<OpTy<'tcx>>> {\n+        ops.into_iter()\n+            .map(|op| self.eval_operand(op))\n+            .collect()\n+    }\n+\n+    // Also used e.g. when miri runs into a constant.\n+    // Unfortunately, this needs an `&mut` to be able to allocate a copy of a `ByRef`\n+    // constant.  This bleeds up to `eval_operand` needing `&mut`.\n+    pub fn const_value_to_op(\n+        &mut self,\n+        val: ConstValue<'tcx>,\n+    ) -> EvalResult<'tcx, Operand> {\n+        match val {\n+            ConstValue::Unevaluated(def_id, substs) => {\n+                let instance = self.resolve(def_id, substs)?;\n+                self.global_to_op(GlobalId {\n+                    instance,\n+                    promoted: None,\n+                })\n+            }\n+            ConstValue::ByRef(alloc, offset) => {\n+                // FIXME: Allocate new AllocId for all constants inside\n+                let id = self.memory.allocate_value(alloc.clone(), MemoryKind::Stack)?;\n+                Ok(Operand::from_ptr(Pointer::new(id, offset), alloc.align))\n+            },\n+            ConstValue::ScalarPair(a, b) =>\n+                Ok(Operand::Immediate(Value::ScalarPair(a.into(), b))),\n+            ConstValue::Scalar(x) =>\n+                Ok(Operand::Immediate(Value::Scalar(x.into()))),\n+        }\n+    }\n+\n+    pub(super) fn global_to_op(&mut self, gid: GlobalId<'tcx>) -> EvalResult<'tcx, Operand> {\n+        let cv = self.const_eval(gid)?;\n+        self.const_value_to_op(cv.val)\n+    }\n+\n+    /// We cannot do self.read_value(self.eval_operand) due to eval_operand taking &mut self,\n+    /// so this helps avoid unnecessary let.\n+    pub fn eval_operand_and_read_valty(\n+        &mut self,\n+        op: &mir::Operand<'tcx>,\n+    ) -> EvalResult<'tcx, ValTy<'tcx>> {\n+        let op = self.eval_operand(op)?;\n+        self.read_value(op)\n+    }\n+    pub fn eval_operand_and_read_scalar(\n+        &mut self,\n+        op: &mir::Operand<'tcx>,\n+    ) -> EvalResult<'tcx, ScalarMaybeUndef> {\n+        Ok(self.eval_operand_and_read_valty(op)?.to_scalar_or_undef())\n+    }\n+\n+    /// reads a tag and produces the corresponding variant index\n+    pub fn read_discriminant_as_variant_index(\n+        &self,\n+        rval: OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, usize> {\n+        match rval.layout.variants {\n+            layout::Variants::Single { index } => Ok(index),\n+            layout::Variants::Tagged { .. } => {\n+                let discr_val = self.read_discriminant_value(rval)?;\n+                rval.layout.ty\n+                    .ty_adt_def()\n+                    .expect(\"tagged layout for non adt\")\n+                    .discriminants(self.tcx.tcx)\n+                    .position(|var| var.val == discr_val)\n+                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant.into())\n+            }\n+            layout::Variants::NicheFilling { .. } => {\n+                let discr_val = self.read_discriminant_value(rval)?;\n+                assert_eq!(discr_val as usize as u128, discr_val);\n+                Ok(discr_val as usize)\n+            },\n+        }\n+    }\n+\n+    pub fn read_discriminant_value(\n+        &self,\n+        rval: OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, u128> {\n+        trace!(\"read_discriminant_value {:#?}\", rval.layout);\n+        if rval.layout.abi == layout::Abi::Uninhabited {\n+            return err!(Unreachable);\n+        }\n+\n+        match rval.layout.variants {\n+            layout::Variants::Single { index } => {\n+                let discr_val = rval.layout.ty.ty_adt_def().map_or(\n+                    index as u128,\n+                    |def| def.discriminant_for_variant(*self.tcx, index).val);\n+                return Ok(discr_val);\n+            }\n+            layout::Variants::Tagged { .. } |\n+            layout::Variants::NicheFilling { .. } => {},\n+        }\n+        let discr_op = self.operand_field(rval, 0)?;\n+        let discr_val = self.read_value(discr_op)?;\n+        trace!(\"discr value: {:?}\", discr_val);\n+        let raw_discr = discr_val.to_scalar()?;\n+        Ok(match rval.layout.variants {\n+            layout::Variants::Single { .. } => bug!(),\n+            // FIXME: We should catch invalid discriminants here!\n+            layout::Variants::Tagged { .. } => {\n+                if discr_val.layout.ty.is_signed() {\n+                    let i = raw_discr.to_bits(discr_val.layout.size)? as i128;\n+                    // going from layout tag type to typeck discriminant type\n+                    // requires first sign extending with the layout discriminant\n+                    let shift = 128 - discr_val.layout.size.bits();\n+                    let sexted = (i << shift) >> shift;\n+                    // and then zeroing with the typeck discriminant type\n+                    let discr_ty = rval.layout.ty\n+                        .ty_adt_def().expect(\"tagged layout corresponds to adt\")\n+                        .repr\n+                        .discr_type();\n+                    let discr_ty = layout::Integer::from_attr(self.tcx.tcx, discr_ty);\n+                    let shift = 128 - discr_ty.size().bits();\n+                    let truncatee = sexted as u128;\n+                    (truncatee << shift) >> shift\n+                } else {\n+                    raw_discr.to_bits(discr_val.layout.size)?\n+                }\n+            },\n+            layout::Variants::NicheFilling {\n+                dataful_variant,\n+                ref niche_variants,\n+                niche_start,\n+                ..\n+            } => {\n+                let variants_start = *niche_variants.start() as u128;\n+                let variants_end = *niche_variants.end() as u128;\n+                match raw_discr {\n+                    Scalar::Ptr(_) => {\n+                        assert!(niche_start == 0);\n+                        assert!(variants_start == variants_end);\n+                        dataful_variant as u128\n+                    },\n+                    Scalar::Bits { bits: raw_discr, size } => {\n+                        assert_eq!(size as u64, discr_val.layout.size.bytes());\n+                        let discr = raw_discr.wrapping_sub(niche_start)\n+                            .wrapping_add(variants_start);\n+                        if variants_start <= discr && discr <= variants_end {\n+                            discr\n+                        } else {\n+                            dataful_variant as u128\n+                        }\n+                    },\n+                }\n+            }\n+        })\n+    }\n+\n+}"}, {"sha": "c5475f9a4c0640a491a976fe134c9e711bc6f8d9", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 26, "deletions": 45, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1,58 +1,39 @@\n use rustc::mir;\n-use rustc::ty::{self, Ty, layout};\n+use rustc::ty::{self, layout::{self, TyLayout}};\n use syntax::ast::FloatTy;\n-use rustc::ty::layout::{LayoutOf, TyLayout};\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n+use rustc::mir::interpret::{EvalResult, Scalar};\n \n-use super::{EvalContext, Place, Machine, ValTy};\n+use super::{EvalContext, PlaceTy, Value, Machine, ValTy};\n \n-use rustc::mir::interpret::{EvalResult, Scalar, Value};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    fn binop_with_overflow(\n-        &self,\n-        op: mir::BinOp,\n-        left: ValTy<'tcx>,\n-        right: ValTy<'tcx>,\n-    ) -> EvalResult<'tcx, (Scalar, bool)> {\n-        let left_val = self.value_to_scalar(left)?;\n-        let right_val = self.value_to_scalar(right)?;\n-        self.binary_op(op, left_val, left.ty, right_val, right.ty)\n-    }\n-\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n-    pub fn intrinsic_with_overflow(\n+    pub fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n         left: ValTy<'tcx>,\n         right: ValTy<'tcx>,\n-        dest: Place,\n-        dest_ty: Ty<'tcx>,\n+        dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n-        let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n+        let (val, overflowed) = self.binary_op(op, left, right)?;\n         let val = Value::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n-        let valty = ValTy {\n-            value: val,\n-            ty: dest_ty,\n-        };\n-        self.write_value(valty, dest)\n+        self.write_value(val, dest)\n     }\n \n     /// Applies the binary operation `op` to the arguments and writes the result to the\n-    /// destination. Returns `true` if the operation overflowed.\n-    pub fn intrinsic_overflowing(\n+    /// destination.\n+    pub fn binop_ignore_overflow(\n         &mut self,\n         op: mir::BinOp,\n         left: ValTy<'tcx>,\n         right: ValTy<'tcx>,\n-        dest: Place,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx, bool> {\n-        let (val, overflowed) = self.binop_with_overflow(op, left, right)?;\n-        self.write_scalar(dest, val, dest_ty)?;\n-        Ok(overflowed)\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        let (val, _overflowed) = self.binary_op(op, left, right)?;\n+        self.write_scalar(val, dest)\n     }\n }\n \n@@ -61,29 +42,29 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn binary_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: Scalar,\n-        left_ty: Ty<'tcx>,\n-        right: Scalar,\n-        right_ty: Ty<'tcx>,\n+        ValTy { value: left, layout: left_layout }: ValTy<'tcx>,\n+        ValTy { value: right, layout: right_layout }: ValTy<'tcx>,\n     ) -> EvalResult<'tcx, (Scalar, bool)> {\n         use rustc::mir::BinOp::*;\n \n-        let left_layout = self.layout_of(left_ty)?;\n-        let right_layout = self.layout_of(right_ty)?;\n+        let left = left.to_scalar()?;\n+        let right = right.to_scalar()?;\n \n         let left_kind = match left_layout.abi {\n             layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => return err!(TypeNotPrimitive(left_ty)),\n+            _ => return err!(TypeNotPrimitive(left_layout.ty)),\n         };\n         let right_kind = match right_layout.abi {\n             layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => return err!(TypeNotPrimitive(right_ty)),\n+            _ => return err!(TypeNotPrimitive(right_layout.ty)),\n         };\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\", bin_op, left, left_kind, right, right_kind);\n \n         // I: Handle operations that support pointers\n         if !left_kind.is_float() && !right_kind.is_float() {\n-            if let Some(handled) = M::try_ptr_op(self, bin_op, left, left_ty, right, right_ty)? {\n+            if let Some(handled) =\n+                M::try_ptr_op(self, bin_op, left, left_layout, right, right_layout)?\n+            {\n                 return Ok(handled);\n             }\n         }\n@@ -188,7 +169,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        if let ty::TyFloat(fty) = left_ty.sty {\n+        if let ty::TyFloat(fty) = left_layout.ty.sty {\n             macro_rules! float_math {\n                 ($ty:path, $size:expr) => {{\n                     let l = <$ty>::from_bits(l);\n@@ -220,7 +201,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        let size = self.layout_of(left_ty).unwrap().size.bytes() as u8;\n+        let size = left_layout.size.bytes() as u8;\n \n         // only ints left\n         let val = match bin_op {\n@@ -260,9 +241,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n                     bin_op,\n                     left,\n-                    left_ty,\n+                    left_layout.ty,\n                     right,\n-                    right_ty,\n+                    right_layout.ty,\n                 );\n                 return err!(Unimplemented(msg));\n             }"}, {"sha": "c3ae78dbecfc841cf98f8ba274e5c16d1c51c445", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 599, "deletions": 353, "changes": 952, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1,472 +1,718 @@\n+//! Computations on places -- field projections, going from mir::Place, and writing\n+//! into a place.\n+//! All high-level functions to write to memory work on places as destinations.\n+\n+use std::hash::{Hash, Hasher};\n+use std::convert::TryFrom;\n+\n use rustc::mir;\n-use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, Align, LayoutOf, TyLayout, HasDataLayout};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use rustc::mir::interpret::{GlobalId, Value, Scalar, EvalResult, Pointer, ScalarMaybeUndef};\n-use super::{EvalContext, Machine, ValTy};\n-use interpret::memory::HasMemory;\n+use rustc::mir::interpret::{\n+    GlobalId, Scalar, EvalResult, Pointer, ScalarMaybeUndef\n+};\n+use super::{EvalContext, Machine, Value, ValTy, Operand, OpTy, MemoryKind};\n+\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+pub struct MemPlace {\n+    /// A place may have an integral pointer for ZSTs, and since it might\n+    /// be turned back into a reference before ever being dereferenced.\n+    /// However, it may never be undef.\n+    pub ptr: Scalar,\n+    pub align: Align,\n+    pub extra: PlaceExtra,\n+}\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Place {\n     /// A place referring to a value allocated in the `Memory` system.\n-    Ptr {\n-        /// A place may have an invalid (integral or undef) pointer,\n-        /// since it might be turned back into a reference\n-        /// before ever being dereferenced.\n-        ptr: ScalarMaybeUndef,\n-        align: Align,\n-        extra: PlaceExtra,\n-    },\n+    Ptr(MemPlace),\n \n-    /// A place referring to a value on the stack. Represented by a stack frame index paired with\n-    /// a Mir local index.\n-    Local { frame: usize, local: mir::Local },\n+    /// To support alloc-free locals, we are able to write directly to a local.\n+    /// (Without that optimization, we'd just always be a `MemPlace`.)\n+    Local {\n+        frame: usize,\n+        local: mir::Local,\n+    },\n }\n \n+// Extra information for fat pointers / places\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum PlaceExtra {\n     None,\n     Length(u64),\n     Vtable(Pointer),\n-    DowncastVariant(usize),\n }\n \n-impl<'tcx> Place {\n-    /// Produces a Place that will error if attempted to be read from\n-    pub fn undef() -> Self {\n-        Self::from_scalar_ptr(ScalarMaybeUndef::Undef, Align::from_bytes(1, 1).unwrap())\n+#[derive(Copy, Clone, Debug)]\n+pub struct PlaceTy<'tcx> {\n+    place: Place,\n+    pub layout: TyLayout<'tcx>,\n+}\n+\n+impl<'tcx> ::std::ops::Deref for PlaceTy<'tcx> {\n+    type Target = Place;\n+    fn deref(&self) -> &Place {\n+        &self.place\n+    }\n+}\n+\n+/// A MemPlace with its layout. Constructing it is only possible in this module.\n+#[derive(Copy, Clone, Debug)]\n+pub struct MPlaceTy<'tcx> {\n+    mplace: MemPlace,\n+    pub layout: TyLayout<'tcx>,\n+}\n+\n+impl<'tcx> ::std::ops::Deref for MPlaceTy<'tcx> {\n+    type Target = MemPlace;\n+    fn deref(&self) -> &MemPlace {\n+        &self.mplace\n     }\n+}\n+\n+impl<'tcx> From<MPlaceTy<'tcx>> for PlaceTy<'tcx> {\n+    fn from(mplace: MPlaceTy<'tcx>) -> Self {\n+        PlaceTy {\n+            place: Place::Ptr(mplace.mplace),\n+            layout: mplace.layout\n+        }\n+    }\n+}\n \n-    pub fn from_scalar_ptr(ptr: ScalarMaybeUndef, align: Align) -> Self {\n-        Place::Ptr {\n+impl MemPlace {\n+    #[inline(always)]\n+    pub fn from_scalar_ptr(ptr: Scalar, align: Align) -> Self {\n+        MemPlace {\n             ptr,\n             align,\n             extra: PlaceExtra::None,\n         }\n     }\n \n+    #[inline(always)]\n+    pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n+        Self::from_scalar_ptr(ptr.into(), align)\n+    }\n+\n+    #[inline(always)]\n+    pub fn to_scalar_ptr_align(self) -> (Scalar, Align) {\n+        assert_eq!(self.extra, PlaceExtra::None);\n+        (self.ptr, self.align)\n+    }\n+\n+    /// Extract the ptr part of the mplace\n+    #[inline(always)]\n+    pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n+        // At this point, we forget about the alignment information -- the place has been turned into a reference,\n+        // and no matter where it came from, it now must be aligned.\n+        self.to_scalar_ptr_align().0.to_ptr()\n+    }\n+\n+    /// Turn a mplace into a (thin or fat) pointer, as a reference, pointing to the same space.\n+    /// This is the inverse of `ref_to_mplace`.\n+    pub fn to_ref(self, cx: impl HasDataLayout) -> Value {\n+        // We ignore the alignment of the place here -- special handling for packed structs ends\n+        // at the `&` operator.\n+        match self.extra {\n+            PlaceExtra::None => Value::Scalar(self.ptr.into()),\n+            PlaceExtra::Length(len) => Value::new_slice(self.ptr.into(), len, cx),\n+            PlaceExtra::Vtable(vtable) => Value::new_dyn_trait(self.ptr.into(), vtable),\n+        }\n+    }\n+}\n+\n+impl<'tcx> MPlaceTy<'tcx> {\n+    #[inline]\n+    fn from_aligned_ptr(ptr: Pointer, layout: TyLayout<'tcx>) -> Self {\n+        MPlaceTy { mplace: MemPlace::from_ptr(ptr, layout.align), layout }\n+    }\n+\n+    #[inline]\n+    pub(super) fn len(self) -> u64 {\n+        // Sanity check\n+        let ty_len = match self.layout.fields {\n+            layout::FieldPlacement::Array { count, .. } => count,\n+            _ => bug!(\"Length for non-array layout {:?} requested\", self.layout),\n+        };\n+        if let PlaceExtra::Length(len) = self.extra {\n+            len\n+        } else {\n+            ty_len\n+        }\n+    }\n+}\n+\n+// Validation needs to hash MPlaceTy, but we cannot hash Layout -- so we just hash the type\n+impl<'tcx> Hash for MPlaceTy<'tcx> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.mplace.hash(state);\n+        self.layout.ty.hash(state);\n+    }\n+}\n+impl<'tcx> PartialEq for MPlaceTy<'tcx> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.mplace == other.mplace && self.layout.ty == other.layout.ty\n+    }\n+}\n+impl<'tcx> Eq for MPlaceTy<'tcx> {}\n+\n+impl<'tcx> OpTy<'tcx> {\n+    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx>, Value> {\n+        match *self {\n+            Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n+            Operand::Immediate(value) => Err(value),\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn to_mem_place(self) -> MPlaceTy<'tcx> {\n+        self.try_as_mplace().unwrap()\n+    }\n+}\n+\n+impl<'tcx> Place {\n+    /// Produces a Place that will error if attempted to be read from or written to\n+    #[inline]\n+    pub fn null(cx: impl HasDataLayout) -> Self {\n+        Self::from_scalar_ptr(Scalar::ptr_null(cx), Align::from_bytes(1, 1).unwrap())\n+    }\n+\n+    #[inline]\n+    pub fn from_scalar_ptr(ptr: Scalar, align: Align) -> Self {\n+        Place::Ptr(MemPlace::from_scalar_ptr(ptr, align))\n+    }\n+\n+    #[inline]\n     pub fn from_ptr(ptr: Pointer, align: Align) -> Self {\n-        Self::from_scalar_ptr(ScalarMaybeUndef::Scalar(ptr.into()), align)\n+        Place::Ptr(MemPlace::from_ptr(ptr, align))\n     }\n \n-    pub fn to_ptr_align_extra(self) -> (ScalarMaybeUndef, Align, PlaceExtra) {\n+    #[inline]\n+    pub fn to_mem_place(self) -> MemPlace {\n         match self {\n-            Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n-            _ => bug!(\"to_ptr_and_extra: expected Place::Ptr, got {:?}\", self),\n+            Place::Ptr(mplace) => mplace,\n+            _ => bug!(\"to_mem_place: expected Place::Ptr, got {:?}\", self),\n \n         }\n     }\n \n-    pub fn to_ptr_align(self) -> (ScalarMaybeUndef, Align) {\n-        let (ptr, align, _extra) = self.to_ptr_align_extra();\n-        (ptr, align)\n+    #[inline]\n+    pub fn to_scalar_ptr_align(self) -> (Scalar, Align) {\n+        self.to_mem_place().to_scalar_ptr_align()\n     }\n \n+    #[inline]\n     pub fn to_ptr(self) -> EvalResult<'tcx, Pointer> {\n-        // At this point, we forget about the alignment information -- the place has been turned into a reference,\n-        // and no matter where it came from, it now must be aligned.\n-        self.to_ptr_align().0.unwrap_or_err()?.to_ptr()\n-    }\n-\n-    pub(super) fn elem_ty_and_len(\n-        self,\n-        ty: Ty<'tcx>,\n-        tcx: TyCtxt<'_, 'tcx, '_>\n-    ) -> (Ty<'tcx>, u64) {\n-        match ty.sty {\n-            ty::TyArray(elem, n) => (elem, n.unwrap_usize(tcx)),\n-\n-            ty::TySlice(elem) => {\n-                match self {\n-                    Place::Ptr { extra: PlaceExtra::Length(len), .. } => (elem, len),\n-                    _ => {\n-                        bug!(\n-                            \"elem_ty_and_len of a TySlice given non-slice place: {:?}\",\n-                            self\n-                        )\n-                    }\n-                }\n-            }\n+        self.to_mem_place().to_ptr()\n+    }\n+}\n \n-            _ => bug!(\"elem_ty_and_len expected array or slice, got {:?}\", ty),\n-        }\n+impl<'tcx> PlaceTy<'tcx> {\n+    /// Produces a Place that will error if attempted to be read from or written to\n+    #[inline]\n+    pub fn null(cx: impl HasDataLayout, layout: TyLayout<'tcx>) -> Self {\n+        PlaceTy { place: Place::from_scalar_ptr(Scalar::ptr_null(cx), layout.align), layout }\n+    }\n+\n+    #[inline]\n+    pub fn to_mem_place(self) -> MPlaceTy<'tcx> {\n+        MPlaceTy { mplace: self.place.to_mem_place(), layout: self.layout }\n     }\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// Reads a value from the place without going through the intermediate step of obtaining\n-    /// a `miri::Place`\n-    pub fn try_read_place(\n+    /// Take a value, which represents a (thin or fat) reference, and make it a place.\n+    /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref`.\n+    pub fn ref_to_mplace(\n+        &self, val: ValTy<'tcx>\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n+        let layout = self.layout_of(pointee_type)?;\n+        let mplace = match self.tcx.struct_tail(pointee_type).sty {\n+            ty::TyDynamic(..) => {\n+                let (ptr, vtable) = val.to_scalar_dyn_trait()?;\n+                MemPlace {\n+                    ptr,\n+                    align: layout.align,\n+                    extra: PlaceExtra::Vtable(vtable),\n+                }\n+            }\n+            ty::TyStr | ty::TySlice(_) => {\n+                let (ptr, len) = val.to_scalar_slice(self)?;\n+                MemPlace {\n+                    ptr,\n+                    align: layout.align,\n+                    extra: PlaceExtra::Length(len),\n+                }\n+            }\n+            _ => MemPlace {\n+                ptr: val.to_scalar()?,\n+                align: layout.align,\n+                extra: PlaceExtra::None,\n+            },\n+        };\n+        Ok(MPlaceTy { mplace, layout })\n+    }\n+\n+    /// Offset a pointer to project to a field. Unlike place_field, this is always\n+    /// possible without allocating, so it can take &self. Also return the field's layout.\n+    /// This supports both struct and array fields.\n+    #[inline(always)]\n+    pub fn mplace_field(\n         &self,\n-        place: &mir::Place<'tcx>,\n-    ) -> EvalResult<'tcx, Option<Value>> {\n-        use rustc::mir::Place::*;\n-        match *place {\n-            // Might allow this in the future, right now there's no way to do this from Rust code anyway\n-            Local(mir::RETURN_PLACE) => err!(ReadFromReturnPointer),\n-            // Directly reading a local will always succeed\n-            Local(local) => self.frame().locals[local].access().map(Some),\n-            // No fast path for statics. Reading from statics is rare and would require another\n-            // Machine function to handle differently in miri.\n-            Promoted(_) |\n-            Static(_) => Ok(None),\n-            Projection(ref proj) => self.try_read_place_projection(proj),\n-        }\n+        base: MPlaceTy<'tcx>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        // Not using the layout method because we want to compute on u64\n+        let offset = match base.layout.fields {\n+            layout::FieldPlacement::Arbitrary { ref offsets, .. } =>\n+                offsets[usize::try_from(field).unwrap()],\n+            layout::FieldPlacement::Array { stride, .. } => {\n+                let len = base.len();\n+                assert!(field < len, \"Tried to access element {} of array/slice with length {}\", field, len);\n+                stride * field\n+            }\n+            _ => bug!(\"Unexpected layout for field access: {:#?}\", base.layout),\n+        };\n+        // the only way conversion can fail if is this is an array (otherwise we already panicked\n+        // above). In that case, all fields are equal.\n+        let field = base.layout.field(self, usize::try_from(field).unwrap_or(0))?;\n+\n+        // Adjust offset\n+        let offset = match base.extra {\n+            PlaceExtra::Vtable(tab) => {\n+                let (_, align) = self.size_and_align_of_dst(ValTy {\n+                    layout: base.layout,\n+                    value: Value::new_dyn_trait(base.ptr, tab),\n+                })?;\n+                offset.abi_align(align)\n+            }\n+            _ => offset,\n+        };\n+\n+        let ptr = base.ptr.ptr_offset(offset, self)?;\n+        let align = base.align.min(field.align);\n+        let extra = if !field.is_unsized() {\n+            PlaceExtra::None\n+        } else {\n+            assert!(base.extra != PlaceExtra::None, \"Expected fat ptr\");\n+            base.extra\n+        };\n+\n+        Ok(MPlaceTy { mplace: MemPlace { ptr, align, extra }, layout: field })\n     }\n \n-    pub fn read_field(\n+    pub fn mplace_subslice(\n         &self,\n-        base: Value,\n-        variant: Option<usize>,\n-        field: mir::Field,\n-        mut base_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Value, TyLayout<'tcx>)> {\n-        if let Some(variant_index) = variant {\n-            base_layout = base_layout.for_variant(self, variant_index);\n-        }\n-        let field_index = field.index();\n-        let field = base_layout.field(self, field_index)?;\n-        if field.size.bytes() == 0 {\n-            return Ok((\n-                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits: 0, size: 0 })),\n-                field,\n-            ));\n-        }\n-        let offset = base_layout.fields.offset(field_index);\n-        let value = match base {\n-            // the field covers the entire type\n-            Value::ScalarPair(..) |\n-            Value::Scalar(_) if offset.bytes() == 0 && field.size == base_layout.size => base,\n-            // extract fields from types with `ScalarPair` ABI\n-            Value::ScalarPair(a, b) => {\n-                let val = if offset.bytes() == 0 { a } else { b };\n-                Value::Scalar(val)\n-            },\n-            Value::ByRef(base_ptr, align) => {\n-                let offset = base_layout.fields.offset(field_index);\n-                let ptr = base_ptr.ptr_offset(offset, self)?;\n-                let align = align.min(base_layout.align).min(field.align);\n-                assert!(!field.is_unsized());\n-                Value::ByRef(ptr, align)\n-            },\n-            Value::Scalar(val) => bug!(\"field access on non aggregate {:#?}, {:#?}\", val, base_layout),\n+        base: MPlaceTy<'tcx>,\n+        from: u64,\n+        to: u64,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        let len = base.len();\n+        assert!(from <= len - to);\n+\n+        // Not using layout method because that works with usize, and does not work with slices\n+        // (that have count 0 in their layout).\n+        let from_offset = match base.layout.fields {\n+            layout::FieldPlacement::Array { stride, .. } =>\n+                stride * from,\n+            _ => bug!(\"Unexpected layout of index access: {:#?}\", base.layout),\n         };\n-        Ok((value, field))\n+        let ptr = base.ptr.ptr_offset(from_offset, self)?;\n+\n+        // Compute extra and new layout\n+        let inner_len = len - to - from;\n+        let (extra, ty) = match base.layout.ty.sty {\n+            ty::TyArray(inner, _) =>\n+                (PlaceExtra::None, self.tcx.mk_array(inner, inner_len)),\n+            ty::TySlice(..) =>\n+                (PlaceExtra::Length(inner_len), base.layout.ty),\n+            _ =>\n+                bug!(\"cannot subslice non-array type: `{:?}`\", base.layout.ty),\n+        };\n+        let layout = self.layout_of(ty)?;\n+\n+        Ok(MPlaceTy {\n+            mplace: MemPlace { ptr, align: base.align, extra },\n+            layout\n+        })\n+    }\n+\n+    pub fn mplace_downcast(\n+        &self,\n+        base: MPlaceTy<'tcx>,\n+        variant: usize,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        // Downcasts only change the layout\n+        assert_eq!(base.extra, PlaceExtra::None);\n+        Ok(MPlaceTy { layout: base.layout.for_variant(self, variant), ..base })\n     }\n \n-    fn try_read_place_projection(\n+    /// Project into an mplace\n+    pub fn mplace_projection(\n         &self,\n-        proj: &mir::PlaceProjection<'tcx>,\n-    ) -> EvalResult<'tcx, Option<Value>> {\n+        base: MPlaceTy<'tcx>,\n+        proj_elem: &mir::PlaceElem<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n         use rustc::mir::ProjectionElem::*;\n-        let base = match self.try_read_place(&proj.base)? {\n-            Some(base) => base,\n-            None => return Ok(None),\n-        };\n-        let base_ty = self.place_ty(&proj.base);\n-        let base_layout = self.layout_of(base_ty)?;\n-        match proj.elem {\n-            Field(field, _) => Ok(Some(self.read_field(base, None, field, base_layout)?.0)),\n-            // The NullablePointer cases should work fine, need to take care for normal enums\n-            Downcast(..) |\n-            Subslice { .. } |\n-            // reading index 0 or index 1 from a ByVal or ByVal pair could be optimized\n-            ConstantIndex { .. } | Index(_) |\n-            // No way to optimize this projection any better than the normal place path\n-            Deref => Ok(None),\n-        }\n+        Ok(match *proj_elem {\n+            Field(field, _) => self.mplace_field(base, field.index() as u64)?,\n+            Downcast(_, variant) => self.mplace_downcast(base, variant)?,\n+            Deref => self.deref_operand(base.into())?,\n+\n+            Index(local) => {\n+                let n = *self.frame().locals[local].access()?;\n+                let n_layout = self.layout_of(self.tcx.types.usize)?;\n+                let n = self.read_scalar(OpTy { op: n, layout: n_layout })?;\n+                let n = n.to_bits(self.tcx.data_layout.pointer_size)?;\n+                self.mplace_field(base, u64::try_from(n).unwrap())?\n+            }\n+\n+            ConstantIndex {\n+                offset,\n+                min_length,\n+                from_end,\n+            } => {\n+                let n = base.len();\n+                assert!(n >= min_length as u64);\n+\n+                let index = if from_end {\n+                    n - u64::from(offset)\n+                } else {\n+                    u64::from(offset)\n+                };\n+\n+                self.mplace_field(base, index)?\n+            }\n+\n+            Subslice { from, to } =>\n+                self.mplace_subslice(base, u64::from(from), u64::from(to))?,\n+        })\n     }\n \n-    /// Returns a value and (in case of a ByRef) if we are supposed to use aligned accesses.\n-    pub(super) fn eval_and_read_place(\n+    /// Get the place of a field inside the place, and also the field's type.\n+    /// Just a convenience function, but used quite a bit.\n+    pub fn place_field(\n         &mut self,\n-        place: &mir::Place<'tcx>,\n-    ) -> EvalResult<'tcx, Value> {\n-        // Shortcut for things like accessing a fat pointer's field,\n-        // which would otherwise (in the `eval_place` path) require moving a `ScalarPair` to memory\n-        // and returning an `Place::Ptr` to it\n-        if let Some(val) = self.try_read_place(place)? {\n-            return Ok(val);\n-        }\n-        let place = self.eval_place(place)?;\n-        self.read_place(place)\n+        base : PlaceTy<'tcx>,\n+        field: u64,\n+    ) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+        // FIXME: We could try to be smarter and avoid allocation for fields that span the\n+        // entire place.\n+        let mplace = self.force_allocation(base)?;\n+        Ok(self.mplace_field(mplace, field)?.into())\n     }\n \n-    pub fn read_place(&self, place: Place) -> EvalResult<'tcx, Value> {\n-        match place {\n-            Place::Ptr { ptr, align, extra } => {\n-                assert_eq!(extra, PlaceExtra::None);\n-                Ok(Value::ByRef(ptr.unwrap_or_err()?, align))\n+    pub fn place_downcast(\n+        &mut self,\n+        base : PlaceTy<'tcx>,\n+        variant: usize,\n+    ) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+        // Downcast just changes the layout\n+        Ok(match base.place {\n+            Place::Ptr(mplace) =>\n+                self.mplace_downcast(MPlaceTy { mplace, layout: base.layout }, variant)?.into(),\n+            Place::Local { .. } => {\n+                let layout = base.layout.for_variant(&self, variant);\n+                PlaceTy { layout, ..base }\n             }\n-            Place::Local { frame, local } => self.stack[frame].locals[local].access(),\n-        }\n+        })\n     }\n \n-    pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, Place> {\n+    /// Project into a place\n+    pub fn place_projection(\n+        &mut self,\n+        base: PlaceTy<'tcx>,\n+        proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n+    ) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n+        use rustc::mir::ProjectionElem::*;\n+        Ok(match *proj_elem {\n+            Field(field, _) =>  self.place_field(base, field.index() as u64)?,\n+            Downcast(_, variant) => self.place_downcast(base, variant)?,\n+            Deref => self.deref_operand(self.place_to_op(base)?)?.into(),\n+            // For the other variants, we have to force an allocation.\n+            // This matches `operand_projection`.\n+            Subslice { .. } | ConstantIndex { .. } | Index(_) => {\n+                let mplace = self.force_allocation(base)?;\n+                self.mplace_projection(mplace, proj_elem)?.into()\n+            }\n+        })\n+    }\n+\n+    /// Compute a place.  You should only use this if you intend to write into this\n+    /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n+    pub fn eval_place(&mut self, mir_place: &mir::Place<'tcx>) -> EvalResult<'tcx, PlaceTy<'tcx>> {\n         use rustc::mir::Place::*;\n         let place = match *mir_place {\n-            Local(mir::RETURN_PLACE) => self.frame().return_place,\n-            Local(local) => Place::Local {\n-                frame: self.cur_frame(),\n-                local,\n+            Local(mir::RETURN_PLACE) => PlaceTy {\n+                place: self.frame().return_place,\n+                layout: self.layout_of_local(self.cur_frame(), mir::RETURN_PLACE)?,\n+            },\n+            Local(local) => PlaceTy {\n+                place: Place::Local {\n+                    frame: self.cur_frame(),\n+                    local,\n+                },\n+                layout: self.layout_of_local(self.cur_frame(), local)?,\n             },\n \n             Promoted(ref promoted) => {\n                 let instance = self.frame().instance;\n-                let val = self.read_global_as_value(GlobalId {\n+                let op = self.global_to_op(GlobalId {\n                     instance,\n                     promoted: Some(promoted.0),\n                 })?;\n-                if let Value::ByRef(ptr, align) = val {\n-                    Place::Ptr {\n-                        ptr: ptr.into(),\n-                        align,\n-                        extra: PlaceExtra::None,\n-                    }\n-                } else {\n-                    bug!(\"evaluated promoted and got {:#?}\", val);\n+                let mplace = op.to_mem_place();\n+                let ty = self.monomorphize(promoted.1, self.substs());\n+                PlaceTy {\n+                    place: Place::Ptr(mplace),\n+                    layout: self.layout_of(ty)?,\n                 }\n             }\n \n             Static(ref static_) => {\n-                let layout = self.layout_of(self.place_ty(mir_place))?;\n+                let ty = self.monomorphize(static_.ty, self.substs());\n+                let layout = self.layout_of(ty)?;\n                 let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n                 let cid = GlobalId {\n                     instance,\n                     promoted: None\n                 };\n                 let alloc = Machine::init_static(self, cid)?;\n-                Place::Ptr {\n-                    ptr: ScalarMaybeUndef::Scalar(Scalar::Ptr(alloc.into())),\n-                    align: layout.align,\n-                    extra: PlaceExtra::None,\n-                }\n+                MPlaceTy::from_aligned_ptr(alloc.into(), layout).into()\n             }\n \n             Projection(ref proj) => {\n-                let ty = self.place_ty(&proj.base);\n                 let place = self.eval_place(&proj.base)?;\n-                return self.eval_place_projection(place, ty, &proj.elem);\n+                self.place_projection(place, &proj.elem)?\n             }\n         };\n \n-        self.dump_local(place);\n+        self.dump_place(place.place);\n \n         Ok(place)\n     }\n \n-    pub fn place_field(\n+    /// Write a scalar to a place\n+    pub fn write_scalar(\n         &mut self,\n-        base: Place,\n-        field: mir::Field,\n-        mut base_layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, (Place, TyLayout<'tcx>)> {\n-        match base {\n-            Place::Ptr { extra: PlaceExtra::DowncastVariant(variant_index), .. } => {\n-                base_layout = base_layout.for_variant(&self, variant_index);\n-            }\n-            _ => {}\n-        }\n-        let field_index = field.index();\n-        let field = base_layout.field(&self, field_index)?;\n-        let offset = base_layout.fields.offset(field_index);\n+        val: impl Into<ScalarMaybeUndef>,\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        self.write_value(Value::Scalar(val.into()), dest)\n+    }\n \n-        // Do not allocate in trivial cases\n-        let (base_ptr, base_align, base_extra) = match base {\n-            Place::Ptr { ptr, align, extra } => (ptr, align, extra),\n+    /// Write a value to a place\n+    pub fn write_value(\n+        &mut self,\n+        src_val: Value,\n+        dest : PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        // See if we can avoid an allocation. This is the counterpart to `try_read_value`,\n+        // but not factored as a separate function.\n+        match dest.place {\n             Place::Local { frame, local } => {\n-                match (self.stack[frame].locals[local].access()?, &base_layout.abi) {\n-                    // in case the field covers the entire type, just return the value\n-                    (Value::Scalar(_), &layout::Abi::Scalar(_)) |\n-                    (Value::ScalarPair(..), &layout::Abi::ScalarPair(..))\n-                    if offset.bytes() == 0 && field.size == base_layout.size => {\n-                        return Ok((base, field))\n+                match *self.stack[frame].locals[local].access_mut()? {\n+                    Operand::Immediate(ref mut dest_val) => {\n+                        // Yay, we can just change the local directly.\n+                        *dest_val = src_val;\n+                        return Ok(());\n                     },\n-                    _ => self.force_allocation(base)?.to_ptr_align_extra(),\n-                }\n-            }\n-        };\n-\n-        let offset = match base_extra {\n-            PlaceExtra::Vtable(tab) => {\n-                let (_, align) = self.size_and_align_of_dst(\n-                    base_layout.ty,\n-                    base_ptr.to_value_with_vtable(tab),\n-                )?;\n-                offset.abi_align(align)\n-            }\n-            _ => offset,\n-        };\n-\n-        let ptr = base_ptr.ptr_offset(offset, &self)?;\n-        let align = base_align.min(base_layout.align).min(field.align);\n-        let extra = if !field.is_unsized() {\n-            PlaceExtra::None\n-        } else {\n-            match base_extra {\n-                PlaceExtra::None => bug!(\"expected fat pointer\"),\n-                PlaceExtra::DowncastVariant(..) => {\n-                    bug!(\"Rust doesn't support unsized fields in enum variants\")\n+                    _ => {},\n                 }\n-                PlaceExtra::Vtable(_) |\n-                PlaceExtra::Length(_) => {}\n-            }\n-            base_extra\n+            },\n+            _ => {},\n         };\n \n-        Ok((Place::Ptr { ptr, align, extra }, field))\n+        // Slow path: write to memory\n+        let dest = self.force_allocation(dest)?;\n+        self.write_value_to_mplace(src_val, dest)\n     }\n \n-    pub fn val_to_place(&self, val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Place> {\n-        let layout = self.layout_of(ty)?;\n-        Ok(match self.tcx.struct_tail(ty).sty {\n-            ty::TyDynamic(..) => {\n-                let (ptr, vtable) = self.into_ptr_vtable_pair(val)?;\n-                Place::Ptr {\n-                    ptr,\n-                    align: layout.align,\n-                    extra: PlaceExtra::Vtable(vtable),\n-                }\n+    /// Write a value to memory\n+    fn write_value_to_mplace(\n+        &mut self,\n+        value: Value,\n+        dest: MPlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"write_value_to_ptr: {:#?}, {:#?}\", value, dest.layout);\n+        assert_eq!(dest.extra, PlaceExtra::None);\n+        // Note that it is really important that the type here is the right one, and matches the type things are read at.\n+        // In case `src_val` is a `ScalarPair`, we don't do any magic here to handle padding properly, which is only\n+        // correct if we never look at this data with the wrong type.\n+        match value {\n+            Value::Scalar(scalar) => {\n+                let signed = match dest.layout.abi {\n+                    layout::Abi::Scalar(ref scal) => match scal.value {\n+                        layout::Primitive::Int(_, signed) => signed,\n+                        _ => false,\n+                    },\n+                    _ => false,\n+                };\n+                self.memory.write_scalar(\n+                    dest.ptr, dest.align, scalar, dest.layout.size, dest.layout.align, signed\n+                )\n             }\n-            ty::TyStr | ty::TySlice(_) => {\n-                let (ptr, len) = self.into_slice(val)?;\n-                Place::Ptr {\n-                    ptr,\n-                    align: layout.align,\n-                    extra: PlaceExtra::Length(len),\n-                }\n+            Value::ScalarPair(a_val, b_val) => {\n+                let (a, b) = match dest.layout.abi {\n+                    layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n+                    _ => bug!(\"write_value_to_ptr: invalid ScalarPair layout: {:#?}\", dest.layout)\n+                };\n+                let (a_size, b_size) = (a.size(&self), b.size(&self));\n+                let (a_align, b_align) = (a.align(&self), b.align(&self));\n+                let a_ptr = dest.ptr;\n+                let b_offset = a_size.abi_align(b_align);\n+                let b_ptr = a_ptr.ptr_offset(b_offset, &self)?.into();\n+                // TODO: What about signedess?\n+                self.memory.write_scalar(a_ptr, dest.align, a_val, a_size, a_align, false)?;\n+                self.memory.write_scalar(b_ptr, dest.align, b_val, b_size, b_align, false)\n             }\n-            _ => Place::from_scalar_ptr(self.into_ptr(val)?, layout.align),\n-        })\n+        }\n     }\n \n-    pub fn place_index(\n+    /// Copy the data from an operand to a place\n+    pub fn copy_op(\n         &mut self,\n-        base: Place,\n-        outer_ty: Ty<'tcx>,\n-        n: u64,\n-    ) -> EvalResult<'tcx, Place> {\n-        // Taking the outer type here may seem odd; it's needed because for array types, the outer type gives away the length.\n-        let base = self.force_allocation(base)?;\n-        let (base_ptr, align) = base.to_ptr_align();\n-\n-        let (elem_ty, len) = base.elem_ty_and_len(outer_ty, self.tcx.tcx);\n-        let elem_size = self.layout_of(elem_ty)?.size;\n-        assert!(\n-            n < len,\n-            \"Tried to access element {} of array/slice with length {}\",\n-            n,\n-            len\n-        );\n-        let ptr = base_ptr.ptr_offset(elem_size * n, &*self)?;\n-        Ok(Place::Ptr {\n-            ptr,\n-            align,\n-            extra: PlaceExtra::None,\n-        })\n+        src: OpTy<'tcx>,\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        trace!(\"Copying {:?} to {:?}\", src, dest);\n+        assert_eq!(src.layout.size, dest.layout.size, \"Size mismatch when copying!\");\n+\n+        // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n+        let (src_ptr, src_align) = match self.try_read_value(src)? {\n+            Ok(src_val) =>\n+                // Yay, we got a value that we can write directly.\n+                return self.write_value(src_val, dest),\n+            Err(mplace) => mplace.to_scalar_ptr_align(),\n+        };\n+        // Slow path, this does not fit into an immediate. Just memcpy.\n+        let (dest_ptr, dest_align) = self.force_allocation(dest)?.to_scalar_ptr_align();\n+        self.memory.copy(\n+            src_ptr, src_align,\n+            dest_ptr, dest_align,\n+            src.layout.size, false\n+        )\n     }\n \n-    pub(super) fn place_downcast(\n+    /// Make sure that a place is in memory, and return where it is.\n+    /// This is essentially `force_to_memplace`.\n+    pub fn force_allocation(\n         &mut self,\n-        base: Place,\n-        variant: usize,\n-    ) -> EvalResult<'tcx, Place> {\n-        // FIXME(solson)\n-        let base = self.force_allocation(base)?;\n-        let (ptr, align) = base.to_ptr_align();\n-        let extra = PlaceExtra::DowncastVariant(variant);\n-        Ok(Place::Ptr { ptr, align, extra })\n+        place: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        let mplace = match place.place {\n+            Place::Local { frame, local } => {\n+                // We need the layout of the local.  We can NOT use the layout we got,\n+                // that might e.g. be a downcast variant!\n+                let local_layout = self.layout_of_local(frame, local)?;\n+                // Make sure it has a place\n+                let rval = *self.stack[frame].locals[local].access()?;\n+                let mplace = self.allocate_op(OpTy { op: rval, layout: local_layout })?.mplace;\n+                // This might have allocated the flag\n+                *self.stack[frame].locals[local].access_mut()? =\n+                    Operand::Indirect(mplace);\n+                // done\n+                mplace\n+            }\n+            Place::Ptr(mplace) => mplace\n+        };\n+        // Return with the original layout, so that the caller can go on\n+        Ok(MPlaceTy { mplace, layout: place.layout })\n     }\n \n-    pub fn eval_place_projection(\n+    pub fn allocate(\n         &mut self,\n-        base: Place,\n-        base_ty: Ty<'tcx>,\n-        proj_elem: &mir::ProjectionElem<'tcx, mir::Local, Ty<'tcx>>,\n-    ) -> EvalResult<'tcx, Place> {\n-        use rustc::mir::ProjectionElem::*;\n-        match *proj_elem {\n-            Field(field, _) => {\n-                let layout = self.layout_of(base_ty)?;\n-                Ok(self.place_field(base, field, layout)?.0)\n-            }\n-\n-            Downcast(_, variant) => {\n-                self.place_downcast(base, variant)\n-            }\n-\n-            Deref => {\n-                let val = self.read_place(base)?;\n-\n-                let pointee_type = match base_ty.sty {\n-                    ty::TyRawPtr(ref tam) => tam.ty,\n-                    ty::TyRef(_, ty, _) => ty,\n-                    ty::TyAdt(def, _) if def.is_box() => base_ty.boxed_ty(),\n-                    _ => bug!(\"can only deref pointer types\"),\n-                };\n+        layout: TyLayout<'tcx>,\n+        kind: MemoryKind<M::MemoryKinds>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        assert!(!layout.is_unsized(), \"cannot alloc memory for unsized type\");\n+        let ptr = self.memory.allocate(layout.size, layout.align, kind)?;\n+        Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n+    }\n \n-                trace!(\"deref to {} on {:?}\", pointee_type, val);\n+    /// Make a place for an operand, allocating if needed\n+    pub fn allocate_op(\n+        &mut self,\n+        OpTy { op, layout }: OpTy<'tcx>,\n+    ) -> EvalResult<'tcx, MPlaceTy<'tcx>> {\n+        Ok(match op {\n+            Operand::Indirect(mplace) => MPlaceTy { mplace, layout },\n+            Operand::Immediate(value) => {\n+                // FIXME: Is stack always right here?\n+                let ptr = self.allocate(layout, MemoryKind::Stack)?;\n+                self.write_value_to_mplace(value, ptr)?;\n+                ptr\n+            },\n+        })\n+    }\n \n-                self.val_to_place(val, pointee_type)\n+    pub fn write_discriminant_value(\n+        &mut self,\n+        variant_index: usize,\n+        dest: PlaceTy<'tcx>,\n+    ) -> EvalResult<'tcx> {\n+        match dest.layout.variants {\n+            layout::Variants::Single { index } => {\n+                if index != variant_index {\n+                    // If the layout of an enum is `Single`, all\n+                    // other variants are necessarily uninhabited.\n+                    assert_eq!(dest.layout.for_variant(&self, variant_index).abi,\n+                               layout::Abi::Uninhabited);\n+                }\n             }\n-\n-            Index(local) => {\n-                let value = self.frame().locals[local].access()?;\n-                let ty = self.tcx.types.usize;\n-                let n = self\n-                    .value_to_scalar(ValTy { value, ty })?\n-                    .to_bits(self.tcx.data_layout.pointer_size)?;\n-                self.place_index(base, base_ty, n as u64)\n+            layout::Variants::Tagged { ref tag, .. } => {\n+                let discr_val = dest.layout.ty.ty_adt_def().unwrap()\n+                    .discriminant_for_variant(*self.tcx, variant_index)\n+                    .val;\n+\n+                // raw discriminants for enums are isize or bigger during\n+                // their computation, but the in-memory tag is the smallest possible\n+                // representation\n+                let size = tag.value.size(self.tcx.tcx);\n+                let shift = 128 - size.bits();\n+                let discr_val = (discr_val << shift) >> shift;\n+\n+                let discr_dest = self.place_field(dest, 0)?;\n+                self.write_scalar(Scalar::Bits {\n+                    bits: discr_val,\n+                    size: size.bytes() as u8,\n+                }, discr_dest)?;\n             }\n-\n-            ConstantIndex {\n-                offset,\n-                min_length,\n-                from_end,\n+            layout::Variants::NicheFilling {\n+                dataful_variant,\n+                ref niche_variants,\n+                niche_start,\n+                ..\n             } => {\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, align) = base.to_ptr_align();\n-\n-                let (elem_ty, n) = base.elem_ty_and_len(base_ty, self.tcx.tcx);\n-                let elem_size = self.layout_of(elem_ty)?.size;\n-                assert!(n >= min_length as u64);\n-\n-                let index = if from_end {\n-                    n - u64::from(offset)\n-                } else {\n-                    u64::from(offset)\n-                };\n-\n-                let ptr = base_ptr.ptr_offset(elem_size * index, &self)?;\n-                Ok(Place::Ptr { ptr, align, extra: PlaceExtra::None })\n-            }\n-\n-            Subslice { from, to } => {\n-                // FIXME(solson)\n-                let base = self.force_allocation(base)?;\n-                let (base_ptr, align) = base.to_ptr_align();\n-\n-                let (elem_ty, n) = base.elem_ty_and_len(base_ty, self.tcx.tcx);\n-                let elem_size = self.layout_of(elem_ty)?.size;\n-                assert!(u64::from(from) <= n - u64::from(to));\n-                let ptr = base_ptr.ptr_offset(elem_size * u64::from(from), &self)?;\n-                // sublicing arrays produces arrays\n-                let extra = if self.type_is_sized(base_ty) {\n-                    PlaceExtra::None\n-                } else {\n-                    PlaceExtra::Length(n - u64::from(to) - u64::from(from))\n-                };\n-                Ok(Place::Ptr { ptr, align, extra })\n+                if variant_index != dataful_variant {\n+                    let niche_dest =\n+                        self.place_field(dest, 0)?;\n+                    let niche_value = ((variant_index - niche_variants.start()) as u128)\n+                        .wrapping_add(niche_start);\n+                    self.write_scalar(Scalar::Bits {\n+                        bits: niche_value,\n+                        size: niche_dest.layout.size.bytes() as u8,\n+                    }, niche_dest)?;\n+                }\n             }\n         }\n+\n+        Ok(())\n     }\n \n-    pub fn place_ty(&self, place: &mir::Place<'tcx>) -> Ty<'tcx> {\n-        self.monomorphize(\n-            place.ty(self.mir(), *self.tcx).to_ty(*self.tcx),\n-            self.substs(),\n-        )\n+    /// Every place can be read from, so we can turm them into an operand\n+    pub fn place_to_op(&self, place: PlaceTy<'tcx>) -> EvalResult<'tcx, OpTy<'tcx>> {\n+        let op = match place.place {\n+            Place::Ptr(mplace) => {\n+                Operand::Indirect(mplace)\n+            }\n+            Place::Local { frame, local } =>\n+                *self.stack[frame].locals[local].access()?\n+        };\n+        Ok(OpTy { op, layout: place.layout })\n     }\n }"}, {"sha": "33ed1862fc3d834ff86eebfe3ac521387c10e04d", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 48, "deletions": 89, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -2,12 +2,11 @@\n //!\n //! The main entry point is the `step` method.\n \n-use rustc::{mir, ty};\n+use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n-use rustc::mir::interpret::{EvalResult, Scalar, Value};\n-use rustc_data_structures::indexed_vec::Idx;\n+use rustc::mir::interpret::{EvalResult, Scalar};\n \n-use super::{EvalContext, Machine, PlaceExtra, ValTy};\n+use super::{EvalContext, Machine};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub fn inc_step_counter_and_detect_loops(&mut self) -> EvalResult<'tcx, ()> {\n@@ -86,8 +85,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 variant_index,\n             } => {\n                 let dest = self.eval_place(place)?;\n-                let dest_ty = self.place_ty(place);\n-                self.write_discriminant_value(dest_ty, dest, variant_index)?;\n+                self.write_discriminant_value(variant_index, dest)?;\n             }\n \n             // Mark locals as alive\n@@ -98,7 +96,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n             // Mark locals as dead\n             StorageDead(local) => {\n-                let old_val = self.frame_mut().storage_dead(local);\n+                let old_val = self.storage_dead(local);\n                 self.deallocate_local(old_val)?;\n             }\n \n@@ -139,58 +137,46 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         place: &mir::Place<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let dest = self.eval_place(place)?;\n-        let dest_ty = self.place_ty(place);\n-        let dest_layout = self.layout_of(dest_ty)?;\n \n         use rustc::mir::Rvalue::*;\n         match *rvalue {\n             Use(ref operand) => {\n-                let value = self.eval_operand(operand)?.value;\n-                let valty = ValTy {\n-                    value,\n-                    ty: dest_ty,\n-                };\n-                self.write_value(valty, dest)?;\n+                let op = self.eval_operand(operand)?;\n+                self.copy_op(op, dest)?;\n             }\n \n             BinaryOp(bin_op, ref left, ref right) => {\n-                let left = self.eval_operand(left)?;\n-                let right = self.eval_operand(right)?;\n-                self.intrinsic_overflowing(\n+                let left = self.eval_operand_and_read_valty(left)?;\n+                let right = self.eval_operand_and_read_valty(right)?;\n+                self.binop_ignore_overflow(\n                     bin_op,\n                     left,\n                     right,\n                     dest,\n-                    dest_ty,\n                 )?;\n             }\n \n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n-                let left = self.eval_operand(left)?;\n-                let right = self.eval_operand(right)?;\n-                self.intrinsic_with_overflow(\n+                let left = self.eval_operand_and_read_valty(left)?;\n+                let right = self.eval_operand_and_read_valty(right)?;\n+                self.binop_with_overflow(\n                     bin_op,\n                     left,\n                     right,\n                     dest,\n-                    dest_ty,\n                 )?;\n             }\n \n             UnaryOp(un_op, ref operand) => {\n-                let val = self.eval_operand_to_scalar(operand)?;\n-                let val = self.unary_op(un_op, val, dest_layout)?;\n-                self.write_scalar(\n-                    dest,\n-                    val,\n-                    dest_ty,\n-                )?;\n+                let val = self.eval_operand_and_read_scalar(operand)?;\n+                let val = self.unary_op(un_op, val.not_undef()?, dest.layout)?;\n+                self.write_scalar(val, dest)?;\n             }\n \n             Aggregate(ref kind, ref operands) => {\n                 let (dest, active_field_index) = match **kind {\n                     mir::AggregateKind::Adt(adt_def, variant_index, _, active_field_index) => {\n-                        self.write_discriminant_value(dest_ty, dest, variant_index)?;\n+                        self.write_discriminant_value(variant_index, dest)?;\n                         if adt_def.is_enum() {\n                             (self.place_downcast(dest, variant_index)?, active_field_index)\n                         } else {\n@@ -200,85 +186,61 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     _ => (dest, None)\n                 };\n \n-                let layout = self.layout_of(dest_ty)?;\n                 for (i, operand) in operands.iter().enumerate() {\n-                    let value = self.eval_operand(operand)?;\n+                    let op = self.eval_operand(operand)?;\n                     // Ignore zero-sized fields.\n-                    if !self.layout_of(value.ty)?.is_zst() {\n+                    if !op.layout.is_zst() {\n                         let field_index = active_field_index.unwrap_or(i);\n-                        let (field_dest, _) = self.place_field(dest, mir::Field::new(field_index), layout)?;\n-                        self.write_value(value, field_dest)?;\n+                        let field_dest = self.place_field(dest, field_index as u64)?;\n+                        self.copy_op(op, field_dest)?;\n                     }\n                 }\n             }\n \n             Repeat(ref operand, _) => {\n-                let (elem_ty, length) = match dest_ty.sty {\n-                    ty::TyArray(elem_ty, n) => (elem_ty, n.unwrap_usize(self.tcx.tcx)),\n-                    _ => {\n-                        bug!(\n-                            \"tried to assign array-repeat to non-array type {:?}\",\n-                            dest_ty\n-                        )\n-                    }\n-                };\n-                let elem_size = self.layout_of(elem_ty)?.size;\n-                let value = self.eval_operand(operand)?.value;\n-\n-                let (dest, dest_align) = self.force_allocation(dest)?.to_ptr_align();\n+                let op = self.eval_operand(operand)?;\n+                let dest = self.force_allocation(dest)?;\n+                let length = dest.len();\n \n                 if length > 0 {\n-                    let dest = dest.unwrap_or_err()?;\n-                    //write the first value\n-                    self.write_value_to_ptr(value, dest, dest_align, elem_ty)?;\n+                    // write the first\n+                    let first = self.mplace_field(dest, 0)?;\n+                    self.copy_op(op, first.into())?;\n \n                     if length > 1 {\n-                        let rest = dest.ptr_offset(elem_size * 1 as u64, &self)?;\n-                        self.memory.copy_repeatedly(dest, dest_align, rest, dest_align, elem_size, length - 1, false)?;\n+                        // copy the rest\n+                        let (dest, dest_align) = first.to_scalar_ptr_align();\n+                        let rest = dest.ptr_offset(first.layout.size, &self)?;\n+                        self.memory.copy_repeatedly(\n+                            dest, dest_align, rest, dest_align, first.layout.size, length - 1, true\n+                        )?;\n                     }\n                 }\n             }\n \n             Len(ref place) => {\n                 // FIXME(CTFE): don't allow computing the length of arrays in const eval\n                 let src = self.eval_place(place)?;\n-                let ty = self.place_ty(place);\n-                let (_, len) = src.elem_ty_and_len(ty, self.tcx.tcx);\n+                let mplace = self.force_allocation(src)?;\n+                let len = mplace.len();\n                 let size = self.memory.pointer_size().bytes() as u8;\n                 self.write_scalar(\n-                    dest,\n                     Scalar::Bits {\n                         bits: len as u128,\n                         size,\n                     },\n-                    dest_ty,\n+                    dest,\n                 )?;\n             }\n \n             Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n-                // We ignore the alignment of the place here -- special handling for packed structs ends\n-                // at the `&` operator.\n-                let (ptr, _align, extra) = self.force_allocation(src)?.to_ptr_align_extra();\n-\n-                let val = match extra {\n-                    PlaceExtra::None => Value::Scalar(ptr),\n-                    PlaceExtra::Length(len) => ptr.to_value_with_len(len, self.tcx.tcx),\n-                    PlaceExtra::Vtable(vtable) => ptr.to_value_with_vtable(vtable),\n-                    PlaceExtra::DowncastVariant(..) => {\n-                        bug!(\"attempted to take a reference to an enum downcast place\")\n-                    }\n-                };\n-                let valty = ValTy {\n-                    value: val,\n-                    ty: dest_ty,\n-                };\n-                self.write_value(valty, dest)?;\n+                let val = self.force_allocation(src)?.to_ref(&self);\n+                self.write_value(val, dest)?;\n             }\n \n-            NullaryOp(mir::NullOp::Box, ty) => {\n-                let ty = self.monomorphize(ty, self.substs());\n-                M::box_alloc(self, ty, dest)?;\n+            NullaryOp(mir::NullOp::Box, _) => {\n+                M::box_alloc(self, dest)?;\n             }\n \n             NullaryOp(mir::NullOp::SizeOf, ty) => {\n@@ -288,35 +250,32 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         \"SizeOf nullary MIR operator called for unsized type\");\n                 let size = self.memory.pointer_size().bytes() as u8;\n                 self.write_scalar(\n-                    dest,\n                     Scalar::Bits {\n                         bits: layout.size.bytes() as u128,\n                         size,\n                     },\n-                    dest_ty,\n+                    dest,\n                 )?;\n             }\n \n             Cast(kind, ref operand, cast_ty) => {\n-                debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest_ty);\n+                debug_assert_eq!(self.monomorphize(cast_ty, self.substs()), dest.layout.ty);\n                 let src = self.eval_operand(operand)?;\n-                self.cast(src, kind, dest_ty, dest)?;\n+                self.cast(src, kind, dest)?;\n             }\n \n             Discriminant(ref place) => {\n-                let ty = self.place_ty(place);\n-                let layout = self.layout_of(ty)?;\n                 let place = self.eval_place(place)?;\n-                let discr_val = self.read_discriminant_value(place, layout)?;\n-                let size = self.layout_of(dest_ty).unwrap().size.bytes() as u8;\n-                self.write_scalar(dest, Scalar::Bits {\n+                let discr_val = self.read_discriminant_value(self.place_to_op(place)?)?;\n+                let size = dest.layout.size.bytes() as u8;\n+                self.write_scalar(Scalar::Bits {\n                     bits: discr_val,\n                     size,\n-                }, dest_ty)?;\n+                }, dest)?;\n             }\n         }\n \n-        self.dump_local(dest);\n+        self.dump_place(*dest);\n \n         Ok(())\n     }"}, {"sha": "df40f90461653c40aaecf795e4a6575a2e031535", "filename": "src/librustc_mir/interpret/terminator/drop.rs", "status": "modified", "additions": 15, "deletions": 30, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fdrop.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1,42 +1,24 @@\n use rustc::mir::BasicBlock;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, layout::LayoutOf};\n use syntax::source_map::Span;\n \n-use rustc::mir::interpret::{EvalResult, Value};\n-use interpret::{Machine, ValTy, EvalContext, Place, PlaceExtra};\n+use rustc::mir::interpret::{EvalResult};\n+use interpret::{Machine, EvalContext, PlaceTy, Value, OpTy, Operand};\n \n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     pub(crate) fn drop_place(\n         &mut self,\n-        place: Place,\n+        place: PlaceTy<'tcx>,\n         instance: ty::Instance<'tcx>,\n-        ty: Ty<'tcx>,\n         span: Span,\n         target: BasicBlock,\n     ) -> EvalResult<'tcx> {\n         trace!(\"drop_place: {:#?}\", place);\n         // We take the address of the object.  This may well be unaligned, which is fine for us here.\n         // However, unaligned accesses will probably make the actual drop implementation fail -- a problem shared\n         // by rustc.\n-        let val = match self.force_allocation(place)? {\n-            Place::Ptr {\n-                ptr,\n-                align: _,\n-                extra: PlaceExtra::Vtable(vtable),\n-            } => ptr.to_value_with_vtable(vtable),\n-            Place::Ptr {\n-                ptr,\n-                align: _,\n-                extra: PlaceExtra::Length(len),\n-            } => ptr.to_value_with_len(len, self.tcx.tcx),\n-            Place::Ptr {\n-                ptr,\n-                align: _,\n-                extra: PlaceExtra::None,\n-            } => Value::Scalar(ptr),\n-            _ => bug!(\"force_allocation broken\"),\n-        };\n-        self.drop(val, instance, ty, span, target)\n+        let val = self.force_allocation(place)?.to_ref(&self);\n+        self.drop(val, instance, place.layout.ty, span, target)\n     }\n \n     fn drop(\n@@ -52,7 +34,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let instance = match ty.sty {\n             ty::TyDynamic(..) => {\n                 if let Value::ScalarPair(_, vtable) = arg {\n-                    self.read_drop_type_from_vtable(vtable.unwrap_or_err()?.to_ptr()?)?\n+                    self.read_drop_type_from_vtable(vtable.to_ptr()?)?\n                 } else {\n                     bug!(\"expected fat ptr, got {:?}\", arg);\n                 }\n@@ -61,17 +43,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         };\n \n         // the drop function expects a reference to the value\n-        let valty = ValTy {\n-            value: arg,\n-            ty: self.tcx.mk_mut_ptr(ty),\n+        let arg = OpTy {\n+            op: Operand::Immediate(arg),\n+            layout: self.layout_of(self.tcx.mk_mut_ptr(ty))?,\n         };\n \n         let fn_sig = self.tcx.fn_sig(instance.def_id()).skip_binder().clone();\n+        // This should always be (), but getting it from the sig seems\n+        // easier than creating a layout of ().\n+        let dest = PlaceTy::null(&self, self.layout_of(fn_sig.output())?);\n \n         self.eval_fn_call(\n             instance,\n-            Some((Place::undef(), target)),\n-            &[valty],\n+            Some((dest, target)),\n+            &[arg],\n             span,\n             fn_sig,\n         )"}, {"sha": "25ce70e4f3b6659f891708db27032b082df3c425", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 49, "deletions": 62, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1,14 +1,13 @@\n use rustc::mir;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::{LayoutOf, Size};\n+use rustc::ty::layout::LayoutOf;\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, Scalar, Value};\n-use super::{EvalContext, Place, Machine, ValTy};\n+use rustc::mir::interpret::{EvalResult, Scalar};\n+use super::{EvalContext, Machine, Value, OpTy, PlaceTy, ValTy, Operand};\n \n use rustc_data_structures::indexed_vec::Idx;\n-use interpret::memory::HasMemory;\n \n mod drop;\n \n@@ -25,7 +24,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         use rustc::mir::TerminatorKind::*;\n         match terminator.kind {\n             Return => {\n-                self.dump_local(self.frame().return_place);\n+                self.dump_place(self.frame().return_place);\n                 self.pop_stack_frame()?\n             }\n \n@@ -38,21 +37,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 ..\n             } => {\n                 let discr_val = self.eval_operand(discr)?;\n-                let discr_prim = self.value_to_scalar(discr_val)?;\n-                let discr_layout = self.layout_of(discr_val.ty).unwrap();\n-                trace!(\"SwitchInt({:?}, {:#?})\", discr_prim, discr_layout);\n+                let discr = self.read_value(discr_val)?;\n+                trace!(\"SwitchInt({:#?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {\n                     // Compare using binary_op\n-                    let const_int = Scalar::Bits { bits: const_int, size: discr_layout.size.bytes() as u8 };\n-                    let res = self.binary_op(mir::BinOp::Eq,\n-                        discr_prim, discr_val.ty,\n-                        const_int, discr_val.ty\n+                    let const_int = Scalar::Bits { bits: const_int, size: discr.layout.size.bytes() as u8 };\n+                    let (res, _) = self.binary_op(mir::BinOp::Eq,\n+                        discr,\n+                        ValTy { value: Value::Scalar(const_int.into()), layout: discr.layout }\n                     )?;\n-                    if res.0.to_bits(Size::from_bytes(1))? != 0 {\n+                    if res.to_bool()? {\n                         target_block = targets[index];\n                         break;\n                     }\n@@ -73,9 +71,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 };\n \n                 let func = self.eval_operand(func)?;\n-                let (fn_def, sig) = match func.ty.sty {\n+                let (fn_def, sig) = match func.layout.ty.sty {\n                     ty::TyFnPtr(sig) => {\n-                        let fn_ptr = self.value_to_scalar(func)?.to_ptr()?;\n+                        let fn_ptr = self.read_scalar(func)?.to_ptr()?;\n                         let instance = self.memory.get_fn(fn_ptr)?;\n                         let instance_ty = instance.ty(*self.tcx);\n                         match instance_ty.sty {\n@@ -99,22 +97,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     }\n                     ty::TyFnDef(def_id, substs) => (\n                         self.resolve(def_id, substs)?,\n-                        func.ty.fn_sig(*self.tcx),\n+                        func.layout.ty.fn_sig(*self.tcx),\n                     ),\n                     _ => {\n-                        let msg = format!(\"can't handle callee of type {:?}\", func.ty);\n+                        let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n                         return err!(Unimplemented(msg));\n                     }\n                 };\n-                let args = self.operands_to_args(args)?;\n+                let args = self.eval_operands(args)?;\n                 let sig = self.tcx.normalize_erasing_late_bound_regions(\n                     ty::ParamEnv::reveal_all(),\n                     &sig,\n                 );\n                 self.eval_fn_call(\n                     fn_def,\n                     destination,\n-                    &args,\n+                    &args[..],\n                     terminator.source_info.span,\n                     sig,\n                 )?;\n@@ -127,19 +125,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             } => {\n                 // FIXME(CTFE): forbid drop in const eval\n                 let place = self.eval_place(location)?;\n-                let ty = self.place_ty(location);\n-                let ty = self.tcx.subst_and_normalize_erasing_regions(\n-                    self.substs(),\n-                    ty::ParamEnv::reveal_all(),\n-                    &ty,\n-                );\n+                let ty = place.layout.ty;\n                 trace!(\"TerminatorKind::drop: {:?}, type {}\", location, ty);\n \n                 let instance = ::monomorphize::resolve_drop_in_place(*self.tcx, ty);\n                 self.drop_place(\n                     place,\n                     instance,\n-                    ty,\n                     terminator.source_info.span,\n                     target,\n                 )?;\n@@ -152,17 +144,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 target,\n                 ..\n             } => {\n-                let cond_val = self.eval_operand_to_scalar(cond)?.to_bool()?;\n+                let cond_val = self.eval_operand_and_read_scalar(cond)?.not_undef()?.to_bool()?;\n                 if expected == cond_val {\n                     self.goto_block(target);\n                 } else {\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            let len = self.eval_operand_to_scalar(len)\n+                            let len = self.eval_operand_and_read_scalar(len)\n                                 .expect(\"can't eval len\")\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            let index = self.eval_operand_to_scalar(index)\n+                            let index = self.eval_operand_and_read_scalar(index)\n                                 .expect(\"can't eval index\")\n                                 .to_bits(self.memory().pointer_size())? as u64;\n                             err!(BoundsCheck { len, index })\n@@ -259,8 +251,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn eval_fn_call(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        destination: Option<(Place, mir::BasicBlock)>,\n-        args: &[ValTy<'tcx>],\n+        destination: Option<(PlaceTy<'tcx>, mir::BasicBlock)>,\n+        args: &[OpTy<'tcx>],\n         span: Span,\n         sig: ty::FnSig<'tcx>,\n     ) -> EvalResult<'tcx> {\n@@ -271,24 +263,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     Some(dest) => dest,\n                     _ => return err!(Unreachable),\n                 };\n-                let ty = sig.output();\n-                let layout = self.layout_of(ty)?;\n-                M::call_intrinsic(self, instance, args, ret, layout, target)?;\n-                self.dump_local(ret);\n+                M::call_intrinsic(self, instance, args, ret, target)?;\n+                self.dump_place(*ret);\n                 Ok(())\n             }\n             // FIXME: figure out why we can't just go through the shim\n             ty::InstanceDef::ClosureOnceShim { .. } => {\n-                if M::eval_fn_call(self, instance, destination, args, span, sig)? {\n+                if M::eval_fn_call(self, instance, destination, args, span)? {\n                     return Ok(());\n                 }\n                 let mut arg_locals = self.frame().mir.args_iter();\n                 match sig.abi {\n                     // closure as closure once\n                     Abi::RustCall => {\n-                        for (arg_local, &valty) in arg_locals.zip(args) {\n+                        for (arg_local, &op) in arg_locals.zip(args) {\n                             let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                            self.write_value(valty, dest)?;\n+                            self.copy_op(op, dest)?;\n                         }\n                     }\n                     // non capture closure as fn ptr\n@@ -301,12 +291,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         );\n                         trace!(\"args: {:#?}\", args);\n                         let local = arg_locals.nth(1).unwrap();\n-                        for (i, &valty) in args.into_iter().enumerate() {\n+                        for (i, &op) in args.into_iter().enumerate() {\n                             let dest = self.eval_place(&mir::Place::Local(local).field(\n                                 mir::Field::new(i),\n-                                valty.ty,\n+                                op.layout.ty,\n                             ))?;\n-                            self.write_value(valty, dest)?;\n+                            self.copy_op(op, dest)?;\n                         }\n                     }\n                     _ => bug!(\"bad ABI for ClosureOnceShim: {:?}\", sig.abi),\n@@ -318,7 +308,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::InstanceDef::CloneShim(..) |\n             ty::InstanceDef::Item(_) => {\n                 // Push the stack frame, and potentially be entirely done if the call got hooked\n-                if M::eval_fn_call(self, instance, destination, args, span, sig)? {\n+                if M::eval_fn_call(self, instance, destination, args, span)? {\n+                    // TODO: Can we make it return the frame to push, instead\n+                    // of the hook doing half of the work and us doing the argument\n+                    // initialization?\n                     return Ok(());\n                 }\n \n@@ -338,47 +331,41 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             // write first argument\n                             let first_local = arg_locals.next().unwrap();\n                             let dest = self.eval_place(&mir::Place::Local(first_local))?;\n-                            self.write_value(args[0], dest)?;\n+                            self.copy_op(args[0], dest)?;\n                         }\n \n                         // unpack and write all other args\n-                        let layout = self.layout_of(args[1].ty)?;\n-                        if let ty::TyTuple(_) = args[1].ty.sty {\n+                        let layout = args[1].layout;\n+                        if let ty::TyTuple(_) = layout.ty.sty {\n                             if layout.is_zst() {\n                                 // Nothing to do, no need to unpack zsts\n                                 return Ok(());\n                             }\n                             if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n                                 for (i, arg_local) in arg_locals.enumerate() {\n-                                    let field = mir::Field::new(i);\n-                                    let (value, layout) = self.read_field(args[1].value, None, field, layout)?;\n+                                    let arg = self.operand_field(args[1], i as u64)?;\n                                     let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                                    let valty = ValTy {\n-                                        value,\n-                                        ty: layout.ty,\n-                                    };\n-                                    self.write_value(valty, dest)?;\n+                                    self.copy_op(arg, dest)?;\n                                 }\n                             } else {\n                                 trace!(\"manual impl of rust-call ABI\");\n                                 // called a manual impl of a rust-call function\n                                 let dest = self.eval_place(\n                                     &mir::Place::Local(arg_locals.next().unwrap()),\n                                 )?;\n-                                self.write_value(args[1], dest)?;\n+                                self.copy_op(args[1], dest)?;\n                             }\n                         } else {\n                             bug!(\n-                                \"rust-call ABI tuple argument was {:#?}, {:#?}\",\n-                                args[1].ty,\n+                                \"rust-call ABI tuple argument was {:#?}\",\n                                 layout\n                             );\n                         }\n                     }\n                     _ => {\n-                        for (arg_local, &valty) in arg_locals.zip(args) {\n+                        for (arg_local, &op) in arg_locals.zip(args) {\n                             let dest = self.eval_place(&mir::Place::Local(arg_local))?;\n-                            self.write_value(valty, dest)?;\n+                            self.copy_op(op, dest)?;\n                         }\n                     }\n                 }\n@@ -388,16 +375,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.memory.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n-                let (ptr, vtable) = self.into_ptr_vtable_pair(args[0].value)?;\n+                let (ptr, vtable) = self.read_value(args[0])?.to_scalar_dyn_trait()?;\n                 let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n                     ptr_align\n-                )?.unwrap_or_err()?.to_ptr()?;\n+                )?.to_ptr()?;\n                 let instance = self.memory.get_fn(fn_ptr)?;\n                 let mut args = args.to_vec();\n-                let ty = self.layout_of(args[0].ty)?.field(&self, 0)?.ty;\n-                args[0].ty = ty;\n-                args[0].value = Value::Scalar(ptr);\n+                let layout = args[0].layout.field(&self, 0)?;\n+                args[0].layout = layout;\n+                args[0].op = Operand::Immediate(Value::Scalar(ptr.into()));\n                 // recurse with concrete function\n                 self.eval_fn_call(instance, destination, &args, span, sig)\n             }"}, {"sha": "1cc8644629ee9a13c993e312ce05d2f0ae5c9dca", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -72,7 +72,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, ty::Instance<'tcx>> {\n         // we don't care about the pointee type, we just want a pointer\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.unwrap_or_err()?.to_ptr()?;\n+        let drop_fn = self.memory.read_ptr_sized(vtable, pointer_align)?.to_ptr()?;\n         self.memory.get_fn(drop_fn)\n     }\n \n@@ -82,11 +82,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     ) -> EvalResult<'tcx, (Size, Align)> {\n         let pointer_size = self.memory.pointer_size();\n         let pointer_align = self.tcx.data_layout.pointer_align;\n-        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.unwrap_or_err()?.to_bits(pointer_size)? as u64;\n+        let size = self.memory.read_ptr_sized(vtable.offset(pointer_size, self)?, pointer_align)?.to_bits(pointer_size)? as u64;\n         let align = self.memory.read_ptr_sized(\n             vtable.offset(pointer_size * 2, self)?,\n             pointer_align\n-        )?.unwrap_or_err()?.to_bits(pointer_size)? as u64;\n+        )?.to_bits(pointer_size)? as u64;\n         Ok((Size::from_bytes(size), Align::from_bytes(align, align).unwrap()))\n     }\n }"}, {"sha": "c450901eec8b715ba419fd0dd6b66105bb2bf733", "filename": "src/librustc_mir/interpret/value.rs", "status": "removed", "additions": 0, "deletions": 572, "changes": 572, "blob_url": "https://github.com/rust-lang/rust/blob/7d4f5f7974f75635c88af31013ae7cc0ed1927ef/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d4f5f7974f75635c88af31013ae7cc0ed1927ef/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalue.rs?ref=7d4f5f7974f75635c88af31013ae7cc0ed1927ef", "patch": "@@ -1,572 +0,0 @@\n-//! Reading and writing values from/to memory, handling LocalValue and the ByRef optimization,\n-//! reading/writing discriminants\n-\n-use std::mem;\n-\n-use rustc::mir;\n-use rustc::ty::layout::{self, Size, Align, IntegerExt, LayoutOf, TyLayout, Primitive};\n-use rustc::ty::{self, Ty, TyCtxt, TypeAndMut};\n-use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n-use rustc::mir::interpret::{\n-    GlobalId, Value, Scalar, FrameInfo, AllocType,\n-    EvalResult, EvalErrorKind, Pointer, ConstValue,\n-    ScalarMaybeUndef,\n-};\n-\n-use super::{Place, PlaceExtra, Memory, Frame,\n-            HasMemory, MemoryKind,\n-            Machine, ValTy, EvalContext};\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n-pub enum LocalValue {\n-    Dead,\n-    Live(Value),\n-}\n-\n-impl LocalValue {\n-    pub fn access(self) -> EvalResult<'static, Value> {\n-        match self {\n-            LocalValue::Dead => err!(DeadLocal),\n-            LocalValue::Live(val) => Ok(val),\n-        }\n-    }\n-}\n-\n-impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    pub fn write_ptr(&mut self, dest: Place, val: Scalar, dest_ty: Ty<'tcx>) -> EvalResult<'tcx> {\n-        let valty = ValTy {\n-            value: val.to_value(),\n-            ty: dest_ty,\n-        };\n-        self.write_value(valty, dest)\n-    }\n-\n-    pub fn write_scalar(\n-        &mut self,\n-        dest: Place,\n-        val: impl Into<ScalarMaybeUndef>,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        let valty = ValTy {\n-            value: Value::Scalar(val.into()),\n-            ty: dest_ty,\n-        };\n-        self.write_value(valty, dest)\n-    }\n-\n-    pub fn write_value(\n-        &mut self,\n-        ValTy { value: src_val, ty: dest_ty } : ValTy<'tcx>,\n-        dest: Place,\n-    ) -> EvalResult<'tcx> {\n-        //trace!(\"Writing {:?} to {:?} at type {:?}\", src_val, dest, dest_ty);\n-        // Note that it is really important that the type here is the right one, and matches the type things are read at.\n-        // In case `src_val` is a `ScalarPair`, we don't do any magic here to handle padding properly, which is only\n-        // correct if we never look at this data with the wrong type.\n-\n-        match dest {\n-            Place::Ptr { ptr, align, extra } => {\n-                assert_eq!(extra, PlaceExtra::None);\n-                self.write_value_to_ptr(src_val, ptr.unwrap_or_err()?, align, dest_ty)\n-            }\n-\n-            Place::Local { frame, local } => {\n-                let old_val = self.stack[frame].locals[local].access()?;\n-                self.write_value_possibly_by_val(\n-                    src_val,\n-                    |this, val| this.stack[frame].set_local(local, val),\n-                    old_val,\n-                    dest_ty,\n-                )\n-            }\n-        }\n-    }\n-\n-    // The cases here can be a bit subtle. Read carefully!\n-    fn write_value_possibly_by_val<F: FnOnce(&mut Self, Value) -> EvalResult<'tcx>>(\n-        &mut self,\n-        src_val: Value,\n-        write_dest: F,\n-        old_dest_val: Value,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        // FIXME: this should be a layout check, not underlying value\n-        if let Value::ByRef(dest_ptr, align) = old_dest_val {\n-            // If the value is already `ByRef` (that is, backed by an `Allocation`),\n-            // then we must write the new value into this allocation, because there may be\n-            // other pointers into the allocation. These other pointers are logically\n-            // pointers into the local variable, and must be able to observe the change.\n-            //\n-            // Thus, it would be an error to replace the `ByRef` with a `ByVal`, unless we\n-            // knew for certain that there were no outstanding pointers to this allocation.\n-            self.write_value_to_ptr(src_val, dest_ptr, align, dest_ty)?;\n-        } else if let Value::ByRef(src_ptr, align) = src_val {\n-            // If the value is not `ByRef`, then we know there are no pointers to it\n-            // and we can simply overwrite the `Value` in the locals array directly.\n-            //\n-            // In this specific case, where the source value is `ByRef`, we must duplicate\n-            // the allocation, because this is a by-value operation. It would be incorrect\n-            // if they referred to the same allocation, since then a change to one would\n-            // implicitly change the other.\n-            //\n-            // It is a valid optimization to attempt reading a primitive value out of the\n-            // source and write that into the destination without making an allocation, so\n-            // we do so here.\n-            if let Ok(Some(src_val)) = self.try_read_value(src_ptr, align, dest_ty) {\n-                write_dest(self, src_val)?;\n-            } else {\n-                let layout = self.layout_of(dest_ty)?;\n-                let dest_ptr = self.alloc_ptr(layout)?.into();\n-                self.memory.copy(src_ptr, align.min(layout.align), dest_ptr, layout.align, layout.size, false)?;\n-                write_dest(self, Value::ByRef(dest_ptr, layout.align))?;\n-            }\n-        } else {\n-            // Finally, we have the simple case where neither source nor destination are\n-            // `ByRef`. We may simply copy the source value over the the destintion.\n-            write_dest(self, src_val)?;\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn write_value_to_ptr(\n-        &mut self,\n-        value: Value,\n-        dest: Scalar,\n-        dest_align: Align,\n-        dest_ty: Ty<'tcx>,\n-    ) -> EvalResult<'tcx> {\n-        let layout = self.layout_of(dest_ty)?;\n-        trace!(\"write_value_to_ptr: {:#?}, {}, {:#?}\", value, dest_ty, layout);\n-        match value {\n-            Value::ByRef(ptr, align) => {\n-                self.memory.copy(ptr, align.min(layout.align), dest, dest_align.min(layout.align), layout.size, false)\n-            }\n-            Value::Scalar(scalar) => {\n-                let signed = match layout.abi {\n-                    layout::Abi::Scalar(ref scal) => match scal.value {\n-                        layout::Primitive::Int(_, signed) => signed,\n-                        _ => false,\n-                    },\n-                    _ => false,\n-                };\n-                self.memory.write_scalar(dest, dest_align, scalar, layout.size, layout.align, signed)\n-            }\n-            Value::ScalarPair(a_val, b_val) => {\n-                trace!(\"write_value_to_ptr valpair: {:#?}\", layout);\n-                let (a, b) = match layout.abi {\n-                    layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\"write_value_to_ptr: invalid ScalarPair layout: {:#?}\", layout)\n-                };\n-                let (a_size, b_size) = (a.size(&self), b.size(&self));\n-                let (a_align, b_align) = (a.align(&self), b.align(&self));\n-                let a_ptr = dest;\n-                let b_offset = a_size.abi_align(b_align);\n-                let b_ptr = dest.ptr_offset(b_offset, &self)?.into();\n-                // TODO: What about signedess?\n-                self.memory.write_scalar(a_ptr, dest_align, a_val, a_size, a_align, false)?;\n-                self.memory.write_scalar(b_ptr, dest_align, b_val, b_size, b_align, false)\n-            }\n-        }\n-    }\n-\n-    pub fn try_read_value(&self, ptr: Scalar, ptr_align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Option<Value>> {\n-        let layout = self.layout_of(ty)?;\n-        self.memory.check_align(ptr, ptr_align)?;\n-\n-        if layout.size.bytes() == 0 {\n-            return Ok(Some(Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { bits: 0, size: 0 }))));\n-        }\n-\n-        let ptr = ptr.to_ptr()?;\n-\n-        match layout.abi {\n-            layout::Abi::Scalar(..) => {\n-                let scalar = self.memory.read_scalar(ptr, ptr_align, layout.size)?;\n-                Ok(Some(Value::Scalar(scalar)))\n-            }\n-            layout::Abi::ScalarPair(ref a, ref b) => {\n-                let (a, b) = (&a.value, &b.value);\n-                let (a_size, b_size) = (a.size(self), b.size(self));\n-                let a_ptr = ptr;\n-                let b_offset = a_size.abi_align(b.align(self));\n-                let b_ptr = ptr.offset(b_offset, self)?.into();\n-                let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n-                let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n-                Ok(Some(Value::ScalarPair(a_val, b_val)))\n-            }\n-            _ => Ok(None),\n-        }\n-    }\n-\n-    pub fn read_value(&self, ptr: Scalar, align: Align, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        if let Some(val) = self.try_read_value(ptr, align, ty)? {\n-            Ok(val)\n-        } else {\n-            bug!(\"primitive read failed for type: {:?}\", ty);\n-        }\n-    }\n-\n-    pub(super) fn eval_operand_to_scalar(\n-        &mut self,\n-        op: &mir::Operand<'tcx>,\n-    ) -> EvalResult<'tcx, Scalar> {\n-        let valty = self.eval_operand(op)?;\n-        self.value_to_scalar(valty)\n-    }\n-\n-    pub(crate) fn operands_to_args(\n-        &mut self,\n-        ops: &[mir::Operand<'tcx>],\n-    ) -> EvalResult<'tcx, Vec<ValTy<'tcx>>> {\n-        ops.into_iter()\n-            .map(|op| self.eval_operand(op))\n-            .collect()\n-    }\n-\n-    pub fn eval_operand(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, ValTy<'tcx>> {\n-        use rustc::mir::Operand::*;\n-        let ty = self.monomorphize(op.ty(self.mir(), *self.tcx), self.substs());\n-        match *op {\n-            // FIXME: do some more logic on `move` to invalidate the old location\n-            Copy(ref place) |\n-            Move(ref place) => {\n-                Ok(ValTy {\n-                    value: self.eval_and_read_place(place)?,\n-                    ty\n-                })\n-            },\n-\n-            Constant(ref constant) => {\n-                let value = self.const_to_value(constant.literal.val)?;\n-\n-                Ok(ValTy {\n-                    value,\n-                    ty,\n-                })\n-            }\n-        }\n-    }\n-\n-    pub fn deallocate_local(&mut self, local: LocalValue) -> EvalResult<'tcx> {\n-        // FIXME: should we tell the user that there was a local which was never written to?\n-        if let LocalValue::Live(Value::ByRef(ptr, _align)) = local {\n-            trace!(\"deallocating local\");\n-            let ptr = ptr.to_ptr()?;\n-            self.memory.dump_alloc(ptr.alloc_id);\n-            self.memory.deallocate_local(ptr)?;\n-        };\n-        Ok(())\n-    }\n-\n-    pub fn allocate_place_for_value(\n-        &mut self,\n-        value: Value,\n-        layout: TyLayout<'tcx>,\n-        variant: Option<usize>,\n-    ) -> EvalResult<'tcx, Place> {\n-        let (ptr, align) = match value {\n-            Value::ByRef(ptr, align) => (ptr, align),\n-            Value::ScalarPair(..) | Value::Scalar(_) => {\n-                let ptr = self.alloc_ptr(layout)?.into();\n-                self.write_value_to_ptr(value, ptr, layout.align, layout.ty)?;\n-                (ptr, layout.align)\n-            },\n-        };\n-        Ok(Place::Ptr {\n-            ptr: ptr.into(),\n-            align,\n-            extra: variant.map_or(PlaceExtra::None, PlaceExtra::DowncastVariant),\n-        })\n-    }\n-\n-    pub fn force_allocation(&mut self, place: Place) -> EvalResult<'tcx, Place> {\n-        let new_place = match place {\n-            Place::Local { frame, local } => {\n-                match self.stack[frame].locals[local].access()? {\n-                    Value::ByRef(ptr, align) => {\n-                        Place::Ptr {\n-                            ptr: ptr.into(),\n-                            align,\n-                            extra: PlaceExtra::None,\n-                        }\n-                    }\n-                    val => {\n-                        let ty = self.stack[frame].mir.local_decls[local].ty;\n-                        let ty = self.monomorphize(ty, self.stack[frame].instance.substs);\n-                        let layout = self.layout_of(ty)?;\n-                        let ptr = self.alloc_ptr(layout)?;\n-                        self.stack[frame].locals[local] =\n-                            LocalValue::Live(Value::ByRef(ptr.into(), layout.align)); // it stays live\n-\n-                        let place = Place::from_ptr(ptr, layout.align);\n-                        self.write_value(ValTy { value: val, ty }, place)?;\n-                        place\n-                    }\n-                }\n-            }\n-            Place::Ptr { .. } => place,\n-        };\n-        Ok(new_place)\n-    }\n-\n-    /// Convert to ByVal or ScalarPair *if possible*, leave `ByRef` otherwise\n-    pub fn try_read_by_ref(&self, mut val: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        if let Value::ByRef(ptr, align) = val {\n-            if let Some(read_val) = self.try_read_value(ptr, align, ty)? {\n-                val = read_val;\n-            }\n-        }\n-        Ok(val)\n-    }\n-\n-    pub fn value_to_scalar(\n-        &self,\n-        ValTy { value, ty } : ValTy<'tcx>,\n-    ) -> EvalResult<'tcx, Scalar> {\n-        let value = match value {\n-            Value::ByRef(ptr, align) => self.read_value(ptr, align, ty)?,\n-            scalar_or_pair => scalar_or_pair,\n-        };\n-        match value {\n-            Value::ByRef(..) => bug!(\"read_value can't result in `ByRef`\"),\n-\n-            Value::Scalar(scalar) => scalar.unwrap_or_err(),\n-\n-            Value::ScalarPair(..) => bug!(\"value_to_scalar can't work with fat pointers\"),\n-        }\n-    }\n-\n-    pub fn storage_live(&mut self, local: mir::Local) -> EvalResult<'tcx, LocalValue> {\n-        trace!(\"{:?} is now live\", local);\n-\n-        let ty = self.frame().mir.local_decls[local].ty;\n-        let init = self.init_value(ty)?;\n-        // StorageLive *always* kills the value that's currently stored\n-        Ok(mem::replace(&mut self.frame_mut().locals[local], LocalValue::Live(init)))\n-    }\n-\n-    pub(super) fn init_value(&mut self, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        let ty = self.monomorphize(ty, self.substs());\n-        let layout = self.layout_of(ty)?;\n-        Ok(match layout.abi {\n-            layout::Abi::Scalar(..) => Value::Scalar(ScalarMaybeUndef::Undef),\n-            layout::Abi::ScalarPair(..) => Value::ScalarPair(\n-                ScalarMaybeUndef::Undef,\n-                ScalarMaybeUndef::Undef,\n-            ),\n-            _ => Value::ByRef(self.alloc_ptr(layout)?.into(), layout.align),\n-        })\n-    }\n-\n-    /// reads a tag and produces the corresponding variant index\n-    pub fn read_discriminant_as_variant_index(\n-        &self,\n-        place: Place,\n-        layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, usize> {\n-        match layout.variants {\n-            ty::layout::Variants::Single { index } => Ok(index),\n-            ty::layout::Variants::Tagged { .. } => {\n-                let discr_val = self.read_discriminant_value(place, layout)?;\n-                layout\n-                    .ty\n-                    .ty_adt_def()\n-                    .expect(\"tagged layout for non adt\")\n-                    .discriminants(self.tcx.tcx)\n-                    .position(|var| var.val == discr_val)\n-                    .ok_or_else(|| EvalErrorKind::InvalidDiscriminant.into())\n-            }\n-            ty::layout::Variants::NicheFilling { .. } => {\n-                let discr_val = self.read_discriminant_value(place, layout)?;\n-                assert_eq!(discr_val as usize as u128, discr_val);\n-                Ok(discr_val as usize)\n-            },\n-        }\n-    }\n-\n-    pub fn read_discriminant_value(\n-        &self,\n-        place: Place,\n-        layout: TyLayout<'tcx>,\n-    ) -> EvalResult<'tcx, u128> {\n-        trace!(\"read_discriminant_value {:#?}\", layout);\n-        if layout.abi == layout::Abi::Uninhabited {\n-            return Ok(0);\n-        }\n-\n-        match layout.variants {\n-            layout::Variants::Single { index } => {\n-                let discr_val = layout.ty.ty_adt_def().map_or(\n-                    index as u128,\n-                    |def| def.discriminant_for_variant(*self.tcx, index).val);\n-                return Ok(discr_val);\n-            }\n-            layout::Variants::Tagged { .. } |\n-            layout::Variants::NicheFilling { .. } => {},\n-        }\n-        let discr_place_val = self.read_place(place)?;\n-        let (discr_val, discr) = self.read_field(discr_place_val, None, mir::Field::new(0), layout)?;\n-        trace!(\"discr value: {:?}, {:?}\", discr_val, discr);\n-        let raw_discr = self.value_to_scalar(ValTy {\n-            value: discr_val,\n-            ty: discr.ty\n-        })?;\n-        let discr_val = match layout.variants {\n-            layout::Variants::Single { .. } => bug!(),\n-            // FIXME: should we catch invalid discriminants here?\n-            layout::Variants::Tagged { .. } => {\n-                if discr.ty.is_signed() {\n-                    let i = raw_discr.to_bits(discr.size)? as i128;\n-                    // going from layout tag type to typeck discriminant type\n-                    // requires first sign extending with the layout discriminant\n-                    let shift = 128 - discr.size.bits();\n-                    let sexted = (i << shift) >> shift;\n-                    // and then zeroing with the typeck discriminant type\n-                    let discr_ty = layout\n-                        .ty\n-                        .ty_adt_def().expect(\"tagged layout corresponds to adt\")\n-                        .repr\n-                        .discr_type();\n-                    let discr_ty = layout::Integer::from_attr(self.tcx.tcx, discr_ty);\n-                    let shift = 128 - discr_ty.size().bits();\n-                    let truncatee = sexted as u128;\n-                    (truncatee << shift) >> shift\n-                } else {\n-                    raw_discr.to_bits(discr.size)?\n-                }\n-            },\n-            layout::Variants::NicheFilling {\n-                dataful_variant,\n-                ref niche_variants,\n-                niche_start,\n-                ..\n-            } => {\n-                let variants_start = *niche_variants.start() as u128;\n-                let variants_end = *niche_variants.end() as u128;\n-                match raw_discr {\n-                    Scalar::Ptr(_) => {\n-                        assert!(niche_start == 0);\n-                        assert!(variants_start == variants_end);\n-                        dataful_variant as u128\n-                    },\n-                    Scalar::Bits { bits: raw_discr, size } => {\n-                        assert_eq!(size as u64, discr.size.bytes());\n-                        let discr = raw_discr.wrapping_sub(niche_start)\n-                            .wrapping_add(variants_start);\n-                        if variants_start <= discr && discr <= variants_end {\n-                            discr\n-                        } else {\n-                            dataful_variant as u128\n-                        }\n-                    },\n-                }\n-            }\n-        };\n-\n-        Ok(discr_val)\n-    }\n-\n-\n-    pub fn write_discriminant_value(\n-        &mut self,\n-        dest_ty: Ty<'tcx>,\n-        dest: Place,\n-        variant_index: usize,\n-    ) -> EvalResult<'tcx> {\n-        let layout = self.layout_of(dest_ty)?;\n-\n-        match layout.variants {\n-            layout::Variants::Single { index } => {\n-                if index != variant_index {\n-                    // If the layout of an enum is `Single`, all\n-                    // other variants are necessarily uninhabited.\n-                    assert_eq!(layout.for_variant(&self, variant_index).abi,\n-                               layout::Abi::Uninhabited);\n-                }\n-            }\n-            layout::Variants::Tagged { ref tag, .. } => {\n-                let discr_val = dest_ty.ty_adt_def().unwrap()\n-                    .discriminant_for_variant(*self.tcx, variant_index)\n-                    .val;\n-\n-                // raw discriminants for enums are isize or bigger during\n-                // their computation, but the in-memory tag is the smallest possible\n-                // representation\n-                let size = tag.value.size(self.tcx.tcx);\n-                let shift = 128 - size.bits();\n-                let discr_val = (discr_val << shift) >> shift;\n-\n-                let (discr_dest, tag) = self.place_field(dest, mir::Field::new(0), layout)?;\n-                self.write_scalar(discr_dest, Scalar::Bits {\n-                    bits: discr_val,\n-                    size: size.bytes() as u8,\n-                }, tag.ty)?;\n-            }\n-            layout::Variants::NicheFilling {\n-                dataful_variant,\n-                ref niche_variants,\n-                niche_start,\n-                ..\n-            } => {\n-                if variant_index != dataful_variant {\n-                    let (niche_dest, niche) =\n-                        self.place_field(dest, mir::Field::new(0), layout)?;\n-                    let niche_value = ((variant_index - niche_variants.start()) as u128)\n-                        .wrapping_add(niche_start);\n-                    self.write_scalar(niche_dest, Scalar::Bits {\n-                        bits: niche_value,\n-                        size: niche.size.bytes() as u8,\n-                    }, niche.ty)?;\n-                }\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n-    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value> {\n-        let ptr = self.memory.allocate_bytes(s.as_bytes());\n-        Ok(Scalar::Ptr(ptr).to_value_with_len(s.len() as u64, self.tcx.tcx))\n-    }\n-\n-    pub fn const_to_value(\n-        &mut self,\n-        val: ConstValue<'tcx>,\n-    ) -> EvalResult<'tcx, Value> {\n-        match val {\n-            ConstValue::Unevaluated(def_id, substs) => {\n-                let instance = self.resolve(def_id, substs)?;\n-                self.read_global_as_value(GlobalId {\n-                    instance,\n-                    promoted: None,\n-                })\n-            }\n-            ConstValue::ByRef(alloc, offset) => {\n-                // FIXME: Allocate new AllocId for all constants inside\n-                let id = self.memory.allocate_value(alloc.clone(), MemoryKind::Stack)?;\n-                Ok(Value::ByRef(Pointer::new(id, offset).into(), alloc.align))\n-            },\n-            ConstValue::ScalarPair(a, b) => Ok(Value::ScalarPair(a.into(), b.into())),\n-            ConstValue::Scalar(val) => Ok(Value::Scalar(val.into())),\n-        }\n-    }\n-}\n-\n-impl<'mir, 'tcx> Frame<'mir, 'tcx> {\n-    pub(super) fn set_local(&mut self, local: mir::Local, value: Value) -> EvalResult<'tcx> {\n-        match self.locals[local] {\n-            LocalValue::Dead => err!(DeadLocal),\n-            LocalValue::Live(ref mut local) => {\n-                *local = value;\n-                Ok(())\n-            }\n-        }\n-    }\n-\n-    /// Returns the old value of the local\n-    pub fn storage_dead(&mut self, local: mir::Local) -> LocalValue {\n-        trace!(\"{:?} is now dead\", local);\n-\n-        mem::replace(&mut self.locals[local], LocalValue::Dead)\n-    }\n-}"}, {"sha": "35b8f63c664fb6139ebe71c280adc1155f80513b", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -37,6 +37,7 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n #![feature(step_trait)]\n #![feature(slice_concat_ext)]\n #![feature(if_while_or_patterns)]\n+#![feature(try_from)]\n \n #![recursion_limit=\"256\"]\n \n@@ -82,7 +83,7 @@ pub fn provide(providers: &mut Providers) {\n     shim::provide(providers);\n     transform::provide(providers);\n     providers.const_eval = interpret::const_eval_provider;\n-    providers.const_value_to_allocation = interpret::const_value_to_allocation_provider;\n+    providers.const_to_allocation = interpret::const_to_allocation_provider;\n     providers.check_match = hair::pattern::check_match;\n }\n "}, {"sha": "3f77e69b7dcbe43f8aaf8ed3605692f3d5393575", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 51, "deletions": 47, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -17,16 +17,16 @@ use rustc::mir::{Constant, Location, Place, Mir, Operand, Rvalue, Local};\n use rustc::mir::{NullOp, StatementKind, Statement, BasicBlock, LocalKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext};\n-use rustc::mir::interpret::{ConstEvalErr, EvalErrorKind, ScalarMaybeUndef};\n+use rustc::mir::interpret::{\n+    ConstEvalErr, EvalErrorKind, ScalarMaybeUndef, Scalar, GlobalId, EvalResult\n+};\n use rustc::ty::{TyCtxt, self, Instance};\n-use rustc::mir::interpret::{Value, Scalar, GlobalId, EvalResult};\n-use interpret::EvalContext;\n-use interpret::CompileTimeEvaluator;\n-use interpret::{eval_promoted, mk_borrowck_eval_cx, ValTy};\n+use interpret::{EvalContext, CompileTimeEvaluator, eval_promoted, mk_borrowck_eval_cx};\n+use interpret::{Value, OpTy, MemoryKind};\n use transform::{MirPass, MirSource};\n use syntax::source_map::{Span, DUMMY_SP};\n use rustc::ty::subst::Substs;\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::ty::ParamEnv;\n use rustc::ty::layout::{\n     LayoutOf, TyLayout, LayoutError,\n@@ -65,7 +65,7 @@ impl MirPass for ConstProp {\n     }\n }\n \n-type Const<'tcx> = (Value, TyLayout<'tcx>, Span);\n+type Const<'tcx> = (OpTy<'tcx>, Span);\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'b, 'a, 'tcx:'a+'b> {\n@@ -257,10 +257,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n         source_info: SourceInfo,\n     ) -> Option<Const<'tcx>> {\n         self.ecx.tcx.span = source_info.span;\n-        match self.ecx.const_to_value(c.literal.val) {\n-            Ok(val) => {\n+        match self.ecx.const_value_to_op(c.literal.val) {\n+            Ok(op) => {\n                 let layout = self.tcx.layout_of(self.param_env.and(c.literal.ty)).ok()?;\n-                Some((val, layout, c.span))\n+                Some((OpTy { op, layout }, c.span))\n             },\n             Err(error) => {\n                 let (stacktrace, span) = self.ecx.generate_stacktrace(None);\n@@ -284,12 +284,15 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _) => {\n                     trace!(\"field proj on {:?}\", proj.base);\n-                    let (base, layout, span) = self.eval_place(&proj.base, source_info)?;\n-                    let valty = self.use_ecx(source_info, |this| {\n-                        this.ecx.read_field(base, None, field, layout)\n+                    let (base, span) = self.eval_place(&proj.base, source_info)?;\n+                    let res = self.use_ecx(source_info, |this| {\n+                        this.ecx.operand_field(base, field.index() as u64)\n                     })?;\n-                    Some((valty.0, valty.1, span))\n+                    Some((res, span))\n                 },\n+                // We could get more projections by using e.g. `operand_projection`,\n+                // but we do not even have the stack frame set up properly so\n+                // an `Index` projection would throw us off-track.\n                 _ => None,\n             },\n             Place::Promoted(ref promoted) => {\n@@ -306,12 +309,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 };\n                 // cannot use `const_eval` here, because that would require having the MIR\n                 // for the current function available, but we're producing said MIR right now\n-                let (value, _, ty) = self.use_ecx(source_info, |this| {\n+                let res = self.use_ecx(source_info, |this| {\n                     eval_promoted(&mut this.ecx, cid, this.mir, this.param_env)\n                 })?;\n-                let val = (value, ty, source_info.span);\n-                trace!(\"evaluated promoted {:?} to {:?}\", promoted, val);\n-                Some(val)\n+                trace!(\"evaluated promoted {:?} to {:?}\", promoted, res);\n+                Some((res, source_info.span))\n             },\n             _ => None,\n         }\n@@ -343,29 +345,25 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n             Rvalue::Discriminant(..) => None,\n \n             Rvalue::Cast(kind, ref operand, _) => {\n-                let (value, layout, span) = self.eval_operand(operand, source_info)?;\n+                let (op, span) = self.eval_operand(operand, source_info)?;\n                 self.use_ecx(source_info, |this| {\n-                    let dest_ptr = this.ecx.alloc_ptr(place_layout)?;\n-                    let place_align = place_layout.align;\n-                    let dest = ::interpret::Place::from_ptr(dest_ptr, place_align);\n-                    this.ecx.cast(ValTy { value, ty: layout.ty }, kind, place_layout.ty, dest)?;\n-                    Ok((\n-                        Value::ByRef(dest_ptr.into(), place_align),\n-                        place_layout,\n-                        span,\n-                    ))\n+                    let dest = this.ecx.allocate(place_layout, MemoryKind::Stack)?;\n+                    this.ecx.cast(op, kind, dest.into())?;\n+                    Ok((dest.into(), span))\n                 })\n             }\n \n             // FIXME(oli-obk): evaluate static/constant slice lengths\n             Rvalue::Len(_) => None,\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n-                    Value::Scalar(Scalar::Bits {\n-                        bits: n as u128,\n-                        size: self.tcx.data_layout.pointer_size.bytes() as u8,\n-                    }.into()),\n-                    self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    OpTy::from_scalar_value(\n+                        Scalar::Bits {\n+                            bits: n as u128,\n+                            size: self.tcx.data_layout.pointer_size.bytes() as u8,\n+                        },\n+                        self.tcx.layout_of(self.param_env.and(self.tcx.types.usize)).ok()?,\n+                    ),\n                     span,\n                 )))\n             }\n@@ -381,12 +379,12 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     return None;\n                 }\n \n-                let val = self.eval_operand(arg, source_info)?;\n-                let prim = self.use_ecx(source_info, |this| {\n-                    this.ecx.value_to_scalar(ValTy { value: val.0, ty: val.1.ty })\n+                let (arg, _) = self.eval_operand(arg, source_info)?;\n+                let val = self.use_ecx(source_info, |this| {\n+                    let prim = this.ecx.read_scalar(arg)?.not_undef()?;\n+                    this.ecx.unary_op(op, prim, arg.layout)\n                 })?;\n-                let val = self.use_ecx(source_info, |this| this.ecx.unary_op(op, prim, val.1))?;\n-                Some((Value::Scalar(val.into()), place_layout, span))\n+                Some((OpTy::from_scalar_value(val, place_layout), span))\n             }\n             Rvalue::CheckedBinaryOp(op, ref left, ref right) |\n             Rvalue::BinaryOp(op, ref left, ref right) => {\n@@ -404,7 +402,7 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 }\n \n                 let r = self.use_ecx(source_info, |this| {\n-                    this.ecx.value_to_scalar(ValTy { value: right.0, ty: right.1.ty })\n+                    this.ecx.read_value(right.0)\n                 })?;\n                 if op == BinOp::Shr || op == BinOp::Shl {\n                     let left_ty = left.ty(self.mir, self.tcx);\n@@ -414,8 +412,9 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                         .unwrap()\n                         .size\n                         .bits();\n-                    let right_size = right.1.size;\n-                    if r.to_bits(right_size).ok().map_or(false, |b| b >= left_bits as u128) {\n+                    let right_size = right.0.layout.size;\n+                    let r_bits = r.to_scalar().and_then(|r| r.to_bits(right_size));\n+                    if r_bits.ok().map_or(false, |b| b >= left_bits as u128) {\n                         let source_scope_local_data = match self.mir.source_scope_local_data {\n                             ClearCrossCrate::Set(ref data) => data,\n                             ClearCrossCrate::Clear => return None,\n@@ -436,11 +435,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 }\n                 let left = self.eval_operand(left, source_info)?;\n                 let l = self.use_ecx(source_info, |this| {\n-                    this.ecx.value_to_scalar(ValTy { value: left.0, ty: left.1.ty })\n+                    this.ecx.read_value(left.0)\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n-                    this.ecx.binary_op(op, l, left.1.ty, r, right.1.ty)\n+                    this.ecx.binary_op(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n                     Value::ScalarPair(\n@@ -455,7 +454,11 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                     }\n                     Value::Scalar(val.into())\n                 };\n-                Some((val, place_layout, span))\n+                let res = OpTy {\n+                    op: ::interpret::Operand::Immediate(val),\n+                    layout: place_layout,\n+                };\n+                Some((res, span))\n             },\n         }\n     }\n@@ -571,7 +574,8 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n             if let Some(value) = self.eval_operand(cond, source_info) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                if Value::Scalar(Scalar::from_bool(*expected).into()) != value.0 {\n+                let expected = Value::Scalar(Scalar::from_bool(*expected).into());\n+                if expected != value.0.to_immediate() {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n                     match cond {\n@@ -607,7 +611,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             let len = self\n                                 .eval_operand(len, source_info)\n                                 .expect(\"len must be const\");\n-                            let len = match len.0 {\n+                            let len = match len.0.to_immediate() {\n                                 Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,\n@@ -616,7 +620,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             let index = self\n                                 .eval_operand(index, source_info)\n                                 .expect(\"index must be const\");\n-                            let index = match index.0 {\n+                            let index = match index.0.to_immediate() {\n                                 Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,"}, {"sha": "010ca1f7ab47529005ee6ec5904324e4fcc8217f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad2de8b4ee099916113b7b3577ac86857b1568be/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ad2de8b4ee099916113b7b3577ac86857b1568be", "patch": "@@ -1375,7 +1375,7 @@ fn maybe_check_static_with_link_section(tcx: TyCtxt, id: DefId, span: Span) {\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n     if let Ok(static_) = tcx.const_eval(param_env.and(cid)) {\n-        let alloc = tcx.const_value_to_allocation(static_);\n+        let alloc = tcx.const_to_allocation(static_);\n         if alloc.relocations.len() != 0 {\n             let msg = \"statics with a custom `#[link_section]` must be a \\\n                        simple list of bytes on the wasm target with no \\"}]}