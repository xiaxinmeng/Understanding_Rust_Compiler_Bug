{"sha": "6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMjY2NmQ1YjAxZDkyZDVlMzM0ODdlYThjNGFiYTllMDAzNTlhODA=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-08-30T20:49:54Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-09-23T21:23:23Z"}, "message": "ICH: Add ability to test the ICH of exported metadata items.", "tree": {"sha": "3df9fe5856f4c24350fca27f4a988aded9b96f10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3df9fe5856f4c24350fca27f4a988aded9b96f10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "html_url": "https://github.com/rust-lang/rust/commit/6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f2c53ea66bc1491ef125b35fa30c1cc890cde82c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2c53ea66bc1491ef125b35fa30c1cc890cde82c", "html_url": "https://github.com/rust-lang/rust/commit/f2c53ea66bc1491ef125b35fa30c1cc890cde82c"}], "stats": {"total": 737, "additions": 622, "deletions": 115}, "files": [{"sha": "28aab1fdd4167e4fc104ba23ebccd45d271d2a28", "filename": "src/librustc_incremental/assert_dep_graph.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_dep_graph.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -59,9 +59,7 @@ use std::io::Write;\n use syntax::ast;\n use syntax::parse::token::InternedString;\n use syntax_pos::Span;\n-\n-const IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n-const THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n+use {ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED};\n \n pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     let _ignore = tcx.dep_graph.in_ignore();\n@@ -91,7 +89,7 @@ pub fn assert_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         assert!(tcx.sess.opts.debugging_opts.query_dep_graph,\n                 \"cannot use the `#[{}]` or `#[{}]` annotations \\\n                  without supplying `-Z query-dep-graph`\",\n-                IF_THIS_CHANGED, THEN_THIS_WOULD_NEED);\n+                ATTR_IF_THIS_CHANGED, ATTR_THEN_THIS_WOULD_NEED);\n     }\n \n     // Check paths.\n@@ -125,7 +123,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n     fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n         let def_id = self.tcx.map.local_def_id(node_id);\n         for attr in attrs {\n-            if attr.check_name(IF_THIS_CHANGED) {\n+            if attr.check_name(ATTR_IF_THIS_CHANGED) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     None => DepNode::Hir(def_id),\n@@ -141,7 +139,7 @@ impl<'a, 'tcx> IfThisChanged<'a, 'tcx> {\n                     }\n                 };\n                 self.if_this_changed.push((attr.span, def_id, dep_node));\n-            } else if attr.check_name(THEN_THIS_WOULD_NEED) {\n+            } else if attr.check_name(ATTR_THEN_THIS_WOULD_NEED) {\n                 let dep_node_interned = self.argument(attr);\n                 let dep_node = match dep_node_interned {\n                     Some(ref n) => {"}, {"sha": "92ed2637c3d1fa8c949765a57c23eb2326cf38b3", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -28,6 +28,7 @@\n //! at the beginning.\n \n use syntax::ast;\n+use std::cell::RefCell;\n use std::hash::{Hash, SipHasher, Hasher};\n use rustc::dep_graph::DepNode;\n use rustc::hir;\n@@ -46,7 +47,42 @@ mod def_path_hash;\n mod svh_visitor;\n mod caching_codemap_view;\n \n-pub type IncrementalHashesMap = FnvHashMap<DepNode<DefId>, u64>;\n+pub struct IncrementalHashesMap {\n+    hashes: FnvHashMap<DepNode<DefId>, u64>,\n+\n+    // These are the metadata hashes for the current crate as they were stored\n+    // during the last compilation session. They are only loaded if\n+    // -Z query-dep-graph was specified and are needed for auto-tests using\n+    // the #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes to\n+    // check whether some metadata hash has changed in between two revisions.\n+    pub prev_metadata_hashes: RefCell<FnvHashMap<DefId, u64>>,\n+}\n+\n+impl IncrementalHashesMap {\n+    pub fn new() -> IncrementalHashesMap {\n+        IncrementalHashesMap {\n+            hashes: FnvHashMap(),\n+            prev_metadata_hashes: RefCell::new(FnvHashMap()),\n+        }\n+    }\n+\n+    pub fn insert(&mut self, k: DepNode<DefId>, v: u64) -> Option<u64> {\n+        self.hashes.insert(k, v)\n+    }\n+\n+    pub fn iter<'a>(&'a self) -> ::std::collections::hash_map::Iter<'a, DepNode<DefId>, u64> {\n+        self.hashes.iter()\n+    }\n+}\n+\n+impl<'a> ::std::ops::Index<&'a DepNode<DefId>> for IncrementalHashesMap {\n+    type Output = u64;\n+\n+    fn index(&self, index: &'a DepNode<DefId>) -> &u64 {\n+        &self.hashes[index]\n+    }\n+}\n+\n \n pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                                     -> IncrementalHashesMap {\n@@ -55,7 +91,7 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     let hash_spans = tcx.sess.opts.debuginfo != NoDebugInfo;\n     let mut visitor = HashItemsVisitor {\n         tcx: tcx,\n-        hashes: FnvHashMap(),\n+        hashes: IncrementalHashesMap::new(),\n         def_path_hashes: DefPathHashes::new(tcx),\n         codemap: CachingCodemapView::new(tcx),\n         hash_spans: hash_spans,"}, {"sha": "55fe5fc1e349a21aa69278692053a484b22781f7", "filename": "src/librustc_incremental/calculate_svh/svh_visitor.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fsvh_visitor.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -30,9 +30,15 @@ use std::hash::{Hash, SipHasher};\n use super::def_path_hash::DefPathHashes;\n use super::caching_codemap_view::CachingCodemapView;\n \n-const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\"cfg\",\n-                                                      \"rustc_clean\",\n-                                                      \"rustc_dirty\"];\n+const IGNORED_ATTRIBUTES: &'static [&'static str] = &[\n+    \"cfg\",\n+    ::ATTR_IF_THIS_CHANGED,\n+    ::ATTR_THEN_THIS_WOULD_NEED,\n+    ::ATTR_DIRTY,\n+    ::ATTR_CLEAN,\n+    ::ATTR_DIRTY_METADATA,\n+    ::ATTR_CLEAN_METADATA\n+];\n \n pub struct StrictVersionHashVisitor<'a, 'hash: 'a, 'tcx: 'hash> {\n     pub tcx: TyCtxt<'hash, 'tcx, 'tcx>,"}, {"sha": "2c1340e566dda587f3022e019e581b6081ac3e40", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -35,6 +35,13 @@ extern crate serialize as rustc_serialize;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n \n+const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n+const ATTR_CLEAN: &'static str = \"rustc_clean\";\n+const ATTR_DIRTY_METADATA: &'static str = \"rustc_metadata_dirty\";\n+const ATTR_CLEAN_METADATA: &'static str = \"rustc_metadata_clean\";\n+const ATTR_IF_THIS_CHANGED: &'static str = \"rustc_if_this_changed\";\n+const ATTR_THEN_THIS_WOULD_NEED: &'static str = \"rustc_then_this_would_need\";\n+\n mod assert_dep_graph;\n mod calculate_svh;\n mod persist;"}, {"sha": "57e7a0bc21a4ec6ca979af5e442555cd9b76c02f", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -13,6 +13,7 @@\n use rustc::dep_graph::{DepNode, WorkProduct, WorkProductId};\n use rustc::hir::def_id::DefIndex;\n use std::sync::Arc;\n+use rustc_data_structures::fnv::FnvHashMap;\n \n use super::directory::DefPathIndex;\n \n@@ -93,6 +94,18 @@ pub struct SerializedMetadataHashes {\n     /// a `DefPathIndex` that gets retracted to the current `DefId`\n     /// (matching the one found in this structure).\n     pub hashes: Vec<SerializedMetadataHash>,\n+\n+    /// For each DefIndex (as it occurs in SerializedMetadataHash), this\n+    /// map stores the DefPathIndex (as it occurs in DefIdDirectory), so\n+    /// that we can find the new DefId for a SerializedMetadataHash in a\n+    /// subsequent compilation session.\n+    ///\n+    /// This map is only needed for running auto-tests using the\n+    /// #[rustc_metadata_dirty] and #[rustc_metadata_clean] attributes, and\n+    /// is only populated if -Z query-dep-graph is specified. It will be\n+    /// empty otherwise. Importing crates are perfectly happy with just having\n+    /// the DefIndex.\n+    pub index_map: FnvHashMap<DefIndex, DefPathIndex>\n }\n \n /// The hash for some metadata that (when saving) will be exported"}, {"sha": "619e237ee34a3fc6f49d30503e5c3f127fb78c3c", "filename": "src/librustc_incremental/persist/directory.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirectory.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -178,7 +178,6 @@ impl<'a,'tcx> DefIdDirectoryBuilder<'a,'tcx> {\n         &self.directory.paths[id.index as usize]\n     }\n \n-\n     pub fn map(&mut self, node: &DepNode<DefId>) -> DepNode<DefPathIndex> {\n         node.map_def(|&def_id| Some(self.add(def_id))).unwrap()\n     }"}, {"sha": "95452021d878487019c154621f070c4021399aaa", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 141, "deletions": 51, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -9,10 +9,10 @@\n // except according to those terms.\n \n //! Debugging code to test the state of the dependency graph just\n-//! after it is loaded from disk. For each node marked with\n-//! `#[rustc_clean]` or `#[rustc_dirty]`, we will check that a\n-//! suitable node for that item either appears or does not appear in\n-//! the dep-graph, as appropriate:\n+//! after it is loaded from disk and just after it has been saved.\n+//! For each node marked with `#[rustc_clean]` or `#[rustc_dirty]`,\n+//! we will check that a suitable node for that item either appears\n+//! or does not appear in the dep-graph, as appropriate:\n //!\n //! - `#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rev2\")]` if we are\n //!   in `#[cfg(rev2)]`, then there MUST NOT be a node\n@@ -23,20 +23,37 @@\n //!\n //! Errors are reported if we are in the suitable configuration but\n //! the required condition is not met.\n+//!\n+//! The `#[rustc_metadata_dirty]` and `#[rustc_metadata_clean]` attributes\n+//! can be used to check the incremental compilation hash (ICH) values of\n+//! metadata exported in rlibs.\n+//!\n+//! - If a node is marked with `#[rustc_metadata_clean(cfg=\"rev2\")]` we\n+//!   check that the metadata hash for that node is the same for \"rev2\"\n+//!   it was for \"rev1\".\n+//! - If a node is marked with `#[rustc_metadata_dirty(cfg=\"rev2\")]` we\n+//!   check that the metadata hash for that node is *different* for \"rev2\"\n+//!   than it was for \"rev1\".\n+//!\n+//! Note that the metadata-testing attributes must never specify the\n+//! first revision. This would lead to a crash since there is no\n+//! previous revision to compare things to.\n+//!\n \n use super::directory::RetracedDefIdDirectory;\n use super::load::DirtyNodes;\n use rustc::dep_graph::{DepGraphQuery, DepNode};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::Visitor;\n-use rustc_data_structures::fnv::FnvHashSet;\n use syntax::ast::{self, Attribute, NestedMetaItem};\n+use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n use syntax::parse::token::InternedString;\n+use syntax_pos::Span;\n use rustc::ty::TyCtxt;\n \n-const DIRTY: &'static str = \"rustc_dirty\";\n-const CLEAN: &'static str = \"rustc_clean\";\n+use {ATTR_DIRTY, ATTR_CLEAN, ATTR_DIRTY_METADATA, ATTR_CLEAN_METADATA};\n+\n const LABEL: &'static str = \"label\";\n const CFG: &'static str = \"cfg\";\n \n@@ -70,50 +87,11 @@ pub struct DirtyCleanVisitor<'a, 'tcx:'a> {\n }\n \n impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n-    fn expect_associated_value(&self, item: &NestedMetaItem) -> InternedString {\n-        if let Some(value) = item.value_str() {\n-            value\n-        } else {\n-            let msg = if let Some(name) = item.name() {\n-                format!(\"associated value expected for `{}`\", name)\n-            } else {\n-                \"expected an associated value\".to_string()\n-            };\n-\n-            self.tcx.sess.span_fatal(item.span, &msg);\n-        }\n-    }\n-\n-    /// Given a `#[rustc_dirty]` or `#[rustc_clean]` attribute, scan\n-    /// for a `cfg=\"foo\"` attribute and check whether we have a cfg\n-    /// flag called `foo`.\n-    fn check_config(&self, attr: &ast::Attribute) -> bool {\n-        debug!(\"check_config(attr={:?})\", attr);\n-        let config = &self.tcx.map.krate().config;\n-        debug!(\"check_config: config={:?}\", config);\n-        for item in attr.meta_item_list().unwrap_or(&[]) {\n-            if item.check_name(CFG) {\n-                let value = self.expect_associated_value(item);\n-                debug!(\"check_config: searching for cfg {:?}\", value);\n-                for cfg in &config[..] {\n-                    if cfg.check_name(&value[..]) {\n-                        debug!(\"check_config: matched {:?}\", cfg);\n-                        return true;\n-                    }\n-                }\n-                return false;\n-            }\n-        }\n-\n-        self.tcx.sess.span_fatal(\n-            attr.span,\n-            &format!(\"no cfg attribute\"));\n-    }\n \n     fn dep_node(&self, attr: &Attribute, def_id: DefId) -> DepNode<DefId> {\n         for item in attr.meta_item_list().unwrap_or(&[]) {\n             if item.check_name(LABEL) {\n-                let value = self.expect_associated_value(item);\n+                let value = expect_associated_value(self.tcx, item);\n                 match DepNode::from_label_string(&value[..], def_id) {\n                     Ok(def_id) => return def_id,\n                     Err(()) => {\n@@ -194,16 +172,128 @@ impl<'a, 'tcx> Visitor<'tcx> for DirtyCleanVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         let def_id = self.tcx.map.local_def_id(item.id);\n         for attr in self.tcx.get_attrs(def_id).iter() {\n-            if attr.check_name(DIRTY) {\n-                if self.check_config(attr) {\n+            if attr.check_name(ATTR_DIRTY) {\n+                if check_config(self.tcx, attr) {\n                     self.assert_dirty(item, self.dep_node(attr, def_id));\n                 }\n-            } else if attr.check_name(CLEAN) {\n-                if self.check_config(attr) {\n+            } else if attr.check_name(ATTR_CLEAN) {\n+                if check_config(self.tcx, attr) {\n                     self.assert_clean(item, self.dep_node(attr, def_id));\n                 }\n             }\n         }\n     }\n }\n \n+pub fn check_dirty_clean_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  prev_metadata_hashes: &FnvHashMap<DefId, u64>,\n+                                  current_metadata_hashes: &FnvHashMap<DefId, u64>) {\n+    if !tcx.sess.opts.debugging_opts.query_dep_graph {\n+        return;\n+    }\n+\n+    tcx.dep_graph.with_ignore(||{\n+        let krate = tcx.map.krate();\n+        krate.visit_all_items(&mut DirtyCleanMetadataVisitor {\n+            tcx: tcx,\n+            prev_metadata_hashes: prev_metadata_hashes,\n+            current_metadata_hashes: current_metadata_hashes,\n+        });\n+    });\n+}\n+\n+pub struct DirtyCleanMetadataVisitor<'a, 'tcx:'a, 'm> {\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    prev_metadata_hashes: &'m FnvHashMap<DefId, u64>,\n+    current_metadata_hashes: &'m FnvHashMap<DefId, u64>,\n+}\n+\n+impl<'a, 'tcx, 'm> Visitor<'tcx> for DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n+    fn visit_item(&mut self, item: &'tcx hir::Item) {\n+        let def_id = self.tcx.map.local_def_id(item.id);\n+\n+        for attr in self.tcx.get_attrs(def_id).iter() {\n+            if attr.check_name(ATTR_DIRTY_METADATA) {\n+                if check_config(self.tcx, attr) {\n+                    self.assert_state(false, def_id, item.span);\n+                }\n+            } else if attr.check_name(ATTR_CLEAN_METADATA) {\n+                if check_config(self.tcx, attr) {\n+                    self.assert_state(true, def_id, item.span);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx, 'm> DirtyCleanMetadataVisitor<'a, 'tcx, 'm> {\n+\n+    fn assert_state(&self, should_be_clean: bool, def_id: DefId, span: Span) {\n+        let item_path = self.tcx.item_path_str(def_id);\n+        debug!(\"assert_state({})\", item_path);\n+\n+        if let Some(&prev_hash) = self.prev_metadata_hashes.get(&def_id) {\n+            let hashes_are_equal = prev_hash == self.current_metadata_hashes[&def_id];\n+\n+            if should_be_clean && !hashes_are_equal {\n+                self.tcx.sess.span_err(\n+                        span,\n+                        &format!(\"Metadata hash of `{}` is dirty, but should be clean\",\n+                                 item_path));\n+            }\n+\n+            let should_be_dirty = !should_be_clean;\n+            if should_be_dirty && hashes_are_equal {\n+                self.tcx.sess.span_err(\n+                        span,\n+                        &format!(\"Metadata hash of `{}` is clean, but should be dirty\",\n+                                 item_path));\n+            }\n+        } else {\n+            self.tcx.sess.span_err(\n+                        span,\n+                        &format!(\"Could not find previous metadata hash of `{}`\",\n+                                 item_path));\n+        }\n+    }\n+}\n+\n+/// Given a `#[rustc_dirty]` or `#[rustc_clean]` attribute, scan\n+/// for a `cfg=\"foo\"` attribute and check whether we have a cfg\n+/// flag called `foo`.\n+fn check_config(tcx: TyCtxt, attr: &ast::Attribute) -> bool {\n+    debug!(\"check_config(attr={:?})\", attr);\n+    let config = &tcx.map.krate().config;\n+    debug!(\"check_config: config={:?}\", config);\n+    for item in attr.meta_item_list().unwrap_or(&[]) {\n+        if item.check_name(CFG) {\n+            let value = expect_associated_value(tcx, item);\n+            debug!(\"check_config: searching for cfg {:?}\", value);\n+            for cfg in &config[..] {\n+                if cfg.check_name(&value[..]) {\n+                    debug!(\"check_config: matched {:?}\", cfg);\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+    }\n+\n+    tcx.sess.span_fatal(\n+        attr.span,\n+        &format!(\"no cfg attribute\"));\n+}\n+\n+fn expect_associated_value(tcx: TyCtxt, item: &NestedMetaItem) -> InternedString {\n+    if let Some(value) = item.value_str() {\n+        value\n+    } else {\n+        let msg = if let Some(name) = item.name() {\n+            format!(\"associated value expected for `{}`\", name)\n+        } else {\n+            \"expected an associated value\".to_string()\n+        };\n+\n+        tcx.sess.span_fatal(item.span, &msg);\n+    }\n+}"}, {"sha": "ba15529c81a570aa950eef032c57254def57bbab", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -12,9 +12,10 @@\n \n use rustc::dep_graph::DepNode;\n use rustc::hir::def_id::DefId;\n+use rustc::hir::svh::Svh;\n use rustc::session::Session;\n use rustc::ty::TyCtxt;\n-use rustc_data_structures::fnv::FnvHashSet;\n+use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n use std::io::Read;\n@@ -224,6 +225,9 @@ pub fn decode_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     dirty_clean::check_dirty_clean_annotations(tcx, &dirty_raw_source_nodes, &retraced);\n \n+    load_prev_metadata_hashes(tcx,\n+                              &retraced,\n+                              &mut *incremental_hashes_map.prev_metadata_hashes.borrow_mut());\n     Ok(())\n }\n \n@@ -241,6 +245,9 @@ fn dirty_nodes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if let Some(dep_node) = retraced.map(&hash.dep_node) {\n             let current_hash = hcx.hash(&dep_node).unwrap();\n             if current_hash == hash.hash {\n+                debug!(\"initial_dirty_nodes: {:?} is clean (hash={:?})\",\n+                   dep_node.map_def(|&def_id| Some(tcx.def_path(def_id))).unwrap(),\n+                   current_hash);\n                 continue;\n             }\n             debug!(\"initial_dirty_nodes: {:?} is dirty as hash is {:?}, was {:?}\",\n@@ -304,3 +311,50 @@ fn delete_dirty_work_product(tcx: TyCtxt,\n         }\n     }\n }\n+\n+fn load_prev_metadata_hashes(tcx: TyCtxt,\n+                             retraced: &RetracedDefIdDirectory,\n+                             output: &mut FnvHashMap<DefId, u64>) {\n+    if !tcx.sess.opts.debugging_opts.query_dep_graph {\n+        return\n+    }\n+\n+    debug!(\"load_prev_metadata_hashes() - Loading previous metadata hashes\");\n+\n+    let file_path = metadata_hash_export_path(tcx.sess);\n+\n+    if !file_path.exists() {\n+        debug!(\"load_prev_metadata_hashes() - Couldn't find file containing \\\n+                hashes at `{}`\", file_path.display());\n+        return\n+    }\n+\n+    debug!(\"load_prev_metadata_hashes() - File: {}\", file_path.display());\n+\n+    let mut data = vec![];\n+    if !File::open(&file_path)\n+             .and_then(|mut file| file.read_to_end(&mut data)).is_ok() {\n+        debug!(\"load_prev_metadata_hashes() - Couldn't read file containing \\\n+                hashes at `{}`\", file_path.display());\n+        return\n+    }\n+\n+    debug!(\"load_prev_metadata_hashes() - Decoding hashes\");\n+    let mut decoder = Decoder::new(&mut data, 0);\n+    let _ = Svh::decode(&mut decoder).unwrap();\n+    let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder).unwrap();\n+\n+    debug!(\"load_prev_metadata_hashes() - Mapping DefIds\");\n+\n+    assert_eq!(serialized_hashes.index_map.len(), serialized_hashes.hashes.len());\n+    for serialized_hash in serialized_hashes.hashes {\n+        let def_path_index = serialized_hashes.index_map[&serialized_hash.def_index];\n+        if let Some(def_id) = retraced.def_id(def_path_index) {\n+            let old = output.insert(def_id, serialized_hash.hash);\n+            assert!(old.is_none(), \"already have hash for {:?}\", def_id);\n+        }\n+    }\n+\n+    debug!(\"load_prev_metadata_hashes() - successfully loaded {} hashes\",\n+           serialized_hashes.index_map.len());\n+}"}, {"sha": "896e8a9845e9480638c6c46f5aecd6b5b1e5f675", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 62, "deletions": 17, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -27,6 +27,7 @@ use super::directory::*;\n use super::hash::*;\n use super::preds::*;\n use super::fs::*;\n+use super::dirty_clean;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap,\n@@ -37,16 +38,32 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n-    let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n+\n     let mut builder = DefIdDirectoryBuilder::new(tcx);\n     let query = tcx.dep_graph.query();\n+    let mut hcx = HashContext::new(tcx, incremental_hashes_map);\n     let preds = Predecessors::new(&query, &mut hcx);\n+    let mut current_metadata_hashes = FnvHashMap();\n+\n+    // IMPORTANT: We are saving the metadata hashes *before* the dep-graph,\n+    //            since metadata-encoding might add new entries to the\n+    //            DefIdDirectory (which is saved in the dep-graph file).\n+    save_in(sess,\n+            metadata_hash_export_path(sess),\n+            |e| encode_metadata_hashes(tcx,\n+                                       svh,\n+                                       &preds,\n+                                       &mut builder,\n+                                       &mut current_metadata_hashes,\n+                                       e));\n     save_in(sess,\n             dep_graph_path(sess),\n             |e| encode_dep_graph(&preds, &mut builder, e));\n-    save_in(sess,\n-            metadata_hash_export_path(sess),\n-            |e| encode_metadata_hashes(tcx, svh, &preds, &mut builder, e));\n+\n+    let prev_metadata_hashes = incremental_hashes_map.prev_metadata_hashes.borrow();\n+    dirty_clean::check_dirty_clean_metadata(tcx,\n+                                            &*prev_metadata_hashes,\n+                                            &current_metadata_hashes);\n }\n \n pub fn save_work_products(sess: &Session) {\n@@ -63,13 +80,17 @@ pub fn save_work_products(sess: &Session) {\n fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n     where F: FnOnce(&mut Encoder) -> io::Result<()>\n {\n+    debug!(\"save: storing data in {}\", path_buf.display());\n+\n     // delete the old dep-graph, if any\n     // Note: It's important that we actually delete the old file and not just\n     // truncate and overwrite it, since it might be a shared hard-link, the\n     // underlying data of which we don't want to modify\n     if path_buf.exists() {\n         match fs::remove_file(&path_buf) {\n-            Ok(()) => {}\n+            Ok(()) => {\n+                debug!(\"save: remove old file\");\n+            }\n             Err(err) => {\n                 sess.err(&format!(\"unable to delete old dep-graph at `{}`: {}\",\n                                   path_buf.display(),\n@@ -94,7 +115,9 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n     // write the data out\n     let data = wr.into_inner();\n     match File::create(&path_buf).and_then(|mut file| file.write_all(&data)) {\n-        Ok(_) => {}\n+        Ok(_) => {\n+            debug!(\"save: data written to disk successfully\");\n+        }\n         Err(err) => {\n             sess.err(&format!(\"failed to write dep-graph to `{}`: {}\",\n                               path_buf.display(),\n@@ -159,26 +182,23 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n                               svh: Svh,\n                               preds: &Predecessors,\n                               builder: &mut DefIdDirectoryBuilder,\n+                              current_metadata_hashes: &mut FnvHashMap<DefId, u64>,\n                               encoder: &mut Encoder)\n                               -> io::Result<()> {\n-    let mut def_id_hashes = FnvHashMap();\n-    let mut def_id_hash = |def_id: DefId| -> u64 {\n-        *def_id_hashes.entry(def_id)\n-            .or_insert_with(|| {\n-                let index = builder.add(def_id);\n-                let path = builder.lookup_def_path(index);\n-                path.deterministic_hash(tcx)\n-            })\n-    };\n-\n     // For each `MetaData(X)` node where `X` is local, accumulate a\n     // hash.  These are the metadata items we export. Downstream\n     // crates will want to see a hash that tells them whether we might\n     // have changed the metadata for a given item since they last\n     // compiled.\n     //\n     // (I initially wrote this with an iterator, but it seemed harder to read.)\n-    let mut serialized_hashes = SerializedMetadataHashes { hashes: vec![] };\n+    let mut serialized_hashes = SerializedMetadataHashes {\n+        hashes: vec![],\n+        index_map: FnvHashMap()\n+    };\n+\n+    let mut def_id_hashes = FnvHashMap();\n+\n     for (&target, sources) in &preds.inputs {\n         let def_id = match *target {\n             DepNode::MetaData(def_id) => {\n@@ -188,6 +208,15 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n             _ => continue,\n         };\n \n+        let mut def_id_hash = |def_id: DefId| -> u64 {\n+            *def_id_hashes.entry(def_id)\n+                .or_insert_with(|| {\n+                    let index = builder.add(def_id);\n+                    let path = builder.lookup_def_path(index);\n+                    path.deterministic_hash(tcx)\n+                })\n+        };\n+\n         // To create the hash for each item `X`, we don't hash the raw\n         // bytes of the metadata (though in principle we\n         // could). Instead, we walk the predecessors of `MetaData(X)`\n@@ -221,6 +250,22 @@ pub fn encode_metadata_hashes(tcx: TyCtxt,\n         });\n     }\n \n+    if tcx.sess.opts.debugging_opts.query_dep_graph {\n+        for serialized_hash in &serialized_hashes.hashes {\n+            let def_id = DefId::local(serialized_hash.def_index);\n+\n+            // Store entry in the index_map\n+            let def_path_index = builder.add(def_id);\n+            serialized_hashes.index_map.insert(def_id.index, def_path_index);\n+\n+            // Record hash in current_metadata_hashes\n+            current_metadata_hashes.insert(def_id, serialized_hash.hash);\n+        }\n+\n+        debug!(\"save: stored index_map (len={}) for serialized hashes\",\n+               serialized_hashes.index_map.len());\n+    }\n+\n     // Encode everything.\n     svh.encode(encoder)?;\n     serialized_hashes.encode(encoder)?;"}, {"sha": "75cfa587ab1f3f8a3c0972d3e6512fd360e65ff8", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -508,6 +508,16 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType, AttributeGat\n                                         is just used for rustc unit tests \\\n                                         and will never be stable\",\n                                        cfg_fn!(rustc_attrs))),\n+    (\"rustc_metadata_dirty\", Whitelisted, Gated(\"rustc_attrs\",\n+                                                \"the `#[rustc_metadata_dirty]` attribute \\\n+                                                 is just used for rustc unit tests \\\n+                                                 and will never be stable\",\n+                                                 cfg_fn!(rustc_attrs))),\n+    (\"rustc_metadata_clean\", Whitelisted, Gated(\"rustc_attrs\",\n+                                                \"the `#[rustc_metadata_clean]` attribute \\\n+                                                 is just used for rustc unit tests \\\n+                                                 and will never be stable\",\n+                                                 cfg_fn!(rustc_attrs))),\n     (\"rustc_partition_reused\", Whitelisted, Gated(\"rustc_attrs\",\n                                                   \"this attribute \\\n                                                    is just used for rustc unit tests \\"}, {"sha": "74c7797be2ab8cf5815c89f9e0866be3265fb2c8", "filename": "src/test/incremental/hashes/struct_defs.rs", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Fstruct_defs.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -0,0 +1,238 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+\n+// This test case tests the incremental compilation hash (ICH) implementation\n+// for struct definitions.\n+\n+// The general pattern followed here is: Change one thing between rev1 and rev2\n+// and make sure that the hash has changed, then change nothing between rev2 and\n+// rev3 and make sure that the hash has not changed.\n+\n+// We also test the ICH for struct definitions exported in metadata. Same as\n+// above, we want to make sure that the change between rev1 and rev2 also\n+// results in a change of the ICH for the struct's metadata, and that it stays\n+// the same between rev2 and rev3.\n+\n+// must-compile-successfully\n+// revisions: cfail1 cfail2 cfail3\n+// compile-flags: -Z query-dep-graph\n+\n+\n+#![allow(warnings)]\n+#![feature(rustc_attrs)]\n+#![crate_type=\"rlib\"]\n+\n+// Layout ----------------------------------------------------------------------\n+#[cfg(cfail1)]\n+pub struct LayoutPacked;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[repr(packed)]\n+pub struct LayoutPacked;\n+\n+#[cfg(cfail1)]\n+struct LayoutC;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+#[repr(C)]\n+struct LayoutC;\n+\n+\n+// Tuple Struct Change Field Type ----------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct TupleStructFieldType(i32);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct TupleStructFieldType(u32);\n+\n+\n+// Tuple Struct Add Field ------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct TupleStructAddField(i32);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct TupleStructAddField(i32, u32);\n+\n+\n+// Tuple Struct Field Visibility -----------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct TupleStructFieldVisibility(char);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct TupleStructFieldVisibility(pub char);\n+\n+\n+// Record Struct Field Type ----------------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct RecordStructFieldType { x: f32 }\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct RecordStructFieldType { x: u64 }\n+\n+\n+// Record Struct Field Name ----------------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct RecordStructFieldName { x: f32 }\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct RecordStructFieldName { y: f32 }\n+\n+\n+// Record Struct Add Field -----------------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct RecordStructAddField { x: f32 }\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct RecordStructAddField { x: f32, y: () }\n+\n+\n+// Record Struct Field Visibility ----------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct RecordStructFieldVisibility { x: f32 }\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct RecordStructFieldVisibility { pub x: f32 }\n+\n+\n+// Add Lifetime Parameter ------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct AddLifetimeParameter<'a>(&'a f32, &'a f64);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct AddLifetimeParameter<'a, 'b>(&'a f32, &'b f64);\n+\n+\n+// Add Lifetime Parameter Bound ------------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct AddLifetimeParameterBound<'a, 'b>(&'a f32, &'b f64);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct AddLifetimeParameterBound<'a, 'b: 'a>(&'a f32, &'b f64);\n+\n+#[cfg(cfail1)]\n+struct AddLifetimeParameterBoundWhereClause<'a, 'b>(&'a f32, &'b f64);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct AddLifetimeParameterBoundWhereClause<'a, 'b>(&'a f32, &'b f64)\n+    where 'b: 'a;\n+\n+\n+// Add Type Parameter ----------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct AddTypeParameter<T1>(T1, T1);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct AddTypeParameter<T1, T2>(T1, T2);\n+\n+\n+// Add Type Parameter Bound ----------------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct AddTypeParameterBound<T>(T);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct AddTypeParameterBound<T: Send>(T);\n+\n+\n+#[cfg(cfail1)]\n+struct AddTypeParameterBoundWhereClause<T>(T);\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_dirty(cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+struct AddTypeParameterBoundWhereClause<T>(T) where T: Sync;\n+\n+\n+// Empty struct ----------------------------------------------------------------\n+\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_metadata_clean(cfg=\"cfail2\")]\n+pub struct EmptyStruct;\n+\n+\n+// Visibility ------------------------------------------------------------------\n+\n+#[cfg(cfail1)]\n+struct Visibility;\n+\n+#[cfg(not(cfail1))]\n+#[rustc_dirty(label=\"Hir\", cfg=\"cfail2\")]\n+#[rustc_clean(label=\"Hir\", cfg=\"cfail3\")]\n+#[rustc_metadata_clean(cfg=\"cfail3\")]\n+pub struct Visibility;"}, {"sha": "503a851676925f3eb8a37e12d8c3381ebcf680b9", "filename": "src/tools/compiletest/src/header.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fheader.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -182,42 +182,32 @@ pub struct TestProps {\n     // testing harness and used when generating compilation\n     // arguments. (In particular, it propagates to the aux-builds.)\n     pub incremental_dir: Option<PathBuf>,\n+    // Specifies that a cfail test must actually compile without errors.\n+    pub must_compile_successfully: bool,\n }\n \n impl TestProps {\n     pub fn new() -> Self {\n-        let error_patterns = Vec::new();\n-        let aux_builds = Vec::new();\n-        let exec_env = Vec::new();\n-        let run_flags = None;\n-        let pp_exact = None;\n-        let check_lines = Vec::new();\n-        let build_aux_docs = false;\n-        let force_host = false;\n-        let check_stdout = false;\n-        let no_prefer_dynamic = false;\n-        let pretty_expanded = false;\n-        let pretty_compare_only = false;\n-        let forbid_output = Vec::new();\n         TestProps {\n-            error_patterns: error_patterns,\n+            error_patterns: vec![],\n             compile_flags: vec![],\n-            run_flags: run_flags,\n-            pp_exact: pp_exact,\n-            aux_builds: aux_builds,\n+            run_flags: None,\n+            pp_exact: None,\n+            aux_builds: vec![],\n             revisions: vec![],\n             rustc_env: vec![],\n-            exec_env: exec_env,\n-            check_lines: check_lines,\n-            build_aux_docs: build_aux_docs,\n-            force_host: force_host,\n-            check_stdout: check_stdout,\n-            no_prefer_dynamic: no_prefer_dynamic,\n-            pretty_expanded: pretty_expanded,\n+            exec_env: vec![],\n+            check_lines: vec![],\n+            build_aux_docs: false,\n+            force_host: false,\n+            check_stdout: false,\n+            no_prefer_dynamic: false,\n+            pretty_expanded: false,\n             pretty_mode: format!(\"normal\"),\n-            pretty_compare_only: pretty_compare_only,\n-            forbid_output: forbid_output,\n+            pretty_compare_only: false,\n+            forbid_output: vec![],\n             incremental_dir: None,\n+            must_compile_successfully: false,\n         }\n     }\n \n@@ -313,6 +303,10 @@ impl TestProps {\n             if let Some(of) = parse_forbid_output(ln) {\n                 self.forbid_output.push(of);\n             }\n+\n+            if !self.must_compile_successfully {\n+                self.must_compile_successfully = parse_must_compile_successfully(ln);\n+            }\n         });\n \n         for key in vec![\"RUST_TEST_NOCAPTURE\", \"RUST_TEST_THREADS\"] {\n@@ -420,6 +414,10 @@ fn parse_pretty_compare_only(line: &str) -> bool {\n     parse_name_directive(line, \"pretty-compare-only\")\n }\n \n+fn parse_must_compile_successfully(line: &str) -> bool {\n+    parse_name_directive(line, \"must-compile-successfully\")\n+}\n+\n fn parse_env(line: &str, name: &str) -> Option<(String, String)> {\n     parse_name_value_directive(line, name).map(|nv| {\n         // nv is either FOO or FOO=BAR"}, {"sha": "9e490738402dad8e1bdb320675665a9437c7b675", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a2666d5b01d92d5e33487ea8c4aba9e00359a80/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=6a2666d5b01d92d5e33487ea8c4aba9e00359a80", "patch": "@@ -129,13 +129,21 @@ impl<'test> TestCx<'test> {\n     fn run_cfail_test(&self) {\n         let proc_res = self.compile_test();\n \n-        if proc_res.status.success() {\n-            self.fatal_proc_rec(\n-                &format!(\"{} test compiled successfully!\", self.config.mode)[..],\n-                &proc_res);\n-        }\n+        if self.props.must_compile_successfully {\n+            if !proc_res.status.success() {\n+                self.fatal_proc_rec(\n+                    \"test compilation failed although it shouldn't!\",\n+                    &proc_res);\n+            }\n+        } else {\n+            if proc_res.status.success() {\n+                self.fatal_proc_rec(\n+                    &format!(\"{} test compiled successfully!\", self.config.mode)[..],\n+                    &proc_res);\n+            }\n \n-        self.check_correct_failure_status(&proc_res);\n+            self.check_correct_failure_status(&proc_res);\n+        }\n \n         let output_to_check = self.get_output(&proc_res);\n         let expected_errors = errors::load_errors(&self.testpaths.file, self.revision);\n@@ -147,6 +155,7 @@ impl<'test> TestCx<'test> {\n         } else {\n             self.check_error_patterns(&output_to_check, &proc_res);\n         }\n+\n         self.check_no_compiler_crash(&proc_res);\n         self.check_forbid_output(&output_to_check, &proc_res);\n     }\n@@ -943,8 +952,12 @@ actual:\\n\\\n                             output_to_check: &str,\n                             proc_res: &ProcRes) {\n         if self.props.error_patterns.is_empty() {\n-            self.fatal(&format!(\"no error pattern specified in {:?}\",\n-                                self.testpaths.file.display()));\n+            if self.props.must_compile_successfully {\n+                return\n+            } else {\n+                self.fatal(&format!(\"no error pattern specified in {:?}\",\n+                                    self.testpaths.file.display()));\n+            }\n         }\n         let mut next_err_idx = 0;\n         let mut next_err_pat = self.props.error_patterns[next_err_idx].trim();"}]}