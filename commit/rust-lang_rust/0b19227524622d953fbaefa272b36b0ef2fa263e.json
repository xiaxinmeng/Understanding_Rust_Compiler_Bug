{"sha": "0b19227524622d953fbaefa272b36b0ef2fa263e", "node_id": "C_kwDOAAsO6NoAKDBiMTkyMjc1MjQ2MjJkOTUzZmJhZWZhMjcyYjM2YjBlZjJmYTI2M2U", "commit": {"author": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2022-10-22T20:32:54Z"}, "committer": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2023-01-09T22:07:25Z"}, "message": "migrate: `internal.rs`", "tree": {"sha": "a6de719a945663d45ec15e93ab820ec61310073b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6de719a945663d45ec15e93ab820ec61310073b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b19227524622d953fbaefa272b36b0ef2fa263e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b19227524622d953fbaefa272b36b0ef2fa263e", "html_url": "https://github.com/rust-lang/rust/commit/0b19227524622d953fbaefa272b36b0ef2fa263e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b19227524622d953fbaefa272b36b0ef2fa263e/comments", "author": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ffaae758e45cc87b435b1a929c8aae9d9ea5a69", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ffaae758e45cc87b435b1a929c8aae9d9ea5a69", "html_url": "https://github.com/rust-lang/rust/commit/5ffaae758e45cc87b435b1a929c8aae9d9ea5a69"}], "stats": {"total": 175, "additions": 99, "deletions": 76}, "files": [{"sha": "747588c683cc531397870c9f98b0f37fe1de0d59", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b19227524622d953fbaefa272b36b0ef2fa263e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/0b19227524622d953fbaefa272b36b0ef2fa263e/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=0b19227524622d953fbaefa272b36b0ef2fa263e", "patch": "@@ -83,6 +83,8 @@ lint_diag_out_of_impl =\n \n lint_untranslatable_diag = diagnostics should be created using translatable messages\n \n+lint_bad_opt_access = {$msg}\n+\n lint_cstring_ptr = getting the inner pointer of a temporary `CString`\n     .as_ptr_label = this pointer will be invalid\n     .unwrap_label = this `CString` is deallocated at the end of the statement, bind it to a variable to extend its lifetime"}, {"sha": "7d13bcff7fd5def2056ca56ce9f84b5ceece4e04", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 35, "deletions": 76, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/0b19227524622d953fbaefa272b36b0ef2fa263e/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b19227524622d953fbaefa272b36b0ef2fa263e/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=0b19227524622d953fbaefa272b36b0ef2fa263e", "patch": "@@ -1,9 +1,14 @@\n //! Some lints that are only useful in the compiler or crates that use compiler internals, such as\n //! Clippy.\n \n+#![deny(rustc::untranslatable_diagnostic)]\n+#![deny(rustc::diagnostic_outside_of_impl)]\n+use crate::lints::{\n+    BadOptAccessDiag, DefaultHashTypesDiag, DiagOutOfImpl, LintPassByHand, NonExistantDocKeyword,\n+    QueryInstability, TyQualified, TykindDiag, TykindKind, UntranslatableDiag,\n+};\n use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext};\n use rustc_ast as ast;\n-use rustc_errors::{fluent, Applicability};\n use rustc_hir::def::Res;\n use rustc_hir::{def_id::DefId, Expr, ExprKind, GenericArg, PatKind, Path, PathSegment, QPath};\n use rustc_hir::{HirId, Impl, Item, ItemKind, Node, Pat, Ty, TyKind};\n@@ -29,20 +34,15 @@ impl LateLintPass<'_> for DefaultHashTypes {\n             // don't lint imports, only actual usages\n             return;\n         }\n-        let replace = match cx.tcx.get_diagnostic_name(def_id) {\n+        let preferred = match cx.tcx.get_diagnostic_name(def_id) {\n             Some(sym::HashMap) => \"FxHashMap\",\n             Some(sym::HashSet) => \"FxHashSet\",\n             _ => return,\n         };\n-        cx.struct_span_lint(\n+        cx.emit_spanned_lint(\n             DEFAULT_HASH_TYPES,\n             path.span,\n-            fluent::lint_default_hash_types,\n-            |lint| {\n-                lint.set_arg(\"preferred\", replace)\n-                    .set_arg(\"used\", cx.tcx.item_name(def_id))\n-                    .note(fluent::note)\n-            },\n+            DefaultHashTypesDiag { preferred, used: cx.tcx.item_name(def_id) },\n         );\n     }\n }\n@@ -83,12 +83,11 @@ impl LateLintPass<'_> for QueryStability {\n         if let Ok(Some(instance)) = ty::Instance::resolve(cx.tcx, cx.param_env, def_id, substs) {\n             let def_id = instance.def_id();\n             if cx.tcx.has_attr(def_id, sym::rustc_lint_query_instability) {\n-                cx.struct_span_lint(\n+                cx.emit_spanned_lint(\n                     POTENTIAL_QUERY_INSTABILITY,\n                     span,\n-                    fluent::lint_query_instability,\n-                    |lint| lint.set_arg(\"query\", cx.tcx.item_name(def_id)).note(fluent::note),\n-                )\n+                    QueryInstability { query: cx.tcx.item_name(def_id) },\n+                );\n             }\n         }\n     }\n@@ -126,14 +125,8 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n             let span = path.span.with_hi(\n                 segment.args.map_or(segment.ident.span, |a| a.span_ext).hi()\n             );\n-            cx.struct_span_lint(USAGE_OF_TY_TYKIND, path.span, fluent::lint_tykind_kind, |lint| {\n-                lint\n-                    .span_suggestion(\n-                        span,\n-                        fluent::suggestion,\n-                        \"ty\",\n-                        Applicability::MaybeIncorrect, // ty maybe needs an import\n-                    )\n+            cx.emit_spanned_lint(USAGE_OF_TY_TYKIND, path.span, TykindKind {\n+                suggestion: span,\n             });\n         }\n     }\n@@ -190,39 +183,17 @@ impl<'tcx> LateLintPass<'tcx> for TyTyKind {\n \n                     match span {\n                         Some(span) => {\n-                            cx.struct_span_lint(\n-                                USAGE_OF_TY_TYKIND,\n-                                path.span,\n-                                fluent::lint_tykind_kind,\n-                                |lint| lint.span_suggestion(\n-                                    span,\n-                                    fluent::suggestion,\n-                                    \"ty\",\n-                                    Applicability::MaybeIncorrect, // ty maybe needs an import\n-                                )\n-                            )\n+                            cx.emit_spanned_lint(USAGE_OF_TY_TYKIND, path.span, TykindKind {\n+                                suggestion: span,\n+                            });\n                         },\n-                        None => cx.struct_span_lint(\n-                            USAGE_OF_TY_TYKIND,\n-                            path.span,\n-                            fluent::lint_tykind,\n-                            |lint| lint.help(fluent::help)\n-                        )\n-                    }\n-                } else if !ty.span.from_expansion() && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n-                    if path.segments.len() > 1 {\n-                        cx.struct_span_lint(USAGE_OF_QUALIFIED_TY, path.span, fluent::lint_ty_qualified, |lint| {\n-                            lint\n-                                .set_arg(\"ty\", t.clone())\n-                                .span_suggestion(\n-                                    path.span,\n-                                    fluent::suggestion,\n-                                    t,\n-                                    // The import probably needs to be changed\n-                                    Applicability::MaybeIncorrect,\n-                                )\n-                        })\n+                        None => cx.emit_spanned_lint(USAGE_OF_TY_TYKIND, path.span, TykindDiag),\n                     }\n+                } else if !ty.span.from_expansion() && path.segments.len() > 1 && let Some(t) = is_ty_or_ty_ctxt(cx, &path) {\n+                    cx.emit_spanned_lint(USAGE_OF_QUALIFIED_TY, path.span, TyQualified {\n+                        ty: t.clone(),\n+                        suggestion: path.span,\n+                    });\n                 }\n             }\n             _ => {}\n@@ -303,12 +274,11 @@ impl EarlyLintPass for LintPassImpl {\n                         && call_site.ctxt().outer_expn_data().kind\n                             != ExpnKind::Macro(MacroKind::Bang, sym::declare_lint_pass)\n                     {\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             LINT_PASS_IMPL_WITHOUT_MACRO,\n                             lint_pass.path.span,\n-                            fluent::lint_lintpass_by_hand,\n-                            |lint| lint.help(fluent::help),\n-                        )\n+                            LintPassByHand,\n+                        );\n                     }\n                 }\n             }\n@@ -338,17 +308,16 @@ impl<'tcx> LateLintPass<'tcx> for ExistingDocKeyword {\n             if let Some(list) = attr.meta_item_list() {\n                 for nested in list {\n                     if nested.has_name(sym::keyword) {\n-                        let v = nested\n+                        let keyword = nested\n                             .value_str()\n                             .expect(\"#[doc(keyword = \\\"...\\\")] expected a value!\");\n-                        if is_doc_keyword(v) {\n+                        if is_doc_keyword(keyword) {\n                             return;\n                         }\n-                        cx.struct_span_lint(\n+                        cx.emit_spanned_lint(\n                             EXISTING_DOC_KEYWORD,\n                             attr.span,\n-                            fluent::lint_non_existant_doc_keyword,\n-                            |lint| lint.set_arg(\"keyword\", v).help(fluent::help),\n+                            NonExistantDocKeyword { keyword },\n                         );\n                     }\n                 }\n@@ -407,12 +376,7 @@ impl LateLintPass<'_> for Diagnostics {\n         }\n         debug!(?found_impl);\n         if !found_parent_with_attr && !found_impl {\n-            cx.struct_span_lint(\n-                DIAGNOSTIC_OUTSIDE_OF_IMPL,\n-                span,\n-                fluent::lint_diag_out_of_impl,\n-                |lint| lint,\n-            )\n+            cx.emit_spanned_lint(DIAGNOSTIC_OUTSIDE_OF_IMPL, span, DiagOutOfImpl);\n         }\n \n         let mut found_diagnostic_message = false;\n@@ -428,12 +392,7 @@ impl LateLintPass<'_> for Diagnostics {\n         }\n         debug!(?found_diagnostic_message);\n         if !found_parent_with_attr && !found_diagnostic_message {\n-            cx.struct_span_lint(\n-                UNTRANSLATABLE_DIAGNOSTIC,\n-                span,\n-                fluent::lint_untranslatable_diag,\n-                |lint| lint,\n-            )\n+            cx.emit_spanned_lint(UNTRANSLATABLE_DIAGNOSTIC, span, UntranslatableDiag);\n         }\n     }\n }\n@@ -465,9 +424,9 @@ impl LateLintPass<'_> for BadOptAccess {\n                 let Some(lit) = item.lit()  &&\n                 let ast::LitKind::Str(val, _) = lit.kind\n             {\n-                cx.struct_span_lint(BAD_OPT_ACCESS, expr.span, val.as_str(), |lint|\n-                    lint\n-                );\n+                cx.emit_spanned_lint(BAD_OPT_ACCESS, expr.span, BadOptAccessDiag {\n+                    msg: val.as_str(),\n+                });\n             }\n         }\n     }"}, {"sha": "196922b78c30c35f331c77eb315684e3e554c767", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0b19227524622d953fbaefa272b36b0ef2fa263e/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b19227524622d953fbaefa272b36b0ef2fa263e/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=0b19227524622d953fbaefa272b36b0ef2fa263e", "patch": "@@ -49,6 +49,68 @@ pub struct EnumIntrinsicsMemVariant<'a> {\n     pub ty_param: Ty<'a>,\n }\n \n+// internal.rs\n+#[derive(LintDiagnostic)]\n+#[diag(lint_default_hash_types)]\n+#[note]\n+pub struct DefaultHashTypesDiag<'a> {\n+    pub preferred: &'a str,\n+    pub used: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_query_instability)]\n+#[note]\n+pub struct QueryInstability {\n+    pub query: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_tykind_kind)]\n+pub struct TykindKind {\n+    #[suggestion(code = \"ty\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_tykind)]\n+#[help]\n+pub struct TykindDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_ty_qualified)]\n+pub struct TyQualified {\n+    pub ty: String,\n+    #[suggestion(code = \"{ty}\", applicability = \"maybe-incorrect\")]\n+    pub suggestion: Span,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_lintpass_by_hand)]\n+#[help]\n+pub struct LintPassByHand;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_non_existant_doc_keyword)]\n+#[help]\n+pub struct NonExistantDocKeyword {\n+    pub keyword: Symbol,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_diag_out_of_impl)]\n+pub struct DiagOutOfImpl;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_untranslatable_diag)]\n+pub struct UntranslatableDiag;\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_bad_opt_access)]\n+pub struct BadOptAccessDiag<'a> {\n+    pub msg: &'a str,\n+}\n+\n // let_underscore.rs\n #[derive(LintDiagnostic)]\n pub enum NonBindingLet {"}]}