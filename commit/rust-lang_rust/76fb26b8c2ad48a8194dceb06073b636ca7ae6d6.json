{"sha": "76fb26b8c2ad48a8194dceb06073b636ca7ae6d6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZmIyNmI4YzJhZDQ4YTgxOTRkY2ViMDYwNzNiNjM2Y2E3YWU2ZDY=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2020-02-22T01:55:35Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2020-02-22T11:34:29Z"}, "message": "Add invalid argument spans to `GenericArgCountMismatch`", "tree": {"sha": "462fa1334b359b096a5915fe3c135afce8100bcd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/462fa1334b359b096a5915fe3c135afce8100bcd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6", "html_url": "https://github.com/rust-lang/rust/commit/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33143fd756f3765daa00809da2d1f66b5d3ac9fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/33143fd756f3765daa00809da2d1f66b5d3ac9fc", "html_url": "https://github.com/rust-lang/rust/commit/33143fd756f3765daa00809da2d1f66b5d3ac9fc"}], "stats": {"total": 84, "additions": 47, "deletions": 37}, "files": [{"sha": "25455ff629b3ba227733fd6cabc92d56881abf9a", "filename": "src/librustc_ast_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6/src%2Flibrustc_ast_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6/src%2Flibrustc_ast_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_passes%2Fast_validation.rs?ref=76fb26b8c2ad48a8194dceb06073b636ca7ae6d6", "patch": "@@ -8,7 +8,7 @@\n \n use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{error_code, struct_span_err, Applicability, FatalError};\n+use rustc_errors::{error_code, struct_span_err, Applicability};\n use rustc_parse::validate_attr;\n use rustc_session::lint::builtin::PATTERNS_IN_FNS_WITHOUT_BODY;\n use rustc_session::lint::LintBuffer;"}, {"sha": "9a80452aef3d2fd65438031c2b0faa7ea7fefd22", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=76fb26b8c2ad48a8194dceb06073b636ca7ae6d6", "patch": "@@ -134,8 +134,12 @@ enum GenericArgPosition {\n \n /// A marker denoting that the generic arguments that were\n /// provided did not match the respective generic parameters.\n-/// The field indicates whether a fatal error was reported (`Some`), or just a lint (`None`).\n-pub struct GenericArgCountMismatch(pub Option<ErrorReported>);\n+pub struct GenericArgCountMismatch {\n+    /// Indicates whether a fatal error was reported (`Some`), or just a lint (`None`).\n+    pub reported: Option<ErrorReported>,\n+    /// A list of spans of arguments provided that were not valid.\n+    pub invalid_args: Vec<Span>,\n+}\n \n impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     pub fn ast_region_to_region(\n@@ -279,7 +283,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             def.parent.is_none() && def.has_self, // `has_self`\n             seg.infer_args || suppress_mismatch,  // `infer_args`\n         )\n-        .0\n     }\n \n     /// Checks that the correct number of generic arguments have been provided.\n@@ -292,7 +295,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         position: GenericArgPosition,\n         has_self: bool,\n         infer_args: bool,\n-    ) -> (Result<(), GenericArgCountMismatch>, Vec<Span>) {\n+    ) -> Result<(), GenericArgCountMismatch> {\n         // At this stage we are guaranteed that the generic arguments are in the correct order, e.g.\n         // that lifetimes will proceed types. So it suffices to check the number of each generic\n         // arguments in order to validate them with respect to the generic parameters.\n@@ -328,12 +331,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 if position == GenericArgPosition::Value\n                     && arg_counts.lifetimes != param_counts.lifetimes\n                 {\n-                    explicit_lifetimes = Err(GenericArgCountMismatch(Some(ErrorReported)));\n+                    explicit_lifetimes = Err(true);\n                     let mut err = tcx.sess.struct_span_err(span, msg);\n                     err.span_note(span_late, note);\n                     err.emit();\n                 } else {\n-                    explicit_lifetimes = Err(GenericArgCountMismatch(None));\n+                    explicit_lifetimes = Err(false);\n                     let mut multispan = MultiSpan::from_span(span);\n                     multispan.push_span_label(span_late, note.to_string());\n                     tcx.struct_span_lint_hir(\n@@ -407,7 +410,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n                 err.emit();\n \n-                Err(GenericArgCountMismatch(Some(ErrorReported)))\n+                Err(true)\n             };\n \n         let mut arg_count_correct = explicit_lifetimes;\n@@ -416,40 +419,46 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if arg_count_correct.is_ok()\n             && (!infer_lifetimes || arg_counts.lifetimes > param_counts.lifetimes)\n         {\n-            arg_count_correct = arg_count_correct.and(check_kind_count(\n+            arg_count_correct = check_kind_count(\n                 \"lifetime\",\n                 param_counts.lifetimes,\n                 param_counts.lifetimes,\n                 arg_counts.lifetimes,\n                 0,\n                 &mut unexpected_spans,\n-            ));\n+            )\n+            .and(arg_count_correct);\n         }\n         // FIXME(const_generics:defaults)\n         if !infer_args || arg_counts.consts > param_counts.consts {\n-            arg_count_correct = arg_count_correct.and(check_kind_count(\n+            arg_count_correct = check_kind_count(\n                 \"const\",\n                 param_counts.consts,\n                 param_counts.consts,\n                 arg_counts.consts,\n                 arg_counts.lifetimes + arg_counts.types,\n                 &mut unexpected_spans,\n-            ));\n+            )\n+            .and(arg_count_correct);\n         }\n         // Note that type errors are currently be emitted *after* const errors.\n         if !infer_args || arg_counts.types > param_counts.types - defaults.types - has_self as usize\n         {\n-            arg_count_correct = arg_count_correct.and(check_kind_count(\n+            arg_count_correct = check_kind_count(\n                 \"type\",\n                 param_counts.types - defaults.types - has_self as usize,\n                 param_counts.types - has_self as usize,\n                 arg_counts.types,\n                 arg_counts.lifetimes,\n                 &mut unexpected_spans,\n-            ));\n+            )\n+            .and(arg_count_correct);\n         }\n \n-        (arg_count_correct, unexpected_spans)\n+        arg_count_correct.map_err(|reported_err| GenericArgCountMismatch {\n+            reported: if reported_err { Some(ErrorReported) } else { None },\n+            invalid_args: unexpected_spans,\n+        })\n     }\n \n     /// Report an error that a generic argument did not match the generic parameter that was\n@@ -501,7 +510,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n-        arg_count_correct: Result<(), GenericArgCountMismatch>,\n+        arg_count_correct: bool,\n         args_for_def_id: impl Fn(DefId) -> (Option<&'b GenericArgs<'b>>, bool),\n         provided_kind: impl Fn(&GenericParamDef, &GenericArg<'_>) -> subst::GenericArg<'tcx>,\n         mut inferred_kind: impl FnMut(\n@@ -595,7 +604,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 // another. This is an error. However, if we already know that\n                                 // the arguments don't match up with the parameters, we won't issue\n                                 // an additional error, as the user already knows what's wrong.\n-                                if arg_count_correct.is_ok() {\n+                                if arg_count_correct {\n                                     Self::generic_arg_mismatch_err(tcx.sess, arg, kind.descr());\n                                 }\n \n@@ -621,7 +630,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         //  2.  We've inferred some lifetimes, which have been provided later (i.e.\n                         //      after a type or const). We want to throw an error in this case.\n \n-                        if arg_count_correct.is_ok() {\n+                        if arg_count_correct {\n                             let kind = arg.descr();\n                             assert_eq!(kind, \"lifetime\");\n                             let provided =\n@@ -686,7 +695,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Vec<Span>) {\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Result<(), GenericArgCountMismatch>)\n+    {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n@@ -712,7 +722,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             assert!(self_ty.is_none() && parent_substs.is_empty());\n         }\n \n-        let (arg_count_correct, potential_assoc_types) = Self::check_generic_arg_count(\n+        let arg_count_correct = Self::check_generic_arg_count(\n             tcx,\n             span,\n             &generic_params,\n@@ -745,7 +755,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             parent_substs,\n             self_ty.is_some(),\n             self_ty,\n-            arg_count_correct,\n+            arg_count_correct.is_ok(),\n             // Provide the generic args, and whether types should be inferred.\n             |did| {\n                 if did == def_id {\n@@ -858,7 +868,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             generic_params, self_ty, substs\n         );\n \n-        (substs, assoc_bindings, potential_assoc_types)\n+        (substs, assoc_bindings, arg_count_correct)\n     }\n \n     crate fn create_substs_for_associated_item(\n@@ -989,7 +999,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n-    ) -> Vec<Span> {\n+    ) -> Result<(), GenericArgCountMismatch> {\n         let trait_def_id = trait_ref.trait_def_id();\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n@@ -1006,7 +1016,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         } else {\n             trait_ref.path.span\n         };\n-        let (substs, assoc_bindings, potential_assoc_types) = self.create_substs_for_ast_trait_ref(\n+        let (substs, assoc_bindings, arg_count_correct) = self.create_substs_for_ast_trait_ref(\n             path_span,\n             trait_def_id,\n             self_ty,\n@@ -1036,7 +1046,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             trait_ref, bounds, poly_trait_ref\n         );\n \n-        potential_assoc_types\n+        arg_count_correct\n     }\n \n     /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n@@ -1064,7 +1074,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         constness: Constness,\n         self_ty: Ty<'tcx>,\n         bounds: &mut Bounds<'tcx>,\n-    ) -> Vec<Span> {\n+    ) -> Result<(), GenericArgCountMismatch> {\n         self.instantiate_poly_trait_ref_inner(\n             &poly_trait_ref.trait_ref,\n             poly_trait_ref.span,\n@@ -1153,7 +1163,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Vec<Span>) {\n+    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, Result<(), GenericArgCountMismatch>)\n+    {\n         debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n \n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n@@ -1498,13 +1509,16 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut potential_assoc_types = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n         for trait_bound in trait_bounds.iter().rev() {\n-            let cur_potential_assoc_types = self.instantiate_poly_trait_ref(\n+            if let Err(GenericArgCountMismatch {\n+                invalid_args: cur_potential_assoc_types, ..\n+            }) = self.instantiate_poly_trait_ref(\n                 trait_bound,\n                 Constness::NotConst,\n                 dummy_self,\n                 &mut bounds,\n-            );\n-            potential_assoc_types.extend(cur_potential_assoc_types.into_iter());\n+            ) {\n+                potential_assoc_types.extend(cur_potential_assoc_types.into_iter());\n+            }\n         }\n \n         // Expand trait aliases recursively and check that only one regular (non-auto) trait"}, {"sha": "108affe5a86c0161fcff0f0f95a383e270e97afc", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=76fb26b8c2ad48a8194dceb06073b636ca7ae6d6", "patch": "@@ -313,7 +313,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             parent_substs,\n             false,\n             None,\n-            arg_count_correct,\n+            arg_count_correct.is_ok(),\n             // Provide the generic args, and whether types should be inferred.\n             |def_id| {\n                 // The last component of the returned tuple here is unimportant."}, {"sha": "3738afb2c3d7671b046fcf7485fd6f5b39f5cf1b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76fb26b8c2ad48a8194dceb06073b636ca7ae6d6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=76fb26b8c2ad48a8194dceb06073b636ca7ae6d6", "patch": "@@ -5452,7 +5452,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // parameter internally, but we don't allow users to specify the\n             // parameter's value explicitly, so we have to do some error-\n             // checking here.\n-            if let Err(GenericArgCountMismatch(Some(ErrorReported))) =\n+            if let Err(GenericArgCountMismatch { reported: Some(ErrorReported), .. }) =\n                 AstConv::check_generic_arg_count_for_call(\n                     tcx, span, &generics, &seg, false, // `is_method_call`\n                 )\n@@ -5521,11 +5521,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &[][..],\n                 has_self,\n                 self_ty,\n-                if infer_args_for_err.is_empty() {\n-                    Ok(())\n-                } else {\n-                    Err(GenericArgCountMismatch(Some(ErrorReported)))\n-                },\n+                infer_args_for_err.is_empty(),\n                 // Provide the generic args, and whether types should be inferred.\n                 |def_id| {\n                     if let Some(&PathSeg(_, index)) ="}]}