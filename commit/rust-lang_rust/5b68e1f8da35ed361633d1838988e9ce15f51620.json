{"sha": "5b68e1f8da35ed361633d1838988e9ce15f51620", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNjhlMWY4ZGEzNWVkMzYxNjMzZDE4Mzg5ODhlOWNlMTVmNTE2MjA=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-10-10T10:39:48Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-10-10T11:12:00Z"}, "message": "Add `Origin::Ast` arguments to all of the migrated AST-borrowck diagnostics.", "tree": {"sha": "da3e84e7fff052f250ac6faa5c206b0a2469d5a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da3e84e7fff052f250ac6faa5c206b0a2469d5a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b68e1f8da35ed361633d1838988e9ce15f51620", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b68e1f8da35ed361633d1838988e9ce15f51620", "html_url": "https://github.com/rust-lang/rust/commit/5b68e1f8da35ed361633d1838988e9ce15f51620", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b68e1f8da35ed361633d1838988e9ce15f51620/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf11ef436bb8883dce57213c27a73bc39870aa9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf11ef436bb8883dce57213c27a73bc39870aa9b", "html_url": "https://github.com/rust-lang/rust/commit/cf11ef436bb8883dce57213c27a73bc39870aa9b"}], "stats": {"total": 93, "additions": 58, "deletions": 35}, "files": [{"sha": "9fe272463ddd6fc7c4595c3110aed9e60fb801f8", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 18, "deletions": 10, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5b68e1f8da35ed361633d1838988e9ce15f51620/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b68e1f8da35ed361633d1838988e9ce15f51620/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5b68e1f8da35ed361633d1838988e9ce15f51620", "patch": "@@ -618,7 +618,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let mut err = self.cannot_act_on_moved_value(use_span,\n                                                              verb,\n                                                              msg,\n-                                                             &format!(\"{}\", nl));\n+                                                             &format!(\"{}\", nl),\n+                                                             Origin::Ast);\n                 let need_note = match lp.ty.sty {\n                     ty::TypeVariants::TyClosure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n@@ -698,7 +699,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             &self,\n             span: Span,\n             lp: &LoanPath<'tcx>) {\n-        self.cannot_partially_reinit_an_uninit_struct(span, &self.loan_path_to_string(lp))\n+        self.cannot_partially_reinit_an_uninit_struct(span,\n+                                                      &self.loan_path_to_string(lp),\n+                                                      Origin::Ast)\n             .emit();\n     }\n \n@@ -760,7 +763,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.cannot_assign(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::ClosureCapture(_)) => {\n-                        self.closure_cannot_assign_to_borrowed(error_span, &descr)\n+                        self.closure_cannot_assign_to_borrowed(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::OverloadedOperator) |\n                     BorrowViolation(euv::AddrOf) |\n@@ -769,7 +772,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     BorrowViolation(euv::AutoUnsafe) |\n                     BorrowViolation(euv::ForLoop) |\n                     BorrowViolation(euv::MatchDiscriminant) => {\n-                        self.cannot_borrow_path_as_mutable(error_span, &descr)\n+                        self.cannot_borrow_path_as_mutable(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n                         span_bug!(err.span,\n@@ -851,12 +854,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((yield_span, _)) = maybe_borrow_across_yield {\n                     debug!(\"err_out_of_scope: opt_yield_span = {:?}\", yield_span);\n-                    self.cannot_borrow_across_generator_yield(error_span, yield_span)\n+                    self.cannot_borrow_across_generator_yield(error_span, yield_span, Origin::Ast)\n                         .emit();\n                     return;\n                 }\n \n-                let mut db = self.path_does_not_live_long_enough(error_span, &msg);\n+                let mut db = self.path_does_not_live_long_enough(error_span, &msg, Origin::Ast);\n                 let (value_kind, value_msg) = match err.cmt.cat {\n                     mc::Categorization::Rvalue(..) =>\n                         (\"temporary value\", \"temporary value created here\"),\n@@ -965,7 +968,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = self.cmt_to_path_or_string(&err.cmt);\n-                let mut db = self.lifetime_too_short_for_reborrow(error_span, &descr);\n+                let mut db = self.lifetime_too_short_for_reborrow(error_span, &descr, Origin::Ast);\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n                         format!(\"`{}`\", self.loan_path_to_string(&lp))\n@@ -1050,10 +1053,14 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n                 let node_id = self.tcx.hir.def_index_to_node_id(id);\n                 let help_span = self.tcx.hir.span(node_id);\n-                self.cannot_act_on_capture_in_sharable_fn(span, prefix, (help_span, help_msg))\n+                self.cannot_act_on_capture_in_sharable_fn(span,\n+                                                          prefix,\n+                                                          (help_span, help_msg),\n+                                                          Origin::Ast)\n             }\n             _ =>  {\n-                self.cannot_assign_into_immutable_reference(span, prefix)\n+                self.cannot_assign_into_immutable_reference(span, prefix,\n+                                                            Origin::Ast)\n             }\n         };\n         self.note_immutability_blame(&mut err, blame);\n@@ -1207,7 +1214,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n         self.cannot_capture_in_long_lived_closure(err.span,\n                                                   &cmt_path_or_string,\n-                                                  capture_span)\n+                                                  capture_span,\n+                                                  Origin::Ast)\n             .span_suggestion(err.span,\n                              &format!(\"to force the closure to take ownership of {} \\\n                                        (and any other referenced variables), \\"}, {"sha": "216f6e4457096d28d6c51590c46840d579a57f36", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 40, "deletions": 25, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5b68e1f8da35ed361633d1838988e9ce15f51620/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b68e1f8da35ed361633d1838988e9ce15f51620/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=5b68e1f8da35ed361633d1838988e9ce15f51620", "patch": "@@ -299,115 +299,130 @@ pub trait BorrowckErrors {\n                                  use_span: Span,\n                                  verb: &str,\n                                  optional_adverb_for_moved: &str,\n-                                 moved_path: &str)\n+                                 moved_path: &str,\n+                                 o: Origin)\n                                  -> DiagnosticBuilder\n     {\n         let err = struct_span_err!(self, use_span, E0382,\n-                                   \"{} of {}moved value: `{}`\",\n-                                   verb, optional_adverb_for_moved, moved_path);\n+                                   \"{} of {}moved value: `{}`{OGN}\",\n+                                   verb, optional_adverb_for_moved, moved_path, OGN=o);\n         err\n     }\n \n     fn cannot_partially_reinit_an_uninit_struct(&self,\n                                                 span: Span,\n-                                                uninit_path: &str)\n+                                                uninit_path: &str,\n+                                                o: Origin)\n                                                 -> DiagnosticBuilder\n     {\n         let err = struct_span_err!(self,\n                                    span,\n                                    E0383,\n-                                   \"partial reinitialization of uninitialized structure `{}`\",\n-                                   uninit_path);\n+                                   \"partial reinitialization of uninitialized structure `{}`{OGN}\",\n+                                   uninit_path, OGN=o);\n         err\n     }\n \n     fn closure_cannot_assign_to_borrowed(&self,\n                                          span: Span,\n-                                         descr: &str)\n+                                         descr: &str,\n+                                         o: Origin)\n                                          -> DiagnosticBuilder\n     {\n-        let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}\", descr);\n+        let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}{OGN}\",\n+                                   descr, OGN=o);\n         err\n     }\n \n     fn cannot_borrow_path_as_mutable(&self,\n                                      span: Span,\n-                                     path: &str)\n+                                     path: &str,\n+                                     o: Origin)\n                                      -> DiagnosticBuilder\n     {\n-        let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable\", path);\n+        let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable{OGN}\",\n+                                   path, OGN=o);\n         err\n     }\n \n     fn cannot_borrow_across_generator_yield(&self,\n                                             span: Span,\n-                                            yield_span: Span)\n+                                            yield_span: Span,\n+                                            o: Origin)\n                                             -> DiagnosticBuilder\n     {\n         let mut err = struct_span_err!(self,\n                                        span,\n                                        E0626,\n-                                       \"borrow may still be in use when generator yields\");\n+                                       \"borrow may still be in use when generator yields{OGN}\",\n+                                       OGN=o);\n         err.span_label(yield_span, \"possible yield occurs here\");\n         err\n     }\n \n     fn path_does_not_live_long_enough(&self,\n                                       span: Span,\n-                                      path: &str)\n+                                      path: &str,\n+                                      o: Origin)\n                                       -> DiagnosticBuilder\n     {\n-        let err = struct_span_err!(self, span, E0597, \"{} does not live long enough\", path);\n+        let err = struct_span_err!(self, span, E0597, \"{} does not live long enough{OGN}\",\n+                                   path, OGN=o);\n         err\n     }\n \n     fn lifetime_too_short_for_reborrow(&self,\n                                        span: Span,\n-                                       path: &str)\n+                                       path: &str,\n+                                       o: Origin)\n                                        -> DiagnosticBuilder\n     {\n         let err = struct_span_err!(self, span, E0598,\n                                    \"lifetime of {} is too short to guarantee \\\n-                                    its contents can be safely reborrowed\",\n-                                   path);\n+                                    its contents can be safely reborrowed{OGN}\",\n+                                   path, OGN=o);\n         err\n     }\n \n     fn cannot_act_on_capture_in_sharable_fn(&self,\n                                             span: Span,\n                                             bad_thing: &str,\n-                                            help: (Span, &str))\n+                                            help: (Span, &str),\n+                                            o: Origin)\n                                             -> DiagnosticBuilder\n     {\n         let (help_span, help_msg) = help;\n         let mut err = struct_span_err!(self, span, E0387,\n-                                       \"{} in a captured outer variable in an `Fn` closure\",\n-                                       bad_thing);\n+                                       \"{} in a captured outer variable in an `Fn` closure{OGN}\",\n+                                       bad_thing, OGN=o);\n         err.span_help(help_span, help_msg);\n         err\n     }\n \n     fn cannot_assign_into_immutable_reference(&self,\n                                               span: Span,\n-                                              bad_thing: &str)\n+                                              bad_thing: &str,\n+                                              o: Origin)\n                                               -> DiagnosticBuilder\n     {\n-        let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference\", bad_thing);\n+        let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference{OGN}\",\n+                                       bad_thing, OGN=o);\n         err.span_label(span, \"assignment into an immutable reference\");\n         err\n     }\n \n     fn cannot_capture_in_long_lived_closure(&self,\n                                             closure_span: Span,\n                                             borrowed_path: &str,\n-                                            capture_span: Span)\n+                                            capture_span: Span,\n+                                            o: Origin)\n                                             -> DiagnosticBuilder\n     {\n         let mut err = struct_span_err!(self, closure_span, E0373,\n                                        \"closure may outlive the current function, \\\n                                         but it borrows {}, \\\n-                                        which is owned by the current function\",\n-                                       borrowed_path);\n+                                        which is owned by the current function{OGN}\",\n+                                       borrowed_path, OGN=o);\n         err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n             .span_label(closure_span, format!(\"may outlive borrowed value {}\", borrowed_path));\n         err"}]}