{"sha": "7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3MjM1NTBmZGQ3ZmUyOWJlZTlkY2JkNDViZGVmNGYyMDlhN2UxZjE=", "commit": {"author": {"name": "Barosl Lee", "email": "vcs@barosl.com", "date": "2015-08-19T04:11:40Z"}, "committer": {"name": "Barosl Lee", "email": "vcs@barosl.com", "date": "2015-08-27T19:46:55Z"}, "message": "Reduce the reliance on `PATH_MAX`\n\n- Rewrite `std::sys::fs::readlink` not to rely on `PATH_MAX`\n\nIt currently has the following problems:\n\n1. It uses `_PC_NAME_MAX` to query the maximum length of a file path in\nthe underlying system. However, the meaning of the constant is the\nmaximum length of *a path component*, not a full path. The correct\nconstant should be `_PC_PATH_MAX`.\n\n2. `pathconf` *may* fail if the referred file does not exist. This can\nbe problematic if the file which the symbolic link points to does not\nexist, but the link itself does exist. In this case, the current\nimplementation resorts to the hard-coded value of `1024`, which is not\nideal.\n\n3. There may exist a platform where there is no limit on file path\nlengths in general. That's the reaon why GNU Hurd doesn't define\n`PATH_MAX` at all, in addition to having `pathconf` always returning\n`-1`. In these platforms, the content of the symbolic link can be\nsilently truncated if the length exceeds the hard-coded limit mentioned\nabove.\n\n4. The value obtained by `pathconf` may be outdated at the point of\nactually calling `readlink`. This is inherently racy.\n\nThis commit introduces a loop that gradually increases the length of the\nbuffer passed to `readlink`, eliminating the need of `pathconf`.\n\n- Remove the arbitrary memory limit of `std::sys::fs::realpath`\n\nAs per POSIX 2013, `realpath` will return a malloc'ed buffer if the\nsecond argument is a null pointer.[1]\n\n[1] http://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html\n\n- Comment on functions that are still using `PATH_MAX`\n\nThere are some functions that only work in terms of `PATH_MAX`, such as\n`F_GETPATH` in OS X. Comments on them for posterity.", "tree": {"sha": "438faf68363ac8833f52c8e4e049de7998253318", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/438faf68363ac8833f52c8e4e049de7998253318"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1", "html_url": "https://github.com/rust-lang/rust/commit/7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1/comments", "author": {"login": "barosl", "id": 573768, "node_id": "MDQ6VXNlcjU3Mzc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/573768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/barosl", "html_url": "https://github.com/barosl", "followers_url": "https://api.github.com/users/barosl/followers", "following_url": "https://api.github.com/users/barosl/following{/other_user}", "gists_url": "https://api.github.com/users/barosl/gists{/gist_id}", "starred_url": "https://api.github.com/users/barosl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/barosl/subscriptions", "organizations_url": "https://api.github.com/users/barosl/orgs", "repos_url": "https://api.github.com/users/barosl/repos", "events_url": "https://api.github.com/users/barosl/events{/privacy}", "received_events_url": "https://api.github.com/users/barosl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "barosl", "id": 573768, "node_id": "MDQ6VXNlcjU3Mzc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/573768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/barosl", "html_url": "https://github.com/barosl", "followers_url": "https://api.github.com/users/barosl/followers", "following_url": "https://api.github.com/users/barosl/following{/other_user}", "gists_url": "https://api.github.com/users/barosl/gists{/gist_id}", "starred_url": "https://api.github.com/users/barosl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/barosl/subscriptions", "organizations_url": "https://api.github.com/users/barosl/orgs", "repos_url": "https://api.github.com/users/barosl/repos", "events_url": "https://api.github.com/users/barosl/events{/privacy}", "received_events_url": "https://api.github.com/users/barosl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ff44ff8faabb7e0545dfefa96b0d601f0f17b94", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff44ff8faabb7e0545dfefa96b0d601f0f17b94", "html_url": "https://github.com/rust-lang/rust/commit/4ff44ff8faabb7e0545dfefa96b0d601f0f17b94"}], "stats": {"total": 51, "additions": 35, "deletions": 16}, "files": [{"sha": "0eebe5af9197dc07601845769e924ef1071f60e4", "filename": "src/libstd/sys/unix/fs.rs", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1/src%2Flibstd%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs.rs?ref=7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1", "patch": "@@ -376,13 +376,19 @@ impl fmt::Debug for File {\n \n         #[cfg(target_os = \"macos\")]\n         fn get_path(fd: c_int) -> Option<PathBuf> {\n+            // FIXME: The use of PATH_MAX is generally not encouraged, but it\n+            // is inevitable in this case because OS X defines `fcntl` with\n+            // `F_GETPATH` in terms of `MAXPATHLEN`, and there are no\n+            // alternatives. If a better method is invented, it should be used\n+            // instead.\n             let mut buf = vec![0;libc::PATH_MAX as usize];\n             let n = unsafe { libc::fcntl(fd, libc::F_GETPATH, buf.as_ptr()) };\n             if n == -1 {\n                 return None;\n             }\n             let l = buf.iter().position(|&c| c == 0).unwrap();\n             buf.truncate(l as usize);\n+            buf.shrink_to_fit();\n             Some(PathBuf::from(OsString::from_vec(buf)))\n         }\n \n@@ -466,18 +472,27 @@ pub fn rmdir(p: &Path) -> io::Result<()> {\n pub fn readlink(p: &Path) -> io::Result<PathBuf> {\n     let c_path = try!(cstr(p));\n     let p = c_path.as_ptr();\n-    let mut len = unsafe { libc::pathconf(p as *mut _, libc::_PC_NAME_MAX) };\n-    if len < 0 {\n-        len = 1024; // FIXME: read PATH_MAX from C ffi?\n-    }\n-    let mut buf: Vec<u8> = Vec::with_capacity(len as usize);\n-    unsafe {\n-        let n = try!(cvt({\n-            libc::readlink(p, buf.as_ptr() as *mut c_char, len as size_t)\n-        }));\n-        buf.set_len(n as usize);\n+\n+    let mut buf = Vec::with_capacity(256);\n+\n+    loop {\n+        let buf_read = try!(cvt(unsafe {\n+            libc::readlink(p, buf.as_mut_ptr() as *mut _, buf.capacity() as libc::size_t)\n+        })) as usize;\n+\n+        unsafe { buf.set_len(buf_read); }\n+\n+        if buf_read != buf.capacity() {\n+            buf.shrink_to_fit();\n+\n+            return Ok(PathBuf::from(OsString::from_vec(buf)));\n+        }\n+\n+        // Trigger the internal buffer resizing logic of `Vec` by requiring\n+        // more space than the current capacity. The length is guaranteed to be\n+        // the same as the capacity due to the if statement above.\n+        buf.reserve(1);\n     }\n-    Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n \n pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n@@ -514,15 +529,15 @@ pub fn lstat(p: &Path) -> io::Result<FileAttr> {\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n     let path = try!(CString::new(p.as_os_str().as_bytes()));\n-    let mut buf = vec![0u8; 16 * 1024];\n+    let buf;\n     unsafe {\n-        let r = c::realpath(path.as_ptr(), buf.as_mut_ptr() as *mut _);\n+        let r = c::realpath(path.as_ptr(), ptr::null_mut());\n         if r.is_null() {\n             return Err(io::Error::last_os_error())\n         }\n+        buf = CStr::from_ptr(r).to_bytes().to_vec();\n+        libc::free(r as *mut _);\n     }\n-    let p = buf.iter().position(|i| *i == 0).unwrap();\n-    buf.truncate(p);\n     Ok(PathBuf::from(OsString::from_vec(buf)))\n }\n "}, {"sha": "37ce30d7066f77801da733c2cc37bae7f85489e2", "filename": "src/rt/rust_builtin.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1/src%2Frt%2Frust_builtin.c", "raw_url": "https://github.com/rust-lang/rust/raw/7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1/src%2Frt%2Frust_builtin.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.c?ref=7723550fdd7fe29bee9dcbd45bdef4f209a7e1f1", "patch": "@@ -341,7 +341,11 @@ const char * rust_current_exe()\n   char **paths;\n   size_t sz;\n   int i;\n-  char buf[2*PATH_MAX], exe[2*PATH_MAX];\n+  /* If `PATH_MAX` is defined on the platform, `realpath` will truncate the\n+   * resolved path up to `PATH_MAX`. While this can make the resolution fail if\n+   * the executable is placed in a deep path, the usage of a buffer whose\n+   * length depends on `PATH_MAX` is still memory safe. */\n+  char buf[2*PATH_MAX], exe[PATH_MAX];\n \n   if (self != NULL)\n     return self;"}]}