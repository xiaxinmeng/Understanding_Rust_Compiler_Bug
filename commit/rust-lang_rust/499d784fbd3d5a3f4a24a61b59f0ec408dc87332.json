{"sha": "499d784fbd3d5a3f4a24a61b59f0ec408dc87332", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5OWQ3ODRmYmQzZDVhM2Y0YTI0YTYxYjU5ZjBlYzQwOGRjODczMzI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-29T07:37:29Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-03-29T17:32:12Z"}, "message": "amortize dfs storage creation", "tree": {"sha": "e417dc3b5e71f27cc65091e5bc106699e1fe85af", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e417dc3b5e71f27cc65091e5bc106699e1fe85af"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/499d784fbd3d5a3f4a24a61b59f0ec408dc87332", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/499d784fbd3d5a3f4a24a61b59f0ec408dc87332", "html_url": "https://github.com/rust-lang/rust/commit/499d784fbd3d5a3f4a24a61b59f0ec408dc87332", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/499d784fbd3d5a3f4a24a61b59f0ec408dc87332/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "96f3e560d91efe5cf6301abb37a1424b05f9dc0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/96f3e560d91efe5cf6301abb37a1424b05f9dc0a", "html_url": "https://github.com/rust-lang/rust/commit/96f3e560d91efe5cf6301abb37a1424b05f9dc0a"}], "stats": {"total": 96, "additions": 65, "deletions": 31}, "files": [{"sha": "4fcd3118f91081db6587ef0e63fd4dbb382c7e02", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dfs.rs", "status": "modified", "additions": 41, "deletions": 20, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/499d784fbd3d5a3f4a24a61b59f0ec408dc87332/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/499d784fbd3d5a3f4a24a61b59f0ec408dc87332/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdfs.rs?ref=499d784fbd3d5a3f4a24a61b59f0ec408dc87332", "patch": "@@ -18,9 +18,26 @@ use borrow_check::nll::region_infer::values::{RegionElementIndex, RegionValueEle\n use syntax::codemap::Span;\n use rustc::mir::{Location, Mir};\n use rustc::ty::RegionVid;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::bitvec::BitVector;\n+use rustc_data_structures::indexed_vec::Idx;\n+\n+pub(super) struct DfsStorage {\n+    stack: Vec<Location>,\n+    visited: BitVector,\n+}\n \n impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Creates dfs storage for use by dfs; this should be shared\n+    /// across as many calls to dfs as possible to amortize allocation\n+    /// costs.\n+    pub(super) fn new_dfs_storage(&self) -> DfsStorage {\n+        let num_elements = self.elements.num_elements();\n+        DfsStorage {\n+            stack: vec![],\n+            visited: BitVector::new(num_elements),\n+        }\n+    }\n+\n     /// Function used to satisfy or test a `R1: R2 @ P`\n     /// constraint. The core idea is that it performs a DFS starting\n     /// from `P`. The precise actions *during* that DFS depend on the\n@@ -35,25 +52,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// - `Err(early)` if the walk was existed early by `op`. `earlyelem` is the\n     ///   value that `op` returned.\n     #[inline(never)] // ensure dfs is identifiable in profiles\n-    pub(super) fn dfs<C>(&self, mir: &Mir<'tcx>, mut op: C) -> Result<bool, C::Early>\n+    pub(super) fn dfs<C>(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        dfs: &mut DfsStorage,\n+        mut op: C,\n+    ) -> Result<bool, C::Early>\n     where\n         C: DfsOp,\n     {\n         let mut changed = false;\n \n-        let mut stack = vec![];\n-        let mut visited = FxHashSet();\n-\n-        stack.push(op.start_point());\n-        while let Some(p) = stack.pop() {\n+        dfs.visited.clear();\n+        dfs.stack.push(op.start_point());\n+        while let Some(p) = dfs.stack.pop() {\n             let point_index = self.elements.index(p);\n \n             if !op.source_region_contains(point_index) {\n                 debug!(\"            not in from-region\");\n                 continue;\n             }\n \n-            if !visited.insert(p) {\n+            if !dfs.visited.insert(point_index.index()) {\n                 debug!(\"            already visited\");\n                 continue;\n             }\n@@ -63,25 +83,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             let block_data = &mir[p.block];\n \n-            let start_stack_len = stack.len();\n+            let start_stack_len = dfs.stack.len();\n \n             if p.statement_index < block_data.statements.len() {\n-                stack.push(Location {\n+                dfs.stack.push(Location {\n                     statement_index: p.statement_index + 1,\n                     ..p\n                 });\n             } else {\n-                stack.extend(block_data.terminator().successors().iter().map(\n-                    |&basic_block| {\n-                        Location {\n+                dfs.stack.extend(\n+                    block_data\n+                        .terminator()\n+                        .successors()\n+                        .iter()\n+                        .map(|&basic_block| Location {\n                             statement_index: 0,\n                             block: basic_block,\n-                        }\n-                    },\n-                ));\n+                        }),\n+                );\n             }\n \n-            if stack.len() == start_stack_len {\n+            if dfs.stack.len() == start_stack_len {\n                 // If we reach the END point in the graph, then copy\n                 // over any skolemized end points in the `from_region`\n                 // and make sure they are included in the `to_region`.\n@@ -230,9 +252,8 @@ impl<'v, 'tcx> DfsOp for TestTargetOutlivesSource<'v, 'tcx> {\n             // `X: ur_in_source`, OK.\n             if self.inferred_values\n                 .universal_regions_outlived_by(self.target_region)\n-                .any(|ur_in_target| {\n-                    self.universal_regions.outlives(ur_in_target, ur_in_source)\n-                }) {\n+                .any(|ur_in_target| self.universal_regions.outlives(ur_in_target, ur_in_source))\n+            {\n                 continue;\n             }\n "}, {"sha": "f80184a22fdc69c7f1999a51fc8303bd5a41dbfe", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/499d784fbd3d5a3f4a24a61b59f0ec408dc87332/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/499d784fbd3d5a3f4a24a61b59f0ec408dc87332/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=499d784fbd3d5a3f4a24a61b59f0ec408dc87332", "patch": "@@ -436,7 +436,9 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     ) -> Option<ClosureRegionRequirements<'gcx>> {\n         assert!(self.inferred_values.is_none(), \"values already inferred\");\n \n-        self.propagate_constraints(mir);\n+        let dfs_storage = &mut self.new_dfs_storage();\n+\n+        self.propagate_constraints(mir, dfs_storage);\n \n         // If this is a closure, we can propagate unsatisfied\n         // `outlives_requirements` to our creator, so create a vector\n@@ -449,7 +451,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             None\n         };\n \n-        self.check_type_tests(infcx, mir, mir_def_id, outlives_requirements.as_mut());\n+        self.check_type_tests(infcx, mir, dfs_storage, mir_def_id, outlives_requirements.as_mut());\n \n         self.check_universal_regions(infcx, mir_def_id, outlives_requirements.as_mut());\n \n@@ -469,22 +471,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// Re-execute the region inference, this time tracking causal information.\n     /// This is significantly slower, so it is done only when an error is being reported.\n     pub(super) fn compute_causal_info(&self, mir: &Mir<'tcx>) -> RegionCausalInfo {\n-        let inferred_values = self.compute_region_values(mir, TrackCauses(true));\n+        let dfs_storage = &mut self.new_dfs_storage();\n+        let inferred_values = self.compute_region_values(mir, dfs_storage, TrackCauses(true));\n         RegionCausalInfo { inferred_values }\n     }\n \n     /// Propagate the region constraints: this will grow the values\n     /// for each region variable until all the constraints are\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n+    fn propagate_constraints(&mut self, mir: &Mir<'tcx>, dfs_storage: &mut dfs::DfsStorage) {\n         self.dependency_map = Some(self.build_dependency_map());\n-        let inferred_values = self.compute_region_values(mir, TrackCauses(false));\n+        let inferred_values = self.compute_region_values(mir, dfs_storage, TrackCauses(false));\n         self.inferred_values = Some(inferred_values);\n     }\n \n     #[inline(never)] // ensure dfs is identifiable in profiles\n-    fn compute_region_values(&self, mir: &Mir<'tcx>, track_causes: TrackCauses) -> RegionValues {\n+    fn compute_region_values(\n+        &self,\n+        mir: &Mir<'tcx>,\n+        dfs_storage: &mut dfs::DfsStorage,\n+        track_causes: TrackCauses,\n+    ) -> RegionValues {\n         debug!(\"compute_region_values()\");\n         debug!(\"compute_region_values: constraints={:#?}\", {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n@@ -515,6 +523,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             // outlives constraint.\n             let Ok(made_changes) = self.dfs(\n                 mir,\n+                dfs_storage,\n                 CopyFromSourceToTarget {\n                     source_region: constraint.sub,\n                     target_region: constraint.sup,\n@@ -569,6 +578,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, 'gcx, 'tcx>,\n         mir: &Mir<'tcx>,\n+        dfs_storage: &mut dfs::DfsStorage,\n         mir_def_id: DefId,\n         mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement<'gcx>>>,\n     ) {\n@@ -577,7 +587,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n-            if self.eval_region_test(mir, type_test.point, type_test.lower_bound, &type_test.test) {\n+            if self.eval_region_test(mir, dfs_storage, type_test.point, type_test.lower_bound, &type_test.test) {\n                 continue;\n             }\n \n@@ -834,6 +844,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn eval_region_test(\n         &self,\n         mir: &Mir<'tcx>,\n+        dfs_storage: &mut dfs::DfsStorage,\n         point: Location,\n         lower_bound: RegionVid,\n         test: &RegionTest,\n@@ -846,26 +857,27 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         match test {\n             RegionTest::IsOutlivedByAllRegionsIn(regions) => regions\n                 .iter()\n-                .all(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n+                .all(|&r| self.eval_outlives(mir, dfs_storage, r, lower_bound, point)),\n \n             RegionTest::IsOutlivedByAnyRegionIn(regions) => regions\n                 .iter()\n-                .any(|&r| self.eval_outlives(mir, r, lower_bound, point)),\n+                .any(|&r| self.eval_outlives(mir, dfs_storage, r, lower_bound, point)),\n \n             RegionTest::Any(tests) => tests\n                 .iter()\n-                .any(|test| self.eval_region_test(mir, point, lower_bound, test)),\n+                .any(|test| self.eval_region_test(mir, dfs_storage, point, lower_bound, test)),\n \n             RegionTest::All(tests) => tests\n                 .iter()\n-                .all(|test| self.eval_region_test(mir, point, lower_bound, test)),\n+                .all(|test| self.eval_region_test(mir, dfs_storage, point, lower_bound, test)),\n         }\n     }\n \n     // Evaluate whether `sup_region: sub_region @ point`.\n     fn eval_outlives(\n         &self,\n         mir: &Mir<'tcx>,\n+        dfs_storage: &mut dfs::DfsStorage,\n         sup_region: RegionVid,\n         sub_region: RegionVid,\n         point: Location,\n@@ -881,6 +893,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // yield an `Err` result.\n         match self.dfs(\n             mir,\n+            dfs_storage,\n             TestTargetOutlivesSource {\n                 source_region: sub_region,\n                 target_region: sup_region,"}]}