{"sha": "9c81889ad258c34635532dc7017d1c2b831230b8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljODE4ODlhZDI1OGMzNDYzNTUzMmRjNzAxN2QxYzJiODMxMjMwYjg=", "commit": {"author": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-07-21T01:03:09Z"}, "committer": {"name": "Roy Frostig", "email": "rfrostig@mozilla.com", "date": "2010-07-21T01:03:09Z"}, "message": "Add a (coarse, first-pass) deque implementation to stdlib.", "tree": {"sha": "bc1490ad4d785b4e18219622558bc607740466d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc1490ad4d785b4e18219622558bc607740466d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9c81889ad258c34635532dc7017d1c2b831230b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9c81889ad258c34635532dc7017d1c2b831230b8", "html_url": "https://github.com/rust-lang/rust/commit/9c81889ad258c34635532dc7017d1c2b831230b8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9c81889ad258c34635532dc7017d1c2b831230b8/comments", "author": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "committer": {"login": "froystig", "id": 123903, "node_id": "MDQ6VXNlcjEyMzkwMw==", "avatar_url": "https://avatars.githubusercontent.com/u/123903?v=4", "gravatar_id": "", "url": "https://api.github.com/users/froystig", "html_url": "https://github.com/froystig", "followers_url": "https://api.github.com/users/froystig/followers", "following_url": "https://api.github.com/users/froystig/following{/other_user}", "gists_url": "https://api.github.com/users/froystig/gists{/gist_id}", "starred_url": "https://api.github.com/users/froystig/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/froystig/subscriptions", "organizations_url": "https://api.github.com/users/froystig/orgs", "repos_url": "https://api.github.com/users/froystig/repos", "events_url": "https://api.github.com/users/froystig/events{/privacy}", "received_events_url": "https://api.github.com/users/froystig/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf3528342a932dd0d523d259ca71b94431703ba9", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf3528342a932dd0d523d259ca71b94431703ba9", "html_url": "https://github.com/rust-lang/rust/commit/bf3528342a932dd0d523d259ca71b94431703ba9"}], "stats": {"total": 162, "additions": 155, "deletions": 7}, "files": [{"sha": "b6399669c43ad2ee2f6399ad7444b48bc9ad1d5e", "filename": "src/lib/_int.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9c81889ad258c34635532dc7017d1c2b831230b8/src%2Flib%2F_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c81889ad258c34635532dc7017d1c2b831230b8/src%2Flib%2F_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_int.rs?ref=9c81889ad258c34635532dc7017d1c2b831230b8", "patch": "@@ -1,3 +1,5 @@\n+import std.sys;\n+\n fn add(int x, int y) -> int { ret x + y; }\n fn sub(int x, int y) -> int { ret x - y; }\n fn mul(int x, int y) -> int { ret x * y; }\n@@ -24,3 +26,16 @@ iter urange(mutable uint lo, uint hi) -> uint {\n     lo += uint(1);\n   }\n }\n+\n+fn next_power_of_two(uint n) -> uint {\n+  // FIXME change |* uint(4)| below to |* uint(8) / uint(2)| and watch the\n+  // world explode.\n+  let uint halfbits = sys.rustrt.size_of[uint]() * uint(4);\n+  let uint tmp = n - uint(1);\n+  let uint shift = uint(1);\n+  while (shift <= halfbits) {\n+    tmp |= tmp >> shift;\n+    shift <<= uint(1);\n+  }\n+  ret tmp + uint(1);\n+}"}, {"sha": "b41c051f5fc961f565b312ab18d275ec357b1b9a", "filename": "src/lib/deque.rs", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/9c81889ad258c34635532dc7017d1c2b831230b8/src%2Flib%2Fdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c81889ad258c34635532dc7017d1c2b831230b8/src%2Flib%2Fdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fdeque.rs?ref=9c81889ad258c34635532dc7017d1c2b831230b8", "patch": "@@ -0,0 +1,137 @@\n+/**\n+ * A deque, for fun.  Untested as of yet.  Likely buggy.\n+ */\n+\n+import std.util;\n+import std._vec;\n+import std._int;\n+\n+type t[T] = obj {\n+  fn size() -> uint;\n+\n+  fn add_front(&T t);\n+  fn add_back(&T t);\n+\n+  fn pop_front() -> T;\n+  fn pop_back() -> T;\n+\n+  fn peek_front() -> T;\n+  fn peek_back() -> T;\n+};\n+\n+fn create[T]() -> t[T] {\n+\n+  type cell[T] = mutable util.option[T];\n+\n+  let uint initial_capacity = uint(32); // 2^5\n+\n+  /**\n+   * Grow is only called on full elts, so nelts is also len(elts), unlike\n+   * elsewhere.\n+   */\n+  fn grow[T](uint nelts, uint lo, vec[cell[T]] elts) -> vec[cell[T]] {\n+    check (nelts == _vec.len[cell[T]](elts));\n+\n+    fn fill[T](uint i, uint nelts, uint lo, &vec[cell[T]] old) -> cell[T] {\n+      if (i < nelts) {\n+        ret old.(int((lo + i) % nelts));\n+      } else {\n+        ret util.none[T]();\n+      }\n+    }\n+\n+    let uint nalloc = _int.next_power_of_two(nelts + uint(1));\n+    let _vec.init_op[cell[T]] copy_op = bind fill[T](_, nelts, lo, elts);\n+    ret _vec.init_fn[cell[T]](copy_op, nalloc);\n+  }\n+\n+  /**\n+   * FIXME (issue #94): We're converting to int every time we index into the\n+   * vec, but we really want to index with the lo and hi uints that we have\n+   * around.\n+   */\n+\n+  fn get[T](&vec[cell[T]] elts, uint i) -> T {\n+    alt (elts.(int(i))) {\n+      case (util.some[T](t)) { ret t; }\n+      case (_) { fail; }\n+    }\n+  }\n+\n+  obj deque[T](mutable uint nelts,\n+               mutable uint lo,\n+               mutable uint hi,\n+               mutable vec[cell[T]] elts)\n+  {\n+    fn size() -> uint { ret nelts; }\n+\n+    fn add_front(&T t) {\n+      let uint oldlo = lo;\n+\n+      if (lo == uint(0)) {\n+        lo = _vec.len[cell[T]](elts) - uint(1);\n+      } else {\n+        lo -= uint(1);\n+      }\n+\n+      if (lo == hi) {\n+        elts = grow[T](nelts, oldlo, elts);\n+        lo = _vec.len[cell[T]](elts) - uint(1);\n+        hi = nelts - uint(1);\n+      }\n+\n+      elts.(int(lo)) = util.some[T](t);\n+      nelts += uint(1);\n+    }\n+\n+    fn add_back(&T t) {\n+      hi = (hi + uint(1)) % _vec.len[cell[T]](elts);\n+\n+      if (lo == hi) {\n+        elts = grow[T](nelts, lo, elts);\n+        lo = uint(0);\n+        hi = nelts;\n+      }\n+\n+      elts.(int(hi)) = util.some[T](t);\n+      nelts += uint(1);\n+    }\n+\n+    /**\n+     * We actually release (turn to none()) the T we're popping so that we\n+     * don't keep anyone's refcount up unexpectedly.\n+     */\n+    fn pop_front() -> T {\n+      let T t = get[T](elts, lo);\n+      elts.(int(lo)) = util.none[T]();\n+      lo = (lo + uint(1)) % _vec.len[cell[T]](elts);\n+      ret t;\n+    }\n+\n+    fn pop_back() -> T {\n+      let T t = get[T](elts, hi);\n+      elts.(int(hi)) = util.none[T]();\n+\n+      if (hi == uint(0)) {\n+        hi = _vec.len[cell[T]](elts) - uint(1);\n+      } else {\n+        hi -= uint(1);\n+      }\n+\n+      ret t;\n+    }\n+\n+    fn peek_front() -> T {\n+      ret get[T](elts, lo);\n+    }\n+\n+    fn peek_back() -> T {\n+      ret get[T](elts, hi);\n+    }\n+  }\n+\n+  let vec[cell[T]] v = _vec.init_elt[cell[T]](util.none[T](),\n+                                              initial_capacity);\n+\n+  ret deque[T](uint(0), uint(0), uint(0), v);\n+}"}, {"sha": "06139bb7c9bac684f64d7ed6fbe9777b2ef300d2", "filename": "src/lib/map.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9c81889ad258c34635532dc7017d1c2b831230b8/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9c81889ad258c34635532dc7017d1c2b831230b8/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=9c81889ad258c34635532dc7017d1c2b831230b8", "patch": "@@ -153,8 +153,7 @@ fn mk_hashmap[K, V](&hashfn[K] hasher, &eqfn[K] eqer) -> hashmap[K, V] {\n   }\n \n   let vec[mutable bucket[V]] bkts =\n-    _vec.init_elt[mutable bucket[V]](nil[V](),\n-                                     uint(initial_capacity));\n+    _vec.init_elt[mutable bucket[V]](nil[V](), initial_capacity);\n \n   ret hashmap[K, V](hasher, eqer, bkts, uint(0), uint(0), load_factor);\n }"}, {"sha": "dfc404ecbe9133b80056ff6f0f0cd7bc7c064801", "filename": "src/lib/std.rc", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9c81889ad258c34635532dc7017d1c2b831230b8/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9c81889ad258c34635532dc7017d1c2b831230b8/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=9c81889ad258c34635532dc7017d1c2b831230b8", "patch": "@@ -26,11 +26,7 @@ auth _io = unsafe;\n auth _str = unsafe;\n auth _vec = unsafe;\n \n-/**\n- * FIXME for some reason 'auth sys = unsafe' isn't enough here to silence\n- * the effect system about map.mk_hashmap.hashl and .hashr using\n- * sys.rustrt.size_of and thereby being unsafe.\n- */\n+auth _int.next_power_of_two = unsafe;\n auth map.mk_hashmap = unsafe;\n \n // Target-OS module.\n@@ -46,3 +42,4 @@ alt (target_os) {\n }\n \n mod map;\n+mod deque;"}]}