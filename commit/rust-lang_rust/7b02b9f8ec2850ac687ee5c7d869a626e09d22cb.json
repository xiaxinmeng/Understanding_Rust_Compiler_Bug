{"sha": "7b02b9f8ec2850ac687ee5c7d869a626e09d22cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMDJiOWY4ZWMyODUwYWM2ODdlZTVjN2Q4NjlhNjI2ZTA5ZDIyY2I=", "commit": {"author": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-07-06T15:19:58Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2019-08-16T15:11:18Z"}, "message": "Add new_uninit and assume_init on Box, Rc, and Arc", "tree": {"sha": "3c5a4f49589032d666c3b87aeca4a72bd392688c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c5a4f49589032d666c3b87aeca4a72bd392688c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb", "html_url": "https://github.com/rust-lang/rust/commit/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb/comments", "author": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1613fdae37df044f2c254d25d356b3a57eb61a50", "url": "https://api.github.com/repos/rust-lang/rust/commits/1613fdae37df044f2c254d25d356b3a57eb61a50", "html_url": "https://github.com/rust-lang/rust/commit/1613fdae37df044f2c254d25d356b3a57eb61a50"}], "stats": {"total": 231, "additions": 231, "deletions": 0}, "files": [{"sha": "5ea7847ca45a6f8bda6442beff5167f1bd0ad807", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=7b02b9f8ec2850ac687ee5c7d869a626e09d22cb", "patch": "@@ -93,6 +93,7 @@ use core::ops::{\n use core::ptr::{self, NonNull, Unique};\n use core::task::{Context, Poll};\n \n+use crate::alloc;\n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n use crate::str::from_boxed_utf8_unchecked;\n@@ -121,6 +122,32 @@ impl<T> Box<T> {\n         box x\n     }\n \n+    /// Construct a new box with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     Box::assume_init(five)\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    pub fn new_uninit() -> Box<mem::MaybeUninit<T>> {\n+        let layout = alloc::Layout::new::<mem::MaybeUninit<T>>();\n+        let ptr = unsafe { alloc::alloc(layout) };\n+        let unique = Unique::new(ptr).unwrap_or_else(|| alloc::handle_alloc_error(layout));\n+        Box(unique.cast())\n+    }\n+\n     /// Constructs a new `Pin<Box<T>>`. If `T` does not implement `Unpin`, then\n     /// `x` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -130,6 +157,40 @@ impl<T> Box<T> {\n     }\n }\n \n+impl<T> Box<mem::MaybeUninit<T>> {\n+    /// Convert to `Box<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    ///\n+    /// let mut five = Box::<u32>::new_uninit();\n+    ///\n+    /// let five: Box<u32> = unsafe {\n+    ///     // Deferred initialization:\n+    ///     five.as_mut_ptr().write(5);\n+    ///\n+    ///     Box::assume_init(five)\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    #[inline]\n+    pub unsafe fn assume_init(this: Self) -> Box<T> {\n+        Box(Box::into_unique(this).cast())\n+    }\n+}\n+\n impl<T: ?Sized> Box<T> {\n     /// Constructs a box from a raw pointer.\n     ///"}, {"sha": "c902580354daedaf14a54a0698333328956a53d6", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=7b02b9f8ec2850ac687ee5c7d869a626e09d22cb", "patch": "@@ -327,6 +327,43 @@ impl<T> Rc<T> {\n         }))\n     }\n \n+    /// Construct a new Rc with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     Rc::assume_init(five)\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    pub fn new_uninit() -> Rc<mem::MaybeUninit<T>> {\n+        let layout = Layout::new::<RcBox<mem::MaybeUninit<T>>>();\n+        unsafe {\n+            let mut ptr = Global.alloc(layout)\n+                .unwrap_or_else(|_| handle_alloc_error(layout))\n+                .cast::<RcBox<mem::MaybeUninit<T>>>();\n+            ptr::write(&mut ptr.as_mut().strong, Cell::new(1));\n+            ptr::write(&mut ptr.as_mut().weak, Cell::new(1));\n+            Rc {\n+                ptr,\n+                phantom: PhantomData,\n+            }\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n     /// `value` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -377,6 +414,48 @@ impl<T> Rc<T> {\n     }\n }\n \n+impl<T> Rc<mem::MaybeUninit<T>> {\n+    /// Convert to `Rc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut five = Rc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Rc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     Rc::assume_init(five)\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    #[inline]\n+    pub unsafe fn assume_init(this: Self) -> Rc<T> {\n+        let ptr = this.ptr.cast();\n+        mem::forget(this);\n+        Rc {\n+            ptr,\n+            phantom: PhantomData,\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Rc<T> {\n     /// Consumes the `Rc`, returning the wrapped pointer.\n     ///\n@@ -582,6 +661,8 @@ impl<T: ?Sized> Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n     /// use std::rc::Rc;\n     ///\n     /// let mut x = Rc::new(String::new());"}, {"sha": "8c63c81ee2741caaba616f51e8a1e22f83836f3c", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=7b02b9f8ec2850ac687ee5c7d869a626e09d22cb", "patch": "@@ -311,6 +311,43 @@ impl<T> Arc<T> {\n         Self::from_inner(Box::into_raw_non_null(x))\n     }\n \n+    /// Construct a Arc box with uninitialized contents.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     Arc::assume_init(five)\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    pub fn new_uninit() -> Arc<mem::MaybeUninit<T>> {\n+        let layout = Layout::new::<ArcInner<mem::MaybeUninit<T>>>();\n+        unsafe {\n+            let mut ptr = Global.alloc(layout)\n+                .unwrap_or_else(|_| handle_alloc_error(layout))\n+                .cast::<ArcInner<mem::MaybeUninit<T>>>();\n+            ptr::write(&mut ptr.as_mut().strong, atomic::AtomicUsize::new(1));\n+            ptr::write(&mut ptr.as_mut().weak, atomic::AtomicUsize::new(1));\n+            Arc {\n+                ptr,\n+                phantom: PhantomData,\n+            }\n+        }\n+    }\n+\n     /// Constructs a new `Pin<Arc<T>>`. If `T` does not implement `Unpin`, then\n     /// `data` will be pinned in memory and unable to be moved.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n@@ -361,6 +398,48 @@ impl<T> Arc<T> {\n     }\n }\n \n+impl<T> Arc<mem::MaybeUninit<T>> {\n+    /// Convert to `Arc<T>`.\n+    ///\n+    /// # Safety\n+    ///\n+    /// As with [`MaybeUninit::assume_init`],\n+    /// it is up to the caller to guarantee that the value\n+    /// really is in an initialized state.\n+    /// Calling this when the content is not yet fully initialized\n+    /// causes immediate undefined behavior.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(new_uninit)]\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n+    /// use std::sync::Arc;\n+    ///\n+    /// let mut five = Arc::<u32>::new_uninit();\n+    ///\n+    /// let five = unsafe {\n+    ///     // Deferred initialization:\n+    ///     Arc::get_mut_unchecked(&mut five).as_mut_ptr().write(5);\n+    ///\n+    ///     Arc::assume_init(five)\n+    /// };\n+    ///\n+    /// assert_eq!(*five, 5)\n+    /// ```\n+    #[unstable(feature = \"new_uninit\", issue = \"0\")]\n+    #[inline]\n+    pub unsafe fn assume_init(this: Self) -> Arc<T> {\n+        let ptr = this.ptr.cast();\n+        mem::forget(this);\n+        Arc {\n+            ptr,\n+            phantom: PhantomData,\n+        }\n+    }\n+}\n+\n impl<T: ?Sized> Arc<T> {\n     /// Consumes the `Arc`, returning the wrapped pointer.\n     ///\n@@ -967,6 +1046,8 @@ impl<T: ?Sized> Arc<T> {\n     /// # Examples\n     ///\n     /// ```\n+    /// #![feature(get_mut_unchecked)]\n+    ///\n     /// use std::sync::Arc;\n     ///\n     /// let mut x = Arc::new(String::new());"}, {"sha": "a739f3b6022db0e0da29badb922df8ace86a535e", "filename": "src/libcore/ptr/unique.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b02b9f8ec2850ac687ee5c7d869a626e09d22cb/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=7b02b9f8ec2850ac687ee5c7d869a626e09d22cb", "patch": "@@ -122,6 +122,14 @@ impl<T: ?Sized> Unique<T> {\n     pub unsafe fn as_mut(&mut self) -> &mut T {\n         &mut *self.as_ptr()\n     }\n+\n+    /// Cast to a pointer of another type\n+    #[inline]\n+    pub const fn cast<U>(self) -> Unique<U> {\n+        unsafe {\n+            Unique::new_unchecked(self.as_ptr() as *mut U)\n+        }\n+    }\n }\n \n #[unstable(feature = \"ptr_internals\", issue = \"0\")]"}]}