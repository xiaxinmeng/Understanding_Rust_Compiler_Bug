{"sha": "92386a7ff37a2a7a01b187afefc51f326e923377", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMzg2YTdmZjM3YTJhN2EwMWIxODdhZmVmYzUxZjMyNmU5MjMzNzc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-09-29T18:14:29Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-10-03T22:12:29Z"}, "message": "metadata: Simplify interface of `resolve_crate`", "tree": {"sha": "3a28e013e99775553a0b7634a529c8b1be835c5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a28e013e99775553a0b7634a529c8b1be835c5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92386a7ff37a2a7a01b187afefc51f326e923377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92386a7ff37a2a7a01b187afefc51f326e923377", "html_url": "https://github.com/rust-lang/rust/commit/92386a7ff37a2a7a01b187afefc51f326e923377", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92386a7ff37a2a7a01b187afefc51f326e923377/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33c9ada8003844b6a683930fdd1442effffd3b0a", "url": "https://api.github.com/repos/rust-lang/rust/commits/33c9ada8003844b6a683930fdd1442effffd3b0a", "html_url": "https://github.com/rust-lang/rust/commit/33c9ada8003844b6a683930fdd1442effffd3b0a"}], "stats": {"total": 106, "additions": 46, "deletions": 60}, "files": [{"sha": "510787998ad071c969f8cab544042737ecbb4418", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92386a7ff37a2a7a01b187afefc51f326e923377/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92386a7ff37a2a7a01b187afefc51f326e923377/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=92386a7ff37a2a7a01b187afefc51f326e923377", "patch": "@@ -148,9 +148,7 @@ pub enum ExternCrateSource {\n         /// such ids\n         DefId,\n     ),\n-    // Crate is loaded by `use`.\n-    Use,\n-    /// Crate is implicitly loaded by an absolute path.\n+    /// Crate is implicitly loaded by a path resolving through extern prelude.\n     Path,\n }\n "}, {"sha": "ea1b746dc07fefd4cfc82d56e2bb8855f93649f0", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 40, "deletions": 52, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/92386a7ff37a2a7a01b187afefc51f326e923377/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92386a7ff37a2a7a01b187afefc51f326e923377/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=92386a7ff37a2a7a01b187afefc51f326e923377", "patch": "@@ -2,7 +2,7 @@\n \n use crate::cstore::{self, CStore, CrateSource, MetadataBlob};\n use crate::locator::{self, CratePaths};\n-use crate::schema::{CrateRoot};\n+use crate::schema::{CrateRoot, CrateDep};\n use rustc_data_structures::sync::{Lrc, RwLock, Lock};\n \n use rustc::hir::def_id::CrateNum;\n@@ -190,7 +190,7 @@ impl<'a> CrateLoader<'a> {\n     fn register_crate(\n         &mut self,\n         host_lib: Option<Library>,\n-        root: &Option<CratePaths>,\n+        root: Option<&CratePaths>,\n         span: Span,\n         lib: Library,\n         dep_kind: DepKind,\n@@ -208,19 +208,20 @@ impl<'a> CrateLoader<'a> {\n         // Claim this crate number and cache it\n         let cnum = self.cstore.alloc_new_crate_num();\n \n+        // Maintain a reference to the top most crate.\n         // Stash paths for top-most crate locally if necessary.\n-        let crate_paths = if root.is_none() {\n-            Some(CratePaths {\n+        let crate_paths;\n+        let root = if let Some(root) = root {\n+            root\n+        } else {\n+            crate_paths = CratePaths {\n                 ident: crate_root.name.to_string(),\n                 dylib: lib.dylib.clone().map(|p| p.0),\n                 rlib:  lib.rlib.clone().map(|p| p.0),\n                 rmeta: lib.rmeta.clone().map(|p| p.0),\n-            })\n-        } else {\n-            None\n+            };\n+            &crate_paths\n         };\n-        // Maintain a reference to the top most crate.\n-        let root = if root.is_some() { root } else { &crate_paths };\n \n         let Library { dylib, rlib, rmeta, metadata } = lib;\n         let cnum_map = self.resolve_crate_deps(root, &crate_root, &metadata, cnum, span, dep_kind);\n@@ -336,15 +337,27 @@ impl<'a> CrateLoader<'a> {\n \n     fn resolve_crate<'b>(\n         &'b mut self,\n-        root: &'b Option<CratePaths>,\n         name: Symbol,\n-        hash: Option<&'b Svh>,\n-        extra_filename: Option<&'b str>,\n         span: Span,\n-        path_kind: PathKind,\n+        dep_kind: DepKind,\n+        dep: Option<(&'b CratePaths, &'b CrateDep)>,\n+    ) -> (CrateNum, Lrc<cstore::CrateMetadata>) {\n+        self.maybe_resolve_crate(name, span, dep_kind, dep).unwrap_or_else(|err| err.report())\n+    }\n+\n+    fn maybe_resolve_crate<'b>(\n+        &'b mut self,\n+        name: Symbol,\n+        span: Span,\n         mut dep_kind: DepKind,\n+        dep: Option<(&'b CratePaths, &'b CrateDep)>,\n     ) -> Result<(CrateNum, Lrc<cstore::CrateMetadata>), LoadError<'b>> {\n         info!(\"resolving crate `{}`\", name);\n+        let (root, hash, extra_filename, path_kind) = match dep {\n+            Some((root, dep)) =>\n+                (Some(root), Some(&dep.hash), Some(&dep.extra_filename[..]), PathKind::Dependency),\n+            None => (None, None, None, PathKind::Crate),\n+        };\n         let result = if let Some(cnum) = self.existing_match(name, hash, path_kind) {\n             (LoadResult::Previous(cnum), None)\n         } else {\n@@ -463,7 +476,7 @@ impl<'a> CrateLoader<'a> {\n \n     // Go through the crate metadata and load any crates that it references\n     fn resolve_crate_deps(&mut self,\n-                          root: &Option<CratePaths>,\n+                          root: &CratePaths,\n                           crate_root: &CrateRoot<'_>,\n                           metadata: &MetadataBlob,\n                           krate: CrateNum,\n@@ -478,9 +491,7 @@ impl<'a> CrateLoader<'a> {\n         // The map from crate numbers in the crate we're resolving to local crate numbers.\n         // We map 0 and all other holes in the map to our parent crate. The \"additional\"\n         // self-dependencies should be harmless.\n-        std::iter::once(krate).chain(crate_root.crate_deps\n-                                                 .decode(metadata)\n-                                                 .map(|dep| {\n+        std::iter::once(krate).chain(crate_root.crate_deps.decode(metadata).map(|dep| {\n             info!(\"resolving dep crate {} hash: `{}` extra filename: `{}`\", dep.name, dep.hash,\n                   dep.extra_filename);\n             if dep.kind == DepKind::UnexportedMacrosOnly {\n@@ -490,11 +501,7 @@ impl<'a> CrateLoader<'a> {\n                 DepKind::MacrosOnly => DepKind::MacrosOnly,\n                 _ => dep.kind,\n             };\n-            let (local_cnum, ..) = self.resolve_crate(\n-                root, dep.name, Some(&dep.hash), Some(&dep.extra_filename), span,\n-                PathKind::Dependency, dep_kind,\n-            ).unwrap_or_else(|err| err.report());\n-            local_cnum\n+            self.resolve_crate(dep.name, span, dep_kind, Some((root, &dep))).0\n         })).collect()\n     }\n \n@@ -513,7 +520,7 @@ impl<'a> CrateLoader<'a> {\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             target: &self.sess.host,\n             triple: host_triple,\n-            root: &None,\n+            root: None,\n             rejected_via_hash: vec![],\n             rejected_via_triple: vec![],\n             rejected_via_kind: vec![],\n@@ -693,10 +700,7 @@ impl<'a> CrateLoader<'a> {\n         };\n         info!(\"panic runtime not found -- loading {}\", name);\n \n-        let dep_kind = DepKind::Implicit;\n-        let (cnum, data) =\n-            self.resolve_crate(&None, name, None, None, DUMMY_SP, PathKind::Crate, dep_kind)\n-                .unwrap_or_else(|err| err.report());\n+        let (cnum, data) = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None);\n \n         // Sanity check the loaded crate to ensure it is indeed a panic runtime\n         // and the panic strategy is indeed what we thought it was.\n@@ -792,20 +796,15 @@ impl<'a> CrateLoader<'a> {\n             });\n \n             if uses_std {\n-                let name = match *sanitizer {\n+                let name = Symbol::intern(match sanitizer {\n                     Sanitizer::Address => \"rustc_asan\",\n                     Sanitizer::Leak => \"rustc_lsan\",\n                     Sanitizer::Memory => \"rustc_msan\",\n                     Sanitizer::Thread => \"rustc_tsan\",\n-                };\n+                });\n                 info!(\"loading sanitizer: {}\", name);\n \n-                let symbol = Symbol::intern(name);\n-                let dep_kind = DepKind::Explicit;\n-                let (_, data) =\n-                    self.resolve_crate(&None, symbol, None, None, DUMMY_SP,\n-                                       PathKind::Crate, dep_kind)\n-                        .unwrap_or_else(|err| err.report());\n+                let data = self.resolve_crate(name, DUMMY_SP, DepKind::Explicit, None).1;\n \n                 // Sanity check the loaded crate to ensure it is indeed a sanitizer runtime\n                 if !data.root.sanitizer_runtime {\n@@ -824,12 +823,8 @@ impl<'a> CrateLoader<'a> {\n         {\n             info!(\"loading profiler\");\n \n-            let symbol = Symbol::intern(\"profiler_builtins\");\n-            let dep_kind = DepKind::Implicit;\n-            let (_, data) =\n-                self.resolve_crate(&None, symbol, None, None, DUMMY_SP,\n-                                   PathKind::Crate, dep_kind)\n-                    .unwrap_or_else(|err| err.report());\n+            let name = Symbol::intern(\"profiler_builtins\");\n+            let data = self.resolve_crate(name, DUMMY_SP, DepKind::Implicit, None).1;\n \n             // Sanity check the loaded crate to ensure it is indeed a profiler runtime\n             if !data.root.profiler_runtime {\n@@ -996,7 +991,7 @@ impl<'a> CrateLoader<'a> {\n             ast::ItemKind::ExternCrate(orig_name) => {\n                 debug!(\"resolving extern crate stmt. ident: {} orig_name: {:?}\",\n                        item.ident, orig_name);\n-                let orig_name = match orig_name {\n+                let name = match orig_name {\n                     Some(orig_name) => {\n                         crate::validate_crate_name(Some(self.sess), &orig_name.as_str(),\n                                             Some(item.span));\n@@ -1010,10 +1005,7 @@ impl<'a> CrateLoader<'a> {\n                     DepKind::Explicit\n                 };\n \n-                let (cnum, ..) = self.resolve_crate(\n-                    &None, orig_name, None, None,\n-                    item.span, PathKind::Crate, dep_kind,\n-                ).unwrap_or_else(|err| err.report());\n+                let cnum = self.resolve_crate(name, item.span, dep_kind, None).0;\n \n                 let def_id = definitions.opt_local_def_id(item.id).unwrap();\n                 let path_len = definitions.def_path(def_id.index).data.len();\n@@ -1039,9 +1031,7 @@ impl<'a> CrateLoader<'a> {\n         name: Symbol,\n         span: Span,\n     ) -> CrateNum {\n-        let cnum = self.resolve_crate(\n-            &None, name, None, None, span, PathKind::Crate, DepKind::Explicit\n-        ).unwrap_or_else(|err| err.report()).0;\n+        let cnum = self.resolve_crate(name, span, DepKind::Explicit, None).0;\n \n         self.update_extern_crate(\n             cnum,\n@@ -1063,9 +1053,7 @@ impl<'a> CrateLoader<'a> {\n         name: Symbol,\n         span: Span,\n     ) -> Option<CrateNum> {\n-        let cnum = self.resolve_crate(\n-            &None, name, None, None, span, PathKind::Crate, DepKind::Explicit\n-        ).ok()?.0;\n+        let cnum = self.maybe_resolve_crate(name, span, DepKind::Explicit, None).ok()?.0;\n \n         self.update_extern_crate(\n             cnum,"}, {"sha": "8df236c41cfb888a88bf0556bec35a2d1046ee1b", "filename": "src/librustc_metadata/locator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92386a7ff37a2a7a01b187afefc51f326e923377/src%2Flibrustc_metadata%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92386a7ff37a2a7a01b187afefc51f326e923377/src%2Flibrustc_metadata%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flocator.rs?ref=92386a7ff37a2a7a01b187afefc51f326e923377", "patch": "@@ -261,7 +261,7 @@ pub struct Context<'a> {\n     pub target: &'a Target,\n     pub triple: TargetTriple,\n     pub filesearch: FileSearch<'a>,\n-    pub root: &'a Option<CratePaths>,\n+    pub root: Option<&'a CratePaths>,\n     pub rejected_via_hash: Vec<CrateMismatch>,\n     pub rejected_via_triple: Vec<CrateMismatch>,\n     pub rejected_via_kind: Vec<CrateMismatch>,\n@@ -322,8 +322,8 @@ impl<'a> Context<'a> {\n \n     pub fn report_errs(self) -> ! {\n         let add = match self.root {\n-            &None => String::new(),\n-            &Some(ref r) => format!(\" which `{}` depends on\", r.ident),\n+            None => String::new(),\n+            Some(r) => format!(\" which `{}` depends on\", r.ident),\n         };\n         let mut msg = \"the following crate versions were found:\".to_string();\n         let mut err = if !self.rejected_via_hash.is_empty() {\n@@ -339,8 +339,8 @@ impl<'a> Context<'a> {\n                 msg.push_str(&format!(\"\\ncrate `{}`: {}\", self.crate_name, path.display()));\n             }\n             match self.root {\n-                &None => {}\n-                &Some(ref r) => {\n+                None => {}\n+                Some(r) => {\n                     for path in r.paths().iter() {\n                         msg.push_str(&format!(\"\\ncrate `{}`: {}\", r.ident, path.display()));\n                     }"}]}