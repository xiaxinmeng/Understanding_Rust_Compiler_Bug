{"sha": "2a08b0e3006aeb997e42d5df135eea63b071fa75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhMDhiMGUzMDA2YWViOTk3ZTQyZDVkZjEzNWVlYTYzYjA3MWZhNzU=", "commit": {"author": {"name": "Hrvoje Niksic", "email": "hniksic@gmail.com", "date": "2020-03-04T21:12:53Z"}, "committer": {"name": "Hrvoje Niksic", "email": "hniksic@gmail.com", "date": "2020-03-19T13:49:21Z"}, "message": "Restore (and reword) the warning against passing invalid values to mem::forget.\n\nAs pointed out by Ralf Jung, dangling references and boxes are\nundefined behavior as per\nhttps://doc.rust-lang.org/reference/behavior-considered-undefined.html\nand the Miri checker.", "tree": {"sha": "89a78e14cf0d9177dd664a6e09ccc0a8073e0934", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89a78e14cf0d9177dd664a6e09ccc0a8073e0934"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a08b0e3006aeb997e42d5df135eea63b071fa75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a08b0e3006aeb997e42d5df135eea63b071fa75", "html_url": "https://github.com/rust-lang/rust/commit/2a08b0e3006aeb997e42d5df135eea63b071fa75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a08b0e3006aeb997e42d5df135eea63b071fa75/comments", "author": {"login": "hniksic", "id": 1078190, "node_id": "MDQ6VXNlcjEwNzgxOTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1078190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hniksic", "html_url": "https://github.com/hniksic", "followers_url": "https://api.github.com/users/hniksic/followers", "following_url": "https://api.github.com/users/hniksic/following{/other_user}", "gists_url": "https://api.github.com/users/hniksic/gists{/gist_id}", "starred_url": "https://api.github.com/users/hniksic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hniksic/subscriptions", "organizations_url": "https://api.github.com/users/hniksic/orgs", "repos_url": "https://api.github.com/users/hniksic/repos", "events_url": "https://api.github.com/users/hniksic/events{/privacy}", "received_events_url": "https://api.github.com/users/hniksic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hniksic", "id": 1078190, "node_id": "MDQ6VXNlcjEwNzgxOTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1078190?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hniksic", "html_url": "https://github.com/hniksic", "followers_url": "https://api.github.com/users/hniksic/followers", "following_url": "https://api.github.com/users/hniksic/following{/other_user}", "gists_url": "https://api.github.com/users/hniksic/gists{/gist_id}", "starred_url": "https://api.github.com/users/hniksic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hniksic/subscriptions", "organizations_url": "https://api.github.com/users/hniksic/orgs", "repos_url": "https://api.github.com/users/hniksic/repos", "events_url": "https://api.github.com/users/hniksic/events{/privacy}", "received_events_url": "https://api.github.com/users/hniksic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e0398c060ba50bde4fe47a3685c0857285001bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e0398c060ba50bde4fe47a3685c0857285001bd", "html_url": "https://github.com/rust-lang/rust/commit/8e0398c060ba50bde4fe47a3685c0857285001bd"}], "stats": {"total": 52, "additions": 35, "deletions": 17}, "files": [{"sha": "7297f66970de5b928e143960390bdf5f533613e8", "filename": "src/libcore/mem/mod.rs", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2a08b0e3006aeb997e42d5df135eea63b071fa75/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a08b0e3006aeb997e42d5df135eea63b071fa75/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=2a08b0e3006aeb997e42d5df135eea63b071fa75", "patch": "@@ -58,7 +58,9 @@ pub use crate::intrinsics::transmute;\n ///\n /// # Examples\n ///\n-/// Leak an I/O object, never closing the file:\n+/// The canonical safe use of `mem::forget` is to circumvent a value's destructor\n+/// implemented by the `Drop` trait. For example, this will leak a `File`, i.e. reclaim\n+/// the space taken by the variable but never close the underlying system resource:\n ///\n /// ```no_run\n /// use std::mem;\n@@ -68,27 +70,40 @@ pub use crate::intrinsics::transmute;\n /// mem::forget(file);\n /// ```\n ///\n-/// The practical use cases for `forget` are rather specialized and mainly come\n-/// up in unsafe or FFI code. For example:\n+/// This is useful when the ownership of the underlying was previously\n+/// transferred to code outside of Rust, for example by transmitting the raw\n+/// file descriptor to C code.\n+///\n+/// # Relationship with `ManuallyDrop`\n+///\n+/// Using `mem::forget` to transmit memory ownership is error-prone and is best\n+/// replaced with `ManuallyDrop`. Consider, for example, this code:\n ///\n /// ```\n /// use std::mem;\n ///\n /// let mut v = vec![65, 122];\n /// // Build a `String` using the contents of `v`\n /// let s = unsafe { String::from_raw_parts(v.as_mut_ptr(), 2, v.capacity()) };\n-/// // immediately leak `v` because its memory is now managed by `s`\n-/// mem::forget(v);\n+/// // leak `v` because its memory is now managed by `s`\n+/// mem::forget(v);  // ERROR - v is invalid and must not be passed to a function\n /// assert_eq!(s, \"Az\");\n /// // `s` is implicitly dropped and its memory deallocated.\n /// ```\n ///\n-/// The above is correct, but brittle. If code gets added between the construction of\n-/// `String` and the invocation of `mem::forget()`, a panic within it will cause a double\n-/// free because the same memory is handled by both `v` and `s`. This can be fixed by\n-/// storing the result of `v.as_mut_ptr()` in a local variable and calling `mem::forget()`\n-/// before `String::from_raw_parts`. This kind of issue can be more robustly prevented by\n-/// using [`ManuallyDrop`], which is usually preferred for such cases:\n+/// There are two issues with the above example:\n+///\n+/// * If more code were added between the construction of `String` and the invocation of\n+///   `mem::forget()`, a panic within it would cause a double free because the same memory\n+///   is handled by both `v` and `s`.\n+/// * After calling `v.as_mut_ptr()` and transmitting the ownership of the data to `s`,\n+///   the `v` value is invalid. Although moving a value to `mem::forget` (which won't\n+///   inspect it) seems safe, some types have strict requirements on their values that\n+///   make them invalid when dangling or no longer owned.  Using invalid values in any\n+///   way, including passing them to or returning them from functions, constitutes\n+///   undefined behavior and may break the assumptions made by the compiler.\n+///\n+/// Switching to `ManuallyDrop` avoids both issues:\n ///\n /// ```\n /// use std::mem::ManuallyDrop;\n@@ -108,12 +123,15 @@ pub use crate::intrinsics::transmute;\n ///\n /// `ManuallyDrop` robustly prevents double-free because we disable `v`'s destructor\n /// before doing anything else. `mem::forget()` doesn't allow this because it consumes its\n-/// argument, forcing us to call it only after extracting anything we need from `v`.\n-///\n-/// Note that the above code cannot panic between construction of `ManuallyDrop` and\n-/// building the string. But even if it could (after a modification), a panic there would\n-/// result in a leak and not a double free. In other words, `ManuallyDrop` errs on the\n-/// side of leaking instead of erring on the side of dropping.\n+/// argument, forcing us to call it only after extracting anything we need from `v`.  Even\n+/// if a panic were introduced between construction of `ManuallyDrop` and building the\n+/// string (which cannot happen in the code as shown), it would result in a leak and not a\n+/// double free. In other words, `ManuallyDrop` errs on the side of leaking instead of\n+/// erring on the side of dropping.\n+///\n+/// Also, `ManuallyDrop` prevents us from having to \"touch\" `v` after transferring the\n+/// ownership to `s` - the final step of interacting with `v` to dispoe of it without\n+/// running its destructor is entirely avoided.\n ///\n /// [drop]: fn.drop.html\n /// [uninit]: fn.uninitialized.html"}]}