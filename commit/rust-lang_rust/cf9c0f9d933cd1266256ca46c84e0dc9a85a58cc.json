{"sha": "cf9c0f9d933cd1266256ca46c84e0dc9a85a58cc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmOWMwZjlkOTMzY2QxMjY2MjU2Y2E0NmM4NGUwZGM5YTg1YTU4Y2M=", "commit": {"author": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-04T23:09:08Z"}, "committer": {"name": "Michael Sullivan", "email": "sully@msully.net", "date": "2011-08-04T23:18:12Z"}, "message": "Use lambdas in gather_locals in typeck.", "tree": {"sha": "c280aa3f762a738d3fec6d35a0bc0a25cea2430f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c280aa3f762a738d3fec6d35a0bc0a25cea2430f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf9c0f9d933cd1266256ca46c84e0dc9a85a58cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf9c0f9d933cd1266256ca46c84e0dc9a85a58cc", "html_url": "https://github.com/rust-lang/rust/commit/cf9c0f9d933cd1266256ca46c84e0dc9a85a58cc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf9c0f9d933cd1266256ca46c84e0dc9a85a58cc/comments", "author": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msullivan", "id": 340349, "node_id": "MDQ6VXNlcjM0MDM0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/340349?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msullivan", "html_url": "https://github.com/msullivan", "followers_url": "https://api.github.com/users/msullivan/followers", "following_url": "https://api.github.com/users/msullivan/following{/other_user}", "gists_url": "https://api.github.com/users/msullivan/gists{/gist_id}", "starred_url": "https://api.github.com/users/msullivan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msullivan/subscriptions", "organizations_url": "https://api.github.com/users/msullivan/orgs", "repos_url": "https://api.github.com/users/msullivan/repos", "events_url": "https://api.github.com/users/msullivan/events{/privacy}", "received_events_url": "https://api.github.com/users/msullivan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95680474e27064a5745e9477a04765247285fb87", "url": "https://api.github.com/repos/rust-lang/rust/commits/95680474e27064a5745e9477a04765247285fb87", "html_url": "https://github.com/rust-lang/rust/commit/95680474e27064a5745e9477a04765247285fb87"}], "stats": {"total": 93, "additions": 36, "deletions": 57}, "files": [{"sha": "f9622e0eee32a95b1ee18cbb3f3ecc06f2e3484c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 36, "deletions": 57, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/cf9c0f9d933cd1266256ca46c84e0dc9a85a58cc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf9c0f9d933cd1266256ca46c84e0dc9a85a58cc/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=cf9c0f9d933cd1266256ca46c84e0dc9a85a58cc", "patch": "@@ -1201,45 +1201,39 @@ type gather_result =\n // Used only as a helper for check_fn.\n fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n                  old_fcx: &option::t[@fn_ctxt]) -> gather_result {\n-    fn next_var_id(nvi: @mutable int) -> int {\n+    let {vb, locals, local_names, nvi} = alt old_fcx {\n+      none. {\n+        { vb: ty::unify::mk_var_bindings(),\n+          locals: new_int_hash[int](),\n+          local_names: new_int_hash[ast::ident](),\n+          nvi: @mutable 0 }\n+      }\n+      some(fcx) {\n+        { vb: fcx.var_bindings,\n+          locals: fcx.locals,\n+          local_names: fcx.local_names,\n+          nvi: fcx.next_var_id }\n+      }\n+    };\n+    let tcx = ccx.tcx;\n+\n+    let next_var_id = lambda(nvi: @mutable int) -> int {\n         let rv = *nvi;\n         *nvi += 1;\n         ret rv;\n-    }\n-    fn assign(tcx: &ty::ctxt, var_bindings: &@ty::unify::var_bindings,\n-              locals: &hashmap[ast::node_id, int],\n-              local_names: &hashmap[ast::node_id, ast::ident],\n-              nvi: @mutable int, nid: ast::node_id, ident: &ast::ident,\n-              ty_opt: option::t[ty::t]) {\n+    };\n+    let assign = lambda(nid: ast::node_id, ident: &ast::ident,\n+                        ty_opt: option::t[ty::t]) {\n         let var_id = next_var_id(nvi);\n         locals.insert(nid, var_id);\n         local_names.insert(nid, ident);\n         alt ty_opt {\n-          none[ty::t]. {/* nothing to do */ }\n-          some[ty::t](typ) {\n-            ty::unify::unify(ty::mk_var(tcx, var_id), typ, var_bindings, tcx);\n+          none. {/* nothing to do */ }\n+          some(typ) {\n+            ty::unify::unify(ty::mk_var(tcx, var_id), typ, vb, tcx);\n           }\n         }\n-    }\n-\n-    let vb;\n-    let locals;\n-    let local_names;\n-    let nvi;\n-    alt old_fcx {\n-      none. {\n-        vb = ty::unify::mk_var_bindings();\n-        locals = new_int_hash[int]();\n-        local_names = new_int_hash[ast::ident]();\n-        nvi = @mutable 0;\n-      }\n-      some(fcx) {\n-        vb = fcx.var_bindings;\n-        locals = fcx.locals;\n-        local_names = fcx.local_names;\n-        nvi = fcx.next_var_id;\n-      }\n-    }\n+    };\n \n     // Add object fields, if any.\n     let obj_fields = ~[];\n@@ -1254,68 +1248,53 @@ fn gather_locals(ccx: &@crate_ctxt, f: &ast::_fn, id: &ast::node_id,\n     }\n     for f: ast::obj_field  in obj_fields {\n         let field_ty = ty::node_id_to_type(ccx.tcx, f.id);\n-        assign(ccx.tcx, vb, locals, local_names, nvi, f.id, f.ident,\n-               some(field_ty));\n+        assign(f.id, f.ident, some(field_ty));\n     }\n \n     // Add formal parameters.\n     let args = ty::ty_fn_args(ccx.tcx, ty::node_id_to_type(ccx.tcx, id));\n     let i = 0u;\n     for arg: ty::arg  in args {\n-        assign(ccx.tcx, vb, locals, local_names, nvi, f.decl.inputs.(i).id,\n-               f.decl.inputs.(i).ident, some[ty::t](arg.ty));\n+        assign(f.decl.inputs.(i).id, f.decl.inputs.(i).ident, some(arg.ty));\n         i += 1u;\n     }\n \n     // Add explicitly-declared locals.\n-    fn visit_local(ccx: @crate_ctxt, vb: @ty::unify::var_bindings,\n-                   locals: hashmap[ast::node_id, int],\n-                   local_names: hashmap[ast::node_id, ast::ident],\n-                   nvi: @mutable int, local: &@ast::local, e: &(),\n-                   v: &visit::vt[()]) {\n+    let visit_local = lambda(local: &@ast::local, e: &(), v: &visit::vt[()]) {\n         alt local.node.ty {\n           none. {\n             // Auto slot.\n-            assign(ccx.tcx, vb, locals, local_names, nvi, local.node.id,\n-                   ident_for_local(local), none);\n+            assign(local.node.id, ident_for_local(local), none);\n           }\n           some(ast_ty) {\n             // Explicitly typed slot.\n             let local_ty = ast_ty_to_ty_crate(ccx, ast_ty);\n-            assign(ccx.tcx, vb, locals, local_names, nvi, local.node.id,\n-                   ident_for_local(local), some(local_ty));\n+            assign(local.node.id, ident_for_local(local), some(local_ty));\n           }\n         }\n         visit::visit_local(local, e, v);\n-    }\n+    };\n \n     // Add pattern bindings.\n-    fn visit_pat(ccx: @crate_ctxt, vb: @ty::unify::var_bindings,\n-                 locals: hashmap[ast::node_id, int],\n-                 local_names: hashmap[ast::node_id, ast::ident],\n-                 nvi: @mutable int, p: &@ast::pat, e: &(),\n-                 v: &visit::vt[()]) {\n+    let visit_pat = lambda(p: &@ast::pat, e: &(), v: &visit::vt[()]) {\n         alt p.node {\n           ast::pat_bind(ident) {\n-            assign(ccx.tcx, vb, locals, local_names, nvi, p.id, ident, none);\n+            assign(p.id, ident, none);\n           }\n           _ {/* no-op */ }\n         }\n         visit::visit_pat(p, e, v);\n-    }\n+    };\n \n     // Don't descend into fns and items\n     fn visit_fn[E](f: &ast::_fn, tp: &ast::ty_param[], sp: &span,\n                    i: &ast::fn_ident, id: ast::node_id, e: &E,\n-                   v: &visit::vt[E]) {\n-    }\n+                   v: &visit::vt[E]) { }\n     fn visit_item[E](i: &@ast::item, e: &E, v: &visit::vt[E]) { }\n \n     let visit =\n-        @{visit_local:\n-              bind visit_local(ccx, vb, locals, local_names, nvi, _, _, _),\n-          visit_pat:\n-              bind visit_pat(ccx, vb, locals, local_names, nvi, _, _, _),\n+        @{visit_local: visit_local,\n+          visit_pat: visit_pat,\n           visit_fn: visit_fn,\n           visit_item: visit_item with *visit::default_visitor()};\n     visit::visit_block(f.body, (), visit::mk_vt(visit));"}]}