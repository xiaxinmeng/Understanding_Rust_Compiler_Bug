{"sha": "15decb86b2b69ddd56d3571c328cd18ac31f2e30", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZGVjYjg2YjJiNjlkZGQ1NmQzNTcxYzMyOGNkMThhYzMxZjJlMzA=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-02-09T13:47:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-09T13:47:32Z"}, "message": "Rollup merge of #39595 - camlorn:structured_repr, r=eddyb\n\nMake reprs use a structured representation instead of a slice\n\nThis is needed for `-z reorder-fields`.  The old design uses a slice taken from HIR, plus a cache that lazily parses.  The new design stores it directly in the `AdtDef` as a `ReprOptions`.  We're doing this now because we need to be able to add reprs that don't necessarily exist in HIR for `-z reorder-fields`, but it needs to happen anyway.\n\n`lookup_repr_hints` should be mostly deprecated.  I want to remove it from `layout` before closing this, unless people think that should be a separate PR.  The `[WIP]` is because of this.  The problem with closing this as-is is that the code here isn't actually testable until some parts of the compiler start using it.\n\nr? @eddyb", "tree": {"sha": "231b3dcacfc4a73d57acb89b3ea72ba9c6c60426", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/231b3dcacfc4a73d57acb89b3ea72ba9c6c60426"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15decb86b2b69ddd56d3571c328cd18ac31f2e30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15decb86b2b69ddd56d3571c328cd18ac31f2e30", "html_url": "https://github.com/rust-lang/rust/commit/15decb86b2b69ddd56d3571c328cd18ac31f2e30", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15decb86b2b69ddd56d3571c328cd18ac31f2e30/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b0e46f03d8f3ffe24b1bd1ae857ed86f95b1b3c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b0e46f03d8f3ffe24b1bd1ae857ed86f95b1b3c2", "html_url": "https://github.com/rust-lang/rust/commit/b0e46f03d8f3ffe24b1bd1ae857ed86f95b1b3c2"}, {"sha": "c3b64cf702552d7d7a68c8b2b4b6290b19b40f73", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3b64cf702552d7d7a68c8b2b4b6290b19b40f73", "html_url": "https://github.com/rust-lang/rust/commit/c3b64cf702552d7d7a68c8b2b4b6290b19b40f73"}], "stats": {"total": 210, "additions": 116, "deletions": 94}, "files": [{"sha": "6203679a510585ef03ae82a7e475d5d44a022725", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=15decb86b2b69ddd56d3571c328cd18ac31f2e30", "patch": "@@ -26,6 +26,7 @@ use middle::resolve_lifetime;\n use middle::stability;\n use mir::Mir;\n use ty::subst::{Kind, Substs};\n+use ty::ReprOptions;\n use traits;\n use ty::{self, TraitRef, Ty, TypeAndMut};\n use ty::{TyS, TypeVariants, Slice};\n@@ -672,9 +673,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn alloc_adt_def(self,\n                          did: DefId,\n                          kind: AdtKind,\n-                         variants: Vec<ty::VariantDef>)\n+                         variants: Vec<ty::VariantDef>,\n+                         repr: ReprOptions)\n                          -> &'gcx ty::AdtDef {\n-        let def = ty::AdtDef::new(self, did, kind, variants);\n+        let def = ty::AdtDef::new(self, did, kind, variants, repr);\n         self.global_arenas.adt_def.alloc(def)\n     }\n "}, {"sha": "3a463e981a6272e152b598113b32bdd4154de9fd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 39, "deletions": 63, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=15decb86b2b69ddd56d3571c328cd18ac31f2e30", "patch": "@@ -15,7 +15,7 @@ pub use self::Primitive::*;\n use infer::InferCtxt;\n use session::Session;\n use traits;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n \n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n@@ -437,7 +437,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    fn repr_discr(tcx: TyCtxt, ty: Ty, hints: &[attr::ReprAttr], min: i64, max: i64)\n+    fn repr_discr(tcx: TyCtxt, ty: Ty, repr: &ReprOptions, min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n@@ -449,34 +449,24 @@ impl Integer {\n         let mut min_from_extern = None;\n         let min_default = I8;\n \n-        for &r in hints.iter() {\n-            match r {\n-                attr::ReprInt(ity) => {\n-                    let discr = Integer::from_attr(&tcx.data_layout, ity);\n-                    let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n-                    if discr < fit {\n-                        bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n-                              discriminant range of enum `{}\", ty)\n-                    }\n-                    return (discr, ity.is_signed());\n-                }\n-                attr::ReprExtern => {\n-                    match &tcx.sess.target.target.arch[..] {\n-                        // WARNING: the ARM EABI has two variants; the one corresponding\n-                        // to `at_least == I32` appears to be used on Linux and NetBSD,\n-                        // but some systems may use the variant corresponding to no\n-                        // lower bound.  However, we don't run on those yet...?\n-                        \"arm\" => min_from_extern = Some(I32),\n-                        _ => min_from_extern = Some(I32),\n-                    }\n-                }\n-                attr::ReprAny => {},\n-                attr::ReprPacked => {\n-                    bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n-                }\n-                attr::ReprSimd => {\n-                    bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n-                }\n+        if let Some(ity) = repr.int {\n+            let discr = Integer::from_attr(&tcx.data_layout, ity);\n+            let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n+            if discr < fit {\n+                bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n+                  discriminant range of enum `{}\", ty)\n+            }\n+            return (discr, ity.is_signed());\n+        }\n+\n+        if repr.c {\n+            match &tcx.sess.target.target.arch[..] {\n+                // WARNING: the ARM EABI has two variants; the one corresponding\n+                // to `at_least == I32` appears to be used on Linux and NetBSD,\n+                // but some systems may use the variant corresponding to no\n+                // lower bound.  However, we don't run on those yet...?\n+                \"arm\" => min_from_extern = Some(I32),\n+                _ => min_from_extern = Some(I32),\n             }\n         }\n \n@@ -568,9 +558,9 @@ enum StructKind {\n impl<'a, 'gcx, 'tcx> Struct {\n     // FIXME(camlorn): reprs need a better representation to deal with multiple reprs on one type.\n     fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n-                  reprs: &[attr::ReprAttr], kind: StructKind,\n+                  repr: &ReprOptions, kind: StructKind,\n                   scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n-        let packed = reprs.contains(&attr::ReprPacked);\n+        let packed = repr.packed;\n         let mut ret = Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n             packed: packed,\n@@ -580,27 +570,16 @@ impl<'a, 'gcx, 'tcx> Struct {\n             min_size: Size::from_bytes(0),\n         };\n \n-        // Anything with ReprExtern or ReprPacked doesn't optimize.\n+        // Anything with repr(C) or repr(packed) doesn't optimize.\n         // Neither do  1-member and 2-member structs.\n         // In addition, code in trans assume that 2-element structs can become pairs.\n         // It's easier to just short-circuit here.\n-        let mut can_optimize = fields.len() > 2 || StructKind::EnumVariant == kind;\n-        if can_optimize {\n-            // This exhaustive match makes new reprs force the adder to modify this function.\n-            // Otherwise, things can silently break.\n-            // Note the inversion, return true to stop optimizing.\n-            can_optimize = !reprs.iter().any(|r| {\n-                match *r {\n-                    attr::ReprAny | attr::ReprInt(_) => false,\n-                    attr::ReprExtern | attr::ReprPacked => true,\n-                    attr::ReprSimd => bug!(\"Simd  vectors should be represented as layout::Vector\")\n-                }\n-            });\n-        }\n+        let mut can_optimize = (fields.len() > 2 || StructKind::EnumVariant == kind)\n+            && ! (repr.c || repr.packed);\n \n         // Disable field reordering until we can decide what to do.\n         // The odd pattern here avoids a warning about the value never being read.\n-        if can_optimize { can_optimize = false }\n+        if can_optimize { can_optimize = false; }\n \n         let (optimize, sort_ascending) = match kind {\n             StructKind::AlwaysSizedUnivariant => (can_optimize, false),\n@@ -1092,7 +1071,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // The never type.\n             ty::TyNever => Univariant {\n-                variant: Struct::new(dl, &vec![], &[],\n+                variant: Struct::new(dl, &vec![], &ReprOptions::default(),\n                   StructKind::AlwaysSizedUnivariant, ty)?,\n                 non_zero: false\n             },\n@@ -1135,12 +1114,12 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyFnDef(..) => {\n                 Univariant {\n                     variant: Struct::new(dl, &vec![],\n-                      &[], StructKind::AlwaysSizedUnivariant, ty)?,\n+                      &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?,\n                     non_zero: false\n                 }\n             }\n             ty::TyDynamic(..) => {\n-                let mut unit = Struct::new(dl, &vec![], &[],\n+                let mut unit = Struct::new(dl, &vec![], &ReprOptions::default(),\n                   StructKind::AlwaysSizedUnivariant, ty)?;\n                 unit.sized = false;\n                 Univariant { variant: unit, non_zero: false }\n@@ -1152,7 +1131,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let st = Struct::new(dl,\n                     &tys.map(|ty| ty.layout(infcx))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    &[],\n+                    &ReprOptions::default(),\n                     StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n@@ -1163,7 +1142,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let st = Struct::new(dl,\n                     &tys.iter().map(|ty| ty.layout(infcx))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    &[], StructKind::AlwaysSizedUnivariant, ty)?;\n+                    &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n \n@@ -1187,16 +1166,13 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                let hints = &tcx.lookup_repr_hints(def.did)[..];\n-\n                 if def.variants.is_empty() {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert_eq!(hints.len(), 0);\n \n                     return success(Univariant {\n                         variant: Struct::new(dl, &vec![],\n-                          &hints[..], StructKind::AlwaysSizedUnivariant, ty)?,\n+                          &def.repr, StructKind::AlwaysSizedUnivariant, ty)?,\n                         non_zero: false\n                     });\n                 }\n@@ -1219,7 +1195,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                     // FIXME: should handle i128? signed-value based impl is weird and hard to\n                     // grok.\n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..],\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &def.repr,\n                                                               min,\n                                                               max);\n                     return success(CEnum {\n@@ -1232,7 +1208,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     });\n                 }\n \n-                if !def.is_enum() || def.variants.len() == 1 && hints.is_empty() {\n+                if !def.is_enum() || def.variants.len() == 1 {\n                     // Struct, or union, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n@@ -1259,7 +1235,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion { variants: un }\n                     } else {\n-                        let st = Struct::new(dl, &fields, &hints[..],\n+                        let st = Struct::new(dl, &fields, &def.repr,\n                           kind, ty)?;\n                         let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n                         Univariant { variant: st, non_zero: non_zero }\n@@ -1282,7 +1258,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n                 }).collect::<Vec<_>>();\n \n-                if variants.len() == 2 && hints.is_empty() {\n+                if variants.len() == 2 && !def.repr.c {\n                     // Nullable pointer optimization\n                     for discr in 0..2 {\n                         let other_fields = variants[1 - discr].iter().map(|ty| {\n@@ -1315,7 +1291,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         let st = Struct::new(dl,\n                             &variants[discr].iter().map(|ty| ty.layout(infcx))\n                               .collect::<Result<Vec<_>, _>>()?,\n-                            &hints[..], StructKind::AlwaysSizedUnivariant, ty)?;\n+                            &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n \n                         // We have to fix the last element of path here.\n                         let mut i = *path.last().unwrap();\n@@ -1338,7 +1314,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // The general case.\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, ty, &hints[..], 0, discr_max);\n+                let (min_ity, _) = Integer::repr_discr(tcx, ty, &def.repr, 0, discr_max);\n \n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n@@ -1356,7 +1332,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     fields.insert(0, &discr);\n                     let st = Struct::new(dl,\n                         &fields,\n-                        &hints[..], StructKind::EnumVariant, ty)?;\n+                        &def.repr, StructKind::EnumVariant, ty)?;\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n                     // It is important to skip the first field."}, {"sha": "beb286108a034cfd7e86181a6c04aa939a76fd35", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 31, "deletions": 2, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=15decb86b2b69ddd56d3571c328cd18ac31f2e30", "patch": "@@ -1327,7 +1327,8 @@ pub struct AdtDef {\n     pub did: DefId,\n     pub variants: Vec<VariantDef>,\n     destructor: Cell<Option<DefId>>,\n-    flags: Cell<AdtFlags>\n+    flags: Cell<AdtFlags>,\n+    pub repr: ReprOptions,\n }\n \n impl PartialEq for AdtDef {\n@@ -1356,11 +1357,38 @@ impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n \n+/// Represents the repr options provided by the user,\n+#[derive(Copy, Clone, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n+pub struct ReprOptions {\n+    pub c: bool,\n+    pub packed: bool,\n+    pub simd: bool,\n+    pub int: Option<attr::IntType>,\n+}\n+\n+impl ReprOptions {\n+    pub fn new<'a, 'gcx, 'tcx>(tcx: &TyCtxt<'a, 'gcx, 'tcx>, did: DefId) -> ReprOptions {\n+        let mut ret = ReprOptions::default();\n+        let attrs = tcx.lookup_repr_hints(did);\n+        for r in attrs.iter() {\n+            match *r {\n+                attr::ReprExtern => ret.c = true,\n+                attr::ReprPacked => ret.packed = true,\n+                attr::ReprSimd => ret.simd = true,\n+                attr::ReprInt(i) => ret.int = Some(i),\n+                attr::ReprAny => (),\n+            }\n+        }\n+        ret\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> AdtDef {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n-           variants: Vec<VariantDef>) -> Self {\n+           variants: Vec<VariantDef>,\n+           repr: ReprOptions) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n@@ -1385,6 +1413,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             variants: variants,\n             flags: Cell::new(flags),\n             destructor: Cell::new(None),\n+            repr: repr,\n         }\n     }\n "}, {"sha": "bb99be20f64d30ed46e4c0e1a6f53bc7605782ea", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=15decb86b2b69ddd56d3571c328cd18ac31f2e30", "patch": "@@ -425,8 +425,8 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::ForeignImmStatic => Def::Static(did, false),\n             EntryKind::MutStatic |\n             EntryKind::ForeignMutStatic => Def::Static(did, true),\n-            EntryKind::Struct(_) => Def::Struct(did),\n-            EntryKind::Union(_) => Def::Union(did),\n+            EntryKind::Struct(_, _) => Def::Struct(did),\n+            EntryKind::Union(_, _) => Def::Union(did),\n             EntryKind::Fn(_) |\n             EntryKind::ForeignFn(_) => Def::Fn(did),\n             EntryKind::Method(_) => Def::Method(did),\n@@ -435,7 +435,7 @@ impl<'tcx> EntryKind<'tcx> {\n             EntryKind::Mod(_) => Def::Mod(did),\n             EntryKind::Variant(_) => Def::Variant(did),\n             EntryKind::Trait(_) => Def::Trait(did),\n-            EntryKind::Enum => Def::Enum(did),\n+            EntryKind::Enum(_) => Def::Enum(did),\n             EntryKind::MacroDef(_) => Def::Macro(did),\n \n             EntryKind::ForeignMod |\n@@ -519,8 +519,8 @@ impl<'a, 'tcx> CrateMetadata {\n                    -> (ty::VariantDef, Option<DefIndex>) {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n-            EntryKind::Struct(data) |\n-            EntryKind::Union(data) => data.decode(self),\n+            EntryKind::Struct(data, _) |\n+            EntryKind::Union(data, _) => data.decode(self),\n             _ => bug!(),\n         };\n \n@@ -547,7 +547,7 @@ impl<'a, 'tcx> CrateMetadata {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n         let mut ctor_index = None;\n-        let variants = if let EntryKind::Enum = item.kind {\n+        let variants = if let EntryKind::Enum(_) = item.kind {\n             item.children\n                 .decode(self)\n                 .map(|index| {\n@@ -561,14 +561,14 @@ impl<'a, 'tcx> CrateMetadata {\n             ctor_index = struct_ctor;\n             vec![variant]\n         };\n-        let kind = match item.kind {\n-            EntryKind::Enum => ty::AdtKind::Enum,\n-            EntryKind::Struct(_) => ty::AdtKind::Struct,\n-            EntryKind::Union(_) => ty::AdtKind::Union,\n+        let (kind, repr) = match item.kind {\n+            EntryKind::Enum(repr) => (ty::AdtKind::Enum, repr),\n+            EntryKind::Struct(_, repr) => (ty::AdtKind::Struct, repr),\n+            EntryKind::Union(_, repr) => (ty::AdtKind::Union, repr),\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let adt = tcx.alloc_adt_def(did, kind, variants);\n+        let adt = tcx.alloc_adt_def(did, kind, variants, repr);\n         if let Some(ctor_index) = ctor_index {\n             // Make adt definition available through constructor id as well.\n             tcx.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n@@ -881,16 +881,16 @@ impl<'a, 'tcx> CrateMetadata {\n \n     pub fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n         match self.entry(node_id).kind {\n-            EntryKind::Struct(data) |\n-            EntryKind::Union(data) |\n+            EntryKind::Struct(data, _) |\n+            EntryKind::Union(data, _) |\n             EntryKind::Variant(data) => data.decode(self).ctor_kind,\n             _ => CtorKind::Fictive,\n         }\n     }\n \n     pub fn get_struct_ctor_def_id(&self, node_id: DefIndex) -> Option<DefId> {\n         match self.entry(node_id).kind {\n-            EntryKind::Struct(data) => {\n+            EntryKind::Struct(data, _) => {\n                 data.decode(self).struct_ctor.map(|index| self.local_def_id(index))\n             }\n             _ => None,"}, {"sha": "f4ff5f4626f3587e9a36ec97e7a61cd3352bacc4", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 5, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=15decb86b2b69ddd56d3571c328cd18ac31f2e30", "patch": "@@ -20,7 +20,7 @@ use rustc::middle::dependency_format::Linkage;\n use rustc::middle::lang_items;\n use rustc::mir;\n use rustc::traits::specialization_graph;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, Ty, TyCtxt, ReprOptions};\n \n use rustc::session::config::{self, CrateTypeProcMacro};\n use rustc::util::nodemap::{FxHashMap, NodeSet};\n@@ -401,8 +401,10 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n         }\n \n+        let repr_options = get_repr_options(&tcx, adt_def_id);\n+\n         Entry {\n-            kind: EntryKind::Struct(self.lazy(&data)),\n+            kind: EntryKind::Struct(self.lazy(&data), repr_options),\n             visibility: self.lazy(&ctor_vis),\n             span: self.lazy(&tcx.def_span(def_id)),\n             attributes: LazySeq::empty(),\n@@ -659,7 +661,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemForeignMod(_) => EntryKind::ForeignMod,\n             hir::ItemTy(..) => EntryKind::Type,\n-            hir::ItemEnum(..) => EntryKind::Enum,\n+            hir::ItemEnum(..) => EntryKind::Enum(get_repr_options(&tcx, def_id)),\n             hir::ItemStruct(ref struct_def, _) => {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n@@ -671,20 +673,24 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 } else {\n                     None\n                 };\n+\n+                let repr_options = get_repr_options(&tcx, def_id);\n+\n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     disr: variant.disr_val.to_u128_unchecked(),\n                     struct_ctor: struct_ctor,\n-                }))\n+                }), repr_options)\n             }\n             hir::ItemUnion(..) => {\n                 let variant = tcx.lookup_adt_def(def_id).struct_variant();\n+                let repr_options = get_repr_options(&tcx, def_id);\n \n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n                     disr: variant.disr_val.to_u128_unchecked(),\n                     struct_ctor: None,\n-                }))\n+                }), repr_options)\n             }\n             hir::ItemDefaultImpl(..) => {\n                 let data = ImplData {\n@@ -1419,3 +1425,11 @@ pub fn encode_metadata<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     result\n }\n+\n+pub fn get_repr_options<'a, 'tcx, 'gcx>(tcx: &TyCtxt<'a, 'tcx, 'gcx>, did: DefId) -> ReprOptions {\n+    let ty = tcx.item_type(did);\n+    match ty.sty {\n+        ty::TyAdt(ref def, _) => return def.repr,\n+        _ => bug!(\"{} is not an ADT\", ty),\n+    }\n+}"}, {"sha": "10aa4784aa2e13611efd3d0f50cdd67833f360b1", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=15decb86b2b69ddd56d3571c328cd18ac31f2e30", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::cstore::{DepKind, LinkagePreference, NativeLibrary};\n use rustc::middle::lang_items;\n use rustc::middle::resolve_lifetime::ObjectLifetimeDefault;\n use rustc::mir;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::{self, Ty, ReprOptions};\n use rustc_back::PanicStrategy;\n \n use rustc_serialize as serialize;\n@@ -228,11 +228,11 @@ pub enum EntryKind<'tcx> {\n     ForeignMutStatic,\n     ForeignMod,\n     Type,\n-    Enum,\n+    Enum(ReprOptions),\n     Field,\n     Variant(Lazy<VariantData>),\n-    Struct(Lazy<VariantData>),\n-    Union(Lazy<VariantData>),\n+    Struct(Lazy<VariantData>, ReprOptions),\n+    Union(Lazy<VariantData>, ReprOptions),\n     Fn(Lazy<FnData>),\n     ForeignFn(Lazy<FnData>),\n     Mod(Lazy<ModData>),"}, {"sha": "7936db65c44acd2a2b54e1ee7f9f83d4c50ae005", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15decb86b2b69ddd56d3571c328cd18ac31f2e30/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=15decb86b2b69ddd56d3571c328cd18ac31f2e30", "patch": "@@ -65,7 +65,7 @@ use middle::const_val::ConstVal;\n use rustc_const_eval::EvalHint::UncheckedExprHint;\n use rustc_const_eval::{ConstContext, report_const_eval_err};\n use rustc::ty::subst::Substs;\n-use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer};\n+use rustc::ty::{ToPredicate, ImplContainer, AssociatedItemContainer, TraitContainer, ReprOptions};\n use rustc::ty::{self, AdtKind, ToPolyTraitRef, Ty, TyCtxt};\n use rustc::ty::util::IntTypeExt;\n use rustc::dep_graph::DepNode;\n@@ -1006,7 +1006,8 @@ fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let ctor_id = if !def.is_struct() { Some(ccx.tcx.hir.local_def_id(def.id())) } else { None };\n     let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n                                                ConstInt::Infer(0), def)];\n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants);\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants,\n+        ReprOptions::new(&ccx.tcx, did));\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n         ccx.tcx.adt_defs.borrow_mut().insert(ctor_id, adt);\n@@ -1024,7 +1025,7 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n     let did = ccx.tcx.hir.local_def_id(it.id);\n     let variants = vec![convert_struct_variant(ccx, did, it.name, ConstInt::Infer(0), def)];\n \n-    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants);\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants, ReprOptions::new(&ccx.tcx, did));\n     ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n@@ -1112,7 +1113,7 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         convert_struct_variant(ccx, did, v.node.name, disr, &v.node.data)\n     }).collect();\n \n-    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants);\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants, ReprOptions::new(&ccx.tcx, did));\n     tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }"}]}