{"sha": "ec55c61305eaf385fc1b93ac9a78284b4d887fe5", "node_id": "C_kwDOAAsO6NoAKGVjNTVjNjEzMDVlYWYzODVmYzFiOTNhYzlhNzgyODRiNGQ4ODdmZTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-10T11:50:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-10T11:50:39Z"}, "message": "Auto merge of #96837 - tmiasko:stdio-fcntl, r=joshtriplett\n\nUse `fcntl(fd, F_GETFD)` to detect if standard streams are open\n\nIn the previous implementation, if the standard streams were open,\nbut the RLIMIT_NOFILE value was below three, the poll would fail\nwith EINVAL:\n\n> ERRORS: EINVAL The nfds value exceeds the RLIMIT_NOFILE value.\n\nSwitch to the existing fcntl based implementation to avoid the issue.\n\nFixes #96621.", "tree": {"sha": "5b6abe8dc4a2278044d14457fb5f298b25e0527b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b6abe8dc4a2278044d14457fb5f298b25e0527b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec55c61305eaf385fc1b93ac9a78284b4d887fe5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec55c61305eaf385fc1b93ac9a78284b4d887fe5", "html_url": "https://github.com/rust-lang/rust/commit/ec55c61305eaf385fc1b93ac9a78284b4d887fe5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec55c61305eaf385fc1b93ac9a78284b4d887fe5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f19ccc2e8dab09e542d4c5a3ec14c7d5bce8d50e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f19ccc2e8dab09e542d4c5a3ec14c7d5bce8d50e", "html_url": "https://github.com/rust-lang/rust/commit/f19ccc2e8dab09e542d4c5a3ec14c7d5bce8d50e"}, {"sha": "2e62fdab76bd92d0d381589fc85602efad93c846", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e62fdab76bd92d0d381589fc85602efad93c846", "html_url": "https://github.com/rust-lang/rust/commit/2e62fdab76bd92d0d381589fc85602efad93c846"}], "stats": {"total": 138, "additions": 103, "deletions": 35}, "files": [{"sha": "7da9f248c877a6c86773704a3fa8557c055958e5", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ec55c61305eaf385fc1b93ac9a78284b4d887fe5/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec55c61305eaf385fc1b93ac9a78284b4d887fe5/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=ec55c61305eaf385fc1b93ac9a78284b4d887fe5", "patch": "@@ -239,6 +239,7 @@\n #![feature(dropck_eyepatch)]\n #![feature(exhaustive_patterns)]\n #![feature(intra_doc_pointers)]\n+#![feature(label_break_value)]\n #![feature(lang_items)]\n #![feature(let_chains)]\n #![feature(let_else)]"}, {"sha": "ddec60961f0caa31df21542248eb33720b6c5b89", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 56, "deletions": 35, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ec55c61305eaf385fc1b93ac9a78284b4d887fe5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec55c61305eaf385fc1b93ac9a78284b4d887fe5/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=ec55c61305eaf385fc1b93ac9a78284b4d887fe5", "patch": "@@ -77,35 +77,65 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n     }\n \n     unsafe fn sanitize_standard_fds() {\n-        #[cfg(not(miri))]\n-        // The standard fds are always available in Miri.\n-        cfg_if::cfg_if! {\n-            if #[cfg(not(any(\n-                target_os = \"emscripten\",\n-                target_os = \"fuchsia\",\n-                target_os = \"vxworks\",\n-                // The poll on Darwin doesn't set POLLNVAL for closed fds.\n-                target_os = \"macos\",\n-                target_os = \"ios\",\n-                target_os = \"redox\",\n-                target_os = \"l4re\",\n-            )))] {\n-                use crate::sys::os::errno;\n-                let pfds: &mut [_] = &mut [\n-                    libc::pollfd { fd: 0, events: 0, revents: 0 },\n-                    libc::pollfd { fd: 1, events: 0, revents: 0 },\n-                    libc::pollfd { fd: 2, events: 0, revents: 0 },\n-                ];\n-                while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n-                    if errno() == libc::EINTR {\n-                        continue;\n+        // fast path with a single syscall for systems with poll()\n+        #[cfg(not(any(\n+            miri,\n+            target_os = \"emscripten\",\n+            target_os = \"fuchsia\",\n+            target_os = \"vxworks\",\n+            // The poll on Darwin doesn't set POLLNVAL for closed fds.\n+            target_os = \"macos\",\n+            target_os = \"ios\",\n+            target_os = \"redox\",\n+            target_os = \"l4re\",\n+        )))]\n+        'poll: {\n+            use crate::sys::os::errno;\n+            let pfds: &mut [_] = &mut [\n+                libc::pollfd { fd: 0, events: 0, revents: 0 },\n+                libc::pollfd { fd: 1, events: 0, revents: 0 },\n+                libc::pollfd { fd: 2, events: 0, revents: 0 },\n+            ];\n+\n+            while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n+                match errno() {\n+                    libc::EINTR => continue,\n+                    libc::EINVAL | libc::EAGAIN | libc::ENOMEM => {\n+                        // RLIMIT_NOFILE or temporary allocation failures\n+                        // may be preventing use of poll(), fall back to fcntl\n+                        break 'poll;\n                     }\n+                    _ => libc::abort(),\n+                }\n+            }\n+            for pfd in pfds {\n+                if pfd.revents & libc::POLLNVAL == 0 {\n+                    continue;\n+                }\n+                if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+                    // If the stream is closed but we failed to reopen it, abort the\n+                    // process. Otherwise we wouldn't preserve the safety of\n+                    // operations on the corresponding Rust object Stdin, Stdout, or\n+                    // Stderr.\n                     libc::abort();\n                 }\n-                for pfd in pfds {\n-                    if pfd.revents & libc::POLLNVAL == 0 {\n-                        continue;\n-                    }\n+            }\n+            return;\n+        }\n+\n+        // fallback in case poll isn't available or limited by RLIMIT_NOFILE\n+        #[cfg(not(any(\n+            // The standard fds are always available in Miri.\n+            miri,\n+            target_os = \"emscripten\",\n+            target_os = \"fuchsia\",\n+            target_os = \"vxworks\",\n+            target_os = \"l4re\",\n+        )))]\n+        {\n+            use crate::sys::os::errno;\n+            for fd in 0..3 {\n+                if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n                     if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n                         // If the stream is closed but we failed to reopen it, abort the\n                         // process. Otherwise we wouldn't preserve the safety of\n@@ -114,15 +144,6 @@ pub unsafe fn init(argc: isize, argv: *const *const u8) {\n                         libc::abort();\n                     }\n                 }\n-            } else if #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"redox\"))] {\n-                use crate::sys::os::errno;\n-                for fd in 0..3 {\n-                    if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n-                        if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n-                            libc::abort();\n-                        }\n-                    }\n-                }\n             }\n         }\n     }"}, {"sha": "549135a46cf1019b4ae42b608994b5d5ede69938", "filename": "src/test/ui/process/nofile-limit.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ec55c61305eaf385fc1b93ac9a78284b4d887fe5/src%2Ftest%2Fui%2Fprocess%2Fnofile-limit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec55c61305eaf385fc1b93ac9a78284b4d887fe5/src%2Ftest%2Fui%2Fprocess%2Fnofile-limit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fnofile-limit.rs?ref=ec55c61305eaf385fc1b93ac9a78284b4d887fe5", "patch": "@@ -0,0 +1,46 @@\n+// Check that statically linked binary executes successfully\n+// with RLIMIT_NOFILE resource lowered to zero. Regression\n+// test for issue #96621.\n+//\n+// run-pass\n+// dont-check-compiler-stderr\n+// only-linux\n+// no-prefer-dynamic\n+// compile-flags: -Ctarget-feature=+crt-static -Crpath=no\n+#![feature(exit_status_error)]\n+#![feature(rustc_private)]\n+extern crate libc;\n+\n+use std::os::unix::process::CommandExt;\n+use std::process::Command;\n+\n+fn main() {\n+    let mut args = std::env::args();\n+    let this = args.next().unwrap();\n+    match args.next().as_deref() {\n+        None => {\n+            let mut cmd = Command::new(this);\n+            cmd.arg(\"Ok!\");\n+            unsafe {\n+                cmd.pre_exec(|| {\n+                    let rlim = libc::rlimit {\n+                        rlim_cur: 0,\n+                        rlim_max: 0,\n+                    };\n+                    if libc::setrlimit(libc::RLIMIT_NOFILE, &rlim) == -1 {\n+                        Err(std::io::Error::last_os_error())\n+                    } else {\n+                        Ok(())\n+                    }\n+                })\n+            };\n+            let output = cmd.output().unwrap();\n+            println!(\"{:?}\", output);\n+            output.status.exit_ok().unwrap();\n+            assert!(output.stdout.starts_with(b\"Ok!\"));\n+        }\n+        Some(word) => {\n+            println!(\"{}\", word);\n+        }\n+    }\n+}"}]}