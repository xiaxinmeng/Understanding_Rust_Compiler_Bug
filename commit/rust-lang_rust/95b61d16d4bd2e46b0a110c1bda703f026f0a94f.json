{"sha": "95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "node_id": "C_kwDOAAsO6NoAKDk1YjYxZDE2ZDRiZDJlNDZiMGExMTBjMWJkYTcwM2YwMjZmMGE5NGY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-25T13:58:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-01-25T13:58:41Z"}, "message": "Auto merge of #107290 - Dylan-DPC:rollup-tovojhr, r=Dylan-DPC\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #105552 (Add help message about function pointers)\n - #106583 (Suggest coercion of `Result` using `?`)\n - #106767 (Allow setting CFG_DISABLE_UNSTABLE_FEATURES to 0)\n - #106823 (Allow fmt::Arguments::as_str() to return more Some(_).)\n - #107166 (rustc_metadata: Support non-`Option` nullable values in metadata tables)\n - #107213 (Add suggestion to remove if in let..else block)\n - #107223 (`sub_ptr()` is equivalent to `usize::try_from().unwrap_unchecked()`, not `usize::from().unwrap_unchecked()`)\n - #107227 (`new_outside_solver` ->  `evaluate_root_goal`)\n - #107232 (rustdoc: simplify settings popover DOM, CSS, JS)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "3978c65aa15a28b360d1428351911119b278aac3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3978c65aa15a28b360d1428351911119b278aac3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "html_url": "https://github.com/rust-lang/rust/commit/95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9467f9553197e1dab950bdc842fd407b0ac2d59b", "url": "https://api.github.com/repos/rust-lang/rust/commits/9467f9553197e1dab950bdc842fd407b0ac2d59b", "html_url": "https://github.com/rust-lang/rust/commit/9467f9553197e1dab950bdc842fd407b0ac2d59b"}, {"sha": "e78fa8a0bc522894c1233c338859f02bf1c6a31e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e78fa8a0bc522894c1233c338859f02bf1c6a31e", "html_url": "https://github.com/rust-lang/rust/commit/e78fa8a0bc522894c1233c338859f02bf1c6a31e"}], "stats": {"total": 1036, "additions": 752, "deletions": 284}, "files": [{"sha": "a3e2002da781c230eff39d72ab2452466bf118e2", "filename": "compiler/rustc_error_messages/locales/en-US/parse.ftl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fparse.ftl?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -238,6 +238,7 @@ parse_const_let_mutually_exclusive = `const` and `let` are mutually exclusive\n \n parse_invalid_expression_in_let_else = a `{$operator}` expression cannot be directly assigned in `let...else`\n parse_invalid_curly_in_let_else = right curly brace `{\"}\"}` before `else` in a `let...else` statement not allowed\n+parse_extra_if_in_let_else = remove the `if` if you meant to write a `let...else` statement\n \n parse_compound_assignment_expression_in_let = can't reassign to an uninitialized variable\n     .suggestion = initialize the variable"}, {"sha": "93d16716346915119dcf3213c27728293e73e20a", "filename": "compiler/rustc_feature/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_feature%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_feature%2Fsrc%2Flib.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -83,7 +83,8 @@ impl UnstableFeatures {\n     /// Otherwise, only `RUSTC_BOOTSTRAP=1` will work.\n     pub fn from_environment(krate: Option<&str>) -> Self {\n         // `true` if this is a feature-staged build, i.e., on the beta or stable channel.\n-        let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+        let disable_unstable_features =\n+            option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").map(|s| s != \"0\").unwrap_or(false);\n         // Returns whether `krate` should be counted as unstable\n         let is_unstable_crate = |var: &str| {\n             krate.map_or(false, |name| var.split(',').any(|new_krate| new_krate == name))"}, {"sha": "1a0715a91cb0c0e8718401a00987bc54803ae36a", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -1613,12 +1613,14 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 if visitor.ret_exprs.len() > 0 && let Some(expr) = expression {\n                     self.note_unreachable_loop_return(&mut err, &expr, &visitor.ret_exprs);\n                 }\n+\n                 let reported = err.emit_unless(unsized_return);\n \n                 self.final_ty = Some(fcx.tcx.ty_error_with_guaranteed(reported));\n             }\n         }\n     }\n+\n     fn note_unreachable_loop_return(\n         &self,\n         err: &mut Diagnostic,"}, {"sha": "7379e75963f532b5d6642b27d2b025b6cb739b30", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 52, "deletions": 2, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -59,7 +59,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             || self.suggest_copied_or_cloned(err, expr, expr_ty, expected)\n             || self.suggest_clone_for_ref(err, expr, expr_ty, expected)\n             || self.suggest_into(err, expr, expr_ty, expected)\n-            || self.suggest_floating_point_literal(err, expr, expected);\n+            || self.suggest_floating_point_literal(err, expr, expected)\n+            || self.note_result_coercion(err, expr, expected, expr_ty);\n         if !suggested {\n             self.point_at_expr_source_of_inferred_type(err, expr, expr_ty, expected);\n         }\n@@ -81,7 +82,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.annotate_expected_due_to_let_ty(err, expr, error);\n         self.emit_type_mismatch_suggestions(err, expr, expr_ty, expected, expected_ty_expr, error);\n         self.note_type_is_not_clone(err, expected, expr_ty, expr);\n-        self.note_need_for_fn_pointer(err, expected, expr_ty);\n         self.note_internal_mutation_in_method(err, expr, expected, expr_ty);\n         self.check_for_range_as_method_call(err, expr, expr_ty, expected);\n         self.check_for_binding_assigned_block_without_tail_expression(err, expr, expr_ty, expected);\n@@ -697,6 +697,56 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         );\n     }\n \n+    pub(crate) fn note_result_coercion(\n+        &self,\n+        err: &mut Diagnostic,\n+        expr: &hir::Expr<'tcx>,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) -> bool {\n+        let ty::Adt(e, substs_e) = expected.kind() else { return false; };\n+        let ty::Adt(f, substs_f) = found.kind() else { return false; };\n+        if e.did() != f.did() {\n+            return false;\n+        }\n+        if Some(e.did()) != self.tcx.get_diagnostic_item(sym::Result) {\n+            return false;\n+        }\n+        let map = self.tcx.hir();\n+        if let Some(hir::Node::Expr(expr)) = map.find_parent(expr.hir_id)\n+            && let hir::ExprKind::Ret(_) = expr.kind\n+        {\n+            // `return foo;`\n+        } else if map.get_return_block(expr.hir_id).is_some() {\n+            // Function's tail expression.\n+        } else {\n+            return false;\n+        }\n+        let e = substs_e.type_at(1);\n+        let f = substs_f.type_at(1);\n+        if self\n+            .infcx\n+            .type_implements_trait(\n+                self.tcx.get_diagnostic_item(sym::Into).unwrap(),\n+                [f, e],\n+                self.param_env,\n+            )\n+            .must_apply_modulo_regions()\n+        {\n+            err.multipart_suggestion(\n+                \"use `?` to coerce and return an appropriate `Err`, and wrap the resulting value \\\n+                 in `Ok` so the expression remains of type `Result`\",\n+                vec![\n+                    (expr.span.shrink_to_lo(), \"Ok(\".to_string()),\n+                    (expr.span.shrink_to_hi(), \"?)\".to_string()),\n+                ],\n+                Applicability::MaybeIncorrect,\n+            );\n+            return true;\n+        }\n+        false\n+    }\n+\n     /// If the expected type is an enum (Issue #55250) with any variants whose\n     /// sole field is of the found type, suggest such variants. (Issue #42764)\n     fn suggest_compatible_variants("}, {"sha": "e9858aef6d0bf4513ae81fed05775cbac54e353d", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -926,43 +926,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub(in super::super) fn note_need_for_fn_pointer(\n-        &self,\n-        err: &mut Diagnostic,\n-        expected: Ty<'tcx>,\n-        found: Ty<'tcx>,\n-    ) {\n-        let (sig, did, substs) = match (&expected.kind(), &found.kind()) {\n-            (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n-                let sig1 = self.tcx.bound_fn_sig(*did1).subst(self.tcx, substs1);\n-                let sig2 = self.tcx.bound_fn_sig(*did2).subst(self.tcx, substs2);\n-                if sig1 != sig2 {\n-                    return;\n-                }\n-                err.note(\n-                    \"different `fn` items always have unique types, even if their signatures are \\\n-                     the same\",\n-                );\n-                (sig1, *did1, substs1)\n-            }\n-            (ty::FnDef(did, substs), ty::FnPtr(sig2)) => {\n-                let sig1 = self.tcx.bound_fn_sig(*did).subst(self.tcx, substs);\n-                if sig1 != *sig2 {\n-                    return;\n-                }\n-                (sig1, *did, substs)\n-            }\n-            _ => return,\n-        };\n-        err.help(&format!(\"change the expected type to be function pointer `{}`\", sig));\n-        err.help(&format!(\n-            \"if the expected type is due to type inference, cast the expected `fn` to a function \\\n-             pointer: `{} as {}`\",\n-            self.tcx.def_path_str_with_substs(did, substs),\n-            sig\n-        ));\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     #[instrument(skip(self, span), level = \"debug\")]"}, {"sha": "212683a5429ed6449987a60cce82f7f2f316e602", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -1841,6 +1841,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                 self.suggest_as_ref_where_appropriate(span, &exp_found, diag);\n                 self.suggest_accessing_field_where_appropriate(cause, &exp_found, diag);\n                 self.suggest_await_on_expect_found(cause, span, &exp_found, diag);\n+                self.suggest_function_pointers(cause, span, &exp_found, diag);\n             }\n         }\n \n@@ -2585,7 +2586,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n     /// with the other type. A TyVar inference type is compatible with any type, and an IntVar or\n     /// FloatVar inference type are compatible with themselves or their concrete types (Int and\n     /// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n-    pub fn same_type_modulo_infer(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+    pub fn same_type_modulo_infer<T: relate::Relate<'tcx>>(&self, a: T, b: T) -> bool {\n         let (a, b) = self.resolve_vars_if_possible((a, b));\n         SameTypeModuloInfer(self).relate(a, b).is_ok()\n     }"}, {"sha": "b2ab39630bdaf1a5919669f499380989feb915f5", "filename": "compiler/rustc_infer/src/infer/error_reporting/suggest.rs", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fsuggest.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -8,7 +8,7 @@ use rustc_middle::traits::{\n     StatementAsExpression,\n };\n use rustc_middle::ty::print::with_no_trimmed_paths;\n-use rustc_middle::ty::{self as ty, Ty, TypeVisitable};\n+use rustc_middle::ty::{self as ty, IsSuggestable, Ty, TypeVisitable};\n use rustc_span::{sym, BytePos, Span};\n \n use crate::errors::SuggAddLetForLetChains;\n@@ -351,6 +351,82 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         }\n     }\n \n+    pub(super) fn suggest_function_pointers(\n+        &self,\n+        cause: &ObligationCause<'tcx>,\n+        span: Span,\n+        exp_found: &ty::error::ExpectedFound<Ty<'tcx>>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        debug!(\"suggest_function_pointers(cause={:?}, exp_found={:?})\", cause, exp_found);\n+        let ty::error::ExpectedFound { expected, found } = exp_found;\n+        let expected_inner = expected.peel_refs();\n+        let found_inner = found.peel_refs();\n+        if !expected_inner.is_fn() || !found_inner.is_fn() {\n+            return;\n+        }\n+        match (&expected_inner.kind(), &found_inner.kind()) {\n+            (ty::FnPtr(sig), ty::FnDef(did, substs)) => {\n+                let expected_sig = &(self.normalize_fn_sig)(*sig);\n+                let found_sig =\n+                    &(self.normalize_fn_sig)(self.tcx.bound_fn_sig(*did).subst(self.tcx, substs));\n+\n+                let fn_name = self.tcx.def_path_str_with_substs(*did, substs);\n+\n+                if !self.same_type_modulo_infer(*found_sig, *expected_sig)\n+                    || !sig.is_suggestable(self.tcx, true)\n+                    || ty::util::is_intrinsic(self.tcx, *did)\n+                {\n+                    return;\n+                }\n+\n+                let (msg, sugg) = match (expected.is_ref(), found.is_ref()) {\n+                    (true, false) => {\n+                        let msg = \"consider using a reference\";\n+                        let sug = format!(\"&{fn_name}\");\n+                        (msg, sug)\n+                    }\n+                    (false, true) => {\n+                        let msg = \"consider removing the reference\";\n+                        let sug = format!(\"{fn_name}\");\n+                        (msg, sug)\n+                    }\n+                    (true, true) => {\n+                        diag.note(\"fn items are distinct from fn pointers\");\n+                        let msg = \"consider casting to a fn pointer\";\n+                        let sug = format!(\"&({fn_name} as {sig})\");\n+                        (msg, sug)\n+                    }\n+                    (false, false) => {\n+                        diag.note(\"fn items are distinct from fn pointers\");\n+                        let msg = \"consider casting to a fn pointer\";\n+                        let sug = format!(\"{fn_name} as {sig}\");\n+                        (msg, sug)\n+                    }\n+                };\n+                diag.span_suggestion(span, msg, &sugg, Applicability::MaybeIncorrect);\n+            }\n+            (ty::FnDef(did1, substs1), ty::FnDef(did2, substs2)) => {\n+                let expected_sig =\n+                    &(self.normalize_fn_sig)(self.tcx.bound_fn_sig(*did1).subst(self.tcx, substs1));\n+                let found_sig =\n+                    &(self.normalize_fn_sig)(self.tcx.bound_fn_sig(*did2).subst(self.tcx, substs2));\n+\n+                if self.same_type_modulo_infer(*found_sig, *expected_sig) {\n+                    diag.note(\n+                    \"different fn items have unique types, even if their signatures are the same\",\n+                    );\n+                }\n+            }\n+            (ty::FnDef(_, _), ty::FnPtr(_)) => {\n+                diag.note(\"fn items are distinct from fn pointers\");\n+            }\n+            _ => {\n+                return;\n+            }\n+        };\n+    }\n+\n     pub fn should_suggest_as_ref(&self, expected: Ty<'tcx>, found: Ty<'tcx>) -> Option<&str> {\n         if let (ty::Adt(exp_def, exp_substs), ty::Ref(_, found_ty, _)) =\n             (expected.kind(), found.kind())"}, {"sha": "bb2dd290c6d5d1edef0ef7f26ae3f0bbb1793d69", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -985,7 +985,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         let vis = self.get_visibility(id);\n         let span = self.get_span(id, sess);\n         let macro_rules = match kind {\n-            DefKind::Macro(..) => self.root.tables.macro_rules.get(self, id).is_some(),\n+            DefKind::Macro(..) => self.root.tables.is_macro_rules.get(self, id),\n             _ => false,\n         };\n \n@@ -1283,7 +1283,7 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     fn get_macro(self, id: DefIndex, sess: &Session) -> ast::MacroDef {\n         match self.def_kind(id) {\n             DefKind::Macro(_) => {\n-                let macro_rules = self.root.tables.macro_rules.get(self, id).is_some();\n+                let macro_rules = self.root.tables.is_macro_rules.get(self, id);\n                 let body =\n                     self.root.tables.macro_definition.get(self, id).unwrap().decode((self, sess));\n                 ast::MacroDef { macro_rules, body: ast::ptr::P(body) }\n@@ -1595,11 +1595,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n     }\n \n     fn get_attr_flags(self, index: DefIndex) -> AttrFlags {\n-        self.root.tables.attr_flags.get(self, index).unwrap_or(AttrFlags::empty())\n+        self.root.tables.attr_flags.get(self, index)\n     }\n \n     fn get_is_intrinsic(self, index: DefIndex) -> bool {\n-        self.root.tables.is_intrinsic.get(self, index).is_some()\n+        self.root.tables.is_intrinsic.get(self, index)\n     }\n }\n "}, {"sha": "eebc2f21dfe4e8e4a79cc888f0aa41c8147d335e", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -226,12 +226,7 @@ provide! { tcx, def_id, other, cdata,\n     deduced_param_attrs => { table }\n     is_type_alias_impl_trait => {\n         debug_assert_eq!(tcx.def_kind(def_id), DefKind::OpaqueTy);\n-        cdata\n-            .root\n-            .tables\n-            .is_type_alias_impl_trait\n-            .get(cdata, def_id.index)\n-            .is_some()\n+        cdata.root.tables.is_type_alias_impl_trait.get(cdata, def_id.index)\n     }\n     collect_return_position_impl_trait_in_trait_tys => {\n         Ok(cdata"}, {"sha": "97f0457ba711677e0ea326bb1d099460da3672b9", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -483,7 +483,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         self.lazy(DefPathHashMapRef::BorrowedFromTcx(self.tcx.def_path_hash_to_def_index_map()))\n     }\n \n-    fn encode_source_map(&mut self) -> LazyTable<u32, LazyValue<rustc_span::SourceFile>> {\n+    fn encode_source_map(&mut self) -> LazyTable<u32, Option<LazyValue<rustc_span::SourceFile>>> {\n         let source_map = self.tcx.sess.source_map();\n         let all_source_files = source_map.files();\n \n@@ -1130,7 +1130,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             attr_flags |= AttrFlags::IS_DOC_HIDDEN;\n         }\n         if !attr_flags.is_empty() {\n-            self.tables.attr_flags.set(def_id.local_def_index, attr_flags);\n+            self.tables.attr_flags.set_nullable(def_id.local_def_index, attr_flags);\n         }\n     }\n \n@@ -1387,7 +1387,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         if impl_item.kind == ty::AssocKind::Fn {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set(def_id.index, ());\n+                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n             }\n         }\n     }\n@@ -1519,7 +1519,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n                 if macro_def.macro_rules {\n-                    self.tables.macro_rules.set(def_id.index, ());\n+                    self.tables.is_macro_rules.set_nullable(def_id.index, true);\n                 }\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n@@ -1529,7 +1529,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             hir::ItemKind::OpaqueTy(ref opaque) => {\n                 self.encode_explicit_item_bounds(def_id);\n                 if matches!(opaque.origin, hir::OpaqueTyOrigin::TyAlias) {\n-                    self.tables.is_type_alias_impl_trait.set(def_id.index, ());\n+                    self.tables.is_type_alias_impl_trait.set_nullable(def_id.index, true);\n                 }\n             }\n             hir::ItemKind::Enum(..) => {\n@@ -1636,7 +1636,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         if let hir::ItemKind::Fn(..) = item.kind {\n             record!(self.tables.fn_sig[def_id] <- tcx.fn_sig(def_id));\n             if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set(def_id.index, ());\n+                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n             }\n         }\n         if let hir::ItemKind::Impl { .. } = item.kind {\n@@ -2038,7 +2038,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n         if let hir::ForeignItemKind::Fn(..) = nitem.kind {\n             if tcx.is_intrinsic(def_id) {\n-                self.tables.is_intrinsic.set(def_id.index, ());\n+                self.tables.is_intrinsic.set_nullable(def_id.index, true);\n             }\n         }\n     }"}, {"sha": "698b2ebc4732a0d0d66c60bc8a1277b973a30b46", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -185,9 +185,9 @@ enum LazyState {\n     Previous(NonZeroUsize),\n }\n \n-type SyntaxContextTable = LazyTable<u32, LazyValue<SyntaxContextData>>;\n-type ExpnDataTable = LazyTable<ExpnIndex, LazyValue<ExpnData>>;\n-type ExpnHashTable = LazyTable<ExpnIndex, LazyValue<ExpnHash>>;\n+type SyntaxContextTable = LazyTable<u32, Option<LazyValue<SyntaxContextData>>>;\n+type ExpnDataTable = LazyTable<ExpnIndex, Option<LazyValue<ExpnData>>>;\n+type ExpnHashTable = LazyTable<ExpnIndex, Option<LazyValue<ExpnHash>>>;\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n pub(crate) struct ProcMacroData {\n@@ -253,7 +253,7 @@ pub(crate) struct CrateRoot {\n \n     def_path_hash_map: LazyValue<DefPathHashMapRef<'static>>,\n \n-    source_map: LazyTable<u32, LazyValue<rustc_span::SourceFile>>,\n+    source_map: LazyTable<u32, Option<LazyValue<rustc_span::SourceFile>>>,\n \n     compiler_builtins: bool,\n     needs_allocator: bool,\n@@ -315,31 +315,43 @@ pub(crate) struct IncoherentImpls {\n \n /// Define `LazyTables` and `TableBuilders` at the same time.\n macro_rules! define_tables {\n-    ($($name:ident: Table<$IDX:ty, $T:ty>),+ $(,)?) => {\n+    (\n+        - nullable: $($name1:ident: Table<$IDX1:ty, $T1:ty>,)+\n+        - optional: $($name2:ident: Table<$IDX2:ty, $T2:ty>,)+\n+    ) => {\n         #[derive(MetadataEncodable, MetadataDecodable)]\n         pub(crate) struct LazyTables {\n-            $($name: LazyTable<$IDX, $T>),+\n+            $($name1: LazyTable<$IDX1, $T1>,)+\n+            $($name2: LazyTable<$IDX2, Option<$T2>>,)+\n         }\n \n         #[derive(Default)]\n         struct TableBuilders {\n-            $($name: TableBuilder<$IDX, $T>),+\n+            $($name1: TableBuilder<$IDX1, $T1>,)+\n+            $($name2: TableBuilder<$IDX2, Option<$T2>>,)+\n         }\n \n         impl TableBuilders {\n             fn encode(&self, buf: &mut FileEncoder) -> LazyTables {\n                 LazyTables {\n-                    $($name: self.$name.encode(buf)),+\n+                    $($name1: self.$name1.encode(buf),)+\n+                    $($name2: self.$name2.encode(buf),)+\n                 }\n             }\n         }\n     }\n }\n \n define_tables! {\n+- nullable:\n+    is_intrinsic: Table<DefIndex, bool>,\n+    is_macro_rules: Table<DefIndex, bool>,\n+    is_type_alias_impl_trait: Table<DefIndex, bool>,\n+    attr_flags: Table<DefIndex, AttrFlags>,\n+\n+- optional:\n     attributes: Table<DefIndex, LazyArray<ast::Attribute>>,\n     children: Table<DefIndex, LazyArray<DefIndex>>,\n-\n     opt_def_kind: Table<DefIndex, DefKind>,\n     visibility: Table<DefIndex, LazyValue<ty::Visibility<DefIndex>>>,\n     def_span: Table<DefIndex, LazyValue<Span>>,\n@@ -370,7 +382,6 @@ define_tables! {\n     impl_parent: Table<DefIndex, RawDefId>,\n     impl_polarity: Table<DefIndex, ty::ImplPolarity>,\n     constness: Table<DefIndex, hir::Constness>,\n-    is_intrinsic: Table<DefIndex, ()>,\n     impl_defaultness: Table<DefIndex, hir::Defaultness>,\n     // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n     coerce_unsized_info: Table<DefIndex, LazyValue<ty::adjustment::CoerceUnsizedInfo>>,\n@@ -380,7 +391,6 @@ define_tables! {\n     fn_arg_names: Table<DefIndex, LazyArray<Ident>>,\n     generator_kind: Table<DefIndex, LazyValue<hir::GeneratorKind>>,\n     trait_def: Table<DefIndex, LazyValue<ty::TraitDef>>,\n-\n     trait_item_def_id: Table<DefIndex, RawDefId>,\n     inherent_impls: Table<DefIndex, LazyArray<DefIndex>>,\n     expn_that_defined: Table<DefIndex, LazyValue<ExpnId>>,\n@@ -395,18 +405,12 @@ define_tables! {\n     def_path_hashes: Table<DefIndex, DefPathHash>,\n     proc_macro_quoted_spans: Table<usize, LazyValue<Span>>,\n     generator_diagnostic_data: Table<DefIndex, LazyValue<GeneratorDiagnosticData<'static>>>,\n-    attr_flags: Table<DefIndex, AttrFlags>,\n     variant_data: Table<DefIndex, LazyValue<VariantData>>,\n     assoc_container: Table<DefIndex, ty::AssocItemContainer>,\n-    // Slot is full when macro is macro_rules.\n-    macro_rules: Table<DefIndex, ()>,\n     macro_definition: Table<DefIndex, LazyValue<ast::DelimArgs>>,\n     proc_macro: Table<DefIndex, MacroKind>,\n     module_reexports: Table<DefIndex, LazyArray<ModChild>>,\n     deduced_param_attrs: Table<DefIndex, LazyArray<DeducedParamAttrs>>,\n-    // Slot is full when opaque is TAIT.\n-    is_type_alias_impl_trait: Table<DefIndex, ()>,\n-\n     trait_impl_trait_tys: Table<DefIndex, LazyValue<FxHashMap<DefId, Ty<'static>>>>,\n }\n \n@@ -419,6 +423,7 @@ struct VariantData {\n }\n \n bitflags::bitflags! {\n+    #[derive(Default)]\n     pub struct AttrFlags: u8 {\n         const MAY_HAVE_DOC_LINKS = 1 << 0;\n         const IS_DOC_HIDDEN      = 1 << 1;"}, {"sha": "70dbf6476e2fab40d8c4a89b575528b3bd3f6f6b", "filename": "compiler/rustc_metadata/src/rmeta/table.rs", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Ftable.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -16,6 +16,7 @@ use std::num::NonZeroUsize;\n /// but this has no impact on safety.\n pub(super) trait FixedSizeEncoding: Default {\n     /// This should be `[u8; BYTE_LEN]`;\n+    /// Cannot use an associated `const BYTE_LEN: usize` instead due to const eval limitations.\n     type ByteArray;\n \n     fn from_bytes(b: &Self::ByteArray) -> Self;\n@@ -199,31 +200,31 @@ impl FixedSizeEncoding for Option<RawDefId> {\n     }\n }\n \n-impl FixedSizeEncoding for Option<AttrFlags> {\n+impl FixedSizeEncoding for AttrFlags {\n     type ByteArray = [u8; 1];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 1]) -> Self {\n-        (b[0] != 0).then(|| AttrFlags::from_bits_truncate(b[0]))\n+        AttrFlags::from_bits_truncate(b[0])\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n-        b[0] = self.map_or(0, |flags| flags.bits())\n+        b[0] = self.bits();\n     }\n }\n \n-impl FixedSizeEncoding for Option<()> {\n+impl FixedSizeEncoding for bool {\n     type ByteArray = [u8; 1];\n \n     #[inline]\n     fn from_bytes(b: &[u8; 1]) -> Self {\n-        (b[0] != 0).then(|| ())\n+        b[0] != 0\n     }\n \n     #[inline]\n     fn write_to_bytes(self, b: &mut [u8; 1]) {\n-        b[0] = self.is_some() as u8\n+        b[0] = self as u8\n     }\n }\n \n@@ -273,44 +274,38 @@ impl<T> FixedSizeEncoding for Option<LazyArray<T>> {\n }\n \n /// Helper for constructing a table's serialization (also see `Table`).\n-pub(super) struct TableBuilder<I: Idx, T>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n-    blocks: IndexVec<I, <Option<T> as FixedSizeEncoding>::ByteArray>,\n+pub(super) struct TableBuilder<I: Idx, T: FixedSizeEncoding> {\n+    blocks: IndexVec<I, T::ByteArray>,\n     _marker: PhantomData<T>,\n }\n \n-impl<I: Idx, T> Default for TableBuilder<I, T>\n-where\n-    Option<T>: FixedSizeEncoding,\n-{\n+impl<I: Idx, T: FixedSizeEncoding> Default for TableBuilder<I, T> {\n     fn default() -> Self {\n         TableBuilder { blocks: Default::default(), _marker: PhantomData }\n     }\n }\n \n-impl<I: Idx, T> TableBuilder<I, T>\n+impl<I: Idx, const N: usize, T> TableBuilder<I, Option<T>>\n where\n-    Option<T>: FixedSizeEncoding,\n+    Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n {\n-    pub(crate) fn set<const N: usize>(&mut self, i: I, value: T)\n-    where\n-        Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(crate) fn set(&mut self, i: I, value: T) {\n+        self.set_nullable(i, Some(value))\n+    }\n+}\n+\n+impl<I: Idx, const N: usize, T: FixedSizeEncoding<ByteArray = [u8; N]>> TableBuilder<I, T> {\n+    pub(crate) fn set_nullable(&mut self, i: I, value: T) {\n         // FIXME(eddyb) investigate more compact encodings for sparse tables.\n         // On the PR @michaelwoerister mentioned:\n         // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n         // > trick (i.e. divide things into buckets of 32 or 64 items and then\n         // > store bit-masks of which item in each bucket is actually serialized).\n         self.blocks.ensure_contains_elem(i, || [0; N]);\n-        Some(value).write_to_bytes(&mut self.blocks[i]);\n+        value.write_to_bytes(&mut self.blocks[i]);\n     }\n \n-    pub(crate) fn encode<const N: usize>(&self, buf: &mut FileEncoder) -> LazyTable<I, T>\n-    where\n-        Option<T>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(crate) fn encode(&self, buf: &mut FileEncoder) -> LazyTable<I, T> {\n         let pos = buf.position();\n         for block in &self.blocks {\n             buf.emit_raw_bytes(block);\n@@ -323,34 +318,27 @@ where\n     }\n }\n \n-impl<I: Idx, T: ParameterizedOverTcx> LazyTable<I, T>\n+impl<I: Idx, const N: usize, T: FixedSizeEncoding<ByteArray = [u8; N]> + ParameterizedOverTcx>\n+    LazyTable<I, T>\n where\n-    Option<T>: FixedSizeEncoding,\n+    for<'tcx> T::Value<'tcx>: FixedSizeEncoding<ByteArray = [u8; N]>,\n {\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n-    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>, const N: usize>(\n-        &self,\n-        metadata: M,\n-        i: I,\n-    ) -> Option<T::Value<'tcx>>\n-    where\n-        Option<T::Value<'tcx>>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(&self, metadata: M, i: I) -> T::Value<'tcx> {\n         debug!(\"LazyTable::lookup: index={:?} len={:?}\", i, self.encoded_size);\n \n         let start = self.position.get();\n         let bytes = &metadata.blob()[start..start + self.encoded_size];\n         let (bytes, []) = bytes.as_chunks::<N>() else { panic!() };\n-        let bytes = bytes.get(i.index())?;\n-        FixedSizeEncoding::from_bytes(bytes)\n+        match bytes.get(i.index()) {\n+            Some(bytes) => FixedSizeEncoding::from_bytes(bytes),\n+            None => FixedSizeEncoding::from_bytes(&[0; N]),\n+        }\n     }\n \n     /// Size of the table in entries, including possible gaps.\n-    pub(super) fn size<const N: usize>(&self) -> usize\n-    where\n-        for<'tcx> Option<T::Value<'tcx>>: FixedSizeEncoding<ByteArray = [u8; N]>,\n-    {\n+    pub(super) fn size(&self) -> usize {\n         self.encoded_size / N\n     }\n }"}, {"sha": "40763da0bb5470ce20924fd76da86713e47e21dd", "filename": "compiler/rustc_parse/src/errors.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Ferrors.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -337,7 +337,9 @@ pub(crate) struct IfExpressionMissingThenBlock {\n     #[primary_span]\n     pub if_span: Span,\n     #[subdiagnostic]\n-    pub sub: IfExpressionMissingThenBlockSub,\n+    pub missing_then_block_sub: IfExpressionMissingThenBlockSub,\n+    #[subdiagnostic]\n+    pub let_else_sub: Option<IfExpressionLetSomeSub>,\n }\n \n #[derive(Subdiagnostic)]\n@@ -348,6 +350,13 @@ pub(crate) enum IfExpressionMissingThenBlockSub {\n     AddThenBlock(#[primary_span] Span),\n }\n \n+#[derive(Subdiagnostic)]\n+#[help(parse_extra_if_in_let_else)]\n+pub(crate) struct IfExpressionLetSomeSub {\n+    #[primary_span]\n+    pub if_span: Span,\n+}\n+\n #[derive(Diagnostic)]\n #[diag(parse_if_expression_missing_condition)]\n pub(crate) struct IfExpressionMissingCondition {"}, {"sha": "3225a309a319b6286ce8baf02c8a3dd63a23a4cb", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -11,15 +11,15 @@ use crate::errors::{\n     ComparisonOrShiftInterpretedAsGenericSugg, DoCatchSyntaxRemoved, DotDotDot, EqFieldInit,\n     ExpectedElseBlock, ExpectedEqForLetExpr, ExpectedExpressionFoundLet,\n     FieldExpressionWithGeneric, FloatLiteralRequiresIntegerPart, FoundExprWouldBeStmt,\n-    IfExpressionMissingCondition, IfExpressionMissingThenBlock, IfExpressionMissingThenBlockSub,\n-    InvalidBlockMacroSegment, InvalidComparisonOperator, InvalidComparisonOperatorSub,\n-    InvalidInterpolatedExpression, InvalidLiteralSuffixOnTupleIndex, InvalidLogicalOperator,\n-    InvalidLogicalOperatorSub, LabeledLoopInBreak, LeadingPlusNotSupported, LeftArrowOperator,\n-    LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath, MalformedLoopLabel,\n-    MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg, MissingCommaAfterMatchArm,\n-    MissingDotDot, MissingInInForLoop, MissingInInForLoopSub, MissingSemicolonBeforeArray,\n-    NoFieldsForFnCall, NotAsNegationOperator, NotAsNegationOperatorSub,\n-    OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n+    IfExpressionLetSomeSub, IfExpressionMissingCondition, IfExpressionMissingThenBlock,\n+    IfExpressionMissingThenBlockSub, InvalidBlockMacroSegment, InvalidComparisonOperator,\n+    InvalidComparisonOperatorSub, InvalidInterpolatedExpression, InvalidLiteralSuffixOnTupleIndex,\n+    InvalidLogicalOperator, InvalidLogicalOperatorSub, LabeledLoopInBreak, LeadingPlusNotSupported,\n+    LeftArrowOperator, LifetimeInBorrowExpression, MacroInvocationWithQualifiedPath,\n+    MalformedLoopLabel, MatchArmBodyWithoutBraces, MatchArmBodyWithoutBracesSugg,\n+    MissingCommaAfterMatchArm, MissingDotDot, MissingInInForLoop, MissingInInForLoopSub,\n+    MissingSemicolonBeforeArray, NoFieldsForFnCall, NotAsNegationOperator,\n+    NotAsNegationOperatorSub, OuterAttributeNotAllowedOnIfElse, ParenthesesWithStructFields,\n     RequireColonAfterLabeledExpression, ShiftInterpretedAsGeneric, StructLiteralNotAllowedHere,\n     StructLiteralNotAllowedHereSugg, TildeAsUnaryOperator, UnexpectedIfWithIf,\n     UnexpectedTokenAfterLabel, UnexpectedTokenAfterLabelSugg, WrapExpressionInParentheses,\n@@ -2251,9 +2251,10 @@ impl<'a> Parser<'a> {\n                     if let ExprKind::Block(_, None) = right.kind => {\n                         self.sess.emit_err(IfExpressionMissingThenBlock {\n                             if_span: lo,\n-                            sub: IfExpressionMissingThenBlockSub::UnfinishedCondition(\n-                                cond_span.shrink_to_lo().to(*binop_span)\n-                            ),\n+                            missing_then_block_sub:\n+                                IfExpressionMissingThenBlockSub::UnfinishedCondition(cond_span.shrink_to_lo().to(*binop_span)),\n+                                let_else_sub: None,\n+\n                         });\n                         std::mem::replace(right, this.mk_expr_err(binop_span.shrink_to_hi()))\n                     },\n@@ -2279,9 +2280,15 @@ impl<'a> Parser<'a> {\n             if let Some(block) = recover_block_from_condition(self) {\n                 block\n             } else {\n+                let let_else_sub = matches!(cond.kind, ExprKind::Let(..))\n+                    .then(|| IfExpressionLetSomeSub { if_span: lo });\n+\n                 self.sess.emit_err(IfExpressionMissingThenBlock {\n                     if_span: lo,\n-                    sub: IfExpressionMissingThenBlockSub::AddThenBlock(cond_span.shrink_to_hi()),\n+                    missing_then_block_sub: IfExpressionMissingThenBlockSub::AddThenBlock(\n+                        cond_span.shrink_to_hi(),\n+                    ),\n+                    let_else_sub,\n                 });\n                 self.mk_block_err(cond_span.shrink_to_hi())\n             }"}, {"sha": "d59fa71406c31197c75a4bedbe1545463f302b8a", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -1,5 +1,6 @@\n use std::mem;\n \n+use super::{Certainty, InferCtxtEvalExt};\n use rustc_infer::{\n     infer::InferCtxt,\n     traits::{\n@@ -8,8 +9,6 @@ use rustc_infer::{\n     },\n };\n \n-use super::{search_graph, Certainty, EvalCtxt};\n-\n /// A trait engine using the new trait solver.\n ///\n /// This is mostly identical to how `evaluate_all` works inside of the\n@@ -66,9 +65,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n             let mut has_changed = false;\n             for obligation in mem::take(&mut self.obligations) {\n                 let goal = obligation.clone().into();\n-                let search_graph = &mut search_graph::SearchGraph::new(infcx.tcx);\n-                let mut ecx = EvalCtxt::new_outside_solver(infcx, search_graph);\n-                let (changed, certainty) = match ecx.evaluate_goal(goal) {\n+                let (changed, certainty) = match infcx.evaluate_root_goal(goal) {\n                     Ok(result) => result,\n                     Err(NoSolution) => {\n                         errors.push(FulfillmentError {"}, {"sha": "70f094014453edfcca6960ef8a09c64a5ab4798f", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -152,6 +152,36 @@ impl<'tcx> TyCtxtExt<'tcx> for TyCtxt<'tcx> {\n     }\n }\n \n+pub trait InferCtxtEvalExt<'tcx> {\n+    /// Evaluates a goal from **outside** of the trait solver.\n+    ///\n+    /// Using this while inside of the solver is wrong as it uses a new\n+    /// search graph which would break cycle detection.\n+    fn evaluate_root_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution>;\n+}\n+\n+impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n+    fn evaluate_root_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut search_graph = search_graph::SearchGraph::new(self.tcx);\n+\n+        let result = EvalCtxt {\n+            search_graph: &mut search_graph,\n+            infcx: self,\n+            var_values: CanonicalVarValues::dummy(),\n+        }\n+        .evaluate_goal(goal);\n+\n+        assert!(search_graph.is_empty());\n+        result\n+    }\n+}\n+\n struct EvalCtxt<'a, 'tcx> {\n     infcx: &'a InferCtxt<'tcx>,\n     var_values: CanonicalVarValues<'tcx>,\n@@ -164,18 +194,6 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         self.infcx.tcx\n     }\n \n-    /// Creates a new evaluation context outside of the trait solver.\n-    ///\n-    /// With this solver making a canonical response doesn't make much sense.\n-    /// The `search_graph` for this solver has to be completely empty.\n-    fn new_outside_solver(\n-        infcx: &'a InferCtxt<'tcx>,\n-        search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n-    ) -> EvalCtxt<'a, 'tcx> {\n-        assert!(search_graph.is_empty());\n-        EvalCtxt { infcx, var_values: CanonicalVarValues::dummy(), search_graph }\n-    }\n-\n     #[instrument(level = \"debug\", skip(tcx, search_graph), ret)]\n     fn evaluate_canonical_goal(\n         tcx: TyCtxt<'tcx>,"}, {"sha": "0145ba5e3cde63815a4c80a7b76bfc91873fbb0b", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -489,9 +489,26 @@ pub struct Arguments<'a> {\n }\n \n impl<'a> Arguments<'a> {\n-    /// Get the formatted string, if it has no arguments to be formatted.\n+    /// Get the formatted string, if it has no arguments to be formatted at runtime.\n     ///\n-    /// This can be used to avoid allocations in the most trivial case.\n+    /// This can be used to avoid allocations in some cases.\n+    ///\n+    /// # Guarantees\n+    ///\n+    /// For `format_args!(\"just a literal\")`, this function is guaranteed to\n+    /// return `Some(\"just a literal\")`.\n+    ///\n+    /// For most cases with placeholders, this function will return `None`.\n+    ///\n+    /// However, the compiler may perform optimizations that can cause this\n+    /// function to return `Some(_)` even if the format string contains\n+    /// placeholders. For example, `format_args!(\"Hello, {}!\", \"world\")` may be\n+    /// optimized to `format_args!(\"Hello, world!\")`, such that `as_str()`\n+    /// returns `Some(\"Hello, world!\")`.\n+    ///\n+    /// The behavior for anything but the trivial case (without placeholders)\n+    /// is not guaranteed, and should not be relied upon for anything other\n+    /// than optimization.\n     ///\n     /// # Examples\n     ///\n@@ -512,7 +529,7 @@ impl<'a> Arguments<'a> {\n     /// ```rust\n     /// assert_eq!(format_args!(\"hello\").as_str(), Some(\"hello\"));\n     /// assert_eq!(format_args!(\"\").as_str(), Some(\"\"));\n-    /// assert_eq!(format_args!(\"{}\", 1).as_str(), None);\n+    /// assert_eq!(format_args!(\"{:?}\", std::env::current_dir()).as_str(), None);\n     /// ```\n     #[stable(feature = \"fmt_as_str\", since = \"1.52.0\")]\n     #[rustc_const_unstable(feature = \"const_arguments_as_str\", issue = \"103900\")]"}, {"sha": "16eb726f6f61476294d3271abdbd21d4c3b00602", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -731,7 +731,7 @@ impl<T: ?Sized> *const T {\n     /// This computes the same value that [`offset_from`](#method.offset_from)\n     /// would compute, but with the added precondition that the offset is\n     /// guaranteed to be non-negative.  This method is equivalent to\n-    /// `usize::from(self.offset_from(origin)).unwrap_unchecked()`,\n+    /// `usize::try_from(self.offset_from(origin)).unwrap_unchecked()`,\n     /// but it provides slightly more information to the optimizer, which can\n     /// sometimes allow it to optimize slightly better with some backends.\n     ///"}, {"sha": "0a2f63e3ec6a5fb1ecce6845f442790d1cfa7c4d", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -904,7 +904,7 @@ impl<T: ?Sized> *mut T {\n     /// This computes the same value that [`offset_from`](#method.offset_from)\n     /// would compute, but with the added precondition that the offset is\n     /// guaranteed to be non-negative.  This method is equivalent to\n-    /// `usize::from(self.offset_from(origin)).unwrap_unchecked()`,\n+    /// `usize::try_from(self.offset_from(origin)).unwrap_unchecked()`,\n     /// but it provides slightly more information to the optimizer, which can\n     /// sometimes allow it to optimize slightly better with some backends.\n     ///"}, {"sha": "9d22ebbee873bab9b680fd37e9fde055e932c3c6", "filename": "library/test/src/cli.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/library%2Ftest%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/library%2Ftest%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Ftest%2Fsrc%2Fcli.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -309,7 +309,8 @@ fn parse_opts_impl(matches: getopts::Matches) -> OptRes {\n // FIXME: Copied from librustc_ast until linkage errors are resolved. Issue #47566\n fn is_nightly() -> bool {\n     // Whether this is a feature-staged build, i.e., on the beta or stable channel\n-    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+    let disable_unstable_features =\n+        option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").map(|s| s != \"0\").unwrap_or(false);\n     // Whether we should enable unstable features for bootstrapping\n     let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n "}, {"sha": "c28cefebc8bf5fccf3796a295959267f6a945810", "filename": "src/librustdoc/html/static/css/settings.css", "status": "modified", "additions": 12, "deletions": 16, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -3,8 +3,7 @@\n \tposition: relative;\n }\n \n-.setting-line .radio-line input,\n-.setting-line .settings-toggle input {\n+.setting-radio input, .setting-check input {\n \tmargin-right: 0.3em;\n \theight: 1.2rem;\n \twidth: 1.2rem;\n@@ -14,21 +13,20 @@\n \t-webkit-appearance: none;\n \tcursor: pointer;\n }\n-.setting-line .radio-line input {\n+.setting-radio input {\n \tborder-radius: 50%;\n }\n-.setting-line .settings-toggle input:checked {\n+.setting-check input:checked {\n \tcontent: url('data:image/svg+xml,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 40 40\">\\\n \t\t<path d=\"M7,25L17,32L33,12\" fill=\"none\" stroke=\"black\" stroke-width=\"5\"/>\\\n \t\t<path d=\"M7,23L17,30L33,10\" fill=\"none\" stroke=\"white\" stroke-width=\"5\"/></svg>');\n }\n \n-.setting-line .radio-line input + span,\n-.setting-line .settings-toggle span {\n+.setting-radio span, .setting-check span {\n \tpadding-bottom: 1px;\n }\n \n-.radio-line .choice {\n+.setting-radio {\n \tmargin-top: 0.1em;\n \tmargin-bottom: 0.1em;\n \tmin-width: 3.8em;\n@@ -37,11 +35,11 @@\n \talign-items: center;\n \tcursor: pointer;\n }\n-.radio-line .choice + .choice {\n+.setting-radio + .setting-radio {\n \tmargin-left: 0.5em;\n }\n \n-.settings-toggle {\n+.setting-check {\n \tposition: relative;\n \twidth: 100%;\n \tmargin-right: 20px;\n@@ -50,23 +48,21 @@\n \tcursor: pointer;\n }\n \n-.setting-line .radio-line input:checked {\n+.setting-radio input:checked {\n \tbox-shadow: inset 0 0 0 3px var(--main-background-color);\n \tbackground-color: var(--settings-input-color);\n }\n-.setting-line .settings-toggle input:checked {\n+.setting-check input:checked {\n \tbackground-color: var(--settings-input-color);\n }\n-.setting-line .radio-line input:focus,\n-.setting-line .settings-toggle input:focus {\n+.setting-radio input:focus, .setting-check input:focus {\n \tbox-shadow: 0 0 1px 1px var(--settings-input-color);\n }\n /* In here we combine both `:focus` and `:checked` properties. */\n-.setting-line .radio-line input:checked:focus {\n+.setting-radio input:checked:focus {\n \tbox-shadow: inset 0 0 0 3px var(--main-background-color),\n \t\t0 0 2px 2px var(--settings-input-color);\n }\n-.setting-line .radio-line input:hover,\n-.setting-line .settings-toggle input:hover {\n+.setting-radio input:hover, .setting-check input:hover {\n \tborder-color: var(--settings-input-color) !important;\n }"}, {"sha": "a841b4b63bae8c1c557fd29475bcb6f016144380", "filename": "src/librustdoc/html/static/js/settings.js", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsettings.js?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -48,13 +48,13 @@\n     }\n \n     function showLightAndDark() {\n-        removeClass(document.getElementById(\"preferred-light-theme\").parentElement, \"hidden\");\n-        removeClass(document.getElementById(\"preferred-dark-theme\").parentElement, \"hidden\");\n+        removeClass(document.getElementById(\"preferred-light-theme\"), \"hidden\");\n+        removeClass(document.getElementById(\"preferred-dark-theme\"), \"hidden\");\n     }\n \n     function hideLightAndDark() {\n-        addClass(document.getElementById(\"preferred-light-theme\").parentElement, \"hidden\");\n-        addClass(document.getElementById(\"preferred-dark-theme\").parentElement, \"hidden\");\n+        addClass(document.getElementById(\"preferred-light-theme\"), \"hidden\");\n+        addClass(document.getElementById(\"preferred-dark-theme\"), \"hidden\");\n     }\n \n     function updateLightAndDark() {\n@@ -80,17 +80,6 @@\n             toggle.onkeyup = handleKey;\n             toggle.onkeyrelease = handleKey;\n         });\n-        onEachLazy(settingsElement.getElementsByClassName(\"select-wrapper\"), elem => {\n-            const select = elem.getElementsByTagName(\"select\")[0];\n-            const settingId = select.id;\n-            const settingValue = getSettingValue(settingId);\n-            if (settingValue !== null) {\n-                select.value = settingValue;\n-            }\n-            select.onchange = function() {\n-                changeSetting(this.id, this.value);\n-            };\n-        });\n         onEachLazy(settingsElement.querySelectorAll(\"input[type=\\\"radio\\\"]\"), elem => {\n             const settingId = elem.name;\n             let settingValue = getSettingValue(settingId);\n@@ -127,38 +116,40 @@\n         let output = \"\";\n \n         for (const setting of settings) {\n-            output += \"<div class=\\\"setting-line\\\">\";\n             const js_data_name = setting[\"js_name\"];\n             const setting_name = setting[\"name\"];\n \n             if (setting[\"options\"] !== undefined) {\n                 // This is a select setting.\n                 output += `\\\n-<div class=\"radio-line\" id=\"${js_data_name}\">\n-    <div class=\"setting-name\">${setting_name}</div>\n-<div class=\"choices\">`;\n+<div class=\"setting-line\" id=\"${js_data_name}\">\n+    <div class=\"setting-radio-name\">${setting_name}</div>\n+    <div class=\"setting-radio-choices\">`;\n                 onEach(setting[\"options\"], option => {\n                     const checked = option === setting[\"default\"] ? \" checked\" : \"\";\n                     const full = `${js_data_name}-${option.replace(/ /g,\"-\")}`;\n \n                     output += `\\\n-<label for=\"${full}\" class=\"choice\">\n-    <input type=\"radio\" name=\"${js_data_name}\"\n-        id=\"${full}\" value=\"${option}\"${checked}>\n-    <span>${option}</span>\n-</label>`;\n+        <label for=\"${full}\" class=\"setting-radio\">\n+            <input type=\"radio\" name=\"${js_data_name}\"\n+                id=\"${full}\" value=\"${option}\"${checked}>\n+            <span>${option}</span>\n+        </label>`;\n                 });\n-                output += \"</div></div>\";\n+                output += `\\\n+    </div>\n+</div>`;\n             } else {\n                 // This is a checkbox toggle.\n                 const checked = setting[\"default\"] === true ? \" checked\" : \"\";\n                 output += `\\\n-<label class=\"settings-toggle\">\\\n-    <input type=\"checkbox\" id=\"${js_data_name}\"${checked}>\\\n-    <span class=\"label\">${setting_name}</span>\\\n-</label>`;\n+<div class=\"setting-line\">\\\n+    <label class=\"setting-check\">\\\n+        <input type=\"checkbox\" id=\"${js_data_name}\"${checked}>\\\n+        <span>${setting_name}</span>\\\n+    </label>\\\n+</div>`;\n             }\n-            output += \"</div>\";\n         }\n         return output;\n     }"}, {"sha": "3e444cbd6dc9985bcab38905b01d3e62f9fa6cb8", "filename": "tests/rustdoc-gui/mobile.goml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Frustdoc-gui%2Fmobile.goml", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Frustdoc-gui%2Fmobile.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fmobile.goml?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -28,7 +28,7 @@ goto: \"file://\" + |DOC_PATH| + \"/settings.html\"\n size: (400, 600)\n // Ignored for now https://github.com/rust-lang/rust/issues/93784.\n // compare-elements-position-near-false: (\n-//     \"#preferred-light-theme .setting-name\",\n-//     \"#preferred-light-theme .choice\",\n+//     \"#preferred-light-theme .setting-radio-name\",\n+//     \"#preferred-light-theme .setting-radio\",\n //     {\"y\": 16},\n // )"}, {"sha": "a84172885780856b3927b12a212ceb2666f9da68", "filename": "tests/rustdoc-gui/settings.goml", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Frustdoc-gui%2Fsettings.goml", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Frustdoc-gui%2Fsettings.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Fsettings.goml?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -43,12 +43,12 @@ wait-for: \"#settings\"\n // We check that the \"Use system theme\" is disabled.\n assert-property: (\"#theme-system-preference\", {\"checked\": \"false\"})\n // Meaning that only the \"theme\" menu is showing up.\n-assert: \".setting-line:not(.hidden) #theme\"\n-assert: \".setting-line.hidden #preferred-dark-theme\"\n-assert: \".setting-line.hidden #preferred-light-theme\"\n+assert: \"#theme.setting-line:not(.hidden)\"\n+assert: \"#preferred-dark-theme.setting-line.hidden\"\n+assert: \"#preferred-light-theme.setting-line.hidden\"\n \n // We check that the correct theme is selected.\n-assert-property: (\"#theme .choices #theme-dark\", {\"checked\": \"true\"})\n+assert-property: (\"#theme .setting-radio-choices #theme-dark\", {\"checked\": \"true\"})\n \n // Some style checks...\n move-cursor-to: \"#settings-menu > a\"\n@@ -109,31 +109,31 @@ assert-css: (\n         \"box-shadow\": \"rgb(33, 150, 243) 0px 0px 1px 1px\",\n     },\n )\n-// Now we check the setting-name for radio buttons is on a different line than the label.\n+// Now we check the setting-radio-name is on a different line than the label.\n compare-elements-position-near: (\n-    \"#theme .setting-name\",\n-    \"#theme .choices\",\n+    \"#theme .setting-radio-name\",\n+    \"#theme .setting-radio-choices\",\n     {\"x\": 1}\n )\n compare-elements-position-near-false: (\n-    \"#theme .setting-name\",\n-    \"#theme .choices\",\n+    \"#theme .setting-radio-name\",\n+    \"#theme .setting-radio-choices\",\n     {\"y\": 1}\n )\n // Now we check that the label positions are all on the same line.\n compare-elements-position-near: (\n-    \"#theme .choices #theme-light\",\n-    \"#theme .choices #theme-dark\",\n+    \"#theme .setting-radio-choices #theme-light\",\n+    \"#theme .setting-radio-choices #theme-dark\",\n     {\"y\": 1}\n )\n compare-elements-position-near: (\n-    \"#theme .choices #theme-dark\",\n-    \"#theme .choices #theme-ayu\",\n+    \"#theme .setting-radio-choices #theme-dark\",\n+    \"#theme .setting-radio-choices #theme-ayu\",\n     {\"y\": 1}\n )\n compare-elements-position-near: (\n-    \"#theme .choices #theme-ayu\",\n-    \"#theme .choices #theme-system-preference\",\n+    \"#theme .setting-radio-choices #theme-ayu\",\n+    \"#theme .setting-radio-choices #theme-system-preference\",\n     {\"y\": 1}\n )\n \n@@ -180,17 +180,17 @@ assert-css: (\n // We now switch the display.\n click: \"#theme-system-preference\"\n // Wait for the hidden element to show up.\n-wait-for: \".setting-line:not(.hidden) #preferred-dark-theme\"\n-assert: \".setting-line:not(.hidden) #preferred-light-theme\"\n+wait-for: \"#preferred-dark-theme.setting-line:not(.hidden)\"\n+assert: \"#preferred-light-theme.setting-line:not(.hidden)\"\n \n // We check their text as well.\n-assert-text: (\"#preferred-dark-theme .setting-name\", \"Preferred dark theme\")\n-assert-text: (\"#preferred-light-theme .setting-name\", \"Preferred light theme\")\n+assert-text: (\"#preferred-dark-theme .setting-radio-name\", \"Preferred dark theme\")\n+assert-text: (\"#preferred-light-theme .setting-radio-name\", \"Preferred light theme\")\n \n // We now check that clicking on the toggles' text is like clicking on the checkbox.\n // To test it, we use the \"Disable keyboard shortcuts\".\n local-storage: {\"rustdoc-disable-shortcuts\": \"false\"}\n-click: \".setting-line:last-child .settings-toggle .label\"\n+click: \".setting-line:last-child .setting-check span\"\n assert-local-storage: {\"rustdoc-disable-shortcuts\": \"true\"}\n \n // Make sure that \"Disable keyboard shortcuts\" actually took effect.\n@@ -200,7 +200,7 @@ assert-false: \"#help-button .popover\"\n wait-for-css: (\"#settings-menu .popover\", {\"display\": \"block\"})\n \n // Now turn keyboard shortcuts back on, and see if they work.\n-click: \".setting-line:last-child .settings-toggle .label\"\n+click: \".setting-line:last-child .setting-check span\"\n assert-local-storage: {\"rustdoc-disable-shortcuts\": \"false\"}\n press-key: \"Escape\"\n press-key: \"?\""}, {"sha": "31c9d99aa832491b76ffc8af89b79c6ba91c76b5", "filename": "tests/rustdoc-gui/theme-change.goml", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Frustdoc-gui%2Ftheme-change.goml", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Frustdoc-gui%2Ftheme-change.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc-gui%2Ftheme-change.goml?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -43,7 +43,7 @@ assert-local-storage: { \"rustdoc-theme\": \"ayu\" }\n \n assert-local-storage-false: { \"rustdoc-use-system-theme\": \"true\" }\n click: \"#theme-system-preference\"\n-wait-for: \".setting-line:not(.hidden) #preferred-light-theme\"\n+wait-for: \"#preferred-light-theme.setting-line:not(.hidden)\"\n assert-local-storage: { \"rustdoc-use-system-theme\": \"true\" }\n // We click on both preferred light and dark themes to be sure that there is a change.\n click: \"#preferred-light-theme-dark\"\n@@ -52,16 +52,16 @@ wait-for-css: (\"body\", { \"background-color\": |background_dark| })\n \n reload:\n // Ensure that the \"preferred themes\" are still displayed.\n-wait-for: \".setting-line:not(.hidden) #preferred-light-theme\"\n+wait-for: \"#preferred-light-theme.setting-line:not(.hidden)\"\n click: \"#theme-light\"\n wait-for-css: (\"body\", { \"background-color\": |background_light| })\n assert-local-storage: { \"rustdoc-theme\": \"light\" }\n // Ensure it's now hidden again\n-wait-for: \".setting-line.hidden #preferred-light-theme\"\n+wait-for: \"#preferred-light-theme.setting-line.hidden\"\n // And ensure the theme was rightly set.\n wait-for-css: (\"body\", { \"background-color\": |background_light| })\n assert-local-storage: { \"rustdoc-theme\": \"light\" }\n \n reload:\n wait-for: \"#settings\"\n-assert: \".setting-line.hidden #preferred-light-theme\"\n+assert: \"#preferred-light-theme.setting-line.hidden\""}, {"sha": "f247ff6cf3f559f7be5bc07a5e5efccac9bd2147", "filename": "tests/ui/fn/fn-compare-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ffn%2Ffn-compare-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ffn%2Ffn-compare-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-compare-mismatch.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -19,6 +19,7 @@ LL |     let x = f == g;\n    |\n    = note: expected fn item `fn() {f}`\n               found fn item `fn() {g}`\n+   = note: different fn items have unique types, even if their signatures are the same\n \n error: aborting due to 2 previous errors\n "}, {"sha": "b6ebc867d284be59a383316218a6f644f455540a", "filename": "tests/ui/fn/fn-item-type.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ffn%2Ffn-item-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ffn%2Ffn-item-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-item-type.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -1,53 +1,52 @@\n // Test that the types of distinct fn items are not compatible by\n // default. See also `run-pass/fn-item-type-*.rs`.\n \n-fn foo<T>(x: isize) -> isize { x * 2 }\n-fn bar<T>(x: isize) -> isize { x * 4 }\n+fn foo<T>(x: isize) -> isize {\n+    x * 2\n+}\n+fn bar<T>(x: isize) -> isize {\n+    x * 4\n+}\n \n-fn eq<T>(x: T, y: T) { }\n+fn eq<T>(x: T, y: T) {}\n \n-trait Foo { fn foo() { /* this is a default fn */ } }\n-impl<T> Foo for T { /* `foo` is still default here */ }\n+trait Foo {\n+    fn foo() { /* this is a default fn */\n+    }\n+}\n+impl<T> Foo for T {\n+    /* `foo` is still default here */\n+}\n \n fn main() {\n     eq(foo::<u8>, bar::<u8>);\n     //~^ ERROR mismatched types\n     //~| expected fn item `fn(_) -> _ {foo::<u8>}`\n     //~| found fn item `fn(_) -> _ {bar::<u8>}`\n     //~| expected fn item, found a different fn item\n-    //~| different `fn` items always have unique types, even if their signatures are the same\n-    //~| change the expected type to be function pointer\n-    //~| if the expected type is due to type inference, cast the expected `fn` to a function pointer\n+    //~| different fn items have unique types, even if their signatures are the same\n \n     eq(foo::<u8>, foo::<i8>);\n     //~^ ERROR mismatched types\n     //~| expected `u8`, found `i8`\n-    //~| different `fn` items always have unique types, even if their signatures are the same\n-    //~| change the expected type to be function pointer\n-    //~| if the expected type is due to type inference, cast the expected `fn` to a function pointer\n+    //~| different fn items have unique types, even if their signatures are the same\n \n     eq(bar::<String>, bar::<Vec<u8>>);\n     //~^ ERROR mismatched types\n     //~| found fn item `fn(_) -> _ {bar::<Vec<u8>>}`\n     //~| expected struct `String`, found struct `Vec`\n-    //~| different `fn` items always have unique types, even if their signatures are the same\n-    //~| change the expected type to be function pointer\n-    //~| if the expected type is due to type inference, cast the expected `fn` to a function pointer\n+    //~| different fn items have unique types, even if their signatures are the same\n \n     // Make sure we distinguish between trait methods correctly.\n     eq(<u8 as Foo>::foo, <u16 as Foo>::foo);\n     //~^ ERROR mismatched types\n     //~| expected `u8`, found `u16`\n-    //~| different `fn` items always have unique types, even if their signatures are the same\n-    //~| change the expected type to be function pointer\n-    //~| if the expected type is due to type inference, cast the expected `fn` to a function pointer\n+    //~| different fn items have unique types, even if their signatures are the same\n \n     eq(foo::<u8>, bar::<u8> as fn(isize) -> isize);\n     //~^ ERROR mismatched types\n     //~| found fn pointer `fn(_) -> _`\n     //~| expected fn item, found fn pointer\n-    //~| change the expected type to be function pointer\n-    //~| if the expected type is due to type inference, cast the expected `fn` to a function pointer\n \n     eq(foo::<u8> as fn(isize) -> isize, bar::<u8>); // ok!\n }"}, {"sha": "cb1b88c7ab8f3519352fb4fb715d0f4c0fc95a5b", "filename": "tests/ui/fn/fn-item-type.stderr", "status": "modified", "additions": 20, "deletions": 29, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ffn%2Ffn-item-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ffn%2Ffn-item-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-item-type.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/fn-item-type.rs:13:19\n+  --> $DIR/fn-item-type.rs:22:19\n    |\n LL |     eq(foo::<u8>, bar::<u8>);\n    |     --            ^^^^^^^^^ expected fn item, found a different fn item\n@@ -8,17 +8,15 @@ LL |     eq(foo::<u8>, bar::<u8>);\n    |\n    = note: expected fn item `fn(_) -> _ {foo::<u8>}`\n               found fn item `fn(_) -> _ {bar::<u8>}`\n-   = note: different `fn` items always have unique types, even if their signatures are the same\n-   = help: change the expected type to be function pointer `fn(isize) -> isize`\n-   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `foo::<u8> as fn(isize) -> isize`\n+   = note: different fn items have unique types, even if their signatures are the same\n note: function defined here\n-  --> $DIR/fn-item-type.rs:7:4\n+  --> $DIR/fn-item-type.rs:11:4\n    |\n-LL | fn eq<T>(x: T, y: T) { }\n+LL | fn eq<T>(x: T, y: T) {}\n    |    ^^          ----\n \n error[E0308]: mismatched types\n-  --> $DIR/fn-item-type.rs:22:19\n+  --> $DIR/fn-item-type.rs:29:19\n    |\n LL |     eq(foo::<u8>, foo::<i8>);\n    |     --            ^^^^^^^^^ expected `u8`, found `i8`\n@@ -27,17 +25,15 @@ LL |     eq(foo::<u8>, foo::<i8>);\n    |\n    = note: expected fn item `fn(_) -> _ {foo::<u8>}`\n               found fn item `fn(_) -> _ {foo::<i8>}`\n-   = note: different `fn` items always have unique types, even if their signatures are the same\n-   = help: change the expected type to be function pointer `fn(isize) -> isize`\n-   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `foo::<u8> as fn(isize) -> isize`\n+   = note: different fn items have unique types, even if their signatures are the same\n note: function defined here\n-  --> $DIR/fn-item-type.rs:7:4\n+  --> $DIR/fn-item-type.rs:11:4\n    |\n-LL | fn eq<T>(x: T, y: T) { }\n+LL | fn eq<T>(x: T, y: T) {}\n    |    ^^          ----\n \n error[E0308]: mismatched types\n-  --> $DIR/fn-item-type.rs:29:23\n+  --> $DIR/fn-item-type.rs:34:23\n    |\n LL |     eq(bar::<String>, bar::<Vec<u8>>);\n    |     --                ^^^^^^^^^^^^^^ expected struct `String`, found struct `Vec`\n@@ -46,17 +42,15 @@ LL |     eq(bar::<String>, bar::<Vec<u8>>);\n    |\n    = note: expected fn item `fn(_) -> _ {bar::<String>}`\n               found fn item `fn(_) -> _ {bar::<Vec<u8>>}`\n-   = note: different `fn` items always have unique types, even if their signatures are the same\n-   = help: change the expected type to be function pointer `fn(isize) -> isize`\n-   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `bar::<String> as fn(isize) -> isize`\n+   = note: different fn items have unique types, even if their signatures are the same\n note: function defined here\n-  --> $DIR/fn-item-type.rs:7:4\n+  --> $DIR/fn-item-type.rs:11:4\n    |\n-LL | fn eq<T>(x: T, y: T) { }\n+LL | fn eq<T>(x: T, y: T) {}\n    |    ^^          ----\n \n error[E0308]: mismatched types\n-  --> $DIR/fn-item-type.rs:38:26\n+  --> $DIR/fn-item-type.rs:41:26\n    |\n LL |     eq(<u8 as Foo>::foo, <u16 as Foo>::foo);\n    |     --                   ^^^^^^^^^^^^^^^^^ expected `u8`, found `u16`\n@@ -65,17 +59,15 @@ LL |     eq(<u8 as Foo>::foo, <u16 as Foo>::foo);\n    |\n    = note: expected fn item `fn() {<u8 as Foo>::foo}`\n               found fn item `fn() {<u16 as Foo>::foo}`\n-   = note: different `fn` items always have unique types, even if their signatures are the same\n-   = help: change the expected type to be function pointer `fn()`\n-   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `<u8 as Foo>::foo as fn()`\n+   = note: different fn items have unique types, even if their signatures are the same\n note: function defined here\n-  --> $DIR/fn-item-type.rs:7:4\n+  --> $DIR/fn-item-type.rs:11:4\n    |\n-LL | fn eq<T>(x: T, y: T) { }\n+LL | fn eq<T>(x: T, y: T) {}\n    |    ^^          ----\n \n error[E0308]: mismatched types\n-  --> $DIR/fn-item-type.rs:45:19\n+  --> $DIR/fn-item-type.rs:46:19\n    |\n LL |     eq(foo::<u8>, bar::<u8> as fn(isize) -> isize);\n    |     --            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected fn item, found fn pointer\n@@ -84,12 +76,11 @@ LL |     eq(foo::<u8>, bar::<u8> as fn(isize) -> isize);\n    |\n    = note: expected fn item `fn(_) -> _ {foo::<u8>}`\n            found fn pointer `fn(_) -> _`\n-   = help: change the expected type to be function pointer `fn(isize) -> isize`\n-   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `foo::<u8> as fn(isize) -> isize`\n+   = note: fn items are distinct from fn pointers\n note: function defined here\n-  --> $DIR/fn-item-type.rs:7:4\n+  --> $DIR/fn-item-type.rs:11:4\n    |\n-LL | fn eq<T>(x: T, y: T) { }\n+LL | fn eq<T>(x: T, y: T) {}\n    |    ^^          ----\n \n error: aborting due to 5 previous errors"}, {"sha": "0597478cb4292a6a4d1f698bbc05b56d36ff2565", "filename": "tests/ui/fn/fn-pointer-mismatch.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ffn%2Ffn-pointer-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ffn%2Ffn-pointer-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-pointer-mismatch.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -0,0 +1,56 @@\n+fn foo(x: u32) -> u32 {\n+    x * 2\n+}\n+\n+fn bar(x: u32) -> u32 {\n+    x * 3\n+}\n+\n+// original example from Issue #102608\n+fn foobar(n: u32) -> u32 {\n+    let g = if n % 2 == 0 { &foo } else { &bar };\n+    //~^ ERROR `if` and `else` have incompatible types\n+    //~| different fn items have unique types, even if their signatures are the same\n+    g(n)\n+}\n+\n+fn main() {\n+    assert_eq!(foobar(7), 21);\n+    assert_eq!(foobar(8), 16);\n+\n+    // general mismatch of fn item types\n+    let mut a = foo;\n+    a = bar;\n+    //~^ ERROR mismatched types\n+    //~| expected fn item `fn(_) -> _ {foo}`\n+    //~| found fn item `fn(_) -> _ {bar}`\n+    //~| different fn items have unique types, even if their signatures are the same\n+\n+    // display note even when boxed\n+    let mut b = Box::new(foo);\n+    b = Box::new(bar);\n+    //~^ ERROR mismatched types\n+    //~| different fn items have unique types, even if their signatures are the same\n+\n+    // suggest removing reference\n+    let c: fn(u32) -> u32 = &foo;\n+    //~^ ERROR mismatched types\n+    //~| expected fn pointer `fn(u32) -> u32`\n+    //~| found reference `&fn(u32) -> u32 {foo}`\n+\n+    // suggest using reference\n+    let d: &fn(u32) -> u32 = foo;\n+    //~^ ERROR mismatched types\n+    //~| expected reference `&fn(u32) -> u32`\n+    //~| found fn item `fn(u32) -> u32 {foo}`\n+\n+    // suggest casting with reference\n+    let e: &fn(u32) -> u32 = &foo;\n+    //~^ ERROR mismatched types\n+    //~| expected reference `&fn(u32) -> u32`\n+    //~| found reference `&fn(u32) -> u32 {foo}`\n+\n+    // OK\n+    let mut z: fn(u32) -> u32 = foo as fn(u32) -> u32;\n+    z = bar;\n+}"}, {"sha": "2dc0710e27e4660a6f8ce6ee28018d463c1d6b12", "filename": "tests/ui/fn/fn-pointer-mismatch.stderr", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ffn%2Ffn-pointer-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ffn%2Ffn-pointer-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ffn%2Ffn-pointer-mismatch.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -0,0 +1,81 @@\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/fn-pointer-mismatch.rs:11:43\n+   |\n+LL |     let g = if n % 2 == 0 { &foo } else { &bar };\n+   |                             ----          ^^^^ expected fn item, found a different fn item\n+   |                             |\n+   |                             expected because of this\n+   |\n+   = note: expected reference `&fn(u32) -> u32 {foo}`\n+              found reference `&fn(u32) -> u32 {bar}`\n+   = note: different fn items have unique types, even if their signatures are the same\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-pointer-mismatch.rs:23:9\n+   |\n+LL |     let mut a = foo;\n+   |                 --- expected due to this value\n+LL |     a = bar;\n+   |         ^^^ expected fn item, found a different fn item\n+   |\n+   = note: expected fn item `fn(_) -> _ {foo}`\n+              found fn item `fn(_) -> _ {bar}`\n+   = note: different fn items have unique types, even if their signatures are the same\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-pointer-mismatch.rs:31:18\n+   |\n+LL |     b = Box::new(bar);\n+   |         -------- ^^^ expected fn item, found a different fn item\n+   |         |\n+   |         arguments to this function are incorrect\n+   |\n+   = note: expected fn item `fn(_) -> _ {foo}`\n+              found fn item `fn(_) -> _ {bar}`\n+   = note: different fn items have unique types, even if their signatures are the same\n+note: associated function defined here\n+  --> $SRC_DIR/alloc/src/boxed.rs:LL:COL\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-pointer-mismatch.rs:36:29\n+   |\n+LL |     let c: fn(u32) -> u32 = &foo;\n+   |            --------------   ^^^^\n+   |            |                |\n+   |            |                expected fn pointer, found reference\n+   |            |                help: consider removing the reference: `foo`\n+   |            expected due to this\n+   |\n+   = note: expected fn pointer `fn(u32) -> u32`\n+               found reference `&fn(u32) -> u32 {foo}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-pointer-mismatch.rs:42:30\n+   |\n+LL |     let d: &fn(u32) -> u32 = foo;\n+   |            ---------------   ^^^\n+   |            |                 |\n+   |            |                 expected `&fn(u32) -> u32`, found fn item\n+   |            |                 help: consider using a reference: `&foo`\n+   |            expected due to this\n+   |\n+   = note: expected reference `&fn(u32) -> u32`\n+                found fn item `fn(u32) -> u32 {foo}`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/fn-pointer-mismatch.rs:48:30\n+   |\n+LL |     let e: &fn(u32) -> u32 = &foo;\n+   |            ---------------   ^^^^\n+   |            |                 |\n+   |            |                 expected fn pointer, found fn item\n+   |            |                 help: consider casting to a fn pointer: `&(foo as fn(u32) -> u32)`\n+   |            expected due to this\n+   |\n+   = note: expected reference `&fn(u32) -> u32`\n+              found reference `&fn(u32) -> u32 {foo}`\n+   = note: fn items are distinct from fn pointers\n+\n+error: aborting due to 6 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "3fba630435c71fb68067ac4f4200aa8d63d98d27", "filename": "tests/ui/let-else/accidental-if.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Flet-else%2Faccidental-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Flet-else%2Faccidental-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet-else%2Faccidental-if.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let x = Some(123);\n+    if let Some(y) = x else { //~ ERROR this `if` expression is missing a block\n+        return;\n+    };\n+}"}, {"sha": "5474a67aac45a6128940aaaa61d401600ab40705", "filename": "tests/ui/let-else/accidental-if.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Flet-else%2Faccidental-if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Flet-else%2Faccidental-if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Flet-else%2Faccidental-if.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -0,0 +1,19 @@\n+error: this `if` expression is missing a block after the condition\n+  --> $DIR/accidental-if.rs:3:5\n+   |\n+LL |     if let Some(y) = x else {\n+   |     ^^\n+   |\n+help: add a block here\n+  --> $DIR/accidental-if.rs:3:23\n+   |\n+LL |     if let Some(y) = x else {\n+   |                       ^\n+help: remove the `if` if you meant to write a `let...else` statement\n+  --> $DIR/accidental-if.rs:3:5\n+   |\n+LL |     if let Some(y) = x else {\n+   |     ^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "310b6c224e0e77decd21ddab61faa77db891a777", "filename": "tests/ui/reify-intrinsic.stderr", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Freify-intrinsic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Freify-intrinsic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Freify-intrinsic.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -23,9 +23,7 @@ LL |         std::intrinsics::unlikely,\n    |\n    = note: expected fn item `extern \"rust-intrinsic\" fn(_) -> _ {likely}`\n               found fn item `extern \"rust-intrinsic\" fn(_) -> _ {unlikely}`\n-   = note: different `fn` items always have unique types, even if their signatures are the same\n-   = help: change the expected type to be function pointer `extern \"rust-intrinsic\" fn(bool) -> bool`\n-   = help: if the expected type is due to type inference, cast the expected `fn` to a function pointer: `likely as extern \"rust-intrinsic\" fn(bool) -> bool`\n+   = note: different fn items have unique types, even if their signatures are the same\n \n error: aborting due to 3 previous errors\n "}, {"sha": "f34ccecdd45e63bb6ded49705ced491c9c5852d4", "filename": "tests/ui/rfc-2497-if-let-chains/ensure-that-let-else-does-not-interact-with-let-chains.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfc-2497-if-let-chains%2Fensure-that-let-else-does-not-interact-with-let-chains.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -37,6 +37,11 @@ help: add a block here\n    |\n LL |     if let Some(n) = opt else {\n    |                         ^\n+help: remove the `if` if you meant to write a `let...else` statement\n+  --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:24:5\n+   |\n+LL |     if let Some(n) = opt else {\n+   |     ^^\n \n error: this `if` expression is missing a block after the condition\n   --> $DIR/ensure-that-let-else-does-not-interact-with-let-chains.rs:28:5"}, {"sha": "07f6dc906c6bbf9bc56c6231b2c1371768a3c08f", "filename": "tests/ui/rfcs/rfc-2396-target_feature-11/fn-ptr.mir.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-ptr.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-ptr.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-ptr.mir.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -5,12 +5,15 @@ LL | #[target_feature(enable = \"sse2\")]\n    | ---------------------------------- `#[target_feature]` added here\n ...\n LL |     let foo: fn() = foo;\n-   |              ----   ^^^ cannot coerce functions with `#[target_feature]` to safe function pointers\n-   |              |\n+   |              ----   ^^^\n+   |              |      |\n+   |              |      cannot coerce functions with `#[target_feature]` to safe function pointers\n+   |              |      help: consider casting to a fn pointer: `foo as fn()`\n    |              expected due to this\n    |\n    = note: expected fn pointer `fn()`\n                  found fn item `fn() {foo}`\n+   = note: fn items are distinct from fn pointers\n    = note: functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\n \n error: aborting due to previous error"}, {"sha": "07f6dc906c6bbf9bc56c6231b2c1371768a3c08f", "filename": "tests/ui/rfcs/rfc-2396-target_feature-11/fn-ptr.thir.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-ptr.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-ptr.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Frfcs%2Frfc-2396-target_feature-11%2Ffn-ptr.thir.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -5,12 +5,15 @@ LL | #[target_feature(enable = \"sse2\")]\n    | ---------------------------------- `#[target_feature]` added here\n ...\n LL |     let foo: fn() = foo;\n-   |              ----   ^^^ cannot coerce functions with `#[target_feature]` to safe function pointers\n-   |              |\n+   |              ----   ^^^\n+   |              |      |\n+   |              |      cannot coerce functions with `#[target_feature]` to safe function pointers\n+   |              |      help: consider casting to a fn pointer: `foo as fn()`\n    |              expected due to this\n    |\n    = note: expected fn pointer `fn()`\n                  found fn item `fn() {foo}`\n+   = note: fn items are distinct from fn pointers\n    = note: functions with `#[target_feature]` can only be coerced to `unsafe` function pointers\n \n error: aborting due to previous error"}, {"sha": "f68939d0ec8c91b56858f119aa88816cf9640af2", "filename": "tests/ui/static/static-reference-to-fn-1.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Fstatic%2Fstatic-reference-to-fn-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Fstatic%2Fstatic-reference-to-fn-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fstatic%2Fstatic-reference-to-fn-1.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -2,10 +2,14 @@ error[E0308]: mismatched types\n   --> $DIR/static-reference-to-fn-1.rs:17:15\n    |\n LL |         func: &foo,\n-   |               ^^^^ expected fn pointer, found fn item\n+   |               ^^^^\n+   |               |\n+   |               expected fn pointer, found fn item\n+   |               help: consider casting to a fn pointer: `&(foo as fn() -> Option<isize>)`\n    |\n    = note: expected reference `&fn() -> Option<isize>`\n               found reference `&fn() -> Option<isize> {foo}`\n+   = note: fn items are distinct from fn pointers\n \n error: aborting due to previous error\n "}, {"sha": "23bafa6c5c94c70a93afabd380f71ab5c3f74427", "filename": "tests/ui/type/type-check/coerce-result-return-value-2.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value-2.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -0,0 +1,24 @@\n+struct A;\n+struct B;\n+impl From<A> for B {\n+    fn from(_: A) -> Self { B }\n+}\n+fn foo4(x: Result<(), A>) -> Result<(), B> {\n+    match true {\n+        true => x, //~ ERROR mismatched types\n+        false => x,\n+    }\n+}\n+fn foo5(x: Result<(), A>) -> Result<(), B> {\n+    match true {\n+        true => return x, //~ ERROR mismatched types\n+        false => return x,\n+    }\n+}\n+fn main() {\n+    let _ = foo4(Ok(()));\n+    let _ = foo5(Ok(()));\n+    let _: Result<(), B> = { //~ ERROR mismatched types\n+        Err(A);\n+    };\n+}"}, {"sha": "5992162341e6e25198d6361572f47847a70f5a9c", "filename": "tests/ui/type/type-check/coerce-result-return-value-2.stderr", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value-2.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -0,0 +1,47 @@\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-result-return-value-2.rs:8:17\n+   |\n+LL | fn foo4(x: Result<(), A>) -> Result<(), B> {\n+   |                              ------------- expected `Result<(), B>` because of return type\n+LL |     match true {\n+LL |         true => x,\n+   |                 ^ expected struct `B`, found struct `A`\n+   |\n+   = note: expected enum `Result<_, B>`\n+              found enum `Result<_, A>`\n+help: use `?` to coerce and return an appropriate `Err`, and wrap the resulting value in `Ok` so the expression remains of type `Result`\n+   |\n+LL |         true => Ok(x?),\n+   |                 +++ ++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-result-return-value-2.rs:14:24\n+   |\n+LL | fn foo5(x: Result<(), A>) -> Result<(), B> {\n+   |                              ------------- expected `Result<(), B>` because of return type\n+LL |     match true {\n+LL |         true => return x,\n+   |                        ^ expected struct `B`, found struct `A`\n+   |\n+   = note: expected enum `Result<_, B>`\n+              found enum `Result<_, A>`\n+help: use `?` to coerce and return an appropriate `Err`, and wrap the resulting value in `Ok` so the expression remains of type `Result`\n+   |\n+LL |         true => return Ok(x?),\n+   |                        +++ ++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-result-return-value-2.rs:21:28\n+   |\n+LL |       let _: Result<(), B> = {\n+   |  ____________________________^\n+LL | |         Err(A);\n+LL | |     };\n+   | |_____^ expected enum `Result`, found `()`\n+   |\n+   = note:   expected enum `Result<(), B>`\n+           found unit type `()`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "8a05407070dada4298d08914dc33301334f89d97", "filename": "tests/ui/type/type-check/coerce-result-return-value.fixed", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value.fixed?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+struct A;\n+struct B;\n+impl From<A> for B {\n+    fn from(_: A) -> Self { B }\n+}\n+fn foo1(x: Result<(), A>) -> Result<(), B> {\n+    Ok(x?) //~ ERROR mismatched types\n+}\n+fn foo2(x: Result<(), A>) -> Result<(), B> {\n+    return Ok(x?); //~ ERROR mismatched types\n+}\n+fn foo3(x: Result<(), A>) -> Result<(), B> {\n+    if true {\n+        Ok(x?) //~ ERROR mismatched types\n+    } else {\n+        Ok(x?) //~ ERROR mismatched types\n+    }\n+}\n+fn main() {\n+    let _ = foo1(Ok(()));\n+    let _ = foo2(Ok(()));\n+    let _ = foo3(Ok(()));\n+}"}, {"sha": "442203addb787241788f92c9ee179506ae498367", "filename": "tests/ui/type/type-check/coerce-result-return-value.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value.rs?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+struct A;\n+struct B;\n+impl From<A> for B {\n+    fn from(_: A) -> Self { B }\n+}\n+fn foo1(x: Result<(), A>) -> Result<(), B> {\n+    x //~ ERROR mismatched types\n+}\n+fn foo2(x: Result<(), A>) -> Result<(), B> {\n+    return x; //~ ERROR mismatched types\n+}\n+fn foo3(x: Result<(), A>) -> Result<(), B> {\n+    if true {\n+        x //~ ERROR mismatched types\n+    } else {\n+        x //~ ERROR mismatched types\n+    }\n+}\n+fn main() {\n+    let _ = foo1(Ok(()));\n+    let _ = foo2(Ok(()));\n+    let _ = foo3(Ok(()));\n+}"}, {"sha": "550153520782c683848d4bdd0d7b2ad13d9089ec", "filename": "tests/ui/type/type-check/coerce-result-return-value.stderr", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/95b61d16d4bd2e46b0a110c1bda703f026f0a94f/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftype%2Ftype-check%2Fcoerce-result-return-value.stderr?ref=95b61d16d4bd2e46b0a110c1bda703f026f0a94f", "patch": "@@ -0,0 +1,65 @@\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-result-return-value.rs:8:5\n+   |\n+LL | fn foo1(x: Result<(), A>) -> Result<(), B> {\n+   |                              ------------- expected `Result<(), B>` because of return type\n+LL |     x\n+   |     ^ expected struct `B`, found struct `A`\n+   |\n+   = note: expected enum `Result<_, B>`\n+              found enum `Result<_, A>`\n+help: use `?` to coerce and return an appropriate `Err`, and wrap the resulting value in `Ok` so the expression remains of type `Result`\n+   |\n+LL |     Ok(x?)\n+   |     +++ ++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-result-return-value.rs:11:12\n+   |\n+LL | fn foo2(x: Result<(), A>) -> Result<(), B> {\n+   |                              ------------- expected `Result<(), B>` because of return type\n+LL |     return x;\n+   |            ^ expected struct `B`, found struct `A`\n+   |\n+   = note: expected enum `Result<_, B>`\n+              found enum `Result<_, A>`\n+help: use `?` to coerce and return an appropriate `Err`, and wrap the resulting value in `Ok` so the expression remains of type `Result`\n+   |\n+LL |     return Ok(x?);\n+   |            +++ ++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-result-return-value.rs:15:9\n+   |\n+LL | fn foo3(x: Result<(), A>) -> Result<(), B> {\n+   |                              ------------- expected `Result<(), B>` because of return type\n+LL |     if true {\n+LL |         x\n+   |         ^ expected struct `B`, found struct `A`\n+   |\n+   = note: expected enum `Result<_, B>`\n+              found enum `Result<_, A>`\n+help: use `?` to coerce and return an appropriate `Err`, and wrap the resulting value in `Ok` so the expression remains of type `Result`\n+   |\n+LL |         Ok(x?)\n+   |         +++ ++\n+\n+error[E0308]: mismatched types\n+  --> $DIR/coerce-result-return-value.rs:17:9\n+   |\n+LL | fn foo3(x: Result<(), A>) -> Result<(), B> {\n+   |                              ------------- expected `Result<(), B>` because of return type\n+...\n+LL |         x\n+   |         ^ expected struct `B`, found struct `A`\n+   |\n+   = note: expected enum `Result<_, B>`\n+              found enum `Result<_, A>`\n+help: use `?` to coerce and return an appropriate `Err`, and wrap the resulting value in `Ok` so the expression remains of type `Result`\n+   |\n+LL |         Ok(x?)\n+   |         +++ ++\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}