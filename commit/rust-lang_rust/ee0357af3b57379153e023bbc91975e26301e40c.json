{"sha": "ee0357af3b57379153e023bbc91975e26301e40c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMDM1N2FmM2I1NzM3OTE1M2UwMjNiYmM5MTk3NWUyNjMwMWU0MGM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-03-13T19:23:18Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-03-27T20:38:17Z"}, "message": "resolve: Partially unify early and late scope-relative ident resolution", "tree": {"sha": "5546e48d246a30e6e6d9990be359adfe86b0d7fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5546e48d246a30e6e6d9990be359adfe86b0d7fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee0357af3b57379153e023bbc91975e26301e40c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee0357af3b57379153e023bbc91975e26301e40c", "html_url": "https://github.com/rust-lang/rust/commit/ee0357af3b57379153e023bbc91975e26301e40c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee0357af3b57379153e023bbc91975e26301e40c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afaf33dcafe9c7068b63eb997df221aa08db7c29", "url": "https://api.github.com/repos/rust-lang/rust/commits/afaf33dcafe9c7068b63eb997df221aa08db7c29", "html_url": "https://github.com/rust-lang/rust/commit/afaf33dcafe9c7068b63eb997df221aa08db7c29"}], "stats": {"total": 239, "additions": 96, "deletions": 143}, "files": [{"sha": "e931e9dfcb2bffad3eee2be9ea2cc6f89f71cbf5", "filename": "compiler/rustc_lint_defs/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee0357af3b57379153e023bbc91975e26301e40c/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0357af3b57379153e023bbc91975e26301e40c/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Fbuiltin.rs?ref=ee0357af3b57379153e023bbc91975e26301e40c", "patch": "@@ -1977,7 +1977,7 @@ declare_lint! {\n     Warn,\n     \"detects proc macro derives using inaccessible names from parent modules\",\n     @future_incompatible = FutureIncompatibleInfo {\n-        reference: \"issue #50504 <https://github.com/rust-lang/rust/issues/50504>\",\n+        reference: \"issue #83583 <https://github.com/rust-lang/rust/issues/83583>\",\n         edition: None,\n     };\n }"}, {"sha": "327beca218e1d6a1f62a0f970acf4a08dd032d9a", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee0357af3b57379153e023bbc91975e26301e40c/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0357af3b57379153e023bbc91975e26301e40c/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=ee0357af3b57379153e023bbc91975e26301e40c", "patch": "@@ -606,7 +606,7 @@ impl<'a> Resolver<'a> {\n     /// Lookup typo candidate in scope for a macro or import.\n     fn early_lookup_typo_candidate(\n         &mut self,\n-        scope_set: ScopeSet,\n+        scope_set: ScopeSet<'a>,\n         parent_scope: &ParentScope<'a>,\n         ident: Ident,\n         filter_fn: &impl Fn(Res) -> bool,\n@@ -662,7 +662,7 @@ impl<'a> Resolver<'a> {\n                     let root_module = this.resolve_crate_root(root_ident);\n                     this.add_module_candidates(root_module, &mut suggestions, filter_fn);\n                 }\n-                Scope::Module(module) => {\n+                Scope::Module(module, _) => {\n                     this.add_module_candidates(module, &mut suggestions, filter_fn);\n                 }\n                 Scope::RegisteredAttrs => {"}, {"sha": "0febd71a52a2d9c95286af37e5ecb7189e5e477e", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 63, "deletions": 131, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/ee0357af3b57379153e023bbc91975e26301e40c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0357af3b57379153e023bbc91975e26301e40c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=ee0357af3b57379153e023bbc91975e26301e40c", "patch": "@@ -25,7 +25,6 @@ use Determinacy::*;\n use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::ptr::P;\n-use rustc_ast::unwrap_or;\n use rustc_ast::visit::{self, Visitor};\n use rustc_ast::{self as ast, NodeId};\n use rustc_ast::{Crate, CRATE_NODE_ID};\n@@ -42,7 +41,7 @@ use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n-use rustc_hir::{PrimTy, TraitCandidate};\n+use rustc_hir::TraitCandidate;\n use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::hir::exports::ExportMap;\n@@ -108,7 +107,9 @@ enum Scope<'a> {\n     DeriveHelpersCompat,\n     MacroRules(MacroRulesScopeRef<'a>),\n     CrateRoot,\n-    Module(Module<'a>),\n+    // The node ID is for reporting the `PROC_MACRO_DERIVE_RESOLUTION_FALLBACK`\n+    // lint if it should be reported.\n+    Module(Module<'a>, Option<NodeId>),\n     RegisteredAttrs,\n     MacroUsePrelude,\n     BuiltinAttrs,\n@@ -122,13 +123,17 @@ enum Scope<'a> {\n /// with different restrictions when looking up the resolution.\n /// This enum is currently used only for early resolution (imports and macros),\n /// but not for late resolution yet.\n-enum ScopeSet {\n+#[derive(Clone, Copy)]\n+enum ScopeSet<'a> {\n     /// All scopes with the given namespace.\n     All(Namespace, /*is_import*/ bool),\n     /// Crate root, then extern prelude (used for mixed 2015-2018 mode in macros).\n     AbsolutePath(Namespace),\n     /// All scopes with macro namespace and the given macro kind restriction.\n     Macro(MacroKind),\n+    /// All scopes with the given namespace, used for partially performing late resolution.\n+    /// The node id enables lints and is used for reporting them.\n+    Late(Namespace, Module<'a>, Option<NodeId>),\n }\n \n /// Everything you need to know about a name's location to resolve it.\n@@ -1466,7 +1471,7 @@ impl<'a> Resolver<'a> {\n \n         self.visit_scopes(ScopeSet::All(TypeNS, false), parent_scope, ctxt, |this, scope, _, _| {\n             match scope {\n-                Scope::Module(module) => {\n+                Scope::Module(module, _) => {\n                     this.traits_in_module(module, assoc_item, &mut found_traits);\n                 }\n                 Scope::StdLibPrelude => {\n@@ -1630,7 +1635,7 @@ impl<'a> Resolver<'a> {\n     /// If the callback returns `Some` result, we stop visiting scopes and return it.\n     fn visit_scopes<T>(\n         &mut self,\n-        scope_set: ScopeSet,\n+        scope_set: ScopeSet<'a>,\n         parent_scope: &ParentScope<'a>,\n         ctxt: SyntaxContext,\n         mut visitor: impl FnMut(\n@@ -1686,12 +1691,17 @@ impl<'a> Resolver<'a> {\n             ScopeSet::All(ns, _) => (ns, None, false),\n             ScopeSet::AbsolutePath(ns) => (ns, None, true),\n             ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Late(ns, ..) => (ns, None, false),\n+        };\n+        let module = match scope_set {\n+            // Start with the specified module.\n+            ScopeSet::Late(_, module, _) => module,\n+            // Jump out of trait or enum modules, they do not act as scopes.\n+            _ => parent_scope.module.nearest_item_scope(),\n         };\n-        // Jump out of trait or enum modules, they do not act as scopes.\n-        let module = parent_scope.module.nearest_item_scope();\n         let mut scope = match ns {\n             _ if is_absolute_path => Scope::CrateRoot,\n-            TypeNS | ValueNS => Scope::Module(module),\n+            TypeNS | ValueNS => Scope::Module(module, None),\n             MacroNS => Scope::DeriveHelpers(parent_scope.expansion),\n         };\n         let mut ctxt = ctxt.normalize_to_macros_2_0();\n@@ -1756,7 +1766,7 @@ impl<'a> Resolver<'a> {\n                     MacroRulesScope::Invocation(invoc_id) => {\n                         Scope::MacroRules(self.invocation_parent_scopes[&invoc_id].macro_rules)\n                     }\n-                    MacroRulesScope::Empty => Scope::Module(module),\n+                    MacroRulesScope::Empty => Scope::Module(module, None),\n                 },\n                 Scope::CrateRoot => match ns {\n                     TypeNS => {\n@@ -1765,10 +1775,16 @@ impl<'a> Resolver<'a> {\n                     }\n                     ValueNS | MacroNS => break,\n                 },\n-                Scope::Module(module) => {\n+                Scope::Module(module, prev_lint_id) => {\n                     use_prelude = !module.no_implicit_prelude;\n-                    match self.hygienic_lexical_parent(module, &mut ctxt) {\n-                        Some(parent_module) => Scope::Module(parent_module),\n+                    let derive_fallback_lint_id = match scope_set {\n+                        ScopeSet::Late(.., lint_id) => lint_id,\n+                        _ => None,\n+                    };\n+                    match self.hygienic_lexical_parent(module, &mut ctxt, derive_fallback_lint_id) {\n+                        Some((parent_module, lint_id)) => {\n+                            Scope::Module(parent_module, lint_id.or(prev_lint_id))\n+                        }\n                         None => {\n                             ctxt.adjust(ExpnId::root());\n                             match ns {\n@@ -1824,6 +1840,7 @@ impl<'a> Resolver<'a> {\n         ribs: &[Rib<'a>],\n     ) -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS || ns == ValueNS);\n+        let orig_ident = ident;\n         if ident.name == kw::Empty {\n             return Some(LexicalScopeBinding::Res(Res::Err));\n         }\n@@ -1873,135 +1890,49 @@ impl<'a> Resolver<'a> {\n                 _ => continue,\n             };\n \n-            let item = self.resolve_ident_in_module_unadjusted(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                parent_scope,\n-                record_used,\n-                path_span,\n-            );\n-            if let Ok(binding) = item {\n-                // The ident resolves to an item.\n-                return Some(LexicalScopeBinding::Item(binding));\n-            }\n-\n             match module.kind {\n                 ModuleKind::Block(..) => {} // We can see through blocks\n                 _ => break,\n             }\n-        }\n \n-        ident = normalized_ident;\n-        let mut poisoned = None;\n-        loop {\n-            let mut span_data = ident.span.data();\n-            let opt_module = if let Some(node_id) = record_used_id {\n-                self.hygienic_lexical_parent_with_compatibility_fallback(\n-                    module,\n-                    &mut span_data.ctxt,\n-                    node_id,\n-                    &mut poisoned,\n-                )\n-            } else {\n-                self.hygienic_lexical_parent(module, &mut span_data.ctxt)\n-            };\n-            ident.span = span_data.span();\n-            module = unwrap_or!(opt_module, break);\n-            let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n-            let result = self.resolve_ident_in_module_unadjusted(\n+            let item = self.resolve_ident_in_module_unadjusted(\n                 ModuleOrUniformRoot::Module(module),\n                 ident,\n                 ns,\n-                adjusted_parent_scope,\n+                parent_scope,\n                 record_used,\n                 path_span,\n             );\n-\n-            match result {\n-                Ok(binding) => {\n-                    if let Some(node_id) = poisoned {\n-                        self.lint_buffer.buffer_lint_with_diagnostic(\n-                            lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n-                            node_id,\n-                            ident.span,\n-                            &format!(\"cannot find {} `{}` in this scope\", ns.descr(), ident),\n-                            BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(ident.span),\n-                        );\n-                    }\n-                    return Some(LexicalScopeBinding::Item(binding));\n-                }\n-                Err(Determined) => continue,\n-                Err(Undetermined) => {\n-                    span_bug!(ident.span, \"undetermined resolution during main resolution pass\")\n-                }\n-            }\n-        }\n-\n-        if !module.no_implicit_prelude {\n-            ident.span.adjust(ExpnId::root());\n-            if ns == TypeNS {\n-                if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n-                    return Some(LexicalScopeBinding::Item(binding));\n-                }\n-                if let Some(ident) = self.registered_tools.get(&ident) {\n-                    let binding =\n-                        (Res::ToolMod, ty::Visibility::Public, ident.span, ExpnId::root())\n-                            .to_name_binding(self.arenas);\n-                    return Some(LexicalScopeBinding::Item(binding));\n-                }\n-            }\n-            if let Some(prelude) = self.prelude {\n-                if let Ok(binding) = self.resolve_ident_in_module_unadjusted(\n-                    ModuleOrUniformRoot::Module(prelude),\n-                    ident,\n-                    ns,\n-                    parent_scope,\n-                    false,\n-                    path_span,\n-                ) {\n-                    return Some(LexicalScopeBinding::Item(binding));\n-                }\n-            }\n-        }\n-\n-        if ns == TypeNS {\n-            if let Some(prim_ty) = PrimTy::from_name(ident.name) {\n-                let binding =\n-                    (Res::PrimTy(prim_ty), ty::Visibility::Public, DUMMY_SP, ExpnId::root())\n-                        .to_name_binding(self.arenas);\n+            if let Ok(binding) = item {\n+                // The ident resolves to an item.\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n         }\n \n-        None\n+        self.early_resolve_ident_in_lexical_scope(\n+            orig_ident,\n+            ScopeSet::Late(ns, module, record_used_id),\n+            parent_scope,\n+            record_used,\n+            record_used,\n+            path_span,\n+        )\n+        .ok()\n+        .map(LexicalScopeBinding::Item)\n     }\n \n     fn hygienic_lexical_parent(\n         &mut self,\n         module: Module<'a>,\n         ctxt: &mut SyntaxContext,\n-    ) -> Option<Module<'a>> {\n+        derive_fallback_lint_id: Option<NodeId>,\n+    ) -> Option<(Module<'a>, Option<NodeId>)> {\n         if !module.expansion.outer_expn_is_descendant_of(*ctxt) {\n-            return Some(self.macro_def_scope(ctxt.remove_mark()));\n+            return Some((self.macro_def_scope(ctxt.remove_mark()), None));\n         }\n \n         if let ModuleKind::Block(..) = module.kind {\n-            return Some(module.parent.unwrap().nearest_item_scope());\n-        }\n-\n-        None\n-    }\n-\n-    fn hygienic_lexical_parent_with_compatibility_fallback(\n-        &mut self,\n-        module: Module<'a>,\n-        ctxt: &mut SyntaxContext,\n-        node_id: NodeId,\n-        poisoned: &mut Option<NodeId>,\n-    ) -> Option<Module<'a>> {\n-        if let module @ Some(..) = self.hygienic_lexical_parent(module, ctxt) {\n-            return module;\n+            return Some((module.parent.unwrap().nearest_item_scope(), None));\n         }\n \n         // We need to support the next case under a deprecation warning\n@@ -2015,20 +1946,21 @@ impl<'a> Resolver<'a> {\n         // ---- end\n         // ```\n         // So we have to fall back to the module's parent during lexical resolution in this case.\n-        if let Some(parent) = module.parent {\n-            // Inner module is inside the macro, parent module is outside of the macro.\n-            if module.expansion != parent.expansion\n-                && module.expansion.is_descendant_of(parent.expansion)\n-            {\n-                // The macro is a proc macro derive\n-                if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n-                    let ext = self.get_macro_by_def_id(def_id);\n-                    if ext.builtin_name.is_none()\n-                        && ext.macro_kind() == MacroKind::Derive\n-                        && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n-                    {\n-                        *poisoned = Some(node_id);\n-                        return module.parent;\n+        if derive_fallback_lint_id.is_some() {\n+            if let Some(parent) = module.parent {\n+                // Inner module is inside the macro, parent module is outside of the macro.\n+                if module.expansion != parent.expansion\n+                    && module.expansion.is_descendant_of(parent.expansion)\n+                {\n+                    // The macro is a proc macro derive\n+                    if let Some(def_id) = module.expansion.expn_data().macro_def_id {\n+                        let ext = self.get_macro_by_def_id(def_id);\n+                        if ext.builtin_name.is_none()\n+                            && ext.macro_kind() == MacroKind::Derive\n+                            && parent.expansion.outer_expn_is_descendant_of(*ctxt)\n+                        {\n+                            return Some((parent, derive_fallback_lint_id));\n+                        }\n                     }\n                 }\n             }"}, {"sha": "d238f65c941af32aed1c7aa358069a64b4aed658", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ee0357af3b57379153e023bbc91975e26301e40c/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee0357af3b57379153e023bbc91975e26301e40c/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=ee0357af3b57379153e023bbc91975e26301e40c", "patch": "@@ -24,7 +24,8 @@ use rustc_hir::def_id;\n use rustc_hir::PrimTy;\n use rustc_middle::middle::stability;\n use rustc_middle::ty;\n-use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, SOFT_UNSTABLE, UNUSED_MACROS};\n+use rustc_session::lint::builtin::{LEGACY_DERIVE_HELPERS, PROC_MACRO_DERIVE_RESOLUTION_FALLBACK};\n+use rustc_session::lint::builtin::{SOFT_UNSTABLE, UNUSED_MACROS};\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n@@ -642,7 +643,7 @@ impl<'a> Resolver<'a> {\n     crate fn early_resolve_ident_in_lexical_scope(\n         &mut self,\n         orig_ident: Ident,\n-        scope_set: ScopeSet,\n+        scope_set: ScopeSet<'a>,\n         parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         force: bool,\n@@ -669,6 +670,7 @@ impl<'a> Resolver<'a> {\n             ScopeSet::All(ns, is_import) => (ns, None, is_import),\n             ScopeSet::AbsolutePath(ns) => (ns, None, false),\n             ScopeSet::Macro(macro_kind) => (MacroNS, Some(macro_kind), false),\n+            ScopeSet::Late(ns, ..) => (ns, None, false),\n         };\n \n         // This is *the* result, resolution from the scope closest to the resolved identifier.\n@@ -777,19 +779,34 @@ impl<'a> Resolver<'a> {\n                             Err((Determinacy::Determined, _)) => Err(Determinacy::Determined),\n                         }\n                     }\n-                    Scope::Module(module) => {\n+                    Scope::Module(module, derive_fallback_lint_id) => {\n                         let adjusted_parent_scope = &ParentScope { module, ..*parent_scope };\n                         let binding = this.resolve_ident_in_module_unadjusted_ext(\n                             ModuleOrUniformRoot::Module(module),\n                             ident,\n                             ns,\n                             adjusted_parent_scope,\n-                            true,\n+                            !matches!(scope_set, ScopeSet::Late(..)),\n                             record_used,\n                             path_span,\n                         );\n                         match binding {\n                             Ok(binding) => {\n+                                if let Some(lint_id) = derive_fallback_lint_id {\n+                                    this.lint_buffer.buffer_lint_with_diagnostic(\n+                                        PROC_MACRO_DERIVE_RESOLUTION_FALLBACK,\n+                                        lint_id,\n+                                        orig_ident.span,\n+                                        &format!(\n+                                            \"cannot find {} `{}` in this scope\",\n+                                            ns.descr(),\n+                                            ident\n+                                        ),\n+                                        BuiltinLintDiagnostics::ProcMacroDeriveResolutionFallback(\n+                                            orig_ident.span,\n+                                        ),\n+                                    );\n+                                }\n                                 let misc_flags = if ptr::eq(module, this.graph_root) {\n                                     Flags::MISC_SUGGEST_CRATE\n                                 } else if module.is_normal() {\n@@ -873,7 +890,7 @@ impl<'a> Resolver<'a> {\n                     Ok((binding, flags))\n                         if sub_namespace_match(binding.macro_kind(), macro_kind) =>\n                     {\n-                        if !record_used {\n+                        if !record_used || matches!(scope_set, ScopeSet::Late(..)) {\n                             return Some(Ok(binding));\n                         }\n "}, {"sha": "5a4ed65ecdc8fe265a2487bc69e2e0ef2ec208c8", "filename": "src/test/ui/proc-macro/generate-mod.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ee0357af3b57379153e023bbc91975e26301e40c/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ee0357af3b57379153e023bbc91975e26301e40c/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fgenerate-mod.stderr?ref=ee0357af3b57379153e023bbc91975e26301e40c", "patch": "@@ -46,7 +46,8 @@ LL | #[derive(generate_mod::CheckDerive)]\n    |\n    = note: `#[warn(proc_macro_derive_resolution_fallback)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: this warning originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: cannot find type `OuterDerive` in this scope\n   --> $DIR/generate-mod.rs:16:10\n@@ -55,7 +56,8 @@ LL | #[derive(generate_mod::CheckDerive)]\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: this warning originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: cannot find type `FromOutside` in this scope\n   --> $DIR/generate-mod.rs:23:14\n@@ -64,7 +66,8 @@ LL |     #[derive(generate_mod::CheckDerive)]\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: this warning originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n warning: cannot find type `OuterDerive` in this scope\n   --> $DIR/generate-mod.rs:23:14\n@@ -73,7 +76,8 @@ LL |     #[derive(generate_mod::CheckDerive)]\n    |              ^^^^^^^^^^^^^^^^^^^^^^^^^ names from parent modules are not accessible without an explicit import\n    |\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #50504 <https://github.com/rust-lang/rust/issues/50504>\n+   = note: for more information, see issue #83583 <https://github.com/rust-lang/rust/issues/83583>\n+   = note: this warning originates in a derive macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors; 4 warnings emitted\n "}]}