{"sha": "081c3aa76dd0805767e0233c0cc6ccf313cf44ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MWMzYWE3NmRkMDgwNTc2N2UwMjMzYzBjYzZjY2YzMTNjZjQ0YmE=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-02-25T20:58:08Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-02-25T20:58:08Z"}, "message": "Pass the abi of native functions all the way to codegen.", "tree": {"sha": "59b76080da8a103b3a8dd7306ffbf2e4d4ed86f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59b76080da8a103b3a8dd7306ffbf2e4d4ed86f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/081c3aa76dd0805767e0233c0cc6ccf313cf44ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/081c3aa76dd0805767e0233c0cc6ccf313cf44ba", "html_url": "https://github.com/rust-lang/rust/commit/081c3aa76dd0805767e0233c0cc6ccf313cf44ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/081c3aa76dd0805767e0233c0cc6ccf313cf44ba/comments", "author": null, "committer": null, "parents": [{"sha": "f8f6f078c505dd0f20526e3ad86c360605fce109", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8f6f078c505dd0f20526e3ad86c360605fce109", "html_url": "https://github.com/rust-lang/rust/commit/f8f6f078c505dd0f20526e3ad86c360605fce109"}], "stats": {"total": 83, "additions": 51, "deletions": 32}, "files": [{"sha": "32bcf6efe7682e79c998b595f5ced0b97eb6e431", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/081c3aa76dd0805767e0233c0cc6ccf313cf44ba/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c3aa76dd0805767e0233c0cc6ccf313cf44ba/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=081c3aa76dd0805767e0233c0cc6ccf313cf44ba", "patch": "@@ -1818,8 +1818,8 @@ impure fn parse_item_native_mod(parser p) -> @ast.item {\n     auto abi = ast.native_abi_cdecl;\n     if (p.peek() != token.MOD) {\n         auto t = parse_str_lit(p);\n-        if (t == \"cdecl\") {\n-        } else if (t == \"rust\") {\n+        if (_str.eq(t, \"cdecl\")) {\n+        } else if (_str.eq(t, \"rust\")) {\n             abi = ast.native_abi_rust;\n         } else {\n             p.err(\"unsupported abi: \" + t);"}, {"sha": "d175432da10fcf1c916a0621309ddc42a9ed5a7f", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/081c3aa76dd0805767e0233c0cc6ccf313cf44ba/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c3aa76dd0805767e0233c0cc6ccf313cf44ba/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=081c3aa76dd0805767e0233c0cc6ccf313cf44ba", "patch": "@@ -516,7 +516,8 @@ fn type_of_fn(@crate_ctxt cx,\n     ret type_of_fn_full(cx, proto, none[TypeRef], inputs, output);\n }\n \n-fn type_of_native_fn(@crate_ctxt cx, vec[ty.arg] inputs,\n+fn type_of_native_fn(@crate_ctxt cx, ast.native_abi abi,\n+                     vec[ty.arg] inputs,\n                      @ty.t output) -> TypeRef {\n     let vec[TypeRef] atys = type_of_explicit_args(cx, inputs);\n     ret T_fn(atys, type_of(cx, output));\n@@ -571,8 +572,8 @@ fn type_of_inner(@crate_ctxt cx, @ty.t t) -> TypeRef {\n         case (ty.ty_fn(?proto, ?args, ?out)) {\n             ret T_fn_pair(cx.tn, type_of_fn(cx, proto, args, out));\n         }\n-        case (ty.ty_native_fn(?args, ?out)) {\n-            ret T_fn_pair(cx.tn, type_of_native_fn(cx, args, out));\n+        case (ty.ty_native_fn(?abi, ?args, ?out)) {\n+            ret T_fn_pair(cx.tn, type_of_native_fn(cx, abi, args, out));\n         }\n         case (ty.ty_obj(?meths)) {\n             auto th = mk_type_handle();"}, {"sha": "f19c2997b924de60e7db600709178899744058fd", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/081c3aa76dd0805767e0233c0cc6ccf313cf44ba/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c3aa76dd0805767e0233c0cc6ccf313cf44ba/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=081c3aa76dd0805767e0233c0cc6ccf313cf44ba", "patch": "@@ -41,7 +41,7 @@ tag sty {\n     ty_tup(vec[@t]);\n     ty_rec(vec[field]);\n     ty_fn(ast.proto, vec[arg], @t);                 // TODO: effect\n-    ty_native_fn(vec[arg], @t);                     // TODO: effect\n+    ty_native_fn(ast.native_abi, vec[arg], @t);     // TODO: effect\n     ty_obj(vec[method]);\n     ty_var(int);                                    // ephemeral type var\n     ty_local(ast.def_id);                           // type of a local var\n@@ -261,7 +261,7 @@ fn ty_to_str(&@t typ) -> str {\n             s = fn_to_str(proto, none[ast.ident], inputs, output);\n         }\n \n-        case (ty_native_fn(?inputs, ?output)) {\n+        case (ty_native_fn(_, ?inputs, ?output)) {\n             s = fn_to_str(ast.proto_fn, none[ast.ident], inputs, output);\n         }\n \n@@ -346,13 +346,13 @@ fn fold_ty(ty_fold fld, @t ty) -> @t {\n             }\n             ret rewrap(ty, ty_fn(proto, new_args, fold_ty(fld, ret_ty)));\n         }\n-        case (ty_native_fn(?args, ?ret_ty)) {\n+        case (ty_native_fn(?abi, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n                 auto new_ty = fold_ty(fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ret rewrap(ty, ty_native_fn(new_args, fold_ty(fld, ret_ty)));\n+            ret rewrap(ty, ty_native_fn(abi, new_args, fold_ty(fld, ret_ty)));\n         }\n         case (ty_obj(?methods)) {\n             let vec[method] new_methods = vec();\n@@ -596,7 +596,7 @@ fn count_ty_params(@t ty) -> uint {\n fn ty_fn_args(@t fty) -> vec[arg] {\n     alt (fty.struct) {\n         case (ty.ty_fn(_, ?a, _)) { ret a; }\n-        case (ty.ty_native_fn(?a, _)) { ret a; }\n+        case (ty.ty_native_fn(_, ?a, _)) { ret a; }\n     }\n     fail;\n }\n@@ -611,15 +611,15 @@ fn ty_fn_proto(@t fty) -> ast.proto {\n fn ty_fn_ret(@t fty) -> @t {\n     alt (fty.struct) {\n         case (ty.ty_fn(_, _, ?r)) { ret r; }\n-        case (ty.ty_native_fn(_, ?r)) { ret r; }\n+        case (ty.ty_native_fn(_, _, ?r)) { ret r; }\n     }\n     fail;\n }\n \n fn is_fn_ty(@t fty) -> bool {\n     alt (fty.struct) {\n         case (ty.ty_fn(_, _, _)) { ret true; }\n-        case (ty.ty_native_fn(_, _)) { ret true; }\n+        case (ty.ty_native_fn(_, _, _)) { ret true; }\n         case (_) { ret false; }\n     }\n     ret false;\n@@ -938,12 +938,18 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n     }\n \n     fn unify_native_fn(@hashmap[int,@ty.t] bindings,\n+                       ast.native_abi e_abi,\n+                       ast.native_abi a_abi,\n                        @ty.t expected,\n                        @ty.t actual,\n                        &unify_handler handler,\n                        vec[arg] expected_inputs, @t expected_output,\n                        vec[arg] actual_inputs, @t actual_output)\n         -> unify_result {\n+        if (e_abi != a_abi) {\n+            ret ures_err(terr_mismatch, expected, actual);\n+        }\n+\n         auto t = unify_fn_common(bindings, expected, actual,\n                                  handler, expected_inputs, expected_output,\n                                  actual_inputs, actual_output);\n@@ -952,7 +958,8 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 ret r;\n             }\n             case (fn_common_res_ok(?result_ins, ?result_out)) {\n-                auto t2 = plain_ty(ty.ty_native_fn(result_ins, result_out));\n+                auto t2 = plain_ty(ty.ty_native_fn(e_abi, result_ins,\n+                                                   result_out));\n                 ret ures_ok(t2);\n             }\n         }\n@@ -1314,10 +1321,12 @@ fn unify(@ty.t expected, @ty.t actual, &unify_handler handler)\n                 }\n             }\n \n-            case (ty.ty_native_fn(?expected_inputs, ?expected_output)) {\n+            case (ty.ty_native_fn(?e_abi, ?expected_inputs,\n+                                  ?expected_output)) {\n                 alt (actual.struct) {\n-                    case (ty.ty_native_fn(?actual_inputs, ?actual_output)) {\n-                        ret unify_native_fn(bindings,\n+                    case (ty.ty_native_fn(?a_abi, ?actual_inputs,\n+                                          ?actual_output)) {\n+                        ret unify_native_fn(bindings, e_abi, a_abi,\n                                             expected, actual, handler,\n                                             expected_inputs, expected_output,\n                                             actual_inputs, actual_output);"}, {"sha": "ce1c59ec01f787bdf08bf8ee7049ca8e3a245231", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/081c3aa76dd0805767e0233c0cc6ccf313cf44ba/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/081c3aa76dd0805767e0233c0cc6ccf313cf44ba/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=081c3aa76dd0805767e0233c0cc6ccf313cf44ba", "patch": "@@ -35,7 +35,7 @@ type ty_table = hashmap[ast.def_id, @ty.t];\n \n tag any_item {\n     any_item_rust(@ast.item);\n-    any_item_native(@ast.native_item);\n+    any_item_native(@ast.native_item, ast.native_abi);\n }\n \n type ty_item_table = hashmap[ast.def_id,any_item];\n@@ -272,7 +272,7 @@ fn ast_ty_to_ty_crate(@crate_ctxt ccx, &@ast.ty ast_ty) -> @ty.t {\n                 ty = actual_type(ty, item);\n                 params = ty_params_of_item(item);\n             }\n-            case (any_item_native(?native_item)) {\n+            case (any_item_native(?native_item, _)) {\n                 params = ty_params_of_native_item(native_item);\n            }\n         }\n@@ -346,10 +346,11 @@ fn ty_of_native_fn_decl(@ty_item_table id_to_ty_item,\n                  fn(&@ast.ty ast_ty) -> @ty.t convert,\n                  fn(&ast.arg a) -> arg ty_of_arg,\n                  &ast.fn_decl decl,\n+                 ast.native_abi abi,\n                  ast.def_id def_id) -> @ty.t {\n     auto input_tys = _vec.map[ast.arg,arg](ty_of_arg, decl.inputs);\n     auto output_ty = convert(decl.output);\n-    auto t_fn = plain_ty(ty.ty_native_fn(input_tys, output_ty));\n+    auto t_fn = plain_ty(ty.ty_native_fn(abi, input_tys, output_ty));\n     item_to_ty.insert(def_id, t_fn);\n     ret t_fn;\n }\n@@ -370,9 +371,9 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n                 ty = actual_type(ty, item);\n                 params = ty_params_of_item(item);\n             }\n-            case (any_item_native(?native_item)) {\n+            case (any_item_native(?native_item, ?abi)) {\n                 ty = ty_of_native_item(id_to_ty_item, item_to_ty,\n-                                       native_item);\n+                                       native_item, abi);\n                 params = ty_params_of_native_item(native_item);\n             }\n         }\n@@ -490,14 +491,15 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n     fn ty_of_native_item(@ty_item_table id_to_ty_item,\n                          @ty_table item_to_ty,\n-                         @ast.native_item it) -> @ty.t {\n+                         @ast.native_item it,\n+                         ast.native_abi abi) -> @ty.t {\n         alt (it.node) {\n             case (ast.native_item_fn(?ident, ?fn_decl, ?params, ?def_id, _)) {\n                 auto get = bind getter(id_to_ty_item, item_to_ty, _);\n                 auto convert = bind ast_ty_to_ty(get, _);\n                 auto f = bind ty_of_arg(id_to_ty_item, item_to_ty, _);\n                 ret ty_of_native_fn_decl(id_to_ty_item, item_to_ty, convert,\n-                                         f, fn_decl, def_id);\n+                                         f, fn_decl, abi, def_id);\n             }\n             case (ast.native_item_ty(_, ?def_id)) {\n                 if (item_to_ty.contains_key(def_id)) {\n@@ -578,7 +580,10 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n         -> @ty_item_table {\n         alt (i.node) {\n             case (ast.native_item_ty(_, ?def_id)) {\n-                id_to_ty_item.insert(def_id, any_item_native(i));\n+                // The abi of types is not used.\n+                id_to_ty_item.insert(def_id,\n+                                     any_item_native(i,\n+                                                     ast.native_abi_cdecl));\n             }\n             case (_) {\n             }\n@@ -598,30 +603,34 @@ fn collect_item_types(session.session sess, @ast.crate crate)\n \n     type env = rec(session.session sess,\n                    @ty_item_table id_to_ty_item,\n-                   @ty_table item_to_ty);\n+                   @ty_table item_to_ty,\n+                   ast.native_abi abi);\n     let @env e = @rec(sess=sess,\n                       id_to_ty_item=id_to_ty_item,\n-                      item_to_ty=item_to_ty);\n+                      item_to_ty=item_to_ty,\n+                      abi=ast.native_abi_cdecl);\n \n     fn convert(&@env e, @ast.item i) -> @env {\n+        auto abi = e.abi;\n         alt (i.node) {\n             case (ast.item_mod(_, _, _)) {\n                 // ignore item_mod, it has no type.\n             }\n-            case (ast.item_native_mod(_, _, _)) {\n+            case (ast.item_native_mod(_, ?native_mod, _)) {\n                 // ignore item_native_mod, it has no type.\n+                abi = native_mod.abi;\n             }\n             case (_) {\n                 // This call populates the ty_table with the converted type of\n                 // the item in passing; we don't need to do anything else.\n                 ty_of_item(e.id_to_ty_item, e.item_to_ty, i);\n             }\n         }\n-        ret e;\n+        ret @rec(abi=abi with *e);\n     }\n \n     fn convert_native(&@env e, @ast.native_item i) -> @env {\n-        ty_of_native_item(e.id_to_ty_item, e.item_to_ty, i);\n+        ty_of_native_item(e.id_to_ty_item, e.item_to_ty, i, e.abi);\n         ret e;\n     }\n \n@@ -1322,8 +1331,8 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             case (ty.ty_fn(?proto, _, _))   {\n                 t_0 = plain_ty(ty.ty_fn(proto, arg_tys_0, rt_0));\n             }\n-            case (ty.ty_native_fn(_, _))   {\n-                t_0 = plain_ty(ty.ty_native_fn(arg_tys_0, rt_0));\n+            case (ty.ty_native_fn(?abi, _, _))   {\n+                t_0 = plain_ty(ty.ty_native_fn(abi, arg_tys_0, rt_0));\n             }\n             case (_) {\n                 log \"check_call_or_bind(): fn expr doesn't have fn type\";\n@@ -1807,7 +1816,7 @@ fn check_expr(&@fn_ctxt fcx, @ast.expr expr) -> @ast.expr {\n             auto rt_1 = plain_ty(ty.ty_nil);    // FIXME: typestate botch\n             alt (expr_ty(result._0).struct) {\n                 case (ty.ty_fn(_,_,?rt))    { rt_1 = rt; }\n-                case (ty.ty_native_fn(_,?rt))    { rt_1 = rt; }\n+                case (ty.ty_native_fn(_, _, ?rt))    { rt_1 = rt; }\n                 case (_) {\n                     log \"LHS of call expr didn't have a function type?!\";\n                     fail;"}]}