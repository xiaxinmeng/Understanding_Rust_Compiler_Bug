{"sha": "c32b26be1000673e06ef2e5d114e39a28a5d6cd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzMmIyNmJlMTAwMDY3M2UwNmVmMmU1ZDExNGUzOWEyOGE1ZDZjZDU=", "commit": {"author": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2013-07-27T05:50:20Z"}, "committer": {"name": "Luqman Aden", "email": "laden@csclub.uwaterloo.ca", "date": "2013-07-27T05:50:20Z"}, "message": "librustc: Unify name mangling for functions and statics.", "tree": {"sha": "6481590dc9c6907dc61594f64764fec58d3750e6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6481590dc9c6907dc61594f64764fec58d3750e6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c32b26be1000673e06ef2e5d114e39a28a5d6cd5", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c32b26be1000673e06ef2e5d114e39a28a5d6cd5", "html_url": "https://github.com/rust-lang/rust/commit/c32b26be1000673e06ef2e5d114e39a28a5d6cd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c32b26be1000673e06ef2e5d114e39a28a5d6cd5/comments", "author": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "committer": {"login": "luqmana", "id": 287063, "node_id": "MDQ6VXNlcjI4NzA2Mw==", "avatar_url": "https://avatars.githubusercontent.com/u/287063?v=4", "gravatar_id": "", "url": "https://api.github.com/users/luqmana", "html_url": "https://github.com/luqmana", "followers_url": "https://api.github.com/users/luqmana/followers", "following_url": "https://api.github.com/users/luqmana/following{/other_user}", "gists_url": "https://api.github.com/users/luqmana/gists{/gist_id}", "starred_url": "https://api.github.com/users/luqmana/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/luqmana/subscriptions", "organizations_url": "https://api.github.com/users/luqmana/orgs", "repos_url": "https://api.github.com/users/luqmana/repos", "events_url": "https://api.github.com/users/luqmana/events{/privacy}", "received_events_url": "https://api.github.com/users/luqmana/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82394013d90f1dfe8f3f990809c74e3f149e23e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82394013d90f1dfe8f3f990809c74e3f149e23e", "html_url": "https://github.com/rust-lang/rust/commit/e82394013d90f1dfe8f3f990809c74e3f149e23e"}], "stats": {"total": 337, "additions": 172, "deletions": 165}, "files": [{"sha": "b0aa35c272b047e789dd4fbd3ce1d698b68f1c73", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 167, "deletions": 159, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/c32b26be1000673e06ef2e5d114e39a28a5d6cd5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32b26be1000673e06ef2e5d114e39a28a5d6cd5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=c32b26be1000673e06ef2e5d114e39a28a5d6cd5", "patch": "@@ -2244,47 +2244,38 @@ pub fn trans_mod(ccx: @mut CrateContext, m: &ast::_mod) {\n \n pub fn register_fn(ccx: @mut CrateContext,\n                    sp: span,\n-                   path: path,\n-                   node_id: ast::node_id,\n-                   attrs: &[ast::Attribute])\n+                   sym: ~str,\n+                   node_id: ast::node_id)\n                 -> ValueRef {\n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n-    register_fn_full(ccx, sp, path, node_id, attrs, t)\n+    register_fn_full(ccx, sp, sym, node_id, t)\n }\n \n pub fn register_fn_full(ccx: @mut CrateContext,\n                         sp: span,\n-                        path: path,\n+                        sym: ~str,\n                         node_id: ast::node_id,\n-                        attrs: &[ast::Attribute],\n                         node_type: ty::t)\n                      -> ValueRef {\n     let llfty = type_of_fn_from_ty(ccx, node_type);\n-    register_fn_fuller(ccx, sp, path, node_id, attrs, node_type,\n+    register_fn_fuller(ccx, sp, sym, node_id, node_type,\n                        lib::llvm::CCallConv, llfty)\n }\n \n pub fn register_fn_fuller(ccx: @mut CrateContext,\n                           sp: span,\n-                          path: path,\n+                          sym: ~str,\n                           node_id: ast::node_id,\n-                          attrs: &[ast::Attribute],\n                           node_type: ty::t,\n                           cc: lib::llvm::CallConv,\n                           fn_ty: Type)\n                           -> ValueRef {\n     debug!(\"register_fn_fuller creating fn for item %d with path %s\",\n            node_id,\n-           ast_map::path_to_str(path, token::get_ident_interner()));\n-\n-    let ps = if attr::contains_name(attrs, \"no_mangle\") {\n-        path_elt_to_str(*path.last(), token::get_ident_interner())\n-    } else {\n-        mangle_exported_name(ccx, path, node_type)\n-    };\n+           ast_map::path_to_str(item_path(ccx, &node_id), token::get_ident_interner()));\n \n-    let llfn = decl_fn(ccx.llmod, ps, cc, fn_ty);\n-    ccx.item_symbols.insert(node_id, ps);\n+    let llfn = decl_fn(ccx.llmod, sym, cc, fn_ty);\n+    ccx.item_symbols.insert(node_id, sym);\n \n     // FIXME #4404 android JNI hacks\n     let is_entry = is_entry_fn(&ccx.sess, node_id) && (!*ccx.sess.building_library ||\n@@ -2430,167 +2421,182 @@ pub fn fill_fn_pair(bcx: @mut Block, pair: ValueRef, llfn: ValueRef,\n     Store(bcx, llenvblobptr, env_cell);\n }\n \n-pub fn item_path(ccx: &CrateContext, i: &ast::item) -> path {\n-    let base = match ccx.tcx.items.get_copy(&i.id) {\n-        ast_map::node_item(_, p) => p,\n-            // separate map for paths?\n+pub fn item_path(ccx: &CrateContext, id: &ast::node_id) -> path {\n+    match ccx.tcx.items.get_copy(id) {\n+        ast_map::node_item(i, p) =>\n+            vec::append((*p).clone(), [path_name(i.ident)]),\n+        // separate map for paths?\n         _ => fail!(\"item_path\")\n-    };\n-    vec::append((*base).clone(), [path_name(i.ident)])\n+    }\n+}\n+\n+fn exported_name(ccx: @mut CrateContext, path: path, ty: ty::t, attrs: &[ast::Attribute]) -> ~str {\n+    if attr::contains_name(attrs, \"no_mangle\") {\n+        path_elt_to_str(*path.last(), token::get_ident_interner())\n+    } else {\n+        mangle_exported_name(ccx, path, ty)\n+    }\n }\n \n pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n     debug!(\"get_item_val(id=`%?`)\", id);\n+\n     let val = ccx.item_vals.find_copy(&id);\n     match val {\n-      Some(v) => v,\n-      None => {\n-        let mut exprt = false;\n-        let item = ccx.tcx.items.get_copy(&id);\n-        let val = match item {\n-          ast_map::node_item(i, pth) => {\n-            let my_path = vec::append((*pth).clone(), [path_name(i.ident)]);\n-            let v = match i.node {\n-              ast::item_static(_, m, expr) => {\n-                let typ = ty::node_id_to_type(ccx.tcx, i.id);\n-                let s =\n-                    if attr::contains_name(i.attrs, \"no_mangle\") {\n-                        path_elt_to_str(*my_path.last(), token::get_ident_interner())\n-                    } else {\n-                        mangle_exported_name(ccx, my_path, typ)\n-                    };\n-                // We need the translated value here, because for enums the\n-                // LLVM type is not fully determined by the Rust type.\n-                let v = consts::const_expr(ccx, expr);\n-                ccx.const_values.insert(id, v);\n-                exprt = m == ast::m_mutbl;\n-                unsafe {\n-                    let llty = llvm::LLVMTypeOf(v);\n-                    let g = do s.as_c_str |buf| {\n-                        llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n+        Some(v) => v,\n+        None => {\n+            let mut exprt = false;\n+            let item = ccx.tcx.items.get_copy(&id);\n+            let val = match item {\n+                ast_map::node_item(i, pth) => {\n+\n+                    let my_path = vec::append((*pth).clone(), [path_name(i.ident)]);\n+                    let ty = ty::node_id_to_type(ccx.tcx, i.id);\n+                    let sym = exported_name(ccx, my_path, ty, i.attrs);\n+\n+                    let v = match i.node {\n+                        ast::item_static(_, m, expr) => {\n+                            // We need the translated value here, because for enums the\n+                            // LLVM type is not fully determined by the Rust type.\n+                            let v = consts::const_expr(ccx, expr);\n+                            ccx.const_values.insert(id, v);\n+                            exprt = m == ast::m_mutbl;\n+\n+                            unsafe {\n+                                let llty = llvm::LLVMTypeOf(v);\n+                                let g = do sym.as_c_str |buf| {\n+                                    llvm::LLVMAddGlobal(ccx.llmod, llty, buf)\n+                                };\n+\n+                                ccx.item_symbols.insert(i.id, sym);\n+                                g\n+                            }\n+                        }\n+\n+                        ast::item_fn(_, purity, _, _, _) => {\n+                            let llfn = if purity != ast::extern_fn {\n+                                register_fn_full(ccx, i.span, sym, i.id, ty)\n+                            } else {\n+                                foreign::register_foreign_fn(ccx, i.span, sym, i.id)\n+                            };\n+                            set_inline_hint_if_appr(i.attrs, llfn);\n+                            llfn\n+                        }\n+\n+                        _ => fail!(\"get_item_val: weird result in table\")\n                     };\n-                    ccx.item_symbols.insert(i.id, s);\n-                    g\n-                }\n-              }\n-              ast::item_fn(_, purity, _, _, _) => {\n-                let llfn = if purity != ast::extern_fn {\n-                    register_fn(ccx, i.span, my_path, i.id, i.attrs)\n-                } else {\n-                    foreign::register_foreign_fn(ccx,\n-                                                 i.span,\n-                                                 my_path,\n-                                                 i.id,\n-                                                 i.attrs)\n-                };\n-                set_inline_hint_if_appr(i.attrs, llfn);\n-                llfn\n-              }\n-              _ => fail!(\"get_item_val: weird result in table\")\n-            };\n-            match (attr::first_attr_value_str_by_name(i.attrs, \"link_section\")) {\n-                Some(sect) => unsafe {\n-                    do sect.as_c_str |buf| {\n-                        llvm::LLVMSetSection(v, buf);\n+\n+                    match (attr::first_attr_value_str_by_name(i.attrs, \"link_section\")) {\n+                        Some(sect) => unsafe {\n+                            do sect.as_c_str |buf| {\n+                                llvm::LLVMSetSection(v, buf);\n+                            }\n+                        },\n+                        None => ()\n                     }\n-                },\n-                None => ()\n-            }\n-            v\n-          }\n-          ast_map::node_trait_method(trait_method, _, pth) => {\n-            debug!(\"get_item_val(): processing a node_trait_method\");\n-            match *trait_method {\n-              ast::required(_) => {\n-                ccx.sess.bug(\"unexpected variant: required trait method in \\\n-                              get_item_val()\");\n-              }\n-              ast::provided(m) => {\n-                exprt = true;\n-                register_method(ccx, id, pth, m)\n-              }\n-            }\n-          }\n-          ast_map::node_method(m, _, pth) => {\n-            register_method(ccx, id, pth, m)\n-          }\n-          ast_map::node_foreign_item(ni, _, _, pth) => {\n-            exprt = true;\n-            match ni.node {\n-                ast::foreign_item_fn(*) => {\n-                    register_fn(ccx, ni.span,\n-                                vec::append((*pth).clone(),\n-                                            [path_name(ni.ident)]),\n-                                ni.id,\n-                                ni.attrs)\n+\n+                    v\n                 }\n-                ast::foreign_item_static(*) => {\n-                    let typ = ty::node_id_to_type(ccx.tcx, ni.id);\n-                    let ident = token::ident_to_str(&ni.ident);\n-                    let g = do ident.as_c_str |buf| {\n-                        unsafe {\n-                            let ty = type_of(ccx, typ);\n-                            llvm::LLVMAddGlobal(ccx.llmod, ty.to_ref(), buf)\n+\n+                ast_map::node_trait_method(trait_method, _, pth) => {\n+                    debug!(\"get_item_val(): processing a node_trait_method\");\n+                    match *trait_method {\n+                        ast::required(_) => {\n+                            ccx.sess.bug(\"unexpected variant: required trait method in \\\n+                                         get_item_val()\");\n                         }\n-                    };\n-                    g\n+                        ast::provided(m) => {\n+                            exprt = true;\n+                            register_method(ccx, id, pth, m)\n+                        }\n+                    }\n                 }\n-            }\n-          }\n \n-          ast_map::node_variant(ref v, enm, pth) => {\n-            let llfn;\n-            match v.node.kind {\n-                ast::tuple_variant_kind(ref args) => {\n-                    assert!(args.len() != 0u);\n-                    let pth = vec::append((*pth).clone(),\n-                                          [path_name(enm.ident),\n-                                           path_name((*v).node.name)]);\n-                    llfn = match enm.node {\n-                      ast::item_enum(_, _) => {\n-                        register_fn(ccx, (*v).span, pth, id, enm.attrs)\n-                      }\n-                      _ => fail!(\"node_variant, shouldn't happen\")\n-                    };\n+                ast_map::node_method(m, _, pth) => {\n+                    register_method(ccx, id, pth, m)\n                 }\n-                ast::struct_variant_kind(_) => {\n-                    fail!(\"struct variant kind unexpected in get_item_val\")\n-                }\n-            }\n-            set_inline_hint(llfn);\n-            llfn\n-          }\n \n-          ast_map::node_struct_ctor(struct_def, struct_item, struct_path) => {\n-            // Only register the constructor if this is a tuple-like struct.\n-            match struct_def.ctor_id {\n-                None => {\n-                    ccx.tcx.sess.bug(\"attempt to register a constructor of \\\n-                                  a non-tuple-like struct\")\n+                ast_map::node_foreign_item(ni, _, _, pth) => {\n+                    let ty = ty::node_id_to_type(ccx.tcx, ni.id);\n+                    exprt = true;\n+\n+                    match ni.node {\n+                        ast::foreign_item_fn(*) => {\n+                            let path = vec::append((*pth).clone(), [path_name(ni.ident)]);\n+                            let sym = exported_name(ccx, path, ty, ni.attrs);\n+\n+                            register_fn_full(ccx, ni.span, sym, ni.id, ty)\n+                        }\n+                        ast::foreign_item_static(*) => {\n+                            let ident = token::ident_to_str(&ni.ident);\n+                            let g = do ident.as_c_str |buf| {\n+                                unsafe {\n+                                    let ty = type_of(ccx, ty);\n+                                    llvm::LLVMAddGlobal(ccx.llmod, ty.to_ref(), buf)\n+                                }\n+                            };\n+                            g\n+                        }\n+                    }\n                 }\n-                Some(ctor_id) => {\n-                    let llfn = register_fn(ccx,\n-                                           struct_item.span,\n-                                           (*struct_path).clone(),\n-                                           ctor_id,\n-                                           struct_item.attrs);\n+\n+                ast_map::node_variant(ref v, enm, pth) => {\n+                    let llfn;\n+                    match v.node.kind {\n+                        ast::tuple_variant_kind(ref args) => {\n+                            assert!(args.len() != 0u);\n+                            let pth = vec::append((*pth).clone(),\n+                                                  [path_name(enm.ident),\n+                                                   path_name((*v).node.name)]);\n+                            let ty = ty::node_id_to_type(ccx.tcx, id);\n+                            let sym = exported_name(ccx, pth, ty, enm.attrs);\n+\n+                            llfn = match enm.node {\n+                                ast::item_enum(_, _) => {\n+                                    register_fn_full(ccx, (*v).span, sym, id, ty)\n+                                }\n+                                _ => fail!(\"node_variant, shouldn't happen\")\n+                            };\n+                        }\n+                        ast::struct_variant_kind(_) => {\n+                            fail!(\"struct variant kind unexpected in get_item_val\")\n+                        }\n+                    }\n                     set_inline_hint(llfn);\n                     llfn\n                 }\n+\n+                ast_map::node_struct_ctor(struct_def, struct_item, struct_path) => {\n+                    // Only register the constructor if this is a tuple-like struct.\n+                    match struct_def.ctor_id {\n+                        None => {\n+                            ccx.tcx.sess.bug(\"attempt to register a constructor of \\\n+                                              a non-tuple-like struct\")\n+                        }\n+                        Some(ctor_id) => {\n+                            let ty = ty::node_id_to_type(ccx.tcx, ctor_id);\n+                            let sym = exported_name(ccx, (*struct_path).clone(), ty,\n+                                                    struct_item.attrs);\n+                            let llfn = register_fn_full(ccx, struct_item.span, sym, ctor_id, ty);\n+                            set_inline_hint(llfn);\n+                            llfn\n+                        }\n+                    }\n+                }\n+\n+                ref variant => {\n+                    ccx.sess.bug(fmt!(\"get_item_val(): unexpected variant: %?\",\n+                                 variant))\n+                }\n+            };\n+\n+            if !exprt && !ccx.reachable.contains(&id) {\n+                lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n             }\n-          }\n \n-          ref variant => {\n-            ccx.sess.bug(fmt!(\"get_item_val(): unexpected variant: %?\",\n-                              variant))\n-          }\n-        };\n-        if !exprt && !ccx.reachable.contains(&id) {\n-            lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n+            ccx.item_vals.insert(id, val);\n+            val\n         }\n-        ccx.item_vals.insert(id, val);\n-        val\n-      }\n     }\n }\n \n@@ -2604,7 +2610,9 @@ pub fn register_method(ccx: @mut CrateContext,\n     path.push(path_name(gensym_name(\"meth\")));\n     path.push(path_name(m.ident));\n \n-    let llfn = register_fn_full(ccx, m.span, path, id, m.attrs, mty);\n+    let sym = exported_name(ccx, path, mty, m.attrs);\n+\n+    let llfn = register_fn_full(ccx, m.span, sym, id, mty);\n     set_inline_hint_if_appr(m.attrs, llfn);\n     llfn\n }\n@@ -2618,7 +2626,7 @@ pub fn trans_constant(ccx: &mut CrateContext, it: @ast::item) {\n                                    ast::def_id { crate: ast::local_crate,\n                                                  node: it.id });\n         let mut i = 0;\n-        let path = item_path(ccx, it);\n+        let path = item_path(ccx, &it.id);\n         for (*enum_definition).variants.iter().advance |variant| {\n             let p = vec::append(path.clone(), [\n                 path_name(variant.node.name),"}, {"sha": "6e198af448bb3b103a468cccc6701cf5d6f0d5b2", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c32b26be1000673e06ef2e5d114e39a28a5d6cd5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c32b26be1000673e06ef2e5d114e39a28a5d6cd5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=c32b26be1000673e06ef2e5d114e39a28a5d6cd5", "patch": "@@ -32,6 +32,7 @@ use middle::ty;\n use middle::ty::FnSig;\n use util::ppaux::ty_to_str;\n \n+use std::cell::Cell;\n use std::uint;\n use std::vec;\n use syntax::codemap::span;\n@@ -1139,22 +1140,20 @@ pub fn trans_foreign_fn(ccx: @mut CrateContext,\n \n pub fn register_foreign_fn(ccx: @mut CrateContext,\n                            sp: span,\n-                           path: ast_map::path,\n-                           node_id: ast::node_id,\n-                           attrs: &[ast::Attribute])\n+                           sym: ~str,\n+                           node_id: ast::node_id)\n                            -> ValueRef {\n     let _icx = push_ctxt(\"foreign::register_foreign_fn\");\n \n     let t = ty::node_id_to_type(ccx.tcx, node_id);\n+    let sym = Cell::new(sym);\n \n     let tys = shim_types(ccx, node_id);\n     do tys.fn_ty.decl_fn |fnty| {\n-        // XXX(pcwalton): We should not copy the path.\n         register_fn_fuller(ccx,\n                            sp,\n-                           path.clone(),\n+                           sym.take(),\n                            node_id,\n-                           attrs,\n                            t,\n                            lib::llvm::CCallConv,\n                            fnty)"}]}