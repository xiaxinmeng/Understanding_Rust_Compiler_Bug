{"sha": "1e156065471051b33ff47ec06c168e341c385c3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlMTU2MDY1NDcxMDUxYjMzZmY0N2VjMDZjMTY4ZTM0MWMzODVjM2M=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-11-03T18:13:11Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-11-05T21:30:52Z"}, "message": "rustc_ast: Visit tokens stored in AST nodes in mutable visitor", "tree": {"sha": "e0fc7e99d8821dffe6b478ffdbe70d64335381ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0fc7e99d8821dffe6b478ffdbe70d64335381ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1e156065471051b33ff47ec06c168e341c385c3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1e156065471051b33ff47ec06c168e341c385c3c", "html_url": "https://github.com/rust-lang/rust/commit/1e156065471051b33ff47ec06c168e341c385c3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1e156065471051b33ff47ec06c168e341c385c3c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9d78d1d02761b906038ba4d54c5f3427f920f5fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d78d1d02761b906038ba4d54c5f3427f920f5fb", "html_url": "https://github.com/rust-lang/rust/commit/9d78d1d02761b906038ba4d54c5f3427f920f5fb"}], "stats": {"total": 76, "additions": 61, "deletions": 15}, "files": [{"sha": "af8b8ad34c8f29db4eb6d09d8360d9d2fb16a090", "filename": "compiler/rustc_ast/src/mut_visit.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1e156065471051b33ff47ec06c168e341c385c3c/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e156065471051b33ff47ec06c168e341c385c3c/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Fmut_visit.rs?ref=1e156065471051b33ff47ec06c168e341c385c3c", "patch": "@@ -461,7 +461,7 @@ pub fn noop_visit_ty_constraint<T: MutVisitor>(\n }\n \n pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n-    let Ty { id, kind, span, tokens: _ } = ty.deref_mut();\n+    let Ty { id, kind, span, tokens } = ty.deref_mut();\n     vis.visit_id(id);\n     match kind {\n         TyKind::Infer | TyKind::ImplicitSelf | TyKind::Err | TyKind::Never | TyKind::CVarArgs => {}\n@@ -497,6 +497,7 @@ pub fn noop_visit_ty<T: MutVisitor>(ty: &mut P<Ty>, vis: &mut T) {\n         TyKind::MacCall(mac) => vis.visit_mac(mac),\n     }\n     vis.visit_span(span);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis: &mut T) {\n@@ -523,13 +524,14 @@ pub fn noop_visit_ident<T: MutVisitor>(Ident { name: _, span }: &mut Ident, vis:\n     vis.visit_span(span);\n }\n \n-pub fn noop_visit_path<T: MutVisitor>(Path { segments, span, tokens: _ }: &mut Path, vis: &mut T) {\n+pub fn noop_visit_path<T: MutVisitor>(Path { segments, span, tokens }: &mut Path, vis: &mut T) {\n     vis.visit_span(span);\n     for PathSegment { ident, id, args } in segments {\n         vis.visit_ident(ident);\n         vis.visit_id(id);\n         visit_opt(args, |args| vis.visit_generic_args(args));\n     }\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_qself<T: MutVisitor>(qself: &mut Option<QSelf>, vis: &mut T) {\n@@ -587,15 +589,17 @@ pub fn noop_visit_local<T: MutVisitor>(local: &mut P<Local>, vis: &mut T) {\n }\n \n pub fn noop_visit_attribute<T: MutVisitor>(attr: &mut Attribute, vis: &mut T) {\n-    let Attribute { kind, id: _, style: _, span, tokens: _ } = attr;\n+    let Attribute { kind, id: _, style: _, span, tokens } = attr;\n     match kind {\n-        AttrKind::Normal(AttrItem { path, args, tokens: _ }) => {\n+        AttrKind::Normal(AttrItem { path, args, tokens }) => {\n             vis.visit_path(path);\n             visit_mac_args(args, vis);\n+            visit_lazy_tts(tokens, vis);\n         }\n         AttrKind::DocComment(..) => {}\n     }\n     vis.visit_span(span);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_mac<T: MutVisitor>(mac: &mut MacCall, vis: &mut T) {\n@@ -658,6 +662,16 @@ pub fn visit_tts<T: MutVisitor>(TokenStream(tts): &mut TokenStream, vis: &mut T)\n     }\n }\n \n+pub fn visit_lazy_tts<T: MutVisitor>(lazy_tts: &mut Option<LazyTokenStream>, vis: &mut T) {\n+    if vis.token_visiting_enabled() {\n+        visit_opt(lazy_tts, |lazy_tts| {\n+            let mut tts = lazy_tts.create_token_stream();\n+            visit_tts(&mut tts, vis);\n+            *lazy_tts = LazyTokenStream::new(tts);\n+        })\n+    }\n+}\n+\n // No `noop_` prefix because there isn't a corresponding method in `MutVisitor`.\n // Applies ident visitor if it's an ident; applies other visits to interpolated nodes.\n // In practice the ident part is not actually used by specific visitors right now,\n@@ -725,9 +739,10 @@ pub fn visit_interpolated<T: MutVisitor>(nt: &mut token::Nonterminal, vis: &mut\n         token::NtLifetime(ident) => vis.visit_ident(ident),\n         token::NtLiteral(expr) => vis.visit_expr(expr),\n         token::NtMeta(item) => {\n-            let AttrItem { path, args, tokens: _ } = item.deref_mut();\n+            let AttrItem { path, args, tokens } = item.deref_mut();\n             vis.visit_path(path);\n             visit_mac_args(args, vis);\n+            visit_lazy_tts(tokens, vis);\n         }\n         token::NtPath(path) => vis.visit_path(path),\n         token::NtTT(tt) => visit_tt(tt, vis),\n@@ -887,10 +902,11 @@ pub fn noop_visit_mt<T: MutVisitor>(MutTy { ty, mutbl: _ }: &mut MutTy, vis: &mu\n }\n \n pub fn noop_visit_block<T: MutVisitor>(block: &mut P<Block>, vis: &mut T) {\n-    let Block { id, stmts, rules: _, span, tokens: _ } = block.deref_mut();\n+    let Block { id, stmts, rules: _, span, tokens } = block.deref_mut();\n     vis.visit_id(id);\n     stmts.flat_map_in_place(|stmt| vis.flat_map_stmt(stmt));\n     vis.visit_span(span);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_item_kind<T: MutVisitor>(kind: &mut ItemKind, vis: &mut T) {\n@@ -955,7 +971,7 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n     mut item: P<AssocItem>,\n     visitor: &mut T,\n ) -> SmallVec<[P<AssocItem>; 1]> {\n-    let Item { id, ident, vis, attrs, kind, span, tokens: _ } = item.deref_mut();\n+    let Item { id, ident, vis, attrs, kind, span, tokens } = item.deref_mut();\n     visitor.visit_id(id);\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n@@ -978,6 +994,7 @@ pub fn noop_flat_map_assoc_item<T: MutVisitor>(\n         AssocItemKind::MacCall(mac) => visitor.visit_mac(mac),\n     }\n     visitor.visit_span(span);\n+    visit_lazy_tts(tokens, visitor);\n     smallvec![item]\n }\n \n@@ -1028,16 +1045,14 @@ pub fn noop_flat_map_item<T: MutVisitor>(\n     mut item: P<Item>,\n     visitor: &mut T,\n ) -> SmallVec<[P<Item>; 1]> {\n-    let Item { ident, attrs, id, kind, vis, span, tokens: _ } = item.deref_mut();\n+    let Item { ident, attrs, id, kind, vis, span, tokens } = item.deref_mut();\n     visitor.visit_ident(ident);\n     visit_attrs(attrs, visitor);\n     visitor.visit_id(id);\n     visitor.visit_item_kind(kind);\n     visitor.visit_vis(vis);\n     visitor.visit_span(span);\n-\n-    // FIXME: if `tokens` is modified with a call to `vis.visit_tts` it causes\n-    //        an ICE during resolve... odd!\n+    visit_lazy_tts(tokens, visitor);\n \n     smallvec![item]\n }\n@@ -1046,7 +1061,7 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(\n     mut item: P<ForeignItem>,\n     visitor: &mut T,\n ) -> SmallVec<[P<ForeignItem>; 1]> {\n-    let Item { ident, attrs, id, kind, vis, span, tokens: _ } = item.deref_mut();\n+    let Item { ident, attrs, id, kind, vis, span, tokens } = item.deref_mut();\n     visitor.visit_id(id);\n     visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n@@ -1069,11 +1084,12 @@ pub fn noop_flat_map_foreign_item<T: MutVisitor>(\n         ForeignItemKind::MacCall(mac) => visitor.visit_mac(mac),\n     }\n     visitor.visit_span(span);\n+    visit_lazy_tts(tokens, visitor);\n     smallvec![item]\n }\n \n pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n-    let Pat { id, kind, span, tokens: _ } = pat.deref_mut();\n+    let Pat { id, kind, span, tokens } = pat.deref_mut();\n     vis.visit_id(id);\n     match kind {\n         PatKind::Wild | PatKind::Rest => {}\n@@ -1108,6 +1124,7 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         PatKind::MacCall(mac) => vis.visit_mac(mac),\n     }\n     vis.visit_span(span);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonConst, vis: &mut T) {\n@@ -1116,7 +1133,7 @@ pub fn noop_visit_anon_const<T: MutVisitor>(AnonConst { id, value }: &mut AnonCo\n }\n \n pub fn noop_visit_expr<T: MutVisitor>(\n-    Expr { kind, id, span, attrs, tokens: _ }: &mut Expr,\n+    Expr { kind, id, span, attrs, tokens }: &mut Expr,\n     vis: &mut T,\n ) {\n     match kind {\n@@ -1295,6 +1312,7 @@ pub fn noop_visit_expr<T: MutVisitor>(\n     vis.visit_id(id);\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n+    visit_lazy_tts(tokens, vis);\n }\n \n pub fn noop_filter_map_expr<T: MutVisitor>(mut e: P<Expr>, vis: &mut T) -> Option<P<Expr>> {\n@@ -1305,11 +1323,12 @@ pub fn noop_filter_map_expr<T: MutVisitor>(mut e: P<Expr>, vis: &mut T) -> Optio\n }\n \n pub fn noop_flat_map_stmt<T: MutVisitor>(\n-    Stmt { kind, mut span, mut id, tokens }: Stmt,\n+    Stmt { kind, mut span, mut id, mut tokens }: Stmt,\n     vis: &mut T,\n ) -> SmallVec<[Stmt; 1]> {\n     vis.visit_id(&mut id);\n     vis.visit_span(&mut span);\n+    visit_lazy_tts(&mut tokens, vis);\n     noop_flat_map_stmt_kind(kind, vis)\n         .into_iter()\n         .map(|kind| Stmt { id, kind, span, tokens: tokens.clone() })"}, {"sha": "0994532b836458a569c81df2759e566e598b8299", "filename": "src/test/ui/proc-macro/nonterminal-token-hygiene.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1e156065471051b33ff47ec06c168e341c385c3c/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1e156065471051b33ff47ec06c168e341c385c3c/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fnonterminal-token-hygiene.rs?ref=1e156065471051b33ff47ec06c168e341c385c3c", "patch": "@@ -0,0 +1,27 @@\n+// Make sure that marks from declarative macros are applied to tokens in nonterminal.\n+\n+// check-pass\n+// aux-build:test-macros.rs\n+\n+#![feature(decl_macro)]\n+\n+#[macro_use]\n+extern crate test_macros;\n+\n+macro_rules! outer {\n+    ($item:item) => {\n+        macro inner() {\n+            recollect! { $item }\n+        }\n+\n+        inner!();\n+    };\n+}\n+\n+struct S;\n+\n+outer! {\n+    struct S; // OK, not a duplicate definition of `S`\n+}\n+\n+fn main() {}"}]}