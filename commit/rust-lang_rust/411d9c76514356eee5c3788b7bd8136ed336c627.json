{"sha": "411d9c76514356eee5c3788b7bd8136ed336c627", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxMWQ5Yzc2NTE0MzU2ZWVlNWMzNzg4YjdiZDgxMzZlZDMzNmM2Mjc=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2018-03-29T05:19:00Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-03-29T05:19:00Z"}, "message": "Merge pull request #2585 from bjgill/use-check-manifest-handling\n\nUse cargo check's manifest handling", "tree": {"sha": "e29e4772ee714a62cb6f77c8c1a2e363faf1bf49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e29e4772ee714a62cb6f77c8c1a2e363faf1bf49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/411d9c76514356eee5c3788b7bd8136ed336c627", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJavHdECRBK7hj4Ov3rIwAAdHIIAAXiFvnPE9R8DZh+qUBpktPE\npgH5yvzD6b542bv6m692cRjCnEvSWDhyU2EuQaloNfjKxkSeLx7X7yPAflW60WA6\n+QvrGzj4VxlHq5wR6v3lVP/9tPtKVr+3nohOv5iOzdtDGjl0zmPH/TcVnJJc+69m\nsC5iGwlyiTDbVIcdDy65RlNlR5f4kzoQmtWJ7TOvVVS9H61VcQozVa+nd+U0HUs8\nCrG7qksQHUCoFbcstEAk6Cgp4E/HjPE8gfQ/lyBddTg+2aPYAjCzLh5GGbTwTxjS\ntolM9l4HYba4tGGdpHpr6JbTlYg88DweyKS4YsI3Tkm+MdgwnKWTSdcxFUeWSNg=\n=+OBL\n-----END PGP SIGNATURE-----\n", "payload": "tree e29e4772ee714a62cb6f77c8c1a2e363faf1bf49\nparent e34a8553b00ebc3fed70dd2347ad0675b7eb0d56\nparent 8db845c189ebce88f4f29d426fb6cb6ae8478b64\nauthor Oliver Schneider <oli-obk@users.noreply.github.com> 1522300740 +0200\ncommitter GitHub <noreply@github.com> 1522300740 +0200\n\nMerge pull request #2585 from bjgill/use-check-manifest-handling\n\nUse cargo check's manifest handling"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/411d9c76514356eee5c3788b7bd8136ed336c627", "html_url": "https://github.com/rust-lang/rust/commit/411d9c76514356eee5c3788b7bd8136ed336c627", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/411d9c76514356eee5c3788b7bd8136ed336c627/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e34a8553b00ebc3fed70dd2347ad0675b7eb0d56", "url": "https://api.github.com/repos/rust-lang/rust/commits/e34a8553b00ebc3fed70dd2347ad0675b7eb0d56", "html_url": "https://github.com/rust-lang/rust/commit/e34a8553b00ebc3fed70dd2347ad0675b7eb0d56"}, {"sha": "8db845c189ebce88f4f29d426fb6cb6ae8478b64", "url": "https://api.github.com/repos/rust-lang/rust/commits/8db845c189ebce88f4f29d426fb6cb6ae8478b64", "html_url": "https://github.com/rust-lang/rust/commit/8db845c189ebce88f4f29d426fb6cb6ae8478b64"}], "stats": {"total": 129, "additions": 4, "deletions": 125}, "files": [{"sha": "a28e5c50929c2d828c41e63f7f47d00ddbfaea69", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/411d9c76514356eee5c3788b7bd8136ed336c627/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/411d9c76514356eee5c3788b7bd8136ed336c627/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=411d9c76514356eee5c3788b7bd8136ed336c627", "patch": "@@ -39,11 +39,11 @@ path = \"src/driver.rs\"\n # begin automatic update\n clippy_lints = { version = \"0.0.190\", path = \"clippy_lints\" }\n # end automatic update\n-cargo_metadata = \"0.5\"\n regex = \"0.2\"\n semver = \"0.9\"\n \n [dev-dependencies]\n+cargo_metadata = \"0.5\"\n compiletest_rs = \"0.3.7\"\n lazy_static = \"1.0\"\n serde_derive = \"1.0\""}, {"sha": "5bdbaf1bc80e3818814bc5301665129bd44f33e2", "filename": "src/main.rs", "status": "modified", "additions": 3, "deletions": 124, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/411d9c76514356eee5c3788b7bd8136ed336c627/src%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/411d9c76514356eee5c3788b7bd8136ed336c627/src%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmain.rs?ref=411d9c76514356eee5c3788b7bd8136ed336c627", "patch": "@@ -3,26 +3,16 @@\n #![feature(rustc_private)]\n #![allow(unknown_lints, missing_docs_in_private_items)]\n \n-use std::collections::HashMap;\n-use std::process;\n-use std::io::{self, Write};\n-\n-extern crate cargo_metadata;\n-\n-use std::path::{Path, PathBuf};\n-\n const CARGO_CLIPPY_HELP: &str = r#\"Checks a package to catch common mistakes and improve your Rust code.\n \n Usage:\n     cargo clippy [options] [--] [<opts>...]\n \n Common options:\n     -h, --help               Print this message\n-    --features               Features to compile for the package\n     -V, --version            Print version info and exit\n-    --all                    Run over all packages in the current workspace\n \n-Other options are the same as `cargo rustc`.\n+Other options are the same as `cargo check`.\n \n To allow or deny a lint from the command line you can use `cargo clippy --`\n with:\n@@ -59,119 +49,8 @@ pub fn main() {\n         return;\n     }\n \n-    let mut manifest_path_arg = std::env::args()\n-        .skip(2)\n-        .skip_while(|val| !val.starts_with(\"--manifest-path\"));\n-    let manifest_path_arg = manifest_path_arg.next().and_then(|val| {\n-        if val == \"--manifest-path\" {\n-            manifest_path_arg.next()\n-        } else if val.starts_with(\"--manifest-path=\") {\n-            Some(val[\"--manifest-path=\".len()..].to_owned())\n-        } else {\n-            None\n-        }\n-    });\n-\n-    let mut metadata = if let Ok(metadata) = cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref)) {\n-        metadata\n-    } else {\n-        println!(\n-            \"{:?}\",\n-            cargo_metadata::metadata(manifest_path_arg.as_ref().map(AsRef::as_ref))\n-        );\n-        let _ = io::stderr().write_fmt(format_args!(\"error: Could not obtain cargo metadata.\\n\"));\n-        process::exit(101);\n-    };\n-\n-    let manifest_path = manifest_path_arg.map(|arg| {\n-        PathBuf::from(arg)\n-            .canonicalize()\n-            .expect(\"manifest path could not be canonicalized\")\n-    });\n-\n-    let packages = if std::env::args().any(|a| a == \"--all\") {\n-        metadata.packages\n-    } else {\n-        let package_index = {\n-            if let Some(manifest_path) = manifest_path {\n-                metadata.packages.iter().position(|package| {\n-                    let package_manifest_path = Path::new(&package.manifest_path)\n-                        .canonicalize()\n-                        .expect(\"package manifest path could not be canonicalized\");\n-                    package_manifest_path == manifest_path\n-                })\n-            } else {\n-                let package_manifest_paths: HashMap<_, _> = metadata\n-                    .packages\n-                    .iter()\n-                    .enumerate()\n-                    .map(|(i, package)| {\n-                        let package_manifest_path = Path::new(&package.manifest_path)\n-                            .parent()\n-                            .expect(\"could not find parent directory of package manifest\")\n-                            .canonicalize()\n-                            .expect(\"package directory cannot be canonicalized\");\n-                        (package_manifest_path, i)\n-                    })\n-                    .collect();\n-\n-                let current_dir = std::env::current_dir()\n-                    .expect(\"CARGO_MANIFEST_DIR not set\")\n-                    .canonicalize()\n-                    .expect(\"manifest directory cannot be canonicalized\");\n-\n-                let mut current_path: &Path = &current_dir;\n-\n-                // This gets the most-recent parent (the one that takes the fewest `cd ..`s to\n-                // reach).\n-                loop {\n-                    if let Some(&package_index) = package_manifest_paths.get(current_path) {\n-                        break Some(package_index);\n-                    } else {\n-                        // We'll never reach the filesystem root, because to get to this point in the\n-                        // code\n-                        // the call to `cargo_metadata::metadata` must have succeeded. So it's okay to\n-                        // unwrap the current path's parent.\n-                        current_path = current_path\n-                            .parent()\n-                            .unwrap_or_else(|| panic!(\"could not find parent of path {}\", current_path.display()));\n-                    }\n-                }\n-            }\n-        }.expect(\"could not find matching package\");\n-\n-        vec![metadata.packages.remove(package_index)]\n-    };\n-\n-    for package in packages {\n-        let manifest_path = package.manifest_path;\n-\n-        for target in package.targets {\n-            let args = std::env::args()\n-                .skip(2)\n-                .filter(|a| a != \"--all\" && !a.starts_with(\"--manifest-path=\"));\n-\n-            let args = std::iter::once(format!(\"--manifest-path={}\", manifest_path)).chain(args);\n-            if let Some(first) = target.kind.get(0) {\n-                if target.kind.len() > 1 || first.ends_with(\"lib\") {\n-                    println!(\"lib: {}\", target.name);\n-                    if let Err(code) = process(std::iter::once(\"--lib\".to_owned()).chain(args)) {\n-                        std::process::exit(code);\n-                    }\n-                } else if [\"bin\", \"example\", \"test\", \"bench\"].contains(&&**first) {\n-                    println!(\"{}: {}\", first, target.name);\n-                    if let Err(code) = process(\n-                        vec![format!(\"--{}\", first), target.name]\n-                            .into_iter()\n-                            .chain(args),\n-                    ) {\n-                        std::process::exit(code);\n-                    }\n-                }\n-            } else {\n-                panic!(\"badly formatted cargo metadata: target::kind is an empty array\");\n-            }\n-        }\n+    if let Err(code) = process(std::env::args().skip(2)) {\n+        std::process::exit(code);\n     }\n }\n "}]}