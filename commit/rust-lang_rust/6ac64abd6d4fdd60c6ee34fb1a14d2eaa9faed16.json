{"sha": "6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhYzY0YWJkNmQ0ZmRkNjBjNmVlMzRmYjFhMTRkMmVhYTlmYWVkMTY=", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2019-09-23T04:14:54Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2019-09-24T06:10:45Z"}, "message": "Just delete the overrides now that they match the default implementations", "tree": {"sha": "575366131d7497d1c796ef5e48d39c91a34b3f7a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/575366131d7497d1c796ef5e48d39c91a34b3f7a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16", "html_url": "https://github.com/rust-lang/rust/commit/6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92e91f7541af929010638355dc16daf27fd28b65", "url": "https://api.github.com/repos/rust-lang/rust/commits/92e91f7541af929010638355dc16daf27fd28b65", "html_url": "https://github.com/rust-lang/rust/commit/92e91f7541af929010638355dc16daf27fd28b65"}], "stats": {"total": 63, "additions": 1, "deletions": 62}, "files": [{"sha": "ccdab1dcf0dc90c363103ff1a2c5d29557d960f7", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 62, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=6ac64abd6d4fdd60c6ee34fb1a14d2eaa9faed16", "patch": "@@ -28,7 +28,7 @@ use crate::fmt;\n use crate::intrinsics::{assume, exact_div, unchecked_sub, is_aligned_and_not_null};\n use crate::isize;\n use crate::iter::*;\n-use crate::ops::{FnMut, Try, self};\n+use crate::ops::{FnMut, self};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n use crate::result::Result;\n@@ -3180,33 +3180,6 @@ macro_rules! iterator {\n                 self.next_back()\n             }\n \n-            #[inline]\n-            fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-            {\n-                // This method historically was unrolled, for as of 2019-09 LLVM\n-                // is not capable of unrolling or vectorizing multiple-exit loops.\n-                // However, doing it always proved to often be a pessimization,\n-                // especially when called with large closures, so it was removed.\n-\n-                let mut accum = init;\n-                while let Some(x) = self.next() {\n-                    accum = f(accum, x)?;\n-                }\n-                Try::from_ok(accum)\n-            }\n-\n-            #[inline]\n-            fn fold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n-                where Fold: FnMut(Acc, Self::Item) -> Acc,\n-            {\n-                let mut accum = init;\n-                while let Some(x) = self.next() {\n-                    accum = f(accum, x);\n-                }\n-                accum\n-            }\n-\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             fn position<P>(&mut self, mut predicate: P) -> Option<usize> where\n@@ -3277,40 +3250,6 @@ macro_rules! iterator {\n                     Some(next_back_unchecked!(self))\n                 }\n             }\n-\n-            #[inline]\n-            fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R where\n-                Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n-            {\n-                // manual unrolling is needed when there are conditional exits from the loop\n-                let mut accum = init;\n-                unsafe {\n-                    while len!(self) >= 4 {\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                    }\n-                    // inlining is_empty everywhere makes a huge performance difference\n-                    while !is_empty!(self) {\n-                        accum = f(accum, next_back_unchecked!(self))?;\n-                    }\n-                }\n-                Try::from_ok(accum)\n-            }\n-\n-            #[inline]\n-            fn rfold<Acc, Fold>(mut self, init: Acc, mut f: Fold) -> Acc\n-                where Fold: FnMut(Acc, Self::Item) -> Acc,\n-            {\n-                // Let LLVM unroll this, rather than using the default\n-                // impl that would force the manual unrolling above\n-                let mut accum = init;\n-                while let Some(x) = self.next_back() {\n-                    accum = f(accum, x);\n-                }\n-                accum\n-            }\n         }\n \n         #[stable(feature = \"fused\", since = \"1.26.0\")]"}]}