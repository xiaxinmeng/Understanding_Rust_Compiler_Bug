{"sha": "d69ada6bf3b6085bdcf23a7503398424027ee2e0", "node_id": "C_kwDOAAsO6NoAKGQ2OWFkYTZiZjNiNjA4NWJkY2YyM2E3NTAzMzk4NDI0MDI3ZWUyZTA", "commit": {"author": {"name": "antoyo", "email": "antoyo@users.noreply.github.com", "date": "2022-04-06T14:14:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-06T14:14:19Z"}, "message": "Merge pull request #156 from yvt/fix-int-ops\n\nImplement `saturating_{add, sub}` for non-native integer types", "tree": {"sha": "31d014d624440d55003554f38029b519c2af74ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31d014d624440d55003554f38029b519c2af74ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d69ada6bf3b6085bdcf23a7503398424027ee2e0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiTaA7CRBK7hj4Ov3rIwAAANcIAB/R90VAZT0Q8jWxx2jplMgU\nKaQWBL2tv6Bb5zvZVtXwVgRr8seQedyMTv6Hu9f8mJqJcmFyUqLHY05Aj85kXvTT\nkDUQWQhJQTzU2iKlgu30V+vs8evDzhM//3mWYOPQvKQV4C3pd4nMZyIFEbeyh3dS\n1UDu6WYnyklLc/z7k6b8fLcoA7F//rVKmBYxBC/3TWnwQtc7R+T5niW+V3CXfrLQ\n+0bQN6oy9jSe0tq+4IOo2x9x9XvEvk68y3YlCM3x4HDAmA4/NiTAcZEu6Gb0hAix\nW6ReyDhkdQ7NMD5bb6pDl59k822izASB9DBJflseZL79PiTu1wIIpvcuzXd6ZfQ=\n=HkWY\n-----END PGP SIGNATURE-----\n", "payload": "tree 31d014d624440d55003554f38029b519c2af74ad\nparent 341b9f274bddcb912a6109c57ee236f3c9529649\nparent a7a09d556ab222f3b24d76defe1d2b2f99aa2c6f\nauthor antoyo <antoyo@users.noreply.github.com> 1649254459 -0400\ncommitter GitHub <noreply@github.com> 1649254459 -0400\n\nMerge pull request #156 from yvt/fix-int-ops\n\nImplement `saturating_{add, sub}` for non-native integer types"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d69ada6bf3b6085bdcf23a7503398424027ee2e0", "html_url": "https://github.com/rust-lang/rust/commit/d69ada6bf3b6085bdcf23a7503398424027ee2e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d69ada6bf3b6085bdcf23a7503398424027ee2e0/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "341b9f274bddcb912a6109c57ee236f3c9529649", "url": "https://api.github.com/repos/rust-lang/rust/commits/341b9f274bddcb912a6109c57ee236f3c9529649", "html_url": "https://github.com/rust-lang/rust/commit/341b9f274bddcb912a6109c57ee236f3c9529649"}, {"sha": "a7a09d556ab222f3b24d76defe1d2b2f99aa2c6f", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7a09d556ab222f3b24d76defe1d2b2f99aa2c6f", "html_url": "https://github.com/rust-lang/rust/commit/a7a09d556ab222f3b24d76defe1d2b2f99aa2c6f"}], "stats": {"total": 541, "additions": 374, "deletions": 167}, "files": [{"sha": "d885bc8bf1fe8b4fba0f5fc3e280653610554413", "filename": "src/intrinsic/mod.rs", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d69ada6bf3b6085bdcf23a7503398424027ee2e0/src%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ada6bf3b6085bdcf23a7503398424027ee2e0/src%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsic%2Fmod.rs?ref=d69ada6bf3b6085bdcf23a7503398424027ee2e0", "patch": "@@ -967,34 +967,55 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn saturating_add(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>, signed: bool, width: u64) -> RValue<'gcc> {\n-        let func = self.current_func.borrow().expect(\"func\");\n-\n+        let result_type = lhs.get_type();\n         if signed {\n-            // Algorithm from: https://stackoverflow.com/a/56531252/389119\n-            let after_block = func.new_block(\"after\");\n-            let func_name =\n-                match width {\n-                    8 => \"__builtin_add_overflow\",\n-                    16 => \"__builtin_add_overflow\",\n-                    32 => \"__builtin_sadd_overflow\",\n-                    64 => \"__builtin_saddll_overflow\",\n-                    128 => \"__builtin_add_overflow\",\n-                    _ => unreachable!(),\n-                };\n-            let overflow_func = self.context.get_builtin_function(func_name);\n-            let result_type = lhs.get_type();\n+            // Based on algorithm from: https://stackoverflow.com/a/56531252/389119\n+            let func = self.current_func.borrow().expect(\"func\");\n             let res = func.new_local(None, result_type, \"saturating_sum\");\n-            let overflow = self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None);\n+            let supports_native_type = self.is_native_int_type(result_type);\n+            let overflow =\n+                if supports_native_type {\n+                    let func_name =\n+                        match width {\n+                            8 => \"__builtin_add_overflow\",\n+                            16 => \"__builtin_add_overflow\",\n+                            32 => \"__builtin_sadd_overflow\",\n+                            64 => \"__builtin_saddll_overflow\",\n+                            128 => \"__builtin_add_overflow\",\n+                            _ => unreachable!(),\n+                        };\n+                    let overflow_func = self.context.get_builtin_function(func_name);\n+                    self.overflow_call(overflow_func, &[lhs, rhs, res.get_address(None)], None)\n+                }\n+                else {\n+                    let func_name =\n+                        match width {\n+                            128 => \"__rust_i128_addo\",\n+                            _ => unreachable!(),\n+                        };\n+                    let param_a = self.context.new_parameter(None, result_type, \"a\");\n+                    let param_b = self.context.new_parameter(None, result_type, \"b\");\n+                    let result_field = self.context.new_field(None, result_type, \"result\");\n+                    let overflow_field = self.context.new_field(None, self.bool_type, \"overflow\");\n+                    let return_type = self.context.new_struct_type(None, \"result_overflow\", &[result_field, overflow_field]);\n+                    let func = self.context.new_function(None, FunctionType::Extern, return_type.as_type(), &[param_a, param_b], func_name, false);\n+                    let result = self.context.new_call(None, func, &[lhs, rhs]);\n+                    let overflow = result.access_field(None, overflow_field);\n+                    let int_result = result.access_field(None, result_field);\n+                    self.llbb().add_assignment(None, res, int_result);\n+                    overflow\n+                };\n \n             let then_block = func.new_block(\"then\");\n+            let after_block = func.new_block(\"after\");\n \n-            let unsigned_type = self.context.new_int_type(width as i32 / 8, false);\n-            let shifted = self.context.new_cast(None, lhs, unsigned_type) >> self.context.new_rvalue_from_int(unsigned_type, width as i32 - 1);\n-            let uint_max = self.context.new_unary_op(None, UnaryOp::BitwiseNegate, unsigned_type,\n-                self.context.new_rvalue_from_int(unsigned_type, 0)\n-            );\n-            let int_max = uint_max >> self.context.new_rvalue_one(unsigned_type);\n-            then_block.add_assignment(None, res, self.context.new_cast(None, shifted + int_max, result_type));\n+            // Return `result_type`'s maximum or minimum value on overflow\n+            // NOTE: convert the type to unsigned to have an unsigned shift.\n+            let unsigned_type = result_type.to_unsigned(&self.cx);\n+            let shifted = self.gcc_lshr(self.gcc_int_cast(lhs, unsigned_type), self.gcc_int(unsigned_type, width as i64 - 1));\n+            let uint_max = self.gcc_not(self.gcc_int(unsigned_type, 0));\n+            let int_max = self.gcc_lshr(uint_max, self.gcc_int(unsigned_type, 1));\n+            then_block.add_assignment(None, res, self.gcc_int_cast(self.gcc_add(shifted, int_max), result_type));\n             then_block.end_with_jump(None, after_block);\n \n             self.llbb().end_with_conditional(None, overflow, then_block, after_block);\n@@ -1007,19 +1028,18 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         }\n         else {\n             // Algorithm from: http://locklessinc.com/articles/sat_arithmetic/\n-            let res = lhs + rhs;\n-            let res_type = res.get_type();\n-            let cond = self.context.new_comparison(None, ComparisonOp::LessThan, res, lhs);\n-            let value = self.context.new_unary_op(None, UnaryOp::Minus, res_type, self.context.new_cast(None, cond, res_type));\n-            res | value\n+            let res = self.gcc_add(lhs, rhs);\n+            let cond = self.gcc_icmp(IntPredicate::IntULT, res, lhs);\n+            let value = self.gcc_neg(self.gcc_int_cast(cond, result_type));\n+            self.gcc_or(res, value)\n         }\n     }\n \n     // Algorithm from: https://locklessinc.com/articles/sat_arithmetic/\n     fn saturating_sub(&mut self, lhs: RValue<'gcc>, rhs: RValue<'gcc>, signed: bool, width: u64) -> RValue<'gcc> {\n+        let result_type = lhs.get_type();\n         if signed {\n-            // Also based on algorithm from: https://stackoverflow.com/a/56531252/389119\n-            let result_type = lhs.get_type();\n+            // Based on algorithm from: https://stackoverflow.com/a/56531252/389119\n             let func = self.current_func.borrow().expect(\"func\");\n             let res = func.new_local(None, result_type, \"saturating_diff\");\n             let supports_native_type = self.is_native_int_type(result_type);\n@@ -1059,6 +1079,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             let then_block = func.new_block(\"then\");\n             let after_block = func.new_block(\"after\");\n \n+            // Return `result_type`'s maximum or minimum value on overflow\n             // NOTE: convert the type to unsigned to have an unsigned shift.\n             let unsigned_type = result_type.to_unsigned(&self.cx);\n             let shifted = self.gcc_lshr(self.gcc_int_cast(lhs, unsigned_type), self.gcc_int(unsigned_type, width as i64 - 1));\n@@ -1076,11 +1097,10 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             res.to_rvalue()\n         }\n         else {\n-            let res = lhs - rhs;\n-            let comparison = self.context.new_comparison(None, ComparisonOp::LessThanEquals, res, lhs);\n-            let comparison = self.context.new_cast(None, comparison, lhs.get_type());\n-            let unary_op = self.context.new_unary_op(None, UnaryOp::Minus, comparison.get_type(), comparison);\n-            self.and(res, unary_op)\n+            let res = self.gcc_sub(lhs, rhs);\n+            let comparison = self.gcc_icmp(IntPredicate::IntULE, res, lhs);\n+            let value = self.gcc_neg(self.gcc_int_cast(comparison, result_type));\n+            self.gcc_and(res, value)\n         }\n     }\n }"}, {"sha": "2b90e4ae8d82b9079b571be7d305d8d6f3f9967c", "filename": "tests/run/int.rs", "status": "modified", "additions": 319, "deletions": 132, "changes": 451, "blob_url": "https://github.com/rust-lang/rust/blob/d69ada6bf3b6085bdcf23a7503398424027ee2e0/tests%2Frun%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d69ada6bf3b6085bdcf23a7503398424027ee2e0/tests%2Frun%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun%2Fint.rs?ref=d69ada6bf3b6085bdcf23a7503398424027ee2e0", "patch": "@@ -3,151 +3,338 @@\n // Run-time:\n //   status: 0\n \n-#![feature(arbitrary_self_types, auto_traits, core_intrinsics, lang_items, start, intrinsics)]\n+#![feature(bench_black_box, const_black_box, core_intrinsics, start)]\n \n #![no_std]\n \n-mod intrinsics {\n-    extern \"rust-intrinsic\" {\n-        pub fn abort() -> !;\n-    }\n+#[panic_handler]\n+fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n+    core::intrinsics::abort();\n }\n \n /*\n- * Core\n+ * Code\n  */\n \n-mod libc {\n-    #[link(name = \"c\")]\n-    extern \"C\" {\n-        pub fn puts(s: *const u8) -> i32;\n+#[start]\n+fn main(_argc: isize, _argv: *const *const u8) -> isize {\n+    use core::hint::black_box;\n+\n+    macro_rules! check {\n+        ($ty:ty, $expr:expr) => {\n+            {\n+                const EXPECTED: $ty = $expr;\n+                assert_eq!($expr, EXPECTED);\n+            }\n+        };\n     }\n-}\n \n-#[panic_handler]\n-fn panic_handler(_: &core::panic::PanicInfo) -> ! {\n-    unsafe {\n-        core::intrinsics::abort();\n+    check!(u32, (2220326408_u32 + black_box(1)) >> (32 - 6));\n+\n+    /// Generate `check!` tests for integer types at least as wide as 128 bits.\n+    macro_rules! check_ops128 {\n+        () => {\n+            check_ops64!();\n+\n+            // Shifts.\n+            check!(T, VAL1 << black_box(64));\n+            check!(T, VAL1 << black_box(81));\n+            check!(T, VAL3 << black_box(63));\n+            check!(T, VAL3 << black_box(64));\n+\n+            check!(T, VAL1 >> black_box(64));\n+            check!(T, VAL2 >> black_box(64));\n+            check!(T, VAL3 >> black_box(64));\n+            check!(T, VAL3 >> black_box(81));\n+        };\n     }\n-}\n \n-/*\n- * Code\n- */\n+    /// Generate `check!` tests for integer types at least as wide as 64 bits.\n+    macro_rules! check_ops64 {\n+        () => {\n+            check_ops32!();\n+\n+            // Shifts.\n+            check!(T, VAL2 << black_box(33));\n+            check!(T, VAL2 << black_box(49));\n+            check!(T, VAL2 << black_box(61));\n+            check!(T, VAL2 << black_box(63));\n+\n+            check!(T, VAL3 << black_box(33));\n+            check!(T, VAL3 << black_box(49));\n+            check!(T, VAL3 << black_box(61));\n+\n+            check!(T, VAL1 >> black_box(33));\n+            check!(T, VAL1 >> black_box(49));\n+            check!(T, VAL1 >> black_box(61));\n+            check!(T, VAL1 >> black_box(63));\n+\n+            check!(T, VAL2 >> black_box(33));\n+            check!(T, VAL2 >> black_box(49));\n+            check!(T, VAL2 >> black_box(61));\n+            check!(T, VAL2 >> black_box(63));\n+\n+            check!(T, VAL3 >> black_box(33));\n+            check!(T, VAL3 >> black_box(49));\n+            check!(T, VAL3 >> black_box(61));\n+            check!(T, VAL3 >> black_box(63));\n+        };\n+    }\n \n-#[start]\n-fn main(argc: isize, _argv: *const *const u8) -> isize {\n-    let var = 134217856_u128;\n-    let var2 = 10475372733397991552_u128;\n-    let var3 = 193236519889708027473620326106273939584_u128;\n-    let var4 = 123236519889708027473620326106273939584_u128;\n-    let var5 = 153236519889708027473620326106273939584_u128;\n-    let var6 = 18446744073709551616_i128;\n-    let var7 = 170141183460469231731687303715884105728_u128;\n-\n-    // Shifts.\n-    assert_eq!(var << (argc as u128 - 1), var);\n-    assert_eq!(var << argc as u128, 268435712);\n-    assert_eq!(var << (argc + 32) as u128, 1152922604118474752);\n-    assert_eq!(var << (argc + 48) as u128, 75557935783508361347072);\n-    assert_eq!(var << (argc + 60) as u128, 309485304969250248077606912);\n-    assert_eq!(var << (argc + 62) as u128, 1237941219877000992310427648);\n-    assert_eq!(var << (argc + 63) as u128, 2475882439754001984620855296);\n-    assert_eq!(var << (argc + 80) as u128, 324518863143436548128224745357312);\n-\n-    assert_eq!(var2 << argc as u128, 20950745466795983104);\n-    assert_eq!(var2 << (argc as u128 - 1), var2);\n-    assert_eq!(var2 << (argc + 32) as u128, 89982766606709001335848566784);\n-    assert_eq!(var2 << (argc + 48) as u128, 5897110592337281111546171672756224);\n-    assert_eq!(var2 << (argc + 60) as u128, 24154564986213503432893119171609493504);\n-    assert_eq!(var2 << (argc + 62) as u128, 96618259944854013731572476686437974016);\n-    assert_eq!(var2 << (argc + 63) as u128, 193236519889708027463144953372875948032);\n-\n-    assert_eq!(var3 << argc as u128, 46190672858477591483866044780779667712);\n-    assert_eq!(var3 << (argc as u128 - 1), var3);\n-    assert_eq!(var3 << (argc + 32) as u128, 21267668304951024224840338247585366016);\n-    assert_eq!(var3 << (argc + 48) as u128, 1335125106377253154015353231953100800);\n-    assert_eq!(var3 << (argc + 60) as u128, 24154564986213503432893119171609493504);\n-    assert_eq!(var3 << (argc + 62) as u128, 96618259944854013731572476686437974016);\n-    assert_eq!(var3 << (argc + 63) as u128, 193236519889708027463144953372875948032);\n-\n-    assert_eq!((2220326408_u32 + argc as u32) >> (32 - 6), 33);\n-\n-    assert_eq!(var >> (argc as u128 - 1), var);\n-    assert_eq!(var >> argc as u128, 67108928);\n-    assert_eq!(var >> (argc + 32) as u128, 0);\n-    assert_eq!(var >> (argc + 48) as u128, 0);\n-    assert_eq!(var >> (argc + 60) as u128, 0);\n-    assert_eq!(var >> (argc + 62) as u128, 0);\n-    assert_eq!(var >> (argc + 63) as u128, 0);\n-\n-    assert_eq!(var2 >> argc as u128, 5237686366698995776);\n-    assert_eq!(var2 >> (argc as u128 - 1), var2);\n-    assert_eq!(var2 >> (argc + 32) as u128, 1219493888);\n-    assert_eq!(var2 >> (argc + 48) as u128, 18608);\n-    assert_eq!(var2 >> (argc + 60) as u128, 4);\n-    assert_eq!(var2 >> (argc + 62) as u128, 1);\n-    assert_eq!(var2 >> (argc + 63) as u128, 0);\n-\n-    assert_eq!(var3 >> (argc as u128 - 1), var3);\n-    assert_eq!(var3 >> argc as u128, 96618259944854013736810163053136969792);\n-    assert_eq!(var3 >> (argc + 32) as u128, 22495691651677250335181635584);\n-    assert_eq!(var3 >> (argc + 48) as u128, 343257013727985387194544);\n-    assert_eq!(var3 >> (argc + 60) as u128, 83802981867183932420);\n-    assert_eq!(var3 >> (argc + 62) as u128, 20950745466795983105);\n-    assert_eq!(var3 >> (argc + 63) as u128, 10475372733397991552);\n-    assert_eq!(var3 >> (argc + 80) as u128, 79920751444992);\n-\n-    assert_eq!(var6 >> argc as u128, 9223372036854775808);\n-    assert_eq!((var6 - 1) >> argc as u128, 9223372036854775807);\n-    assert_eq!(var7 >> argc as u128, 85070591730234615865843651857942052864);\n-\n-    // Casts\n-    assert_eq!((var >> (argc + 32) as u128) as u64, 0);\n-    assert_eq!((var >> argc as u128) as u64, 67108928);\n-\n-    // Addition.\n-    assert_eq!(var + argc as u128, 134217857);\n-\n-    assert_eq!(var2 + argc as u128, 10475372733397991553);\n-    assert_eq!(var2 + (var2 + argc as u128) as u128, 20950745466795983105);\n-\n-    assert_eq!(var3 + argc as u128, 193236519889708027473620326106273939585);\n-\n-    // Subtraction\n-    assert_eq!(var - argc as u128, 134217855);\n-\n-    assert_eq!(var2 - argc as u128, 10475372733397991551);\n-\n-    assert_eq!(var3 - argc as u128, 193236519889708027473620326106273939583);\n-\n-    // Multiplication\n-    assert_eq!(var * (argc + 1) as u128, 268435712);\n-    assert_eq!(var * (argc as u128 + var2), 1405982069077538020949770368);\n-\n-    assert_eq!(var2 * (argc + 1) as u128, 20950745466795983104);\n-    assert_eq!(var2 * (argc as u128 + var2), 109733433903618109003204073240861360256);\n-\n-    assert_eq!(var3 * argc as u128, 193236519889708027473620326106273939584);\n-\n-    assert_eq!(var4 * (argc + 1) as u128, 246473039779416054947240652212547879168);\n-\n-    assert_eq!(var5 * (argc + 1) as u128, 306473039779416054947240652212547879168);\n-\n-    // Division.\n-    assert_eq!(var / (argc + 1) as u128, 67108928);\n-    assert_eq!(var / (argc + 2) as u128, 44739285);\n-\n-    assert_eq!(var2 / (argc + 1) as u128, 5237686366698995776);\n-    assert_eq!(var2 / (argc + 2) as u128, 3491790911132663850);\n-\n-    assert_eq!(var3 / (argc + 1) as u128, 96618259944854013736810163053136969792);\n-    assert_eq!(var3 / (argc + 2) as u128, 64412173296569342491206775368757979861);\n-    assert_eq!(var3 / (argc as u128 + var4), 1);\n-    assert_eq!(var3 / (argc as u128 + var2), 18446744073709551615);\n-\n-    assert_eq!(var4 / (argc + 1) as u128, 61618259944854013736810163053136969792);\n-    assert_eq!(var4 / (argc + 2) as u128, 41078839963236009157873442035424646528);\n+    /// Generate `check!` tests for integer types at least as wide as 32 bits.\n+    macro_rules! check_ops32 {\n+        () => {\n+            // Shifts.\n+            check!(T, VAL2 << black_box(1));\n+            check!(T, VAL2 << black_box(0));\n+\n+            check!(T, VAL3 << black_box(1));\n+            check!(T, VAL3 << black_box(0));\n+\n+            check!(T, VAL1.wrapping_shl(black_box(0)));\n+            check!(T, VAL1.wrapping_shl(black_box(1)));\n+            check!(T, VAL1.wrapping_shl(black_box(33)));\n+            check!(T, VAL1.wrapping_shl(black_box(49)));\n+            check!(T, VAL1.wrapping_shl(black_box(61)));\n+            check!(T, VAL1.wrapping_shl(black_box(63)));\n+            check!(T, VAL1.wrapping_shl(black_box(64)));\n+            check!(T, VAL1.wrapping_shl(black_box(81)));\n+\n+            check!(Option<T>, VAL1.checked_shl(black_box(0)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(1)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(33)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(49)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(61)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(63)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(64)));\n+            check!(Option<T>, VAL1.checked_shl(black_box(81)));\n+\n+            check!(T, VAL1 >> black_box(0));\n+            check!(T, VAL1 >> black_box(1));\n+\n+            check!(T, VAL2 >> black_box(1));\n+            check!(T, VAL2 >> black_box(0));\n+\n+            check!(T, VAL3 >> black_box(0));\n+            check!(T, VAL3 >> black_box(1));\n+\n+            check!(T, VAL1.wrapping_shr(black_box(0)));\n+            check!(T, VAL1.wrapping_shr(black_box(1)));\n+            check!(T, VAL1.wrapping_shr(black_box(33)));\n+            check!(T, VAL1.wrapping_shr(black_box(49)));\n+            check!(T, VAL1.wrapping_shr(black_box(61)));\n+            check!(T, VAL1.wrapping_shr(black_box(63)));\n+            check!(T, VAL1.wrapping_shr(black_box(64)));\n+            check!(T, VAL1.wrapping_shr(black_box(81)));\n+\n+            check!(Option<T>, VAL1.checked_shr(black_box(0)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(1)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(33)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(49)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(61)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(63)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(64)));\n+            check!(Option<T>, VAL1.checked_shr(black_box(81)));\n+\n+            // Casts\n+            check!(u64, (VAL1 >> black_box(1)) as u64);\n+\n+            // Addition.\n+            check!(T, VAL1 + black_box(1));\n+            check!(T, VAL2 + black_box(1));\n+            check!(T, VAL2 + (VAL2 + black_box(1)));\n+            check!(T, VAL3 + black_box(1));\n+\n+            check!(Option<T>, VAL1.checked_add(black_box(1)));\n+            check!(Option<T>, VAL2.checked_add(black_box(1)));\n+            check!(Option<T>, VAL2.checked_add(VAL2 + black_box(1)));\n+            check!(Option<T>, VAL3.checked_add(T::MAX));\n+            check!(Option<T>, VAL3.checked_add(T::MIN));\n+\n+            check!(T, VAL1.wrapping_add(black_box(1)));\n+            check!(T, VAL2.wrapping_add(black_box(1)));\n+            check!(T, VAL2.wrapping_add(VAL2 + black_box(1)));\n+            check!(T, VAL3.wrapping_add(T::MAX));\n+            check!(T, VAL3.wrapping_add(T::MIN));\n+\n+            check!((T, bool), VAL1.overflowing_add(black_box(1)));\n+            check!((T, bool), VAL2.overflowing_add(black_box(1)));\n+            check!((T, bool), VAL2.overflowing_add(VAL2 + black_box(1)));\n+            check!((T, bool), VAL3.overflowing_add(T::MAX));\n+            check!((T, bool), VAL3.overflowing_add(T::MIN));\n+\n+            check!(T, VAL1.saturating_add(black_box(1)));\n+            check!(T, VAL2.saturating_add(black_box(1)));\n+            check!(T, VAL2.saturating_add(VAL2 + black_box(1)));\n+            check!(T, VAL3.saturating_add(T::MAX));\n+            check!(T, VAL3.saturating_add(T::MIN));\n+\n+            // Subtraction\n+            check!(T, VAL1 - black_box(1));\n+            check!(T, VAL2 - black_box(1));\n+            check!(T, VAL3 - black_box(1));\n+\n+            check!(Option<T>, VAL1.checked_sub(black_box(1)));\n+            check!(Option<T>, VAL2.checked_sub(black_box(1)));\n+            check!(Option<T>, VAL2.checked_sub(VAL2 + black_box(1)));\n+            check!(Option<T>, VAL3.checked_sub(T::MAX));\n+            check!(Option<T>, VAL3.checked_sub(T::MIN));\n+\n+            check!(T, VAL1.wrapping_sub(black_box(1)));\n+            check!(T, VAL2.wrapping_sub(black_box(1)));\n+            check!(T, VAL2.wrapping_sub(VAL2 + black_box(1)));\n+            check!(T, VAL3.wrapping_sub(T::MAX));\n+            check!(T, VAL3.wrapping_sub(T::MIN));\n+\n+            check!((T, bool), VAL1.overflowing_sub(black_box(1)));\n+            check!((T, bool), VAL2.overflowing_sub(black_box(1)));\n+            check!((T, bool), VAL2.overflowing_sub(VAL2 + black_box(1)));\n+            check!((T, bool), VAL3.overflowing_sub(T::MAX));\n+            check!((T, bool), VAL3.overflowing_sub(T::MIN));\n+\n+            check!(T, VAL1.saturating_sub(black_box(1)));\n+            check!(T, VAL2.saturating_sub(black_box(1)));\n+            check!(T, VAL2.saturating_sub(VAL2 + black_box(1)));\n+            check!(T, VAL3.saturating_sub(T::MAX));\n+            check!(T, VAL3.saturating_sub(T::MIN));\n+\n+            // Multiplication\n+            check!(T, VAL1 * black_box(2));\n+            check!(T, VAL1 * (black_box(1) + VAL2));\n+            check!(T, VAL2 * black_box(2));\n+            check!(T, VAL2 * (black_box(1) + VAL2));\n+            check!(T, VAL3 * black_box(1));\n+            check!(T, VAL4 * black_box(2));\n+            check!(T, VAL5 * black_box(2));\n+\n+            check!(Option<T>, VAL1.checked_mul(black_box(2)));\n+            check!(Option<T>, VAL1.checked_mul(black_box(1) + VAL2));\n+            check!(Option<T>, VAL3.checked_mul(VAL3));\n+            check!(Option<T>, VAL4.checked_mul(black_box(2)));\n+            check!(Option<T>, VAL5.checked_mul(black_box(2)));\n+\n+            check!(T, VAL1.wrapping_mul(black_box(2)));\n+            check!(T, VAL1.wrapping_mul((black_box(1) + VAL2)));\n+            check!(T, VAL3.wrapping_mul(VAL3));\n+            check!(T, VAL4.wrapping_mul(black_box(2)));\n+            check!(T, VAL5.wrapping_mul(black_box(2)));\n+\n+            check!((T, bool), VAL1.overflowing_mul(black_box(2)));\n+            check!((T, bool), VAL1.overflowing_mul(black_box(1) + VAL2));\n+            check!((T, bool), VAL3.overflowing_mul(VAL3));\n+            check!((T, bool), VAL4.overflowing_mul(black_box(2)));\n+            check!((T, bool), VAL5.overflowing_mul(black_box(2)));\n+\n+            check!(T, VAL1.saturating_mul(black_box(2)));\n+            check!(T, VAL1.saturating_mul(black_box(1) + VAL2));\n+            check!(T, VAL3.saturating_mul(VAL3));\n+            check!(T, VAL4.saturating_mul(black_box(2)));\n+            check!(T, VAL5.saturating_mul(black_box(2)));\n+\n+            // Division.\n+            check!(T, VAL1 / black_box(2));\n+            check!(T, VAL1 / black_box(3));\n+\n+            check!(T, VAL2 / black_box(2));\n+            check!(T, VAL2 / black_box(3));\n+\n+            check!(T, VAL3 / black_box(2));\n+            check!(T, VAL3 / black_box(3));\n+            check!(T, VAL3 / (black_box(1) + VAL4));\n+            check!(T, VAL3 / (black_box(1) + VAL2));\n+\n+            check!(T, VAL4 / black_box(2));\n+            check!(T, VAL4 / black_box(3));\n+\n+            check!(Option<T>, VAL1.checked_div(black_box(2)));\n+            check!(Option<T>, VAL1.checked_div(black_box(1) + VAL2));\n+            check!(Option<T>, VAL3.checked_div(VAL3));\n+            check!(Option<T>, VAL4.checked_div(black_box(2)));\n+            check!(Option<T>, VAL5.checked_div(black_box(2)));\n+            check!(Option<T>, (T::MIN).checked_div(black_box(0 as T).wrapping_sub(1)));\n+            check!(Option<T>, VAL5.checked_div(black_box(0))); // var5 / 0\n+\n+            check!(T, VAL1.wrapping_div(black_box(2)));\n+            check!(T, VAL1.wrapping_div(black_box(1) + VAL2));\n+            check!(T, VAL3.wrapping_div(VAL3));\n+            check!(T, VAL4.wrapping_div(black_box(2)));\n+            check!(T, VAL5.wrapping_div(black_box(2)));\n+            check!(T, (T::MIN).wrapping_div(black_box(0 as T).wrapping_sub(1)));\n+\n+            check!((T, bool), VAL1.overflowing_div(black_box(2)));\n+            check!((T, bool), VAL1.overflowing_div(black_box(1) + VAL2));\n+            check!((T, bool), VAL3.overflowing_div(VAL3));\n+            check!((T, bool), VAL4.overflowing_div(black_box(2)));\n+            check!((T, bool), VAL5.overflowing_div(black_box(2)));\n+            check!((T, bool), (T::MIN).overflowing_div(black_box(0 as T).wrapping_sub(1)));\n+\n+            check!(T, VAL1.saturating_div(black_box(2)));\n+            check!(T, VAL1.saturating_div((black_box(1) + VAL2)));\n+            check!(T, VAL3.saturating_div(VAL3));\n+            check!(T, VAL4.saturating_div(black_box(2)));\n+            check!(T, VAL5.saturating_div(black_box(2)));\n+            check!(T, (T::MIN).saturating_div((0 as T).wrapping_sub(black_box(1))));\n+        };\n+    }\n+\n+    {\n+        type T = u32;\n+        const VAL1: T = 14162_u32;\n+        const VAL2: T = 14556_u32;\n+        const VAL3: T = 323656954_u32;\n+        const VAL4: T = 2023651954_u32;\n+        const VAL5: T = 1323651954_u32;\n+        check_ops32!();\n+    }\n+\n+    {\n+        type T = i32;\n+        const VAL1: T = 13456_i32;\n+        const VAL2: T = 10475_i32;\n+        const VAL3: T = 923653954_i32;\n+        const VAL4: T = 993198738_i32;\n+        const VAL5: T = 1023653954_i32;\n+        check_ops32!();\n+    }\n+\n+    {\n+        type T = u64;\n+        const VAL1: T = 134217856_u64;\n+        const VAL2: T = 104753732_u64;\n+        const VAL3: T = 12323651988970863954_u64;\n+        const VAL4: T = 7323651988970863954_u64;\n+        const VAL5: T = 8323651988970863954_u64;\n+        check_ops64!();\n+    }\n+\n+    {\n+        type T = i64;\n+        const VAL1: T = 134217856_i64;\n+        const VAL2: T = 104753732_i64;\n+        const VAL3: T = 6323651988970863954_i64;\n+        const VAL4: T = 2323651988970863954_i64;\n+        const VAL5: T = 3323651988970863954_i64;\n+        check_ops64!();\n+    }\n+\n+    {\n+        type T = u128;\n+        const VAL1: T = 134217856_u128;\n+        const VAL2: T = 10475372733397991552_u128;\n+        const VAL3: T = 193236519889708027473620326106273939584_u128;\n+        const VAL4: T = 123236519889708027473620326106273939584_u128;\n+        const VAL5: T = 153236519889708027473620326106273939584_u128;\n+        check_ops128!();\n+    }\n+    {\n+        type T = i128;\n+        const VAL1: T = 134217856_i128;\n+        const VAL2: T = 10475372733397991552_i128;\n+        const VAL3: T = 83236519889708027473620326106273939584_i128;\n+        const VAL4: T = 63236519889708027473620326106273939584_i128;\n+        const VAL5: T = 73236519889708027473620326106273939584_i128;\n+        check_ops128!();\n+    }\n \n     0\n }"}]}