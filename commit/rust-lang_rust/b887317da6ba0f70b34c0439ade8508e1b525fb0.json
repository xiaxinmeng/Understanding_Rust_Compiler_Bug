{"sha": "b887317da6ba0f70b34c0439ade8508e1b525fb0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4ODczMTdkYTZiYTBmNzBiMzRjMDQzOWFkZTg1MDhlMWI1MjVmYjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-22T08:10:41Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-22T08:10:41Z"}, "message": "Auto merge of #47158 - rkruppe:repr-transparent, r=eddyb\n\nImplement repr(transparent)\n\nr? @eddyb for the functional changes. The bulk of the PR is error messages and docs, might be good to have a doc person look over those.\n\ncc #43036\ncc @nox", "tree": {"sha": "ce6ba8d360d4f6026f495694b15b31e4b9f86179", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce6ba8d360d4f6026f495694b15b31e4b9f86179"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b887317da6ba0f70b34c0439ade8508e1b525fb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b887317da6ba0f70b34c0439ade8508e1b525fb0", "html_url": "https://github.com/rust-lang/rust/commit/b887317da6ba0f70b34c0439ade8508e1b525fb0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b887317da6ba0f70b34c0439ade8508e1b525fb0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc072ed0ca8e2e9f8c79fb04e85b47b5c0e8d6ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc072ed0ca8e2e9f8c79fb04e85b47b5c0e8d6ae", "html_url": "https://github.com/rust-lang/rust/commit/bc072ed0ca8e2e9f8c79fb04e85b47b5c0e8d6ae"}, {"sha": "2be697bc215f19b4bf17df6b9b56626ab7b1d994", "url": "https://api.github.com/repos/rust-lang/rust/commits/2be697bc215f19b4bf17df6b9b56626ab7b1d994", "html_url": "https://github.com/rust-lang/rust/commit/2be697bc215f19b4bf17df6b9b56626ab7b1d994"}], "stats": {"total": 893, "additions": 881, "deletions": 12}, "files": [{"sha": "62202dc96fd4620e2ce53da7df0dfc40de26978a", "filename": "src/doc/unstable-book/src/language-features/repr-transparent.md", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-transparent.md", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-transparent.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-transparent.md?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -0,0 +1,176 @@\n+# `repr_transparent`\n+\n+The tracking issue for this feature is: [#43036]\n+\n+[#43036]: https://github.com/rust-lang/rust/issues/43036\n+\n+------------------------\n+\n+This feature enables the `repr(transparent)` attribute on structs, which enables\n+the use of newtypes without the usual ABI implications of wrapping the value in\n+a struct.\n+\n+## Background\n+\n+It's sometimes useful to add additional type safety by introducing *newtypes*.\n+For example, code that handles numeric quantities in different units such as\n+millimeters, centimeters, grams, kilograms, etc. may want to use the type system\n+to rule out mistakes such as adding millimeters to grams:\n+\n+```rust\n+use std::ops::Add;\n+\n+struct Millimeters(f64);\n+struct Grams(f64);\n+\n+impl Add<Millimeters> for Millimeters {\n+    type Output = Millimeters;\n+\n+    fn add(self, other: Millimeters) -> Millimeters {\n+        Millimeters(self.0 + other.0)\n+    }\n+}\n+\n+// Likewise: impl Add<Grams> for Grams {}\n+```\n+\n+Other uses of newtypes include using `PhantomData` to add lifetimes to raw\n+pointers or to implement the \"phantom types\" pattern. See the [PhantomData]\n+documentation and [the Nomicon][nomicon-phantom] for more details.\n+\n+The added type safety is especially useful when interacting with C or other\n+languages. However, in those cases we need to ensure the newtypes we add do not\n+introduce incompatibilities with the C ABI.\n+\n+## Newtypes in FFI\n+\n+Luckily, `repr(C)` newtypes are laid out just like the type they wrap on all\n+platforms which Rust currently supports, and likely on many more. For example,\n+consider this C declaration:\n+\n+```C\n+struct Object {\n+    double weight; //< in grams\n+    double height; //< in millimeters\n+    // ...\n+}\n+\n+void frobnicate(struct Object *);\n+```\n+\n+While using this C code from Rust, we could add `repr(C)` to the `Grams` and\n+`Millimeters` newtypes introduced above and use them to add some type safety\n+while staying compatible with the memory layout of `Object`:\n+\n+```rust,no_run\n+#[repr(C)]\n+struct Grams(f64);\n+\n+#[repr(C)]\n+struct Millimeters(f64);\n+\n+#[repr(C)]\n+struct Object {\n+    weight: Grams,\n+    height: Millimeters,\n+    // ...\n+}\n+\n+extern {\n+    fn frobnicate(_: *mut Object);\n+}\n+```\n+\n+This works even when adding some `PhantomData` fields, because they are\n+zero-sized and therefore don't have to affect the memory layout.\n+\n+However, there's more to the ABI than just memory layout: there's also the\n+question of how function call arguments and return values are passed. Many\n+common ABI treat a struct containing a single field differently from that field\n+itself, at least when the field is a scalar (e.g., integer or float or pointer).\n+\n+To continue the above example, suppose the C library also exposes a function\n+like this:\n+\n+```C\n+double calculate_weight(double height);\n+```\n+\n+Using our newtypes on the Rust side like this will cause an ABI mismatch on many\n+platforms:\n+\n+```rust,ignore\n+extern {\n+    fn calculate_weight(height: Millimeters) -> Grams;\n+}\n+```\n+\n+For example, on x86_64 Linux, Rust will pass the argument in an integer\n+register, while the C function expects the argument to be in a floating-point\n+register. Likewise, the C function will return the result in a floating-point\n+register while Rust will expect it in an integer register.\n+\n+Note that this problem is not specific to floats: To give another example,\n+32-bit x86 linux will pass and return `struct Foo(i32);` on the stack while\n+`i32` is placed in registers.\n+\n+## Enter `repr(transparent)`\n+\n+So while `repr(C)` happens to do the right thing with respect to memory layout,\n+it's not quite the right tool for newtypes in FFI. Instead of declaring a C\n+struct, we need to communicate to the Rust compiler that our newtype is just for\n+type safety on the Rust side. This is what `repr(transparent)` does.\n+\n+The attribute can be applied to a newtype-like structs that contains a single\n+field. It indicates that the newtype should be represented exactly like that\n+field's type, i.e., the newtype should be ignored for ABI purpopses: not only is\n+it laid out the same in memory, it is also passed identically in function calls.\n+\n+In the above example, the ABI mismatches can be prevented by making the newtypes\n+`Grams` and `Millimeters` transparent like this:\n+\n+```rust\n+#![feature(repr_transparent)]\n+\n+#[repr(transparent)]\n+struct Grams(f64);\n+\n+#[repr(transparent)]\n+struct Millimeters(f64);\n+```\n+\n+In addition to that single field, any number of zero-sized fields are permitted,\n+including but not limited to `PhantomData`:\n+\n+```rust\n+#![feature(repr_transparent)]\n+\n+use std::marker::PhantomData;\n+\n+struct Foo { /* ... */ }\n+\n+#[repr(transparent)]\n+struct FooPtrWithLifetime<'a>(*const Foo, PhantomData<&'a Foo>);\n+\n+#[repr(transparent)]\n+struct NumberWithUnit<T, U>(T, PhantomData<U>);\n+\n+struct CustomZst;\n+\n+#[repr(transparent)]\n+struct PtrWithCustomZst<'a> {\n+    ptr: FooPtrWithLifetime<'a>,\n+    some_marker: CustomZst,\n+}\n+```\n+\n+Transparent structs can be nested: `PtrWithCustomZst` is also represented\n+exactly like `*const Foo`.\n+\n+Because `repr(transparent)` delegates all representation concerns to another\n+type, it is incompatible with all other `repr(..)` attributes. It also cannot be\n+applied to enums, unions, empty structs, structs whose fields are all\n+zero-sized, or structs with *multiple* non-zero-sized fields.\n+\n+[PhantomData]: https://doc.rust-lang.org/std/marker/struct.PhantomData.html\n+[nomicon-phantom]: https://doc.rust-lang.org/nomicon/phantom-data.html"}, {"sha": "1d7cde8126547ed8672f73fb3ba14629176e6e53", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -2003,7 +2003,69 @@ that refers to itself. That is permitting, since the closure would be\n invoking itself via a virtual call, and hence does not directly\n reference its own *type*.\n \n-\"##, }\n+\"##,\n+\n+E0692: r##\"\n+A `repr(transparent)` type was also annotated with other, incompatible\n+representation hints.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0692\n+#![feature(repr_transparent)]\n+\n+#[repr(transparent, C)] // error: incompatible representation hints\n+struct Grams(f32);\n+```\n+\n+A type annotated as `repr(transparent)` delegates all representation concerns to\n+another type, so adding more representation hints is contradictory. Remove\n+either the `transparent` hint or the other hints, like this:\n+\n+```\n+#![feature(repr_transparent)]\n+\n+#[repr(transparent)]\n+struct Grams(f32);\n+```\n+\n+Alternatively, move the other attributes to the contained type:\n+\n+```\n+#![feature(repr_transparent)]\n+\n+#[repr(C)]\n+struct Foo {\n+    x: i32,\n+    // ...\n+}\n+\n+#[repr(transparent)]\n+struct FooWrapper(Foo);\n+```\n+\n+Note that introducing another `struct` just to have a place for the other\n+attributes may have unintended side effects on the representation:\n+\n+```\n+#![feature(repr_transparent)]\n+\n+#[repr(transparent)]\n+struct Grams(f32);\n+\n+#[repr(C)]\n+struct Float(f32);\n+\n+#[repr(transparent)]\n+struct Grams2(Float); // this is not equivalent to `Grams` above\n+```\n+\n+Here, `Grams2` is a not equivalent to `Grams` -- the former transparently wraps\n+a (non-transparent) struct containing a single float, while `Grams` is a\n+transparent wrapper around a float. This can make a difference for the ABI.\n+\"##,\n+\n+}\n \n \n register_diagnostics! {"}, {"sha": "a073910fdc83f1d06d23d655189d044a56ea05b7", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -92,6 +92,7 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n         let mut int_reprs = 0;\n         let mut is_c = false;\n         let mut is_simd = false;\n+        let mut is_transparent = false;\n \n         for hint in &hints {\n             let name = if let Some(name) = hint.name() {\n@@ -137,6 +138,14 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                         continue\n                     }\n                 }\n+                \"transparent\" => {\n+                    is_transparent = true;\n+                    if target != Target::Struct {\n+                        (\"a\", \"struct\")\n+                    } else {\n+                        continue\n+                    }\n+                }\n                 \"i8\" | \"u8\" | \"i16\" | \"u16\" |\n                 \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n                 \"isize\" | \"usize\" => {\n@@ -155,14 +164,22 @@ impl<'a, 'tcx> CheckAttrVisitor<'a, 'tcx> {\n                 .emit();\n         }\n \n+        // Just point at all repr hints if there are any incompatibilities.\n+        // This is not ideal, but tracking precisely which ones are at fault is a huge hassle.\n+        let hint_spans = hints.iter().map(|hint| hint.span);\n+\n+        // Error on repr(transparent, <anything else>).\n+        if is_transparent && hints.len() > 1 {\n+            let hint_spans: Vec<_> = hint_spans.clone().collect();\n+            span_err!(self.tcx.sess, hint_spans, E0692,\n+                      \"transparent struct cannot have other repr hints\");\n+        }\n         // Warn on repr(u8, u16), repr(C, simd), and c-like-enum-repr(C, u8)\n         if (int_reprs > 1)\n            || (is_simd && is_c)\n            || (int_reprs == 1 && is_c && is_c_like_enum(item)) {\n-            // Just point at all repr hints. This is not ideal, but tracking\n-            // precisely which ones are at fault is a huge hassle.\n-            let spans: Vec<_> = hints.iter().map(|hint| hint.span).collect();\n-            span_warn!(self.tcx.sess, spans, E0566,\n+            let hint_spans: Vec<_> = hint_spans.collect();\n+            span_warn!(self.tcx.sess, hint_spans, E0566,\n                        \"conflicting representation hints\");\n         }\n     }"}, {"sha": "d727dfb0c4b2deef220d33c0f16cefa057ad8e37", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -44,6 +44,7 @@\n #![feature(box_syntax)]\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n+#![feature(copy_closures, clone_closures)]\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n #![feature(dyn_trait)]"}, {"sha": "deaea70f760f1fcf726c64832d4168e8398f4b4d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -1499,8 +1499,9 @@ bitflags! {\n         const IS_C               = 1 << 0;\n         const IS_PACKED          = 1 << 1;\n         const IS_SIMD            = 1 << 2;\n+        const IS_TRANSPARENT     = 1 << 3;\n         // Internal only for now. If true, don't reorder fields.\n-        const IS_LINEAR          = 1 << 3;\n+        const IS_LINEAR          = 1 << 4;\n \n         // Any of these flags being set prevent field reordering optimisation.\n         const IS_UNOPTIMISABLE   = ReprFlags::IS_C.bits |\n@@ -1540,6 +1541,7 @@ impl ReprOptions {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked => ReprFlags::IS_PACKED,\n+                    attr::ReprTransparent => ReprFlags::IS_TRANSPARENT,\n                     attr::ReprSimd => ReprFlags::IS_SIMD,\n                     attr::ReprInt(i) => {\n                         size = Some(i);\n@@ -1567,6 +1569,8 @@ impl ReprOptions {\n     #[inline]\n     pub fn packed(&self) -> bool { self.flags.contains(ReprFlags::IS_PACKED) }\n     #[inline]\n+    pub fn transparent(&self) -> bool { self.flags.contains(ReprFlags::IS_TRANSPARENT) }\n+    #[inline]\n     pub fn linear(&self) -> bool { self.flags.contains(ReprFlags::IS_LINEAR) }\n \n     pub fn discr_type(&self) -> attr::IntType {"}, {"sha": "2267d2b89ccf1d80d925659bb77a1db4b50cd230", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -416,7 +416,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                 }\n                 match def.adt_kind() {\n                     AdtKind::Struct => {\n-                        if !def.repr.c() {\n+                        if !def.repr.c() && !def.repr.transparent() {\n                             return FfiUnsafe(\"found struct without foreign-function-safe \\\n                                               representation annotation in foreign module, \\\n                                               consider adding a #[repr(C)] attribute to the type\");\n@@ -427,13 +427,24 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n                                               adding a member to this struct\");\n                         }\n \n-                        // We can't completely trust repr(C) markings; make sure the\n-                        // fields are actually safe.\n+                        // We can't completely trust repr(C) and repr(transparent) markings;\n+                        // make sure the fields are actually safe.\n                         let mut all_phantom = true;\n                         for field in &def.non_enum_variant().fields {\n                             let field_ty = cx.fully_normalize_associated_types_in(\n                                 &field.ty(cx, substs)\n                             );\n+                            // repr(transparent) types are allowed to have arbitrary ZSTs, not just\n+                            // PhantomData -- skip checking all ZST fields\n+                            if def.repr.transparent() {\n+                                let is_zst = (cx, cx.param_env(field.did))\n+                                    .layout_of(field_ty)\n+                                    .map(|layout| layout.is_zst())\n+                                    .unwrap_or(false);\n+                                if is_zst {\n+                                    continue;\n+                                }\n+                            }\n                             let r = self.check_type_for_ffi(cache, field_ty);\n                             match r {\n                                 FfiSafe => {"}, {"sha": "cb8ce8d5ac331296e971ac3f02bef1cbf36d5331", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -101,6 +101,7 @@ use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::maps::Providers;\n use rustc::ty::util::{Representability, IntTypeExt};\n+use rustc::ty::layout::LayoutOf;\n use errors::{DiagnosticBuilder, DiagnosticId};\n use require_c_abi_if_variadic;\n use session::{CompileIncomplete, config, Session};\n@@ -1104,6 +1105,7 @@ fn check_struct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         check_simd(tcx, span, def_id);\n     }\n \n+    check_transparent(tcx, span, def_id);\n     check_packed(tcx, span, def_id);\n }\n \n@@ -1517,6 +1519,42 @@ fn check_packed_inner<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     false\n }\n \n+fn check_transparent<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, sp: Span, def_id: DefId) {\n+    let adt = tcx.adt_def(def_id);\n+    if !adt.repr.transparent() {\n+        return;\n+    }\n+\n+    // For each field, figure out if it's known to be a ZST and align(1)\n+    let field_infos: Vec<_> = adt.non_enum_variant().fields.iter().map(|field| {\n+        let ty = field.ty(tcx, Substs::identity_for_item(tcx, field.did));\n+        let param_env = tcx.param_env(field.did);\n+        let layout = (tcx, param_env).layout_of(ty);\n+        // We are currently checking the type this field came from, so it must be local\n+        let span = tcx.hir.span_if_local(field.did).unwrap();\n+        let zst = layout.map(|layout| layout.is_zst()).unwrap_or(false);\n+        let align1 = layout.map(|layout| layout.align.abi() == 1).unwrap_or(false);\n+        (span, zst, align1)\n+    }).collect();\n+\n+    let non_zst_fields = field_infos.iter().filter(|(_span, zst, _align1)| !*zst);\n+    let non_zst_count = non_zst_fields.clone().count();\n+    if non_zst_count != 1 {\n+        let field_spans: Vec<_> = non_zst_fields.map(|(span, _zst, _align1)| *span).collect();\n+        struct_span_err!(tcx.sess, sp, E0690,\n+                         \"transparent struct needs exactly one non-zero-sized field, but has {}\",\n+                          non_zst_count)\n+        .span_note(field_spans, \"non-zero-sized field\")\n+        .emit();\n+    }\n+    for &(span, zst, align1) in &field_infos {\n+        if zst && !align1 {\n+            span_err!(tcx.sess, span, E0691,\n+                      \"zero-sized field in transparent struct has alignment larger than 1\");\n+        }\n+    }\n+}\n+\n #[allow(trivial_numeric_casts)]\n pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             sp: Span,"}, {"sha": "4f661a4f5e67d739a01c549d8d952609ffb4529f", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -4605,6 +4605,99 @@ let _ = x.powi(2);\n let _ = (2.0 as f32).powi(2);\n ```\n \"##,\n+\n+E0690: r##\"\n+A struct with the representation hint `repr(transparent)` had zero or more than\n+on fields that were not guaranteed to be zero-sized.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0690\n+#![feature(repr_transparent)]\n+\n+#[repr(transparent)]\n+struct LengthWithUnit<U> { // error: transparent struct needs exactly one\n+    value: f32,            //        non-zero-sized field, but has 2\n+    unit: U,\n+}\n+```\n+\n+Because transparent structs are represented exactly like one of their fields at\n+run time, said field must be uniquely determined. If there is no field, or if\n+there are multiple fields, it is not clear how the struct should be represented.\n+Note that fields of zero-typed types (e.g., `PhantomData`) can also exist\n+alongside the field that contains the actual data, they do not count for this\n+error. When generic types are involved (as in the above example), an error is\n+reported because the type parameter could be non-zero-sized.\n+\n+To combine `repr(transparent)` with type parameters, `PhantomData` may be\n+useful:\n+\n+```\n+#![feature(repr_transparent)]\n+\n+use std::marker::PhantomData;\n+\n+#[repr(transparent)]\n+struct LengthWithUnit<U> {\n+    value: f32,\n+    unit: PhantomData<U>,\n+}\n+```\n+\"##,\n+\n+E0691: r##\"\n+A struct with the `repr(transparent)` representation hint contains a zero-sized\n+field that requires non-trivial alignment.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0691\n+#![feature(repr_transparent, repr_align, attr_literals)]\n+\n+#[repr(align(32))]\n+struct ForceAlign32;\n+\n+#[repr(transparent)]\n+struct Wrapper(f32, ForceAlign32); // error: zero-sized field in transparent\n+                                   //        struct has alignment larger than 1\n+```\n+\n+A transparent struct is supposed to be represented exactly like the piece of\n+data it contains. Zero-sized fields with different alignment requirements\n+potentially conflict with this property. In the example above, `Wrapper` would\n+have to be aligned to 32 bytes even though `f32` has a smaller alignment\n+requirement.\n+\n+Consider removing the over-aligned zero-sized field:\n+\n+```\n+#![feature(repr_transparent)]\n+\n+#[repr(transparent)]\n+struct Wrapper(f32);\n+```\n+\n+Alternatively, `PhantomData<T>` has alignment 1 for all `T`, so you can use it\n+if you need to keep the field for some reason:\n+\n+```\n+#![feature(repr_transparent, repr_align, attr_literals)]\n+\n+use std::marker::PhantomData;\n+\n+#[repr(align(32))]\n+struct ForceAlign32;\n+\n+#[repr(transparent)]\n+struct Wrapper(f32, PhantomData<ForceAlign32>);\n+```\n+\n+Note that empty arrays `[T; 0]` have the same alignment requirement as the\n+element type `T`. Also note that the error is conservatively reported even when\n+the alignment of the zero-sized type is less than or equal to the data field's\n+alignment.\n+\"##,\n }\n \n register_diagnostics! {"}, {"sha": "786a6783440640011f5a9101300242e06654c544", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -77,6 +77,7 @@ This API is completely unstable and subject to change.\n #![feature(box_syntax)]\n #![feature(crate_visibility_modifier)]\n #![feature(conservative_impl_trait)]\n+#![feature(copy_closures, clone_closures)]\n #![feature(from_ref)]\n #![feature(match_default_bindings)]\n #![feature(never_type)]"}, {"sha": "d18d6f5e6bd0d8a9b05447c6aec2eee9ffded2b3", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -992,7 +992,8 @@ pub fn find_deprecation(diagnostic: &Handler, attrs: &[Attribute],\n /// Valid repr contents: any of the primitive integral type names (see\n /// `int_type_of_word`, below) to specify enum discriminant type; `C`, to use\n /// the same discriminant size that the corresponding C enum would or C\n-/// structure layout, and `packed` to remove padding.\n+/// structure layout, `packed` to remove padding, and `transparent` to elegate representation\n+/// concerns to the only non-ZST field.\n pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr> {\n     let mut acc = Vec::new();\n     if attr.path == \"repr\" {\n@@ -1011,6 +1012,7 @@ pub fn find_repr_attrs(diagnostic: &Handler, attr: &Attribute) -> Vec<ReprAttr>\n                         \"C\" => Some(ReprC),\n                         \"packed\" => Some(ReprPacked),\n                         \"simd\" => Some(ReprSimd),\n+                        \"transparent\" => Some(ReprTransparent),\n                         _ => match int_type_of_word(word) {\n                             Some(ity) => Some(ReprInt(ity)),\n                             None => {\n@@ -1082,6 +1084,7 @@ pub enum ReprAttr {\n     ReprC,\n     ReprPacked,\n     ReprSimd,\n+    ReprTransparent,\n     ReprAlign(u32),\n }\n "}, {"sha": "ac5a10ec70364674bc46c5abf810ee108667ec88", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -452,6 +452,9 @@ declare_features! (\n \n     // `extern` in paths\n     (active, extern_in_paths, \"1.23.0\", Some(44660)),\n+\n+    // Allows `#[repr(transparent)]` attribute on newtype structs\n+    (active, repr_transparent, \"1.25.0\", Some(43036)),\n );\n \n declare_features! (\n@@ -1524,6 +1527,11 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                                                \"the struct `#[repr(align(u16))]` attribute \\\n                                                 is experimental\");\n                         }\n+                        if item.check_name(\"transparent\") {\n+                            gate_feature_post!(&self, repr_transparent, attr.span,\n+                                               \"the `#[repr(transparent)]` attribute \\\n+                                               is experimental\");\n+                        }\n                     }\n                 }\n             }"}, {"sha": "3660d2fe46a92b0ff86c22a91627a484495fd6fa", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -830,7 +830,9 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n     for a in type_attrs {\n         for r in &attr::find_repr_attrs(diagnostic, a) {\n             repr_type_name = match *r {\n-                attr::ReprPacked | attr::ReprSimd | attr::ReprAlign(_) => continue,\n+                attr::ReprPacked | attr::ReprSimd | attr::ReprAlign(_) | attr::ReprTransparent =>\n+                    continue,\n+\n                 attr::ReprC => \"i32\",\n \n                 attr::ReprInt(attr::SignedInt(ast::IntTy::Isize)) => \"isize\","}, {"sha": "2eeed2b788ce2f68154dfa32243aa51bc7a6fc2a", "filename": "src/test/codegen/repr-transparent-aggregates-1.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-1.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+// ignore-arm\n+// ignore-mips\n+// ignore-mips64\n+// ignore-powerpc\n+// ignore-powerpc64\n+// See repr-transparent.rs\n+\n+#![crate_type=\"lib\"]\n+#![feature(repr_transparent)]\n+\n+\n+#[repr(C)]\n+pub struct Big([u32; 16]);\n+\n+#[repr(transparent)]\n+pub struct BigW(Big);\n+\n+// CHECK: define void @test_Big(%Big* [[BIG_RET_ATTRS:.*]], %Big* [[BIG_ARG_ATTRS:.*]])\n+#[no_mangle]\n+pub extern fn test_Big(_: Big) -> Big { loop {} }\n+\n+// CHECK: define void @test_BigW(%BigW* [[BIG_RET_ATTRS]], %BigW* [[BIG_ARG_ATTRS]])\n+#[no_mangle]\n+pub extern fn test_BigW(_: BigW) -> BigW { loop {} }\n+\n+\n+#[repr(C)]\n+pub union BigU {\n+    foo: [u32; 16],\n+}\n+\n+#[repr(transparent)]\n+pub struct BigUw(BigU);\n+\n+// CHECK: define void @test_BigU(%BigU* [[BIGU_RET_ATTRS:.*]], %BigU* [[BIGU_ARG_ATTRS:.*]])\n+#[no_mangle]\n+pub extern fn test_BigU(_: BigU) -> BigU { loop {} }\n+\n+// CHECK: define void @test_BigUw(%BigUw* [[BIGU_RET_ATTRS]], %BigUw* [[BIGU_ARG_ATTRS]])\n+#[no_mangle]\n+pub extern fn test_BigUw(_: BigUw) -> BigUw { loop {} }"}, {"sha": "e6374928a5cbfd8e954800439e90abdce7909627", "filename": "src/test/codegen/repr-transparent-aggregates-2.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent-aggregates-2.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+// ignore-aarch64\n+// ignore-asmjs\n+// ignore-s390x\n+// ignore-wasm\n+// ignore-x86\n+// ignore-x86_64\n+// See repr-transparent.rs\n+\n+#![crate_type=\"lib\"]\n+#![feature(repr_transparent)]\n+\n+\n+#[repr(C)]\n+pub struct Big([u32; 16]);\n+\n+#[repr(transparent)]\n+pub struct BigW(Big);\n+\n+// CHECK: define void @test_Big(%Big* [[BIG_RET_ATTRS:.*]], [16 x i32]\n+#[no_mangle]\n+pub extern fn test_Big(_: Big) -> Big { loop {} }\n+\n+// CHECK: define void @test_BigW(%BigW* [[BIG_RET_ATTRS]], [16 x i32]\n+#[no_mangle]\n+pub extern fn test_BigW(_: BigW) -> BigW { loop {} }\n+\n+\n+#[repr(C)]\n+pub union BigU {\n+    foo: [u32; 16],\n+}\n+\n+#[repr(transparent)]\n+pub struct BigUw(BigU);\n+\n+// CHECK: define void @test_BigU(%BigU* [[BIGU_RET_ATTRS:.*]], [16 x i32]\n+#[no_mangle]\n+pub extern fn test_BigU(_: BigU) -> BigU { loop {} }\n+\n+// CHECK: define void @test_BigUw(%BigUw* [[BIGU_RET_ATTRS]], [16 x i32]\n+#[no_mangle]\n+pub extern fn test_BigUw(_: BigUw) -> BigUw { loop {} }"}, {"sha": "31020d8b94f80b5eb1bf546c280a6b72d33daca6", "filename": "src/test/codegen/repr-transparent.rs", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcodegen%2Frepr-transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Frepr-transparent.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -0,0 +1,177 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -C no-prepopulate-passes\n+\n+#![crate_type=\"lib\"]\n+#![feature(repr_transparent, repr_simd)]\n+\n+use std::marker::PhantomData;\n+\n+pub struct Zst1;\n+pub struct Zst2(());\n+\n+#[repr(transparent)]\n+pub struct F32(f32);\n+\n+// CHECK: define float @test_F32(float %arg0)\n+#[no_mangle]\n+pub extern fn test_F32(_: F32) -> F32 { loop {} }\n+\n+#[repr(transparent)]\n+pub struct Ptr(*mut u8);\n+\n+// CHECK: define i8* @test_Ptr(i8* %arg0)\n+#[no_mangle]\n+pub extern fn test_Ptr(_: Ptr) -> Ptr { loop {} }\n+\n+#[repr(transparent)]\n+pub struct WithZst(u64, Zst1);\n+\n+// CHECK: define i64 @test_WithZst(i64 %arg0)\n+#[no_mangle]\n+pub extern fn test_WithZst(_: WithZst) -> WithZst { loop {} }\n+\n+#[repr(transparent)]\n+pub struct WithZeroSizedArray(*const f32, [i8; 0]);\n+\n+// Apparently we use i32* when newtype-unwrapping f32 pointers. Whatever.\n+// CHECK: define i32* @test_WithZeroSizedArray(i32* %arg0)\n+#[no_mangle]\n+pub extern fn test_WithZeroSizedArray(_: WithZeroSizedArray) -> WithZeroSizedArray { loop {} }\n+\n+#[repr(transparent)]\n+pub struct Generic<T>(T);\n+\n+// CHECK: define double @test_Generic(double %arg0)\n+#[no_mangle]\n+pub extern fn test_Generic(_: Generic<f64>) -> Generic<f64> { loop {} }\n+\n+#[repr(transparent)]\n+pub struct GenericPlusZst<T>(T, Zst2);\n+\n+#[repr(u8)]\n+pub enum Bool { True, False, FileNotFound }\n+\n+// CHECK: define{{( zeroext)?}} i8 @test_Gpz(i8{{( zeroext)?}} %arg0)\n+#[no_mangle]\n+pub extern fn test_Gpz(_: GenericPlusZst<Bool>) -> GenericPlusZst<Bool> { loop {} }\n+\n+#[repr(transparent)]\n+pub struct LifetimePhantom<'a, T: 'a>(*const T, PhantomData<&'a T>);\n+\n+// CHECK: define i16* @test_LifetimePhantom(i16* %arg0)\n+#[no_mangle]\n+pub extern fn test_LifetimePhantom(_: LifetimePhantom<i16>) -> LifetimePhantom<i16> { loop {} }\n+\n+// This works despite current alignment resrictions because PhantomData is always align(1)\n+#[repr(transparent)]\n+pub struct UnitPhantom<T, U> { val: T, unit: PhantomData<U> }\n+\n+pub struct Px;\n+\n+// CHECK: define float @test_UnitPhantom(float %arg0)\n+#[no_mangle]\n+pub extern fn test_UnitPhantom(_: UnitPhantom<f32, Px>) -> UnitPhantom<f32, Px> { loop {} }\n+\n+#[repr(transparent)]\n+pub struct TwoZsts(Zst1, i8, Zst2);\n+\n+// CHECK: define{{( signext)?}} i8 @test_TwoZsts(i8{{( signext)?}} %arg0)\n+#[no_mangle]\n+pub extern fn test_TwoZsts(_: TwoZsts) -> TwoZsts { loop {} }\n+\n+#[repr(transparent)]\n+pub struct Nested1(Zst2, Generic<f64>);\n+\n+// CHECK: define double @test_Nested1(double %arg0)\n+#[no_mangle]\n+pub extern fn test_Nested1(_: Nested1) -> Nested1 { loop {} }\n+\n+#[repr(transparent)]\n+pub struct Nested2(Nested1, Zst1);\n+\n+// CHECK: define double @test_Nested2(double %arg0)\n+#[no_mangle]\n+pub extern fn test_Nested2(_: Nested2) -> Nested2 { loop {} }\n+\n+#[repr(simd)]\n+struct f32x4(f32, f32, f32, f32);\n+\n+#[repr(transparent)]\n+pub struct Vector(f32x4);\n+\n+// CHECK: define <4 x float> @test_Vector(<4 x float> %arg0)\n+#[no_mangle]\n+pub extern fn test_Vector(_: Vector) -> Vector { loop {} }\n+\n+trait Mirror { type It: ?Sized; }\n+impl<T: ?Sized> Mirror for T { type It = Self; }\n+\n+#[repr(transparent)]\n+pub struct StructWithProjection(<f32 as Mirror>::It);\n+\n+// CHECK: define float @test_Projection(float %arg0)\n+#[no_mangle]\n+pub extern fn test_Projection(_: StructWithProjection) -> StructWithProjection { loop {} }\n+\n+\n+// The rest of this file tests newtypes around small aggregates on an ABI where small aggregates are\n+// packed into one register. This is ABI-dependent, so instead we focus on one ABI and supply a\n+// dummy definition for other ABIs to keep FileCheck happy.\n+//\n+// Bigger aggregates are tested in separate files called repr-transparent-aggregate-*.rs because\n+// there, the expected LLVM IR function signatures vary so much that it's not reasonably possible to\n+// cover all of them with a single CHECK line. Instead we group ABIs by the general \"shape\" of the\n+// signature and have a separate test file for each bin.\n+//\n+// PS: You may be wondering why we don't just compare the return types and argument types for\n+// equality with FileCheck regex captures. Well, rustc doesn't perform newtype unwrapping on\n+// newtypes containing aggregates. This is OK on all ABIs we support, but because LLVM has not\n+// gotten rid of pointee types yet, the IR function signature will be syntactically different (%Foo*\n+// vs %FooWrapper*).\n+\n+#[repr(C)]\n+pub struct Rgb8 { r: u8, g: u8, b: u8 }\n+\n+#[repr(transparent)]\n+pub struct Rgb8Wrap(Rgb8);\n+\n+// NB: closing parenthesis is missing because sometimes the argument has a name and sometimes not\n+// CHECK: define i32 @test_Rgb8Wrap(i32\n+#[no_mangle]\n+#[cfg(all(target_arch=\"x86_64\", target_os=\"linux\"))]\n+pub extern fn test_Rgb8Wrap(_: Rgb8Wrap) -> Rgb8Wrap { loop {} }\n+\n+#[cfg(not(all(target_arch=\"x86_64\", target_os=\"linux\")))]\n+#[no_mangle]\n+pub extern fn test_Rgb8Wrap(_: u32) -> u32 { loop {} }\n+\n+// Same as with the small struct above: ABI-dependent, we only test the interesting case\n+// (ABIs that pack the aggregate into a scalar) and stub it out on other ABIs\n+\n+#[repr(C)]\n+pub union FloatBits {\n+    float: f32,\n+    bits: u32,\n+}\n+\n+#[repr(transparent)]\n+pub struct SmallUnion(FloatBits);\n+\n+// NB: closing parenthesis is missing because sometimes the argument has a name and sometimes not\n+// CHECK: define i32 @test_SmallUnion(i32\n+#[no_mangle]\n+#[cfg(all(target_arch=\"x86_64\", target_os=\"linux\"))]\n+pub extern fn test_SmallUnion(_: SmallUnion) -> SmallUnion { loop {} }\n+\n+#[cfg(not(all(target_arch=\"x86_64\", target_os=\"linux\")))]\n+#[no_mangle]\n+pub extern fn test_SmallUnion(_: u32) -> u32 { loop {} }"}, {"sha": "c22239dee0a80868c82144338eb9d6dd817ba3ee", "filename": "src/test/compile-fail/lint-ctypes.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-ctypes.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -9,10 +9,12 @@\n // except according to those terms.\n \n #![deny(improper_ctypes)]\n-#![feature(libc, i128_type)]\n+#![feature(libc, i128_type, repr_transparent)]\n \n extern crate libc;\n \n+use std::marker::PhantomData;\n+\n trait Mirror { type It: ?Sized; }\n impl<T: ?Sized> Mirror for T { type It = Self; }\n #[repr(C)]\n@@ -28,6 +30,22 @@ pub type RustFn = fn();\n pub type RustBadRet = extern fn() -> Box<u32>;\n pub type CVoidRet = ();\n pub struct Foo;\n+#[repr(transparent)]\n+pub struct TransparentI128(i128);\n+#[repr(transparent)]\n+pub struct TransparentStr(&'static str);\n+#[repr(transparent)]\n+pub struct TransparentBadFn(RustBadRet);\n+#[repr(transparent)]\n+pub struct TransparentInt(u32);\n+#[repr(transparent)]\n+pub struct TransparentRef<'a>(&'a TransparentInt);\n+#[repr(transparent)]\n+pub struct TransparentLifetime<'a>(*const u8, PhantomData<&'a ()>);\n+#[repr(transparent)]\n+pub struct TransparentUnit<U>(f32, PhantomData<U>);\n+#[repr(transparent)]\n+pub struct TransparentCustomZst(i32, ZeroSize);\n \n #[repr(C)]\n pub struct ZeroSizeWithPhantomData(::std::marker::PhantomData<i32>);\n@@ -51,6 +69,9 @@ extern {\n     pub fn fn_type(p: RustFn); //~ ERROR found function pointer with Rust\n     pub fn fn_type2(p: fn()); //~ ERROR found function pointer with Rust\n     pub fn fn_contained(p: RustBadRet); //~ ERROR: found struct without\n+    pub fn transparent_i128(p: TransparentI128); //~ ERROR: found Rust type `i128`\n+    pub fn transparent_str(p: TransparentStr); //~ ERROR: found Rust type `str`\n+    pub fn transparent_fn(p: TransparentBadFn); //~ ERROR: found struct without\n \n     pub fn good3(fptr: Option<extern fn()>);\n     pub fn good4(aptr: &[u8; 4 as usize]);\n@@ -62,6 +83,11 @@ extern {\n     pub fn good10() -> CVoidRet;\n     pub fn good11(size: isize);\n     pub fn good12(size: usize);\n+    pub fn good13(n: TransparentInt);\n+    pub fn good14(p: TransparentRef);\n+    pub fn good15(p: TransparentLifetime);\n+    pub fn good16(p: TransparentUnit<ZeroSize>);\n+    pub fn good17(p: TransparentCustomZst);\n }\n \n #[cfg(not(target_arch = \"wasm32\"))]"}, {"sha": "cf0870866c76df43d584ae634935e6071a75ded2", "filename": "src/test/compile-fail/repr-transparent-other-items.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcompile-fail%2Frepr-transparent-other-items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcompile-fail%2Frepr-transparent-other-items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepr-transparent-other-items.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_transparent)]\n+\n+// See also repr-transparent.rs\n+\n+#[repr(transparent)] //~ ERROR unsupported representation for zero-variant enum\n+enum Void {}         //~| ERROR should be applied to struct\n+\n+#[repr(transparent)] //~ ERROR should be applied to struct\n+enum FieldlessEnum {\n+    Foo,\n+    Bar,\n+}\n+\n+#[repr(transparent)] //~ ERROR should be applied to struct\n+enum Enum {\n+    Foo(String),\n+    Bar(u32),\n+}\n+\n+#[repr(transparent)] //~ ERROR should be applied to struct\n+union Foo {\n+    u: u32,\n+    s: i32\n+}\n+\n+#[repr(transparent)] //~ ERROR should be applied to struct\n+fn cant_repr_this() {}\n+\n+#[repr(transparent)] //~ ERROR should be applied to struct\n+static CANT_REPR_THIS: u32 = 0;"}, {"sha": "7b91a6f68e3d54a705e966c171b533dd4c540977", "filename": "src/test/compile-fail/repr-transparent-other-reprs.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcompile-fail%2Frepr-transparent-other-reprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcompile-fail%2Frepr-transparent-other-reprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepr-transparent-other-reprs.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(repr_transparent, repr_align, attr_literals)]\n+\n+// See also repr-transparent.rs\n+\n+#[repr(transparent, C)] //~ ERROR cannot have other repr\n+struct TransparentPlusC {\n+    ptr: *const u8\n+}\n+\n+#[repr(transparent, packed)] //~ ERROR cannot have other repr\n+struct TransparentPlusPacked(*const u8);\n+\n+#[repr(transparent, align(2))] //~ ERROR cannot have other repr\n+struct TransparentPlusAlign(u8);\n+\n+#[repr(transparent)] //~ ERROR cannot have other repr\n+#[repr(C)]\n+struct SeparateAttributes(*mut u8);"}, {"sha": "b5e6a0fa0b13796a5842f5699967dc036053c6f5", "filename": "src/test/compile-fail/repr-transparent.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcompile-fail%2Frepr-transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fcompile-fail%2Frepr-transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frepr-transparent.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This file tests repr(transparent)-related errors reported during typeck. Other errors\n+// that are reported earlier and therefore preempt these are tested in:\n+// - repr-transparent-other-reprs.rs\n+// - repr-transparent-other-items.rs\n+\n+#![feature(repr_align, attr_literals)]\n+#![feature(repr_transparent)]\n+\n+use std::marker::PhantomData;\n+\n+#[repr(transparent)]\n+struct NoFields; //~ ERROR needs exactly one non-zero-sized field\n+\n+#[repr(transparent)]\n+struct ContainsOnlyZst(()); //~ ERROR needs exactly one non-zero-sized field\n+\n+#[repr(transparent)]\n+struct ContainsOnlyZstArray([bool; 0]); //~ ERROR needs exactly one non-zero-sized field\n+\n+#[repr(transparent)]\n+struct ContainsMultipleZst(PhantomData<*const i32>, NoFields);\n+//~^ ERROR needs exactly one non-zero-sized field\n+\n+#[repr(transparent)]\n+struct MultipleNonZst(u8, u8); //~ ERROR needs exactly one non-zero-sized field\n+\n+trait Mirror { type It: ?Sized; }\n+impl<T: ?Sized> Mirror for T { type It = Self; }\n+\n+#[repr(transparent)]\n+pub struct StructWithProjection(f32, <f32 as Mirror>::It);\n+//~^ ERROR needs exactly one non-zero-sized field\n+\n+#[repr(transparent)]\n+struct NontrivialAlignZst(u32, [u16; 0]); //~ ERROR alignment larger than 1\n+\n+#[repr(align(32))]\n+struct ZstAlign32<T>(PhantomData<T>);\n+\n+#[repr(transparent)]\n+struct GenericAlign<T>(ZstAlign32<T>, u32); //~ ERROR alignment larger than 1"}, {"sha": "deadf2e535d05a84cbc637421b595d72a731e4fc", "filename": "src/test/ui/feature-gate-repr_transparent.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fui%2Ffeature-gate-repr_transparent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fui%2Ffeature-gate-repr_transparent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-repr_transparent.rs?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(transparent)] //~ error: the `#[repr(transparent)]` attribute is experimental\n+struct Foo(u64);\n+\n+fn main() {}"}, {"sha": "d1292e95491ab356467c5aa6d00887f20d93e4f9", "filename": "src/test/ui/feature-gate-repr_transparent.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fui%2Ffeature-gate-repr_transparent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b887317da6ba0f70b34c0439ade8508e1b525fb0/src%2Ftest%2Fui%2Ffeature-gate-repr_transparent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate-repr_transparent.stderr?ref=b887317da6ba0f70b34c0439ade8508e1b525fb0", "patch": "@@ -0,0 +1,10 @@\n+error[E0658]: the `#[repr(transparent)]` attribute is experimental (see issue #43036)\n+  --> $DIR/feature-gate-repr_transparent.rs:11:1\n+   |\n+11 | #[repr(transparent)] //~ error: the `#[repr(transparent)]` attribute is experimental\n+   | ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: add #![feature(repr_transparent)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+"}]}