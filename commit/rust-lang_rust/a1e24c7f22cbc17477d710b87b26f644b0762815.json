{"sha": "a1e24c7f22cbc17477d710b87b26f644b0762815", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZTI0YzdmMjJjYmMxNzQ3N2Q3MTBiODdiMjZmNjQ0YjA3NjI4MTU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-14T08:44:03Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-03-17T07:53:07Z"}, "message": "De-@ typeck::check::method.", "tree": {"sha": "8ce94fd74ae410c17946c26f1521b680bc9cf176", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8ce94fd74ae410c17946c26f1521b680bc9cf176"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1e24c7f22cbc17477d710b87b26f644b0762815", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e24c7f22cbc17477d710b87b26f644b0762815", "html_url": "https://github.com/rust-lang/rust/commit/a1e24c7f22cbc17477d710b87b26f644b0762815", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1e24c7f22cbc17477d710b87b26f644b0762815/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da842c6278d3e8ec068d4cc2b4c93c2e292f8e4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/da842c6278d3e8ec068d4cc2b4c93c2e292f8e4b", "html_url": "https://github.com/rust-lang/rust/commit/da842c6278d3e8ec068d4cc2b4c93c2e292f8e4b"}], "stats": {"total": 290, "additions": 138, "deletions": 152}, "files": [{"sha": "5d232b488a6a70f46ec15a8bbd1907ba37af8fba", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 138, "deletions": 152, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/a1e24c7f22cbc17477d710b87b26f644b0762815/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1e24c7f22cbc17477d710b87b26f644b0762815/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=a1e24c7f22cbc17477d710b87b26f644b0762815", "patch": "@@ -95,7 +95,6 @@ use middle::typeck::check::regionmanip::replace_late_bound_regions_in_fn_sig;\n use util::common::indenter;\n use util::ppaux::Repr;\n \n-use std::cell::RefCell;\n use collections::HashSet;\n use std::result;\n use std::vec_ng::Vec;\n@@ -132,15 +131,15 @@ pub fn lookup<'a>(\n         check_traits: CheckTraitsFlag,      // Whether we check traits only.\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<MethodCallee> {\n-    let lcx = LookupContext {\n+    let mut lcx = LookupContext {\n         fcx: fcx,\n         span: expr.span,\n         self_expr: Some(self_expr),\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n-        impl_dups: @RefCell::new(HashSet::new()),\n-        inherent_candidates: @RefCell::new(Vec::new()),\n-        extension_candidates: @RefCell::new(Vec::new()),\n+        impl_dups: HashSet::new(),\n+        inherent_candidates: Vec::new(),\n+        extension_candidates: Vec::new(),\n         deref_args: deref_args,\n         check_traits: check_traits,\n         autoderef_receiver: autoderef_receiver,\n@@ -161,7 +160,7 @@ pub fn lookup<'a>(\n     lcx.reset_candidates();\n     lcx.push_bound_candidates(self_ty, None);\n     lcx.push_extension_candidates(expr.id);\n-    return lcx.search(self_ty);\n+    lcx.search(self_ty)\n }\n \n pub fn lookup_in_trait<'a>(\n@@ -176,15 +175,15 @@ pub fn lookup_in_trait<'a>(\n         supplied_tps: &'a [ty::t],          // The list of types X, Y, ... .\n         autoderef_receiver: AutoderefReceiverFlag)\n      -> Option<MethodCallee> {\n-    let lcx = LookupContext {\n+    let mut lcx = LookupContext {\n         fcx: fcx,\n         span: span,\n         self_expr: self_expr,\n         m_name: m_name,\n         supplied_tps: supplied_tps,\n-        impl_dups: @RefCell::new(HashSet::new()),\n-        inherent_candidates: @RefCell::new(Vec::new()),\n-        extension_candidates: @RefCell::new(Vec::new()),\n+        impl_dups: HashSet::new(),\n+        inherent_candidates: Vec::new(),\n+        extension_candidates: Vec::new(),\n         deref_args: check::DoDerefArgs,\n         check_traits: CheckTraitsOnly,\n         autoderef_receiver: autoderef_receiver,\n@@ -198,6 +197,91 @@ pub fn lookup_in_trait<'a>(\n     lcx.search(self_ty)\n }\n \n+\n+\n+// Determine the index of a method in the list of all methods belonging\n+// to a trait and its supertraits.\n+fn get_method_index(tcx: &ty::ctxt,\n+                    trait_ref: &TraitRef,\n+                    subtrait: @TraitRef,\n+                    n_method: uint) -> uint {\n+    // We need to figure the \"real index\" of the method in a\n+    // listing of all the methods of an object. We do this by\n+    // iterating down the supertraits of the object's trait until\n+    // we find the trait the method came from, counting up the\n+    // methods from them.\n+    let mut method_count = 0;\n+    ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n+        if bound_ref.def_id == trait_ref.def_id { false }\n+            else {\n+            method_count += ty::trait_methods(tcx, bound_ref.def_id).len();\n+            true\n+        }\n+    });\n+    method_count + n_method\n+}\n+\n+fn construct_transformed_self_ty_for_object(\n+    tcx: &ty::ctxt,\n+    span: Span,\n+    trait_def_id: ast::DefId,\n+    rcvr_substs: &ty::substs,\n+    method_ty: &ty::Method)\n+    -> ty::t {\n+    /*!\n+        * This is a bit tricky. We have a match against a trait method\n+        * being invoked on an object, and we want to generate the\n+        * self-type. As an example, consider a trait\n+        *\n+        *     trait Foo {\n+        *         fn r_method<'a>(&'a self);\n+        *         fn u_method(~self);\n+        *     }\n+        *\n+        * Now, assuming that `r_method` is being called, we want the\n+        * result to be `&'a Foo`. Assuming that `u_method` is being\n+        * called, we want the result to be `~Foo`. Of course,\n+        * this transformation has already been done as part of\n+        * `method_ty.fty.sig.inputs[0]`, but there the type\n+        * is expressed in terms of `Self` (i.e., `&'a Self`, `~Self`).\n+        * Because objects are not standalone types, we can't just substitute\n+        * `s/Self/Foo/`, so we must instead perform this kind of hokey\n+        * match below.\n+        */\n+\n+    let substs = ty::substs {regions: rcvr_substs.regions.clone(),\n+                                self_ty: None,\n+                                tps: rcvr_substs.tps.clone()};\n+    match method_ty.explicit_self {\n+        ast::SelfStatic => {\n+            tcx.sess.span_bug(span, \"static method for object type receiver\");\n+        }\n+        ast::SelfValue => {\n+            ty::mk_err() // error reported in `enforce_object_limitations()`\n+        }\n+        ast::SelfRegion(..) | ast::SelfUniq => {\n+            let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n+            match ty::get(transformed_self_ty).sty {\n+                ty::ty_rptr(r, mt) => { // must be SelfRegion\n+                    ty::mk_trait(tcx, trait_def_id, substs,\n+                                 RegionTraitStore(r), mt.mutbl,\n+                                 ty::EmptyBuiltinBounds())\n+                }\n+                ty::ty_uniq(_) => { // must be SelfUniq\n+                    ty::mk_trait(tcx, trait_def_id, substs,\n+                                 UniqTraitStore, ast::MutImmutable,\n+                                 ty::EmptyBuiltinBounds())\n+                }\n+                _ => {\n+                    tcx.sess.span_bug(span,\n+                        format!(\"'impossible' transformed_self_ty: {}\",\n+                                transformed_self_ty.repr(tcx)));\n+                }\n+            }\n+        }\n+    }\n+}\n+\n struct LookupContext<'a> {\n     fcx: &'a FnCtxt<'a>,\n     span: Span,\n@@ -210,9 +294,9 @@ struct LookupContext<'a> {\n \n     m_name: ast::Name,\n     supplied_tps: &'a [ty::t],\n-    impl_dups: @RefCell<HashSet<DefId>>,\n-    inherent_candidates: @RefCell<Vec<Candidate> >,\n-    extension_candidates: @RefCell<Vec<Candidate> >,\n+    impl_dups: HashSet<DefId>,\n+    inherent_candidates: Vec<Candidate>,\n+    extension_candidates: Vec<Candidate>,\n     deref_args: check::DerefArgs,\n     check_traits: CheckTraitsFlag,\n     autoderef_receiver: AutoderefReceiverFlag,\n@@ -315,12 +399,12 @@ impl<'a> LookupContext<'a> {\n     // ______________________________________________________________________\n     // Candidate collection (see comment at start of file)\n \n-    fn reset_candidates(&self) {\n-        self.inherent_candidates.set(Vec::new());\n-        self.extension_candidates.set(Vec::new());\n+    fn reset_candidates(&mut self) {\n+        self.inherent_candidates = Vec::new();\n+        self.extension_candidates = Vec::new();\n     }\n \n-    fn push_inherent_candidates(&self, self_ty: ty::t) {\n+    fn push_inherent_candidates(&mut self, self_ty: ty::t) {\n         /*!\n          * Collect all inherent candidates into\n          * `self.inherent_candidates`.  See comment at the start of\n@@ -354,7 +438,7 @@ impl<'a> LookupContext<'a> {\n         });\n     }\n \n-    fn push_bound_candidates(&self, self_ty: ty::t, restrict_to: Option<DefId>) {\n+    fn push_bound_candidates(&mut self, self_ty: ty::t, restrict_to: Option<DefId>) {\n         let span = self.self_expr.map_or(self.span, |e| e.span);\n         check::autoderef(self.fcx, span, self_ty, None, PreferMutLvalue, |self_ty, _| {\n             match get(self_ty).sty {\n@@ -378,20 +462,18 @@ impl<'a> LookupContext<'a> {\n         });\n     }\n \n-    fn push_extension_candidate(&self, trait_did: DefId) {\n+    fn push_extension_candidate(&mut self, trait_did: DefId) {\n         ty::populate_implementations_for_trait_if_necessary(self.tcx(), trait_did);\n \n         // Look for explicit implementations.\n-        let trait_impls = self.tcx().trait_impls.borrow();\n-        for impl_infos in trait_impls.get().find(&trait_did).iter() {\n+        for impl_infos in self.tcx().trait_impls.borrow().get().find(&trait_did).iter() {\n             for impl_info in impl_infos.borrow().get().iter() {\n-                self.push_candidates_from_impl(\n-                    self.extension_candidates.borrow_mut().get(), *impl_info);\n+                self.push_candidates_from_impl(*impl_info, true);\n             }\n         }\n     }\n \n-    fn push_extension_candidates(&self, expr_id: ast::NodeId) {\n+    fn push_extension_candidates(&mut self, expr_id: ast::NodeId) {\n         // If the method being called is associated with a trait, then\n         // find all the impls of that trait.  Each of those are\n         // candidates.\n@@ -403,38 +485,15 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    // Determine the index of a method in the list of all methods belonging\n-    // to a trait and its supertraits.\n-    fn get_method_index(&self,\n-                        trait_ref: @TraitRef,\n-                        subtrait: @TraitRef,\n-                        n_method: uint) -> uint {\n-        let tcx = self.tcx();\n-\n-        // We need to figure the \"real index\" of the method in a\n-        // listing of all the methods of an object. We do this by\n-        // iterating down the supertraits of the object's trait until\n-        // we find the trait the method came from, counting up the\n-        // methods from them.\n-        let mut method_count = 0;\n-        ty::each_bound_trait_and_supertraits(tcx, &[subtrait], |bound_ref| {\n-            if bound_ref.def_id == trait_ref.def_id { false }\n-                else {\n-                method_count += ty::trait_methods(tcx, bound_ref.def_id).len();\n-                true\n-            }\n-        });\n-        return method_count + n_method;\n-    }\n-\n-\n-    fn push_inherent_candidates_from_object(&self,\n+    fn push_inherent_candidates_from_object(&mut self,\n                                             did: DefId,\n                                             substs: &ty::substs) {\n         debug!(\"push_inherent_candidates_from_object(did={}, substs={})\",\n                self.did_to_str(did),\n                substs.repr(self.tcx()));\n         let _indenter = indenter();\n+        let tcx = self.tcx();\n+        let span = self.span;\n \n         // It is illegal to invoke a method on a trait instance that\n         // refers to the `self` type. An error will be reported by\n@@ -452,13 +511,13 @@ impl<'a> LookupContext<'a> {\n \n         self.push_inherent_candidates_from_bounds_inner(&[trait_ref],\n             |new_trait_ref, m, method_num, _bound_num| {\n-            let vtable_index =\n-                self.get_method_index(new_trait_ref, trait_ref, method_num);\n+            let vtable_index = get_method_index(tcx, new_trait_ref,\n+                                                trait_ref, method_num);\n             let mut m = (*m).clone();\n             // We need to fix up the transformed self type.\n             *m.fty.sig.inputs.get_mut(0) =\n-                self.construct_transformed_self_ty_for_object(\n-                    did, &rcvr_substs, &m);\n+                construct_transformed_self_ty_for_object(\n+                    tcx, span, did, &rcvr_substs, &m);\n \n             Some(Candidate {\n                 rcvr_match_condition: RcvrMatchesIfObject(did),\n@@ -474,7 +533,7 @@ impl<'a> LookupContext<'a> {\n         });\n     }\n \n-    fn push_inherent_candidates_from_param(&self,\n+    fn push_inherent_candidates_from_param(&mut self,\n                                            rcvr_ty: ty::t,\n                                            restrict_to: Option<DefId>,\n                                            param_ty: param_ty) {\n@@ -494,7 +553,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n \n-    fn push_inherent_candidates_from_self(&self,\n+    fn push_inherent_candidates_from_self(&mut self,\n                                           rcvr_ty: ty::t,\n                                           restrict_to: Option<DefId>) {\n         debug!(\"push_inherent_candidates_from_self()\");\n@@ -505,7 +564,7 @@ impl<'a> LookupContext<'a> {\n             param_self)\n     }\n \n-    fn push_inherent_candidates_from_bounds(&self,\n+    fn push_inherent_candidates_from_bounds(&mut self,\n                                             self_ty: ty::t,\n                                             bounds: &[@TraitRef],\n                                             restrict_to: Option<DefId>,\n@@ -536,7 +595,7 @@ impl<'a> LookupContext<'a> {\n \n     // Do a search through a list of bounds, using a callback to actually\n     // create the candidates.\n-    fn push_inherent_candidates_from_bounds_inner(&self,\n+    fn push_inherent_candidates_from_bounds_inner(&mut self,\n                                                   bounds: &[@TraitRef],\n                                                   mk_cand: |tr: @TraitRef,\n                                                             m: @ty::Method,\n@@ -561,7 +620,7 @@ impl<'a> LookupContext<'a> {\n                         Some(cand) => {\n                             debug!(\"pushing inherent candidate for param: {}\",\n                                    cand.repr(self.tcx()));\n-                            self.inherent_candidates.borrow_mut().get().push(cand);\n+                            self.inherent_candidates.push(cand);\n                         }\n                         None => {}\n                     }\n@@ -577,32 +636,23 @@ impl<'a> LookupContext<'a> {\n     }\n \n \n-    fn push_inherent_impl_candidates_for_type(&self, did: DefId) {\n+    fn push_inherent_impl_candidates_for_type(&mut self, did: DefId) {\n         // Read the inherent implementation candidates for this type from the\n         // metadata if necessary.\n         ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n \n-        let inherent_impls = self.tcx().inherent_impls.borrow();\n-        let opt_impl_infos = inherent_impls.get().find(&did);\n-        for impl_infos in opt_impl_infos.iter() {\n-            let impl_infos = impl_infos.borrow();\n-            for impl_info in impl_infos.get().iter() {\n-                let mut inherent_candidates = self.inherent_candidates\n-                                                  .borrow_mut();\n-                self.push_candidates_from_impl(inherent_candidates.get(),\n-                                               *impl_info);\n+        for impl_infos in self.tcx().inherent_impls.borrow().get().find(&did).iter() {\n+            for impl_info in impl_infos.borrow().get().iter() {\n+                self.push_candidates_from_impl(*impl_info, false);\n             }\n         }\n     }\n \n-    fn push_candidates_from_impl(&self,\n-                                 candidates: &mut Vec<Candidate>,\n-                                 impl_info: &ty::Impl) {\n-        {\n-            let mut impl_dups = self.impl_dups.borrow_mut();\n-            if !impl_dups.get().insert(impl_info.did) {\n-                return; // already visited\n-            }\n+    fn push_candidates_from_impl(&mut self,\n+                                 impl_info: &ty::Impl,\n+                                 is_extension: bool) {\n+        if !self.impl_dups.insert(impl_info.did) {\n+            return; // already visited\n         }\n \n         debug!(\"push_candidates_from_impl: {} {} {}\",\n@@ -631,6 +681,12 @@ impl<'a> LookupContext<'a> {\n             ty: impl_ty\n         } = impl_self_ty(&vcx, span, impl_info.did);\n \n+        let candidates = if is_extension {\n+            &mut self.extension_candidates\n+        } else {\n+            &mut self.inherent_candidates\n+        };\n+\n         candidates.push(Candidate {\n             rcvr_match_condition: RcvrMatchesIfSubtype(impl_ty),\n             rcvr_substs: impl_substs,\n@@ -913,28 +969,19 @@ impl<'a> LookupContext<'a> {\n         // existing code.\n \n         debug!(\"searching inherent candidates\");\n-        let mut inherent_candidates = self.inherent_candidates.borrow_mut();\n-        match self.consider_candidates(rcvr_ty, inherent_candidates.get()) {\n+        match self.consider_candidates(rcvr_ty, self.inherent_candidates.as_slice()) {\n             None => {}\n             Some(mme) => {\n                 return Some(mme);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        let mut extension_candidates = self.extension_candidates.borrow_mut();\n-        match self.consider_candidates(rcvr_ty, extension_candidates.get()) {\n-            None => {\n-                return None;\n-            }\n-            Some(mme) => {\n-                return Some(mme);\n-            }\n-        }\n+        self.consider_candidates(rcvr_ty, self.extension_candidates.as_slice())\n     }\n \n     fn consider_candidates(&self, rcvr_ty: ty::t,\n-                           candidates: &mut Vec<Candidate>)\n+                           candidates: &[Candidate])\n                            -> Option<MethodCallee> {\n         // FIXME(pcwalton): Do we need to clone here?\n         let relevant_candidates: Vec<Candidate> =\n@@ -1140,66 +1187,6 @@ impl<'a> LookupContext<'a> {\n         }\n     }\n \n-    fn construct_transformed_self_ty_for_object(\n-        &self,\n-        trait_def_id: ast::DefId,\n-        rcvr_substs: &ty::substs,\n-        method_ty: &ty::Method)\n-        -> ty::t {\n-        /*!\n-         * This is a bit tricky. We have a match against a trait method\n-         * being invoked on an object, and we want to generate the\n-         * self-type. As an example, consider a trait\n-         *\n-         *     trait Foo {\n-         *         fn r_method<'a>(&'a self);\n-         *         fn u_method(~self);\n-         *     }\n-         *\n-         * Now, assuming that `r_method` is being called, we want the\n-         * result to be `&'a Foo`. Assuming that `u_method` is being\n-         * called, we want the result to be `~Foo`. Of course,\n-         * this transformation has already been done as part of\n-         * `method_ty.fty.sig.inputs[0]`, but there the type\n-         * is expressed in terms of `Self` (i.e., `&'a Self`, `~Self`).\n-         * Because objects are not standalone types, we can't just substitute\n-         * `s/Self/Foo/`, so we must instead perform this kind of hokey\n-         * match below.\n-         */\n-\n-        let substs = ty::substs {regions: rcvr_substs.regions.clone(),\n-                                 self_ty: None,\n-                                 tps: rcvr_substs.tps.clone()};\n-        match method_ty.explicit_self {\n-            ast::SelfStatic => {\n-                self.bug(\"static method for object type receiver\");\n-            }\n-            ast::SelfValue => {\n-                ty::mk_err() // error reported in `enforce_object_limitations()`\n-            }\n-            ast::SelfRegion(..) | ast::SelfUniq => {\n-                let transformed_self_ty = *method_ty.fty.sig.inputs.get(0);\n-                match ty::get(transformed_self_ty).sty {\n-                    ty::ty_rptr(r, mt) => { // must be SelfRegion\n-                        ty::mk_trait(self.tcx(), trait_def_id,\n-                                     substs, RegionTraitStore(r), mt.mutbl,\n-                                     ty::EmptyBuiltinBounds())\n-                    }\n-                    ty::ty_uniq(_) => { // must be SelfUniq\n-                        ty::mk_trait(self.tcx(), trait_def_id,\n-                                     substs, UniqTraitStore, ast::MutImmutable,\n-                                     ty::EmptyBuiltinBounds())\n-                    }\n-                    _ => {\n-                        self.bug(\n-                            format!(\"'impossible' transformed_self_ty: {}\",\n-                                 transformed_self_ty.repr(self.tcx())));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn enforce_object_limitations(&self, candidate: &Candidate) {\n         /*!\n          * There are some limitations to calling functions through an\n@@ -1426,7 +1413,7 @@ impl<'a> LookupContext<'a> {\n         &self.fcx.inh.infcx\n     }\n \n-    fn tcx(&'a self) -> &'a ty::ctxt {\n+    fn tcx(&self) -> &'a ty::ctxt {\n         self.fcx.tcx()\n     }\n \n@@ -1439,8 +1426,7 @@ impl<'a> LookupContext<'a> {\n     }\n \n     fn bug(&self, s: &str) -> ! {\n-        let span = self.self_expr.map_or(self.span, |e| e.span);\n-        self.tcx().sess.span_bug(span, s)\n+        self.tcx().sess.span_bug(self.span, s)\n     }\n }\n "}]}