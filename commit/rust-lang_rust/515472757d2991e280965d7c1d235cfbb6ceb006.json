{"sha": "515472757d2991e280965d7c1d235cfbb6ceb006", "node_id": "C_kwDOAAsO6NoAKDUxNTQ3Mjc1N2QyOTkxZTI4MDk2NWQ3YzFkMjM1Y2ZiYjZjZWIwMDY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-08T21:37:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-11-08T21:37:59Z"}, "message": "Auto merge of #90443 - camelid:rustdoc-subst, r=GuillaumeGomez\n\nMerge `DocContext.{ty,lt,ct}_substs` into one map\n\nIt should be impossible to have more than one entry with a particular\nkey across the three maps, so they should be one map. In addition to\nmaking it impossible for multiple entries to exist, this should improve\nmemory usage since now only one map is allocated on the stack and heap.\n\nr? `@GuillaumeGomez`", "tree": {"sha": "5f557dc1eb81b0cd54d4547582f3cfe46f768026", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f557dc1eb81b0cd54d4547582f3cfe46f768026"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/515472757d2991e280965d7c1d235cfbb6ceb006", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/515472757d2991e280965d7c1d235cfbb6ceb006", "html_url": "https://github.com/rust-lang/rust/commit/515472757d2991e280965d7c1d235cfbb6ceb006", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/515472757d2991e280965d7c1d235cfbb6ceb006/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "495322d776fd6f679cd8cd4ca02b8fa834da654b", "url": "https://api.github.com/repos/rust-lang/rust/commits/495322d776fd6f679cd8cd4ca02b8fa834da654b", "html_url": "https://github.com/rust-lang/rust/commit/495322d776fd6f679cd8cd4ca02b8fa834da654b"}, {"sha": "5a77f3006f0e15c35e905b6f4f08a33f7005c3d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a77f3006f0e15c35e905b6f4f08a33f7005c3d1", "html_url": "https://github.com/rust-lang/rust/commit/5a77f3006f0e15c35e905b6f4f08a33f7005c3d1"}], "stats": {"total": 250, "additions": 132, "deletions": 118}, "files": [{"sha": "3db0ef17fd81064aa52efd07d4a2ea656a4e3d1d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 95, "deletions": 93, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/515472757d2991e280965d7c1d235cfbb6ceb006/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515472757d2991e280965d7c1d235cfbb6ceb006/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=515472757d2991e280965d7c1d235cfbb6ceb006", "patch": "@@ -190,7 +190,7 @@ impl Clean<Lifetime> for hir::Lifetime {\n             | rl::Region::Free(_, node_id),\n         ) = def\n         {\n-            if let Some(lt) = cx.lt_substs.get(&node_id).cloned() {\n+            if let Some(lt) = cx.substs.get(&node_id).and_then(|p| p.as_lt()).cloned() {\n                 return lt;\n             }\n         }\n@@ -1120,7 +1120,6 @@ impl Clean<Item> for ty::AssocItem {\n }\n \n fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n-    use rustc_hir::GenericParamCount;\n     let hir::Ty { hir_id: _, span, ref kind } = *hir_ty;\n     let qpath = match kind {\n         hir::TyKind::Path(qpath) => qpath,\n@@ -1130,105 +1129,20 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     match qpath {\n         hir::QPath::Resolved(None, ref path) => {\n             if let Res::Def(DefKind::TyParam, did) = path.res {\n-                if let Some(new_ty) = cx.ty_substs.get(&did).cloned() {\n+                if let Some(new_ty) = cx.substs.get(&did).and_then(|p| p.as_ty()).cloned() {\n                     return new_ty;\n                 }\n                 if let Some(bounds) = cx.impl_trait_bounds.remove(&did.into()) {\n                     return ImplTrait(bounds);\n                 }\n             }\n \n-            let mut alias = None;\n-            if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n-                // Substitute private type aliases\n-                if let Some(def_id) = def_id.as_local() {\n-                    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n-                    if !cx.cache.access_levels.is_exported(def_id.to_def_id()) {\n-                        alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n-                    }\n-                }\n-            };\n-\n-            if let Some(&hir::ItemKind::TyAlias(ref ty, ref generics)) = alias {\n-                let provided_params = &path.segments.last().expect(\"segments were empty\");\n-                let mut ty_substs = FxHashMap::default();\n-                let mut lt_substs = FxHashMap::default();\n-                let mut ct_substs = FxHashMap::default();\n-                let generic_args = provided_params.args();\n-                {\n-                    let mut indices: GenericParamCount = Default::default();\n-                    for param in generics.params.iter() {\n-                        match param.kind {\n-                            hir::GenericParamKind::Lifetime { .. } => {\n-                                let mut j = 0;\n-                                let lifetime = generic_args.args.iter().find_map(|arg| match arg {\n-                                    hir::GenericArg::Lifetime(lt) => {\n-                                        if indices.lifetimes == j {\n-                                            return Some(lt);\n-                                        }\n-                                        j += 1;\n-                                        None\n-                                    }\n-                                    _ => None,\n-                                });\n-                                if let Some(lt) = lifetime.cloned() {\n-                                    let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                    let cleaned = if !lt.is_elided() {\n-                                        lt.clean(cx)\n-                                    } else {\n-                                        self::types::Lifetime::elided()\n-                                    };\n-                                    lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n-                                }\n-                                indices.lifetimes += 1;\n-                            }\n-                            hir::GenericParamKind::Type { ref default, .. } => {\n-                                let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                let mut j = 0;\n-                                let type_ = generic_args.args.iter().find_map(|arg| match arg {\n-                                    hir::GenericArg::Type(ty) => {\n-                                        if indices.types == j {\n-                                            return Some(ty);\n-                                        }\n-                                        j += 1;\n-                                        None\n-                                    }\n-                                    _ => None,\n-                                });\n-                                if let Some(ty) = type_ {\n-                                    ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n-                                } else if let Some(default) = *default {\n-                                    ty_substs\n-                                        .insert(ty_param_def_id.to_def_id(), default.clean(cx));\n-                                }\n-                                indices.types += 1;\n-                            }\n-                            hir::GenericParamKind::Const { .. } => {\n-                                let const_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                let mut j = 0;\n-                                let const_ = generic_args.args.iter().find_map(|arg| match arg {\n-                                    hir::GenericArg::Const(ct) => {\n-                                        if indices.consts == j {\n-                                            return Some(ct);\n-                                        }\n-                                        j += 1;\n-                                        None\n-                                    }\n-                                    _ => None,\n-                                });\n-                                if let Some(ct) = const_ {\n-                                    ct_substs.insert(const_param_def_id.to_def_id(), ct.clean(cx));\n-                                }\n-                                // FIXME(const_generics_defaults)\n-                                indices.consts += 1;\n-                            }\n-                        }\n-                    }\n-                }\n-                return cx.enter_alias(ty_substs, lt_substs, ct_substs, |cx| ty.clean(cx));\n+            if let Some(expanded) = maybe_expand_private_type_alias(cx, path) {\n+                expanded\n+            } else {\n+                let path = path.clean(cx);\n+                resolve_type(cx, path)\n             }\n-            let path = path.clean(cx);\n-            resolve_type(cx, path)\n         }\n         hir::QPath::Resolved(Some(ref qself), p) => {\n             // Try to normalize `<X as Y>::T` to a type\n@@ -1272,6 +1186,94 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     }\n }\n \n+fn maybe_expand_private_type_alias(cx: &mut DocContext<'_>, path: &hir::Path<'_>) -> Option<Type> {\n+    let Res::Def(DefKind::TyAlias, def_id) = path.res else { return None };\n+    // Substitute private type aliases\n+    let Some(def_id) = def_id.as_local() else { return None };\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n+    let alias = if !cx.cache.access_levels.is_exported(def_id.to_def_id()) {\n+        &cx.tcx.hir().expect_item(hir_id).kind\n+    } else {\n+        return None;\n+    };\n+    let hir::ItemKind::TyAlias(ty, generics) = alias else { return None };\n+\n+    let provided_params = &path.segments.last().expect(\"segments were empty\");\n+    let mut substs = FxHashMap::default();\n+    let generic_args = provided_params.args();\n+\n+    let mut indices: hir::GenericParamCount = Default::default();\n+    for param in generics.params.iter() {\n+        match param.kind {\n+            hir::GenericParamKind::Lifetime { .. } => {\n+                let mut j = 0;\n+                let lifetime = generic_args.args.iter().find_map(|arg| match arg {\n+                    hir::GenericArg::Lifetime(lt) => {\n+                        if indices.lifetimes == j {\n+                            return Some(lt);\n+                        }\n+                        j += 1;\n+                        None\n+                    }\n+                    _ => None,\n+                });\n+                if let Some(lt) = lifetime.cloned() {\n+                    let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                    let cleaned = if !lt.is_elided() {\n+                        lt.clean(cx)\n+                    } else {\n+                        self::types::Lifetime::elided()\n+                    };\n+                    substs.insert(lt_def_id.to_def_id(), SubstParam::Lifetime(cleaned));\n+                }\n+                indices.lifetimes += 1;\n+            }\n+            hir::GenericParamKind::Type { ref default, .. } => {\n+                let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                let mut j = 0;\n+                let type_ = generic_args.args.iter().find_map(|arg| match arg {\n+                    hir::GenericArg::Type(ty) => {\n+                        if indices.types == j {\n+                            return Some(ty);\n+                        }\n+                        j += 1;\n+                        None\n+                    }\n+                    _ => None,\n+                });\n+                if let Some(ty) = type_ {\n+                    substs.insert(ty_param_def_id.to_def_id(), SubstParam::Type(ty.clean(cx)));\n+                } else if let Some(default) = *default {\n+                    substs.insert(ty_param_def_id.to_def_id(), SubstParam::Type(default.clean(cx)));\n+                }\n+                indices.types += 1;\n+            }\n+            hir::GenericParamKind::Const { .. } => {\n+                let const_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                let mut j = 0;\n+                let const_ = generic_args.args.iter().find_map(|arg| match arg {\n+                    hir::GenericArg::Const(ct) => {\n+                        if indices.consts == j {\n+                            return Some(ct);\n+                        }\n+                        j += 1;\n+                        None\n+                    }\n+                    _ => None,\n+                });\n+                if let Some(ct) = const_ {\n+                    substs\n+                        .insert(const_param_def_id.to_def_id(), SubstParam::Constant(ct.clean(cx)));\n+                }\n+                // FIXME(const_generics_defaults)\n+                indices.consts += 1;\n+            }\n+        }\n+    }\n+\n+    Some(cx.enter_alias(substs, |cx| ty.clean(cx)))\n+}\n+\n impl Clean<Type> for hir::Ty<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n         use rustc_hir::*;"}, {"sha": "fd4d620c9591e12ab03359b7e5fe6c0177abd807", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/515472757d2991e280965d7c1d235cfbb6ceb006/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515472757d2991e280965d7c1d235cfbb6ceb006/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=515472757d2991e280965d7c1d235cfbb6ceb006", "patch": "@@ -2279,3 +2279,32 @@ impl TypeBinding {\n         }\n     }\n }\n+\n+/// The type, lifetime, or constant that a private type alias's parameter should be\n+/// replaced with when expanding a use of that type alias.\n+///\n+/// For example:\n+///\n+/// ```\n+/// type PrivAlias<T> = Vec<T>;\n+///\n+/// pub fn public_fn() -> PrivAlias<i32> { vec![] }\n+/// ```\n+///\n+/// `public_fn`'s docs will show it as returning `Vec<i32>`, since `PrivAlias` is private.\n+/// [`SubstParam`] is used to record that `T` should be mapped to `i32`.\n+crate enum SubstParam {\n+    Type(Type),\n+    Lifetime(Lifetime),\n+    Constant(Constant),\n+}\n+\n+impl SubstParam {\n+    crate fn as_ty(&self) -> Option<&Type> {\n+        if let Self::Type(ty) = self { Some(ty) } else { None }\n+    }\n+\n+    crate fn as_lt(&self) -> Option<&Lifetime> {\n+        if let Self::Lifetime(lt) = self { Some(lt) } else { None }\n+    }\n+}"}, {"sha": "7fa6484d238967d549cc69351ef1851877eebe46", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 25, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/515472757d2991e280965d7c1d235cfbb6ceb006/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515472757d2991e280965d7c1d235cfbb6ceb006/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=515472757d2991e280965d7c1d235cfbb6ceb006", "patch": "@@ -54,14 +54,10 @@ crate struct DocContext<'tcx> {\n     /// Used while populating `external_traits` to ensure we don't process the same trait twice at\n     /// the same time.\n     crate active_extern_traits: FxHashSet<DefId>,\n-    // The current set of type and lifetime substitutions,\n+    // The current set of parameter substitutions,\n     // for expanding type aliases at the HIR level:\n-    /// Table `DefId` of type parameter -> substituted type\n-    crate ty_substs: FxHashMap<DefId, clean::Type>,\n-    /// Table `DefId` of lifetime parameter -> substituted lifetime\n-    crate lt_substs: FxHashMap<DefId, clean::Lifetime>,\n-    /// Table `DefId` of const parameter -> substituted const\n-    crate ct_substs: FxHashMap<DefId, clean::Constant>,\n+    /// Table `DefId` of type, lifetime, or const parameter -> substituted type, lifetime, or const\n+    crate substs: FxHashMap<DefId, clean::SubstParam>,\n     /// Table synthetic type parameter for `impl Trait` in argument position -> bounds\n     crate impl_trait_bounds: FxHashMap<ImplTraitParam, Vec<clean::GenericBound>>,\n     /// Auto-trait or blanket impls processed so far, as `(self_ty, trait_def_id)`.\n@@ -104,25 +100,13 @@ impl<'tcx> DocContext<'tcx> {\n \n     /// Call the closure with the given parameters set as\n     /// the substitutions for a type alias' RHS.\n-    crate fn enter_alias<F, R>(\n-        &mut self,\n-        ty_substs: FxHashMap<DefId, clean::Type>,\n-        lt_substs: FxHashMap<DefId, clean::Lifetime>,\n-        ct_substs: FxHashMap<DefId, clean::Constant>,\n-        f: F,\n-    ) -> R\n+    crate fn enter_alias<F, R>(&mut self, substs: FxHashMap<DefId, clean::SubstParam>, f: F) -> R\n     where\n         F: FnOnce(&mut Self) -> R,\n     {\n-        let (old_tys, old_lts, old_cts) = (\n-            mem::replace(&mut self.ty_substs, ty_substs),\n-            mem::replace(&mut self.lt_substs, lt_substs),\n-            mem::replace(&mut self.ct_substs, ct_substs),\n-        );\n+        let old_substs = mem::replace(&mut self.substs, substs);\n         let r = f(self);\n-        self.ty_substs = old_tys;\n-        self.lt_substs = old_lts;\n-        self.ct_substs = old_cts;\n+        self.substs = old_substs;\n         r\n     }\n \n@@ -350,9 +334,7 @@ crate fn run_global_ctxt(\n         param_env: ParamEnv::empty(),\n         external_traits: Default::default(),\n         active_extern_traits: Default::default(),\n-        ty_substs: Default::default(),\n-        lt_substs: Default::default(),\n-        ct_substs: Default::default(),\n+        substs: Default::default(),\n         impl_trait_bounds: Default::default(),\n         generated_synthetics: Default::default(),\n         auto_traits: tcx"}, {"sha": "938a0c507a524978be95cab939e7eaac453dab90", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/515472757d2991e280965d7c1d235cfbb6ceb006/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/515472757d2991e280965d7c1d235cfbb6ceb006/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=515472757d2991e280965d7c1d235cfbb6ceb006", "patch": "@@ -9,6 +9,7 @@\n #![feature(control_flow_enum)]\n #![feature(box_syntax)]\n #![feature(in_band_lifetimes)]\n+#![feature(let_else)]\n #![feature(nll)]\n #![feature(test)]\n #![feature(crate_visibility_modifier)]"}]}