{"sha": "79c2c986a29faf7be042a5ab40975b9b8f1c2575", "node_id": "C_kwDOAAsO6NoAKDc5YzJjOTg2YTI5ZmFmN2JlMDQyYTVhYjQwOTc1YjliOGYxYzI1NzU", "commit": {"author": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-06-16T16:54:51Z"}, "committer": {"name": "Oli Scherer", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2023-06-16T19:39:48Z"}, "message": "Pacify tidy", "tree": {"sha": "15ccdf97562a61b572bfd226bbaec3ccf56f9705", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15ccdf97562a61b572bfd226bbaec3ccf56f9705"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79c2c986a29faf7be042a5ab40975b9b8f1c2575", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79c2c986a29faf7be042a5ab40975b9b8f1c2575", "html_url": "https://github.com/rust-lang/rust/commit/79c2c986a29faf7be042a5ab40975b9b8f1c2575", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79c2c986a29faf7be042a5ab40975b9b8f1c2575/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3b7dd6388503ef555f4dbf027d6075ee5c8b3ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/f3b7dd6388503ef555f4dbf027d6075ee5c8b3ee", "html_url": "https://github.com/rust-lang/rust/commit/f3b7dd6388503ef555f4dbf027d6075ee5c8b3ee"}], "stats": {"total": 244, "additions": 128, "deletions": 116}, "files": [{"sha": "05a3ab63d5cf3551b9a4e5173dd8c4bf7349d46b", "filename": "compiler/rustc_hir_analysis/src/astconv/lint.rs", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/79c2c986a29faf7be042a5ab40975b9b8f1c2575/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79c2c986a29faf7be042a5ab40975b9b8f1c2575/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Flint.rs?ref=79c2c986a29faf7be042a5ab40975b9b8f1c2575", "patch": "@@ -0,0 +1,124 @@\n+use rustc_ast::TraitObjectSyntax;\n+use rustc_errors::{Diagnostic, StashKey};\n+use rustc_hir as hir;\n+use rustc_lint_defs::{builtin::BARE_TRAIT_OBJECTS, Applicability};\n+use rustc_trait_selection::traits::error_reporting::suggestions::NextTypeParamName;\n+\n+use super::AstConv;\n+\n+impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n+    /// Make sure that we are in the condition to suggest the blanket implementation.\n+    pub(super) fn maybe_lint_blanket_trait_impl(\n+        &self,\n+        self_ty: &hir::Ty<'_>,\n+        diag: &mut Diagnostic,\n+    ) {\n+        let tcx = self.tcx();\n+        let parent_id = tcx.hir().get_parent_item(self_ty.hir_id).def_id;\n+        if let hir::Node::Item(hir::Item {\n+            kind:\n+                hir::ItemKind::Impl(hir::Impl {\n+                    self_ty: impl_self_ty, of_trait: Some(of_trait_ref), generics, ..\n+                }),\n+            ..\n+        }) = tcx.hir().get_by_def_id(parent_id) && self_ty.hir_id == impl_self_ty.hir_id\n+        {\n+            if !of_trait_ref.trait_def_id().is_some_and(|def_id| def_id.is_local()) {\n+                return;\n+            }\n+            let of_trait_span = of_trait_ref.path.span;\n+            // make sure that we are not calling unwrap to abort during the compilation\n+            let Ok(impl_trait_name) = tcx.sess.source_map().span_to_snippet(self_ty.span) else { return; };\n+            let Ok(of_trait_name) = tcx.sess.source_map().span_to_snippet(of_trait_span) else { return; };\n+            // check if the trait has generics, to make a correct suggestion\n+            let param_name = generics.params.next_type_param_name(None);\n+\n+            let add_generic_sugg = if let Some(span) = generics.span_for_param_suggestion() {\n+                (span, format!(\", {}: {}\", param_name, impl_trait_name))\n+            } else {\n+                (generics.span, format!(\"<{}: {}>\", param_name, impl_trait_name))\n+            };\n+            diag.multipart_suggestion(\n+            format!(\"alternatively use a blanket \\\n+                     implementation to implement `{of_trait_name}` for \\\n+                     all types that also implement `{impl_trait_name}`\"),\n+                vec![\n+                    (self_ty.span, param_name),\n+                    add_generic_sugg,\n+                ],\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+\n+    pub(super) fn maybe_lint_bare_trait(&self, self_ty: &hir::Ty<'_>, in_path: bool) {\n+        let tcx = self.tcx();\n+        if let hir::TyKind::TraitObject([poly_trait_ref, ..], _, TraitObjectSyntax::None) =\n+            self_ty.kind\n+        {\n+            let needs_bracket = in_path\n+                && !tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_prev_source(self_ty.span)\n+                    .ok()\n+                    .is_some_and(|s| s.trim_end().ends_with('<'));\n+\n+            let is_global = poly_trait_ref.trait_ref.path.is_global();\n+\n+            let mut sugg = Vec::from_iter([(\n+                self_ty.span.shrink_to_lo(),\n+                format!(\n+                    \"{}dyn {}\",\n+                    if needs_bracket { \"<\" } else { \"\" },\n+                    if is_global { \"(\" } else { \"\" },\n+                ),\n+            )]);\n+\n+            if is_global || needs_bracket {\n+                sugg.push((\n+                    self_ty.span.shrink_to_hi(),\n+                    format!(\n+                        \"{}{}\",\n+                        if is_global { \")\" } else { \"\" },\n+                        if needs_bracket { \">\" } else { \"\" },\n+                    ),\n+                ));\n+            }\n+\n+            if self_ty.span.edition().rust_2021() {\n+                let msg = \"trait objects must include the `dyn` keyword\";\n+                let label = \"add `dyn` keyword before this trait\";\n+                let mut diag =\n+                    rustc_errors::struct_span_err!(tcx.sess, self_ty.span, E0782, \"{}\", msg);\n+                if self_ty.span.can_be_used_for_suggestions() {\n+                    diag.multipart_suggestion_verbose(\n+                        label,\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                // check if the impl trait that we are considering is a impl of a local trait\n+                self.maybe_lint_blanket_trait_impl(&self_ty, &mut diag);\n+                diag.stash(self_ty.span, StashKey::TraitMissingMethod);\n+            } else {\n+                let msg = \"trait objects without an explicit `dyn` are deprecated\";\n+                tcx.struct_span_lint_hir(\n+                    BARE_TRAIT_OBJECTS,\n+                    self_ty.hir_id,\n+                    self_ty.span,\n+                    msg,\n+                    |lint| {\n+                        lint.multipart_suggestion_verbose(\n+                            \"use `dyn`\",\n+                            sugg,\n+                            Applicability::MachineApplicable,\n+                        );\n+                        self.maybe_lint_blanket_trait_impl(&self_ty, lint);\n+                        lint\n+                    },\n+                );\n+            }\n+        }\n+    }\n+}"}, {"sha": "221c7ce4f6ff8bc15316c831ba6643fdde4c8cb4", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 4, "deletions": 116, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/79c2c986a29faf7be042a5ab40975b9b8f1c2575/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79c2c986a29faf7be042a5ab40975b9b8f1c2575/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=79c2c986a29faf7be042a5ab40975b9b8f1c2575", "patch": "@@ -4,6 +4,7 @@\n \n mod errors;\n pub mod generics;\n+mod lint;\n \n use crate::astconv::errors::prohibit_assoc_ty_binding;\n use crate::astconv::generics::{check_generic_arg_count, create_substs_for_generic_args};\n@@ -19,7 +20,7 @@ use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n     struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed, FatalError,\n-    MultiSpan, StashKey,\n+    MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n@@ -33,14 +34,12 @@ use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::GenericParamDefKind;\n use rustc_middle::ty::{self, Const, IsSuggestable, Ty, TyCtxt, TypeVisitableExt};\n use rustc_middle::ty::{DynKind, ToPredicate};\n-use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n+use rustc_session::lint::builtin::AMBIGUOUS_ASSOCIATED_ITEMS;\n use rustc_span::edit_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n-use rustc_trait_selection::traits::error_reporting::{\n-    report_object_safety_error, suggestions::NextTypeParamName,\n-};\n+use rustc_trait_selection::traits::error_reporting::report_object_safety_error;\n use rustc_trait_selection::traits::wf::object_region_bounds;\n use rustc_trait_selection::traits::{\n     self, astconv_object_safety_violations, NormalizeExt, ObligationCtxt,\n@@ -3715,115 +3714,4 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n         Some(r)\n     }\n-\n-    /// Make sure that we are in the condition to suggest the blanket implementation.\n-    fn maybe_lint_blanket_trait_impl(&self, self_ty: &hir::Ty<'_>, diag: &mut Diagnostic) {\n-        let tcx = self.tcx();\n-        let parent_id = tcx.hir().get_parent_item(self_ty.hir_id).def_id;\n-        if let hir::Node::Item(hir::Item {\n-            kind:\n-                hir::ItemKind::Impl(hir::Impl {\n-                    self_ty: impl_self_ty, of_trait: Some(of_trait_ref), generics, ..\n-                }),\n-            ..\n-        }) = tcx.hir().get_by_def_id(parent_id) && self_ty.hir_id == impl_self_ty.hir_id\n-        {\n-            if !of_trait_ref.trait_def_id().is_some_and(|def_id| def_id.is_local()) {\n-                return;\n-            }\n-            let of_trait_span = of_trait_ref.path.span;\n-            // make sure that we are not calling unwrap to abort during the compilation\n-            let Ok(impl_trait_name) = tcx.sess.source_map().span_to_snippet(self_ty.span) else { return; };\n-            let Ok(of_trait_name) = tcx.sess.source_map().span_to_snippet(of_trait_span) else { return; };\n-            // check if the trait has generics, to make a correct suggestion\n-            let param_name = generics.params.next_type_param_name(None);\n-\n-            let add_generic_sugg = if let Some(span) = generics.span_for_param_suggestion() {\n-                (span, format!(\", {}: {}\", param_name, impl_trait_name))\n-            } else {\n-                (generics.span, format!(\"<{}: {}>\", param_name, impl_trait_name))\n-            };\n-            diag.multipart_suggestion(\n-            format!(\"alternatively use a blanket \\\n-                     implementation to implement `{of_trait_name}` for \\\n-                     all types that also implement `{impl_trait_name}`\"),\n-                vec![\n-                    (self_ty.span, param_name),\n-                    add_generic_sugg,\n-                ],\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-    }\n-\n-    fn maybe_lint_bare_trait(&self, self_ty: &hir::Ty<'_>, in_path: bool) {\n-        let tcx = self.tcx();\n-        if let hir::TyKind::TraitObject([poly_trait_ref, ..], _, TraitObjectSyntax::None) =\n-            self_ty.kind\n-        {\n-            let needs_bracket = in_path\n-                && !tcx\n-                    .sess\n-                    .source_map()\n-                    .span_to_prev_source(self_ty.span)\n-                    .ok()\n-                    .is_some_and(|s| s.trim_end().ends_with('<'));\n-\n-            let is_global = poly_trait_ref.trait_ref.path.is_global();\n-\n-            let mut sugg = Vec::from_iter([(\n-                self_ty.span.shrink_to_lo(),\n-                format!(\n-                    \"{}dyn {}\",\n-                    if needs_bracket { \"<\" } else { \"\" },\n-                    if is_global { \"(\" } else { \"\" },\n-                ),\n-            )]);\n-\n-            if is_global || needs_bracket {\n-                sugg.push((\n-                    self_ty.span.shrink_to_hi(),\n-                    format!(\n-                        \"{}{}\",\n-                        if is_global { \")\" } else { \"\" },\n-                        if needs_bracket { \">\" } else { \"\" },\n-                    ),\n-                ));\n-            }\n-\n-            if self_ty.span.edition().rust_2021() {\n-                let msg = \"trait objects must include the `dyn` keyword\";\n-                let label = \"add `dyn` keyword before this trait\";\n-                let mut diag =\n-                    rustc_errors::struct_span_err!(tcx.sess, self_ty.span, E0782, \"{}\", msg);\n-                if self_ty.span.can_be_used_for_suggestions() {\n-                    diag.multipart_suggestion_verbose(\n-                        label,\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-                // check if the impl trait that we are considering is a impl of a local trait\n-                self.maybe_lint_blanket_trait_impl(&self_ty, &mut diag);\n-                diag.stash(self_ty.span, StashKey::TraitMissingMethod);\n-            } else {\n-                let msg = \"trait objects without an explicit `dyn` are deprecated\";\n-                tcx.struct_span_lint_hir(\n-                    BARE_TRAIT_OBJECTS,\n-                    self_ty.hir_id,\n-                    self_ty.span,\n-                    msg,\n-                    |lint| {\n-                        lint.multipart_suggestion_verbose(\n-                            \"use `dyn`\",\n-                            sugg,\n-                            Applicability::MachineApplicable,\n-                        );\n-                        self.maybe_lint_blanket_trait_impl(&self_ty, lint);\n-                        lint\n-                    },\n-                );\n-            }\n-        }\n-    }\n }"}]}