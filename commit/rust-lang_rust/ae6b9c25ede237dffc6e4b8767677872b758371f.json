{"sha": "ae6b9c25ede237dffc6e4b8767677872b758371f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNmI5YzI1ZWRlMjM3ZGZmYzZlNGI4NzY3Njc3ODcyYjc1ODM3MWY=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-03T19:33:27Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-05-04T06:42:20Z"}, "message": "internal: remove one more usage of the rewriter", "tree": {"sha": "29583d70de437b6f1d96c1e831722076112042ee", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29583d70de437b6f1d96c1e831722076112042ee"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae6b9c25ede237dffc6e4b8767677872b758371f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae6b9c25ede237dffc6e4b8767677872b758371f", "html_url": "https://github.com/rust-lang/rust/commit/ae6b9c25ede237dffc6e4b8767677872b758371f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae6b9c25ede237dffc6e4b8767677872b758371f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2349366b57d49dad7293ecd91620835236f980e", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2349366b57d49dad7293ecd91620835236f980e", "html_url": "https://github.com/rust-lang/rust/commit/a2349366b57d49dad7293ecd91620835236f980e"}], "stats": {"total": 72, "additions": 49, "deletions": 23}, "files": [{"sha": "4b0bba2abceaefa0876e644cca2ecab1699b83b9", "filename": "crates/ide_assists/src/assist_context.rs", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ae6b9c25ede237dffc6e4b8767677872b758371f/crates%2Fide_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6b9c25ede237dffc6e4b8767677872b758371f/crates%2Fide_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fassist_context.rs?ref=ae6b9c25ede237dffc6e4b8767677872b758371f", "patch": "@@ -185,7 +185,29 @@ pub(crate) struct AssistBuilder {\n     source_change: SourceChange,\n \n     /// Maps the original, immutable `SyntaxNode` to a `clone_for_update` twin.\n-    mutated_tree: Option<(SyntaxNode, SyntaxNode)>,\n+    mutated_tree: Option<TreeMutator>,\n+}\n+\n+pub(crate) struct TreeMutator {\n+    immutable: SyntaxNode,\n+    mutable_clone: SyntaxNode,\n+}\n+\n+impl TreeMutator {\n+    pub(crate) fn new(immutable: &SyntaxNode) -> TreeMutator {\n+        let immutable = immutable.ancestors().last().unwrap();\n+        let mutable_clone = immutable.clone_for_update();\n+        TreeMutator { immutable, mutable_clone }\n+    }\n+\n+    pub(crate) fn make_mut<N: AstNode>(&self, node: &N) -> N {\n+        N::cast(self.make_syntax_mut(node.syntax())).unwrap()\n+    }\n+\n+    pub(crate) fn make_syntax_mut(&self, node: &SyntaxNode) -> SyntaxNode {\n+        let ptr = SyntaxNodePtr::new(node);\n+        ptr.to_node(&self.mutable_clone)\n+    }\n }\n \n impl AssistBuilder {\n@@ -204,8 +226,8 @@ impl AssistBuilder {\n     }\n \n     fn commit(&mut self) {\n-        if let Some((old, new)) = self.mutated_tree.take() {\n-            algo::diff(&old, &new).into_text_edit(&mut self.edit)\n+        if let Some(tm) = self.mutated_tree.take() {\n+            algo::diff(&tm.immutable, &tm.mutable_clone).into_text_edit(&mut self.edit)\n         }\n \n         let edit = mem::take(&mut self.edit).finish();\n@@ -228,16 +250,7 @@ impl AssistBuilder {\n     /// phase, and then get their mutable couterparts using `make_mut` in the\n     /// mutable state.\n     pub(crate) fn make_mut(&mut self, node: SyntaxNode) -> SyntaxNode {\n-        let root = &self\n-            .mutated_tree\n-            .get_or_insert_with(|| {\n-                let immutable = node.ancestors().last().unwrap();\n-                let mutable = immutable.clone_for_update();\n-                (immutable, mutable)\n-            })\n-            .1;\n-        let ptr = SyntaxNodePtr::new(&&node);\n-        ptr.to_node(root)\n+        self.mutated_tree.get_or_insert_with(|| TreeMutator::new(&node)).make_syntax_mut(&node)\n     }\n \n     /// Remove specified `range` of text."}, {"sha": "93b28370caec12bb093e4b91db7e964fbbdc8a72", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ae6b9c25ede237dffc6e4b8767677872b758371f/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae6b9c25ede237dffc6e4b8767677872b758371f/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=ae6b9c25ede237dffc6e4b8767677872b758371f", "patch": "@@ -16,12 +16,13 @@ use syntax::{\n         edit::{AstNodeEdit, IndentLevel},\n         AstNode,\n     },\n+    ted,\n     SyntaxKind::{self, BLOCK_EXPR, BREAK_EXPR, COMMENT, PATH_EXPR, RETURN_EXPR},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, TokenAtOffset, WalkEvent, T,\n };\n \n use crate::{\n-    assist_context::{AssistContext, Assists},\n+    assist_context::{AssistContext, Assists, TreeMutator},\n     AssistId,\n };\n \n@@ -1366,7 +1367,10 @@ fn rewrite_body_segment(\n \n /// change all usages to account for added `&`/`&mut` for some params\n fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode) -> SyntaxNode {\n-    let mut rewriter = SyntaxRewriter::default();\n+    let mut usages_for_param: Vec<(&Param, Vec<ast::Expr>)> = Vec::new();\n+\n+    let tm = TreeMutator::new(syntax);\n+\n     for param in params {\n         if !param.kind().is_ref() {\n             continue;\n@@ -1376,30 +1380,39 @@ fn fix_param_usages(ctx: &AssistContext, params: &[Param], syntax: &SyntaxNode)\n         let usages = usages\n             .iter()\n             .filter(|reference| syntax.text_range().contains_range(reference.range))\n-            .filter_map(|reference| path_element_of_reference(syntax, reference));\n-        for path in usages {\n-            match path.syntax().ancestors().skip(1).find_map(ast::Expr::cast) {\n+            .filter_map(|reference| path_element_of_reference(syntax, reference))\n+            .map(|expr| tm.make_mut(&expr));\n+\n+        usages_for_param.push((param, usages.collect()));\n+    }\n+\n+    let res = tm.make_syntax_mut(syntax);\n+\n+    for (param, usages) in usages_for_param {\n+        for usage in usages {\n+            match usage.syntax().ancestors().skip(1).find_map(ast::Expr::cast) {\n                 Some(ast::Expr::MethodCallExpr(_)) | Some(ast::Expr::FieldExpr(_)) => {\n                     // do nothing\n                 }\n                 Some(ast::Expr::RefExpr(node))\n                     if param.kind() == ParamKind::MutRef && node.mut_token().is_some() =>\n                 {\n-                    rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n+                    ted::replace(node.syntax(), node.expr().unwrap().syntax());\n                 }\n                 Some(ast::Expr::RefExpr(node))\n                     if param.kind() == ParamKind::SharedRef && node.mut_token().is_none() =>\n                 {\n-                    rewriter.replace_ast(&node.clone().into(), &node.expr().unwrap());\n+                    ted::replace(node.syntax(), node.expr().unwrap().syntax());\n                 }\n                 Some(_) | None => {\n-                    rewriter.replace_ast(&path, &make::expr_prefix(T![*], path.clone()));\n+                    let p = &make::expr_prefix(T![*], usage.clone()).clone_for_update();\n+                    ted::replace(usage.syntax(), p.syntax())\n                 }\n-            };\n+            }\n         }\n     }\n \n-    rewriter.rewrite(syntax)\n+    res\n }\n \n fn update_external_control_flow(handler: &FlowHandler, syntax: &SyntaxNode) -> SyntaxNode {"}]}