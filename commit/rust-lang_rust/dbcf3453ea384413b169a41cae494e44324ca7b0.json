{"sha": "dbcf3453ea384413b169a41cae494e44324ca7b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiY2YzNDUzZWEzODQ0MTNiMTY5YTQxY2FlNDk0ZTQ0MzI0Y2E3YjA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-10T00:35:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-10T00:35:38Z"}, "message": "Auto merge of #84015 - tdelabro:issue-76704-fix, r=Amanieu\n\ndoc asm feature - Added new 'Label' section with example and explanations\n\nFixes #76704", "tree": {"sha": "09895809c8238fed9443a1012ab3ccb4c578c4b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09895809c8238fed9443a1012ab3ccb4c578c4b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbcf3453ea384413b169a41cae494e44324ca7b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbcf3453ea384413b169a41cae494e44324ca7b0", "html_url": "https://github.com/rust-lang/rust/commit/dbcf3453ea384413b169a41cae494e44324ca7b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbcf3453ea384413b169a41cae494e44324ca7b0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dae9d6ac3e9a8fb389cfe471b30f4d72c3122196", "url": "https://api.github.com/repos/rust-lang/rust/commits/dae9d6ac3e9a8fb389cfe471b30f4d72c3122196", "html_url": "https://github.com/rust-lang/rust/commit/dae9d6ac3e9a8fb389cfe471b30f4d72c3122196"}, {"sha": "1f7de3fa983ef1153fcae10a67a1d6f1f9efdeb3", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f7de3fa983ef1153fcae10a67a1d6f1f9efdeb3", "html_url": "https://github.com/rust-lang/rust/commit/1f7de3fa983ef1153fcae10a67a1d6f1f9efdeb3"}], "stats": {"total": 72, "additions": 53, "deletions": 19}, "files": [{"sha": "4f9033cedc3ff7aef6ef3cd75af34897fcbf1a1d", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/dbcf3453ea384413b169a41cae494e44324ca7b0/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/dbcf3453ea384413b169a41cae494e44324ca7b0/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=dbcf3453ea384413b169a41cae494e44324ca7b0", "patch": "@@ -35,7 +35,7 @@ Inline assembly is currently supported on the following architectures:\n Let us start with the simplest possible example:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n unsafe {\n     asm!(\"nop\");\n }\n@@ -52,7 +52,7 @@ Now inserting an instruction that does nothing is rather boring. Let us do somet\n actually acts on data:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n let x: u64;\n unsafe {\n     asm!(\"mov {}, 5\", out(reg) x);\n@@ -74,7 +74,7 @@ the template and will read the variable from there after the inline assembly fin\n Let us see another example that also uses an input:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n let i: u64 = 3;\n let o: u64;\n unsafe {\n@@ -114,7 +114,7 @@ readability, and allows reordering instructions without changing the argument or\n We can further refine the above example to avoid the `mov` instruction:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n let mut x: u64 = 3;\n unsafe {\n     asm!(\"add {0}, {number}\", inout(reg) x, number = const 5);\n@@ -128,7 +128,7 @@ This is different from specifying an input and output separately in that it is g\n It is also possible to specify different variables for the input and output parts of an `inout` operand:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n let x: u64 = 3;\n let y: u64;\n unsafe {\n@@ -150,7 +150,7 @@ There is also a `inlateout` variant of this specifier.\n Here is an example where `inlateout` *cannot* be used:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n let mut a: u64 = 4;\n let b: u64 = 4;\n let c: u64 = 4;\n@@ -171,7 +171,7 @@ Here the compiler is free to allocate the same register for inputs `b` and `c` s\n However the following example can use `inlateout` since the output is only modified after all input registers have been read:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n let mut a: u64 = 4;\n let b: u64 = 4;\n unsafe {\n@@ -190,7 +190,7 @@ While `reg` is generally available on any architecture, these are highly archite\n among others can be addressed by their name.\n \n ```rust,allow_fail,no_run\n-# #![feature(asm)]\n+#![feature(asm)]\n let cmd = 0xd1;\n unsafe {\n     asm!(\"out 0x64, eax\", in(\"eax\") cmd);\n@@ -206,7 +206,7 @@ Note that unlike other operand types, explicit register operands cannot be used\n Consider this example which uses the x86 `mul` instruction:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n fn mul(a: u64, b: u64) -> u128 {\n     let lo: u64;\n     let hi: u64;\n@@ -242,7 +242,7 @@ We need to tell the compiler about this since it may need to save and restore th\n around the inline assembly block.\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n let ebx: u32;\n let ecx: u32;\n \n@@ -272,7 +272,7 @@ However we still need to tell the compiler that `eax` and `edx` have been modifi\n This can also be used with a general register class (e.g. `reg`) to obtain a scratch register for use inside the asm code:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n // Multiply x by 6 using shifts and adds\n let mut x: u64 = 4;\n unsafe {\n@@ -294,7 +294,7 @@ A special operand type, `sym`, allows you to use the symbol name of a `fn` or `s\n This allows you to call a function or access a global variable without needing to keep its address in a register.\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n extern \"C\" fn foo(arg: i32) {\n     println!(\"arg = {}\", arg);\n }\n@@ -316,7 +316,7 @@ fn call_foo(arg: i32) {\n             // Also mark AVX-512 registers as clobbered. This is accepted by the\n             // compiler even if AVX-512 is not enabled on the current target.\n             out(\"xmm16\") _, out(\"xmm17\") _, out(\"xmm18\") _, out(\"xmm19\") _,\n-            out(\"xmm20\") _, out(\"xmm21\") _, out(\"xmm22\") _, out(\"xmm13\") _,\n+            out(\"xmm20\") _, out(\"xmm21\") _, out(\"xmm22\") _, out(\"xmm23\") _,\n             out(\"xmm24\") _, out(\"xmm25\") _, out(\"xmm26\") _, out(\"xmm27\") _,\n             out(\"xmm28\") _, out(\"xmm29\") _, out(\"xmm30\") _, out(\"xmm31\") _,\n         )\n@@ -336,7 +336,7 @@ By default the compiler will always choose the name that refers to the full regi\n This default can be overriden by using modifiers on the template string operands, just like you would with format strings:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n let mut x: u16 = 0xab;\n \n unsafe {\n@@ -361,7 +361,7 @@ For example, in x86/x86_64 and intel assembly syntax, you should wrap inputs/out\n to indicate they are memory operands:\n \n ```rust,allow_fail\n-# #![feature(asm, llvm_asm)]\n+#![feature(asm, llvm_asm)]\n # fn load_fpu_control_word(control: u16) {\n unsafe {\n     asm!(\"fldcw [{}]\", in(reg) &control, options(nostack));\n@@ -372,14 +372,51 @@ unsafe {\n # }\n ```\n \n+## Labels\n+\n+The compiler is allowed to instantiate multiple copies an `asm!` block, for example when the function containing it is inlined in multiple places. As a consequence, you should only use GNU assembler [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.\n+\n+Moreover, due to [an llvm bug], you shouldn't use labels exclusively made of `0` and `1` digits, e.g. `0`, `11` or `101010`, as they may end up being interpreted as binary values.\n+\n+```rust,allow_fail\n+#![feature(asm)]\n+\n+let mut a = 0;\n+unsafe {\n+    asm!(\n+        \"mov {0}, 10\",\n+        \"2:\",\n+        \"sub {0}, 1\",\n+        \"cmp {0}, 3\",\n+        \"jle 2f\",\n+        \"jmp 2b\",\n+        \"2:\",\n+        \"add {0}, 2\",\n+        out(reg) a\n+    );\n+}\n+assert_eq!(a, 5);\n+```\n+\n+This will decrement the `{0}` register value from 10 to 3, then add 2 and store it in `a`.\n+\n+This example show a few thing:\n+\n+First that the same number can be used as a label multiple times in the same inline block.\n+\n+Second, that when a numeric label is used as a reference (as an instruction operand, for example), the suffixes b (\u201cbackward\u201d) or f (\u201cforward\u201d) should be added to the numeric label. It will then refer to the nearest label defined by this number in this direction.\n+\n+[local labels]: https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels\n+[an llvm bug]: https://bugs.llvm.org/show_bug.cgi?id=36144\n+\n ## Options\n \n By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However in many cases, it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.\n \n Let's take our previous example of an `add` instruction:\n \n ```rust,allow_fail\n-# #![feature(asm)]\n+#![feature(asm)]\n let mut a: u64 = 4;\n let b: u64 = 4;\n unsafe {\n@@ -787,8 +824,5 @@ The compiler performs some additional checks on options:\n     - You are responsible for switching any target-specific state (e.g. thread-local storage, stack bounds).\n     - The set of memory locations that you may access is the intersection of those allowed by the `asm!` blocks you entered and exited.\n - You cannot assume that an `asm!` block will appear exactly once in the output binary. The compiler is allowed to instantiate multiple copies of the `asm!` block, for example when the function containing it is inlined in multiple places.\n-  - As a consequence, you should only use [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.\n \n > **Note**: As a general rule, the flags covered by `preserves_flags` are those which are *not* preserved when performing a function call.\n-\n-[local labels]: https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels"}]}