{"sha": "fa7c4d503015638a9696a54432beca7af6999f10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhN2M0ZDUwMzAxNTYzOGE5Njk2YTU0NDMyYmVjYTdhZjY5OTlmMTA=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-27T15:16:54Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-27T15:16:54Z"}, "message": "Recover comments between 'impl' and the opening brace", "tree": {"sha": "c32dc5c2b2515e8cfe0bf2a5992842b307a9ab71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c32dc5c2b2515e8cfe0bf2a5992842b307a9ab71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa7c4d503015638a9696a54432beca7af6999f10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7c4d503015638a9696a54432beca7af6999f10", "html_url": "https://github.com/rust-lang/rust/commit/fa7c4d503015638a9696a54432beca7af6999f10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa7c4d503015638a9696a54432beca7af6999f10/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6bbc6b54de37738ea8991b1dd928b9d49d53cd67", "url": "https://api.github.com/repos/rust-lang/rust/commits/6bbc6b54de37738ea8991b1dd928b9d49d53cd67", "html_url": "https://github.com/rust-lang/rust/commit/6bbc6b54de37738ea8991b1dd928b9d49d53cd67"}], "stats": {"total": 41, "additions": 28, "deletions": 13}, "files": [{"sha": "3217cc9b8f6a13069a3b7a89073950bbbfa2c13b", "filename": "src/items.rs", "status": "modified", "additions": 28, "deletions": 13, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fa7c4d503015638a9696a54432beca7af6999f10/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa7c4d503015638a9696a54432beca7af6999f10/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=fa7c4d503015638a9696a54432beca7af6999f10", "patch": "@@ -517,8 +517,10 @@ pub fn format_impl(\n     where_span_end: Option<BytePos>,\n ) -> Option<String> {\n     if let ast::ItemKind::Impl(_, _, _, ref generics, _, ref self_ty, ref items) = item.node {\n-        let mut result = String::new();\n+        let mut result = String::with_capacity(128);\n         let ref_and_type = try_opt!(format_impl_ref_and_type(context, item, offset));\n+        let indent_str = offset.to_string(context.config);\n+        let sep = format!(\"\\n{}\", &indent_str);\n         result.push_str(&ref_and_type);\n \n         let where_budget = if result.contains('\\n') {\n@@ -543,6 +545,24 @@ pub fn format_impl(\n             option,\n         ));\n \n+        // If there is no where clause, we may have missing comments between the trait name and\n+        // the opening brace.\n+        if generics.where_clause.predicates.is_empty() {\n+            if let Some(hi) = where_span_end {\n+                match recover_missing_comment_in_span(\n+                    mk_sp(self_ty.span.hi, hi),\n+                    Shape::indented(offset, context.config),\n+                    context,\n+                    last_line_width(&result),\n+                ) {\n+                    Some(ref missing_comment) if !missing_comment.is_empty() => {\n+                        result.push_str(missing_comment);\n+                    }\n+                    _ => (),\n+                }\n+            }\n+        }\n+\n         if try_opt!(is_impl_single_line(\n             context,\n             &items,\n@@ -551,9 +571,8 @@ pub fn format_impl(\n             &item,\n         )) {\n             result.push_str(&where_clause_str);\n-            if where_clause_str.contains('\\n') {\n-                let white_space = offset.to_string(context.config);\n-                result.push_str(&format!(\"\\n{}{{\\n{}}}\", &white_space, &white_space));\n+            if where_clause_str.contains('\\n') || last_line_contains_single_line_comment(&result) {\n+                result.push_str(&format!(\"{}{{{}}}\", &sep, &sep));\n             } else {\n                 result.push_str(\" {}\");\n             }\n@@ -569,14 +588,11 @@ pub fn format_impl(\n         result.push_str(&where_clause_str);\n \n         match context.config.item_brace_style() {\n-            BraceStyle::AlwaysNextLine => {\n-                result.push('\\n');\n-                result.push_str(&offset.to_string(context.config));\n-            }\n+            _ if last_line_contains_single_line_comment(&result) => result.push_str(&sep),\n+            BraceStyle::AlwaysNextLine => result.push_str(&sep),\n             BraceStyle::PreferSameLine => result.push(' '),\n             BraceStyle::SameLineWhere => if !where_clause_str.is_empty() {\n-                result.push('\\n');\n-                result.push_str(&offset.to_string(context.config));\n+                result.push_str(&sep);\n             } else {\n                 result.push(' ');\n             },\n@@ -610,8 +626,7 @@ pub fn format_impl(\n         }\n \n         if result.chars().last().unwrap() == '{' {\n-            result.push('\\n');\n-            result.push_str(&offset.to_string(context.config));\n+            result.push_str(&sep);\n         }\n         result.push('}');\n \n@@ -632,7 +647,7 @@ fn is_impl_single_line(\n     let open_pos = try_opt!(snippet.find_uncommented(\"{\")) + 1;\n \n     Some(\n-        context.config.impl_empty_single_line() && items.is_empty() &&\n+        context.config.impl_empty_single_line() && items.is_empty() && !result.contains('\\n') &&\n             result.len() + where_clause_str.len() <= context.config.max_width() &&\n             !contains_comment(&snippet[open_pos..]),\n     )"}]}