{"sha": "f44b951a1ea40b61508b2d0abb3f239797f885c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0NGI5NTFhMWVhNDBiNjE1MDhiMmQwYWJiM2YyMzk3OTdmODg1YzU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-28T19:05:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-06-28T19:05:12Z"}, "message": "auto merge of #7451 : cmr/rust/rewrite-each-path, r=pcwalton", "tree": {"sha": "326ffc88eb48938b5c57daad927cf6e7462a13e1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/326ffc88eb48938b5c57daad927cf6e7462a13e1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f44b951a1ea40b61508b2d0abb3f239797f885c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f44b951a1ea40b61508b2d0abb3f239797f885c5", "html_url": "https://github.com/rust-lang/rust/commit/f44b951a1ea40b61508b2d0abb3f239797f885c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f44b951a1ea40b61508b2d0abb3f239797f885c5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e4e2f70c90f01b5be22a192c883b9dcb34df7ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e4e2f70c90f01b5be22a192c883b9dcb34df7ff", "html_url": "https://github.com/rust-lang/rust/commit/4e4e2f70c90f01b5be22a192c883b9dcb34df7ff"}, {"sha": "4f044891a5457acb06338c78f9aa58d8b4c9d53f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f044891a5457acb06338c78f9aa58d8b4c9d53f", "html_url": "https://github.com/rust-lang/rust/commit/4f044891a5457acb06338c78f9aa58d8b4c9d53f"}], "stats": {"total": 5297, "additions": 3434, "deletions": 1863}, "files": [{"sha": "cc53d7d17a25a5019b7f9fe01922bbe38a48e3e5", "filename": "doc/rust.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -2862,13 +2862,13 @@ call to the method `make_string`.\n Types in Rust are categorized into kinds, based on various properties of the components of the type.\n The kinds are:\n \n-`Const`\n+`Freeze`\n   : Types of this kind are deeply immutable;\n     they contain no mutable memory locations directly or indirectly via pointers.\n-`Owned`\n+`Send`\n   : Types of this kind can be safely sent between tasks.\n     This kind includes scalars, owning pointers, owned closures, and\n-    structural types containing only other owned types. All `Owned` types are `Static`.\n+    structural types containing only other owned types. All `Send` types are `Static`.\n `Static`\n   : Types of this kind do not contain any borrowed pointers;\n     this can be a useful guarantee for code that breaks borrowing assumptions using [`unsafe` operations](#unsafe-functions).\n@@ -2882,7 +2882,7 @@ The kinds are:\n     trait provides a single method `finalize` that takes no parameters, and is run\n     when values of the type are dropped. Such a method is called a \"destructor\",\n     and are always executed in \"top-down\" order: a value is completely destroyed\n-    before any of the values it owns run their destructors. Only `Owned` types\n+    before any of the values it owns run their destructors. Only `Send` types\n     that do not implement `Copy` can implement `Drop`.\n \n > **Note:** The `finalize` method may be renamed in future versions of Rust.\n@@ -2968,10 +2968,10 @@ frame they are allocated within.\n A task owns all memory it can *safely* reach through local variables,\n as well as managed, owning and borrowed pointers.\n \n-When a task sends a value that has the `Owned` trait to another task,\n+When a task sends a value that has the `Send` trait to another task,\n it loses ownership of the value sent and can no longer refer to it.\n This is statically guaranteed by the combined use of \"move semantics\",\n-and the compiler-checked _meaning_ of the `Owned` trait:\n+and the compiler-checked _meaning_ of the `Send` trait:\n it is only instantiated for (transitively) sendable kinds of data constructor and pointers,\n never including managed or borrowed pointers.\n \n@@ -3116,7 +3116,7 @@ These include:\n   - read-only and read-write shared variables with various safe mutual exclusion patterns\n   - simple locks and semaphores\n \n-When such facilities carry values, the values are restricted to the [`Owned` type-kind](#type-kinds).\n+When such facilities carry values, the values are restricted to the [`Send` type-kind](#type-kinds).\n Restricting communication interfaces to this kind ensures that no borrowed or managed pointers move between tasks.\n Thus access to an entire data structure can be mediated through its owning \"root\" value;\n no further locking or copying is required to avoid data races within the substructure of such a value."}, {"sha": "047b57e56a61aa950e1e93228a217c72a9608c6d", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -159,7 +159,7 @@ pub struct Unique<T> {\n     priv ptr: *mut T\n }\n \n-impl<T: Owned> Unique<T> {\n+impl<T: Send> Unique<T> {\n     pub fn new(value: T) -> Unique<T> {\n         unsafe {\n             let ptr = malloc(std::sys::size_of::<T>() as size_t) as *mut T;\n@@ -182,7 +182,7 @@ impl<T: Owned> Unique<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Owned> Drop for Unique<T> {\n+impl<T: Send> Drop for Unique<T> {\n     fn drop(&self) {\n         unsafe {\n             let x = intrinsics::init(); // dummy value to swap in"}, {"sha": "aa6e90826bbbf5d902eeb4cbd0477244abb1bbcd", "filename": "doc/tutorial.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -1281,9 +1281,9 @@ let your_crayons = ~[BananaMania, Beaver, Bittersweet];\n // Add two vectors to create a new one\n let our_crayons = my_crayons + your_crayons;\n \n-// += will append to a vector, provided it lives in a mutable slot\n+// .push_all() will append to a vector, provided it lives in a mutable slot\n let mut my_crayons = my_crayons;\n-my_crayons += your_crayons;\n+my_crayons.push_all(your_crayons);\n ~~~~\n \n > ***Note:*** The above examples of vector addition use owned"}, {"sha": "4649d4dfc3c4b913f1f7f38f5cea63e82bd0a8db", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -21,7 +21,7 @@ pub fn load_errors(testfile: &Path) -> ~[ExpectedError] {\n     let mut line_num = 1u;\n     while !rdr.eof() {\n         let ln = rdr.read_line();\n-        error_patterns += parse_expected(line_num, ln);\n+        error_patterns.push_all_move(parse_expected(line_num, ln));\n         line_num += 1u;\n     }\n     return error_patterns;"}, {"sha": "0e04be34c795a7a4ac32e854b8be5a2bb53fd36c", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -226,8 +226,8 @@ actual:\\n\\\n                          ~\"-L\", config.build_base.to_str(),\n                          ~\"-L\",\n                          aux_output_dir_name(config, testfile).to_str()];\n-        args += split_maybe_args(&config.rustcflags);\n-        args += split_maybe_args(&props.compile_flags);\n+        args.push_all_move(split_maybe_args(&config.rustcflags));\n+        args.push_all_move(split_maybe_args(&props.compile_flags));\n         return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n     }\n }\n@@ -581,8 +581,8 @@ fn make_compile_args(config: &config, props: &TestProps, extras: ~[~str],\n                      ~\"-o\", xform(config, testfile).to_str(),\n                      ~\"-L\", config.build_base.to_str()]\n         + extras;\n-    args += split_maybe_args(&config.rustcflags);\n-    args += split_maybe_args(&props.compile_flags);\n+    args.push_all_move(split_maybe_args(&config.rustcflags));\n+    args.push_all_move(split_maybe_args(&props.compile_flags));\n     return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n }\n "}, {"sha": "2fb03fecb5988e14da7a87aafa43c18fcde7c4e0", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -112,15 +112,15 @@ impl<'self> Condvar<'self> {\n pub struct ARC<T> { x: UnsafeAtomicRcBox<T> }\n \n /// Create an atomically reference counted wrapper.\n-pub fn ARC<T:Const + Owned>(data: T) -> ARC<T> {\n+pub fn ARC<T:Freeze + Send>(data: T) -> ARC<T> {\n     ARC { x: UnsafeAtomicRcBox::new(data) }\n }\n \n /**\n  * Access the underlying data in an atomically reference counted\n  * wrapper.\n  */\n-impl<T:Const+Owned> ARC<T> {\n+impl<T:Freeze+Send> ARC<T> {\n     pub fn get<'a>(&'a self) -> &'a T {\n         unsafe { &*self.x.get_immut() }\n     }\n@@ -133,7 +133,7 @@ impl<T:Const+Owned> ARC<T> {\n  * object. However, one of the `arc` objects can be sent to another task,\n  * allowing them to share the underlying data.\n  */\n-impl<T:Const + Owned> Clone for ARC<T> {\n+impl<T:Freeze + Send> Clone for ARC<T> {\n     fn clone(&self) -> ARC<T> {\n         ARC { x: self.x.clone() }\n     }\n@@ -149,22 +149,22 @@ struct MutexARCInner<T> { lock: Mutex, failed: bool, data: T }\n struct MutexARC<T> { x: UnsafeAtomicRcBox<MutexARCInner<T>> }\n \n /// Create a mutex-protected ARC with the supplied data.\n-pub fn MutexARC<T:Owned>(user_data: T) -> MutexARC<T> {\n+pub fn MutexARC<T:Send>(user_data: T) -> MutexARC<T> {\n     mutex_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a mutex-protected ARC with the supplied data and a specified number\n  * of condvars (as sync::mutex_with_condvars).\n  */\n-pub fn mutex_arc_with_condvars<T:Owned>(user_data: T,\n+pub fn mutex_arc_with_condvars<T:Send>(user_data: T,\n                                     num_condvars: uint) -> MutexARC<T> {\n     let data =\n         MutexARCInner { lock: mutex_with_condvars(num_condvars),\n                           failed: false, data: user_data };\n     MutexARC { x: UnsafeAtomicRcBox::new(data) }\n }\n \n-impl<T:Owned> Clone for MutexARC<T> {\n+impl<T:Send> Clone for MutexARC<T> {\n     /// Duplicate a mutex-protected ARC, as arc::clone.\n     fn clone(&self) -> MutexARC<T> {\n         // NB: Cloning the underlying mutex is not necessary. Its reference\n@@ -173,7 +173,7 @@ impl<T:Owned> Clone for MutexARC<T> {\n     }\n }\n \n-impl<T:Owned> MutexARC<T> {\n+impl<T:Send> MutexARC<T> {\n \n     /**\n      * Access the underlying mutable data with mutual exclusion from other\n@@ -282,14 +282,14 @@ struct RWARC<T> {\n }\n \n /// Create a reader/writer ARC with the supplied data.\n-pub fn RWARC<T:Const + Owned>(user_data: T) -> RWARC<T> {\n+pub fn RWARC<T:Freeze + Send>(user_data: T) -> RWARC<T> {\n     rw_arc_with_condvars(user_data, 1)\n }\n /**\n  * Create a reader/writer ARC with the supplied data and a specified number\n  * of condvars (as sync::rwlock_with_condvars).\n  */\n-pub fn rw_arc_with_condvars<T:Const + Owned>(\n+pub fn rw_arc_with_condvars<T:Freeze + Send>(\n     user_data: T,\n     num_condvars: uint) -> RWARC<T>\n {\n@@ -299,7 +299,7 @@ pub fn rw_arc_with_condvars<T:Const + Owned>(\n     RWARC { x: UnsafeAtomicRcBox::new(data), }\n }\n \n-impl<T:Const + Owned> RWARC<T> {\n+impl<T:Freeze + Send> RWARC<T> {\n     /// Duplicate a rwlock-protected ARC, as arc::clone.\n     pub fn clone(&self) -> RWARC<T> {\n         RWARC {\n@@ -309,7 +309,7 @@ impl<T:Const + Owned> RWARC<T> {\n \n }\n \n-impl<T:Const + Owned> RWARC<T> {\n+impl<T:Freeze + Send> RWARC<T> {\n     /**\n      * Access the underlying data mutably. Locks the rwlock in write mode;\n      * other readers and writers will block.\n@@ -435,7 +435,7 @@ impl<T:Const + Owned> RWARC<T> {\n // lock it. This wraps the unsafety, with the justification that the 'lock'\n // field is never overwritten; only 'failed' and 'data'.\n #[doc(hidden)]\n-fn borrow_rwlock<T:Const + Owned>(state: *const RWARCInner<T>) -> *RWlock {\n+fn borrow_rwlock<T:Freeze + Send>(state: *const RWARCInner<T>) -> *RWlock {\n     unsafe { cast::transmute(&const (*state).lock) }\n }\n \n@@ -452,7 +452,7 @@ pub struct RWReadMode<'self, T> {\n     token: sync::RWlockReadMode<'self>,\n }\n \n-impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n+impl<'self, T:Freeze + Send> RWWriteMode<'self, T> {\n     /// Access the pre-downgrade RWARC in write mode.\n     pub fn write<U>(&mut self, blk: &fn(x: &mut T) -> U) -> U {\n         match *self {\n@@ -493,7 +493,7 @@ impl<'self, T:Const + Owned> RWWriteMode<'self, T> {\n     }\n }\n \n-impl<'self, T:Const + Owned> RWReadMode<'self, T> {\n+impl<'self, T:Freeze + Send> RWReadMode<'self, T> {\n     /// Access the post-downgrade rwlock in read mode.\n     pub fn read<U>(&self, blk: &fn(x: &T) -> U) -> U {\n         match *self {"}, {"sha": "2f18b0562e0feb03c56dbe7b6e43017e67a4f38e", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -186,20 +186,18 @@ impl Arena {\n     #[inline]\n     fn alloc_pod_inner(&mut self, n_bytes: uint, align: uint) -> *u8 {\n         unsafe {\n-            // XXX: Borrow check\n-            let head = transmute_mut_region(&mut self.pod_head);\n-\n-            let start = round_up_to(head.fill, align);\n+            let this = transmute_mut_region(self);\n+            let start = round_up_to(this.pod_head.fill, align);\n             let end = start + n_bytes;\n-            if end > at_vec::capacity(head.data) {\n-                return self.alloc_pod_grow(n_bytes, align);\n+            if end > at_vec::capacity(this.pod_head.data) {\n+                return this.alloc_pod_grow(n_bytes, align);\n             }\n-            head.fill = end;\n+            this.pod_head.fill = end;\n \n             //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n             //       start, n_bytes, align, head.fill);\n \n-            ptr::offset(vec::raw::to_ptr(head.data), start)\n+            ptr::offset(vec::raw::to_ptr(this.pod_head.data), start)\n         }\n     }\n \n@@ -231,21 +229,31 @@ impl Arena {\n     fn alloc_nonpod_inner(&mut self, n_bytes: uint, align: uint)\n                           -> (*u8, *u8) {\n         unsafe {\n-            let head = transmute_mut_region(&mut self.head);\n+            let start;\n+            let end;\n+            let tydesc_start;\n+            let after_tydesc;\n+\n+            {\n+                let head = transmute_mut_region(&mut self.head);\n+\n+                tydesc_start = head.fill;\n+                after_tydesc = head.fill + sys::size_of::<*TyDesc>();\n+                start = round_up_to(after_tydesc, align);\n+                end = start + n_bytes;\n+            }\n \n-            let tydesc_start = head.fill;\n-            let after_tydesc = head.fill + sys::size_of::<*TyDesc>();\n-            let start = round_up_to(after_tydesc, align);\n-            let end = start + n_bytes;\n-            if end > at_vec::capacity(head.data) {\n+            if end > at_vec::capacity(self.head.data) {\n                 return self.alloc_nonpod_grow(n_bytes, align);\n             }\n+\n+            let head = transmute_mut_region(&mut self.head);\n             head.fill = round_up_to(end, sys::pref_align_of::<*TyDesc>());\n \n             //debug!(\"idx = %u, size = %u, align = %u, fill = %u\",\n             //       start, n_bytes, align, head.fill);\n \n-            let buf = vec::raw::to_ptr(head.data);\n+            let buf = vec::raw::to_ptr(self.head.data);\n             return (ptr::offset(buf, tydesc_start), ptr::offset(buf, start));\n         }\n     }"}, {"sha": "4fe7761bf18da24bcdd50c89ab057a093e6036db", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -476,9 +476,15 @@ impl Bitv {\n      * character is either '0' or '1'.\n      */\n      pub fn to_str(&self) -> ~str {\n-       let mut rs = ~\"\";\n-       for self.each() |i| { if i { rs += \"1\"; } else { rs += \"0\"; } };\n-       rs\n+        let mut rs = ~\"\";\n+        for self.each() |i| {\n+            if i {\n+                rs.push_char('1');\n+            } else {\n+                rs.push_char('0');\n+            }\n+        };\n+        rs\n      }\n \n "}, {"sha": "2cb2128db5f7363cd96dd6c1b15f398942c90ae5", "filename": "src/libextra/comm.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcomm.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -30,7 +30,7 @@ pub struct DuplexStream<T, U> {\n }\n \n // Allow these methods to be used without import:\n-impl<T:Owned,U:Owned> DuplexStream<T, U> {\n+impl<T:Send,U:Send> DuplexStream<T, U> {\n     pub fn send(&self, x: T) {\n         self.chan.send(x)\n     }\n@@ -48,19 +48,19 @@ impl<T:Owned,U:Owned> DuplexStream<T, U> {\n     }\n }\n \n-impl<T:Owned,U:Owned> GenericChan<T> for DuplexStream<T, U> {\n+impl<T:Send,U:Send> GenericChan<T> for DuplexStream<T, U> {\n     fn send(&self, x: T) {\n         self.chan.send(x)\n     }\n }\n \n-impl<T:Owned,U:Owned> GenericSmartChan<T> for DuplexStream<T, U> {\n+impl<T:Send,U:Send> GenericSmartChan<T> for DuplexStream<T, U> {\n     fn try_send(&self, x: T) -> bool {\n         self.chan.try_send(x)\n     }\n }\n \n-impl<T:Owned,U:Owned> GenericPort<U> for DuplexStream<T, U> {\n+impl<T:Send,U:Send> GenericPort<U> for DuplexStream<T, U> {\n     fn recv(&self) -> U {\n         self.port.recv()\n     }\n@@ -70,20 +70,20 @@ impl<T:Owned,U:Owned> GenericPort<U> for DuplexStream<T, U> {\n     }\n }\n \n-impl<T:Owned,U:Owned> Peekable<U> for DuplexStream<T, U> {\n+impl<T:Send,U:Send> Peekable<U> for DuplexStream<T, U> {\n     fn peek(&self) -> bool {\n         self.port.peek()\n     }\n }\n \n-impl<T:Owned,U:Owned> Selectable for DuplexStream<T, U> {\n+impl<T:Send,U:Send> Selectable for DuplexStream<T, U> {\n     fn header(&mut self) -> *mut pipes::PacketHeader {\n         self.port.header()\n     }\n }\n \n /// Creates a bidirectional stream.\n-pub fn DuplexStream<T:Owned,U:Owned>()\n+pub fn DuplexStream<T:Send,U:Send>()\n     -> (DuplexStream<T, U>, DuplexStream<U, T>)\n {\n     let (p1, c2) = comm::stream();"}, {"sha": "c4fb03a7a7dea553f247b4dae9a57b70d9349675", "filename": "src/libextra/crypto/digest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fcrypto%2Fdigest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fcrypto%2Fdigest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fdigest.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -49,9 +49,9 @@ fn to_hex(rr: &[u8]) -> ~str {\n     for rr.iter().advance() |b| {\n         let hex = uint::to_str_radix(*b as uint, 16u);\n         if hex.len() == 1 {\n-            s += \"0\";\n+            s.push_char('0');\n         }\n-        s += hex;\n+        s.push_str(hex);\n     }\n     return s;\n }"}, {"sha": "69eb9afad853b0e7a8906193ee15aa209f6bf74d", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -12,6 +12,8 @@\n \n use core::prelude::*;\n \n+use core::str;\n+\n // Simple Extensible Binary Markup Language (ebml) reader and writer on a\n // cursor model. See the specification here:\n //     http://www.matroska.org/technical/specs/rfc/index.html\n@@ -34,6 +36,20 @@ pub struct Doc {\n     end: uint,\n }\n \n+impl Doc {\n+    pub fn get(&self, tag: uint) -> Doc {\n+        reader::get_doc(*self, tag)\n+    }\n+\n+    pub fn as_str_slice<'a>(&'a self) -> &'a str {\n+        str::from_bytes_slice(self.data.slice(self.start, self.end))\n+    }\n+\n+    pub fn as_str(&self) -> ~str {\n+        self.as_str_slice().to_owned()\n+    }\n+}\n+\n pub struct TaggedDoc {\n     tag: uint,\n     doc: Doc,\n@@ -78,36 +94,18 @@ pub mod reader {\n \n     use serialize;\n \n-    use core::prelude::*;\n     use core::cast::transmute;\n     use core::int;\n     use core::io;\n-    use core::str;\n \n     #[cfg(target_arch = \"x86\")]\n     #[cfg(target_arch = \"x86_64\")]\n+    use core::option::{None, Option, Some};\n     use core::ptr::offset;\n-\n-    #[cfg(target_arch = \"x86\")]\n-    #[cfg(target_arch = \"x86_64\")]\n     use core::unstable::intrinsics::bswap32;\n \n     // ebml reading\n \n-    impl Doc {\n-        pub fn get(&self, tag: uint) -> Doc {\n-            get_doc(*self, tag)\n-        }\n-\n-        pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-            str::from_bytes_slice(self.data.slice(self.start, self.end))\n-        }\n-\n-        pub fn as_str(&self) -> ~str {\n-            self.as_str_slice().to_owned()\n-        }\n-    }\n-\n     struct Res {\n         val: uint,\n         next: uint"}, {"sha": "d5e43e85a140ee2910ee2c47d0eaf5e3756efbd2", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -166,8 +166,8 @@ Constructors for flat pipes that send POD types using memcpy.\n \n # Safety Note\n \n-This module is currently unsafe because it uses `Copy Owned` as a type\n-parameter bounds meaning POD (plain old data), but `Copy Owned` and\n+This module is currently unsafe because it uses `Copy Send` as a type\n+parameter bounds meaning POD (plain old data), but `Copy Send` and\n POD are not equivelant.\n \n */\n@@ -191,7 +191,7 @@ pub mod pod {\n     pub type PipeChan<T> = FlatChan<T, PodFlattener<T>, PipeByteChan>;\n \n     /// Create a `FlatPort` from a `Reader`\n-    pub fn reader_port<T:Copy + Owned,R:Reader>(\n+    pub fn reader_port<T:Copy + Send,R:Reader>(\n         reader: R\n     ) -> ReaderPort<T, R> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n@@ -200,7 +200,7 @@ pub mod pod {\n     }\n \n     /// Create a `FlatChan` from a `Writer`\n-    pub fn writer_chan<T:Copy + Owned,W:Writer>(\n+    pub fn writer_chan<T:Copy + Send,W:Writer>(\n         writer: W\n     ) -> WriterChan<T, W> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n@@ -209,21 +209,21 @@ pub mod pod {\n     }\n \n     /// Create a `FlatPort` from a `Port<~[u8]>`\n-    pub fn pipe_port<T:Copy + Owned>(port: Port<~[u8]>) -> PipePort<T> {\n+    pub fn pipe_port<T:Copy + Send>(port: Port<~[u8]>) -> PipePort<T> {\n         let unflat: PodUnflattener<T> = PodUnflattener::new();\n         let byte_port = PipeBytePort::new(port);\n         FlatPort::new(unflat, byte_port)\n     }\n \n     /// Create a `FlatChan` from a `Chan<~[u8]>`\n-    pub fn pipe_chan<T:Copy + Owned>(chan: Chan<~[u8]>) -> PipeChan<T> {\n+    pub fn pipe_chan<T:Copy + Send>(chan: Chan<~[u8]>) -> PipeChan<T> {\n         let flat: PodFlattener<T> = PodFlattener::new();\n         let byte_chan = PipeByteChan::new(chan);\n         FlatChan::new(flat, byte_chan)\n     }\n \n     /// Create a pair of `FlatChan` and `FlatPort`, backed by pipes\n-    pub fn pipe_stream<T:Copy + Owned>() -> (PipePort<T>, PipeChan<T>) {\n+    pub fn pipe_stream<T:Copy + Send>() -> (PipePort<T>, PipeChan<T>) {\n         let (port, chan) = comm::stream();\n         return (pipe_port(port), pipe_chan(chan));\n     }\n@@ -352,7 +352,7 @@ pub mod flatteners {\n     use core::sys::size_of;\n     use core::vec;\n \n-    // FIXME #4074: Copy + Owned != POD\n+    // FIXME #4074: Copy + Send != POD\n     pub struct PodUnflattener<T> {\n         bogus: ()\n     }\n@@ -361,7 +361,7 @@ pub mod flatteners {\n         bogus: ()\n     }\n \n-    impl<T:Copy + Owned> Unflattener<T> for PodUnflattener<T> {\n+    impl<T:Copy + Send> Unflattener<T> for PodUnflattener<T> {\n         fn unflatten(&self, buf: ~[u8]) -> T {\n             assert!(size_of::<T>() != 0);\n             assert_eq!(size_of::<T>(), buf.len());\n@@ -371,7 +371,7 @@ pub mod flatteners {\n         }\n     }\n \n-    impl<T:Copy + Owned> Flattener<T> for PodFlattener<T> {\n+    impl<T:Copy + Send> Flattener<T> for PodFlattener<T> {\n         fn flatten(&self, val: T) -> ~[u8] {\n             assert!(size_of::<T>() != 0);\n             let val: *T = ptr::to_unsafe_ptr(&val);\n@@ -380,15 +380,15 @@ pub mod flatteners {\n         }\n     }\n \n-    impl<T:Copy + Owned> PodUnflattener<T> {\n+    impl<T:Copy + Send> PodUnflattener<T> {\n         pub fn new() -> PodUnflattener<T> {\n             PodUnflattener {\n                 bogus: ()\n             }\n         }\n     }\n \n-    impl<T:Copy + Owned> PodFlattener<T> {\n+    impl<T:Copy + Send> PodFlattener<T> {\n         pub fn new() -> PodFlattener<T> {\n             PodFlattener {\n                 bogus: ()"}, {"sha": "00f4cc3989be38a41ca729ef4c4e550488925e8e", "filename": "src/libextra/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -101,7 +101,7 @@ pub fn from_value<A>(val: A) -> Future<A> {\n     Future {state: Forced(val)}\n }\n \n-pub fn from_port<A:Owned>(port: PortOne<A>) -> Future<A> {\n+pub fn from_port<A:Send>(port: PortOne<A>) -> Future<A> {\n     /*!\n      * Create a future from a port\n      *\n@@ -127,7 +127,7 @@ pub fn from_fn<A>(f: ~fn() -> A) -> Future<A> {\n     Future {state: Pending(f)}\n }\n \n-pub fn spawn<A:Owned>(blk: ~fn() -> A) -> Future<A> {\n+pub fn spawn<A:Send>(blk: ~fn() -> A) -> Future<A> {\n     /*!\n      * Create a future from a unique closure.\n      *"}, {"sha": "fa064e6330e7b4dd3d9bad6a30c34df3300123b3", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 32, "deletions": 18, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -606,33 +606,47 @@ pub mod groups {\n             let mut row = \" \".repeat(4);\n \n             // short option\n-            row += match short_name.len() {\n-                0 => ~\"\",\n-                1 => ~\"-\" + short_name + \" \",\n+            match short_name.len() {\n+                0 => {}\n+                1 => {\n+                    row.push_char('-');\n+                    row.push_str(short_name);\n+                    row.push_char(' ');\n+                }\n                 _ => fail!(\"the short name should only be 1 ascii char long\"),\n-            };\n+            }\n \n             // long option\n-            row += match long_name.len() {\n-                0 => ~\"\",\n-                _ => ~\"--\" + long_name + \" \",\n-            };\n+            match long_name.len() {\n+                0 => {}\n+                _ => {\n+                    row.push_str(\"--\");\n+                    row.push_str(long_name);\n+                    row.push_char(' ');\n+                }\n+            }\n \n             // arg\n-            row += match hasarg {\n-                No    => ~\"\",\n-                Yes   => hint,\n-                Maybe => ~\"[\" + hint + \"]\",\n-            };\n+            match hasarg {\n+                No => {}\n+                Yes => row.push_str(hint),\n+                Maybe => {\n+                    row.push_char('[');\n+                    row.push_str(hint);\n+                    row.push_char(']');\n+                }\n+            }\n \n             // FIXME: #5516\n             // here we just need to indent the start of the description\n             let rowlen = row.len();\n-            row += if rowlen < 24 {\n-                \" \".repeat(24 - rowlen)\n+            if rowlen < 24 {\n+                for (24 - rowlen).times {\n+                    row.push_char(' ')\n+                }\n             } else {\n-                copy desc_sep\n-            };\n+                row.push_str(desc_sep)\n+            }\n \n             // Normalize desc to contain words separated by one space character\n             let mut desc_normalized_whitespace = ~\"\";\n@@ -649,7 +663,7 @@ pub mod groups {\n \n             // FIXME: #5516\n             // wrapped description\n-            row += desc_rows.connect(desc_sep);\n+            row.push_str(desc_rows.connect(desc_sep));\n \n             row\n         });"}, {"sha": "a71be18174ab872a9457ecbbe98794798dbea82d", "filename": "src/libextra/json.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fjson.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -60,25 +60,27 @@ fn escape_str(s: &str) -> ~str {\n     let mut escaped = ~\"\\\"\";\n     for s.iter().advance |c| {\n         match c {\n-          '\"' => escaped += \"\\\\\\\"\",\n-          '\\\\' => escaped += \"\\\\\\\\\",\n-          '\\x08' => escaped += \"\\\\b\",\n-          '\\x0c' => escaped += \"\\\\f\",\n-          '\\n' => escaped += \"\\\\n\",\n-          '\\r' => escaped += \"\\\\r\",\n-          '\\t' => escaped += \"\\\\t\",\n-          _ => escaped += str::from_char(c)\n+          '\"' => escaped.push_str(\"\\\\\\\"\"),\n+          '\\\\' => escaped.push_str(\"\\\\\\\\\"),\n+          '\\x08' => escaped.push_str(\"\\\\b\"),\n+          '\\x0c' => escaped.push_str(\"\\\\f\"),\n+          '\\n' => escaped.push_str(\"\\\\n\"),\n+          '\\r' => escaped.push_str(\"\\\\r\"),\n+          '\\t' => escaped.push_str(\"\\\\t\"),\n+          _ => escaped.push_char(c),\n         }\n     };\n \n-    escaped += \"\\\"\";\n+    escaped.push_char('\"');\n \n     escaped\n }\n \n fn spaces(n: uint) -> ~str {\n     let mut ss = ~\"\";\n-    for n.times { ss.push_str(\" \"); }\n+    for n.times {\n+        ss.push_str(\" \");\n+    }\n     return ss;\n }\n "}, {"sha": "3be7394b46d0bd275fdb31273d5fa971e653ec0b", "filename": "src/libextra/md4.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -59,7 +59,8 @@ pub fn md4(msg: &[u8]) -> Quad {\n     while i < e {\n         let (aa, bb, cc, dd) = (a, b, c, d);\n \n-        let mut (j, base) = (0u, i);\n+        let mut j = 0u;\n+        let mut base = i;\n         while j < 16u {\n             x[j] = (msg[base] as u32) + (msg[base + 1u] as u32 << 8u32) +\n                 (msg[base + 2u] as u32 << 16u32) +\n@@ -118,8 +119,10 @@ pub fn md4_str(msg: &[u8]) -> ~str {\n         let mut i = 0u32;\n         while i < 4u32 {\n             let byte = (u >> (i * 8u32)) as u8;\n-            if byte <= 16u8 { result += \"0\"; }\n-            result += uint::to_str_radix(byte as uint, 16u);\n+            if byte <= 16u8 {\n+                result.push_char('0')\n+            }\n+            result.push_str(uint::to_str_radix(byte as uint, 16u));\n             i += 1u32;\n         }\n     }"}, {"sha": "a60f51e751e1c4cd73eafe6a391717f44d460b21", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -93,10 +93,10 @@ fn encode_inner(s: &str, full_url: bool) -> ~str {\n                         out.push_char(ch);\n                       }\n \n-                      _ => out += fmt!(\"%%%X\", ch as uint)\n+                      _ => out.push_str(fmt!(\"%%%X\", ch as uint))\n                     }\n                 } else {\n-                    out += fmt!(\"%%%X\", ch as uint);\n+                    out.push_str(fmt!(\"%%%X\", ch as uint));\n                 }\n               }\n             }\n@@ -192,7 +192,7 @@ fn encode_plus(s: &str) -> ~str {\n                 out.push_char(ch);\n               }\n               ' ' => out.push_char('+'),\n-              _ => out += fmt!(\"%%%X\", ch as uint)\n+              _ => out.push_str(fmt!(\"%%%X\", ch as uint))\n             }\n         }\n \n@@ -218,7 +218,7 @@ pub fn encode_form_urlencoded(m: &HashMap<~str, ~[~str]>) -> ~str {\n                 first = false;\n             }\n \n-            out += fmt!(\"%s=%s\", key, encode_plus(*value));\n+            out.push_str(fmt!(\"%s=%s\", key, encode_plus(*value)));\n         }\n     }\n \n@@ -415,7 +415,9 @@ fn get_authority(rawurl: &str) ->\n     let mut port = None;\n \n     let mut colon_count = 0;\n-    let mut (pos, begin, end) = (0, 2, len);\n+    let mut pos = 0;\n+    let mut begin = 2;\n+    let mut end = len;\n \n     for rawurl.iter().enumerate().advance |(i,c)| {\n         if i < 2 { loop; } // ignore the leading //"}, {"sha": "002d8a7f9567a42c139db8cba799b7698ea7fe1d", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -380,7 +380,8 @@ impl Integer for BigUint {\n             let mut d = Zero::zero::<BigUint>();\n             let mut n = 1;\n             while m >= b {\n-                let mut (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n+                let (d0, d_unit, b_unit) = div_estimate(&m, &b, n);\n+                let mut d0 = d0;\n                 let mut prod = b * d0;\n                 while prod > m {\n                     // FIXME(#6050): overloaded operators force moves with generic types\n@@ -442,7 +443,8 @@ impl Integer for BigUint {\n \n     fn gcd(&self, other: &BigUint) -> BigUint {\n         // Use Euclid's algorithm\n-        let mut (m, n) = (copy *self, copy *other);\n+        let mut m = copy *self;\n+        let mut n = copy *other;\n         while !m.is_zero() {\n             let temp = m;\n             m = n % temp;\n@@ -506,11 +508,11 @@ impl ToStrRadix for BigUint {\n             let mut m      = n;\n             while m > divider {\n                 let (d, m0) = m.div_mod_floor(&divider);\n-                result += [m0.to_uint() as BigDigit];\n+                result.push(m0.to_uint() as BigDigit);\n                 m = d;\n             }\n             if !m.is_zero() {\n-                result += [m.to_uint() as BigDigit];\n+                result.push(m.to_uint() as BigDigit);\n             }\n             return result;\n         }"}, {"sha": "a3014cf8894bf5abd5204371cb7248efddfbbf27", "filename": "src/libextra/par.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fpar.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -33,7 +33,7 @@ static min_granularity : uint = 1024u;\n  * This is used to build most of the other parallel vector functions,\n  * like map or alli.\n  */\n-fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n+fn map_slices<A:Copy + Send,B:Copy + Send>(\n     xs: &[A],\n     f: &fn() -> ~fn(uint, v: &[A]) -> B)\n     -> ~[B] {\n@@ -88,7 +88,7 @@ fn map_slices<A:Copy + Owned,B:Copy + Owned>(\n }\n \n /// A parallel version of map.\n-pub fn map<A:Copy + Owned,B:Copy + Owned>(\n+pub fn map<A:Copy + Send,B:Copy + Send>(\n     xs: &[A], fn_factory: &fn() -> ~fn(&A) -> B) -> ~[B] {\n     vec::concat(map_slices(xs, || {\n         let f = fn_factory();\n@@ -99,7 +99,7 @@ pub fn map<A:Copy + Owned,B:Copy + Owned>(\n }\n \n /// A parallel version of mapi.\n-pub fn mapi<A:Copy + Owned,B:Copy + Owned>(\n+pub fn mapi<A:Copy + Send,B:Copy + Send>(\n         xs: &[A],\n         fn_factory: &fn() -> ~fn(uint, &A) -> B) -> ~[B] {\n     let slices = map_slices(xs, || {\n@@ -118,7 +118,7 @@ pub fn mapi<A:Copy + Owned,B:Copy + Owned>(\n }\n \n /// Returns true if the function holds for all elements in the vector.\n-pub fn alli<A:Copy + Owned>(\n+pub fn alli<A:Copy + Send>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(uint, &A) -> bool) -> bool\n {\n@@ -133,7 +133,7 @@ pub fn alli<A:Copy + Owned>(\n }\n \n /// Returns true if the function holds for any elements in the vector.\n-pub fn any<A:Copy + Owned>(\n+pub fn any<A:Copy + Send>(\n     xs: &[A],\n     fn_factory: &fn() -> ~fn(&A) -> bool) -> bool {\n     let mapped = map_slices(xs, || {"}, {"sha": "009d68ac026016b593c9945aeaad44c42f3255ad", "filename": "src/libextra/rc.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Frc.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -13,10 +13,10 @@\n /** Task-local reference counted smart pointers\n \n Task-local reference counted smart pointers are an alternative to managed boxes with deterministic\n-destruction. They are restricted to containing types that are either `Owned` or `Const` (or both) to\n+destruction. They are restricted to containing types that are either `Send` or `Freeze` (or both) to\n prevent cycles.\n \n-Neither `Rc<T>` or `RcMut<T>` is ever `Owned` and `RcMut<T>` is never `Const`. If `T` is `Const`, a\n+Neither `Rc<T>` or `RcMut<T>` is ever `Send` and `RcMut<T>` is never `Freeze`. If `T` is `Freeze`, a\n cycle cannot be created with `Rc<T>` because there is no way to modify it after creation.\n \n */\n@@ -35,8 +35,8 @@ struct RcBox<T> {\n }\n \n /// Immutable reference counted pointer type\n-#[non_owned]\n #[unsafe_no_drop_flag]\n+#[non_sendable]\n pub struct Rc<T> {\n     priv ptr: *mut RcBox<T>,\n }\n@@ -51,12 +51,12 @@ impl<T> Rc<T> {\n }\n \n // FIXME: #6516: should be a static method\n-pub fn rc_from_owned<T: Owned>(value: T) -> Rc<T> {\n+pub fn rc_from_owned<T: Send>(value: T) -> Rc<T> {\n     unsafe { Rc::new(value) }\n }\n \n // FIXME: #6516: should be a static method\n-pub fn rc_from_const<T: Const>(value: T) -> Rc<T> {\n+pub fn rc_from_const<T: Freeze>(value: T) -> Rc<T> {\n     unsafe { Rc::new(value) }\n }\n \n@@ -168,6 +168,7 @@ struct RcMutBox<T> {\n \n /// Mutable reference counted pointer type\n #[non_owned]\n+#[non_sendable]\n #[mutable]\n #[unsafe_no_drop_flag]\n pub struct RcMut<T> {\n@@ -184,12 +185,12 @@ impl<T> RcMut<T> {\n }\n \n // FIXME: #6516: should be a static method\n-pub fn rc_mut_from_owned<T: Owned>(value: T) -> RcMut<T> {\n+pub fn rc_mut_from_owned<T: Send>(value: T) -> RcMut<T> {\n     unsafe { RcMut::new(value) }\n }\n \n // FIXME: #6516: should be a static method\n-pub fn rc_mut_from_const<T: Const>(value: T) -> RcMut<T> {\n+pub fn rc_mut_from_const<T: Freeze>(value: T) -> RcMut<T> {\n     unsafe { RcMut::new(value) }\n }\n "}, {"sha": "3908b61381b78bb18f3980e211b78991f371510d", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -86,7 +86,7 @@ struct SemInner<Q> {\n struct Sem<Q>(Exclusive<SemInner<Q>>);\n \n #[doc(hidden)]\n-fn new_sem<Q:Owned>(count: int, q: Q) -> Sem<Q> {\n+fn new_sem<Q:Send>(count: int, q: Q) -> Sem<Q> {\n     Sem(exclusive(SemInner {\n         count: count, waiters: new_waitqueue(), blocked: q }))\n }\n@@ -101,7 +101,7 @@ fn new_sem_and_signal(count: int, num_condvars: uint)\n }\n \n #[doc(hidden)]\n-impl<Q:Owned> Sem<Q> {\n+impl<Q:Send> Sem<Q> {\n     pub fn acquire(&self) {\n         unsafe {\n             let mut waiter_nobe = None;\n@@ -153,7 +153,7 @@ impl Sem<()> {\n \n #[doc(hidden)]\n impl Sem<~[Waitqueue]> {\n-    pub fn access<U>(&self, blk: &fn() -> U) -> U {\n+    pub fn access_waitqueue<U>(&self, blk: &fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n             do task::unkillable {\n@@ -175,7 +175,7 @@ struct SemReleaseGeneric<'self, Q> { sem: &'self Sem<Q> }\n \n #[doc(hidden)]\n #[unsafe_destructor]\n-impl<'self, Q:Owned> Drop for SemReleaseGeneric<'self, Q> {\n+impl<'self, Q:Send> Drop for SemReleaseGeneric<'self, Q> {\n     fn drop(&self) {\n         self.sem.release();\n     }\n@@ -381,7 +381,7 @@ impl Sem<~[Waitqueue]> {\n     // The only other places that condvars get built are rwlock.write_cond()\n     // and rwlock_write_mode.\n     pub fn access_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n-        do self.access {\n+        do self.access_waitqueue {\n             blk(&Condvar { sem: self, order: Nothing })\n         }\n     }\n@@ -456,7 +456,9 @@ impl Clone for Mutex {\n \n impl Mutex {\n     /// Run a function with ownership of the mutex.\n-    pub fn lock<U>(&self, blk: &fn() -> U) -> U { (&self.sem).access(blk) }\n+    pub fn lock<U>(&self, blk: &fn() -> U) -> U {\n+        (&self.sem).access_waitqueue(blk)\n+    }\n \n     /// Run a function with ownership of the mutex and a handle to a condvar.\n     pub fn lock_cond<U>(&self, blk: &fn(c: &Condvar) -> U) -> U {\n@@ -559,7 +561,7 @@ impl RWlock {\n         unsafe {\n             do task::unkillable {\n                 (&self.order_lock).acquire();\n-                do (&self.access_lock).access {\n+                do (&self.access_lock).access_waitqueue {\n                     (&self.order_lock).release();\n                     task::rekillable(blk)\n                 }"}, {"sha": "5180a71939c3ad20117d7bd66530a5faea7228f9", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -470,13 +470,14 @@ priv fn format(val: Param, op: FormatOp, flags: Flags) -> Result<~[u8],~str> {\n                         FormatHex|FormatHEX => 16,\n                         FormatString => util::unreachable()\n                     };\n-                    let mut (s,_) = match op {\n+                    let (s,_) = match op {\n                         FormatDigit => {\n                             let sign = if flags.sign { SignAll } else { SignNeg };\n                             to_str_bytes_common(&d, radix, false, sign, DigAll)\n                         }\n                         _ => to_str_bytes_common(&(d as uint), radix, false, SignNone, DigAll)\n                     };\n+                    let mut s = s;\n                     if flags.precision > s.len() {\n                         let mut s_ = vec::with_capacity(flags.precision);\n                         let n = flags.precision - s.len();"}, {"sha": "209b46809ce31d24308ba8dbb2a96cc140f601d0", "filename": "src/libextra/test.rs", "status": "modified", "additions": 121, "deletions": 124, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -19,15 +19,21 @@ use core::prelude::*;\n \n use getopts;\n use sort;\n+use stats::Stats;\n use term;\n+use time::precise_time_ns;\n \n use core::comm::{stream, SharedChan};\n use core::either;\n use core::io;\n+use core::num;\n use core::option;\n+use core::rand::RngUtil;\n+use core::rand;\n use core::result;\n use core::task;\n use core::to_str::ToStr;\n+use core::u64;\n use core::uint;\n use core::vec;\n \n@@ -609,152 +615,143 @@ fn calc_result(desc: &TestDesc, task_succeeded: bool) -> TestResult {\n     }\n }\n \n-pub mod bench {\n-    use core::prelude::*;\n-\n-    use core::num;\n-    use core::rand::RngUtil;\n-    use core::rand;\n-    use core::u64;\n-    use core::vec;\n-    use stats::Stats;\n-    use test::{BenchHarness, BenchSamples};\n-    use time::precise_time_ns;\n-\n-    impl BenchHarness {\n-        /// Callback for benchmark functions to run in their body.\n-        pub fn iter(&mut self, inner:&fn()) {\n-            self.ns_start = precise_time_ns();\n-            let k = self.iterations;\n-            for u64::range(0, k) |_| {\n-                inner();\n-            }\n-            self.ns_end = precise_time_ns();\n+impl BenchHarness {\n+    /// Callback for benchmark functions to run in their body.\n+    pub fn iter(&mut self, inner:&fn()) {\n+        self.ns_start = precise_time_ns();\n+        let k = self.iterations;\n+        for u64::range(0, k) |_| {\n+            inner();\n         }\n+        self.ns_end = precise_time_ns();\n+    }\n \n-        pub fn ns_elapsed(&mut self) -> u64 {\n-            if self.ns_start == 0 || self.ns_end == 0 {\n-                0\n-            } else {\n-                self.ns_end - self.ns_start\n-            }\n+    pub fn ns_elapsed(&mut self) -> u64 {\n+        if self.ns_start == 0 || self.ns_end == 0 {\n+            0\n+        } else {\n+            self.ns_end - self.ns_start\n         }\n+    }\n \n-        pub fn ns_per_iter(&mut self) -> u64 {\n-            if self.iterations == 0 {\n-                0\n-            } else {\n-                self.ns_elapsed() / self.iterations\n-            }\n+    pub fn ns_per_iter(&mut self) -> u64 {\n+        if self.iterations == 0 {\n+            0\n+        } else {\n+            self.ns_elapsed() / self.iterations\n         }\n+    }\n \n-        pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n-            self.iterations = n;\n-            debug!(\"running benchmark for %u iterations\",\n-                   n as uint);\n-            f(self);\n-        }\n+    pub fn bench_n(&mut self, n: u64, f: &fn(&mut BenchHarness)) {\n+        self.iterations = n;\n+        debug!(\"running benchmark for %u iterations\",\n+               n as uint);\n+        f(self);\n+    }\n \n-        // This is the Go benchmark algorithm. It produces a single\n-        // datapoint and always tries to run for 1s.\n-        pub fn go_bench(&mut self, f: &fn(&mut BenchHarness)) {\n-\n-            // Rounds a number down to the nearest power of 10.\n-            fn round_down_10(n: u64) -> u64 {\n-                let mut n = n;\n-                let mut res = 1;\n-                while n > 10 {\n-                    n = n / 10;\n-                    res *= 10;\n-                }\n-                res\n-            }\n+    // This is the Go benchmark algorithm. It produces a single\n+    // datapoint and always tries to run for 1s.\n+    pub fn go_bench(&mut self, f: &fn(&mut BenchHarness)) {\n \n-            // Rounds x up to a number of the form [1eX, 2eX, 5eX].\n-            fn round_up(n: u64) -> u64 {\n-                let base = round_down_10(n);\n-                if n < (2 * base) {\n-                    2 * base\n-                } else if n < (5 * base) {\n-                    5 * base\n-                } else {\n-                    10 * base\n-                }\n+        // Rounds a number down to the nearest power of 10.\n+        fn round_down_10(n: u64) -> u64 {\n+            let mut n = n;\n+            let mut res = 1;\n+            while n > 10 {\n+                n = n / 10;\n+                res *= 10;\n             }\n+            res\n+        }\n \n-            // Initial bench run to get ballpark figure.\n-            let mut n = 1_u64;\n-            self.bench_n(n, f);\n-\n-            while n < 1_000_000_000 &&\n-                self.ns_elapsed() < 1_000_000_000 {\n-                let last = n;\n-\n-                // Try to estimate iter count for 1s falling back to 1bn\n-                // iterations if first run took < 1ns.\n-                if self.ns_per_iter() == 0 {\n-                    n = 1_000_000_000;\n-                } else {\n-                    n = 1_000_000_000 / self.ns_per_iter();\n-                }\n-\n-                n = u64::max(u64::min(n+n/2, 100*last), last+1);\n-                n = round_up(n);\n-                self.bench_n(n, f);\n+        // Rounds x up to a number of the form [1eX, 2eX, 5eX].\n+        fn round_up(n: u64) -> u64 {\n+            let base = round_down_10(n);\n+            if n < (2 * base) {\n+                2 * base\n+            } else if n < (5 * base) {\n+                5 * base\n+            } else {\n+                10 * base\n             }\n         }\n \n-        // This is a more statistics-driven benchmark algorithm.\n-        // It stops as quickly as 50ms, so long as the statistical\n-        // properties are satisfactory. If those properties are\n-        // not met, it may run as long as the Go algorithm.\n-        pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n-\n-            let mut rng = rand::rng();\n-            let mut magnitude = 10;\n-            let mut prev_madp = 0.0;\n+        // Initial bench run to get ballpark figure.\n+        let mut n = 1_u64;\n+        self.bench_n(n, f);\n \n-            loop {\n-                let n_samples = rng.gen_uint_range(50, 60);\n-                let n_iter = rng.gen_uint_range(magnitude,\n-                                                magnitude * 2);\n+        while n < 1_000_000_000 &&\n+            self.ns_elapsed() < 1_000_000_000 {\n+            let last = n;\n \n-                let samples = do vec::from_fn(n_samples) |_| {\n-                    self.bench_n(n_iter as u64, f);\n-                    self.ns_per_iter() as f64\n-                };\n+            // Try to estimate iter count for 1s falling back to 1bn\n+            // iterations if first run took < 1ns.\n+            if self.ns_per_iter() == 0 {\n+                n = 1_000_000_000;\n+            } else {\n+                n = 1_000_000_000 / self.ns_per_iter();\n+            }\n \n-                // Eliminate outliers\n-                let med = samples.median();\n-                let mad = samples.median_abs_dev();\n-                let samples = do vec::filter(samples) |f| {\n-                    num::abs(*f - med) <= 3.0 * mad\n-                };\n+            n = u64::max(u64::min(n+n/2, 100*last), last+1);\n+            n = round_up(n);\n+            self.bench_n(n, f);\n+        }\n+    }\n \n-                debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n-                       n_samples, med as float, mad as float,\n-                       samples.len());\n-\n-                if samples.len() != 0 {\n-                    // If we have _any_ cluster of signal...\n-                    let curr_madp = samples.median_abs_dev_pct();\n-                    if self.ns_elapsed() > 1_000_000 &&\n-                        (curr_madp < 1.0 ||\n-                         num::abs(curr_madp - prev_madp) < 0.1) {\n-                        return samples;\n-                    }\n-                    prev_madp = curr_madp;\n-\n-                    if n_iter > 20_000_000 ||\n-                        self.ns_elapsed() > 20_000_000 {\n-                        return samples;\n-                    }\n+    // This is a more statistics-driven benchmark algorithm.\n+    // It stops as quickly as 50ms, so long as the statistical\n+    // properties are satisfactory. If those properties are\n+    // not met, it may run as long as the Go algorithm.\n+    pub fn auto_bench(&mut self, f: &fn(&mut BenchHarness)) -> ~[f64] {\n+\n+        let mut rng = rand::rng();\n+        let mut magnitude = 10;\n+        let mut prev_madp = 0.0;\n+\n+        loop {\n+            let n_samples = rng.gen_uint_range(50, 60);\n+            let n_iter = rng.gen_uint_range(magnitude,\n+                                            magnitude * 2);\n+\n+            let samples = do vec::from_fn(n_samples) |_| {\n+                self.bench_n(n_iter as u64, f);\n+                self.ns_per_iter() as f64\n+            };\n+\n+            // Eliminate outliers\n+            let med = samples.median();\n+            let mad = samples.median_abs_dev();\n+            let samples = do vec::filter(samples) |f| {\n+                num::abs(*f - med) <= 3.0 * mad\n+            };\n+\n+            debug!(\"%u samples, median %f, MAD=%f, %u survived filter\",\n+                   n_samples, med as float, mad as float,\n+                   samples.len());\n+\n+            if samples.len() != 0 {\n+                // If we have _any_ cluster of signal...\n+                let curr_madp = samples.median_abs_dev_pct();\n+                if self.ns_elapsed() > 1_000_000 &&\n+                    (curr_madp < 1.0 ||\n+                     num::abs(curr_madp - prev_madp) < 0.1) {\n+                    return samples;\n                 }\n+                prev_madp = curr_madp;\n \n-                magnitude *= 2;\n+                if n_iter > 20_000_000 ||\n+                    self.ns_elapsed() > 20_000_000 {\n+                    return samples;\n+                }\n             }\n+\n+            magnitude *= 2;\n         }\n     }\n+}\n+\n+pub mod bench {\n+    use test::{BenchHarness, BenchSamples};\n \n     pub fn benchmark(f: &fn(&mut BenchHarness)) -> BenchSamples {\n "}, {"sha": "931a42d3c5377f2f196aeddbbb0976460c41a8a2", "filename": "src/libextra/time.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftime.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -849,7 +849,7 @@ priv fn do_strftime(format: &str, tm: &Tm) -> ~str {\n     do io::with_str_reader(format) |rdr| {\n         while !rdr.eof() {\n             match rdr.read_char() {\n-                '%' => buf += parse_type(rdr.read_char(), tm),\n+                '%' => buf.push_str(parse_type(rdr.read_char(), tm)),\n                 ch => buf.push_char(ch)\n             }\n         }"}, {"sha": "e23f9113319d0281014a73ccb2d2ddd847e188b4", "filename": "src/libextra/timer.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftimer.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -39,7 +39,7 @@ use core::libc;\n  * * ch - a channel of type T to send a `val` on\n  * * val - a value of type T to send over the provided `ch`\n  */\n-pub fn delayed_send<T:Owned>(iotask: &IoTask,\n+pub fn delayed_send<T:Send>(iotask: &IoTask,\n                               msecs: uint,\n                               ch: &Chan<T>,\n                               val: T) {\n@@ -119,11 +119,12 @@ pub fn sleep(iotask: &IoTask, msecs: uint) {\n  * on the provided port in the allotted timeout period, then the result will\n  * be a `Some(T)`. If not, then `None` will be returned.\n  */\n-pub fn recv_timeout<T:Copy + Owned>(iotask: &IoTask,\n+pub fn recv_timeout<T:Copy + Send>(iotask: &IoTask,\n                                    msecs: uint,\n                                    wait_po: &Port<T>)\n                                    -> Option<T> {\n-    let mut (timeout_po, timeout_ch) = stream::<()>();\n+    let (timeout_po, timeout_ch) = stream::<()>();\n+    let mut timeout_po = timeout_po;\n     delayed_send(iotask, msecs, &timeout_ch, ());\n \n     // XXX: Workaround due to ports and channels not being &mut. They should"}, {"sha": "567f9eda2fbae460159a8c2e6c81b35a9c876732", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -272,7 +272,7 @@ impl Context {\n         }\n     }\n \n-    pub fn prep<T:Owned +\n+    pub fn prep<T:Send +\n                   Encodable<json::Encoder> +\n                   Decodable<json::Decoder>>(@self, // FIXME(#5121)\n                                             fn_name:&str,\n@@ -292,7 +292,7 @@ trait TPrep {\n     fn declare_input(&mut self, kind:&str, name:&str, val:&str);\n     fn is_fresh(&self, cat:&str, kind:&str, name:&str, val:&str) -> bool;\n     fn all_fresh(&self, cat:&str, map:&WorkMap) -> bool;\n-    fn exec<T:Owned +\n+    fn exec<T:Send +\n               Encodable<json::Encoder> +\n               Decodable<json::Decoder>>( // FIXME(#5121)\n         &self, blk: ~fn(&Exec) -> T) -> Work<T>;\n@@ -328,7 +328,7 @@ impl TPrep for Prep {\n         return true;\n     }\n \n-    fn exec<T:Owned +\n+    fn exec<T:Send +\n               Encodable<json::Encoder> +\n               Decodable<json::Decoder>>( // FIXME(#5121)\n             &self, blk: ~fn(&Exec) -> T) -> Work<T> {\n@@ -365,7 +365,7 @@ impl TPrep for Prep {\n     }\n }\n \n-impl<T:Owned +\n+impl<T:Send +\n        Encodable<json::Encoder> +\n        Decodable<json::Decoder>> Work<T> { // FIXME(#5121)\n     pub fn new(p: @mut Prep, e: Either<T,PortOne<(Exec,T)>>) -> Work<T> {\n@@ -374,7 +374,7 @@ impl<T:Owned +\n }\n \n // FIXME (#3724): movable self. This should be in impl Work.\n-fn unwrap<T:Owned +\n+fn unwrap<T:Send +\n             Encodable<json::Encoder> +\n             Decodable<json::Decoder>>( // FIXME(#5121)\n         w: Work<T>) -> T {"}, {"sha": "af23696cbc1a6b882e0172d49bd8164eba8adce0", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -642,15 +642,15 @@ pub fn sanitize(s: &str) -> ~str {\n     for s.iter().advance |c| {\n         match c {\n             // Escape these with $ sequences\n-            '@' => result += \"$SP$\",\n-            '~' => result += \"$UP$\",\n-            '*' => result += \"$RP$\",\n-            '&' => result += \"$BP$\",\n-            '<' => result += \"$LT$\",\n-            '>' => result += \"$GT$\",\n-            '(' => result += \"$LP$\",\n-            ')' => result += \"$RP$\",\n-            ',' => result += \"$C$\",\n+            '@' => result.push_str(\"$SP$\"),\n+            '~' => result.push_str(\"$UP$\"),\n+            '*' => result.push_str(\"$RP$\"),\n+            '&' => result.push_str(\"$BP$\"),\n+            '<' => result.push_str(\"$LT$\"),\n+            '>' => result.push_str(\"$GT$\"),\n+            '(' => result.push_str(\"$LP$\"),\n+            ')' => result.push_str(\"$RP$\"),\n+            ',' => result.push_str(\"$C$\"),\n \n             // '.' doesn't occur in types and functions, so reuse it\n             // for ':'\n@@ -686,12 +686,14 @@ pub fn mangle(sess: Session, ss: path) -> ~str {\n     let mut n = ~\"_ZN\"; // Begin name-sequence.\n \n     for ss.iter().advance |s| {\n-        match *s { path_name(s) | path_mod(s) => {\n-          let sani = sanitize(sess.str_of(s));\n-          n += fmt!(\"%u%s\", sani.len(), sani);\n-        } }\n+        match *s {\n+            path_name(s) | path_mod(s) => {\n+                let sani = sanitize(sess.str_of(s));\n+                n.push_str(fmt!(\"%u%s\", sani.len(), sani));\n+            }\n+        }\n     }\n-    n += \"E\"; // End name-sequence.\n+    n.push_char('E'); // End name-sequence.\n     n\n }\n "}, {"sha": "18693b52fc87eaab11d139b311c5ac4aa8f83775", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -19,7 +19,7 @@ use front;\n use lib::llvm::llvm;\n use metadata::{creader, cstore, filesearch};\n use metadata;\n-use middle::{trans, freevars, kind, ty, typeck, lint, astencode};\n+use middle::{trans, freevars, kind, ty, typeck, lint, astencode, reachable};\n use middle;\n use util::common::time;\n use util::ppaux;\n@@ -299,10 +299,16 @@ pub fn compile_rest(sess: Session,\n         time(time_passes, ~\"kind checking\", ||\n              kind::check_crate(ty_cx, method_map, crate));\n \n+        let reachable_map =\n+            time(time_passes, ~\"reachability checking\", ||\n+                reachable::find_reachable(ty_cx, method_map, crate));\n+\n         time(time_passes, ~\"lint checking\", ||\n              lint::check_crate(ty_cx, crate));\n \n-        if phases.to == cu_no_trans { return (Some(crate), Some(ty_cx)); }\n+        if phases.to == cu_no_trans {\n+            return (Some(crate), Some(ty_cx));\n+        }\n \n         let maps = astencode::Maps {\n             root_map: root_map,\n@@ -315,9 +321,13 @@ pub fn compile_rest(sess: Session,\n \n         let outputs = outputs.get_ref();\n         time(time_passes, ~\"translation\", ||\n-             trans::base::trans_crate(sess, crate, ty_cx,\n+             trans::base::trans_crate(sess,\n+                                      crate,\n+                                      ty_cx,\n                                       &outputs.obj_filename,\n-                                      exp_map2, maps))\n+                                      exp_map2,\n+                                      reachable_map,\n+                                      maps))\n     };\n \n     let outputs = outputs.get_ref();"}, {"sha": "ec86b43ffa3c69981b4951a7614eed78bf7ddf09", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -403,8 +403,12 @@ mod test {\n \n     fn make_crate(with_bin: bool, with_lib: bool) -> @ast::crate {\n         let mut attrs = ~[];\n-        if with_bin { attrs += [make_crate_type_attr(@\"bin\")]; }\n-        if with_lib { attrs += [make_crate_type_attr(@\"lib\")]; }\n+        if with_bin {\n+            attrs.push(make_crate_type_attr(@\"bin\"));\n+        }\n+        if with_lib {\n+            attrs.push(make_crate_type_attr(@\"lib\"));\n+        }\n         @codemap::respan(codemap::dummy_sp(), ast::crate_ {\n             module: ast::_mod { view_items: ~[], items: ~[] },\n             attrs: attrs,"}, {"sha": "e7725436f2b4ff826808cf9706fa0b3d11fd6489", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -176,6 +176,10 @@ pub static tag_item_method_tps: uint = 0x7b;\n pub static tag_item_method_fty: uint = 0x7c;\n pub static tag_item_method_transformed_self_ty: uint = 0x7d;\n \n+pub static tag_mod_child: uint = 0x7e;\n+pub static tag_misc_info: uint = 0x7f;\n+pub static tag_misc_info_crate_items: uint = 0x80;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "4ede9f96f1f401421c466ab4950e8617bf051e03", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -97,18 +97,14 @@ pub fn get_enum_variants(tcx: ty::ctxt, def: ast::def_id)\n     return decoder::get_enum_variants(cstore.intr, cdata, def.node, tcx)\n }\n \n-pub fn get_impls_for_mod(cstore: @mut cstore::CStore, def: ast::def_id,\n-                         name: Option<ast::ident>)\n-                      -> @~[@resolve::Impl] {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    do decoder::get_impls_for_mod(cstore.intr, cdata, def.node, name) |cnum| {\n-        cstore::get_crate_data(cstore, cnum)\n-    }\n+/// Returns information about the given implementation.\n+pub fn get_impl(cstore: @mut cstore::CStore, impl_def_id: ast::def_id)\n+                -> resolve::Impl {\n+    let cdata = cstore::get_crate_data(cstore, impl_def_id.crate);\n+    decoder::get_impl(cstore.intr, cdata, impl_def_id.node)\n }\n \n-pub fn get_method(tcx: ty::ctxt,\n-                  def: ast::def_id) -> ty::Method\n-{\n+pub fn get_method(tcx: ty::ctxt, def: ast::def_id) -> ty::Method {\n     let cdata = cstore::get_crate_data(tcx.cstore, def.crate);\n     decoder::get_method(tcx.cstore.intr, cdata, def.node, tcx)\n }"}, {"sha": "69faf519bc2804f772711a7eea0dc7ebbbbf1e67", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 230, "deletions": 93, "changes": 323, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -458,94 +458,246 @@ pub fn each_lang_item(cdata: cmd, f: &fn(ast::node_id, uint) -> bool) -> bool {\n     return true;\n }\n \n-/// Iterates over all the paths in the given crate.\n-pub fn each_path(intr: @ident_interner,\n-                 cdata: cmd,\n-                 get_crate_data: GetCrateDataCb,\n-                 f: &fn(&str, def_like, ast::visibility) -> bool)\n-                 -> bool {\n-    // FIXME #4572: This function needs to be nuked, as it's impossible to make fast.\n-    // It's the source of most of the performance problems when compiling small crates.\n+struct EachItemContext<'self> {\n+    intr: @ident_interner,\n+    cdata: cmd,\n+    get_crate_data: GetCrateDataCb<'self>,\n+    path_builder: &'self mut ~str,\n+    callback: &'self fn(&str, def_like, ast::visibility) -> bool,\n+}\n \n-    let root = reader::Doc(cdata.data);\n-    let items = reader::get_doc(root, tag_items);\n-    let items_data = reader::get_doc(items, tag_items_data);\n-\n-    // First, go through all the explicit items.\n-    for reader::tagged_docs(items_data, tag_items_data_item) |item_doc| {\n-        let path = ast_map::path_to_str(item_path(item_doc), intr);\n-        let path_is_empty = path.is_empty();\n-        if !path_is_empty {\n-            // Extract the def ID.\n-            let def_id = item_def_id(item_doc, cdata);\n-\n-            // Construct the def for this item.\n-            debug!(\"(each_path) yielding explicit item: %s\", path);\n-            let def_like = item_to_def_like(item_doc, def_id, cdata.cnum);\n-\n-            let vis = item_visibility(item_doc);\n-\n-            // Hand the information off to the iteratee.\n-            if !f(path, def_like, vis) {\n-                return false;\n+impl<'self> EachItemContext<'self> {\n+    // Pushes the given name and returns the old length.\n+    fn push_name(&mut self, string: &str) -> uint {\n+        let path_len = self.path_builder.len();\n+        if path_len != 0 {\n+            self.path_builder.push_str(\"::\")\n+        }\n+        self.path_builder.push_str(string);\n+        path_len\n+    }\n+\n+    // Pops the given name.\n+    fn pop_name(&mut self, old_len: uint) {\n+        // XXX(pcwalton): There's no safe function to do this. :(\n+        unsafe {\n+            str::raw::set_len(self.path_builder, old_len)\n+        }\n+    }\n+\n+    fn process_item_and_pop_name(&mut self,\n+                                 doc: ebml::Doc,\n+                                 def_id: ast::def_id,\n+                                 old_len: uint)\n+                                 -> bool {\n+        let def_like = item_to_def_like(doc, def_id, self.cdata.cnum);\n+        match def_like {\n+            dl_def(def) => {\n+                debug!(\"(iterating over each item of a module) processing \\\n+                        `%s` (def %?)\",\n+                       *self.path_builder,\n+                       def);\n+            }\n+            _ => {\n+                debug!(\"(iterating over each item of a module) processing \\\n+                        `%s` (%d:%d)\",\n+                       *self.path_builder,\n+                       def_id.crate,\n+                       def_id.node);\n             }\n         }\n \n-        // If this is a module, find the reexports.\n-        for each_reexport(item_doc) |reexport_doc| {\n-            let def_id_doc =\n-                reader::get_doc(reexport_doc,\n-                                tag_items_data_item_reexport_def_id);\n-            let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n-            let def_id = translate_def_id(cdata, def_id);\n-\n-            let reexport_name_doc =\n-                reader::get_doc(reexport_doc,\n-                                tag_items_data_item_reexport_name);\n-            let reexport_name = reexport_name_doc.as_str_slice();\n-\n-            let reexport_path;\n-            if path_is_empty {\n-                reexport_path = reexport_name.to_owned();\n+        let vis = item_visibility(doc);\n+\n+        let mut continue = (self.callback)(*self.path_builder, def_like, vis);\n+\n+        let family = item_family(doc);\n+        if family == ForeignMod {\n+            // These are unnamed; pop the name now.\n+            self.pop_name(old_len)\n+        }\n+\n+        if continue {\n+            // Recurse if necessary.\n+            match family {\n+                Mod | ForeignMod | Trait | Impl => {\n+                    continue = self.each_item_of_module(def_id);\n+                }\n+                ImmStatic | MutStatic | Struct | UnsafeFn | Fn | ForeignFn |\n+                UnsafeStaticMethod | StaticMethod | Type | ForeignType |\n+                Variant | Enum | PublicField | PrivateField |\n+                InheritedField => {}\n+            }\n+        }\n+\n+        if family != ForeignMod {\n+            self.pop_name(old_len)\n+        }\n+\n+        continue\n+    }\n+\n+    fn each_item_of_module(&mut self, def_id: ast::def_id) -> bool {\n+        // This item might not be in this crate. If it's not, look it up.\n+        let (cdata, items) = if def_id.crate == self.cdata.cnum {\n+            let items = reader::get_doc(reader::Doc(self.cdata.data),\n+                                        tag_items);\n+            (self.cdata, items)\n+        } else {\n+            let crate_data = (self.get_crate_data)(def_id.crate);\n+            let root = reader::Doc(crate_data.data);\n+            (crate_data, reader::get_doc(root, tag_items))\n+        };\n+\n+        // Look up the item.\n+        let item_doc = match maybe_find_item(def_id.node, items) {\n+            None => return false,\n+            Some(item_doc) => item_doc,\n+        };\n+\n+        self.each_child_of_module_or_crate(item_doc)\n+    }\n+\n+    fn each_child_of_module_or_crate(&mut self, item_doc: ebml::Doc) -> bool {\n+        let mut continue = true;\n+\n+        // Iterate over all children.\n+        for reader::tagged_docs(item_doc, tag_mod_child) |child_info_doc| {\n+            let child_def_id = reader::with_doc_data(child_info_doc,\n+                                                     parse_def_id);\n+            let child_def_id = translate_def_id(self.cdata, child_def_id);\n+\n+            // This item may be in yet another crate, if it was the child of\n+            // a reexport.\n+            let other_crates_items = if child_def_id.crate ==\n+                    self.cdata.cnum {\n+                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n             } else {\n-                reexport_path = path + \"::\" + reexport_name;\n+                let crate_data = (self.get_crate_data)(child_def_id.crate);\n+                let root = reader::Doc(crate_data.data);\n+                reader::get_doc(root, tag_items)\n+            };\n+\n+            debug!(\"(iterating over each item of a module) looking up item \\\n+                    %d:%d in `%s`, crate %d\",\n+                   child_def_id.crate,\n+                   child_def_id.node,\n+                   *self.path_builder,\n+                   self.cdata.cnum);\n+\n+            // Get the item.\n+            match maybe_find_item(child_def_id.node, other_crates_items) {\n+                None => {}\n+                Some(child_item_doc) => {\n+                    // Push the name.\n+                    let child_name = item_name(self.intr, child_item_doc);\n+                    debug!(\"(iterating over each item of a module) pushing \\\n+                            name `%s` onto `%s`\",\n+                           token::ident_to_str(&child_name),\n+                           *self.path_builder);\n+                    let old_len =\n+                        self.push_name(token::ident_to_str(&child_name));\n+\n+                    // Process this item.\n+                    continue = self.process_item_and_pop_name(child_item_doc,\n+                                                              child_def_id,\n+                                                              old_len);\n+\n+                    if !continue {\n+                        break\n+                    }\n+                }\n             }\n+        }\n+\n+        if !continue {\n+            return false\n+        }\n \n-            // This reexport may be in yet another crate\n-            let other_crates_items = if def_id.crate == cdata.cnum {\n-                items\n+        // Iterate over reexports.\n+        for each_reexport(item_doc) |reexport_doc| {\n+            let def_id_doc = reader::get_doc(\n+                reexport_doc,\n+                tag_items_data_item_reexport_def_id);\n+            let orig_def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n+\n+            // NB: was \"cdata\"\n+            let def_id = translate_def_id(self.cdata, orig_def_id);\n+\n+            let name_doc = reader::get_doc(reexport_doc,\n+                                           tag_items_data_item_reexport_name);\n+            let name = name_doc.as_str_slice();\n+\n+            // Push the name.\n+            debug!(\"(iterating over each item of a module) pushing \\\n+                    reexported name `%s` onto `%s` (crate %d, orig %d, \\\n+                    in crate %d)\",\n+                   name,\n+                   *self.path_builder,\n+                   def_id.crate,\n+                   orig_def_id.crate,\n+                   self.cdata.cnum);\n+            let old_len = self.push_name(name);\n+\n+            // This reexport may be in yet another crate.\n+            let other_crates_items = if def_id.crate == self.cdata.cnum {\n+                reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n             } else {\n-                let crate_data = get_crate_data(def_id.crate);\n+                let crate_data = (self.get_crate_data)(def_id.crate);\n                 let root = reader::Doc(crate_data.data);\n                 reader::get_doc(root, tag_items)\n             };\n \n             // Get the item.\n             match maybe_find_item(def_id.node, other_crates_items) {\n                 None => {}\n-                Some(item_doc) => {\n-                    // Construct the def for this item.\n-                    let def_like = item_to_def_like(item_doc,\n-                                                    def_id,\n-                                                    cdata.cnum);\n-\n-                    // Hand the information off to the iteratee.\n-                    debug!(\"(each_path) yielding reexported \\\n-                           item: %s\", reexport_path);\n-\n-                    if (!f(reexport_path, def_like, ast::public)) {\n-                        return false;\n-                    }\n+                Some(reexported_item_doc) => {\n+                    continue = self.process_item_and_pop_name(\n+                        reexported_item_doc,\n+                        def_id,\n+                        old_len);\n                 }\n             }\n+\n+            if !continue {\n+                break\n+            }\n         }\n+\n+        continue\n     }\n+}\n \n-    return true;\n+/// Iterates over all the paths in the given crate.\n+pub fn each_path(intr: @ident_interner,\n+                 cdata: cmd,\n+                 get_crate_data: GetCrateDataCb,\n+                 f: &fn(&str, def_like, ast::visibility) -> bool)\n+                 -> bool {\n+    // FIXME #4572: This function needs to be nuked, as it's impossible to\n+    // make fast. It's the source of most of the performance problems when\n+    // compiling small crates.\n+\n+    let root_doc = reader::Doc(cdata.data);\n+    let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n+    let crate_items_doc = reader::get_doc(misc_info_doc,\n+                                          tag_misc_info_crate_items);\n+\n+    let mut path_builder = ~\"\";\n+\n+    let mut context = EachItemContext {\n+        intr: intr,\n+        cdata: cdata,\n+        get_crate_data: get_crate_data,\n+        path_builder: &mut path_builder,\n+        callback: f,\n+    };\n+\n+    // Iterate over all top-level crate items.\n+    context.each_child_of_module_or_crate(crate_items_doc)\n }\n \n-pub fn get_item_path(cdata: cmd, id: ast::node_id)\n-    -> ast_map::path {\n+pub fn get_item_path(cdata: cmd, id: ast::node_id) -> ast_map::path {\n     item_path(lookup_item(id, cdata.data))\n }\n \n@@ -661,35 +813,20 @@ fn item_impl_methods(intr: @ident_interner, cdata: cmd, item: ebml::Doc,\n     rslt\n }\n \n-pub fn get_impls_for_mod(intr: @ident_interner,\n-                         cdata: cmd,\n-                         m_id: ast::node_id,\n-                         name: Option<ast::ident>,\n-                         get_cdata: &fn(ast::crate_num) -> cmd)\n-                      -> @~[@resolve::Impl] {\n+/// Returns information about the given implementation.\n+pub fn get_impl(intr: @ident_interner, cdata: cmd, impl_id: ast::node_id)\n+                -> resolve::Impl {\n     let data = cdata.data;\n-    let mod_item = lookup_item(m_id, data);\n-    let mut result = ~[];\n-    for reader::tagged_docs(mod_item, tag_mod_impl) |doc| {\n-        let did = reader::with_doc_data(doc, parse_def_id);\n-        let local_did = translate_def_id(cdata, did);\n-        debug!(\"(get impls for mod) getting did %? for '%?'\",\n-               local_did, name);\n-          // The impl may be defined in a different crate. Ask the caller\n-          // to give us the metadata\n-        let impl_cdata = get_cdata(local_did.crate);\n-        let impl_data = impl_cdata.data;\n-        let item = lookup_item(local_did.node, impl_data);\n-        let nm = item_name(intr, item);\n-        if match name { Some(n) => { n == nm } None => { true } } {\n-           let base_tps = item_ty_param_count(item);\n-           result.push(@resolve::Impl {\n-                did: local_did, ident: nm,\n-                methods: item_impl_methods(intr, impl_cdata, item, base_tps)\n-            });\n-        };\n+    let impl_item = lookup_item(impl_id, data);\n+    let base_tps = item_ty_param_count(impl_item);\n+    resolve::Impl {\n+        did: ast::def_id {\n+            crate: cdata.cnum,\n+            node: impl_id,\n+        },\n+        ident: item_name(intr, impl_item),\n+        methods: item_impl_methods(intr, cdata, impl_item, base_tps),\n     }\n-    @result\n }\n \n pub fn get_method_name_and_explicit_self("}, {"sha": "e394c8dcf92f92f48e2959d7038407f492791969", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 197, "deletions": 78, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -16,14 +16,13 @@ use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n-use middle::trans::reachable;\n use middle::ty::node_id_to_type;\n use middle::ty;\n use middle;\n use util::ppaux::ty_to_str;\n \n use core::hash::HashUtil;\n-use core::hashmap::HashMap;\n+use core::hashmap::{HashMap, HashSet};\n use core::int;\n use core::io;\n use core::str;\n@@ -60,13 +59,13 @@ pub type encode_inlined_item<'self> = &'self fn(ecx: &EncodeContext,\n pub struct EncodeParams<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n-    reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'self HashMap<ast::node_id, ~str>,\n     discrim_symbols: &'self HashMap<ast::node_id, @str>,\n     link_meta: &'self LinkMeta,\n     cstore: @mut cstore::CStore,\n-    encode_inlined_item: encode_inlined_item<'self>\n+    encode_inlined_item: encode_inlined_item<'self>,\n+    reachable: @mut HashSet<ast::node_id>,\n }\n \n struct Stats {\n@@ -75,6 +74,7 @@ struct Stats {\n     dep_bytes: uint,\n     lang_item_bytes: uint,\n     link_args_bytes: uint,\n+    misc_bytes: uint,\n     item_bytes: uint,\n     index_bytes: uint,\n     zero_bytes: uint,\n@@ -87,14 +87,14 @@ pub struct EncodeContext<'self> {\n     diag: @span_handler,\n     tcx: ty::ctxt,\n     stats: @mut Stats,\n-    reachable: reachable::map,\n     reexports2: middle::resolve::ExportMap2,\n     item_symbols: &'self HashMap<ast::node_id, ~str>,\n     discrim_symbols: &'self HashMap<ast::node_id, @str>,\n     link_meta: &'self LinkMeta,\n     cstore: &'self cstore::CStore,\n     encode_inlined_item: encode_inlined_item<'self>,\n-    type_abbrevs: abbrev_map\n+    type_abbrevs: abbrev_map,\n+    reachable: @mut HashSet<ast::node_id>,\n }\n \n pub fn reachable(ecx: &EncodeContext, id: node_id) -> bool {\n@@ -157,8 +157,8 @@ fn encode_trait_ref(ebml_w: &mut writer::Encoder,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n \n     ebml_w.start_tag(tag);\n     tyencode::enc_trait_ref(ebml_w.writer, ty_str_ctxt, trait_ref);\n@@ -185,8 +185,8 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     for params.iter().advance |param| {\n         ebml_w.start_tag(tag);\n         tyencode::enc_type_param_def(ebml_w.writer, ty_str_ctxt, param);\n@@ -218,8 +218,8 @@ pub fn write_type(ecx: &EncodeContext,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     tyencode::enc_ty(ebml_w.writer, ty_str_ctxt, typ);\n }\n \n@@ -231,8 +231,8 @@ pub fn write_vstore(ecx: &EncodeContext,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     tyencode::enc_vstore(ebml_w.writer, ty_str_ctxt, vstore);\n }\n \n@@ -264,8 +264,8 @@ fn encode_method_fty(ecx: &EncodeContext,\n         diag: ecx.diag,\n         ds: def_to_str,\n         tcx: ecx.tcx,\n-        reachable: |a| r.contains(&a),\n-        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)};\n+        abbrevs: tyencode::ac_use_abbrevs(ecx.type_abbrevs)\n+    };\n     tyencode::enc_bare_fn_ty(ebml_w.writer, ty_str_ctxt, typ);\n \n     ebml_w.end_tag();\n@@ -473,12 +473,77 @@ fn encode_reexported_static_methods(ecx: &EncodeContext,\n     }\n }\n \n+/// Iterates through \"auxiliary node IDs\", which are node IDs that describe\n+/// top-level items that are sub-items of the given item. Specifically:\n+///\n+/// * For enums, iterates through the node IDs of the variants.\n+///\n+/// * For newtype structs, iterates through the node ID of the constructor.\n+fn each_auxiliary_node_id(item: @item, callback: &fn(node_id) -> bool)\n+                          -> bool {\n+    let mut continue = true;\n+    match item.node {\n+        item_enum(ref enum_def, _) => {\n+            for enum_def.variants.iter().advance |variant| {\n+                continue = callback(variant.node.id);\n+                if !continue {\n+                    break\n+                }\n+            }\n+        }\n+        item_struct(struct_def, _) => {\n+            // If this is a newtype struct, return the constructor.\n+            match struct_def.ctor_id {\n+                Some(ctor_id) if struct_def.fields.len() > 0 &&\n+                        struct_def.fields[0].node.kind ==\n+                        ast::unnamed_field => {\n+                    continue = callback(ctor_id);\n+                }\n+                _ => {}\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    continue\n+}\n+\n+fn encode_reexports(ecx: &EncodeContext,\n+                    ebml_w: &mut writer::Encoder,\n+                    id: node_id,\n+                    path: &[ast_map::path_elt]) {\n+    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+    match ecx.reexports2.find(&id) {\n+        Some(ref exports) => {\n+            debug!(\"(encoding info for module) found reexports for %d\", id);\n+            for exports.iter().advance |exp| {\n+                debug!(\"(encoding info for module) reexport '%s' for %d\",\n+                       exp.name, id);\n+                ebml_w.start_tag(tag_items_data_item_reexport);\n+                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n+                ebml_w.wr_str(def_to_str(exp.def_id));\n+                ebml_w.end_tag();\n+                ebml_w.start_tag(tag_items_data_item_reexport_name);\n+                ebml_w.wr_str(exp.name);\n+                ebml_w.end_tag();\n+                ebml_w.end_tag();\n+                encode_reexported_static_methods(ecx, ebml_w, path, exp);\n+            }\n+        }\n+        None => {\n+            debug!(\"(encoding info for module) found no reexports for %d\",\n+                   id);\n+        }\n+    }\n+}\n+\n fn encode_info_for_mod(ecx: &EncodeContext,\n                        ebml_w: &mut writer::Encoder,\n                        md: &_mod,\n                        id: node_id,\n                        path: &[ast_map::path_elt],\n-                       name: ident) {\n+                       name: ident,\n+                       vis: visibility) {\n     ebml_w.start_tag(tag_items_data_item);\n     encode_def_id(ebml_w, local_def(id));\n     encode_family(ebml_w, 'm');\n@@ -487,6 +552,16 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n \n     // Encode info about all the module children.\n     for md.items.iter().advance |item| {\n+        ebml_w.start_tag(tag_mod_child);\n+        ebml_w.wr_str(def_to_str(local_def(item.id)));\n+        ebml_w.end_tag();\n+\n+        for each_auxiliary_node_id(*item) |auxiliary_node_id| {\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n+            ebml_w.end_tag();\n+        }\n+\n         match item.node {\n             item_impl(*) => {\n                 let (ident, did) = (item.ident, item.id);\n@@ -500,35 +575,16 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                 ebml_w.wr_str(def_to_str(local_def(did)));\n                 ebml_w.end_tag();\n             }\n-            _ => {} // FIXME #4573: Encode these too.\n+            _ => {}\n         }\n     }\n \n     encode_path(ecx, ebml_w, path, ast_map::path_mod(name));\n \n-    // Encode the reexports of this module.\n-    debug!(\"(encoding info for module) encoding reexports for %d\", id);\n-    match ecx.reexports2.find(&id) {\n-        Some(ref exports) => {\n-            debug!(\"(encoding info for module) found reexports for %d\", id);\n-            for exports.iter().advance |exp| {\n-                debug!(\"(encoding info for module) reexport '%s' for %d\",\n-                       exp.name, id);\n-                ebml_w.start_tag(tag_items_data_item_reexport);\n-                ebml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                ebml_w.wr_str(def_to_str(exp.def_id));\n-                ebml_w.end_tag();\n-                ebml_w.start_tag(tag_items_data_item_reexport_name);\n-                ebml_w.wr_str(exp.name);\n-                ebml_w.end_tag();\n-                ebml_w.end_tag();\n-                encode_reexported_static_methods(ecx, ebml_w, path, exp);\n-            }\n-        }\n-        None => {\n-            debug!(\"(encoding info for module) found no reexports for %d\",\n-                   id);\n-        }\n+    // Encode the reexports of this module, if this module is public.\n+    if vis == public {\n+        debug!(\"(encoding info for module) encoding reexports for %d\", id);\n+        encode_reexports(ecx, ebml_w, id, path);\n     }\n \n     ebml_w.end_tag();\n@@ -780,13 +836,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         index: @mut ~[entry<int>],\n                         path: &[ast_map::path_elt]) {\n     let tcx = ecx.tcx;\n-    let must_write =\n-        match item.node {\n-          item_enum(_, _) | item_impl(*) | item_trait(*) | item_struct(*) |\n-          item_mod(*) | item_foreign_mod(*) | item_static(*) => true,\n-          _ => false\n-        };\n-    if !must_write && !reachable(ecx, item.id) { return; }\n \n     fn add_to_index_(item: @item, ebml_w: &writer::Encoder,\n                      index: @mut ~[entry<int>]) {\n@@ -809,6 +858,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n         encode_symbol(ecx, ebml_w, item.id);\n+        encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         ebml_w.end_tag();\n@@ -821,6 +871,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let tps_len = generics.ty_params.len();\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n+        encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_attributes(ebml_w, item.attrs);\n         if tps_len > 0u || should_inline(item.attrs) {\n@@ -832,15 +883,29 @@ fn encode_info_for_item(ecx: &EncodeContext,\n       }\n       item_mod(ref m) => {\n         add_to_index();\n-        encode_info_for_mod(ecx, ebml_w, m, item.id, path, item.ident);\n+        encode_info_for_mod(ecx,\n+                            ebml_w,\n+                            m,\n+                            item.id,\n+                            path,\n+                            item.ident,\n+                            item.vis);\n       }\n-      item_foreign_mod(_) => {\n+      item_foreign_mod(ref fm) => {\n         add_to_index();\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, local_def(item.id));\n         encode_family(ebml_w, 'n');\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n+\n+        // Encode all the items in this module.\n+        for fm.items.iter().advance |foreign_item| {\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(local_def(foreign_item.id)));\n+            ebml_w.end_tag();\n+        }\n+\n         ebml_w.end_tag();\n       }\n       item_ty(_, ref generics) => {\n@@ -898,23 +963,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(tcx, item.id));\n \n-        // If this is a tuple- or enum-like struct, encode the type of the\n-        // constructor.\n-        if struct_def.fields.len() > 0 &&\n-                struct_def.fields[0].node.kind == ast::unnamed_field {\n-            let ctor_id = match struct_def.ctor_id {\n-                Some(ctor_id) => ctor_id,\n-                None => ecx.tcx.sess.bug(\"struct def didn't have ctor id\"),\n-            };\n-\n-            encode_info_for_struct_ctor(ecx,\n-                                        ebml_w,\n-                                        path,\n-                                        item.ident,\n-                                        ctor_id,\n-                                        index);\n-        }\n-\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n@@ -944,6 +992,23 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         let bkts = create_index(idx);\n         encode_index(ebml_w, bkts, write_int);\n         ebml_w.end_tag();\n+\n+        // If this is a tuple- or enum-like struct, encode the type of the\n+        // constructor.\n+        if struct_def.fields.len() > 0 &&\n+                struct_def.fields[0].node.kind == ast::unnamed_field {\n+            let ctor_id = match struct_def.ctor_id {\n+                Some(ctor_id) => ctor_id,\n+                None => ecx.tcx.sess.bug(\"struct def didn't have ctor id\"),\n+            };\n+\n+            encode_info_for_struct_ctor(ecx,\n+                                        ebml_w,\n+                                        path,\n+                                        item.ident,\n+                                        ctor_id,\n+                                        index);\n+        }\n       }\n       item_impl(ref generics, opt_trait, ty, ref methods) => {\n         add_to_index();\n@@ -979,7 +1044,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         // >:-<\n         let mut impl_path = vec::append(~[], path);\n-        impl_path += [ast_map::path_name(item.ident)];\n+        impl_path.push(ast_map::path_name(item.ident));\n \n         for methods.iter().advance |m| {\n             index.push(entry {val: m.id, pos: ebml_w.writer.tell()});\n@@ -1008,6 +1073,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             ebml_w.start_tag(tag_item_trait_method);\n             encode_def_id(ebml_w, method_def_id);\n             ebml_w.end_tag();\n+\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(method_def_id));\n+            ebml_w.end_tag();\n         }\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         for super_traits.iter().advance |ast_trait_ref| {\n@@ -1092,7 +1161,6 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n                                 index: @mut ~[entry<int>],\n                                 path: ast_map::path,\n                                 abi: AbiSet) {\n-    if !reachable(ecx, nitem.id) { return; }\n     index.push(entry { val: nitem.id, pos: ebml_w.writer.tell() });\n \n     ebml_w.start_tag(tag_items_data_item);\n@@ -1102,6 +1170,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_family(ebml_w, purity_fn_family(purity));\n         encode_type_param_bounds(ebml_w, ecx, &generics.ty_params);\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n+        encode_name(ecx, ebml_w, nitem.ident);\n         if abi.is_intrinsic() {\n             (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_foreign(nitem));\n         } else {\n@@ -1118,6 +1187,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         }\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.tcx, nitem.id));\n         encode_symbol(ecx, ebml_w, nitem.id);\n+        encode_name(ecx, ebml_w, nitem.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n     }\n@@ -1131,9 +1201,13 @@ fn encode_info_for_items(ecx: &EncodeContext,\n     let index = @mut ~[];\n     ebml_w.start_tag(tag_items_data);\n     index.push(entry { val: crate_node_id, pos: ebml_w.writer.tell() });\n-    encode_info_for_mod(ecx, ebml_w, &crate.node.module,\n-                        crate_node_id, [],\n-                        syntax::parse::token::special_idents::invalid);\n+    encode_info_for_mod(ecx,\n+                        ebml_w,\n+                        &crate.node.module,\n+                        crate_node_id,\n+                        [],\n+                        syntax::parse::token::special_idents::invalid,\n+                        public);\n     let items = ecx.tcx.items;\n \n     // See comment in `encode_side_tables_for_ii` in astencode\n@@ -1162,6 +1236,12 @@ fn encode_info_for_items(ecx: &EncodeContext,\n                 visit::visit_foreign_item(ni, (cx, v));\n                 match items.get_copy(&ni.id) {\n                     ast_map::node_foreign_item(_, abi, _, pt) => {\n+                        debug!(\"writing foreign item %s::%s\",\n+                               ast_map::path_to_str(\n+                                *pt,\n+                                token::get_ident_interner()),\n+                                token::ident_to_str(&ni.ident));\n+\n                         let mut ebml_w = copy ebml_w;\n                         // See above\n                         let ecx : &EncodeContext = unsafe { cast::transmute(ecx_ptr) };\n@@ -1421,6 +1501,30 @@ fn encode_link_args(ecx: &EncodeContext, ebml_w: &mut writer::Encoder) {\n     ebml_w.end_tag();\n }\n \n+fn encode_misc_info(ecx: &EncodeContext,\n+                    crate: &crate,\n+                    ebml_w: &mut writer::Encoder) {\n+    ebml_w.start_tag(tag_misc_info);\n+    ebml_w.start_tag(tag_misc_info_crate_items);\n+    for crate.node.module.items.iter().advance |&item| {\n+        ebml_w.start_tag(tag_mod_child);\n+        ebml_w.wr_str(def_to_str(local_def(item.id)));\n+        ebml_w.end_tag();\n+\n+        for each_auxiliary_node_id(item) |auxiliary_node_id| {\n+            ebml_w.start_tag(tag_mod_child);\n+            ebml_w.wr_str(def_to_str(local_def(auxiliary_node_id)));\n+            ebml_w.end_tag();\n+        }\n+    }\n+\n+    // Encode reexports for the root module.\n+    encode_reexports(ecx, ebml_w, 0, []);\n+\n+    ebml_w.end_tag();\n+    ebml_w.end_tag();\n+}\n+\n fn encode_crate_dep(ecx: &EncodeContext,\n                     ebml_w: &mut writer::Encoder,\n                     dep: decoder::crate_dep) {\n@@ -1460,29 +1564,39 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         dep_bytes: 0,\n         lang_item_bytes: 0,\n         link_args_bytes: 0,\n+        misc_bytes: 0,\n         item_bytes: 0,\n         index_bytes: 0,\n         zero_bytes: 0,\n         total_bytes: 0,\n         n_inlines: 0\n     };\n-    let EncodeParams{item_symbols, diag, tcx, reachable, reexports2,\n-                     discrim_symbols, cstore, encode_inlined_item,\n-                     link_meta, _} = parms;\n+    let EncodeParams {\n+        item_symbols,\n+        diag,\n+        tcx,\n+        reexports2,\n+        discrim_symbols,\n+        cstore,\n+        encode_inlined_item,\n+        link_meta,\n+        reachable,\n+        _\n+    } = parms;\n     let type_abbrevs = @mut HashMap::new();\n     let stats = @mut stats;\n     let ecx = EncodeContext {\n         diag: diag,\n         tcx: tcx,\n         stats: stats,\n-        reachable: reachable,\n         reexports2: reexports2,\n         item_symbols: item_symbols,\n         discrim_symbols: discrim_symbols,\n         link_meta: link_meta,\n         cstore: cstore,\n         encode_inlined_item: encode_inlined_item,\n-        type_abbrevs: type_abbrevs\n+        type_abbrevs: type_abbrevs,\n+        reachable: reachable,\n      };\n \n     let mut ebml_w = writer::Encoder(wr as @io::Writer);\n@@ -1508,6 +1622,11 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n     encode_link_args(&ecx, &mut ebml_w);\n     ecx.stats.link_args_bytes = *wr.pos - i;\n \n+    // Encode miscellaneous info.\n+    i = *wr.pos;\n+    encode_misc_info(&ecx, crate, &mut ebml_w);\n+    ecx.stats.misc_bytes = *wr.pos - i;\n+\n     // Encode and index the items.\n     ebml_w.start_tag(tag_items);\n     i = *wr.pos;\n@@ -1535,6 +1654,7 @@ pub fn encode_metadata(parms: EncodeParams, crate: &crate) -> ~[u8] {\n         io::println(fmt!(\"       dep bytes: %u\", ecx.stats.dep_bytes));\n         io::println(fmt!(\" lang item bytes: %u\", ecx.stats.lang_item_bytes));\n         io::println(fmt!(\" link args bytes: %u\", ecx.stats.link_args_bytes));\n+        io::println(fmt!(\"      misc bytes: %u\", ecx.stats.misc_bytes));\n         io::println(fmt!(\"      item bytes: %u\", ecx.stats.item_bytes));\n         io::println(fmt!(\"     index bytes: %u\", ecx.stats.index_bytes));\n         io::println(fmt!(\"      zero bytes: %u\", ecx.stats.zero_bytes));\n@@ -1557,7 +1677,6 @@ pub fn encoded_ty(tcx: ty::ctxt, t: ty::t) -> ~str {\n         diag: tcx.diag,\n         ds: def_to_str,\n         tcx: tcx,\n-        reachable: |_id| false,\n         abbrevs: tyencode::ac_no_abbrevs};\n     do io::with_str_writer |wr| {\n         tyencode::enc_ty(wr, cx, t);"}, {"sha": "1ec5c983f624819bc697666cf6c21de838317ae8", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -261,7 +261,9 @@ fn parse_opt<T>(st: &mut PState, f: &fn(&mut PState) -> T) -> Option<T> {\n fn parse_str(st: &mut PState, term: char) -> ~str {\n     let mut result = ~\"\";\n     while peek(st) != term {\n-        result += str::from_byte(next_byte(st));\n+        unsafe {\n+            str::raw::push_byte(&mut result, next_byte(st));\n+        }\n     }\n     next(st);\n     return result;\n@@ -554,13 +556,13 @@ fn parse_bounds(st: &mut PState, conv: conv_did) -> ty::ParamBounds {\n     loop {\n         match next(st) {\n             'S' => {\n-                param_bounds.builtin_bounds.add(ty::BoundOwned);\n+                param_bounds.builtin_bounds.add(ty::BoundSend);\n             }\n             'C' => {\n                 param_bounds.builtin_bounds.add(ty::BoundCopy);\n             }\n             'K' => {\n-                param_bounds.builtin_bounds.add(ty::BoundConst);\n+                param_bounds.builtin_bounds.add(ty::BoundFreeze);\n             }\n             'O' => {\n                 param_bounds.builtin_bounds.add(ty::BoundStatic);"}, {"sha": "fb72617b743fc017f7fe995932faaa9b22aa2a99", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -31,7 +31,6 @@ pub struct ctxt {\n     ds: @fn(def_id) -> ~str,\n     // The type context.\n     tcx: ty::ctxt,\n-    reachable: @fn(node_id) -> bool,\n     abbrevs: abbrev_ctxt\n }\n \n@@ -401,9 +400,9 @@ fn enc_fn_sig(w: @io::Writer, cx: @ctxt, fsig: &ty::FnSig) {\n fn enc_bounds(w: @io::Writer, cx: @ctxt, bs: &ty::ParamBounds) {\n     for bs.builtin_bounds.each |bound| {\n         match bound {\n-            ty::BoundOwned => w.write_char('S'),\n+            ty::BoundSend => w.write_char('S'),\n             ty::BoundCopy => w.write_char('C'),\n-            ty::BoundConst => w.write_char('K'),\n+            ty::BoundFreeze => w.write_char('K'),\n             ty::BoundStatic => w.write_char('O'),\n             ty::BoundSized => w.write_char('Z'),\n         }"}, {"sha": "70e94844319e7922379fe382998e24df9dfb021c", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -368,14 +368,17 @@ impl tr for ast::def {\n             ast::def_static_method(did.tr(xcx),\n                                    did2_opt.map(|did2| did2.tr(xcx)),\n                                    p)\n-          },\n-          ast::def_self_ty(nid) => ast::def_self_ty(xcx.tr_id(nid)),\n-          ast::def_self(nid, i) => ast::def_self(xcx.tr_id(nid), i),\n-          ast::def_mod(did) => ast::def_mod(did.tr(xcx)),\n-          ast::def_foreign_mod(did) => ast::def_foreign_mod(did.tr(xcx)),\n-          ast::def_static(did, m) => ast::def_static(did.tr(xcx), m),\n-          ast::def_arg(nid, b) => ast::def_arg(xcx.tr_id(nid), b),\n-          ast::def_local(nid, b) => ast::def_local(xcx.tr_id(nid), b),\n+          }\n+          ast::def_method(did0, did1) => {\n+            ast::def_method(did0.tr(xcx), did1.map(|did1| did1.tr(xcx)))\n+          }\n+          ast::def_self_ty(nid) => { ast::def_self_ty(xcx.tr_id(nid)) }\n+          ast::def_self(nid, i) => { ast::def_self(xcx.tr_id(nid), i) }\n+          ast::def_mod(did) => { ast::def_mod(did.tr(xcx)) }\n+          ast::def_foreign_mod(did) => { ast::def_foreign_mod(did.tr(xcx)) }\n+          ast::def_static(did, m) => { ast::def_static(did.tr(xcx), m) }\n+          ast::def_arg(nid, b) => { ast::def_arg(xcx.tr_id(nid), b) }\n+          ast::def_local(nid, b) => { ast::def_local(xcx.tr_id(nid), b) }\n           ast::def_variant(e_did, v_did) => {\n             ast::def_variant(e_did.tr(xcx), v_did.tr(xcx))\n           },\n@@ -692,12 +695,12 @@ trait get_ty_str_ctxt {\n \n impl<'self> get_ty_str_ctxt for e::EncodeContext<'self> {\n     fn ty_str_ctxt(&self) -> @tyencode::ctxt {\n-        let r = self.reachable;\n-        @tyencode::ctxt {diag: self.tcx.sess.diagnostic(),\n-                        ds: e::def_to_str,\n-                        tcx: self.tcx,\n-                        reachable: |a| r.contains(&a),\n-                        abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)}\n+        @tyencode::ctxt {\n+            diag: self.tcx.sess.diagnostic(),\n+            ds: e::def_to_str,\n+            tcx: self.tcx,\n+            abbrevs: tyencode::ac_use_abbrevs(self.type_abbrevs)\n+        }\n     }\n }\n "}, {"sha": "8bb5c4620ef78e196467fa77d3561fcadc557e43", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -359,7 +359,7 @@ of its owner:\n     LIFETIME(LV.f, LT, MQ)              // L-Field\n       LIFETIME(LV, LT, MQ)\n \n-    LIFETIME(*LV, LT, MQ)               // L-Deref-Owned\n+    LIFETIME(*LV, LT, MQ)               // L-Deref-Send\n       TYPE(LV) = ~Ty\n       LIFETIME(LV, LT, MQ)\n \n@@ -504,7 +504,7 @@ must prevent the owned pointer `LV` from being mutated, which means\n that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n on `LV`:\n \n-    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Owned-Pointer\n+    RESTRICTIONS(*LV, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n       TYPE(LV) = ~Ty\n       RESTRICTIONS(LV, ACTIONS|MUTATE|CLAIM) = RS\n \n@@ -539,14 +539,14 @@ mutable borrowed pointers.\n \n ### Restrictions for loans of const aliasable pointees\n \n-Const pointers are read-only. There may be `&mut` or `&` aliases, and\n+Freeze pointers are read-only. There may be `&mut` or `&` aliases, and\n we can not prevent *anything* but moves in that case. So the\n `RESTRICTIONS` function is only defined if `ACTIONS` is the empty set.\n Because moves from a `&const` or `@const` lvalue are never legal, it\n is not necessary to add any restrictions at all to the final\n result.\n \n-    RESTRICTIONS(*LV, []) = []                         // R-Deref-Const-Borrowed\n+    RESTRICTIONS(*LV, []) = []                         // R-Deref-Freeze-Borrowed\n       TYPE(LV) = &const Ty or @const Ty\n \n ### Restrictions for loans of mutable borrowed pointees"}, {"sha": "131ee5aa067b4c77a6b32811b93d0aa20eeb4909", "filename": "src/librustc/middle/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -109,7 +109,7 @@ impl GuaranteeLifetimeContext {\n             }\n \n             mc::cat_downcast(base) |\n-            mc::cat_deref(base, _, mc::uniq_ptr(*)) |  // L-Deref-Owned\n+            mc::cat_deref(base, _, mc::uniq_ptr(*)) |  // L-Deref-Send\n             mc::cat_interior(base, _) => {             // L-Field\n                 self.check(base, discr_scope)\n             }"}, {"sha": "5f4251ad0a424a6448d3a1bae870088e223d08e8", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -103,7 +103,7 @@ impl RestrictionsContext {\n             }\n \n             mc::cat_deref(cmt_base, _, mc::uniq_ptr(*)) => {\n-                // R-Deref-Owned-Pointer\n+                // R-Deref-Send-Pointer\n                 //\n                 // When we borrow the interior of an owned pointer, we\n                 // cannot permit the base to be mutated, because that\n@@ -125,7 +125,7 @@ impl RestrictionsContext {\n \n             mc::cat_deref(_, _, mc::region_ptr(m_const, _)) |\n             mc::cat_deref(_, _, mc::gc_ptr(m_const)) => {\n-                // R-Deref-Const-Borrowed\n+                // R-Deref-Freeze-Borrowed\n                 self.check_no_mutability_control(cmt, restrictions);\n                 Safe\n             }"}, {"sha": "f0c091ac53caeed798d21aece3433aab794456fc", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -31,21 +31,21 @@ use syntax::{visit, ast_util};\n //\n //  send: Things that can be sent on channels or included in spawned closures.\n //  copy: Things that can be copied.\n-//  const: Things thare are deeply immutable. They are guaranteed never to\n+//  freeze: Things thare are deeply immutable. They are guaranteed never to\n //    change, and can be safely shared without copying between tasks.\n-//  owned: Things that do not contain borrowed pointers.\n+//  'static: Things that do not contain borrowed pointers.\n //\n // Send includes scalar types as well as classes and unique types containing\n // only sendable types.\n //\n // Copy includes boxes, closure and unique types containing copyable types.\n //\n-// Const include scalar types, things without non-const fields, and pointers\n-// to const things.\n+// Freeze include scalar types, things without non-const fields, and pointers\n+// to freezable things.\n //\n // This pass ensures that type parameters are only instantiated with types\n // whose kinds are equal or less general than the way the type parameter was\n-// annotated (with the `send`, `copy` or `const` keyword).\n+// annotated (with the `Send`, `Copy` or `Freeze` bound).\n //\n // It also verifies that noncopyable kinds are not copied. Sendability is not\n // applied, since none of our language primitives send. Instead, the sending\n@@ -90,18 +90,18 @@ fn check_struct_safe_for_destructor(cx: Context,\n             self_ty: None,\n             tps: ~[]\n         });\n-        if !ty::type_is_owned(cx.tcx, struct_ty) {\n+        if !ty::type_is_sendable(cx.tcx, struct_ty) {\n             cx.tcx.sess.span_err(span,\n-                                 \"cannot implement a destructor on a struct \\\n-                                  that is not Owned\");\n+                                 \"cannot implement a destructor on a \\\n+                                  structure that does not satisfy Send\");\n             cx.tcx.sess.span_note(span,\n                                   \"use \\\"#[unsafe_destructor]\\\" on the \\\n                                    implementation to force the compiler to \\\n                                    allow this\");\n         }\n     } else {\n         cx.tcx.sess.span_err(span,\n-                             \"cannot implement a destructor on a struct \\\n+                             \"cannot implement a destructor on a structure \\\n                               with type parameters\");\n         cx.tcx.sess.span_note(span,\n                               \"use \\\"#[unsafe_destructor]\\\" on the \\\n@@ -438,10 +438,10 @@ fn check_copy(cx: Context, ty: ty::t, sp: span, reason: &str) {\n     }\n }\n \n-pub fn check_owned(cx: Context, ty: ty::t, sp: span) -> bool {\n-    if !ty::type_is_owned(cx.tcx, ty) {\n+pub fn check_send(cx: Context, ty: ty::t, sp: span) -> bool {\n+    if !ty::type_is_sendable(cx.tcx, ty) {\n         cx.tcx.sess.span_err(\n-            sp, fmt!(\"value has non-owned type `%s`\",\n+            sp, fmt!(\"value has non-sendable type `%s`\",\n                      ty_to_str(cx.tcx, ty)));\n         false\n     } else {\n@@ -489,7 +489,7 @@ pub fn check_durable(tcx: ty::ctxt, ty: ty::t, sp: span) -> bool {\n /// `deque<T>`, then whatever borrowed ptrs may appear in `T` also\n /// appear in `deque<T>`.\n ///\n-/// (3) The type parameter is owned (and therefore does not contain\n+/// (3) The type parameter is sendable (and therefore does not contain\n /// borrowed ptrs).\n ///\n /// FIXME(#5723)---This code should probably move into regionck.\n@@ -528,7 +528,7 @@ pub fn check_cast_for_escaping_regions(\n     }\n \n     // Assuming the trait instance can escape, then ensure that each parameter\n-    // either appears in the trait type or is owned.\n+    // either appears in the trait type or is sendable.\n     let target_params = ty::param_tys_in_type(target_ty);\n     let source_ty = ty::expr_ty(cx.tcx, source);\n     ty::walk_regions_and_ty(\n@@ -574,3 +574,4 @@ pub fn check_cast_for_escaping_regions(\n         cx.tcx.region_maps.is_subregion_of(r_sub, r_sup)\n     }\n }\n+"}, {"sha": "08e55df5b368d367f631897283472d2d2383cb12", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -13,9 +13,9 @@\n // Language items are items that represent concepts intrinsic to the language\n // itself. Examples are:\n //\n-// * Traits that specify \"kinds\"; e.g. \"const\", \"copy\", \"owned\".\n+// * Traits that specify \"kinds\"; e.g. \"Freeze\", \"Copy\", \"Send\".\n //\n-// * Traits that represent operators; e.g. \"add\", \"sub\", \"index\".\n+// * Traits that represent operators; e.g. \"Add\", \"Sub\", \"Index\".\n //\n // * Functions called by the compiler itself.\n \n@@ -33,9 +33,9 @@ use syntax::visit::visit_crate;\n use core::hashmap::HashMap;\n \n pub enum LangItem {\n-    ConstTraitLangItem,         // 0\n+    FreezeTraitLangItem,        // 0\n     CopyTraitLangItem,          // 1\n-    OwnedTraitLangItem,         // 2\n+    SendTraitLangItem,          // 2\n     SizedTraitLangItem,         // 3\n \n     DropTraitLangItem,          // 4\n@@ -99,9 +99,9 @@ impl LanguageItems {\n \n     pub fn item_name(index: uint) -> &'static str {\n         match index {\n-            0  => \"const\",\n+            0  => \"freeze\",\n             1  => \"copy\",\n-            2  => \"owned\",\n+            2  => \"send\",\n             3  => \"sized\",\n \n             4  => \"drop\",\n@@ -152,14 +152,14 @@ impl LanguageItems {\n \n     // FIXME #4621: Method macros sure would be nice here.\n \n-    pub fn const_trait(&const self) -> def_id {\n-        self.items[ConstTraitLangItem as uint].get()\n+    pub fn freeze_trait(&const self) -> def_id {\n+        self.items[FreezeTraitLangItem as uint].get()\n     }\n     pub fn copy_trait(&const self) -> def_id {\n         self.items[CopyTraitLangItem as uint].get()\n     }\n-    pub fn owned_trait(&const self) -> def_id {\n-        self.items[OwnedTraitLangItem as uint].get()\n+    pub fn send_trait(&const self) -> def_id {\n+        self.items[SendTraitLangItem as uint].get()\n     }\n     pub fn sized_trait(&const self) -> def_id {\n         self.items[SizedTraitLangItem as uint].get()\n@@ -291,13 +291,13 @@ struct LanguageItemCollector<'self> {\n }\n \n impl<'self> LanguageItemCollector<'self> {\n-\n-    pub fn new<'a>(crate: &'a crate, session: Session) -> LanguageItemCollector<'a> {\n+    pub fn new<'a>(crate: &'a crate, session: Session)\n+                   -> LanguageItemCollector<'a> {\n         let mut item_refs = HashMap::new();\n \n-        item_refs.insert(@\"const\", ConstTraitLangItem as uint);\n+        item_refs.insert(@\"freeze\", FreezeTraitLangItem as uint);\n         item_refs.insert(@\"copy\", CopyTraitLangItem as uint);\n-        item_refs.insert(@\"owned\", OwnedTraitLangItem as uint);\n+        item_refs.insert(@\"send\", SendTraitLangItem as uint);\n         item_refs.insert(@\"sized\", SizedTraitLangItem as uint);\n \n         item_refs.insert(@\"drop\", DropTraitLangItem as uint);"}, {"sha": "52c01fa76476bb6b3204b1c395032b49a671b1c9", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -452,7 +452,7 @@ impl mem_categorization_ctxt {\n           ast::def_trait(_) | ast::def_ty(_) | ast::def_prim_ty(_) |\n           ast::def_ty_param(*) | ast::def_struct(*) |\n           ast::def_typaram_binder(*) | ast::def_region(_) |\n-          ast::def_label(_) | ast::def_self_ty(*) => {\n+          ast::def_label(_) | ast::def_self_ty(*) | ast::def_method(*) => {\n               @cmt_ {\n                   id:id,\n                   span:span,"}, {"sha": "88bd9c1f6f4aa62bb3cd51149dc640500d1894a6", "filename": "src/librustc/middle/reachable.rs", "status": "added", "additions": 438, "deletions": 0, "changes": 438, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -0,0 +1,438 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Finds items that are externally reachable, to determine which items\n+// need to have their metadata (and possibly their AST) serialized.\n+// All items that can be referred to through an exported name are\n+// reachable, and when a reachable thing is inline or generic, it\n+// makes all other generics or inline functions that it references\n+// reachable as well.\n+\n+use core::prelude::*;\n+use core::iterator::IteratorUtil;\n+\n+use middle::resolve;\n+use middle::ty;\n+use middle::typeck;\n+\n+use core::hashmap::HashSet;\n+use syntax::ast::*;\n+use syntax::ast;\n+use syntax::ast_map;\n+use syntax::ast_util::def_id_of_def;\n+use syntax::attr;\n+use syntax::codemap;\n+use syntax::parse::token;\n+use syntax::visit::Visitor;\n+use syntax::visit;\n+\n+// Returns true if the given set of attributes contains the `#[inline]`\n+// attribute.\n+fn attributes_specify_inlining(attrs: &[attribute]) -> bool {\n+    attr::attrs_contains_name(attrs, \"inline\")\n+}\n+\n+// Returns true if the given set of generics implies that the item it's\n+// associated with must be inlined.\n+fn generics_require_inlining(generics: &Generics) -> bool {\n+    !generics.ty_params.is_empty()\n+}\n+\n+// Returns true if the given item must be inlined because it may be\n+// monomorphized or it was marked with `#[inline]`. This will only return\n+// true for functions.\n+fn item_might_be_inlined(item: @item) -> bool {\n+    if attributes_specify_inlining(item.attrs) {\n+        return true\n+    }\n+\n+    match item.node {\n+        item_fn(_, _, _, ref generics, _) => {\n+            generics_require_inlining(generics)\n+        }\n+        _ => false,\n+    }\n+}\n+\n+// Returns true if the given type method must be inlined because it may be\n+// monomorphized or it was marked with `#[inline]`.\n+fn ty_method_might_be_inlined(ty_method: &ty_method) -> bool {\n+    attributes_specify_inlining(ty_method.attrs) ||\n+        generics_require_inlining(&ty_method.generics)\n+}\n+\n+// Returns true if the given trait method must be inlined because it may be\n+// monomorphized or it was marked with `#[inline]`.\n+fn trait_method_might_be_inlined(trait_method: &trait_method) -> bool {\n+    match *trait_method {\n+        required(ref ty_method) => ty_method_might_be_inlined(ty_method),\n+        provided(_) => true\n+    }\n+}\n+\n+// The context we're in. If we're in a public context, then public symbols are\n+// marked reachable. If we're in a private context, then only trait\n+// implementations are marked reachable.\n+#[deriving(Eq)]\n+enum PrivacyContext {\n+    PublicContext,\n+    PrivateContext,\n+}\n+\n+// Information needed while computing reachability.\n+struct ReachableContext {\n+    // The type context.\n+    tcx: ty::ctxt,\n+    // The method map, which links node IDs of method call expressions to the\n+    // methods they've been resolved to.\n+    method_map: typeck::method_map,\n+    // The set of items which must be exported in the linkage sense.\n+    reachable_symbols: @mut HashSet<node_id>,\n+    // A worklist of item IDs. Each item ID in this worklist will be inlined\n+    // and will be scanned for further references.\n+    worklist: @mut ~[node_id],\n+}\n+\n+impl ReachableContext {\n+    // Creates a new reachability computation context.\n+    fn new(tcx: ty::ctxt, method_map: typeck::method_map)\n+           -> ReachableContext {\n+        ReachableContext {\n+            tcx: tcx,\n+            method_map: method_map,\n+            reachable_symbols: @mut HashSet::new(),\n+            worklist: @mut ~[],\n+        }\n+    }\n+\n+    // Step 1: Mark all public symbols, and add all public symbols that might\n+    // be inlined to a worklist.\n+    fn mark_public_symbols(&self, crate: @crate) {\n+        let reachable_symbols = self.reachable_symbols;\n+        let worklist = self.worklist;\n+        let visitor = visit::mk_vt(@Visitor {\n+            visit_item: |item, (privacy_context, visitor):\n+                    (PrivacyContext, visit::vt<PrivacyContext>)| {\n+                match item.node {\n+                    item_fn(*) => {\n+                        if privacy_context == PublicContext {\n+                            reachable_symbols.insert(item.id);\n+                        }\n+                        if item_might_be_inlined(item) {\n+                            worklist.push(item.id)\n+                        }\n+                    }\n+                    item_struct(ref struct_def, _) => {\n+                        match struct_def.ctor_id {\n+                            Some(ctor_id) if\n+                                    privacy_context == PublicContext => {\n+                                reachable_symbols.insert(ctor_id);\n+                            }\n+                            Some(_) | None => {}\n+                        }\n+                    }\n+                    item_enum(ref enum_def, _) => {\n+                        if privacy_context == PublicContext {\n+                            for enum_def.variants.iter().advance |variant| {\n+                                reachable_symbols.insert(variant.node.id);\n+                            }\n+                        }\n+                    }\n+                    item_impl(ref generics, trait_ref, _, ref methods) => {\n+                        // XXX(pcwalton): We conservatively assume any methods\n+                        // on a trait implementation are reachable, when this\n+                        // is not the case. We could be more precise by only\n+                        // treating implementations of reachable or cross-\n+                        // crate traits as reachable.\n+\n+                        let should_be_considered_public = |method: @method| {\n+                            (method.vis == public &&\n+                                    privacy_context == PublicContext) ||\n+                                    trait_ref.is_some()\n+                        };\n+\n+                        // Mark all public methods as reachable.\n+                        for methods.iter().advance |&method| {\n+                            if should_be_considered_public(method) {\n+                                reachable_symbols.insert(method.id);\n+                            }\n+                        }\n+\n+                        if generics_require_inlining(generics) {\n+                            // If the impl itself has generics, add all public\n+                            // symbols to the worklist.\n+                            for methods.iter().advance |&method| {\n+                                if should_be_considered_public(method) {\n+                                    worklist.push(method.id)\n+                                }\n+                            }\n+                        } else {\n+                            // Otherwise, add only public methods that have\n+                            // generics to the worklist.\n+                            for methods.iter().advance |method| {\n+                                let generics = &method.generics;\n+                                let attrs = &method.attrs;\n+                                if generics_require_inlining(generics) ||\n+                                        attributes_specify_inlining(*attrs) ||\n+                                        should_be_considered_public(*method) {\n+                                    worklist.push(method.id)\n+                                }\n+                            }\n+                        }\n+                    }\n+                    item_trait(_, _, ref trait_methods) => {\n+                        // Mark all provided methods as reachable.\n+                        if privacy_context == PublicContext {\n+                            for trait_methods.iter().advance |trait_method| {\n+                                match *trait_method {\n+                                    provided(method) => {\n+                                        reachable_symbols.insert(method.id);\n+                                        worklist.push(method.id)\n+                                    }\n+                                    required(_) => {}\n+                                }\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                if item.vis == public && privacy_context == PublicContext {\n+                    visit::visit_item(item, (PublicContext, visitor))\n+                } else {\n+                    visit::visit_item(item, (PrivateContext, visitor))\n+                }\n+            },\n+            .. *visit::default_visitor()\n+        });\n+\n+        visit::visit_crate(crate, (PublicContext, visitor))\n+    }\n+\n+    // Returns true if the given def ID represents a local item that is\n+    // eligible for inlining and false otherwise.\n+    fn def_id_represents_local_inlined_item(tcx: ty::ctxt, def_id: def_id)\n+                                            -> bool {\n+        if def_id.crate != local_crate {\n+            return false\n+        }\n+\n+        let node_id = def_id.node;\n+        match tcx.items.find(&node_id) {\n+            Some(&ast_map::node_item(item, _)) => {\n+                match item.node {\n+                    item_fn(*) => item_might_be_inlined(item),\n+                    _ => false,\n+                }\n+            }\n+            Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n+                match *trait_method {\n+                    required(_) => false,\n+                    provided(_) => true,\n+                }\n+            }\n+            Some(&ast_map::node_method(method, impl_did, _)) => {\n+                if generics_require_inlining(&method.generics) ||\n+                        attributes_specify_inlining(method.attrs) {\n+                    true\n+                } else {\n+                    // Check the impl. If the generics on the self type of the\n+                    // impl require inlining, this method does too.\n+                    assert!(impl_did.crate == local_crate);\n+                    match tcx.items.find(&impl_did.node) {\n+                        Some(&ast_map::node_item(item, _)) => {\n+                            match item.node {\n+                                item_impl(ref generics, _, _, _) => {\n+                                    generics_require_inlining(generics)\n+                                }\n+                                _ => false\n+                            }\n+                        }\n+                        Some(_) => {\n+                            tcx.sess.span_bug(method.span,\n+                                              \"method is not inside an \\\n+                                               impl?!\")\n+                        }\n+                        None => {\n+                            tcx.sess.span_bug(method.span,\n+                                              \"the impl that this method is \\\n+                                               supposedly inside of doesn't \\\n+                                               exist in the AST map?!\")\n+                        }\n+                    }\n+                }\n+            }\n+            Some(_) => false,\n+            None => false   // This will happen for default methods.\n+        }\n+    }\n+\n+    // Helper function to set up a visitor for `propagate()` below.\n+    fn init_visitor(&self) -> visit::vt<()> {\n+        let (worklist, method_map) = (self.worklist, self.method_map);\n+        let (tcx, reachable_symbols) = (self.tcx, self.reachable_symbols);\n+        visit::mk_vt(@visit::Visitor {\n+            visit_expr: |expr, (_, visitor)| {\n+                match expr.node {\n+                    expr_path(_) => {\n+                        let def = match tcx.def_map.find(&expr.id) {\n+                            Some(&def) => def,\n+                            None => {\n+                                tcx.sess.span_bug(expr.span,\n+                                                  \"def ID not in def map?!\")\n+                            }\n+                        };\n+\n+                        let def_id = def_id_of_def(def);\n+                        if ReachableContext::\n+                                def_id_represents_local_inlined_item(tcx,\n+                                                                     def_id) {\n+                            worklist.push(def_id.node)\n+                        }\n+                        reachable_symbols.insert(def_id.node);\n+                    }\n+                    expr_method_call(*) => {\n+                        match method_map.find(&expr.id) {\n+                            Some(&typeck::method_map_entry {\n+                                origin: typeck::method_static(def_id),\n+                                _\n+                            }) => {\n+                                if ReachableContext::\n+                                    def_id_represents_local_inlined_item(\n+                                        tcx,\n+                                        def_id) {\n+                                    worklist.push(def_id.node)\n+                                }\n+                                reachable_symbols.insert(def_id.node);\n+                            }\n+                            Some(_) => {}\n+                            None => {\n+                                tcx.sess.span_bug(expr.span,\n+                                                  \"method call expression \\\n+                                                   not in method map?!\")\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+\n+                visit::visit_expr(expr, ((), visitor))\n+            },\n+            ..*visit::default_visitor()\n+        })\n+    }\n+\n+    // Step 2: Mark all symbols that the symbols on the worklist touch.\n+    fn propagate(&self) {\n+        let visitor = self.init_visitor();\n+        let mut scanned = HashSet::new();\n+        while self.worklist.len() > 0 {\n+            let search_item = self.worklist.pop();\n+            if scanned.contains(&search_item) {\n+                loop\n+            }\n+            scanned.insert(search_item);\n+            self.reachable_symbols.insert(search_item);\n+\n+            // Find the AST block corresponding to the item and visit it,\n+            // marking all path expressions that resolve to something\n+            // interesting.\n+            match self.tcx.items.find(&search_item) {\n+                Some(&ast_map::node_item(item, _)) => {\n+                    match item.node {\n+                        item_fn(_, _, _, _, ref search_block) => {\n+                            visit::visit_block(search_block, ((), visitor))\n+                        }\n+                        _ => {\n+                            self.tcx.sess.span_bug(item.span,\n+                                                   \"found non-function item \\\n+                                                    in worklist?!\")\n+                        }\n+                    }\n+                }\n+                Some(&ast_map::node_trait_method(trait_method, _, _)) => {\n+                    match *trait_method {\n+                        required(ref ty_method) => {\n+                            self.tcx.sess.span_bug(ty_method.span,\n+                                                   \"found required method in \\\n+                                                    worklist?!\")\n+                        }\n+                        provided(ref method) => {\n+                            visit::visit_block(&method.body, ((), visitor))\n+                        }\n+                    }\n+                }\n+                Some(&ast_map::node_method(ref method, _, _)) => {\n+                    visit::visit_block(&method.body, ((), visitor))\n+                }\n+                Some(_) => {\n+                    let ident_interner = token::get_ident_interner();\n+                    let desc = ast_map::node_id_to_str(self.tcx.items,\n+                                                       search_item,\n+                                                       ident_interner);\n+                    self.tcx.sess.bug(fmt!(\"found unexpected thingy in \\\n+                                            worklist: %s\",\n+                                            desc))\n+                }\n+                None => {\n+                    self.tcx.sess.bug(fmt!(\"found unmapped ID in worklist: \\\n+                                            %d\",\n+                                           search_item))\n+                }\n+            }\n+        }\n+    }\n+\n+    // Step 3: Mark all destructors as reachable.\n+    //\n+    // XXX(pcwalton): This is a conservative overapproximation, but fixing\n+    // this properly would result in the necessity of computing *type*\n+    // reachability, which might result in a compile time loss.\n+    fn mark_destructors_reachable(&self) {\n+        for self.tcx.destructor_for_type.iter().advance\n+                |(_, destructor_def_id)| {\n+            if destructor_def_id.crate == local_crate {\n+                self.reachable_symbols.insert(destructor_def_id.node);\n+            }\n+        }\n+    }\n+}\n+\n+pub fn find_reachable(tcx: ty::ctxt,\n+                      method_map: typeck::method_map,\n+                      crate: @crate)\n+                      -> @mut HashSet<node_id> {\n+    // XXX(pcwalton): We only need to mark symbols that are exported. But this\n+    // is more complicated than just looking at whether the symbol is `pub`,\n+    // because it might be the target of a `pub use` somewhere. For now, I\n+    // think we are fine, because you can't `pub use` something that wasn't\n+    // exported due to the bug whereby `use` only looks through public\n+    // modules even if you're inside the module the `use` appears in. When\n+    // this bug is fixed, however, this code will need to be updated. Probably\n+    // the easiest way to fix this (although a conservative overapproximation)\n+    // is to have the name resolution pass mark all targets of a `pub use` as\n+    // \"must be reachable\".\n+\n+    let reachable_context = ReachableContext::new(tcx, method_map);\n+\n+    // Step 1: Mark all public symbols, and add all public symbols that might\n+    // be inlined to a worklist.\n+    reachable_context.mark_public_symbols(crate);\n+\n+    // Step 2: Mark all symbols that the symbols on the worklist touch.\n+    reachable_context.propagate();\n+\n+    // Step 3: Mark all destructors as reachable.\n+    reachable_context.mark_destructors_reachable();\n+\n+    // Return the set of reachable symbols.\n+    reachable_context.reachable_symbols\n+}\n+"}, {"sha": "b2bfd9d1661b79aea40897630957c47510ff9762", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 124, "deletions": 145, "changes": 269, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -652,19 +652,17 @@ impl NameBindings {\n                 match self.type_def {\n                     None => None,\n                     Some(ref type_def) => {\n-                        // FIXME (#3784): This is reallllly questionable.\n-                        // Perhaps the right thing to do is to merge def_mod\n-                        // and def_ty.\n                         match (*type_def).type_def {\n                             Some(type_def) => Some(type_def),\n                             None => {\n-                                match (*type_def).module_def {\n-                                    Some(module_def) => {\n-                                        let module_def = &mut *module_def;\n-                                        module_def.def_id.map(|def_id|\n-                                            def_mod(*def_id))\n+                                match type_def.module_def {\n+                                    Some(module) => {\n+                                        match module.def_id {\n+                                            Some(did) => Some(def_mod(did)),\n+                                            None => None,\n+                                        }\n                                     }\n-                                    None => None\n+                                    None => None,\n                                 }\n                             }\n                         }\n@@ -1230,49 +1228,29 @@ impl Resolver {\n                 visit_item(item, (new_parent, visitor));\n             }\n \n-            item_impl(_, trait_ref_opt, ty, ref methods) => {\n-                // If this implements an anonymous trait and it has static\n-                // methods, then add all the static methods within to a new\n-                // module, if the type was defined within this module.\n+            item_impl(_, None, ty, ref methods) => {\n+                // If this implements an anonymous trait, then add all the\n+                // methods within to a new module, if the type was defined\n+                // within this module.\n                 //\n                 // FIXME (#3785): This is quite unsatisfactory. Perhaps we\n                 // should modify anonymous traits to only be implementable in\n                 // the same module that declared the type.\n \n-                // Bail out early if there are no static methods.\n-                let mut methods_seen = HashMap::new();\n-                let mut has_static_methods = false;\n-                for methods.iter().advance |method| {\n-                    match method.explicit_self.node {\n-                        sty_static => has_static_methods = true,\n-                        _ => {\n-                            // Make sure you can't define duplicate methods\n-                            let ident = method.ident;\n-                            let span = method.span;\n-                            let old_sp = methods_seen.find_or_insert(ident, span);\n-                            if *old_sp != span {\n-                                self.session.span_err(span,\n-                                                      fmt!(\"duplicate definition of method `%s`\",\n-                                                           self.session.str_of(ident)));\n-                                self.session.span_note(*old_sp,\n-                                                       fmt!(\"first definition of method `%s` here\",\n-                                                            self.session.str_of(ident)));\n-                            }\n-                        }\n-                    }\n-                }\n-\n-                // If there are static methods, then create the module\n-                // and add them.\n-                match (trait_ref_opt, ty) {\n-                    (None, @Ty { node: ty_path(path, _, _), _ }) if\n-                            has_static_methods && path.idents.len() == 1 => {\n+                // Create the module and add all methods.\n+                match *ty {\n+                    Ty {\n+                        node: ty_path(path, _, _),\n+                        _\n+                    } if path.idents.len() == 1 => {\n                         let name = path_to_ident(path);\n \n                         let new_parent = match parent.children.find(&name) {\n                             // It already exists\n-                            Some(&child) if child.get_module_if_available().is_some() &&\n-                                            child.get_module().kind == ImplModuleKind => {\n+                            Some(&child) if child.get_module_if_available()\n+                                                 .is_some() &&\n+                                            child.get_module().kind ==\n+                                                ImplModuleKind => {\n                                 ModuleReducedGraphParent(child.get_module())\n                             }\n                             // Create the module\n@@ -1283,39 +1261,45 @@ impl Resolver {\n                                                    ForbidDuplicateModules,\n                                                    sp);\n \n-                                let parent_link = self.get_parent_link(new_parent,\n-                                                                       ident);\n+                                let parent_link =\n+                                    self.get_parent_link(new_parent, ident);\n                                 let def_id = local_def(item.id);\n                                 name_bindings.define_module(Public,\n                                                             parent_link,\n                                                             Some(def_id),\n                                                             ImplModuleKind,\n                                                             sp);\n \n-                                ModuleReducedGraphParent(name_bindings.get_module())\n+                                ModuleReducedGraphParent(\n+                                    name_bindings.get_module())\n                             }\n                         };\n \n-                        // For each static method...\n+                        // For each method...\n                         for methods.iter().advance |method| {\n-                            match method.explicit_self.node {\n+                            // Add the method to the module.\n+                            let ident = method.ident;\n+                            let (method_name_bindings, _) =\n+                                self.add_child(ident,\n+                                               new_parent,\n+                                               ForbidDuplicateValues,\n+                                               method.span);\n+                            let def = match method.explicit_self.node {\n                                 sty_static => {\n-                                    // Add the static method to the\n-                                    // module.\n-                                    let ident = method.ident;\n-                                    let (method_name_bindings, _) =\n-                                        self.add_child(\n-                                            ident,\n-                                            new_parent,\n-                                            ForbidDuplicateValues,\n-                                            method.span);\n-                                    let def = def_fn(local_def(method.id),\n-                                                     method.purity);\n-                                    method_name_bindings.define_value(\n-                                        Public, def, method.span);\n+                                    // Static methods become `def_fn`s.\n+                                    def_fn(local_def(method.id),\n+                                           method.purity)\n                                 }\n-                                _ => {}\n-                            }\n+                                _ => {\n+                                    // Non-static methods become\n+                                    // `def_method`s.\n+                                    def_method(local_def(method.id), None)\n+                                }\n+                            };\n+\n+                            method_name_bindings.define_value(Public,\n+                                                              def,\n+                                                              method.span);\n                         }\n                     }\n                     _ => {}\n@@ -1324,77 +1308,58 @@ impl Resolver {\n                 visit_item(item, (parent, visitor));\n             }\n \n+            item_impl(_, Some(_), ty, ref methods) => {\n+                visit_item(item, (parent, visitor));\n+            }\n+\n             item_trait(_, _, ref methods) => {\n                 let (name_bindings, new_parent) =\n                     self.add_child(ident, parent, ForbidDuplicateTypes, sp);\n \n-                // If the trait has static methods, then add all the static\n-                // methods within to a new module.\n-                //\n-                // We only need to create the module if the trait has static\n-                // methods, so check that first.\n-                let mut has_static_methods = false;\n-                for (*methods).iter().advance |method| {\n-                    let ty_m = trait_method_to_ty_method(method);\n-                    match ty_m.explicit_self.node {\n-                        sty_static => {\n-                            has_static_methods = true;\n-                            break;\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-\n-                // Create the module if necessary.\n-                let module_parent_opt;\n-                if has_static_methods {\n-                    let parent_link = self.get_parent_link(parent, ident);\n-                    name_bindings.define_module(privacy,\n-                                                parent_link,\n-                                                Some(local_def(item.id)),\n-                                                TraitModuleKind,\n-                                                sp);\n-                    module_parent_opt = Some(ModuleReducedGraphParent(\n-                        name_bindings.get_module()));\n-                } else {\n-                    module_parent_opt = None;\n-                }\n+                // Add all the methods within to a new module.\n+                let parent_link = self.get_parent_link(parent, ident);\n+                name_bindings.define_module(privacy,\n+                                            parent_link,\n+                                            Some(local_def(item.id)),\n+                                            TraitModuleKind,\n+                                            sp);\n+                let module_parent = ModuleReducedGraphParent(name_bindings.\n+                                                             get_module());\n \n                 // Add the names of all the methods to the trait info.\n                 let mut method_names = HashMap::new();\n                 for methods.iter().advance |method| {\n                     let ty_m = trait_method_to_ty_method(method);\n \n                     let ident = ty_m.ident;\n-                    // Add it to the trait info if not static,\n-                    // add it as a name in the trait module otherwise.\n-                    match ty_m.explicit_self.node {\n-                        sty_static => {\n-                            let def = def_static_method(\n-                                local_def(ty_m.id),\n-                                Some(local_def(item.id)),\n-                                ty_m.purity);\n \n-                            let (method_name_bindings, _) =\n-                                self.add_child(ident,\n-                                               module_parent_opt.get(),\n-                                               ForbidDuplicateValues,\n-                                               ty_m.span);\n-                            method_name_bindings.define_value(Public,\n-                                                              def,\n-                                                              ty_m.span);\n+                    // Add it as a name in the trait module.\n+                    let def = match ty_m.explicit_self.node {\n+                        sty_static => {\n+                            // Static methods become `def_static_method`s.\n+                            def_static_method(local_def(ty_m.id),\n+                                              Some(local_def(item.id)),\n+                                              ty_m.purity)\n                         }\n                         _ => {\n-                            // Make sure you can't define duplicate methods\n-                            let old_sp = method_names.find_or_insert(ident, ty_m.span);\n-                            if *old_sp != ty_m.span {\n-                                self.session.span_err(ty_m.span,\n-                                                      fmt!(\"duplicate definition of method `%s`\",\n-                                                           self.session.str_of(ident)));\n-                                self.session.span_note(*old_sp,\n-                                                       fmt!(\"first definition of method `%s` here\",\n-                                                            self.session.str_of(ident)));\n-                            }\n+                            // Non-static methods become `def_method`s.\n+                            def_method(local_def(ty_m.id),\n+                                       Some(local_def(item.id)))\n+                        }\n+                    };\n+\n+                    let (method_name_bindings, _) =\n+                        self.add_child(ident,\n+                                       module_parent,\n+                                       ForbidDuplicateValues,\n+                                       ty_m.span);\n+                    method_name_bindings.define_value(Public, def, ty_m.span);\n+\n+                    // Add it to the trait info if not static.\n+                    match ty_m.explicit_self.node {\n+                        sty_static => {}\n+                        _ => {\n+                            method_names.insert(ident, ());\n                         }\n                     }\n                 }\n@@ -1751,6 +1716,9 @@ impl Resolver {\n             child_name_bindings.define_type(privacy, def, dummy_sp());\n             self.structs.insert(def_id);\n           }\n+          def_method(*) => {\n+            // Ignored; handled elsewhere.\n+          }\n           def_self(*) | def_arg(*) | def_local(*) |\n           def_prim_ty(*) | def_ty_param(*) | def_binding(*) |\n           def_use(*) | def_upvar(*) | def_region(*) |\n@@ -2091,8 +2059,12 @@ impl Resolver {\n         let mut first = true;\n         let mut result = ~\"\";\n         for idents.iter().advance |ident| {\n-            if first { first = false; } else { result += \"::\" };\n-            result += self.session.str_of(*ident);\n+            if first {\n+                first = false\n+            } else {\n+                result.push_str(\"::\")\n+            }\n+            result.push_str(self.session.str_of(*ident));\n         };\n         return result;\n     }\n@@ -2387,7 +2359,8 @@ impl Resolver {\n         }\n         match type_result {\n             BoundResult(target_module, name_bindings) => {\n-                debug!(\"(resolving single import) found type target\");\n+                debug!(\"(resolving single import) found type target: %?\",\n+                        name_bindings.type_def.get().type_def);\n                 import_resolution.type_target =\n                     Some(Target(target_module, name_bindings));\n                 import_resolution.type_id = directive.id;\n@@ -3186,12 +3159,14 @@ impl Resolver {\n             Some(def_id) if def_id.crate == local_crate => {\n                 // OK. Continue.\n                 debug!(\"(recording exports for module subtree) recording \\\n-                        exports for local module\");\n+                        exports for local module `%s`\",\n+                       self.module_to_str(module_));\n             }\n             None => {\n                 // Record exports for the root module.\n                 debug!(\"(recording exports for module subtree) recording \\\n-                        exports for root module\");\n+                        exports for root module `%s`\",\n+                       self.module_to_str(module_));\n             }\n             Some(_) => {\n                 // Bail out.\n@@ -3265,22 +3240,8 @@ impl Resolver {\n     pub fn add_exports_for_module(@mut self,\n                                   exports2: &mut ~[Export2],\n                                   module_: @mut Module) {\n-        for module_.children.iter().advance |(ident, namebindings)| {\n-            debug!(\"(computing exports) maybe export '%s'\",\n-                   self.session.str_of(*ident));\n-            self.add_exports_of_namebindings(&mut *exports2,\n-                                             *ident,\n-                                             *namebindings,\n-                                             TypeNS,\n-                                             false);\n-            self.add_exports_of_namebindings(&mut *exports2,\n-                                             *ident,\n-                                             *namebindings,\n-                                             ValueNS,\n-                                             false);\n-        }\n-\n-        for module_.import_resolutions.iter().advance |(ident, importresolution)| {\n+        for module_.import_resolutions.iter().advance |(ident,\n+                                                        importresolution)| {\n             if importresolution.privacy != Public {\n                 debug!(\"(computing exports) not reexporting private `%s`\",\n                        self.session.str_of(*ident));\n@@ -4514,8 +4475,8 @@ impl Resolver {\n \n         if path.global {\n             return self.resolve_crate_relative_path(path,\n-                                                 self.xray_context,\n-                                                 namespace);\n+                                                    self.xray_context,\n+                                                    namespace);\n         }\n \n         if path.idents.len() > 1 {\n@@ -4943,6 +4904,22 @@ impl Resolver {\n                         // Write the result into the def map.\n                         debug!(\"(resolving expr) resolved `%s`\",\n                                self.idents_to_str(path.idents));\n+\n+                        // First-class methods are not supported yet; error\n+                        // out here.\n+                        match def {\n+                            def_method(*) => {\n+                                self.session.span_err(expr.span,\n+                                                      \"first-class methods \\\n+                                                       are not supported\");\n+                                self.session.span_note(expr.span,\n+                                                       \"call the method \\\n+                                                        using the `.` \\\n+                                                        syntax\");\n+                            }\n+                            _ => {}\n+                        }\n+\n                         self.record_def(expr.id, def);\n                     }\n                     None => {\n@@ -5072,6 +5049,9 @@ impl Resolver {\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n             expr_method_call(_, _, ident, _, _, _) => {\n+                debug!(\"(recording candidate traits for expr) recording \\\n+                        traits for %d\",\n+                       expr.id);\n                 let traits = self.search_for_traits_containing_method(ident);\n                 self.trait_map.insert(expr.id, @mut traits);\n             }\n@@ -5147,7 +5127,6 @@ impl Resolver {\n         debug!(\"(searching for traits containing method) looking for '%s'\",\n                self.session.str_of(name));\n \n-\n         let mut found_traits = ~[];\n         let mut search_module = self.current_module;\n         match self.method_map.find(&name) {\n@@ -5411,7 +5390,7 @@ pub fn resolve_crate(session: Session,\n                   -> CrateMap {\n     let resolver = @mut Resolver(session, lang_items, crate);\n     resolver.resolve();\n-    let Resolver{def_map, export_map2, trait_map, _} = copy *resolver;\n+    let Resolver { def_map, export_map2, trait_map, _ } = copy *resolver;\n     CrateMap {\n         def_map: def_map,\n         exp_map2: export_map2,"}, {"sha": "a1d1b737f31f2fc88ef4da554d7cbd693731227d", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -98,15 +98,15 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n     if !ia.clobbers.is_empty() && !clobbers.is_empty() {\n         clobbers = fmt!(\"%s,%s\", ia.clobbers, clobbers);\n     } else {\n-        clobbers += ia.clobbers;\n+        clobbers.push_str(ia.clobbers);\n     };\n \n     // Add the clobbers to our constraints list\n-    if !clobbers.is_empty() && !constraints.is_empty() {\n-        constraints += \",\";\n-        constraints += clobbers;\n+    if clobbers.len() != 0 && constraints.len() != 0 {\n+        constraints.push_char(',');\n+        constraints.push_str(clobbers);\n     } else {\n-        constraints += clobbers;\n+        constraints.push_str(clobbers);\n     }\n \n     debug!(\"Asm Constraints: %?\", constraints);"}, {"sha": "df7f73a52436a656ac95a00a32eba7188240f826", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -54,7 +54,6 @@ use middle::trans::machine;\n use middle::trans::machine::{llalign_of_min, llsize_of};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n-use middle::trans::reachable;\n use middle::trans::tvec;\n use middle::trans::type_of;\n use middle::trans::type_of::*;\n@@ -65,7 +64,7 @@ use util::ppaux::{Repr, ty_to_str};\n use middle::trans::type_::Type;\n \n use core::hash;\n-use core::hashmap::{HashMap};\n+use core::hashmap::{HashMap, HashSet};\n use core::int;\n use core::io;\n use core::libc::c_uint;\n@@ -2437,7 +2436,6 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n             }\n           }\n           ast_map::node_method(m, _, pth) => {\n-            exprt = true;\n             register_method(ccx, id, pth, m)\n           }\n           ast_map::node_foreign_item(ni, _, _, pth) => {\n@@ -2511,7 +2509,7 @@ pub fn get_item_val(ccx: @mut CrateContext, id: ast::node_id) -> ValueRef {\n                               variant))\n           }\n         };\n-        if !(exprt || ccx.reachable.contains(&id)) {\n+        if !exprt && !ccx.reachable.contains(&id) {\n             lib::llvm::SetLinkage(val, lib::llvm::InternalLinkage);\n         }\n         ccx.item_vals.insert(id, val);\n@@ -2818,13 +2816,13 @@ pub fn crate_ctxt_to_encode_parms<'r>(cx: &'r CrateContext, ie: encoder::encode_\n         encoder::EncodeParams {\n             diag: diag,\n             tcx: cx.tcx,\n-            reachable: cx.reachable,\n             reexports2: cx.exp_map2,\n             item_symbols: item_symbols,\n             discrim_symbols: discrim_symbols,\n             link_meta: link_meta,\n             cstore: cx.sess.cstore,\n-            encode_inlined_item: ie\n+            encode_inlined_item: ie,\n+            reachable: cx.reachable,\n         }\n }\n \n@@ -2890,16 +2888,12 @@ pub fn trans_crate(sess: session::Session,\n                    tcx: ty::ctxt,\n                    output: &Path,\n                    emap2: resolve::ExportMap2,\n-                   maps: astencode::Maps) -> (ContextRef, ModuleRef, LinkMeta) {\n+                   reachable_map: @mut HashSet<ast::node_id>,\n+                   maps: astencode::Maps)\n+                   -> (ContextRef, ModuleRef, LinkMeta) {\n \n     let mut symbol_hasher = hash::default_state();\n     let link_meta = link::build_link_meta(sess, crate, output, &mut symbol_hasher);\n-    let reachable = reachable::find_reachable(\n-        &crate.node.module,\n-        emap2,\n-        tcx,\n-        maps.method_map\n-    );\n \n     // Append \".rc\" to crate name as LLVM module identifier.\n     //\n@@ -2917,8 +2911,15 @@ pub fn trans_crate(sess: session::Session,\n     //     sess.bug(\"couldn't enable multi-threaded LLVM\");\n     // }\n \n-    let ccx = @mut CrateContext::new(sess, llmod_id, tcx, emap2, maps,\n-                                 symbol_hasher, link_meta, reachable);\n+    let ccx = @mut CrateContext::new(sess,\n+                                     llmod_id,\n+                                     tcx,\n+                                     emap2,\n+                                     maps,\n+                                     symbol_hasher,\n+                                     link_meta,\n+                                     reachable_map);\n+\n     {\n         let _icx = push_ctxt(\"data\");\n         trans_constants(ccx, crate);"}, {"sha": "dc32a3b4e2c884e9d5ff3afe2cfa15bf06c2e8ec", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -68,13 +68,13 @@ pub fn count_insn(cx: block, category: &str) {\n         i = 0u;\n         while i < len {\n             i = *mm.get(&v[i]);\n-            s += \"/\";\n-            s += v[i];\n+            s.push_char('/');\n+            s.push_str(v[i]);\n             i += 1u;\n         }\n \n-        s += \"/\";\n-        s += category;\n+        s.push_char('/');\n+        s.push_str(category);\n \n         let n = match h.find(&s) {\n           Some(&n) => n,\n@@ -610,12 +610,21 @@ pub fn GEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {\n \n // Simple wrapper around GEP that takes an array of ints and wraps them\n // in C_i32()\n-//\n-// FIXME #6571: Use a small-vector optimization to avoid allocations here.\n+#[inline]\n pub fn GEPi(cx: block, base: ValueRef, ixs: &[uint]) -> ValueRef {\n-    let v = do vec::map(ixs) |i| { C_i32(*i as i32) };\n-    count_insn(cx, \"gepi\");\n-    return InBoundsGEP(cx, base, v);\n+    // Small vector optimization. This should catch 100% of the cases that\n+    // we care about.\n+    if ixs.len() < 16 {\n+        let mut small_vec = [ C_i32(0), ..16 ];\n+        for ixs.iter().enumerate().advance |(i, &ix)| {\n+            small_vec[i] = C_i32(ix as i32)\n+        }\n+        InBoundsGEP(cx, base, small_vec.slice(0, ixs.len()))\n+    } else {\n+        let v = do vec::map(ixs) |i| { C_i32(*i as i32) };\n+        count_insn(cx, \"gepi\");\n+        InBoundsGEP(cx, base, v)\n+    }\n }\n \n pub fn InBoundsGEP(cx: block, Pointer: ValueRef, Indices: &[ValueRef]) -> ValueRef {"}, {"sha": "45fdda1990cc8ff51b1bb6fa43521d9f49d8e87f", "filename": "src/librustc/middle/trans/cabi_arm.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_arm.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -139,12 +139,14 @@ impl ABIInfo for ARM_ABIInfo {\n             attrs.push(attr);\n         }\n \n-        let mut (ret_ty, ret_attr) = if ret_def {\n+        let (ret_ty, ret_attr) = if ret_def {\n             classify_ret_ty(rty)\n         } else {\n             (LLVMType { cast: false, ty: Type::void() }, None)\n         };\n \n+        let mut ret_ty = ret_ty;\n+\n         let sret = ret_attr.is_some();\n         if sret {\n             arg_tys.unshift(ret_ty);"}, {"sha": "47f2fb8634c16cc3955053d6dbf4ed84b5d033f9", "filename": "src/librustc/middle/trans/cabi_mips.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_mips.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -178,12 +178,14 @@ impl ABIInfo for MIPS_ABIInfo {\n                     atys: &[Type],\n                     rty: Type,\n                     ret_def: bool) -> FnType {\n-        let mut (ret_ty, ret_attr) = if ret_def {\n+        let (ret_ty, ret_attr) = if ret_def {\n             classify_ret_ty(rty)\n         } else {\n             (LLVMType { cast: false, ty: Type::void() }, None)\n         };\n \n+        let mut ret_ty = ret_ty;\n+\n         let sret = ret_attr.is_some();\n         let mut arg_tys = ~[];\n         let mut attrs = ~[];"}, {"sha": "6c264e637a60b944456ea0bb5e406b99ec92ed97", "filename": "src/librustc/middle/trans/cabi_x86_64.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86_64.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -39,7 +39,11 @@ enum RegClass {\n     Memory\n }\n \n-impl Type {\n+trait TypeMethods {\n+    fn is_reg_ty(&self) -> bool;\n+}\n+\n+impl TypeMethods for Type {\n     fn is_reg_ty(&self) -> bool {\n         match self.kind() {\n             Integer | Pointer | Float | Double => true,\n@@ -360,8 +364,9 @@ fn x86_64_tys(atys: &[Type],\n         arg_tys.push(ty);\n         attrs.push(attr);\n     }\n-    let mut (ret_ty, ret_attr) = x86_64_ty(rty, |cls| cls.is_ret_bysret(),\n+    let (ret_ty, ret_attr) = x86_64_ty(rty, |cls| cls.is_ret_bysret(),\n                                        StructRetAttribute);\n+    let mut ret_ty = ret_ty;\n     let sret = ret_attr.is_some();\n     if sret {\n         arg_tys = vec::append(~[ret_ty], arg_tys);"}, {"sha": "3405db8e52f6b66f2ae063b383a8e835d24109aa", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -146,7 +146,7 @@ pub fn trans(bcx: block, expr: @ast::expr) -> Callee {\n             ast::def_static(*) | ast::def_ty(*) | ast::def_prim_ty(*) |\n             ast::def_use(*) | ast::def_typaram_binder(*) |\n             ast::def_region(*) | ast::def_label(*) | ast::def_ty_param(*) |\n-            ast::def_self_ty(*) => {\n+            ast::def_self_ty(*) | ast::def_method(*) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n                     fmt!(\"Cannot translate def %? \\\n@@ -319,9 +319,10 @@ pub fn trans_fn_ref_with_vtables(\n         // Should be either intra-crate or inlined.\n         assert_eq!(def_id.crate, ast::local_crate);\n \n-        let mut (val, must_cast) =\n+        let (val, must_cast) =\n             monomorphize::monomorphic_fn(ccx, def_id, &substs,\n                                          vtables, opt_impl_did, Some(ref_id));\n+        let mut val = val;\n         if must_cast && ref_id != 0 {\n             // Monotype of the REFERENCE to the function (type params\n             // are subst'd)"}, {"sha": "a7ffa8e13b027319b7b61872186aa2abea95973d", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -964,9 +964,12 @@ pub fn path_str(sess: session::Session, p: &[path_elt]) -> ~str {\n     for p.iter().advance |e| {\n         match *e {\n             ast_map::path_name(s) | ast_map::path_mod(s) => {\n-                if first { first = false; }\n-                else { r += \"::\"; }\n-                r += sess.str_of(s);\n+                if first {\n+                    first = false\n+                } else {\n+                    r.push_str(\"::\")\n+                }\n+                r.push_str(sess.str_of(s));\n             }\n         }\n     }"}, {"sha": "9b81fc406b7cc993c88a56efa1795f89967c40db", "filename": "src/librustc/middle/trans/context.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontext.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -21,7 +21,6 @@ use middle::resolve;\n use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::debuginfo;\n-use middle::trans::reachable;\n use middle::trans::type_use;\n use middle::ty;\n \n@@ -48,7 +47,7 @@ pub struct CrateContext {\n      intrinsics: HashMap<&'static str, ValueRef>,\n      item_vals: HashMap<ast::node_id, ValueRef>,\n      exp_map2: resolve::ExportMap2,\n-     reachable: reachable::map,\n+     reachable: @mut HashSet<ast::node_id>,\n      item_symbols: HashMap<ast::node_id, ~str>,\n      link_meta: LinkMeta,\n      enum_sizes: HashMap<ty::t, uint>,\n@@ -115,10 +114,15 @@ pub struct CrateContext {\n }\n \n impl CrateContext {\n-    pub fn new(sess: session::Session, name: &str, tcx: ty::ctxt,\n-               emap2: resolve::ExportMap2, maps: astencode::Maps,\n-               symbol_hasher: hash::State, link_meta: LinkMeta,\n-               reachable: reachable::map) -> CrateContext {\n+    pub fn new(sess: session::Session,\n+               name: &str,\n+               tcx: ty::ctxt,\n+               emap2: resolve::ExportMap2,\n+               maps: astencode::Maps,\n+               symbol_hasher: hash::State,\n+               link_meta: LinkMeta,\n+               reachable: @mut HashSet<ast::node_id>)\n+               -> CrateContext {\n         unsafe {\n             let llcx = llvm::LLVMContextCreate();\n             set_task_llcx(llcx);"}, {"sha": "35322730756026562e4442e545b38d6bd878e557", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -907,9 +907,12 @@ fn trans_lvalue_unadjusted(bcx: block, expr: @ast::expr) -> DatumBlock {\n         let scaled_ix = Mul(bcx, ix_val, vt.llunit_size);\n         base::maybe_name_value(bcx.ccx(), scaled_ix, \"scaled_ix\");\n \n-        let mut (bcx, base, len) =\n+        let (bcx, base, len) =\n             base_datum.get_vec_base_and_len(bcx, index_expr.span,\n                                             index_expr.id, 0);\n+        let mut bcx = bcx;\n+        let mut base = base;\n+        let mut len = len;\n \n         if ty::type_is_str(base_ty) {\n             // acccount for null terminator in the case of string"}, {"sha": "64d6bbec87c48a36d7b9e651a67206b3a02fb55c", "filename": "src/librustc/middle/trans/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmod.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -37,7 +37,6 @@ pub mod foreign;\n pub mod reflect;\n pub mod debuginfo;\n pub mod type_use;\n-pub mod reachable;\n pub mod machine;\n pub mod adt;\n pub mod asm;"}, {"sha": "e950c24c49e8d415c40bac705c59ada2357b1fc0", "filename": "src/librustc/middle/trans/reachable.rs", "status": "removed", "additions": 0, "deletions": 246, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/4e4e2f70c90f01b5be22a192c883b9dcb34df7ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4e4e2f70c90f01b5be22a192c883b9dcb34df7ff/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=4e4e2f70c90f01b5be22a192c883b9dcb34df7ff", "patch": "@@ -1,246 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Finds items that are externally reachable, to determine which items\n-// need to have their metadata (and possibly their AST) serialized.\n-// All items that can be referred to through an exported name are\n-// reachable, and when a reachable thing is inline or generic, it\n-// makes all other generics or inline functions that it references\n-// reachable as well.\n-\n-use core::prelude::*;\n-\n-use middle::resolve;\n-use middle::ty;\n-use middle::typeck;\n-\n-use core::hashmap::HashSet;\n-use syntax::ast;\n-use syntax::ast::*;\n-use syntax::ast_util::def_id_of_def;\n-use syntax::attr;\n-use syntax::codemap;\n-use syntax::print::pprust::expr_to_str;\n-use syntax::{visit, ast_map};\n-\n-pub type map = @HashSet<node_id>;\n-\n-struct ctx<'self> {\n-    exp_map2: resolve::ExportMap2,\n-    tcx: ty::ctxt,\n-    method_map: typeck::method_map,\n-    rmap: &'self mut HashSet<node_id>,\n-}\n-\n-pub fn find_reachable(crate_mod: &_mod, exp_map2: resolve::ExportMap2,\n-                      tcx: ty::ctxt, method_map: typeck::method_map) -> map {\n-    let mut rmap = HashSet::new();\n-    {\n-        let cx = @mut ctx {\n-            exp_map2: exp_map2,\n-            tcx: tcx,\n-            method_map: method_map,\n-            rmap: &mut rmap\n-        };\n-        traverse_public_mod(cx, ast::crate_node_id, crate_mod);\n-        traverse_all_resources_and_impls(cx, crate_mod);\n-    }\n-    return @rmap;\n-}\n-\n-fn traverse_exports(cx: @mut ctx, mod_id: node_id) -> bool {\n-    let mut found_export = false;\n-    match cx.exp_map2.find(&mod_id) {\n-      Some(ref exp2s) => {\n-        for (*exp2s).iter().advance |e2| {\n-            found_export = true;\n-            traverse_def_id(cx, e2.def_id)\n-        };\n-      }\n-      None => ()\n-    }\n-    return found_export;\n-}\n-\n-fn traverse_def_id(cx: @mut ctx, did: def_id) {\n-    if did.crate != local_crate { return; }\n-    match cx.tcx.items.find(&did.node) {\n-        None => (), // This can happen for self, for example\n-        Some(&ast_map::node_item(item, _)) => traverse_public_item(cx, item),\n-        Some(&ast_map::node_method(_, impl_id, _)) => traverse_def_id(cx, impl_id),\n-        Some(&ast_map::node_foreign_item(item, _, _, _)) => {\n-            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-            cx.rmap.insert(item.id);\n-        }\n-        Some(&ast_map::node_variant(ref v, _, _)) => {\n-            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-            cx.rmap.insert(v.node.id);\n-        }\n-        _ => ()\n-    }\n-}\n-\n-fn traverse_public_mod(cx: @mut ctx, mod_id: node_id, m: &_mod) {\n-    if !traverse_exports(cx, mod_id) {\n-        // No exports, so every local item is exported\n-        for m.items.iter().advance |item| {\n-            traverse_public_item(cx, *item);\n-        }\n-    }\n-}\n-\n-fn traverse_public_item(cx: @mut ctx, item: @item) {\n-    {\n-        // FIXME #6021: naming rmap shouldn't be necessary\n-        let cx = &mut *cx;\n-        let rmap: &mut HashSet<node_id> = cx.rmap;\n-        if rmap.contains(&item.id) { return; }\n-        rmap.insert(item.id);\n-    }\n-\n-    match item.node {\n-      item_mod(ref m) => traverse_public_mod(cx, item.id, m),\n-      item_foreign_mod(ref nm) => {\n-          if !traverse_exports(cx, item.id) {\n-              for nm.items.iter().advance |item| {\n-                  let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-                  cx.rmap.insert(item.id);\n-              }\n-          }\n-      }\n-      item_fn(_, _, _, ref generics, ref blk) => {\n-        if generics.ty_params.len() > 0u ||\n-           attr::find_inline_attr(item.attrs) != attr::ia_none {\n-            traverse_inline_body(cx, blk);\n-        }\n-      }\n-      item_impl(ref generics, _, _, ref ms) => {\n-        for ms.iter().advance |m| {\n-            if generics.ty_params.len() > 0u ||\n-                m.generics.ty_params.len() > 0u ||\n-                attr::find_inline_attr(m.attrs) != attr::ia_none\n-            {\n-                {\n-                    let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-                    cx.rmap.insert(m.id);\n-                }\n-                traverse_inline_body(cx, &m.body);\n-            }\n-        }\n-      }\n-      item_struct(ref struct_def, _) => {\n-        for struct_def.ctor_id.iter().advance |&ctor_id| {\n-            let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-            cx.rmap.insert(ctor_id);\n-        }\n-      }\n-      item_ty(t, _) => {\n-        traverse_ty(t, (cx,\n-                        visit::mk_vt(@visit::Visitor {visit_ty: traverse_ty,\n-                                                      ..*visit::default_visitor()})))\n-      }\n-      item_static(*) |\n-      item_enum(*) | item_trait(*) => (),\n-      item_mac(*) => fail!(\"item macros unimplemented\")\n-    }\n-}\n-\n-fn traverse_ty<'a>(ty: @Ty, (cx, v): (@mut ctx<'a>, visit::vt<@mut ctx<'a>>)) {\n-    {\n-        let cx = &mut *cx; // FIXME(#6269) reborrow @mut to &mut\n-        if cx.rmap.contains(&ty.id) { return; }\n-        cx.rmap.insert(ty.id);\n-    }\n-\n-    match ty.node {\n-      ty_path(p, _bounds, p_id) => {\n-        match cx.tcx.def_map.find(&p_id) {\n-          // Kind of a hack to check this here, but I'm not sure what else\n-          // to do\n-          Some(&def_prim_ty(_)) => { /* do nothing */ }\n-          Some(&d) => traverse_def_id(cx, def_id_of_def(d)),\n-          None    => { /* do nothing -- but should we fail here? */ }\n-        }\n-        for p.types.iter().advance |t| {\n-            (v.visit_ty)(*t, (cx, v));\n-        }\n-      }\n-      _ => visit::visit_ty(ty, (cx, v))\n-    }\n-}\n-\n-fn traverse_inline_body(cx: @mut ctx, body: &blk) {\n-    fn traverse_expr<'a>(e: @expr, (cx, v): (@mut ctx<'a>,\n-                                             visit::vt<@mut ctx<'a>>)) {\n-        match e.node {\n-          expr_path(_) => {\n-            match cx.tcx.def_map.find(&e.id) {\n-                Some(&d) => {\n-                    traverse_def_id(cx, def_id_of_def(d));\n-                }\n-                None => cx.tcx.sess.span_bug(\n-                    e.span,\n-                    fmt!(\"Unbound node id %? while traversing %s\",\n-                         e.id,\n-                         expr_to_str(e, cx.tcx.sess.intr())))\n-            }\n-          }\n-          expr_method_call(*) => {\n-            match cx.method_map.find(&e.id) {\n-              Some(&typeck::method_map_entry {\n-                  origin: typeck::method_static(did),\n-                  _\n-                }) => {\n-                traverse_def_id(cx, did);\n-              }\n-              Some(_) => {}\n-              None => {\n-                cx.tcx.sess.span_bug(e.span, \"expr_method_call not in \\\n-                                              method map\");\n-              }\n-            }\n-          }\n-          _ => ()\n-        }\n-        visit::visit_expr(e, (cx, v));\n-    }\n-    // Don't ignore nested items: for example if a generic fn contains a\n-    // generic impl (as in deque::create), we need to monomorphize the\n-    // impl as well\n-    fn traverse_item(i: @item, (cx, _v): (@mut ctx, visit::vt<@mut ctx>)) {\n-      traverse_public_item(cx, i);\n-    }\n-    visit::visit_block(body, (cx, visit::mk_vt(@visit::Visitor {\n-        visit_expr: traverse_expr,\n-        visit_item: traverse_item,\n-         ..*visit::default_visitor()\n-    })));\n-}\n-\n-fn traverse_all_resources_and_impls(cx: @mut ctx, crate_mod: &_mod) {\n-    visit::visit_mod(\n-        crate_mod,\n-        codemap::dummy_sp(),\n-        0,\n-        (cx,\n-        visit::mk_vt(@visit::Visitor {\n-            visit_expr: |_e, (_cx, _v)| { },\n-            visit_item: |i, (cx, v)| {\n-                visit::visit_item(i, (cx, v));\n-                match i.node {\n-                    item_impl(*) => {\n-                        traverse_public_item(cx, i);\n-                    }\n-                    _ => ()\n-                }\n-            },\n-            ..*visit::default_visitor()\n-        })));\n-}"}, {"sha": "175529be206296701996ae73bdf19915aac6f51b", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 40, "deletions": 38, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -686,8 +686,8 @@ pub type BuiltinBounds = EnumSet<BuiltinBound>;\n pub enum BuiltinBound {\n     BoundCopy,\n     BoundStatic,\n-    BoundOwned,\n-    BoundConst,\n+    BoundSend,\n+    BoundFreeze,\n     BoundSized,\n }\n \n@@ -699,8 +699,8 @@ pub fn AllBuiltinBounds() -> BuiltinBounds {\n     let mut set = EnumSet::empty();\n     set.add(BoundCopy);\n     set.add(BoundStatic);\n-    set.add(BoundOwned);\n-    set.add(BoundConst);\n+    set.add(BoundSend);\n+    set.add(BoundFreeze);\n     set.add(BoundSized);\n     set\n }\n@@ -1838,8 +1838,8 @@ impl TypeContents {\n         match bb {\n             BoundCopy => self.is_copy(cx),\n             BoundStatic => self.is_static(cx),\n-            BoundConst => self.is_const(cx),\n-            BoundOwned => self.is_owned(cx),\n+            BoundFreeze => self.is_freezable(cx),\n+            BoundSend => self.is_sendable(cx),\n             BoundSized => self.is_sized(cx),\n         }\n     }\n@@ -1865,23 +1865,23 @@ impl TypeContents {\n         TC_BORROWED_POINTER\n     }\n \n-    pub fn is_owned(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::nonowned(cx))\n+    pub fn is_sendable(&self, cx: ctxt) -> bool {\n+        !self.intersects(TypeContents::nonsendable(cx))\n     }\n \n-    pub fn nonowned(_cx: ctxt) -> TypeContents {\n-        TC_MANAGED + TC_BORROWED_POINTER + TC_NON_OWNED\n+    pub fn nonsendable(_cx: ctxt) -> TypeContents {\n+        TC_MANAGED + TC_BORROWED_POINTER + TC_NON_SENDABLE\n     }\n \n     pub fn contains_managed(&self) -> bool {\n         self.intersects(TC_MANAGED)\n     }\n \n-    pub fn is_const(&self, cx: ctxt) -> bool {\n-        !self.intersects(TypeContents::nonconst(cx))\n+    pub fn is_freezable(&self, cx: ctxt) -> bool {\n+        !self.intersects(TypeContents::nonfreezable(cx))\n     }\n \n-    pub fn nonconst(_cx: ctxt) -> TypeContents {\n+    pub fn nonfreezable(_cx: ctxt) -> TypeContents {\n         TC_MUTABLE\n     }\n \n@@ -1908,12 +1908,12 @@ impl TypeContents {\n             // this assertion.\n             assert!(self.intersects(TC_OWNED_POINTER));\n         }\n-        let tc = TC_MANAGED + TC_DTOR + TypeContents::owned(cx);\n+        let tc = TC_MANAGED + TC_DTOR + TypeContents::sendable(cx);\n         self.intersects(tc)\n     }\n \n-    pub fn owned(_cx: ctxt) -> TypeContents {\n-        //! Any kind of owned contents.\n+    pub fn sendable(_cx: ctxt) -> TypeContents {\n+        //! Any kind of sendable contents.\n         TC_OWNED_POINTER + TC_OWNED_VEC\n     }\n }\n@@ -1969,8 +1969,8 @@ static TC_ONCE_CLOSURE: TypeContents =     TypeContents{bits: 0b0001_0000_0000};\n /// An enum with no variants.\n static TC_EMPTY_ENUM: TypeContents =       TypeContents{bits: 0b0010_0000_0000};\n \n-/// Contains a type marked with `#[non_owned]`\n-static TC_NON_OWNED: TypeContents =        TypeContents{bits: 0b0100_0000_0000};\n+/// Contains a type marked with `#[non_sendable]`\n+static TC_NON_SENDABLE: TypeContents =     TypeContents{bits: 0b0100_0000_0000};\n \n /// Is a bare vector, str, function, trait, etc (only relevant at top level).\n static TC_DYNAMIC_SIZE: TypeContents =     TypeContents{bits: 0b1000_0000_0000};\n@@ -1986,12 +1986,12 @@ pub fn type_is_static(cx: ctxt, t: ty::t) -> bool {\n     type_contents(cx, t).is_static(cx)\n }\n \n-pub fn type_is_owned(cx: ctxt, t: ty::t) -> bool {\n-    type_contents(cx, t).is_owned(cx)\n+pub fn type_is_sendable(cx: ctxt, t: ty::t) -> bool {\n+    type_contents(cx, t).is_sendable(cx)\n }\n \n-pub fn type_is_const(cx: ctxt, t: ty::t) -> bool {\n-    type_contents(cx, t).is_const(cx)\n+pub fn type_is_freezable(cx: ctxt, t: ty::t) -> bool {\n+    type_contents(cx, t).is_freezable(cx)\n }\n \n pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n@@ -2045,7 +2045,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         let _i = indenter();\n \n         let result = match get(ty).sty {\n-            // Scalar and unique types are sendable, constant, and owned\n+            // Scalar and unique types are sendable, freezable, and durable\n             ty_nil | ty_bot | ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(_) | ty_ptr(_) => {\n                 TC_NONE\n@@ -2060,7 +2060,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             }\n \n             ty_box(mt) => {\n-                TC_MANAGED + statically_sized(nonowned(tc_mt(cx, mt, cache)))\n+                TC_MANAGED +\n+                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n             }\n \n             ty_trait(_, _, store, mutbl, bounds) => {\n@@ -2069,7 +2070,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n             ty_rptr(r, mt) => {\n                 borrowed_contents(r, mt.mutbl) +\n-                    statically_sized(nonowned(tc_mt(cx, mt, cache)))\n+                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n             }\n \n             ty_uniq(mt) => {\n@@ -2081,12 +2082,13 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             }\n \n             ty_evec(mt, vstore_box) => {\n-                TC_MANAGED + statically_sized(nonowned(tc_mt(cx, mt, cache)))\n+                TC_MANAGED +\n+                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n             }\n \n             ty_evec(mt, vstore_slice(r)) => {\n                 borrowed_contents(r, mt.mutbl) +\n-                    statically_sized(nonowned(tc_mt(cx, mt, cache)))\n+                    statically_sized(nonsendable(tc_mt(cx, mt, cache)))\n             }\n \n             ty_evec(mt, vstore_fixed(_)) => {\n@@ -2118,7 +2120,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                     TC_NONE,\n                     |tc, f| tc + tc_mt(cx, f.mt, cache));\n                 if ty::has_dtor(cx, did) {\n-                    res += TC_DTOR;\n+                    res = res + TC_DTOR;\n                 }\n                 apply_tc_attr(cx, did, res)\n             }\n@@ -2203,10 +2205,10 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n     fn apply_tc_attr(cx: ctxt, did: def_id, mut tc: TypeContents) -> TypeContents {\n         if has_attr(cx, did, \"mutable\") {\n-            tc += TC_MUTABLE;\n+            tc = tc + TC_MUTABLE;\n         }\n-        if has_attr(cx, did, \"non_owned\") {\n-            tc += TC_NON_OWNED;\n+        if has_attr(cx, did, \"non_sendable\") {\n+            tc = tc + TC_NON_SENDABLE;\n         }\n         tc\n     }\n@@ -2227,7 +2229,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n         mc + rc\n     }\n \n-    fn nonowned(pointee: TypeContents) -> TypeContents {\n+    fn nonsendable(pointee: TypeContents) -> TypeContents {\n         /*!\n          *\n          * Given a non-owning pointer to some type `T` with\n@@ -2291,11 +2293,11 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 BoundCopy if store == UniqTraitStore\n                             => TC_NONCOPY_TRAIT,\n                 BoundCopy   => TC_NONE, // @Trait/&Trait are copyable either way\n-                BoundStatic if bounds.contains_elem(BoundOwned)\n-                            => TC_NONE, // Owned bound implies static bound.\n+                BoundStatic if bounds.contains_elem(BoundSend)\n+                            => TC_NONE, // Send bound implies static bound.\n                 BoundStatic => TC_BORROWED_POINTER, // Useful for \"@Trait:'static\"\n-                BoundOwned  => TC_NON_OWNED,\n-                BoundConst  => TC_MUTABLE,\n+                BoundSend   => TC_NON_SENDABLE,\n+                BoundFreeze => TC_MUTABLE,\n                 BoundSized  => TC_NONE, // don't care if interior is sized\n             };\n         }\n@@ -2314,8 +2316,8 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             tc = tc - match bound {\n                 BoundCopy => TypeContents::noncopyable(cx),\n                 BoundStatic => TypeContents::nonstatic(cx),\n-                BoundOwned => TypeContents::nonowned(cx),\n-                BoundConst => TypeContents::nonconst(cx),\n+                BoundSend => TypeContents::nonsendable(cx),\n+                BoundFreeze => TypeContents::nonfreezable(cx),\n                 // The dynamic-size bit can be removed at pointer-level, etc.\n                 BoundSized => TypeContents::dynamically_sized(cx),\n             };"}, {"sha": "07fb23fea48a3323c145d9f072d0885727b6ff38", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -753,7 +753,7 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n     //! Converts a list of bounds from the AST into a `BuiltinBounds`\n     //! struct. Reports an error if any of the bounds that appear\n     //! in the AST refer to general traits and not the built-in traits\n-    //! like `Copy` or `Owned`. Used to translate the bounds that\n+    //! like `Copy` or `Send`. Used to translate the bounds that\n     //! appear in closure and trait types, where only builtin bounds are\n     //! legal.\n     //! If no bounds were specified, we choose a \"default\" bound based on\n@@ -788,9 +788,9 @@ fn conv_builtin_bounds(tcx: ty::ctxt, ast_bounds: &Option<OptVec<ast::TyParamBou\n             }\n             builtin_bounds\n         },\n-        // ~Trait is sugar for ~Trait:Owned.\n+        // ~Trait is sugar for ~Trait:Send.\n         (&None, ty::UniqTraitStore) => {\n-            let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundOwned); set\n+            let mut set = ty::EmptyBuiltinBounds(); set.add(ty::BoundSend); set\n         }\n         // @Trait is sugar for @Trait:'static.\n         // &'static Trait is sugar for &'static Trait:'static.\n@@ -807,19 +807,19 @@ pub fn try_add_builtin_trait(tcx: ty::ctxt,\n                              trait_def_id: ast::def_id,\n                              builtin_bounds: &mut ty::BuiltinBounds) -> bool {\n     //! Checks whether `trait_ref` refers to one of the builtin\n-    //! traits, like `Copy` or `Owned`, and adds the corresponding\n+    //! traits, like `Copy` or `Send`, and adds the corresponding\n     //! bound to the set `builtin_bounds` if so. Returns true if `trait_ref`\n     //! is a builtin trait.\n \n     let li = &tcx.lang_items;\n-    if trait_def_id == li.owned_trait() {\n-        builtin_bounds.add(ty::BoundOwned);\n+    if trait_def_id == li.send_trait() {\n+        builtin_bounds.add(ty::BoundSend);\n         true\n     } else if trait_def_id == li.copy_trait() {\n         builtin_bounds.add(ty::BoundCopy);\n         true\n-    } else if trait_def_id == li.const_trait() {\n-        builtin_bounds.add(ty::BoundConst);\n+    } else if trait_def_id == li.freeze_trait() {\n+        builtin_bounds.add(ty::BoundFreeze);\n         true\n     } else if trait_def_id == li.sized_trait() {\n         builtin_bounds.add(ty::BoundSized);"}, {"sha": "58a527f35018dfe9b4542ff244376f93eb3da9bc", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -538,7 +538,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n           check_pointer_pat(pcx, Managed, inner, pat.id, pat.span, expected);\n       }\n       ast::pat_uniq(inner) => {\n-          check_pointer_pat(pcx, Owned, inner, pat.id, pat.span, expected);\n+          check_pointer_pat(pcx, Send, inner, pat.id, pat.span, expected);\n       }\n       ast::pat_region(inner) => {\n           check_pointer_pat(pcx, Borrowed, inner, pat.id, pat.span, expected);\n@@ -624,7 +624,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n         ty::ty_box(e_inner) if pointer_kind == Managed => {\n             check_inner(e_inner);\n         }\n-        ty::ty_uniq(e_inner) if pointer_kind == Owned => {\n+        ty::ty_uniq(e_inner) if pointer_kind == Send => {\n             check_inner(e_inner);\n         }\n         ty::ty_rptr(_, e_inner) if pointer_kind == Borrowed => {\n@@ -641,7 +641,7 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n                 Some(expected),\n                 fmt!(\"%s pattern\", match pointer_kind {\n                     Managed => \"an @-box\",\n-                    Owned => \"a ~-box\",\n+                    Send => \"a ~-box\",\n                     Borrowed => \"an &-pointer\"\n                 }),\n                 None);\n@@ -651,4 +651,4 @@ pub fn check_pointer_pat(pcx: &pat_ctxt,\n }\n \n #[deriving(Eq)]\n-enum PointerKind { Managed, Owned, Borrowed }\n+enum PointerKind { Managed, Send, Borrowed }"}, {"sha": "4bebca3c9a8b3308caff76da6b2fd9cbfd8dd9e5", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -1088,16 +1088,19 @@ impl<'self> LookupContext<'self> {\n             _ => {}\n         }\n \n-        return match candidate.method_ty.explicit_self {\n+        let result = match candidate.method_ty.explicit_self {\n             sty_static => {\n+                debug!(\"(is relevant?) explicit self is static\");\n                 false\n             }\n \n             sty_value => {\n+                debug!(\"(is relevant?) explicit self is by-value\");\n                 self.fcx.can_mk_subty(rcvr_ty, candidate.rcvr_ty).is_ok()\n             }\n \n             sty_region(_, m) => {\n+                debug!(\"(is relevant?) explicit self is a region\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_rptr(_, mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1109,6 +1112,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_box(m) => {\n+                debug!(\"(is relevant?) explicit self is a box\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_box(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1120,6 +1124,7 @@ impl<'self> LookupContext<'self> {\n             }\n \n             sty_uniq(m) => {\n+                debug!(\"(is relevant?) explicit self is a unique pointer\");\n                 match ty::get(rcvr_ty).sty {\n                     ty::ty_uniq(mt) => {\n                         mutability_matches(mt.mutbl, m) &&\n@@ -1131,6 +1136,10 @@ impl<'self> LookupContext<'self> {\n             }\n         };\n \n+        debug!(\"(is relevant?) %s\", if result { \"yes\" } else { \"no\" });\n+\n+        return result;\n+\n         fn mutability_matches(self_mutbl: ast::mutability,\n                               candidate_mutbl: ast::mutability) -> bool {\n             //! True if `self_mutbl <: candidate_mutbl`"}, {"sha": "4c1c8e5c2c8a3cd2cced0c9b2da05068a5074d0a", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 15, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -213,6 +213,13 @@ impl PurityState {\n     }\n }\n \n+/// Whether `check_binop` allows overloaded operators to be invoked.\n+#[deriving(Eq)]\n+enum AllowOverloadedOperatorsFlag {\n+    AllowOverloadedOperators,\n+    DontAllowOverloadedOperators,\n+}\n+\n pub struct FnCtxt {\n     // Number of errors that had been reported when we started\n     // checking this function. On exit, if we find that *more* errors\n@@ -784,10 +791,6 @@ impl FnCtxt {\n         ast_ty_to_ty(self, self, ast_t)\n     }\n \n-    pub fn expr_to_str(&self, expr: @ast::expr) -> ~str {\n-        expr.repr(self.tcx())\n-    }\n-\n     pub fn pat_to_str(&self, pat: @ast::pat) -> ~str {\n         pat.repr(self.tcx())\n     }\n@@ -796,9 +799,8 @@ impl FnCtxt {\n         match self.inh.node_types.find(&ex.id) {\n             Some(&t) => t,\n             None => {\n-                self.tcx().sess.bug(\n-                    fmt!(\"no type for %s in fcx %s\",\n-                         self.expr_to_str(ex), self.tag()));\n+                self.tcx().sess.bug(fmt!(\"no type for expr in fcx %s\",\n+                                         self.tag()));\n             }\n         }\n     }\n@@ -1138,7 +1140,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                expr: @ast::expr,\n                                expected: Option<ty::t>,\n                                unifier: &fn()) {\n-    debug!(\">> typechecking %s\", fcx.expr_to_str(expr));\n+    debug!(\">> typechecking\");\n \n     fn check_method_argument_types(\n         fcx: @mut FnCtxt,\n@@ -1391,6 +1393,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 method_map.insert(expr.id, (*entry));\n             }\n             None => {\n+                debug!(\"(checking method call) failing expr is %d\", expr.id);\n+\n                 fcx.type_error_message(expr.span,\n                   |actual| {\n                       fmt!(\"type `%s` does not implement any method in scope \\\n@@ -1487,7 +1491,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                    lhs: @ast::expr,\n                    rhs: @ast::expr,\n                    // Used only in the error case\n-                   expected_result: Option<ty::t>\n+                   expected_result: Option<ty::t>,\n+                   allow_overloaded_operators: AllowOverloadedOperatorsFlag\n                   ) {\n         let tcx = fcx.ccx.tcx;\n \n@@ -1537,8 +1542,30 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         }\n \n-        let result_t = check_user_binop(fcx, callee_id, expr, lhs, lhs_t, op, rhs,\n-                                       expected_result);\n+        // Check for overloaded operators if allowed.\n+        let result_t;\n+        if allow_overloaded_operators == AllowOverloadedOperators {\n+            result_t = check_user_binop(fcx,\n+                                        callee_id,\n+                                        expr,\n+                                        lhs,\n+                                        lhs_t,\n+                                        op,\n+                                        rhs,\n+                                        expected_result);\n+        } else {\n+            fcx.type_error_message(expr.span,\n+                                   |actual| {\n+                                        fmt!(\"binary operation %s cannot be \\\n+                                              applied to type `%s`\",\n+                                             ast_util::binop_to_str(op),\n+                                             actual)\n+                                   },\n+                                   lhs_t,\n+                                   None);\n+            result_t = ty::mk_err();\n+        }\n+\n         fcx.write_ty(expr.id, result_t);\n         if ty::type_is_error(result_t) {\n             fcx.write_ty(rhs.id, result_t);\n@@ -1704,8 +1731,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n             ty::mk_closure(tcx, fn_ty_copy)\n         };\n \n-        debug!(\"check_expr_fn_with_unifier %s fty=%s\",\n-               fcx.expr_to_str(expr),\n+        debug!(\"check_expr_fn_with_unifier fty=%s\",\n                fcx.infcx().ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n@@ -2229,7 +2255,15 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         fcx.write_ty(id, typ);\n       }\n       ast::expr_binary(callee_id, op, lhs, rhs) => {\n-        check_binop(fcx, callee_id, expr, op, lhs, rhs, expected);\n+        check_binop(fcx,\n+                    callee_id,\n+                    expr,\n+                    op,\n+                    lhs,\n+                    rhs,\n+                    expected,\n+                    AllowOverloadedOperators);\n+\n         let lhs_ty = fcx.expr_ty(lhs);\n         let rhs_ty = fcx.expr_ty(rhs);\n         if ty::type_is_error(lhs_ty) ||\n@@ -2242,7 +2276,15 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         }\n       }\n       ast::expr_assign_op(callee_id, op, lhs, rhs) => {\n-        check_binop(fcx, callee_id, expr, op, lhs, rhs, expected);\n+        check_binop(fcx,\n+                    callee_id,\n+                    expr,\n+                    op,\n+                    lhs,\n+                    rhs,\n+                    expected,\n+                    DontAllowOverloadedOperators);\n+\n         let lhs_t = fcx.expr_ty(lhs);\n         let result_t = fcx.expr_ty(expr);\n         demand::suptype(fcx, expr.span, result_t, lhs_t);\n@@ -3247,6 +3289,9 @@ pub fn ty_param_bounds_and_ty_for_def(fcx: @mut FnCtxt,\n       ast::def_self_ty(*) => {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found self ty\");\n       }\n+      ast::def_method(*) => {\n+        fcx.ccx.tcx.sess.span_bug(sp, \"expected value but found method\");\n+      }\n     }\n }\n "}, {"sha": "df81ebd48aa235286fff10698e65f6d01e4fb1c1", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -230,7 +230,7 @@ fn constrain_bindings_in_pat(pat: @ast::pat, rcx: @mut Rcx) {\n }\n \n fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n-    debug!(\"regionck::visit_expr(e=%s)\", rcx.fcx.expr_to_str(expr));\n+    debug!(\"regionck::visit_expr(e=?)\");\n \n     let has_method_map = rcx.fcx.inh.method_map.contains_key(&expr.id);\n \n@@ -520,8 +520,7 @@ fn constrain_derefs(rcx: @mut Rcx,\n     let tcx = rcx.fcx.tcx();\n     let r_deref_expr = ty::re_scope(deref_expr.id);\n     for uint::range(0, derefs) |i| {\n-        debug!(\"constrain_derefs(deref_expr=%s, derefd_ty=%s, derefs=%?/%?\",\n-               rcx.fcx.expr_to_str(deref_expr),\n+        debug!(\"constrain_derefs(deref_expr=?, derefd_ty=%s, derefs=%?/%?\",\n                rcx.fcx.infcx().ty_to_str(derefd_ty),\n                i, derefs);\n \n@@ -576,8 +575,7 @@ fn constrain_index(rcx: @mut Rcx,\n \n     let tcx = rcx.fcx.tcx();\n \n-    debug!(\"constrain_index(index_expr=%s, indexed_ty=%s\",\n-           rcx.fcx.expr_to_str(index_expr),\n+    debug!(\"constrain_index(index_expr=?, indexed_ty=%s\",\n            rcx.fcx.infcx().ty_to_str(indexed_ty));\n \n     let r_index_expr = ty::re_scope(index_expr.id);\n@@ -808,7 +806,7 @@ pub mod guarantor {\n          * to the lifetime of its guarantor (if any).\n          */\n \n-        debug!(\"guarantor::for_addr_of(base=%s)\", rcx.fcx.expr_to_str(base));\n+        debug!(\"guarantor::for_addr_of(base=?)\");\n \n         let guarantor = guarantor(rcx, base);\n         link(rcx, expr.span, expr.id, guarantor);\n@@ -842,8 +840,7 @@ pub mod guarantor {\n          * region pointers.\n          */\n \n-        debug!(\"guarantor::for_autoref(expr=%s, autoref=%?)\",\n-               rcx.fcx.expr_to_str(expr), autoref);\n+        debug!(\"guarantor::for_autoref(autoref=%?)\", autoref);\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         debug!(\"    unadjusted cat=%?\", expr_ct.cat);\n@@ -970,7 +967,7 @@ pub mod guarantor {\n          * `&expr`).\n          */\n \n-        debug!(\"guarantor(expr=%s)\", rcx.fcx.expr_to_str(expr));\n+        debug!(\"guarantor()\");\n         match expr.node {\n             ast::expr_unary(_, ast::deref, b) => {\n                 let cat = categorize(rcx, b);\n@@ -1034,7 +1031,7 @@ pub mod guarantor {\n     }\n \n     fn categorize(rcx: @mut Rcx, expr: @ast::expr) -> ExprCategorization {\n-        debug!(\"categorize(expr=%s)\", rcx.fcx.expr_to_str(expr));\n+        debug!(\"categorize()\");\n \n         let mut expr_ct = categorize_unadjusted(rcx, expr);\n         debug!(\"before adjustments, cat=%?\", expr_ct.cat);\n@@ -1086,7 +1083,7 @@ pub mod guarantor {\n     fn categorize_unadjusted(rcx: @mut Rcx,\n                              expr: @ast::expr)\n                           -> ExprCategorizationType {\n-        debug!(\"categorize_unadjusted(expr=%s)\", rcx.fcx.expr_to_str(expr));\n+        debug!(\"categorize_unadjusted()\");\n \n         let guarantor = {\n             if rcx.fcx.inh.method_map.contains_key(&expr.id) {"}, {"sha": "a537d0cc72c571ed64c9d931bd44f16ddbb4cca4", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 71, "deletions": 90, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -17,7 +17,7 @@\n use core::prelude::*;\n \n use metadata::csearch::{each_path, get_impl_trait};\n-use metadata::csearch::{get_impls_for_mod};\n+use metadata::csearch;\n use metadata::cstore::{CStore, iter_crate_data};\n use metadata::decoder::{dl_def, dl_field, dl_impl};\n use middle::resolve::{Impl, MethodInfo};\n@@ -855,92 +855,81 @@ impl CoherenceChecker {\n \n     // External crate handling\n \n-    pub fn add_impls_for_module(&self,\n-                                impls_seen: &mut HashSet<def_id>,\n-                                crate_store: @mut CStore,\n-                                module_def_id: def_id) {\n-        let implementations = get_impls_for_mod(crate_store,\n-                                                module_def_id,\n-                                                None);\n-        for implementations.iter().advance |implementation| {\n-            debug!(\"coherence: adding impl from external crate: %s\",\n-                   ty::item_path_str(self.crate_context.tcx,\n-                                     implementation.did));\n-\n-            // Make sure we don't visit the same implementation\n-            // multiple times.\n-            if !impls_seen.insert(implementation.did) {\n-                // Skip this one.\n-                loop;\n-            }\n-            // Good. Continue.\n+    pub fn add_external_impl(&self,\n+                             impls_seen: &mut HashSet<def_id>,\n+                             crate_store: @mut CStore,\n+                             impl_def_id: def_id) {\n+        let implementation = csearch::get_impl(crate_store, impl_def_id);\n \n-            let self_type = lookup_item_type(self.crate_context.tcx,\n-                                             implementation.did);\n-            let associated_traits = get_impl_trait(self.crate_context.tcx,\n-                                                    implementation.did);\n+        debug!(\"coherence: adding impl from external crate: %s\",\n+               ty::item_path_str(self.crate_context.tcx, implementation.did));\n \n-            // Do a sanity check to make sure that inherent methods have base\n-            // types.\n+        // Make sure we don't visit the same implementation multiple times.\n+        if !impls_seen.insert(implementation.did) {\n+            // Skip this one.\n+            return\n+        }\n+        // Good. Continue.\n \n-            if associated_traits.is_none() {\n-                match get_base_type_def_id(self.inference_context,\n-                                           dummy_sp(),\n-                                           self_type.ty) {\n-                    None => {\n-                        let session = self.crate_context.tcx.sess;\n-                        session.bug(fmt!(\n-                            \"no base type for external impl \\\n-                             with no trait: %s (type %s)!\",\n-                             session.str_of(implementation.ident),\n-                             ty_to_str(self.crate_context.tcx,self_type.ty)));\n-                    }\n-                    Some(_) => {\n-                        // Nothing to do.\n-                    }\n+        let self_type = lookup_item_type(self.crate_context.tcx,\n+                                         implementation.did);\n+        let associated_traits = get_impl_trait(self.crate_context.tcx,\n+                                               implementation.did);\n+\n+        // Do a sanity check to make sure that inherent methods have base\n+        // types.\n+        if associated_traits.is_none() {\n+            match get_base_type_def_id(self.inference_context,\n+                                       dummy_sp(),\n+                                       self_type.ty) {\n+                None => {\n+                    let session = self.crate_context.tcx.sess;\n+                    session.bug(fmt!(\"no base type for external impl with no \\\n+                                      trait: %s (type %s)!\",\n+                                     session.str_of(implementation.ident),\n+                                     ty_to_str(self.crate_context.tcx,\n+                                               self_type.ty)));\n                 }\n+                Some(_) => {} // Nothing to do.\n             }\n+        }\n \n-            let mut implementation = *implementation;\n-\n-            // Record all the trait methods.\n-            for associated_traits.iter().advance |trait_ref| {\n-                self.instantiate_default_methods(implementation.did,\n-                                                 &**trait_ref);\n-                // Could we avoid these copies when we don't need them?\n-                let mut methods = /*bad?*/ copy implementation.methods;\n-                self.add_provided_methods_to_impl(\n-                    &mut methods,\n-                    &trait_ref.def_id,\n-                    &implementation.did);\n-                implementation = @Impl { methods: methods,\n-                                        .. *implementation };\n-\n-\n-                self.add_trait_method(trait_ref.def_id, implementation);\n-            }\n+        // Record all the trait methods.\n+        let mut implementation = @implementation;\n+        for associated_traits.iter().advance |trait_ref| {\n+            self.instantiate_default_methods(implementation.did,\n+                                             *trait_ref);\n+\n+            // XXX(sully): We could probably avoid this copy if there are no\n+            // default methods.\n+            let mut methods = copy implementation.methods;\n+            self.add_provided_methods_to_impl(&mut methods,\n+                                              &trait_ref.def_id,\n+                                              &implementation.did);\n+            implementation = @Impl {\n+                methods: methods,\n+                ..*implementation\n+            };\n \n-            // Add the implementation to the mapping from\n-            // implementation to base type def ID, if there is a base\n-            // type for this implementation.\n+            self.add_trait_method(trait_ref.def_id, implementation);\n+        }\n \n-            match get_base_type_def_id(self.inference_context,\n-                                     dummy_sp(),\n-                                     self_type.ty) {\n-                None => {\n-                    // Nothing to do.\n+        // Add the implementation to the mapping from implementation to base\n+        // type def ID, if there is a base type for this implementation.\n+        match get_base_type_def_id(self.inference_context,\n+                                   dummy_sp(),\n+                                   self_type.ty) {\n+            None => {} // Nothing to do.\n+            Some(base_type_def_id) => {\n+                // inherent methods apply to `impl Type` but not\n+                // `impl Trait for Type`:\n+                if associated_traits.is_none() {\n+                    self.add_inherent_method(base_type_def_id,\n+                                             implementation);\n                 }\n-                Some(base_type_def_id) => {\n-                    // inherent methods apply to `impl Type` but not\n-                    // `impl Trait for Type`:\n-                    if associated_traits.is_none() {\n-                        self.add_inherent_method(base_type_def_id,\n-                                                 implementation);\n-                    }\n \n-                    self.base_type_def_ids.insert(implementation.did,\n-                                                  base_type_def_id);\n-                }\n+                self.base_type_def_ids.insert(implementation.did,\n+                                              base_type_def_id);\n             }\n         }\n     }\n@@ -952,22 +941,14 @@ impl CoherenceChecker {\n \n         let crate_store = self.crate_context.tcx.sess.cstore;\n         do iter_crate_data(crate_store) |crate_number, _crate_metadata| {\n-            self.add_impls_for_module(&mut impls_seen,\n-                                      crate_store,\n-                                      def_id { crate: crate_number,\n-                                               node: 0 });\n-\n             for each_path(crate_store, crate_number) |_, def_like, _| {\n                 match def_like {\n-                    dl_def(def_mod(def_id)) => {\n-                        self.add_impls_for_module(&mut impls_seen,\n-                                                  crate_store,\n-                                                  def_id);\n-                    }\n-                    dl_def(_) | dl_impl(_) | dl_field => {\n-                        // Skip this.\n-                        loop;\n+                    dl_impl(def_id) => {\n+                        self.add_external_impl(&mut impls_seen,\n+                                               crate_store,\n+                                               def_id)\n                     }\n+                    dl_def(_) | dl_field => loop,   // Skip this.\n                 }\n             }\n         }"}, {"sha": "5065a475a4055acb40071a8bec66f73b5af30d40", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -81,10 +81,20 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::crate) {\n         })));\n }\n \n-impl CrateCtxt {\n+pub trait ToTy {\n     fn to_ty<RS:region_scope + Copy + 'static>(\n-        &self, rs: &RS, ast_ty: &ast::Ty) -> ty::t\n-    {\n+             &self,\n+             rs: &RS,\n+             ast_ty: &ast::Ty)\n+             -> ty::t;\n+}\n+\n+impl ToTy for CrateCtxt {\n+    fn to_ty<RS:region_scope + Copy + 'static>(\n+             &self,\n+             rs: &RS,\n+             ast_ty: &ast::Ty)\n+             -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n@@ -1165,7 +1175,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n          * enum consisting of a newtyped Ty or a region) to ty's\n          * notion of ty param bounds, which can either be user-defined\n          * traits, or one of the four built-in traits (formerly known\n-         * as kinds): Const, Copy, and Send.\n+         * as kinds): Freeze, Copy, and Send.\n          */\n \n         let mut param_bounds = ty::ParamBounds {"}, {"sha": "7a4ea0999efab6e5d2a60169ca72ed07e53646ac", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -64,7 +64,8 @@ use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n-use middle::typeck::infer::{cres, InferCtxt, ures};\n+use middle::typeck::infer::unify::{InferCtxtMethods, UnifyInferCtxtMethods};\n+use middle::typeck::infer::{InferCtxt, cres, ures};\n use util::common::indent;\n \n use core::result::{iter_vec2, map_vec2};"}, {"sha": "ed19310d5d69eec6fa597cb62149d937ec637e44", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 77, "deletions": 39, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -71,15 +71,53 @@ impl LatticeValue for ty::t {\n     }\n }\n \n-impl CombineFields {\n-    pub fn var_sub_var<T:Copy + InferStr + LatticeValue,\n-                       V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n-                                                                        a_id:\n-                                                                        V,\n-                                                                        b_id:\n-                                                                        V)\n-                                                                        ->\n-                                                                        ures {\n+pub trait CombineFieldsLatticeMethods {\n+    fn var_sub_var<T:Copy + InferStr + LatticeValue,\n+                   V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n+                                                                    a_id: V,\n+                                                                    b_id: V)\n+                                                                    -> ures;\n+    /// make variable a subtype of T\n+    fn var_sub_t<T:Copy + InferStr + LatticeValue,\n+                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 &self,\n+                 a_id: V,\n+                 b: T)\n+                 -> ures;\n+    fn t_sub_var<T:Copy + InferStr + LatticeValue,\n+                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 &self,\n+                 a: T,\n+                 b_id: V)\n+                 -> ures;\n+    fn merge_bnd<T:Copy + InferStr + LatticeValue>(\n+                 &self,\n+                 a: &Bound<T>,\n+                 b: &Bound<T>,\n+                 lattice_op: LatticeOp<T>)\n+                 -> cres<Bound<T>>;\n+    fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n+                                V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n+                                &self,\n+                                v_id: V,\n+                                a: &Bounds<T>,\n+                                b: &Bounds<T>,\n+                                rank: uint)\n+                                -> ures;\n+    fn bnds<T:Copy + InferStr + LatticeValue>(\n+            &self,\n+            a: &Bound<T>,\n+            b: &Bound<T>)\n+            -> ures;\n+}\n+\n+impl CombineFieldsLatticeMethods for CombineFields {\n+    fn var_sub_var<T:Copy + InferStr + LatticeValue,\n+                   V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                   &self,\n+                   a_id: V,\n+                   b_id: V)\n+                   -> ures {\n         /*!\n          *\n          * Make one variable a subtype of another variable.  This is a\n@@ -127,12 +165,12 @@ impl CombineFields {\n     }\n \n     /// make variable a subtype of T\n-    pub fn var_sub_t<T:Copy + InferStr + LatticeValue,\n-                     V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n-                                                                      a_id: V,\n-                                                                      b: T)\n-                                                                      -> ures\n-                                                                      {\n+    fn var_sub_t<T:Copy + InferStr + LatticeValue,\n+                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 &self,\n+                 a_id: V,\n+                 b: T)\n+                 -> ures {\n         /*!\n          *\n          * Make a variable (`a_id`) a subtype of the concrete type `b` */\n@@ -151,12 +189,12 @@ impl CombineFields {\n             a_id, a_bounds, b_bounds, node_a.rank)\n     }\n \n-    pub fn t_sub_var<T:Copy + InferStr + LatticeValue,\n-                     V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(&self,\n-                                                                      a: T,\n-                                                                      b_id: V)\n-                                                                      -> ures\n-                                                                      {\n+    fn t_sub_var<T:Copy + InferStr + LatticeValue,\n+                 V:Copy + Eq + ToStr + Vid + UnifyVid<Bounds<T>>>(\n+                 &self,\n+                 a: T,\n+                 b_id: V)\n+                 -> ures {\n         /*!\n          *\n          * Make a concrete type (`a`) a subtype of the variable `b_id` */\n@@ -175,12 +213,12 @@ impl CombineFields {\n             b_id, a_bounds, b_bounds, node_b.rank)\n     }\n \n-    pub fn merge_bnd<T:Copy + InferStr + LatticeValue>(&self,\n-                                                       a: &Bound<T>,\n-                                                       b: &Bound<T>,\n-                                                       lattice_op:\n-                                                       LatticeOp<T>)\n-                                                       -> cres<Bound<T>> {\n+    fn merge_bnd<T:Copy + InferStr + LatticeValue>(\n+                 &self,\n+                 a: &Bound<T>,\n+                 b: &Bound<T>,\n+                 lattice_op: LatticeOp<T>)\n+                 -> cres<Bound<T>> {\n         /*!\n          *\n          * Combines two bounds into a more general bound. */\n@@ -202,14 +240,14 @@ impl CombineFields {\n         }\n     }\n \n-    pub fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n-                                    V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n-                                    &self,\n-                                    v_id: V,\n-                                    a: &Bounds<T>,\n-                                    b: &Bounds<T>,\n-                                    rank: uint)\n-                                    -> ures {\n+    fn set_var_to_merged_bounds<T:Copy + InferStr + LatticeValue,\n+                                V:Copy+Eq+ToStr+Vid+UnifyVid<Bounds<T>>>(\n+                                &self,\n+                                v_id: V,\n+                                a: &Bounds<T>,\n+                                b: &Bounds<T>,\n+                                rank: uint)\n+                                -> ures {\n         /*!\n          *\n          * Updates the bounds for the variable `v_id` to be the intersection\n@@ -264,10 +302,10 @@ impl CombineFields {\n         uok()\n     }\n \n-    pub fn bnds<T:Copy + InferStr + LatticeValue>(&self,\n-                                                  a: &Bound<T>,\n-                                                  b: &Bound<T>)\n-                                                  -> ures {\n+    fn bnds<T:Copy + InferStr + LatticeValue>(&self,\n+                                              a: &Bound<T>,\n+                                              b: &Bound<T>)\n+                                              -> ures {\n         debug!(\"bnds(%s <: %s)\", a.inf_str(self.infcx),\n                b.inf_str(self.infcx));\n         let _r = indenter();"}, {"sha": "1311907eed2eea01c63b5eeeb16067660e5e5c92", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -54,7 +54,7 @@ use middle::ty;\n use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{region_var_bound_by_region_var, unresolved_ty};\n use middle::typeck::infer::to_str::InferStr;\n-use middle::typeck::infer::unify::Root;\n+use middle::typeck::infer::unify::{Root, UnifyInferCtxtMethods};\n use util::common::{indent, indenter};\n use util::ppaux::ty_to_str;\n "}, {"sha": "eb912aa2dda4b7c06f1e0e4d432d96d0ee7a86cd", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -18,6 +18,7 @@ use middle::typeck::infer::combine::*;\n use middle::typeck::infer::cres;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::InferCtxt;\n+use middle::typeck::infer::lattice::CombineFieldsLatticeMethods;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n use util::common::{indent, indenter};"}, {"sha": "a185633a7ac77ea0716ee9fe3cfcf5b194a3eff9", "filename": "src/librustc/middle/typeck/infer/unify.rs", "status": "modified", "additions": 68, "deletions": 27, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Funify.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -40,9 +40,31 @@ pub trait UnifyVid<T> {\n                                       -> &'v mut ValsAndBindings<Self, T>;\n }\n \n-impl InferCtxt {\n-    pub fn get<T:Copy, V:Copy+Eq+Vid+UnifyVid<T>>(&mut self, vid: V)\n-                                                  -> Node<V, T> {\n+pub trait UnifyInferCtxtMethods {\n+    fn get<T:Copy,\n+           V:Copy + Eq + Vid + UnifyVid<T>>(\n+           &mut self,\n+           vid: V)\n+           -> Node<V, T>;\n+    fn set<T:Copy + InferStr,\n+           V:Copy + Vid + ToStr + UnifyVid<T>>(\n+           &mut self,\n+           vid: V,\n+           new_v: VarValue<V, T>);\n+    fn unify<T:Copy + InferStr,\n+             V:Copy + Vid + ToStr + UnifyVid<T>>(\n+             &mut self,\n+             node_a: &Node<V, T>,\n+             node_b: &Node<V, T>)\n+             -> (V, uint);\n+}\n+\n+impl UnifyInferCtxtMethods for InferCtxt {\n+    fn get<T:Copy,\n+           V:Copy + Eq + Vid + UnifyVid<T>>(\n+           &mut self,\n+           vid: V)\n+           -> Node<V, T> {\n         /*!\n          *\n          * Find the root node for `vid`. This uses the standard\n@@ -84,10 +106,11 @@ impl InferCtxt {\n         }\n     }\n \n-    pub fn set<T:Copy + InferStr,\n-               V:Copy + Vid + ToStr + UnifyVid<T>>(&mut self,\n-                                                   vid: V,\n-                                                   new_v: VarValue<V, T>) {\n+    fn set<T:Copy + InferStr,\n+           V:Copy + Vid + ToStr + UnifyVid<T>>(\n+           &mut self,\n+           vid: V,\n+           new_v: VarValue<V, T>) {\n         /*!\n          *\n          * Sets the value for `vid` to `new_v`.  `vid` MUST be a root node!\n@@ -102,11 +125,12 @@ impl InferCtxt {\n         vb.vals.insert(vid.to_uint(), new_v);\n     }\n \n-    pub fn unify<T:Copy + InferStr,\n-                 V:Copy + Vid + ToStr + UnifyVid<T>>(&mut self,\n-                                                     node_a: &Node<V, T>,\n-                                                     node_b: &Node<V, T>)\n-                                                     -> (V, uint) {\n+    fn unify<T:Copy + InferStr,\n+             V:Copy + Vid + ToStr + UnifyVid<T>>(\n+             &mut self,\n+             node_a: &Node<V, T>,\n+             node_b: &Node<V, T>)\n+             -> (V, uint) {\n         // Rank optimization: if you don't know what it is, check\n         // out <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>\n \n@@ -155,14 +179,31 @@ pub fn mk_err<T:SimplyUnifiable>(a_is_expected: bool,\n     }\n }\n \n-impl InferCtxt {\n-    pub fn simple_vars<T:Copy+Eq+InferStr+SimplyUnifiable,\n-                       V:Copy+Eq+Vid+ToStr+UnifyVid<Option<T>>>(&mut self,\n-                                                                a_is_expected:\n-                                                                bool,\n-                                                                a_id: V,\n-                                                                b_id: V)\n-                                                                -> ures {\n+pub trait InferCtxtMethods {\n+    fn simple_vars<T:Copy + Eq + InferStr + SimplyUnifiable,\n+                   V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+                   &mut self,\n+                   a_is_expected: bool,\n+                   a_id: V,\n+                   b_id: V)\n+                   -> ures;\n+    fn simple_var_t<T:Copy + Eq + InferStr + SimplyUnifiable,\n+                    V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+                    &mut self,\n+                    a_is_expected: bool,\n+                    a_id: V,\n+                    b: T)\n+                    -> ures;\n+}\n+\n+impl InferCtxtMethods for InferCtxt {\n+    fn simple_vars<T:Copy + Eq + InferStr + SimplyUnifiable,\n+                   V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+                   &mut self,\n+                   a_is_expected: bool,\n+                   a_id: V,\n+                   b_id: V)\n+                   -> ures {\n         /*!\n          *\n          * Unifies two simple variables.  Because simple variables do\n@@ -194,13 +235,13 @@ impl InferCtxt {\n         return uok();\n     }\n \n-    pub fn simple_var_t<T:Copy+Eq+InferStr+SimplyUnifiable,\n-                        V:Copy+Eq+Vid+ToStr+UnifyVid<Option<T>>>(&mut self,\n-                                                                 a_is_expected\n-                                                                 : bool,\n-                                                                 a_id: V,\n-                                                                 b: T)\n-                                                                 -> ures {\n+    fn simple_var_t<T:Copy + Eq + InferStr + SimplyUnifiable,\n+                    V:Copy + Eq + Vid + ToStr + UnifyVid<Option<T>>>(\n+                    &mut self,\n+                    a_is_expected: bool,\n+                    a_id: V,\n+                    b: T)\n+                    -> ures {\n         /*!\n          *\n          * Sets the value of the variable `a_id` to `b`.  Because"}, {"sha": "957cf02ed77ec436fc3e92b4c1da9aba346600dc", "filename": "src/librustc/rustc.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -80,6 +80,7 @@ pub mod middle {\n     pub mod moves;\n     pub mod entry;\n     pub mod effect;\n+    pub mod reachable;\n }\n \n pub mod front {"}, {"sha": "548eebaea0bea78c16a814abf0c3f8c0b5f926d5", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -488,7 +488,9 @@ pub fn parameterized(cx: ctxt,\n         }\n     };\n \n-    strs += vec::map(tps, |t| ty_to_str(cx, *t));\n+    for tps.iter().advance |t| {\n+        strs.push(ty_to_str(cx, *t))\n+    }\n \n     if strs.len() > 0u {\n         fmt!(\"%s<%s>\", base, strs.connect(\",\"))\n@@ -575,8 +577,8 @@ impl Repr for ty::ParamBounds {\n             res.push(match b {\n                 ty::BoundCopy => ~\"Copy\",\n                 ty::BoundStatic => ~\"'static\",\n-                ty::BoundOwned => ~\"Owned\",\n-                ty::BoundConst => ~\"Const\",\n+                ty::BoundSend => ~\"Send\",\n+                ty::BoundFreeze => ~\"Freeze\",\n                 ty::BoundSized => ~\"Sized\",\n             });\n         }\n@@ -781,8 +783,8 @@ impl UserString for ty::BuiltinBound {\n         match *self {\n             ty::BoundCopy => ~\"Copy\",\n             ty::BoundStatic => ~\"'static\",\n-            ty::BoundOwned => ~\"Owned\",\n-            ty::BoundConst => ~\"Const\",\n+            ty::BoundSend => ~\"Send\",\n+            ty::BoundFreeze => ~\"Freeze\",\n             ty::BoundSized => ~\"Sized\",\n         }\n     }"}, {"sha": "27ab3aca0209331d0e57d27938257d057c4f4895", "filename": "src/librustdoc/astsrv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustdoc%2Fastsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustdoc%2Fastsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fastsrv.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -99,7 +99,7 @@ fn act(po: &Port<Msg>, source: @str, parse: Parser) {\n     }\n }\n \n-pub fn exec<T:Owned>(\n+pub fn exec<T:Send>(\n     srv: Srv,\n     f: ~fn(ctxt: Ctxt) -> T\n ) -> T {"}, {"sha": "a2e50d37fb63e567d566b1cb5594b07b6f92e0fb", "filename": "src/librustdoc/attr_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustdoc%2Fattr_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustdoc%2Fattr_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_pass.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -101,7 +101,7 @@ fn fold_item(\n     }\n }\n \n-fn parse_item_attrs<T:Owned>(\n+fn parse_item_attrs<T:Send>(\n     srv: astsrv::Srv,\n     id: doc::AstId,\n     parse_attrs: ~fn(a: ~[ast::attribute]) -> T) -> T {"}, {"sha": "e9deef6b22364b613ac6ed77610bebac94e3d601", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -152,7 +152,7 @@ pub fn header_kind(doc: doc::ItemTag) -> ~str {\n             ~\"Function\"\n         }\n         doc::ConstTag(_) => {\n-            ~\"Const\"\n+            ~\"Freeze\"\n         }\n         doc::EnumTag(_) => {\n             ~\"Enum\"\n@@ -192,11 +192,11 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n             let mut trait_part = ~\"\";\n             for doc.trait_types.iter().enumerate().advance |(i, trait_type)| {\n                 if i == 0 {\n-                    trait_part += \" of \";\n+                    trait_part.push_str(\" of \");\n                 } else {\n-                    trait_part += \", \";\n+                    trait_part.push_str(\", \");\n                 }\n-                trait_part += *trait_type;\n+                trait_part.push_str(*trait_type);\n             }\n             fmt!(\"%s for %s%s\", trait_part, *self_ty, bounds)\n         }\n@@ -786,7 +786,7 @@ mod test {\n     #[test]\n     fn should_write_const_header() {\n         let markdown = render(~\"static a: bool = true;\");\n-        assert!(markdown.contains(\"## Const `a`\\n\\n\"));\n+        assert!(markdown.contains(\"## Freeze `a`\\n\\n\"));\n     }\n \n     #[test]"}, {"sha": "a093824e453bff8b9c5f73b759a8be9e0799e11f", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -130,7 +130,7 @@ fn generic_writer(process: ~fn(markdown: ~str)) -> Writer {\n         let mut keep_going = true;\n         while keep_going {\n             match po.recv() {\n-              Write(s) => markdown += s,\n+              Write(s) => markdown.push_str(s),\n               Done => keep_going = false\n             }\n         }\n@@ -214,7 +214,7 @@ fn future_writer() -> (Writer, future::Future<~str>) {\n         let mut res = ~\"\";\n         loop {\n             match port.recv() {\n-              Write(s) => res += s,\n+              Write(s) => res.push_str(s),\n               Done => break\n             }\n         }"}, {"sha": "35a433ec9dedd84e5edba12de3013af92e3c0334", "filename": "src/librustdoc/page_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustdoc%2Fpage_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustdoc%2Fpage_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpage_pass.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -70,7 +70,7 @@ fn make_doc_from_pages(page_port: &PagePort) -> doc::Doc {\n     loop {\n         let val = page_port.recv();\n         if val.is_some() {\n-            pages += [val.unwrap()];\n+            pages.push(val.unwrap());\n         } else {\n             break;\n         }"}, {"sha": "5873f361ad7341dc42bfafa054defe81dd2f7067", "filename": "src/librusti/rusti.rc", "status": "added", "additions": 666, "deletions": 0, "changes": 666, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -0,0 +1,666 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * rusti - A REPL using the JIT backend\n+ *\n+ * Rusti works by serializing state between lines of input. This means that each\n+ * line can be run in a separate task, and the only limiting factor is that all\n+ * local bound variables are encodable.\n+ *\n+ * This is accomplished by feeding in generated input to rustc for execution in\n+ * the JIT compiler. Currently input actually gets fed in three times to get\n+ * information about the program.\n+ *\n+ * - Pass #1\n+ *   In this pass, the input is simply thrown at the parser and the input comes\n+ *   back. This validates the structure of the program, and at this stage the\n+ *   global items (fns, structs, impls, traits, etc.) are filtered from the\n+ *   input into the \"global namespace\". These declarations shadow all previous\n+ *   declarations of an item by the same name.\n+ *\n+ * - Pass #2\n+ *   After items have been stripped, the remaining input is passed to rustc\n+ *   along with all local variables declared (initialized to nothing). This pass\n+ *   runs up to typechecking. From this, we can learn about the types of each\n+ *   bound variable, what variables are bound, and also ensure that all the\n+ *   types are encodable (the input can actually be run).\n+ *\n+ * - Pass #3\n+ *   Finally, a program is generated to deserialize the local variable state,\n+ *   run the code input, and then reserialize all bindings back into a local\n+ *   hash map. Once this code runs, the input has fully been run and the REPL\n+ *   waits for new input.\n+ *\n+ * Encoding/decoding is done with EBML, and there is simply a map of ~str ->\n+ * ~[u8] maintaining the values of each local binding (by name).\n+ */\n+\n+#[link(name = \"rusti\",\n+       vers = \"0.7-pre\",\n+       uuid = \"7fb5bf52-7d45-4fee-8325-5ad3311149fc\",\n+       url = \"https://github.com/mozilla/rust/tree/master/src/rusti\")];\n+\n+#[license = \"MIT/ASL2\"];\n+#[crate_type = \"lib\"];\n+\n+extern mod extra;\n+extern mod rustc;\n+extern mod syntax;\n+\n+use std::{libc, io, os, task, vec};\n+use std::cell::Cell;\n+use extra::rl;\n+\n+use rustc::driver::{driver, session};\n+use syntax::{ast, diagnostic};\n+use syntax::ast_util::*;\n+use syntax::parse::token;\n+use syntax::print::pprust;\n+\n+use program::Program;\n+use utils::*;\n+\n+mod program;\n+pub mod utils;\n+\n+/**\n+ * A structure shared across REPL instances for storing history\n+ * such as statements and view items. I wish the AST was sendable.\n+ */\n+pub struct Repl {\n+    prompt: ~str,\n+    binary: ~str,\n+    running: bool,\n+    lib_search_paths: ~[~str],\n+\n+    program: Program,\n+}\n+\n+// Action to do after reading a :command\n+enum CmdAction {\n+    action_none,\n+    action_run_line(~str),\n+}\n+\n+/// Run an input string in a Repl, returning the new Repl.\n+fn run(mut repl: Repl, input: ~str) -> Repl {\n+    // Build some necessary rustc boilerplate for compiling things\n+    let binary = repl.binary.to_managed();\n+    let options = @session::options {\n+        crate_type: session::unknown_crate,\n+        binary: binary,\n+        addl_lib_search_paths: @mut repl.lib_search_paths.map(|p| Path(*p)),\n+        jit: true,\n+        .. copy *session::basic_options()\n+    };\n+    // Because we assume that everything is encodable (and assert so), add some\n+    // extra helpful information if the error crops up. Otherwise people are\n+    // bound to be very confused when they find out code is running that they\n+    // never typed in...\n+    let sess = driver::build_session(options, |cm, msg, lvl| {\n+        diagnostic::emit(cm, msg, lvl);\n+        if msg.contains(\"failed to find an implementation of trait\") &&\n+           msg.contains(\"extra::serialize::Encodable\") {\n+            diagnostic::emit(cm,\n+                             \"Currrently rusti serializes bound locals between \\\n+                              different lines of input. This means that all \\\n+                              values of local variables need to be encodable, \\\n+                              and this type isn't encodable\",\n+                             diagnostic::note);\n+        }\n+    });\n+    let intr = token::get_ident_interner();\n+\n+    //\n+    // Stage 1: parse the input and filter it into the program (as necessary)\n+    //\n+    debug!(\"parsing: %s\", input);\n+    let crate = parse_input(sess, binary, input);\n+    let mut to_run = ~[];       // statements to run (emitted back into code)\n+    let new_locals = @mut ~[];  // new locals being defined\n+    let mut result = None;      // resultant expression (to print via pp)\n+    do find_main(crate, sess) |blk| {\n+        // Fish out all the view items, be sure to record 'extern mod' items\n+        // differently beause they must appear before all 'use' statements\n+        for blk.node.view_items.iter().advance |vi| {\n+            let s = do with_pp(intr) |pp, _| {\n+                pprust::print_view_item(pp, *vi);\n+            };\n+            match vi.node {\n+                ast::view_item_extern_mod(*) => {\n+                    repl.program.record_extern(s);\n+                }\n+                ast::view_item_use(*) => { repl.program.record_view_item(s); }\n+            }\n+        }\n+\n+        // Iterate through all of the block's statements, inserting them into\n+        // the correct portions of the program\n+        for blk.node.stmts.iter().advance |stmt| {\n+            let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n+            match stmt.node {\n+                ast::stmt_decl(d, _) => {\n+                    match d.node {\n+                        ast::decl_item(it) => {\n+                            let name = sess.str_of(it.ident);\n+                            match it.node {\n+                                // Structs are treated specially because to make\n+                                // them at all usable they need to be decorated\n+                                // with #[deriving(Encoable, Decodable)]\n+                                ast::item_struct(*) => {\n+                                    repl.program.record_struct(name, s);\n+                                }\n+                                // Item declarations are hoisted out of main()\n+                                _ => { repl.program.record_item(name, s); }\n+                            }\n+                        }\n+\n+                        // Local declarations must be specially dealt with,\n+                        // record all local declarations for use later on\n+                        ast::decl_local(l) => {\n+                            let mutbl = l.node.is_mutbl;\n+                            do each_binding(l) |path, _| {\n+                                let s = do with_pp(intr) |pp, _| {\n+                                    pprust::print_path(pp, path, false);\n+                                };\n+                                new_locals.push((s, mutbl));\n+                            }\n+                            to_run.push(s);\n+                        }\n+                    }\n+                }\n+\n+                // run statements with expressions (they have effects)\n+                ast::stmt_mac(*) | ast::stmt_semi(*) | ast::stmt_expr(*) => {\n+                    to_run.push(s);\n+                }\n+            }\n+        }\n+        result = do blk.node.expr.map_consume |e| {\n+            do with_pp(intr) |pp, _| { pprust::print_expr(pp, e); }\n+        };\n+    }\n+    // return fast for empty inputs\n+    if to_run.len() == 0 && result.is_none() {\n+        return repl;\n+    }\n+\n+    //\n+    // Stage 2: run everything up to typeck to learn the types of the new\n+    //          variables introduced into the program\n+    //\n+    info!(\"Learning about the new types in the program\");\n+    repl.program.set_cache(); // before register_new_vars (which changes them)\n+    let input = to_run.connect(\"\\n\");\n+    let test = repl.program.test_code(input, &result, *new_locals);\n+    debug!(\"testing with ^^^^^^ %?\", (||{ println(test) })());\n+    let dinput = driver::str_input(test.to_managed());\n+    let cfg = driver::build_configuration(sess, binary, &dinput);\n+    let outputs = driver::build_output_filenames(&dinput, &None, &None, [], sess);\n+    let (crate, tcx) = driver::compile_upto(sess, copy cfg, &dinput,\n+                                            driver::cu_typeck, Some(outputs));\n+    // Once we're typechecked, record the types of all local variables defined\n+    // in this input\n+    do find_main(crate.expect(\"crate after cu_typeck\"), sess) |blk| {\n+        repl.program.register_new_vars(blk, tcx.expect(\"tcx after cu_typeck\"));\n+    }\n+\n+    //\n+    // Stage 3: Actually run the code in the JIT\n+    //\n+    info!(\"actually running code\");\n+    let code = repl.program.code(input, &result);\n+    debug!(\"actually running ^^^^^^ %?\", (||{ println(code) })());\n+    let input = driver::str_input(code.to_managed());\n+    let cfg = driver::build_configuration(sess, binary, &input);\n+    let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n+    let sess = driver::build_session(options, diagnostic::emit);\n+    driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n+                         Some(outputs));\n+\n+    //\n+    // Stage 4: Inform the program that computation is done so it can update all\n+    //          local variable bindings.\n+    //\n+    info!(\"cleaning up after code\");\n+    repl.program.consume_cache();\n+\n+    return repl;\n+\n+    fn parse_input(sess: session::Session, binary: @str,\n+                   input: &str) -> @ast::crate {\n+        let code = fmt!(\"fn main() {\\n %s \\n}\", input);\n+        let input = driver::str_input(code.to_managed());\n+        let cfg = driver::build_configuration(sess, binary, &input);\n+        let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n+        let (crate, _) = driver::compile_upto(sess, cfg, &input,\n+                                              driver::cu_parse, Some(outputs));\n+        crate.expect(\"parsing should return a crate\")\n+    }\n+\n+    fn find_main(crate: @ast::crate, sess: session::Session,\n+                 f: &fn(&ast::blk)) {\n+        for crate.node.module.items.iter().advance |item| {\n+            match item.node {\n+                ast::item_fn(_, _, _, _, ref blk) => {\n+                    if item.ident == sess.ident_of(\"main\") {\n+                        return f(blk);\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        fail!(\"main function was expected somewhere...\");\n+    }\n+}\n+\n+// Compiles a crate given by the filename as a library if the compiled\n+// version doesn't exist or is older than the source file. Binary is\n+// the name of the compiling executable. Returns Some(true) if it\n+// successfully compiled, Some(false) if the crate wasn't compiled\n+// because it already exists and is newer than the source file, or\n+// None if there were compile errors.\n+fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n+    match do task::try {\n+        let src_path = Path(src_filename);\n+        let binary = binary.to_managed();\n+        let options = @session::options {\n+            binary: binary,\n+            addl_lib_search_paths: @mut ~[os::getcwd()],\n+            .. copy *session::basic_options()\n+        };\n+        let input = driver::file_input(copy src_path);\n+        let sess = driver::build_session(options, diagnostic::emit);\n+        *sess.building_library = true;\n+        let cfg = driver::build_configuration(sess, binary, &input);\n+        let outputs = driver::build_output_filenames(\n+            &input, &None, &None, [], sess);\n+        // If the library already exists and is newer than the source\n+        // file, skip compilation and return None.\n+        let mut should_compile = true;\n+        let dir = os::list_dir_path(&Path(outputs.out_filename.dirname()));\n+        let maybe_lib_path = do dir.iter().find_ |file| {\n+            // The actual file's name has a hash value and version\n+            // number in it which is unknown at this time, so looking\n+            // for a file that matches out_filename won't work,\n+            // instead we guess which file is the library by matching\n+            // the prefix and suffix of out_filename to files in the\n+            // directory.\n+            let file_str = file.filename().get();\n+            file_str.starts_with(outputs.out_filename.filestem().get())\n+                && file_str.ends_with(outputs.out_filename.filetype().get())\n+        };\n+        match maybe_lib_path {\n+            Some(lib_path) => {\n+                let (src_mtime, _) = src_path.get_mtime().get();\n+                let (lib_mtime, _) = lib_path.get_mtime().get();\n+                if lib_mtime >= src_mtime {\n+                    should_compile = false;\n+                }\n+            },\n+            None => { },\n+        }\n+        if (should_compile) {\n+            println(fmt!(\"compiling %s...\", src_filename));\n+            driver::compile_upto(sess, cfg, &input, driver::cu_everything,\n+                                 Some(outputs));\n+            true\n+        } else { false }\n+    } {\n+        Ok(true) => Some(true),\n+        Ok(false) => Some(false),\n+        Err(_) => None,\n+    }\n+}\n+\n+/// Tries to get a line from rl after outputting a prompt. Returns\n+/// None if no input was read (e.g. EOF was reached).\n+fn get_line(use_rl: bool, prompt: &str) -> Option<~str> {\n+    if use_rl {\n+        let result = unsafe { rl::read(prompt) };\n+\n+        match result {\n+            None => None,\n+            Some(line) => {\n+                unsafe { rl::add_history(line) };\n+                Some(line)\n+            }\n+        }\n+    } else {\n+        if io::stdin().eof() {\n+            None\n+        } else {\n+            Some(io::stdin().read_line())\n+        }\n+    }\n+}\n+\n+/// Run a command, e.g. :clear, :exit, etc.\n+fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n+           cmd: ~str, args: ~[~str], use_rl: bool) -> CmdAction {\n+    let mut action = action_none;\n+    match cmd {\n+        ~\"exit\" => repl.running = false,\n+        ~\"clear\" => {\n+            repl.program.clear();\n+\n+            // XXX: Win32 version of linenoise can't do this\n+            //rl::clear();\n+        }\n+        ~\"help\" => {\n+            println(\n+                \":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\\\n+                 :load <crate> ... - loads given crates as dynamic libraries\\n\\\n+                 :clear - clear the bindings\\n\\\n+                 :exit - exit from the repl\\n\\\n+                 :help - show this message\");\n+        }\n+        ~\"load\" => {\n+            let mut loaded_crates: ~[~str] = ~[];\n+            for args.iter().advance |arg| {\n+                let (crate, filename) =\n+                    if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n+                    (arg.slice_to(arg.len() - 3).to_owned(), copy *arg)\n+                } else {\n+                    (copy *arg, *arg + \".rs\")\n+                };\n+                match compile_crate(filename, copy repl.binary) {\n+                    Some(_) => loaded_crates.push(crate),\n+                    None => { }\n+                }\n+            }\n+            for loaded_crates.iter().advance |crate| {\n+                let crate_path = Path(*crate);\n+                let crate_dir = crate_path.dirname();\n+                repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n+                if !repl.lib_search_paths.iter().any_(|x| x == &crate_dir) {\n+                    repl.lib_search_paths.push(crate_dir);\n+                }\n+            }\n+            if loaded_crates.is_empty() {\n+                println(\"no crates loaded\");\n+            } else {\n+                println(fmt!(\"crates loaded: %s\",\n+                                 loaded_crates.connect(\", \")));\n+            }\n+        }\n+        ~\"{\" => {\n+            let mut multiline_cmd = ~\"\";\n+            let mut end_multiline = false;\n+            while (!end_multiline) {\n+                match get_line(use_rl, \"rusti| \") {\n+                    None => fail!(\"unterminated multiline command :{ .. :}\"),\n+                    Some(line) => {\n+                        if line.trim() == \":}\" {\n+                            end_multiline = true;\n+                        } else {\n+                            multiline_cmd.push_str(line);\n+                            multiline_cmd.push_char('\\n');\n+                        }\n+                    }\n+                }\n+            }\n+            action = action_run_line(multiline_cmd);\n+        }\n+        _ => println(~\"unknown cmd: \" + cmd)\n+    }\n+    return action;\n+}\n+\n+/// Executes a line of input, which may either be rust code or a\n+/// :command. Returns a new Repl if it has changed.\n+pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n+                use_rl: bool)\n+    -> Option<Repl> {\n+    if line.starts_with(\":\") {\n+        // drop the : and the \\n (one byte each)\n+        let full = line.slice(1, line.len());\n+        let split: ~[~str] = full.word_iter().transform(|s| s.to_owned()).collect();\n+        let len = split.len();\n+\n+        if len > 0 {\n+            let cmd = copy split[0];\n+\n+            if !cmd.is_empty() {\n+                let args = if len > 1 {\n+                    vec::slice(split, 1, len).to_owned()\n+                } else { ~[] };\n+\n+                match run_cmd(repl, in, out, cmd, args, use_rl) {\n+                    action_none => { }\n+                    action_run_line(multiline_cmd) => {\n+                        if !multiline_cmd.is_empty() {\n+                            return run_line(repl, in, out, multiline_cmd, use_rl);\n+                        }\n+                    }\n+                }\n+                return None;\n+            }\n+        }\n+    }\n+\n+    let line = Cell::new(line);\n+    let r = Cell::new(copy *repl);\n+    let result = do task::try {\n+        run(r.take(), line.take())\n+    };\n+\n+    if result.is_ok() {\n+        return Some(result.get());\n+    }\n+    return None;\n+}\n+\n+pub fn main() {\n+    let args = os::args();\n+    let in = io::stdin();\n+    let out = io::stdout();\n+    let mut repl = Repl {\n+        prompt: ~\"rusti> \",\n+        binary: copy args[0],\n+        running: true,\n+        lib_search_paths: ~[],\n+\n+        program: Program::new(),\n+    };\n+\n+    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n+\n+    // only print this stuff if the user is actually typing into rusti\n+    if istty {\n+        println(\"WARNING: The Rust REPL is experimental and may be\");\n+        println(\"unstable. If you encounter problems, please use the\");\n+        println(\"compiler instead. Type :help for help.\");\n+\n+        unsafe {\n+            do rl::complete |line, suggest| {\n+                if line.starts_with(\":\") {\n+                    suggest(~\":clear\");\n+                    suggest(~\":exit\");\n+                    suggest(~\":help\");\n+                    suggest(~\":load\");\n+                }\n+            }\n+        }\n+    }\n+\n+    while repl.running {\n+        match get_line(istty, repl.prompt) {\n+            None => break,\n+            Some(line) => {\n+                if line.is_empty() {\n+                    if istty {\n+                        println(\"()\");\n+                    }\n+                    loop;\n+                }\n+                match run_line(&mut repl, in, out, line, istty) {\n+                    Some(new_repl) => repl = new_repl,\n+                    None => { }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::io;\n+    use std::iterator::IteratorUtil;\n+    use program::Program;\n+    use super::*;\n+\n+    fn repl() -> Repl {\n+        Repl {\n+            prompt: ~\"rusti> \",\n+            binary: ~\"rusti\",\n+            running: true,\n+            lib_search_paths: ~[],\n+            program: Program::new(),\n+        }\n+    }\n+\n+    fn run_program(prog: &str) {\n+        let mut r = repl();\n+        for prog.split_iter('\\n').advance |cmd| {\n+            let result = run_line(&mut r, io::stdin(), io::stdout(),\n+                                  cmd.to_owned(), false);\n+            r = result.expect(fmt!(\"the command '%s' failed\", cmd));\n+        }\n+    }\n+\n+    #[test]\n+    // FIXME: #7220 rusti on 32bit mac doesn't work.\n+    #[cfg(not(target_word_size=\"32\",\n+              target_os=\"macos\"))]\n+    fn run_all() {\n+        // FIXME(#7071):\n+        // By default, unit tests are run in parallel. Rusti, on the other hand,\n+        // does not enjoy doing this. I suspect that it is because the LLVM\n+        // bindings are not thread-safe (when running parallel tests, some tests\n+        // were triggering assertions in LLVM (or segfaults). Hence, this\n+        // function exists to run everything serially (sadface).\n+        //\n+        // To get some interesting output, run with RUST_LOG=rusti::tests\n+\n+        debug!(\"hopefully this runs\");\n+        run_program(\"\");\n+\n+        debug!(\"regression test for #5937\");\n+        run_program(\"use std::hashmap;\");\n+\n+        debug!(\"regression test for #5784\");\n+        run_program(\"let a = 3;\");\n+\n+        // XXX: can't spawn new tasks because the JIT code is cleaned up\n+        //      after the main function is done.\n+        // debug!(\"regression test for #5803\");\n+        // run_program(\"\n+        //     spawn( || println(\\\"Please don't segfault\\\") );\n+        //     do spawn { println(\\\"Please?\\\"); }\n+        // \");\n+\n+        debug!(\"inferred integers are usable\");\n+        run_program(\"let a = 2;\\n()\\n\");\n+        run_program(\"\n+            let a = 3;\n+            let b = 4u;\n+            assert!((a as uint) + b == 7)\n+        \");\n+\n+        debug!(\"local variables can be shadowed\");\n+        run_program(\"\n+            let a = 3;\n+            let a = 5;\n+            assert!(a == 5)\n+        \");\n+\n+        debug!(\"strings are usable\");\n+        run_program(\"\n+            let a = ~\\\"\\\";\n+            let b = \\\"\\\";\n+            let c = @\\\"\\\";\n+            let d = a + b + c;\n+            assert!(d.len() == 0);\n+        \");\n+\n+        debug!(\"vectors are usable\");\n+        run_program(\"\n+            let a = ~[1, 2, 3];\n+            let b = &[1, 2, 3];\n+            let c = @[1, 2, 3];\n+            let d = a + b + c;\n+            assert!(d.len() == 9);\n+            let e: &[int] = [];\n+        \");\n+\n+        debug!(\"structs are usable\");\n+        run_program(\"\n+            struct A{ a: int }\n+            let b = A{ a: 3 };\n+            assert!(b.a == 3)\n+        \");\n+\n+        debug!(\"mutable variables\");\n+        run_program(\"\n+            let mut a = 3;\n+            a = 5;\n+            let mut b = std::hashmap::HashSet::new::<int>();\n+            b.insert(a);\n+            assert!(b.contains(&5))\n+            assert!(b.len() == 1)\n+        \");\n+\n+        debug!(\"functions are cached\");\n+        run_program(\"\n+            fn fib(x: int) -> int { if x < 2 {x} else { fib(x - 1) + fib(x - 2) } }\n+            let a = fib(3);\n+            let a = a + fib(4);\n+            assert!(a == 5)\n+        \");\n+\n+        debug!(\"modules are cached\");\n+        run_program(\"\n+            mod b { pub fn foo() -> uint { 3 } }\n+            assert!(b::foo() == 3)\n+        \");\n+\n+        debug!(\"multiple function definitions are allowed\");\n+        run_program(\"\n+            fn f() {}\n+            fn f() {}\n+            f()\n+        \");\n+\n+        debug!(\"multiple item definitions are allowed\");\n+        run_program(\"\n+            fn f() {}\n+            mod f {}\n+            struct f;\n+            enum f {}\n+            fn f() {}\n+            f()\n+        \");\n+    }\n+\n+    #[test]\n+    // FIXME: #7220 rusti on 32bit mac doesn't work.\n+    #[cfg(not(target_word_size=\"32\",\n+              target_os=\"macos\"))]\n+    fn exit_quits() {\n+        let mut r = repl();\n+        assert!(r.running);\n+        let result = run_line(&mut r, io::stdin(), io::stdout(),\n+                              ~\":exit\", false);\n+        assert!(result.is_none());\n+        assert!(!r.running);\n+    }\n+}"}, {"sha": "abb0cf271ec464981212fc11eac42d4d8bc9777d", "filename": "src/librusti/rusti.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -402,7 +402,8 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                         if line.trim() == \":}\" {\n                             end_multiline = true;\n                         } else {\n-                            multiline_cmd += line + \"\\n\";\n+                            multiline_cmd.push_str(line);\n+                            multiline_cmd.push_char('\\n');\n                         }\n                     }\n                 }"}, {"sha": "550a3411b5ddcc5ef3f465394e5003a81b3159f6", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -185,7 +185,21 @@ impl<'self> PkgScript<'self> {\n \n }\n \n-impl Ctx {\n+pub trait CtxMethods {\n+    fn run(&self, cmd: &str, args: ~[~str]);\n+    fn do_cmd(&self, _cmd: &str, _pkgname: &str);\n+    fn build(&self, workspace: &Path, pkgid: &PkgId);\n+    fn clean(&self, workspace: &Path, id: &PkgId);\n+    fn info(&self);\n+    fn install(&self, workspace: &Path, id: &PkgId);\n+    fn install_no_build(&self, workspace: &Path, id: &PkgId);\n+    fn prefer(&self, _id: &str, _vers: Option<~str>);\n+    fn test(&self);\n+    fn uninstall(&self, _id: &str, _vers: Option<~str>);\n+    fn unprefer(&self, _id: &str, _vers: Option<~str>);\n+}\n+\n+impl CtxMethods for Ctx {\n \n     fn run(&self, cmd: &str, args: ~[~str]) {\n         match cmd {"}, {"sha": "83dcde48b3a8e4268dbb8b057d6979c558db7ddb", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -248,7 +248,7 @@ fn command_line_test_output(args: &[~str]) -> ~[~str] {\n     let p_output = command_line_test(args, &os::getcwd());\n     let test_output = str::from_bytes(p_output.output);\n     for test_output.split_iter('\\n').advance |s| {\n-        result += [s.to_owned()];\n+        result.push(s.to_owned());\n     }\n     result\n }"}, {"sha": "8f0870af513320be08449740652c008a05070487", "filename": "src/libstd/char.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fchar.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -10,6 +10,7 @@\n \n //! Utilities for manipulating the char type\n \n+use container::Container;\n use option::{None, Option, Some};\n use str;\n use str::{StrSlice, OwnedStr};"}, {"sha": "947aa5708c2967f686e3d54e67603666673286a2", "filename": "src/libstd/clone.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fclone.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -22,7 +22,7 @@ by convention implementing the `Clone` trait and calling the\n \n */\n \n-use core::kinds::Const;\n+use core::kinds::Freeze;\n \n /// A common trait for cloning an object.\n pub trait Clone {\n@@ -112,17 +112,17 @@ impl<T: DeepClone> DeepClone for ~T {\n     fn deep_clone(&self) -> ~T { ~(**self).deep_clone() }\n }\n \n-// FIXME: #6525: should also be implemented for `T: Owned + DeepClone`\n-impl<T: Const + DeepClone> DeepClone for @T {\n-    /// Return a deep copy of the managed box. The `Const` trait is required to prevent performing\n+// FIXME: #6525: should also be implemented for `T: Send + DeepClone`\n+impl<T: Freeze + DeepClone> DeepClone for @T {\n+    /// Return a deep copy of the managed box. The `Freeze` trait is required to prevent performing\n     /// a deep clone of a potentially cyclical type.\n     #[inline]\n     fn deep_clone(&self) -> @T { @(**self).deep_clone() }\n }\n \n-// FIXME: #6525: should also be implemented for `T: Owned + DeepClone`\n-impl<T: Const + DeepClone> DeepClone for @mut T {\n-    /// Return a deep copy of the managed box. The `Const` trait is required to prevent performing\n+// FIXME: #6525: should also be implemented for `T: Send + DeepClone`\n+impl<T: Freeze + DeepClone> DeepClone for @mut T {\n+    /// Return a deep copy of the managed box. The `Freeze` trait is required to prevent performing\n     /// a deep clone of a potentially cyclical type.\n     #[inline]\n     fn deep_clone(&self) -> @mut T { @mut (**self).deep_clone() }"}, {"sha": "8316a33ecf1f8f65f9ef7322875fddbb29482744", "filename": "src/libstd/comm.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -17,7 +17,7 @@ Message passing\n use cast::{transmute, transmute_mut};\n use container::Container;\n use either::{Either, Left, Right};\n-use kinds::Owned;\n+use kinds::Send;\n use option::{Option, Some, None};\n use uint;\n use vec::OwnedVector;\n@@ -77,7 +77,7 @@ pub struct Port<T> {\n These allow sending or receiving an unlimited number of messages.\n \n */\n-pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n+pub fn stream<T:Send>() -> (Port<T>, Chan<T>) {\n     let (port, chan) = match rt::context() {\n         rt::OldTaskContext => match pipesy::stream() {\n             (p, c) => (Left(p), Left(c))\n@@ -91,7 +91,7 @@ pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n     return (port, chan);\n }\n \n-impl<T: Owned> GenericChan<T> for Chan<T> {\n+impl<T: Send> GenericChan<T> for Chan<T> {\n     fn send(&self, x: T) {\n         match self.inner {\n             Left(ref chan) => chan.send(x),\n@@ -100,7 +100,7 @@ impl<T: Owned> GenericChan<T> for Chan<T> {\n     }\n }\n \n-impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+impl<T: Send> GenericSmartChan<T> for Chan<T> {\n     fn try_send(&self, x: T) -> bool {\n         match self.inner {\n             Left(ref chan) => chan.try_send(x),\n@@ -109,7 +109,7 @@ impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n     }\n }\n \n-impl<T: Owned> GenericPort<T> for Port<T> {\n+impl<T: Send> GenericPort<T> for Port<T> {\n     fn recv(&self) -> T {\n         match self.inner {\n             Left(ref port) => port.recv(),\n@@ -125,7 +125,7 @@ impl<T: Owned> GenericPort<T> for Port<T> {\n     }\n }\n \n-impl<T: Owned> Peekable<T> for Port<T> {\n+impl<T: Send> Peekable<T> for Port<T> {\n     fn peek(&self) -> bool {\n         match self.inner {\n             Left(ref port) => port.peek(),\n@@ -134,7 +134,7 @@ impl<T: Owned> Peekable<T> for Port<T> {\n     }\n }\n \n-impl<T: Owned> Selectable for Port<T> {\n+impl<T: Send> Selectable for Port<T> {\n     fn header(&mut self) -> *mut PacketHeader {\n         match self.inner {\n             Left(ref mut port) => port.header(),\n@@ -149,7 +149,7 @@ pub struct PortSet<T> {\n     ports: ~[pipesy::Port<T>],\n }\n \n-impl<T: Owned> PortSet<T> {\n+impl<T: Send> PortSet<T> {\n     pub fn new() -> PortSet<T> {\n         PortSet {\n             ports: ~[]\n@@ -175,7 +175,7 @@ impl<T: Owned> PortSet<T> {\n     }\n }\n \n-impl<T:Owned> GenericPort<T> for PortSet<T> {\n+impl<T:Send> GenericPort<T> for PortSet<T> {\n     fn try_recv(&self) -> Option<T> {\n         unsafe {\n             let self_ports = transmute_mut(&self.ports);\n@@ -204,7 +204,7 @@ impl<T:Owned> GenericPort<T> for PortSet<T> {\n     }\n }\n \n-impl<T: Owned> Peekable<T> for PortSet<T> {\n+impl<T: Send> Peekable<T> for PortSet<T> {\n     fn peek(&self) -> bool {\n         // It'd be nice to use self.port.each, but that version isn't\n         // pure.\n@@ -223,7 +223,7 @@ pub struct SharedChan<T> {\n     ch: Exclusive<pipesy::Chan<T>>\n }\n \n-impl<T: Owned> SharedChan<T> {\n+impl<T: Send> SharedChan<T> {\n     /// Converts a `chan` into a `shared_chan`.\n     pub fn new(c: Chan<T>) -> SharedChan<T> {\n         let Chan { inner } = c;\n@@ -235,7 +235,7 @@ impl<T: Owned> SharedChan<T> {\n     }\n }\n \n-impl<T: Owned> GenericChan<T> for SharedChan<T> {\n+impl<T: Send> GenericChan<T> for SharedChan<T> {\n     fn send(&self, x: T) {\n         unsafe {\n             let mut xx = Some(x);\n@@ -247,7 +247,7 @@ impl<T: Owned> GenericChan<T> for SharedChan<T> {\n     }\n }\n \n-impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n+impl<T: Send> GenericSmartChan<T> for SharedChan<T> {\n     fn try_send(&self, x: T) -> bool {\n         unsafe {\n             let mut xx = Some(x);\n@@ -259,7 +259,7 @@ impl<T: Owned> GenericSmartChan<T> for SharedChan<T> {\n     }\n }\n \n-impl<T: Owned> ::clone::Clone for SharedChan<T> {\n+impl<T: Send> ::clone::Clone for SharedChan<T> {\n     fn clone(&self) -> SharedChan<T> {\n         SharedChan { ch: self.ch.clone() }\n     }\n@@ -273,7 +273,7 @@ pub struct ChanOne<T> {\n     inner: Either<pipesy::ChanOne<T>, rtcomm::ChanOne<T>>\n }\n \n-pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n     let (port, chan) = match rt::context() {\n         rt::OldTaskContext => match pipesy::oneshot() {\n             (p, c) => (Left(p), Left(c)),\n@@ -287,7 +287,7 @@ pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n     return (port, chan);\n }\n \n-impl<T: Owned> PortOne<T> {\n+impl<T: Send> PortOne<T> {\n     pub fn recv(self) -> T {\n         let PortOne { inner } = self;\n         match inner {\n@@ -305,7 +305,7 @@ impl<T: Owned> PortOne<T> {\n     }\n }\n \n-impl<T: Owned> ChanOne<T> {\n+impl<T: Send> ChanOne<T> {\n     pub fn send(self, data: T) {\n         let ChanOne { inner } = self;\n         match inner {\n@@ -323,31 +323,31 @@ impl<T: Owned> ChanOne<T> {\n     }\n }\n \n-pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n+pub fn recv_one<T: Send>(port: PortOne<T>) -> T {\n     let PortOne { inner } = port;\n     match inner {\n         Left(p) => pipesy::recv_one(p),\n         Right(p) => p.recv()\n     }\n }\n \n-pub fn try_recv_one<T: Owned>(port: PortOne<T>) -> Option<T> {\n+pub fn try_recv_one<T: Send>(port: PortOne<T>) -> Option<T> {\n     let PortOne { inner } = port;\n     match inner {\n         Left(p) => pipesy::try_recv_one(p),\n         Right(p) => p.try_recv()\n     }\n }\n \n-pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n+pub fn send_one<T: Send>(chan: ChanOne<T>, data: T) {\n     let ChanOne { inner } = chan;\n     match inner {\n         Left(c) => pipesy::send_one(c, data),\n         Right(c) => c.send(data)\n     }\n }\n \n-pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n+pub fn try_send_one<T: Send>(chan: ChanOne<T>, data: T) -> bool {\n     let ChanOne { inner } = chan;\n     match inner {\n         Left(c) => pipesy::try_send_one(c, data),\n@@ -357,25 +357,25 @@ pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n \n mod pipesy {\n \n-    use kinds::Owned;\n+    use kinds::Send;\n     use option::{Option, Some, None};\n     use pipes::{recv, try_recv, peek, PacketHeader};\n     use super::{GenericChan, GenericSmartChan, GenericPort, Peekable, Selectable};\n     use cast::transmute_mut;\n     use util::replace;\n \n     /*proto! oneshot (\n-        Oneshot:send<T:Owned> {\n+        Oneshot:send<T:Send> {\n             send(T) -> !\n         }\n     )*/\n \n     #[allow(non_camel_case_types)]\n     pub mod oneshot {\n-        priv use core::kinds::Owned;\n+        priv use core::kinds::Send;\n         use ptr::to_mut_unsafe_ptr;\n \n-        pub fn init<T: Owned>() -> (server::Oneshot<T>, client::Oneshot<T>) {\n+        pub fn init<T: Send>() -> (server::Oneshot<T>, client::Oneshot<T>) {\n             pub use core::pipes::HasBuffer;\n \n             let buffer = ~::core::pipes::Buffer {\n@@ -399,10 +399,10 @@ mod pipesy {\n         #[allow(non_camel_case_types)]\n         pub mod client {\n \n-            priv use core::kinds::Owned;\n+            priv use core::kinds::Send;\n \n             #[allow(non_camel_case_types)]\n-            pub fn try_send<T: Owned>(pipe: Oneshot<T>, x_0: T) ->\n+            pub fn try_send<T: Send>(pipe: Oneshot<T>, x_0: T) ->\n                 ::core::option::Option<()> {\n                 {\n                     use super::send;\n@@ -414,7 +414,7 @@ mod pipesy {\n             }\n \n             #[allow(non_camel_case_types)]\n-            pub fn send<T: Owned>(pipe: Oneshot<T>, x_0: T) {\n+            pub fn send<T: Send>(pipe: Oneshot<T>, x_0: T) {\n                 {\n                     use super::send;\n                     let message = send(x_0);\n@@ -464,12 +464,12 @@ mod pipesy {\n     }\n \n     /// Initialiase a (send-endpoint, recv-endpoint) oneshot pipe pair.\n-    pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+    pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n         let (port, chan) = oneshot::init();\n         (PortOne::new(port), ChanOne::new(chan))\n     }\n \n-    impl<T: Owned> PortOne<T> {\n+    impl<T: Send> PortOne<T> {\n         pub fn recv(self) -> T { recv_one(self) }\n         pub fn try_recv(self) -> Option<T> { try_recv_one(self) }\n         pub fn unwrap(self) -> oneshot::server::Oneshot<T> {\n@@ -479,7 +479,7 @@ mod pipesy {\n         }\n     }\n \n-    impl<T: Owned> ChanOne<T> {\n+    impl<T: Send> ChanOne<T> {\n         pub fn send(self, data: T) { send_one(self, data) }\n         pub fn try_send(self, data: T) -> bool { try_send_one(self, data) }\n         pub fn unwrap(self) -> oneshot::client::Oneshot<T> {\n@@ -493,7 +493,7 @@ mod pipesy {\n     * Receive a message from a oneshot pipe, failing if the connection was\n     * closed.\n     */\n-    pub fn recv_one<T: Owned>(port: PortOne<T>) -> T {\n+    pub fn recv_one<T: Send>(port: PortOne<T>) -> T {\n         match port {\n             PortOne { contents: port } => {\n                 let oneshot::send(message) = recv(port);\n@@ -503,7 +503,7 @@ mod pipesy {\n     }\n \n     /// Receive a message from a oneshot pipe unless the connection was closed.\n-    pub fn try_recv_one<T: Owned> (port: PortOne<T>) -> Option<T> {\n+    pub fn try_recv_one<T: Send> (port: PortOne<T>) -> Option<T> {\n         match port {\n             PortOne { contents: port } => {\n                 let message = try_recv(port);\n@@ -519,7 +519,7 @@ mod pipesy {\n     }\n \n     /// Send a message on a oneshot pipe, failing if the connection was closed.\n-    pub fn send_one<T: Owned>(chan: ChanOne<T>, data: T) {\n+    pub fn send_one<T: Send>(chan: ChanOne<T>, data: T) {\n         match chan {\n             ChanOne { contents: chan } => oneshot::client::send(chan, data),\n         }\n@@ -529,7 +529,7 @@ mod pipesy {\n     * Send a message on a oneshot pipe, or return false if the connection was\n     * closed.\n     */\n-    pub fn try_send_one<T: Owned>(chan: ChanOne<T>, data: T) -> bool {\n+    pub fn try_send_one<T: Send>(chan: ChanOne<T>, data: T) -> bool {\n         match chan {\n             ChanOne { contents: chan } => {\n                 oneshot::client::try_send(chan, data).is_some()\n@@ -540,16 +540,16 @@ mod pipesy {\n     // Streams - Make pipes a little easier in general.\n \n     /*proto! streamp (\n-        Open:send<T: Owned> {\n+        Open:send<T: Send> {\n             data(T) -> Open<T>\n         }\n     )*/\n \n     #[allow(non_camel_case_types)]\n     pub mod streamp {\n-        priv use core::kinds::Owned;\n+        priv use core::kinds::Send;\n \n-        pub fn init<T: Owned>() -> (server::Open<T>, client::Open<T>) {\n+        pub fn init<T: Send>() -> (server::Open<T>, client::Open<T>) {\n             pub use core::pipes::HasBuffer;\n             ::core::pipes::entangle()\n         }\n@@ -559,10 +559,10 @@ mod pipesy {\n \n         #[allow(non_camel_case_types)]\n         pub mod client {\n-            priv use core::kinds::Owned;\n+            priv use core::kinds::Send;\n \n             #[allow(non_camel_case_types)]\n-            pub fn try_data<T: Owned>(pipe: Open<T>, x_0: T) ->\n+            pub fn try_data<T: Send>(pipe: Open<T>, x_0: T) ->\n                 ::core::option::Option<Open<T>> {\n                 {\n                     use super::data;\n@@ -575,7 +575,7 @@ mod pipesy {\n             }\n \n             #[allow(non_camel_case_types)]\n-            pub fn data<T: Owned>(pipe: Open<T>, x_0: T) -> Open<T> {\n+            pub fn data<T: Send>(pipe: Open<T>, x_0: T) -> Open<T> {\n                 {\n                     use super::data;\n                     let (s, c) = ::core::pipes::entangle();\n@@ -613,7 +613,7 @@ mod pipesy {\n     These allow sending or receiving an unlimited number of messages.\n \n     */\n-    pub fn stream<T:Owned>() -> (Port<T>, Chan<T>) {\n+    pub fn stream<T:Send>() -> (Port<T>, Chan<T>) {\n         let (s, c) = streamp::init();\n \n         (Port {\n@@ -623,7 +623,7 @@ mod pipesy {\n         })\n     }\n \n-    impl<T: Owned> GenericChan<T> for Chan<T> {\n+    impl<T: Send> GenericChan<T> for Chan<T> {\n         #[inline]\n         fn send(&self, x: T) {\n             unsafe {\n@@ -634,7 +634,7 @@ mod pipesy {\n         }\n     }\n \n-    impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+    impl<T: Send> GenericSmartChan<T> for Chan<T> {\n         #[inline]\n         fn try_send(&self, x: T) -> bool {\n             unsafe {\n@@ -651,7 +651,7 @@ mod pipesy {\n         }\n     }\n \n-    impl<T: Owned> GenericPort<T> for Port<T> {\n+    impl<T: Send> GenericPort<T> for Port<T> {\n         #[inline]\n         fn recv(&self) -> T {\n             unsafe {\n@@ -679,7 +679,7 @@ mod pipesy {\n         }\n     }\n \n-    impl<T: Owned> Peekable<T> for Port<T> {\n+    impl<T: Send> Peekable<T> for Port<T> {\n         #[inline]\n         fn peek(&self) -> bool {\n             unsafe {\n@@ -695,7 +695,7 @@ mod pipesy {\n         }\n     }\n \n-    impl<T: Owned> Selectable for Port<T> {\n+    impl<T: Send> Selectable for Port<T> {\n         fn header(&mut self) -> *mut PacketHeader {\n             match self.endp {\n                 Some(ref mut endp) => endp.header(),\n@@ -723,15 +723,15 @@ pub fn select2i<A:Selectable, B:Selectable>(a: &mut A, b: &mut B)\n }\n \n /// Receive a message from one of two endpoints.\n-pub trait Select2<T: Owned, U: Owned> {\n+pub trait Select2<T: Send, U: Send> {\n     /// Receive a message or return `None` if a connection closes.\n     fn try_select(&mut self) -> Either<Option<T>, Option<U>>;\n     /// Receive a message or fail if a connection closes.\n     fn select(&mut self) -> Either<T, U>;\n }\n \n-impl<T:Owned,\n-     U:Owned,\n+impl<T:Send,\n+     U:Send,\n      Left:Selectable + GenericPort<T>,\n      Right:Selectable + GenericPort<U>>\n      Select2<T, U>"}, {"sha": "6c3fcd41ed3b9d6fb1b698f95faee702332efa27", "filename": "src/libstd/hash.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -24,6 +24,7 @@\n use container::Container;\n use iterator::IteratorUtil;\n use rt::io::Writer;\n+use str::OwnedStr;\n use to_bytes::IterBytes;\n use uint;\n use vec::ImmutableVector;\n@@ -369,7 +370,7 @@ impl Streaming for SipState {\n         let r = self.result_bytes();\n         let mut s = ~\"\";\n         for r.iter().advance |b| {\n-            s += uint::to_str_radix(*b as uint, 16u);\n+            s.push_str(uint::to_str_radix(*b as uint, 16u));\n         }\n         s\n     }\n@@ -471,7 +472,7 @@ mod tests {\n         fn to_hex_str(r: &[u8, ..8]) -> ~str {\n             let mut s = ~\"\";\n             for r.iter().advance |b| {\n-                s += uint::to_str_radix(*b as uint, 16u);\n+                s.push_str(uint::to_str_radix(*b as uint, 16u));\n             }\n             s\n         }\n@@ -492,7 +493,7 @@ mod tests {\n \n             assert!(f == i && f == v);\n \n-            buf += [t as u8];\n+            buf.push(t as u8);\n             stream_inc.input([t as u8]);\n \n             t += 1;"}, {"sha": "59ac58a514f3d4a107d96658cf5babe57ad233f3", "filename": "src/libstd/io.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -771,7 +771,9 @@ impl<T:Reader> ReaderUtil for T {\n     fn read_le_uint_n(&self, nbytes: uint) -> u64 {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n-        let mut (val, pos, i) = (0u64, 0, nbytes);\n+        let mut val = 0u64;\n+        let mut pos = 0;\n+        let mut i = nbytes;\n         while i > 0 {\n             val += (self.read_u8() as u64) << pos;\n             pos += 8;\n@@ -787,7 +789,8 @@ impl<T:Reader> ReaderUtil for T {\n     fn read_be_uint_n(&self, nbytes: uint) -> u64 {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n-        let mut (val, i) = (0u64, nbytes);\n+        let mut val = 0u64;\n+        let mut i = nbytes;\n         while i > 0 {\n             i -= 1;\n             val += (self.read_u8() as u64) << i * 8;"}, {"sha": "f350e1061680524e9ea7cbb0a24bbafef0b070d6", "filename": "src/libstd/kinds.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fkinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fkinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fkinds.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -24,11 +24,10 @@ The 4 kinds are\n   scalar types and managed pointers, and exludes owned pointers. It\n   also excludes types that implement `Drop`.\n \n-* Owned - owned types and types containing owned types.  These types\n+* Send - owned types and types containing owned types.  These types\n   may be transferred across task boundaries.\n \n-* Const - types that are deeply immutable. Const types are used for\n-  freezable data structures.\n+* Freeze - types that are deeply immutable.\n \n `Copy` types include both implicitly copyable types that the compiler\n will copy automatically and non-implicitly copyable types that require\n@@ -44,14 +43,28 @@ pub trait Copy {\n     // Empty.\n }\n \n+#[cfg(stage0)]\n #[lang=\"owned\"]\n-pub trait Owned {\n-    // Empty.\n+pub trait Send {\n+    // empty.\n+}\n+\n+#[cfg(not(stage0))]\n+#[lang=\"send\"]\n+pub trait Send {\n+    // empty.\n }\n \n+#[cfg(stage0)]\n #[lang=\"const\"]\n-pub trait Const {\n-    // Empty.\n+pub trait Freeze {\n+    // empty.\n+}\n+\n+#[cfg(not(stage0))]\n+#[lang=\"freeze\"]\n+pub trait Freeze {\n+    // empty.\n }\n \n #[lang=\"sized\"]"}, {"sha": "845152f85525183753ffc53ebbedb351aa9b313b", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -400,7 +400,8 @@ impl Integer for $T {\n     #[inline]\n     fn gcd(&self, other: &$T) -> $T {\n         // Use Euclid's algorithm\n-        let mut (m, n) = (*self, *other);\n+        let mut m = *self;\n+        let mut n = *other;\n         while m != 0 {\n             let temp = m;\n             m = n % temp;"}, {"sha": "b856c3c65ea5aa04e829815a93be8d00e57d6654", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -412,7 +412,7 @@ pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(radix: uint, pow\n         if my_pow % 2u == 1u {\n             total = total * multiplier;\n         }\n-        my_pow     = my_pow / 2u;\n+        my_pow = my_pow / 2u;\n         multiplier = multiplier * multiplier;\n     }\n     total"}, {"sha": "0dabe7fafa834e67fffb48b9bc77f6e892c8833c", "filename": "src/libstd/num/uint_macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint_macros.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -237,7 +237,8 @@ impl Integer for $T {\n     #[inline]\n     fn gcd(&self, other: &$T) -> $T {\n         // Use Euclid's algorithm\n-        let mut (m, n) = (*self, *other);\n+        let mut m = *self;\n+        let mut n = *other;\n         while m != 0 {\n             let temp = m;\n             m = n % temp;"}, {"sha": "400a93ee28f4e667a9e6d97e4c63746b2c94dfdc", "filename": "src/libstd/os.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -29,6 +29,7 @@\n #[allow(missing_doc)];\n \n use cast;\n+use container::Container;\n use io;\n use iterator::IteratorUtil;\n use libc;\n@@ -145,7 +146,7 @@ pub mod win32 {\n     pub fn as_utf16_p<T>(s: &str, f: &fn(*u16) -> T) -> T {\n         let mut t = s.to_utf16();\n         // Null terminate before passing on.\n-        t += [0u16];\n+        t.push(0u16);\n         vec::as_imm_buf(t, |buf, _len| f(buf))\n     }\n }\n@@ -1500,7 +1501,10 @@ mod tests {\n     fn test_getenv_big() {\n         let mut s = ~\"\";\n         let mut i = 0;\n-        while i < 100 { s += \"aaaaaaaaaa\"; i += 1; }\n+        while i < 100 {\n+            s = s + \"aaaaaaaaaa\";\n+            i += 1;\n+        }\n         let n = make_rand_name();\n         setenv(n, s);\n         debug!(copy s);"}, {"sha": "a5e82c31d79008786354acd6dac5569b14224d19", "filename": "src/libstd/path.rs", "status": "modified", "additions": 66, "deletions": 14, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -21,8 +21,8 @@ use cmp::Eq;\n use iterator::IteratorUtil;\n use libc;\n use option::{None, Option, Some};\n+use str::{OwnedStr, Str, StrSlice, StrVector};\n use str;\n-use str::{Str, StrSlice, StrVector};\n use to_str::ToStr;\n use ascii::{AsciiCast, AsciiStr};\n use vec::{OwnedVector, ImmutableVector};\n@@ -335,8 +335,8 @@ mod stat {\n     }\n }\n \n-\n-impl Path {\n+#[cfg(target_os = \"win32\")]\n+impl WindowsPath {\n     pub fn stat(&self) -> Option<libc::stat> {\n         unsafe {\n              do str::as_c_str(self.to_str()) |buf| {\n@@ -349,12 +349,35 @@ impl Path {\n         }\n     }\n \n-    #[cfg(unix)]\n-    pub fn lstat(&self) -> Option<libc::stat> {\n+    pub fn exists(&self) -> bool {\n+        match self.stat() {\n+            None => false,\n+            Some(_) => true,\n+        }\n+    }\n+\n+    pub fn get_size(&self) -> Option<i64> {\n+        match self.stat() {\n+            None => None,\n+            Some(ref st) => Some(st.st_size as i64),\n+        }\n+    }\n+\n+    pub fn get_mode(&self) -> Option<uint> {\n+        match self.stat() {\n+            None => None,\n+            Some(ref st) => Some(st.st_mode as uint),\n+        }\n+    }\n+}\n+\n+#[cfg(not(target_os = \"win32\"))]\n+impl PosixPath {\n+    pub fn stat(&self) -> Option<libc::stat> {\n         unsafe {\n-            do str::as_c_str(self.to_str()) |buf| {\n+             do str::as_c_str(self.to_str()) |buf| {\n                 let mut st = stat::arch::default_stat();\n-                match libc::lstat(buf, &mut st) {\n+                match libc::stat(buf, &mut st) {\n                     0 => Some(st),\n                     _ => None,\n                 }\n@@ -396,7 +419,7 @@ impl Path {\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n-impl Path {\n+impl PosixPath {\n     pub fn get_atime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n@@ -428,9 +451,24 @@ impl Path {\n     }\n }\n \n+#[cfg(unix)]\n+impl PosixPath {\n+    pub fn lstat(&self) -> Option<libc::stat> {\n+        unsafe {\n+            do str::as_c_str(self.to_str()) |buf| {\n+                let mut st = stat::arch::default_stat();\n+                match libc::lstat(buf, &mut st) {\n+                    0 => Some(st),\n+                    _ => None,\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"macos\")]\n-impl Path {\n+impl PosixPath {\n     pub fn get_birthtime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n@@ -443,7 +481,7 @@ impl Path {\n }\n \n #[cfg(target_os = \"win32\")]\n-impl Path {\n+impl WindowsPath {\n     pub fn get_atime(&self) -> Option<(i64, int)> {\n         match self.stat() {\n             None => None,\n@@ -470,13 +508,21 @@ impl Path {\n             }\n         }\n     }\n+\n+    /// Execute a function on p as well as all of its ancestors\n+    pub fn each_parent(&self, f: &fn(&Path)) {\n+        if !self.components.is_empty() {\n+            f(self);\n+            self.pop().each_parent(f);\n+        }\n+    }\n }\n \n impl ToStr for PosixPath {\n     fn to_str(&self) -> ~str {\n         let mut s = ~\"\";\n         if self.is_absolute {\n-            s += \"/\";\n+            s.push_str(\"/\");\n         }\n         s + self.components.connect(\"/\")\n     }\n@@ -655,15 +701,21 @@ impl ToStr for WindowsPath {\n     fn to_str(&self) -> ~str {\n         let mut s = ~\"\";\n         match self.host {\n-          Some(ref h) => { s += \"\\\\\\\\\"; s += *h; }\n+          Some(ref h) => {\n+            s.push_str(\"\\\\\\\\\");\n+            s.push_str(*h);\n+          }\n           None => { }\n         }\n         match self.device {\n-          Some(ref d) => { s += *d; s += \":\"; }\n+          Some(ref d) => {\n+            s.push_str(*d);\n+            s.push_str(\":\");\n+          }\n           None => { }\n         }\n         if self.is_absolute {\n-            s += \"\\\\\";\n+            s.push_str(\"\\\\\");\n         }\n         s + self.components.connect(\"\\\\\")\n     }"}, {"sha": "49713a3a23b9a338e4a42dc656a8700290b2f9d7", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -88,7 +88,7 @@ use container::Container;\n use cast::{forget, transmute, transmute_copy, transmute_mut};\n use either::{Either, Left, Right};\n use iterator::IteratorUtil;\n-use kinds::Owned;\n+use kinds::Send;\n use libc;\n use ops::Drop;\n use option::{None, Option, Some};\n@@ -177,7 +177,7 @@ impl PacketHeader {\n         transmute_copy(&self.buffer)\n     }\n \n-    pub fn set_buffer<T:Owned>(&mut self, b: ~Buffer<T>) {\n+    pub fn set_buffer<T:Send>(&mut self, b: ~Buffer<T>) {\n         unsafe {\n             self.buffer = transmute_copy(&b);\n         }\n@@ -193,13 +193,13 @@ pub trait HasBuffer {\n     fn set_buffer(&mut self, b: *libc::c_void);\n }\n \n-impl<T:Owned> HasBuffer for Packet<T> {\n+impl<T:Send> HasBuffer for Packet<T> {\n     fn set_buffer(&mut self, b: *libc::c_void) {\n         self.header.buffer = b;\n     }\n }\n \n-pub fn mk_packet<T:Owned>() -> Packet<T> {\n+pub fn mk_packet<T:Send>() -> Packet<T> {\n     Packet {\n         header: PacketHeader(),\n         payload: None,\n@@ -230,7 +230,7 @@ pub fn packet<T>() -> *mut Packet<T> {\n     p\n }\n \n-pub fn entangle_buffer<T:Owned,Tstart:Owned>(\n+pub fn entangle_buffer<T:Send,Tstart:Send>(\n     mut buffer: ~Buffer<T>,\n     init: &fn(*libc::c_void, x: &mut T) -> *mut Packet<Tstart>)\n     -> (RecvPacketBuffered<Tstart, T>, SendPacketBuffered<Tstart, T>) {\n@@ -396,7 +396,7 @@ pub fn send<T,Tbuffer>(mut p: SendPacketBuffered<T,Tbuffer>,\n Fails if the sender closes the connection.\n \n */\n-pub fn recv<T:Owned,Tbuffer:Owned>(\n+pub fn recv<T:Send,Tbuffer:Send>(\n     p: RecvPacketBuffered<T, Tbuffer>) -> T {\n     try_recv(p).expect(\"connection closed\")\n }\n@@ -407,7 +407,7 @@ Returns `None` if the sender has closed the connection without sending\n a message, or `Some(T)` if a message was received.\n \n */\n-pub fn try_recv<T:Owned,Tbuffer:Owned>(mut p: RecvPacketBuffered<T, Tbuffer>)\n+pub fn try_recv<T:Send,Tbuffer:Send>(mut p: RecvPacketBuffered<T, Tbuffer>)\n                                        -> Option<T> {\n     let p_ = p.unwrap();\n     let p = unsafe { &mut *p_ };\n@@ -427,7 +427,7 @@ pub fn try_recv<T:Owned,Tbuffer:Owned>(mut p: RecvPacketBuffered<T, Tbuffer>)\n     }\n }\n \n-fn try_recv_<T:Owned>(p: &mut Packet<T>) -> Option<T> {\n+fn try_recv_<T:Send>(p: &mut Packet<T>) -> Option<T> {\n     // optimistic path\n     match p.header.state {\n       Full => {\n@@ -511,7 +511,7 @@ fn try_recv_<T:Owned>(p: &mut Packet<T>) -> Option<T> {\n }\n \n /// Returns true if messages are available.\n-pub fn peek<T:Owned,Tb:Owned>(p: &mut RecvPacketBuffered<T, Tb>) -> bool {\n+pub fn peek<T:Send,Tb:Send>(p: &mut RecvPacketBuffered<T, Tb>) -> bool {\n     unsafe {\n         match (*p.header()).state {\n             Empty | Terminated => false,\n@@ -521,7 +521,7 @@ pub fn peek<T:Owned,Tb:Owned>(p: &mut RecvPacketBuffered<T, Tb>) -> bool {\n     }\n }\n \n-fn sender_terminate<T:Owned>(p: *mut Packet<T>) {\n+fn sender_terminate<T:Send>(p: *mut Packet<T>) {\n     let p = unsafe {\n         &mut *p\n     };\n@@ -553,7 +553,7 @@ fn sender_terminate<T:Owned>(p: *mut Packet<T>) {\n     }\n }\n \n-fn receiver_terminate<T:Owned>(p: *mut Packet<T>) {\n+fn receiver_terminate<T:Send>(p: *mut Packet<T>) {\n     let p = unsafe {\n         &mut *p\n     };\n@@ -671,7 +671,7 @@ pub struct SendPacketBuffered<T, Tbuffer> {\n }\n \n #[unsafe_destructor]\n-impl<T:Owned,Tbuffer:Owned> Drop for SendPacketBuffered<T,Tbuffer> {\n+impl<T:Send,Tbuffer:Send> Drop for SendPacketBuffered<T,Tbuffer> {\n     fn drop(&self) {\n         unsafe {\n             let this: &mut SendPacketBuffered<T,Tbuffer> = transmute(self);\n@@ -729,7 +729,7 @@ pub struct RecvPacketBuffered<T, Tbuffer> {\n }\n \n #[unsafe_destructor]\n-impl<T:Owned,Tbuffer:Owned> Drop for RecvPacketBuffered<T,Tbuffer> {\n+impl<T:Send,Tbuffer:Send> Drop for RecvPacketBuffered<T,Tbuffer> {\n     fn drop(&self) {\n         unsafe {\n             let this: &mut RecvPacketBuffered<T,Tbuffer> = transmute(self);\n@@ -741,7 +741,7 @@ impl<T:Owned,Tbuffer:Owned> Drop for RecvPacketBuffered<T,Tbuffer> {\n     }\n }\n \n-impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n+impl<T:Send,Tbuffer:Send> RecvPacketBuffered<T, Tbuffer> {\n     pub fn unwrap(&mut self) -> *mut Packet<T> {\n         replace(&mut self.p, None).unwrap()\n     }\n@@ -751,7 +751,7 @@ impl<T:Owned,Tbuffer:Owned> RecvPacketBuffered<T, Tbuffer> {\n     }\n }\n \n-impl<T:Owned,Tbuffer:Owned> Selectable for RecvPacketBuffered<T, Tbuffer> {\n+impl<T:Send,Tbuffer:Send> Selectable for RecvPacketBuffered<T, Tbuffer> {\n     fn header(&mut self) -> *mut PacketHeader {\n         match self.p {\n             Some(packet) => unsafe {\n@@ -807,7 +807,7 @@ Sometimes messages will be available on both endpoints at once. In\n this case, `select2` may return either `left` or `right`.\n \n */\n-pub fn select2<A:Owned,Ab:Owned,B:Owned,Bb:Owned>(\n+pub fn select2<A:Send,Ab:Send,B:Send,Bb:Send>(\n     mut a: RecvPacketBuffered<A, Ab>,\n     mut b: RecvPacketBuffered<B, Bb>)\n     -> Either<(Option<A>, RecvPacketBuffered<B, Bb>),\n@@ -847,7 +847,7 @@ pub fn select2i<A:Selectable,B:Selectable>(a: &mut A, b: &mut B)\n \n /// Waits on a set of endpoints. Returns a message, its index, and a\n /// list of the remaining endpoints.\n-pub fn select<T:Owned,Tb:Owned>(mut endpoints: ~[RecvPacketBuffered<T, Tb>])\n+pub fn select<T:Send,Tb:Send>(mut endpoints: ~[RecvPacketBuffered<T, Tb>])\n                                 -> (uint,\n                                     Option<T>,\n                                     ~[RecvPacketBuffered<T, Tb>]) {"}, {"sha": "13d19b276f59eed58528d4b8c0136ed97dbfab70", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -29,7 +29,8 @@ Rust's prelude has three main parts:\n \n // Reexported core operators\n pub use either::{Either, Left, Right};\n-pub use kinds::{Const, Copy, Owned, Sized};\n+pub use kinds::{Copy, Sized};\n+pub use kinds::{Freeze, Send};\n pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Drop};"}, {"sha": "5baff8aee68dd159a11b3029120de1ec83f54da1", "filename": "src/libstd/rand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -42,6 +42,7 @@ fn main () {\n \n use cast;\n use cmp;\n+use container::Container;\n use int;\n use iterator::IteratorUtil;\n use local_data;\n@@ -720,7 +721,8 @@ impl IsaacRng {\n     fn isaac(&mut self) {\n         self.c += 1;\n         // abbreviations\n-        let mut (a, b) = (self.a, self.b + self.c);\n+        let mut a = self.a;\n+        let mut b = self.b + self.c;\n \n         static midpoint: uint = RAND_SIZE as uint / 2;\n "}, {"sha": "e8dad2fc5e862202bf92a2f03f17b0d3f5c8c682", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -89,7 +89,8 @@ impl Rand for StandardNormal {\n             // do-while, so the condition should be true on the first\n             // run, they get overwritten anyway (0 < 1, so these are\n             // good).\n-            let mut (x, y) = (1.0, 0.0);\n+            let mut x = 1.0;\n+            let mut y = 0.0;\n \n             // XXX infinities?\n             while -2.0*y < x * x {"}, {"sha": "72907f40a0744a4949f61684f7adda0de6314804", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -19,7 +19,7 @@ use option::*;\n use cast;\n use util;\n use ops::Drop;\n-use kinds::Owned;\n+use kinds::Send;\n use rt::sched::{Scheduler, Coroutine};\n use rt::local::Local;\n use unstable::intrinsics::{atomic_xchg, atomic_load};\n@@ -68,7 +68,7 @@ pub struct PortOneHack<T> {\n     suppress_finalize: bool\n }\n \n-pub fn oneshot<T: Owned>() -> (PortOne<T>, ChanOne<T>) {\n+pub fn oneshot<T: Send>() -> (PortOne<T>, ChanOne<T>) {\n     let packet: ~Packet<T> = ~Packet {\n         state: STATE_BOTH,\n         payload: None\n@@ -307,20 +307,20 @@ pub struct Port<T> {\n     next: Cell<PortOne<StreamPayload<T>>>\n }\n \n-pub fn stream<T: Owned>() -> (Port<T>, Chan<T>) {\n+pub fn stream<T: Send>() -> (Port<T>, Chan<T>) {\n     let (pone, cone) = oneshot();\n     let port = Port { next: Cell::new(pone) };\n     let chan = Chan { next: Cell::new(cone) };\n     return (port, chan);\n }\n \n-impl<T: Owned> GenericChan<T> for Chan<T> {\n+impl<T: Send> GenericChan<T> for Chan<T> {\n     fn send(&self, val: T) {\n         self.try_send(val);\n     }\n }\n \n-impl<T: Owned> GenericSmartChan<T> for Chan<T> {\n+impl<T: Send> GenericSmartChan<T> for Chan<T> {\n     fn try_send(&self, val: T) -> bool {\n         let (next_pone, next_cone) = oneshot();\n         let cone = self.next.take();"}, {"sha": "c6654e9dabed0b72a35b1fdd71f3166f7164e2ad", "filename": "src/libstd/rt/io/extensions.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frt%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fextensions.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -343,7 +343,9 @@ impl<T: Reader> ReaderByteConversions for T {\n     fn read_le_uint_n(&mut self, nbytes: uint) -> u64 {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n-        let mut (val, pos, i) = (0u64, 0, nbytes);\n+        let mut val = 0u64;\n+        let mut pos = 0;\n+        let mut i = nbytes;\n         while i > 0 {\n             val += (self.read_u8() as u64) << pos;\n             pos += 8;\n@@ -359,7 +361,8 @@ impl<T: Reader> ReaderByteConversions for T {\n     fn read_be_uint_n(&mut self, nbytes: uint) -> u64 {\n         assert!(nbytes > 0 && nbytes <= 8);\n \n-        let mut (val, i) = (0u64, nbytes);\n+        let mut val = 0u64;\n+        let mut i = nbytes;\n         while i > 0 {\n             i -= 1;\n             val += (self.read_u8() as u64) << i * 8;"}, {"sha": "d561e81d032712efaa400e457f7c02914ea42ab0", "filename": "src/libstd/rt/message_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use container::Container;\n-use kinds::Owned;\n+use kinds::Send;\n use vec::OwnedVector;\n use cell::Cell;\n use option::*;\n@@ -21,7 +21,7 @@ pub struct MessageQueue<T> {\n     priv queue: ~Exclusive<~[T]>\n }\n \n-impl<T: Owned> MessageQueue<T> {\n+impl<T: Send> MessageQueue<T> {\n     pub fn new() -> MessageQueue<T> {\n         MessageQueue {\n             queue: ~exclusive(~[])"}, {"sha": "00d2774426884f12f05076bdfa2f875c9d4583ba", "filename": "src/libstd/rt/work_queue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frt%2Fwork_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Frt%2Fwork_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fwork_queue.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -13,15 +13,15 @@ use option::*;\n use vec::OwnedVector;\n use unstable::sync::{Exclusive, exclusive};\n use cell::Cell;\n-use kinds::Owned;\n+use kinds::Send;\n use clone::Clone;\n \n pub struct WorkQueue<T> {\n     // XXX: Another mystery bug fixed by boxing this lock\n     priv queue: ~Exclusive<~[T]>\n }\n \n-impl<T: Owned> WorkQueue<T> {\n+impl<T: Send> WorkQueue<T> {\n     pub fn new() -> WorkQueue<T> {\n         WorkQueue {\n             queue: ~exclusive(~[])"}, {"sha": "2144afc0fbd1858d6390f11c87e9b4d728428293", "filename": "src/libstd/str.rs", "status": "modified", "additions": 88, "deletions": 15, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -357,7 +357,8 @@ impl<'self> Iterator<(uint, uint)> for StrMatchesIndexIterator<'self> {\n     fn next(&mut self) -> Option<(uint, uint)> {\n         // See Issue #1932 for why this is a naive search\n         let (h_len, n_len) = (self.haystack.len(), self.needle.len());\n-        let mut (match_start, match_i) = (0, 0);\n+        let mut match_start = 0;\n+        let mut match_i = 0;\n \n         while self.position < h_len {\n             if self.haystack[self.position] == self.needle[match_i] {\n@@ -473,6 +474,31 @@ pub fn each_split_within<'a>(ss: &'a str,\n     return cont;\n }\n \n+/**\n+ * Replace all occurrences of one string with another\n+ *\n+ * # Arguments\n+ *\n+ * * s - The string containing substrings to replace\n+ * * from - The string to replace\n+ * * to - The replacement string\n+ *\n+ * # Return value\n+ *\n+ * The original string with all occurances of `from` replaced with `to`\n+ */\n+pub fn replace(s: &str, from: &str, to: &str) -> ~str {\n+    let mut result = ~\"\";\n+    let mut last_end = 0;\n+    for s.matches_index_iter(from).advance |(start, end)| {\n+        result.push_str(unsafe{raw::slice_bytes(s, last_end, start)});\n+        result.push_str(to);\n+        last_end = end;\n+    }\n+    result.push_str(unsafe{raw::slice_bytes(s, last_end, s.len())});\n+    result\n+}\n+\n /*\n Section: Comparing strings\n */\n@@ -631,6 +657,48 @@ pub fn with_capacity(capacity: uint) -> ~str {\n     buf\n }\n \n+/**\n+ * As char_len but for a slice of a string\n+ *\n+ * # Arguments\n+ *\n+ * * s - A valid string\n+ * * start - The position inside `s` where to start counting in bytes\n+ * * end - The position where to stop counting\n+ *\n+ * # Return value\n+ *\n+ * The number of Unicode characters in `s` between the given indices.\n+ */\n+pub fn count_chars(s: &str, start: uint, end: uint) -> uint {\n+    assert!(s.is_char_boundary(start));\n+    assert!(s.is_char_boundary(end));\n+    let mut i = start;\n+    let mut len = 0u;\n+    while i < end {\n+        let next = s.char_range_at(i).next;\n+        len += 1u;\n+        i = next;\n+    }\n+    return len;\n+}\n+\n+/// Counts the number of bytes taken by the first `n` chars in `s`\n+/// starting from `start`.\n+pub fn count_bytes<'b>(s: &'b str, start: uint, n: uint) -> uint {\n+    assert!(s.is_char_boundary(start));\n+    let mut end = start;\n+    let mut cnt = n;\n+    let l = s.len();\n+    while cnt > 0u {\n+        assert!(end < l);\n+        let next = s.char_range_at(end).next;\n+        cnt -= 1u;\n+        end = next;\n+    }\n+    end - start\n+}\n+\n /// Given a first byte, determine how many bytes are in this UTF-8 character\n pub fn utf8_char_width(b: u8) -> uint {\n     let byte: uint = b as uint;\n@@ -737,7 +805,8 @@ pub mod raw {\n \n     /// Create a Rust string from a null-terminated *u8 buffer\n     pub unsafe fn from_buf(buf: *u8) -> ~str {\n-        let mut (curr, i) = (buf, 0u);\n+        let mut curr = buf;\n+        let mut i = 0u;\n         while *curr != 0u8 {\n             i += 1u;\n             curr = ptr::offset(buf, i);\n@@ -790,7 +859,8 @@ pub mod raw {\n     /// invalidated later.\n     pub unsafe fn c_str_to_static_slice(s: *libc::c_char) -> &'static str {\n         let s = s as *u8;\n-        let mut (curr, len) = (s, 0u);\n+        let mut curr = s;\n+        let mut len = 0u;\n         while *curr != 0u8 {\n             len += 1u;\n             curr = ptr::offset(s, len);\n@@ -1070,6 +1140,17 @@ impl<'self> Str for @str {\n     }\n }\n \n+impl<'self> Container for &'self str {\n+    #[inline]\n+    fn len(&self) -> uint {\n+        do as_buf(*self) |_p, n| { n - 1u }\n+    }\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        self.len() == 0\n+    }\n+}\n+\n #[allow(missing_doc)]\n pub trait StrSlice<'self> {\n     fn contains<'a>(&self, needle: &'a str) -> bool;\n@@ -1088,10 +1169,8 @@ pub trait StrSlice<'self> {\n     fn any_line_iter(&self) -> AnyLineIterator<'self>;\n     fn word_iter(&self) -> WordIterator<'self>;\n     fn ends_with(&self, needle: &str) -> bool;\n-    fn is_empty(&self) -> bool;\n     fn is_whitespace(&self) -> bool;\n     fn is_alphanumeric(&self) -> bool;\n-    fn len(&self) -> uint;\n     fn char_len(&self) -> uint;\n \n     fn slice(&self, begin: uint, end: uint) -> &'self str;\n@@ -1292,9 +1371,6 @@ impl<'self> StrSlice<'self> for &'self str {\n         self.split_iter(char::is_whitespace).filter(|s| !s.is_empty())\n     }\n \n-    /// Returns true if the string has length 0\n-    #[inline]\n-    fn is_empty(&self) -> bool { self.len() == 0 }\n     /**\n      * Returns true if the string contains only whitespace\n      *\n@@ -1309,11 +1385,6 @@ impl<'self> StrSlice<'self> for &'self str {\n      */\n     #[inline]\n     fn is_alphanumeric(&self) -> bool { self.iter().all(char::is_alphanumeric) }\n-    /// Returns the size in bytes not counting the null terminator\n-    #[inline]\n-    fn len(&self) -> uint {\n-        do as_buf(*self) |_p, n| { n - 1u }\n-    }\n     /// Returns the number of characters that a string holds\n     #[inline]\n     fn char_len(&self) -> uint { self.iter().len_() }\n@@ -1357,7 +1428,8 @@ impl<'self> StrSlice<'self> for &'self str {\n     fn slice_chars(&self, begin: uint, end: uint) -> &'self str {\n         assert!(begin <= end);\n         // not sure how to use the iterators for this nicely.\n-        let mut (position, count) = (0, 0);\n+        let mut position = 0;\n+        let mut count = 0;\n         let l = self.len();\n         while count < begin && position < l {\n             position = self.char_range_at(position).next;\n@@ -1505,7 +1577,8 @@ impl<'self> StrSlice<'self> for &'self str {\n      * The original string with all occurances of `from` replaced with `to`\n      */\n     pub fn replace(&self, from: &str, to: &str) -> ~str {\n-        let mut (result, last_end) = (~\"\", 0);\n+        let mut result = ~\"\";\n+        let mut last_end = 0;\n         for self.matches_index_iter(from).advance |(start, end)| {\n             result.push_str(unsafe{raw::slice_bytes(*self, last_end, start)});\n             result.push_str(to);"}, {"sha": "a8e8cfd163ad7005d5733dca0709e1b5d073a482", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -353,7 +353,7 @@ impl TaskBuilder {\n     }\n \n     /// Runs a task, while transfering ownership of one argument to the child.\n-    pub fn spawn_with<A:Owned>(&mut self, arg: A, f: ~fn(v: A)) {\n+    pub fn spawn_with<A:Send>(&mut self, arg: A, f: ~fn(v: A)) {\n         let arg = Cell::new(arg);\n         do self.spawn {\n             f(arg.take());\n@@ -373,7 +373,7 @@ impl TaskBuilder {\n      * # Failure\n      * Fails if a future_result was already set for this task.\n      */\n-    pub fn try<T:Owned>(&mut self, f: ~fn() -> T) -> Result<T,()> {\n+    pub fn try<T:Send>(&mut self, f: ~fn() -> T) -> Result<T,()> {\n         let (po, ch) = stream::<T>();\n         let mut result = None;\n \n@@ -445,7 +445,7 @@ pub fn spawn_supervised(f: ~fn()) {\n     task.spawn(f)\n }\n \n-pub fn spawn_with<A:Owned>(arg: A, f: ~fn(v: A)) {\n+pub fn spawn_with<A:Send>(arg: A, f: ~fn(v: A)) {\n     /*!\n      * Runs a task, while transfering ownership of one argument to the\n      * child.\n@@ -478,7 +478,7 @@ pub fn spawn_sched(mode: SchedMode, f: ~fn()) {\n     task.spawn(f)\n }\n \n-pub fn try<T:Owned>(f: ~fn() -> T) -> Result<T,()> {\n+pub fn try<T:Send>(f: ~fn() -> T) -> Result<T,()> {\n     /*!\n      * Execute a function in another task and return either the return value\n      * of the function or result::err."}, {"sha": "8f06fede05722d794f1a172c7cc727f47f0d50c3", "filename": "src/libstd/task/spawn.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Ftask%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Ftask%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fspawn.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -636,7 +636,8 @@ fn spawn_raw_oldsched(mut opts: TaskOpts, f: ~fn()) {\n         let child_data = Cell::new((notify_chan, child_arc, ancestors));\n         let result: ~fn() = || {\n             // Agh. Get move-mode items into the closure. FIXME (#2829)\n-            let mut (notify_chan, child_arc, ancestors) = child_data.take();\n+            let (notify_chan, child_arc, ancestors) = child_data.take();\n+            let mut ancestors = ancestors;\n             // Child task runs this code.\n \n             // Even if the below code fails to kick the child off, we must"}, {"sha": "77701acd33e2eec8d88ced57ae28556e9def5aa5", "filename": "src/libstd/to_str.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_str.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -53,7 +53,8 @@ impl<A:ToStr> ToStr for (A,) {\n impl<A:ToStr+Hash+Eq, B:ToStr+Hash+Eq> ToStr for HashMap<A, B> {\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        let mut (acc, first) = (~\"{\", true);\n+        let mut acc = ~\"{\";\n+        let mut first = true;\n         for self.iter().advance |(key, value)| {\n             if first {\n                 first = false;\n@@ -73,7 +74,8 @@ impl<A:ToStr+Hash+Eq, B:ToStr+Hash+Eq> ToStr for HashMap<A, B> {\n impl<A:ToStr+Hash+Eq> ToStr for HashSet<A> {\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        let mut (acc, first) = (~\"{\", true);\n+        let mut acc = ~\"{\";\n+        let mut first = true;\n         for self.iter().advance |element| {\n             if first {\n                 first = false;\n@@ -121,7 +123,8 @@ impl<A:ToStr,B:ToStr,C:ToStr> ToStr for (A, B, C) {\n impl<'self,A:ToStr> ToStr for &'self [A] {\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        let mut (acc, first) = (~\"[\", true);\n+        let mut acc = ~\"[\";\n+        let mut first = true;\n         for self.iter().advance |elt| {\n             if first {\n                 first = false;\n@@ -139,7 +142,8 @@ impl<'self,A:ToStr> ToStr for &'self [A] {\n impl<A:ToStr> ToStr for ~[A] {\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        let mut (acc, first) = (~\"[\", true);\n+        let mut acc = ~\"[\";\n+        let mut first = true;\n         for self.iter().advance |elt| {\n             if first {\n                 first = false;\n@@ -157,7 +161,8 @@ impl<A:ToStr> ToStr for ~[A] {\n impl<A:ToStr> ToStr for @[A] {\n     #[inline]\n     fn to_str(&self) -> ~str {\n-        let mut (acc, first) = (~\"[\", true);\n+        let mut acc = ~\"[\";\n+        let mut first = true;\n         for self.iter().advance |elt| {\n             if first {\n                 first = false;"}, {"sha": "624062a7ec4072279f010726491164506dbba6ca", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -94,6 +94,7 @@ use iterator::IteratorUtil;\n #[doc(hidden)]\n pub mod ct {\n     use char;\n+    use container::Container;\n     use prelude::*;\n     use str;\n "}, {"sha": "285a8114cc24032e287e8264a753ee746f074ed1", "filename": "src/libstd/unstable/global.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Funstable%2Fglobal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Funstable%2Fglobal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fglobal.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -27,7 +27,7 @@ avoid hitting the mutex.\n \n use cast::{transmute};\n use clone::Clone;\n-use kinds::Owned;\n+use kinds::Send;\n use libc::{c_void};\n use option::{Option, Some, None};\n use ops::Drop;\n@@ -43,7 +43,7 @@ use sys::Closure;\n \n pub type GlobalDataKey<'self,T> = &'self fn(v: T);\n \n-pub unsafe fn global_data_clone_create<T:Owned + Clone>(\n+pub unsafe fn global_data_clone_create<T:Send + Clone>(\n     key: GlobalDataKey<T>, create: &fn() -> ~T) -> T {\n     /*!\n      * Clone a global value or, if it has not been created,\n@@ -59,7 +59,7 @@ pub unsafe fn global_data_clone_create<T:Owned + Clone>(\n     global_data_clone_create_(key_ptr(key), create)\n }\n \n-unsafe fn global_data_clone_create_<T:Owned + Clone>(\n+unsafe fn global_data_clone_create_<T:Send + Clone>(\n     key: uint, create: &fn() -> ~T) -> T {\n \n     let mut clone_value: Option<T> = None;\n@@ -79,13 +79,13 @@ unsafe fn global_data_clone_create_<T:Owned + Clone>(\n     return clone_value.unwrap();\n }\n \n-unsafe fn global_data_modify<T:Owned>(\n+unsafe fn global_data_modify<T:Send>(\n     key: GlobalDataKey<T>, op: &fn(Option<~T>) -> Option<~T>) {\n \n     global_data_modify_(key_ptr(key), op)\n }\n \n-unsafe fn global_data_modify_<T:Owned>(\n+unsafe fn global_data_modify_<T:Send>(\n     key: uint, op: &fn(Option<~T>) -> Option<~T>) {\n \n     let mut old_dtor = None;\n@@ -124,7 +124,7 @@ unsafe fn global_data_modify_<T:Owned>(\n     }\n }\n \n-pub unsafe fn global_data_clone<T:Owned + Clone>(\n+pub unsafe fn global_data_clone<T:Send + Clone>(\n     key: GlobalDataKey<T>) -> Option<T> {\n     let mut maybe_clone: Option<T> = None;\n     do global_data_modify(key) |current| {\n@@ -220,7 +220,7 @@ fn get_global_state() -> Exclusive<GlobalState> {\n     }\n }\n \n-fn key_ptr<T:Owned>(key: GlobalDataKey<T>) -> uint {\n+fn key_ptr<T:Send>(key: GlobalDataKey<T>) -> uint {\n     unsafe {\n         let closure: Closure = transmute(key);\n         return transmute(closure.code);"}, {"sha": "06c3ecb81475741077d542260c39c7d5e0739cde", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -17,7 +17,7 @@ use unstable::finally::Finally;\n use unstable::intrinsics;\n use ops::Drop;\n use clone::Clone;\n-use kinds::Owned;\n+use kinds::Send;\n \n /// An atomically reference counted pointer.\n ///\n@@ -31,7 +31,7 @@ struct AtomicRcBoxData<T> {\n     data: Option<T>,\n }\n \n-impl<T: Owned> UnsafeAtomicRcBox<T> {\n+impl<T: Send> UnsafeAtomicRcBox<T> {\n     pub fn new(data: T) -> UnsafeAtomicRcBox<T> {\n         unsafe {\n             let data = ~AtomicRcBoxData { count: 1, data: Some(data) };\n@@ -61,7 +61,7 @@ impl<T: Owned> UnsafeAtomicRcBox<T> {\n     }\n }\n \n-impl<T: Owned> Clone for UnsafeAtomicRcBox<T> {\n+impl<T: Send> Clone for UnsafeAtomicRcBox<T> {\n     fn clone(&self) -> UnsafeAtomicRcBox<T> {\n         unsafe {\n             let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n@@ -144,7 +144,7 @@ pub struct Exclusive<T> {\n     x: UnsafeAtomicRcBox<ExData<T>>\n }\n \n-pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n+pub fn exclusive<T:Send>(user_data: T) -> Exclusive<T> {\n     let data = ExData {\n         lock: LittleLock(),\n         failed: false,\n@@ -155,14 +155,14 @@ pub fn exclusive<T:Owned>(user_data: T) -> Exclusive<T> {\n     }\n }\n \n-impl<T:Owned> Clone for Exclusive<T> {\n+impl<T:Send> Clone for Exclusive<T> {\n     // Duplicate an exclusive ARC, as std::arc::clone.\n     fn clone(&self) -> Exclusive<T> {\n         Exclusive { x: self.x.clone() }\n     }\n }\n \n-impl<T:Owned> Exclusive<T> {\n+impl<T:Send> Exclusive<T> {\n     // Exactly like std::arc::mutex_arc,access(), but with the little_lock\n     // instead of a proper mutex. Same reason for being unsafe.\n     //"}, {"sha": "aa4d632a48273c7d04492c83800241131b04a21b", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -348,7 +348,8 @@ pub fn consume_reverse<T>(mut v: ~[T], f: &fn(uint, v: T)) {\n pub fn dedup<T:Eq>(v: &mut ~[T]) {\n     unsafe {\n         if v.len() < 1 { return; }\n-        let mut (last_written, next_to_read) = (0, 1);\n+        let mut last_written = 0;\n+        let mut next_to_read = 1;\n         do as_const_buf(*v) |p, ln| {\n             // We have a mutable reference to v, so we can make arbitrary\n             // changes. (cf. push and pop)\n@@ -798,7 +799,8 @@ pub fn bsearch_elem<T:TotalOrd>(v: &[T], x: &T) -> Option<uint> {\n  * Convert a vector of pairs into a pair of vectors, by reference. As unzip().\n  */\n pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n-    let mut (ts, us) = (~[], ~[]);\n+    let mut ts = ~[];\n+    let mut us = ~[];\n     for v.iter().advance |p| {\n         let (t, u) = copy *p;\n         ts.push(t);\n@@ -816,7 +818,8 @@ pub fn unzip_slice<T:Copy,U:Copy>(v: &[(T, U)]) -> (~[T], ~[U]) {\n  * of the i-th tuple of the input vector.\n  */\n pub fn unzip<T,U>(v: ~[(T, U)]) -> (~[T], ~[U]) {\n-    let mut (ts, us) = (~[], ~[]);\n+    let mut ts = ~[];\n+    let mut us = ~[];\n     do consume(v) |_i, p| {\n         let (t, u) = p;\n         ts.push(t);"}, {"sha": "8e1c51caf7c1aaeeabd6935b720647a6524fbff9", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -147,7 +147,7 @@ pub static crate_node_id: node_id = 0;\n // The AST represents all type param bounds as types.\n // typeck::collect::compute_bounds matches these against\n // the \"special\" built-in traits (see middle::lang_items) and\n-// detects Copy, Send, Owned, and Const.\n+// detects Copy, Send, Send, and Freeze.\n pub enum TyParamBound {\n     TraitTyParamBound(@trait_ref),\n     RegionTyParamBound\n@@ -205,7 +205,8 @@ pub enum def {\n     def_struct(def_id),\n     def_typaram_binder(node_id), /* struct, impl or trait with ty params */\n     def_region(node_id),\n-    def_label(node_id)\n+    def_label(node_id),\n+    def_method(def_id /* method */, Option<def_id> /* trait */),\n }\n \n \n@@ -1047,7 +1048,7 @@ pub struct trait_ref {\n pub enum visibility { public, private, inherited }\n \n impl visibility {\n-    fn inherit_from(&self, parent_visibility: visibility) -> visibility {\n+    pub fn inherit_from(&self, parent_visibility: visibility) -> visibility {\n         match self {\n             &inherited => parent_visibility,\n             &public | &private => *self"}, {"sha": "6761736d2f374e61026af19e4b7137eb03461fe2", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -59,7 +59,7 @@ pub fn def_id_of_def(d: def) -> def_id {\n       def_fn(id, _) | def_static_method(id, _, _) | def_mod(id) |\n       def_foreign_mod(id) | def_static(id, _) |\n       def_variant(_, id) | def_ty(id) | def_ty_param(id, _) |\n-      def_use(id) | def_struct(id) | def_trait(id) => {\n+      def_use(id) | def_struct(id) | def_trait(id) | def_method(id, _) => {\n         id\n       }\n       def_arg(id, _) | def_local(id, _) | def_self(id, _) | def_self_ty(id)\n@@ -619,6 +619,15 @@ pub enum Privacy {\n     Public\n }\n \n+/// Returns true if the given pattern consists solely of an identifier\n+/// and false otherwise.\n+pub fn pat_is_ident(pat: @ast::pat) -> bool {\n+    match pat.node {\n+        ast::pat_ident(*) => true,\n+        _ => false,\n+    }\n+}\n+\n // HYGIENE FUNCTIONS\n \n /// Construct an identifier with the given name and an empty context:"}, {"sha": "ab7d3fda50137eb1bfda42b6947097a5f1ca764b", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -263,8 +263,11 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         let s = fmt!(\"%s:%u \", fm.name, last_line + 1u);\n         let mut indent = s.len();\n         let mut out = ~\"\";\n-        while indent > 0u { out += \" \"; indent -= 1u; }\n-        out += \"...\\n\";\n+        while indent > 0u {\n+            out.push_char(' ');\n+            indent -= 1u;\n+        }\n+        out.push_str(\"...\\n\");\n         io::stderr().write_str(out);\n     }\n \n@@ -285,23 +288,29 @@ fn highlight_lines(cm: @codemap::CodeMap,\n         // part of the 'filename:line ' part of the previous line.\n         let skip = fm.name.len() + digits + 3u;\n         for skip.times() {\n-            s += \" \";\n+            s.push_char(' ');\n         }\n         let orig = fm.get_line(lines.lines[0] as int);\n         for uint::range(0u,left-skip) |pos| {\n             let curChar = (orig[pos] as char);\n-            s += match curChar { // Whenever a tab occurs on the previous\n-                '\\t' => \"\\t\",    // line, we insert one on the error-point-\n-                _ => \" \"         // -squiggly-line as well (instead of a\n-            };                   // space). This way the squiggly-line will\n-        }                        // usually appear in the correct position.\n+            // Whenever a tab occurs on the previous line, we insert one on\n+            // the error-point-squiggly-line as well (instead of a space).\n+            // That way the squiggly line will usually appear in the correct\n+            // position.\n+            match curChar {\n+                '\\t' => s.push_char('\\t'),\n+                _ => s.push_char(' '),\n+            };\n+        }\n         io::stderr().write_str(s);\n         let mut s = ~\"^\";\n         let hi = cm.lookup_char_pos(sp.hi);\n         if hi.col != lo.col {\n             // the ^ already takes up one space\n             let num_squigglies = hi.col.to_uint()-lo.col.to_uint()-1u;\n-            for num_squigglies.times() { s += \"~\"; }\n+            for num_squigglies.times() {\n+                s.push_char('~')\n+            }\n         }\n         print_maybe_colored(s + \"\\n\", diagnosticcolor(lvl));\n     }"}, {"sha": "7df8874076e091456f2fb32bdc485f1ccd9629ba", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -26,8 +26,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n             }\n         } else {\n             match *e {\n-                ast::tt_tok(_, token::IDENT(ident,_)) =>\n-                res_str += cx.str_of(ident),\n+                ast::tt_tok(_, token::IDENT(ident,_)) => res_str.push_str(cx.str_of(ident)),\n                 _ => cx.span_fatal(sp, \"concat_idents! requires ident args.\")\n             }\n         }"}, {"sha": "c9d63d2c416795471e182fc238c2c1edfb5bb7e4", "filename": "src/libsyntax/ext/deriving/to_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fto_str.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -30,7 +30,7 @@ pub fn expand_deriving_to_str(cx: @ExtCtxt,\n                 generics: LifetimeBounds::empty(),\n                 explicit_self: borrowed_explicit_self(),\n                 args: ~[],\n-                ret_ty: Ptr(~Literal(Path::new_local(\"str\")), Owned),\n+                ret_ty: Ptr(~Literal(Path::new_local(\"str\")), Send),\n                 const_nonmatching: false,\n                 combine_substructure: to_str_substructure\n             }"}, {"sha": "a2f9aa58d99adcb4312dc3b1639f69df8a39f37f", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -22,7 +22,7 @@ use opt_vec;\n \n /// The types of pointers\n pub enum PtrTy<'self> {\n-    Owned, // ~\n+    Send, // ~\n     Managed(ast::mutability), // @[mut]\n     Borrowed(Option<&'self str>, ast::mutability), // &['lifetime] [mut]\n }\n@@ -128,7 +128,7 @@ impl<'self> Ty<'self> {\n             Ptr(ref ty, ref ptr) => {\n                 let raw_ty = ty.to_ty(cx, span, self_ty, self_generics);\n                 match *ptr {\n-                    Owned => {\n+                    Send => {\n                         cx.ty_uniq(span, raw_ty)\n                     }\n                     Managed(mutbl) => {\n@@ -248,7 +248,7 @@ pub fn get_explicit_self(cx: @ExtCtxt, span: span, self_ptr: &Option<PtrTy>)\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n-                    Owned => ast::sty_uniq(ast::m_imm),\n+                    Send => ast::sty_uniq(ast::m_imm),\n                     Managed(mutbl) => ast::sty_box(mutbl),\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| @cx.lifetime(span,"}, {"sha": "3044cd50b344c4e11591d99dbf2b46087562a616", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -65,8 +65,8 @@ impl gen_send for message {\n                 args_ast);\n \n             let mut body = ~\"{\\n\";\n-            body += fmt!(\"use super::%s;\\n\", name);\n-            body += \"let mut pipe = pipe;\\n\";\n+            body.push_str(fmt!(\"use super::%s;\\n\", name));\n+            body.push_str(\"let mut pipe = pipe;\\n\");\n \n             if this.proto.is_bounded() {\n                 let (sp, rp) = match (this.dir, next.dir) {\n@@ -76,13 +76,15 @@ impl gen_send for message {\n                   (recv, recv) => (~\"c\", ~\"s\")\n                 };\n \n-                body += \"let mut b = pipe.reuse_buffer();\\n\";\n-                body += fmt!(\"let %s = ::std::pipes::SendPacketBuffered(\\\n-                              &mut (b.buffer.data.%s));\\n\",\n-                             sp, next.name);\n-                body += fmt!(\"let %s = ::std::pipes::RecvPacketBuffered(\\\n-                              &mut (b.buffer.data.%s));\\n\",\n-                             rp, next.name);\n+                body.push_str(\"let mut b = pipe.reuse_buffer();\\n\");\n+                body.push_str(fmt!(\"let %s = ::std::pipes::SendPacketBuffered(\\\n+                                    &mut (b.buffer.data.%s));\\n\",\n+                                    sp,\n+                                    next.name));\n+                body.push_str(fmt!(\"let %s = ::std::pipes::RecvPacketBuffered(\\\n+                                   &mut (b.buffer.data.%s));\\n\",\n+                                   rp,\n+                                   next.name));\n             }\n             else {\n                 let pat = match (this.dir, next.dir) {\n@@ -92,23 +94,22 @@ impl gen_send for message {\n                   (recv, recv) => \"(s, c)\"\n                 };\n \n-                body += fmt!(\"let %s = ::std::pipes::entangle();\\n\", pat);\n+                body.push_str(fmt!(\"let %s = ::std::pipes::entangle();\\n\", pat));\n             }\n-            body += fmt!(\"let message = %s(%s);\\n\",\n-                         name,\n-                         vec::append_one(\n-                             arg_names.map(|x| cx.str_of(*x)),\n-                             @\"s\").connect(\", \"));\n+            body.push_str(fmt!(\"let message = %s(%s);\\n\",\n+                                name,\n+                                vec::append_one(arg_names.map(|x| cx.str_of(*x)), @\"s\")\n+                                                         .connect(\", \")));\n \n             if !try {\n-                body += fmt!(\"::std::pipes::send(pipe, message);\\n\");\n+                body.push_str(fmt!(\"::std::pipes::send(pipe, message);\\n\"));\n                 // return the new channel\n-                body += \"c }\";\n+                body.push_str(\"c }\");\n             }\n             else {\n-                body += fmt!(\"if ::std::pipes::send(pipe, message) {\\n \\\n+                body.push_str(fmt!(\"if ::std::pipes::send(pipe, message) {\\n \\\n                                   ::std::pipes::rt::make_some(c) \\\n-                              } else { ::std::pipes::rt::make_none() } }\");\n+                              } else { ::std::pipes::rt::make_none() } }\"));\n             }\n \n             let body = cx.parse_expr(body.to_managed());\n@@ -155,19 +156,19 @@ impl gen_send for message {\n                 };\n \n                 let mut body = ~\"{ \";\n-                body += fmt!(\"use super::%s;\\n\", name);\n-                body += fmt!(\"let message = %s%s;\\n\", name, message_args);\n+                body.push_str(fmt!(\"use super::%s;\\n\", name));\n+                body.push_str(fmt!(\"let message = %s%s;\\n\", name, message_args));\n \n                 if !try {\n-                    body += fmt!(\"::std::pipes::send(pipe, message);\\n\");\n-                    body += \" }\";\n+                    body.push_str(fmt!(\"::std::pipes::send(pipe, message);\\n\"));\n+                    body.push_str(\" }\");\n                 } else {\n-                    body += fmt!(\"if ::std::pipes::send(pipe, message) \\\n+                    body.push_str(fmt!(\"if ::std::pipes::send(pipe, message) \\\n                                         { \\\n                                       ::std::pipes::rt::make_some(()) \\\n                                   } else { \\\n                                     ::std::pipes::rt::make_none() \\\n-                                  } }\");\n+                                  } }\"));\n                 }\n \n                 let body = cx.parse_expr(body.to_managed());\n@@ -433,10 +434,10 @@ impl gen_init for protocol {\n         let mut server_states = ~[];\n \n         for (copy self.states).iter().advance |s| {\n-            items += s.to_type_decls(cx);\n+            items.push_all_move(s.to_type_decls(cx));\n \n-            client_states += s.to_endpoint_decls(cx, send);\n-            server_states += s.to_endpoint_decls(cx, recv);\n+            client_states.push_all_move(s.to_endpoint_decls(cx, send));\n+            server_states.push_all_move(s.to_endpoint_decls(cx, recv));\n         }\n \n         if self.is_bounded() {"}, {"sha": "d33b72ae3c90e8170d031e360b1503ce72fa039b", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -42,7 +42,7 @@ impl parser_attr for Parser {\n                 if self.look_ahead(1u) != token::LBRACKET {\n                     break;\n                 }\n-                attrs += [self.parse_attribute(ast::attr_outer)];\n+                attrs.push(self.parse_attribute(ast::attr_outer));\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n@@ -53,7 +53,7 @@ impl parser_attr for Parser {\n                 if attr.node.style != ast::attr_outer {\n                   self.fatal(\"expected outer comment\");\n                 }\n-                attrs += [attr];\n+                attrs.push(attr);\n                 self.bump();\n               }\n               _ => break\n@@ -77,9 +77,7 @@ impl parser_attr for Parser {\n         self.expect(&token::RBRACKET);\n         let hi = self.span.hi;\n         return spanned(lo, hi, ast::attribute_ { style: style,\n-                                                 value: meta_item,\n-                                                 is_sugared_doc: false });\n-    }\n+                                                 value: meta_item, is_sugared_doc: false }); }\n \n     // Parse attributes that appear after the opening of an item, each\n     // terminated by a semicolon. In addition to a vector of inner attributes,\n@@ -105,15 +103,15 @@ impl parser_attr for Parser {\n                 let attr = self.parse_attribute(ast::attr_inner);\n                 if *self.token == token::SEMI {\n                     self.bump();\n-                    inner_attrs += [attr];\n+                    inner_attrs.push(attr);\n                 } else {\n                     // It's not really an inner attribute\n                     let outer_attr =\n                         spanned(attr.span.lo, attr.span.hi,\n                             ast::attribute_ { style: ast::attr_outer,\n                                               value: attr.node.value,\n                                               is_sugared_doc: false });\n-                    next_outer_attrs += [outer_attr];\n+                    next_outer_attrs.push(outer_attr);\n                     break;\n                 }\n               }\n@@ -125,9 +123,9 @@ impl parser_attr for Parser {\n                 );\n                 self.bump();\n                 if attr.node.style == ast::attr_inner {\n-                  inner_attrs += [attr];\n+                  inner_attrs.push(attr);\n                 } else {\n-                  next_outer_attrs += [attr];\n+                  next_outer_attrs.push(attr);\n                   break;\n                 }\n               }"}, {"sha": "01af33b13b856316c9ac235e57eeb0f32d56488d", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -254,7 +254,7 @@ fn read_block_comment(rdr: @mut StringReader,\n             bump(rdr);\n         }\n         if !is_eof(rdr) {\n-            curr_line += \"*/\";\n+            curr_line.push_str(\"*/\");\n             bump(rdr);\n             bump(rdr);\n         }\n@@ -278,13 +278,13 @@ fn read_block_comment(rdr: @mut StringReader,\n                 if rdr.curr == '/' && nextch(rdr) == '*' {\n                     bump(rdr);\n                     bump(rdr);\n-                    curr_line += \"*\";\n+                    curr_line.push_char('*');\n                     level += 1;\n                 } else {\n                     if rdr.curr == '*' && nextch(rdr) == '/' {\n                         bump(rdr);\n                         bump(rdr);\n-                        curr_line += \"/\";\n+                        curr_line.push_char('/');\n                         level -= 1;\n                     } else { bump(rdr); }\n                 }"}, {"sha": "04f62f35749034e7a147274ad108a62034de6ac3", "filename": "src/libsyntax/parse/common.rs", "status": "modified", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcommon.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -51,251 +51,3 @@ pub fn token_to_str(token: &token::Token) -> ~str {\n     token::to_str(get_ident_interner(), token)\n }\n \n-impl Parser {\n-    // convert a token to a string using self's reader\n-    pub fn token_to_str(&self, token: &token::Token) -> ~str {\n-        token::to_str(get_ident_interner(), token)\n-    }\n-\n-    // convert the current token to a string using self's reader\n-    pub fn this_token_to_str(&self) -> ~str {\n-        self.token_to_str(self.token)\n-    }\n-\n-    pub fn unexpected_last(&self, t: &token::Token) -> ! {\n-        self.span_fatal(\n-            *self.last_span,\n-            fmt!(\n-                \"unexpected token: `%s`\",\n-                self.token_to_str(t)\n-            )\n-        );\n-    }\n-\n-    pub fn unexpected(&self) -> ! {\n-        self.fatal(\n-            fmt!(\n-                \"unexpected token: `%s`\",\n-                self.this_token_to_str()\n-            )\n-        );\n-    }\n-\n-    // expect and consume the token t. Signal an error if\n-    // the next token is not t.\n-    pub fn expect(&self, t: &token::Token) {\n-        if *self.token == *t {\n-            self.bump();\n-        } else {\n-            self.fatal(\n-                fmt!(\n-                    \"expected `%s` but found `%s`\",\n-                    self.token_to_str(t),\n-                    self.this_token_to_str()\n-                )\n-            )\n-        }\n-    }\n-\n-    pub fn parse_ident(&self) -> ast::ident {\n-        self.check_strict_keywords();\n-        self.check_reserved_keywords();\n-        match *self.token {\n-            token::IDENT(i, _) => {\n-                self.bump();\n-                i\n-            }\n-            token::INTERPOLATED(token::nt_ident(*)) => {\n-                self.bug(\"ident interpolation not converted to real token\");\n-            }\n-            _ => {\n-                self.fatal(\n-                    fmt!(\n-                        \"expected ident, found `%s`\",\n-                        self.this_token_to_str()\n-                    )\n-                );\n-            }\n-        }\n-    }\n-\n-    pub fn parse_path_list_ident(&self) -> ast::path_list_ident {\n-        let lo = self.span.lo;\n-        let ident = self.parse_ident();\n-        let hi = self.last_span.hi;\n-        spanned(lo, hi, ast::path_list_ident_ { name: ident,\n-                                                id: self.get_id() })\n-    }\n-\n-    // consume token 'tok' if it exists. Returns true if the given\n-    // token was present, false otherwise.\n-    pub fn eat(&self, tok: &token::Token) -> bool {\n-        return if *self.token == *tok { self.bump(); true } else { false };\n-    }\n-\n-    pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n-        token::is_keyword(kw, self.token)\n-    }\n-\n-    // if the next token is the given keyword, eat it and return\n-    // true. Otherwise, return false.\n-    pub fn eat_keyword(&self, kw: keywords::Keyword) -> bool {\n-        let is_kw = match *self.token {\n-            token::IDENT(sid, false) => kw.to_ident().name == sid.name,\n-            _ => false\n-        };\n-        if is_kw { self.bump() }\n-        is_kw\n-    }\n-\n-    // if the given word is not a keyword, signal an error.\n-    // if the next token is not the given word, signal an error.\n-    // otherwise, eat it.\n-    pub fn expect_keyword(&self, kw: keywords::Keyword) {\n-        if !self.eat_keyword(kw) {\n-            self.fatal(\n-                fmt!(\n-                    \"expected `%s`, found `%s`\",\n-                    self.id_to_str(kw.to_ident()),\n-                    self.this_token_to_str()\n-                )\n-            );\n-        }\n-    }\n-\n-    // signal an error if the given string is a strict keyword\n-    pub fn check_strict_keywords(&self) {\n-        if token::is_strict_keyword(self.token) {\n-            self.span_err(*self.last_span,\n-                          fmt!(\"found `%s` in ident position\", self.this_token_to_str()));\n-        }\n-    }\n-\n-    // signal an error if the current token is a reserved keyword\n-    pub fn check_reserved_keywords(&self) {\n-        if token::is_reserved_keyword(self.token) {\n-            self.fatal(fmt!(\"`%s` is a reserved keyword\", self.this_token_to_str()));\n-        }\n-    }\n-\n-    // expect and consume a GT. if a >> is seen, replace it\n-    // with a single > and continue. If a GT is not seen,\n-    // signal an error.\n-    pub fn expect_gt(&self) {\n-        if *self.token == token::GT {\n-            self.bump();\n-        } else if *self.token == token::BINOP(token::SHR) {\n-            self.replace_token(\n-                token::GT,\n-                self.span.lo + BytePos(1u),\n-                self.span.hi\n-            );\n-        } else {\n-            let mut s: ~str = ~\"expected `\";\n-            s += self.token_to_str(&token::GT);\n-            s += \"`, found `\";\n-            s += self.this_token_to_str();\n-            s += \"`\";\n-            self.fatal(s);\n-        }\n-    }\n-\n-    // parse a sequence bracketed by '<' and '>', stopping\n-    // before the '>'.\n-    pub fn parse_seq_to_before_gt<T: Copy>(&self,\n-                                           sep: Option<token::Token>,\n-                                           f: &fn(&Parser) -> T)\n-                                           -> OptVec<T> {\n-        let mut first = true;\n-        let mut v = opt_vec::Empty;\n-        while *self.token != token::GT\n-            && *self.token != token::BINOP(token::SHR) {\n-            match sep {\n-              Some(ref t) => {\n-                if first { first = false; }\n-                else { self.expect(t); }\n-              }\n-              _ => ()\n-            }\n-            v.push(f(self));\n-        }\n-        return v;\n-    }\n-\n-    pub fn parse_seq_to_gt<T: Copy>(&self,\n-                                    sep: Option<token::Token>,\n-                                    f: &fn(&Parser) -> T)\n-                                    -> OptVec<T> {\n-        let v = self.parse_seq_to_before_gt(sep, f);\n-        self.expect_gt();\n-        return v;\n-    }\n-\n-    // parse a sequence, including the closing delimiter. The function\n-    // f must consume tokens until reaching the next separator or\n-    // closing bracket.\n-    pub fn parse_seq_to_end<T: Copy>(&self,\n-                                     ket: &token::Token,\n-                                     sep: SeqSep,\n-                                     f: &fn(&Parser) -> T)\n-                                     -> ~[T] {\n-        let val = self.parse_seq_to_before_end(ket, sep, f);\n-        self.bump();\n-        val\n-    }\n-\n-    // parse a sequence, not including the closing delimiter. The function\n-    // f must consume tokens until reaching the next separator or\n-    // closing bracket.\n-    pub fn parse_seq_to_before_end<T: Copy>(&self,\n-                                            ket: &token::Token,\n-                                            sep: SeqSep,\n-                                            f: &fn(&Parser) -> T)\n-                                            -> ~[T] {\n-        let mut first: bool = true;\n-        let mut v: ~[T] = ~[];\n-        while *self.token != *ket {\n-            match sep.sep {\n-              Some(ref t) => {\n-                if first { first = false; }\n-                else { self.expect(t); }\n-              }\n-              _ => ()\n-            }\n-            if sep.trailing_sep_allowed && *self.token == *ket { break; }\n-            v.push(f(self));\n-        }\n-        return v;\n-    }\n-\n-    // parse a sequence, including the closing delimiter. The function\n-    // f must consume tokens until reaching the next separator or\n-    // closing bracket.\n-    pub fn parse_unspanned_seq<T: Copy>(&self,\n-                                        bra: &token::Token,\n-                                        ket: &token::Token,\n-                                        sep: SeqSep,\n-                                        f: &fn(&Parser) -> T)\n-                                        -> ~[T] {\n-        self.expect(bra);\n-        let result = self.parse_seq_to_before_end(ket, sep, f);\n-        self.bump();\n-        result\n-    }\n-\n-    // NB: Do not use this function unless you actually plan to place the\n-    // spanned list in the AST.\n-    pub fn parse_seq<T: Copy>(&self,\n-                              bra: &token::Token,\n-                              ket: &token::Token,\n-                              sep: SeqSep,\n-                              f: &fn(&Parser) -> T)\n-                              -> spanned<~[T]> {\n-        let lo = self.span.lo;\n-        self.expect(bra);\n-        let result = self.parse_seq_to_before_end(ket, sep, f);\n-        let hi = self.span.hi;\n-        self.bump();\n-        spanned(lo, hi, result)\n-    }\n-}"}, {"sha": "4a872832952665b31a7f6a38874c833e3f134f2a", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -180,7 +180,7 @@ pub fn bump(rdr: &mut StringReader) {\n         let byte_offset_diff = next.next - current_byte_offset;\n         rdr.pos = rdr.pos + BytePos(byte_offset_diff);\n         rdr.curr = next.ch;\n-        rdr.col += CharPos(1u);\n+        rdr.col = rdr.col + CharPos(1u);\n         if last_char == '\\n' {\n             rdr.filemap.next_line(rdr.last_pos);\n             rdr.col = CharPos(0u);\n@@ -448,8 +448,8 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n         is_float = true;\n         bump(rdr);\n         let dec_part = scan_digits(rdr, 10u);\n-        num_str += \".\";\n-        num_str += dec_part;\n+        num_str.push_char('.');\n+        num_str.push_str(dec_part);\n     }\n     if is_float {\n         match base {\n@@ -461,7 +461,7 @@ fn scan_number(c: char, rdr: @mut StringReader) -> token::Token {\n     match scan_exponent(rdr) {\n       Some(ref s) => {\n         is_float = true;\n-        num_str += (*s);\n+        num_str.push_str(*s);\n       }\n       None => ()\n     }"}, {"sha": "fff4c125af620a8a0faac5ed8e9b6aa252e25f88", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -62,6 +62,8 @@ pub enum ObsoleteSyntax {\n     ObsoleteFixedLengthVectorType,\n     ObsoleteNamedExternModule,\n     ObsoleteMultipleLocalDecl,\n+    ObsoleteMutWithMultipleBindings,\n+    ObsoletePatternCopyKeyword,\n }\n \n impl to_bytes::IterBytes for ObsoleteSyntax {\n@@ -71,7 +73,26 @@ impl to_bytes::IterBytes for ObsoleteSyntax {\n     }\n }\n \n-impl Parser {\n+pub trait ParserObsoleteMethods {\n+    /// Reports an obsolete syntax non-fatal error.\n+    fn obsolete(&self, sp: span, kind: ObsoleteSyntax);\n+    // Reports an obsolete syntax non-fatal error, and returns\n+    // a placeholder expression\n+    fn obsolete_expr(&self, sp: span, kind: ObsoleteSyntax) -> @expr;\n+    fn report(&self,\n+              sp: span,\n+              kind: ObsoleteSyntax,\n+              kind_str: &str,\n+              desc: &str);\n+    fn token_is_obsolete_ident(&self, ident: &str, token: &Token) -> bool;\n+    fn is_obsolete_ident(&self, ident: &str) -> bool;\n+    fn eat_obsolete_ident(&self, ident: &str) -> bool;\n+    fn try_parse_obsolete_struct_ctor(&self) -> bool;\n+    fn try_parse_obsolete_with(&self) -> bool;\n+    fn try_parse_obsolete_priv_section(&self, attrs: &[attribute]) -> bool;\n+}\n+\n+impl ParserObsoleteMethods for Parser {\n     /// Reports an obsolete syntax non-fatal error.\n     pub fn obsolete(&self, sp: span, kind: ObsoleteSyntax) {\n         let (kind_str, desc) = match kind {\n@@ -223,6 +244,15 @@ impl Parser {\n                 \"instead of e.g. `let a = 1, b = 2`, write \\\n                  `let (a, b) = (1, 2)`.\"\n             ),\n+            ObsoleteMutWithMultipleBindings => (\n+                \"`mut` with multiple bindings\",\n+                \"use multiple local declarations instead of e.g. `let mut \\\n+                 (x, y) = ...`.\"\n+            ),\n+            ObsoletePatternCopyKeyword => (\n+                \"`copy` in patterns\",\n+                \"`copy` in patterns no longer has any effect\"\n+            ),\n         };\n \n         self.report(sp, kind, kind_str, desc);"}, {"sha": "f1b5c4d16be974ad7a9e13a0ae57efa64f488fdd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 273, "deletions": 8, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -64,7 +64,7 @@ use codemap::{span, BytePos, spanned, mk_sp};\n use codemap;\n use parse::attr::parser_attr;\n use parse::classify;\n-use parse::common::{seq_sep_none};\n+use parse::common::{SeqSep, seq_sep_none};\n use parse::common::{seq_sep_trailing_disallowed, seq_sep_trailing_allowed};\n use parse::lexer::reader;\n use parse::lexer::TokenAndSpan;\n@@ -83,8 +83,12 @@ use parse::obsolete::{ObsoleteLifetimeNotation, ObsoleteConstManagedPointer};\n use parse::obsolete::{ObsoletePurity, ObsoleteStaticMethod};\n use parse::obsolete::{ObsoleteConstItem, ObsoleteFixedLengthVectorType};\n use parse::obsolete::{ObsoleteNamedExternModule, ObsoleteMultipleLocalDecl};\n-use parse::token::{can_begin_expr, get_ident_interner, ident_to_str, is_ident, is_ident_or_path};\n-use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents, token_to_binop};\n+use parse::obsolete::{ObsoleteMutWithMultipleBindings};\n+use parse::obsolete::{ObsoletePatternCopyKeyword, ParserObsoleteMethods};\n+use parse::token::{can_begin_expr, get_ident_interner, ident_to_str, is_ident};\n+use parse::token::{is_ident_or_path};\n+use parse::token::{is_plain_ident, INTERPOLATED, keywords, special_idents};\n+use parse::token::{token_to_binop};\n use parse::token;\n use parse::{new_sub_parser_from_file, next_node_id, ParseSess};\n use opt_vec;\n@@ -270,6 +274,253 @@ impl Drop for Parser {\n }\n \n impl Parser {\n+    // convert a token to a string using self's reader\n+    pub fn token_to_str(&self, token: &token::Token) -> ~str {\n+        token::to_str(get_ident_interner(), token)\n+    }\n+\n+    // convert the current token to a string using self's reader\n+    pub fn this_token_to_str(&self) -> ~str {\n+        self.token_to_str(self.token)\n+    }\n+\n+    pub fn unexpected_last(&self, t: &token::Token) -> ! {\n+        self.span_fatal(\n+            *self.last_span,\n+            fmt!(\n+                \"unexpected token: `%s`\",\n+                self.token_to_str(t)\n+            )\n+        );\n+    }\n+\n+    pub fn unexpected(&self) -> ! {\n+        self.fatal(\n+            fmt!(\n+                \"unexpected token: `%s`\",\n+                self.this_token_to_str()\n+            )\n+        );\n+    }\n+\n+    // expect and consume the token t. Signal an error if\n+    // the next token is not t.\n+    pub fn expect(&self, t: &token::Token) {\n+        if *self.token == *t {\n+            self.bump();\n+        } else {\n+            self.fatal(\n+                fmt!(\n+                    \"expected `%s` but found `%s`\",\n+                    self.token_to_str(t),\n+                    self.this_token_to_str()\n+                )\n+            )\n+        }\n+    }\n+\n+    pub fn parse_ident(&self) -> ast::ident {\n+        self.check_strict_keywords();\n+        self.check_reserved_keywords();\n+        match *self.token {\n+            token::IDENT(i, _) => {\n+                self.bump();\n+                i\n+            }\n+            token::INTERPOLATED(token::nt_ident(*)) => {\n+                self.bug(\"ident interpolation not converted to real token\");\n+            }\n+            _ => {\n+                self.fatal(\n+                    fmt!(\n+                        \"expected ident, found `%s`\",\n+                        self.this_token_to_str()\n+                    )\n+                );\n+            }\n+        }\n+    }\n+\n+    pub fn parse_path_list_ident(&self) -> ast::path_list_ident {\n+        let lo = self.span.lo;\n+        let ident = self.parse_ident();\n+        let hi = self.last_span.hi;\n+        spanned(lo, hi, ast::path_list_ident_ { name: ident,\n+                                                id: self.get_id() })\n+    }\n+\n+    // consume token 'tok' if it exists. Returns true if the given\n+    // token was present, false otherwise.\n+    pub fn eat(&self, tok: &token::Token) -> bool {\n+        return if *self.token == *tok { self.bump(); true } else { false };\n+    }\n+\n+    pub fn is_keyword(&self, kw: keywords::Keyword) -> bool {\n+        token::is_keyword(kw, self.token)\n+    }\n+\n+    // if the next token is the given keyword, eat it and return\n+    // true. Otherwise, return false.\n+    pub fn eat_keyword(&self, kw: keywords::Keyword) -> bool {\n+        let is_kw = match *self.token {\n+            token::IDENT(sid, false) => kw.to_ident().name == sid.name,\n+            _ => false\n+        };\n+        if is_kw { self.bump() }\n+        is_kw\n+    }\n+\n+    // if the given word is not a keyword, signal an error.\n+    // if the next token is not the given word, signal an error.\n+    // otherwise, eat it.\n+    pub fn expect_keyword(&self, kw: keywords::Keyword) {\n+        if !self.eat_keyword(kw) {\n+            self.fatal(\n+                fmt!(\n+                    \"expected `%s`, found `%s`\",\n+                    self.id_to_str(kw.to_ident()).to_str(),\n+                    self.this_token_to_str()\n+                )\n+            );\n+        }\n+    }\n+\n+    // signal an error if the given string is a strict keyword\n+    pub fn check_strict_keywords(&self) {\n+        if token::is_strict_keyword(self.token) {\n+            self.span_err(*self.last_span,\n+                          fmt!(\"found `%s` in ident position\", self.this_token_to_str()));\n+        }\n+    }\n+\n+    // signal an error if the current token is a reserved keyword\n+    pub fn check_reserved_keywords(&self) {\n+        if token::is_reserved_keyword(self.token) {\n+            self.fatal(fmt!(\"`%s` is a reserved keyword\", self.this_token_to_str()));\n+        }\n+    }\n+\n+    // expect and consume a GT. if a >> is seen, replace it\n+    // with a single > and continue. If a GT is not seen,\n+    // signal an error.\n+    pub fn expect_gt(&self) {\n+        if *self.token == token::GT {\n+            self.bump();\n+        } else if *self.token == token::BINOP(token::SHR) {\n+            self.replace_token(\n+                token::GT,\n+                self.span.lo + BytePos(1u),\n+                self.span.hi\n+            );\n+        } else {\n+            let mut s: ~str = ~\"expected `\";\n+            s.push_str(self.token_to_str(&token::GT));\n+            s.push_str(\"`, found `\");\n+            s.push_str(self.this_token_to_str());\n+            s.push_str(\"`\");\n+            self.fatal(s);\n+        }\n+    }\n+\n+    // parse a sequence bracketed by '<' and '>', stopping\n+    // before the '>'.\n+    pub fn parse_seq_to_before_gt<T: Copy>(&self,\n+                                           sep: Option<token::Token>,\n+                                           f: &fn(&Parser) -> T)\n+                                           -> OptVec<T> {\n+        let mut first = true;\n+        let mut v = opt_vec::Empty;\n+        while *self.token != token::GT\n+            && *self.token != token::BINOP(token::SHR) {\n+            match sep {\n+              Some(ref t) => {\n+                if first { first = false; }\n+                else { self.expect(t); }\n+              }\n+              _ => ()\n+            }\n+            v.push(f(self));\n+        }\n+        return v;\n+    }\n+\n+    pub fn parse_seq_to_gt<T: Copy>(&self,\n+                                    sep: Option<token::Token>,\n+                                    f: &fn(&Parser) -> T)\n+                                    -> OptVec<T> {\n+        let v = self.parse_seq_to_before_gt(sep, f);\n+        self.expect_gt();\n+        return v;\n+    }\n+\n+    // parse a sequence, including the closing delimiter. The function\n+    // f must consume tokens until reaching the next separator or\n+    // closing bracket.\n+    pub fn parse_seq_to_end<T: Copy>(&self,\n+                                     ket: &token::Token,\n+                                     sep: SeqSep,\n+                                     f: &fn(&Parser) -> T)\n+                                     -> ~[T] {\n+        let val = self.parse_seq_to_before_end(ket, sep, f);\n+        self.bump();\n+        val\n+    }\n+\n+    // parse a sequence, not including the closing delimiter. The function\n+    // f must consume tokens until reaching the next separator or\n+    // closing bracket.\n+    pub fn parse_seq_to_before_end<T: Copy>(&self,\n+                                            ket: &token::Token,\n+                                            sep: SeqSep,\n+                                            f: &fn(&Parser) -> T)\n+                                            -> ~[T] {\n+        let mut first: bool = true;\n+        let mut v: ~[T] = ~[];\n+        while *self.token != *ket {\n+            match sep.sep {\n+              Some(ref t) => {\n+                if first { first = false; }\n+                else { self.expect(t); }\n+              }\n+              _ => ()\n+            }\n+            if sep.trailing_sep_allowed && *self.token == *ket { break; }\n+            v.push(f(self));\n+        }\n+        return v;\n+    }\n+\n+    // parse a sequence, including the closing delimiter. The function\n+    // f must consume tokens until reaching the next separator or\n+    // closing bracket.\n+    pub fn parse_unspanned_seq<T: Copy>(&self,\n+                                        bra: &token::Token,\n+                                        ket: &token::Token,\n+                                        sep: SeqSep,\n+                                        f: &fn(&Parser) -> T)\n+                                        -> ~[T] {\n+        self.expect(bra);\n+        let result = self.parse_seq_to_before_end(ket, sep, f);\n+        self.bump();\n+        result\n+    }\n+\n+    // NB: Do not use this function unless you actually plan to place the\n+    // spanned list in the AST.\n+    pub fn parse_seq<T: Copy>(&self,\n+                              bra: &token::Token,\n+                              ket: &token::Token,\n+                              sep: SeqSep,\n+                              f: &fn(&Parser) -> T)\n+                              -> spanned<~[T]> {\n+        let lo = self.span.lo;\n+        self.expect(bra);\n+        let result = self.parse_seq_to_before_end(ket, sep, f);\n+        let hi = self.span.hi;\n+        self.bump();\n+        spanned(lo, hi, result)\n+    }\n+\n     // advance the parser by one token\n     pub fn bump(&self) {\n         *self.last_span = copy *self.span;\n@@ -821,6 +1072,11 @@ impl Parser {\n             self.parse_arg_mode();\n             is_mutbl = self.eat_keyword(keywords::Mut);\n             let pat = self.parse_pat();\n+\n+            if is_mutbl && !ast_util::pat_is_ident(pat) {\n+                self.obsolete(*self.span, ObsoleteMutWithMultipleBindings)\n+            }\n+\n             self.expect(&token::COLON);\n             pat\n         } else {\n@@ -2437,8 +2693,7 @@ impl Parser {\n                 pat = self.parse_pat_ident(bind_by_ref(mutbl));\n             } else if self.eat_keyword(keywords::Copy) {\n                 // parse copy pat\n-                self.warn(\"copy keyword in patterns no longer has any effect, \\\n-                           remove it\");\n+                self.obsolete(*self.span, ObsoletePatternCopyKeyword);\n                 pat = self.parse_pat_ident(bind_infer);\n             } else {\n                 let can_be_enum_or_struct;\n@@ -2560,6 +2815,11 @@ impl Parser {\n     fn parse_local(&self, is_mutbl: bool) -> @local {\n         let lo = self.span.lo;\n         let pat = self.parse_pat();\n+\n+        if is_mutbl && !ast_util::pat_is_ident(pat) {\n+            self.obsolete(*self.span, ObsoleteMutWithMultipleBindings)\n+        }\n+\n         let mut ty = @Ty {\n             id: self.get_id(),\n             node: ty_infer,\n@@ -4244,8 +4504,12 @@ impl Parser {\n         // FAILURE TO PARSE ITEM\n         if visibility != inherited {\n             let mut s = ~\"unmatched visibility `\";\n-            s += if visibility == public { \"pub\" } else { \"priv\" };\n-            s += \"`\";\n+            if visibility == public {\n+                s.push_str(\"pub\")\n+            } else {\n+                s.push_str(\"priv\")\n+            }\n+            s.push_char('`');\n             self.span_fatal(*self.last_span, s);\n         }\n         return iovi_none;\n@@ -4420,7 +4684,8 @@ impl Parser {\n         let mut attrs = vec::append(first_item_attrs,\n                                     self.parse_outer_attributes());\n         // First, parse view items.\n-        let mut (view_items, items) = (~[], ~[]);\n+        let mut view_items = ~[];\n+        let mut items = ~[];\n         let mut done = false;\n         // I think this code would probably read better as a single\n         // loop with a mutable three-state-variable (for extern mods,"}, {"sha": "793626f0e1808a369d7afaef0522ac4aa779f1f7", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -178,14 +178,14 @@ pub fn to_str(in: @ident_interner, t: &Token) -> ~str {\n       LIT_FLOAT(ref s, t) => {\n         let mut body = ident_to_str(s).to_owned();\n         if body.ends_with(\".\") {\n-            body += \"0\";  // `10.f` is not a float literal\n+            body.push_char('0');  // `10.f` is not a float literal\n         }\n         body + ast_util::float_ty_to_str(t)\n       }\n       LIT_FLOAT_UNSUFFIXED(ref s) => {\n         let mut body = ident_to_str(s).to_owned();\n         if body.ends_with(\".\") {\n-            body += \"0\";  // `10.f` is not a float literal\n+            body.push_char('0');  // `10.f` is not a float literal\n         }\n         body\n       }"}, {"sha": "7cd3faf9a90533cba4b9fcbd81b570c23ee7f237", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -122,12 +122,14 @@ pub fn buf_str(toks: ~[token], szs: ~[int], left: uint, right: uint,\n     let mut s = ~\"[\";\n     while i != right && L != 0u {\n         L -= 1u;\n-        if i != left { s += \", \"; }\n-        s += fmt!(\"%d=%s\", szs[i], tok_str(toks[i]));\n+        if i != left {\n+            s.push_str(\", \");\n+        }\n+        s.push_str(fmt!(\"%d=%s\", szs[i], tok_str(toks[i])));\n         i += 1u;\n         i %= n;\n     }\n-    s += \"]\";\n+    s.push_char(']');\n     return s;\n }\n "}, {"sha": "3cdc4fd0fa106f8d35aabf1a9787c9d84baf5f75", "filename": "src/libsyntax/util/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Futil%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Flibsyntax%2Futil%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Finterner.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -21,7 +21,7 @@ pub struct Interner<T> {\n }\n \n // when traits can extend traits, we should extend index<uint,T> to get []\n-impl<T:Eq + IterBytes + Hash + Const + Copy> Interner<T> {\n+impl<T:Eq + IterBytes + Hash + Freeze + Copy> Interner<T> {\n     pub fn new() -> Interner<T> {\n         Interner {\n             map: @mut HashMap::new(),"}, {"sha": "beca0adbe3c5b4902bfaea002d14739c047b2837", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -11,7 +11,7 @@\n use std::comm::*;\n use std::task;\n \n-pub fn foo<T:Owned + Copy>(x: T) -> Port<T> {\n+pub fn foo<T:Send + Copy>(x: T) -> Port<T> {\n     let (p, c) = stream();\n     do task::spawn() {\n         c.send(copy x);"}, {"sha": "8c491a4dfc83b1eb07ce73bf8d8755ecf57c340d", "filename": "src/test/auxiliary/issue-2526.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fauxiliary%2Fissue-2526.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-2526.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -20,17 +20,17 @@ struct arc_destruct<T> {\n }\n \n #[unsafe_destructor]\n-impl<T:Const> Drop for arc_destruct<T> {\n+impl<T:Freeze> Drop for arc_destruct<T> {\n     fn drop(&self) {}\n }\n \n-fn arc_destruct<T:Const>(data: int) -> arc_destruct<T> {\n+fn arc_destruct<T:Freeze>(data: int) -> arc_destruct<T> {\n     arc_destruct {\n         _data: data\n     }\n }\n \n-fn arc<T:Const>(_data: T) -> arc_destruct<T> {\n+fn arc<T:Freeze>(_data: T) -> arc_destruct<T> {\n     arc_destruct(0)\n }\n "}, {"sha": "c4d89a698c1abecf6d310f61957470d58f40fff3", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -87,9 +87,8 @@ fn vec_plus() {\n     while i < 1500 {\n         let rv = vec::from_elem(r.gen_uint_range(0, i + 1), i);\n         if r.gen() {\n-            v += rv;\n-        }\n-        else {\n+            v.push_all_move(rv);\n+        } else {\n             v = rv + v;\n         }\n         i += 1;"}, {"sha": "1d32a78303a8f6ca831587f2f8dd65d20e75dd3f", "filename": "src/test/bench/pingpong.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fpingpong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fpingpong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fpingpong.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -82,7 +82,7 @@ endpoint. The send endpoint is returned to the caller and the receive\n endpoint is passed to the new task.\n \n */\n-pub fn spawn_service<T:Owned,Tb:Owned>(\n+pub fn spawn_service<T:Send,Tb:Send>(\n             init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                                   SendPacketBuffered<T, Tb>),\n             service: ~fn(v: RecvPacketBuffered<T, Tb>))\n@@ -103,7 +103,7 @@ pub fn spawn_service<T:Owned,Tb:Owned>(\n receive state.\n \n */\n-pub fn spawn_service_recv<T:Owned,Tb:Owned>(\n+pub fn spawn_service_recv<T:Send,Tb:Send>(\n         init: extern fn() -> (SendPacketBuffered<T, Tb>,\n                               RecvPacketBuffered<T, Tb>),\n         service: ~fn(v: SendPacketBuffered<T, Tb>))\n@@ -120,7 +120,7 @@ pub fn spawn_service_recv<T:Owned,Tb:Owned>(\n     client\n }\n \n-fn switch<T:Owned,Tb:Owned,U>(endp: std::pipes::RecvPacketBuffered<T, Tb>,\n+fn switch<T:Send,Tb:Send,U>(endp: std::pipes::RecvPacketBuffered<T, Tb>,\n                               f: &fn(v: Option<T>) -> U)\n                               -> U {\n     f(std::pipes::try_recv(endp))"}, {"sha": "49a3a3ec5d7d39801df461ea4595ae7816956573", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -50,8 +50,8 @@ fn show_color(cc: color) -> ~str {\n fn show_color_list(set: ~[color]) -> ~str {\n     let mut out = ~\"\";\n     for set.iter().advance |col| {\n-        out += \" \";\n-        out += show_color(*col);\n+        out.push_char(' ');\n+        out.push_str(show_color(*col));\n     }\n     return out;\n }"}, {"sha": "da8d65a1dcbab449ba3b98fca941ba240dd2d992", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -47,7 +47,7 @@ fn make_cumulative(aa: ~[AminoAcids]) -> ~[AminoAcids] {\n     let mut ans: ~[AminoAcids] = ~[];\n     for aa.iter().advance |a| {\n         cp += a.prob;\n-        ans += [AminoAcids {ch: a.ch, prob: cp}];\n+        ans.push(AminoAcids {ch: a.ch, prob: cp});\n     }\n     ans\n }"}, {"sha": "d26fe80e8a124f4c815a4ce73c83828dfe5783e0", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -70,7 +70,7 @@ fn sort_and_fmt(mm: &HashMap<~[u8], uint>, total: uint) -> ~str {\n            let b = str::raw::from_bytes(k);\n            // FIXME: #4318 Instead of to_ascii and to_str_ascii, could use\n            // to_ascii_consume and to_str_consume to not do a unnecessary copy.\n-           buffer += (fmt!(\"%s %0.3f\\n\", b.to_ascii().to_upper().to_str_ascii(), v));\n+           buffer.push_str(fmt!(\"%s %0.3f\\n\", b.to_ascii().to_upper().to_str_ascii(), v));\n        }\n    }\n "}, {"sha": "b79ecd03c0c68b685021dc62fc44b535658880fc", "filename": "src/test/bench/shootout-mandelbrot.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-mandelbrot.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -23,7 +23,10 @@ fn main() {\n         for range(0, h) |y| {\n             let y = y as f64;\n             for range(0, w) |x| {\n-                let mut (Zr, Zi, Tr, Ti) = (0f64, 0f64, 0f64, 0f64);\n+                let mut Zr = 0f64;\n+                let mut Zi = 0f64;\n+                let mut Tr = 0f64;\n+                let mut Ti = 0f64;\n                 let Cr = 2.0 * (x as f64) / (w as f64) - 1.5;\n                 let Ci = 2.0 * (y as f64) / (h as f64) - 1.0;\n "}, {"sha": "97168de5d43ec4a77dd826d5059c764f890e4e4b", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -13,7 +13,9 @@\n use std::os;\n \n fn start(n_tasks: int, token: int) {\n-    let mut (p, ch1) = stream();\n+    let (p, ch1) = stream();\n+    let mut p = p;\n+    let mut ch1 = ch1;\n     ch1.send(token);\n     //  XXX could not get this to work with a range closure\n     let mut i = 2;"}, {"sha": "2396d6efc5cc1a924c1911ee43cd65cf1c6e6205", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -103,7 +103,9 @@ impl Sudoku {\n         for u8::range(0u8, 9u8) |row| {\n             for u8::range(0u8, 9u8) |col| {\n                 let color = self.grid[row][col];\n-                if color == 0u8 { work += [(row, col)]; }\n+                if color == 0u8 {\n+                    work.push((row, col));\n+                }\n             }\n         }\n "}, {"sha": "0c9220d18ab760949e35fa5d79a31aab960def88", "filename": "src/test/compile-fail/closure-bounds-subtype.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-subtype.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -5,35 +5,35 @@ fn take_any(_: &fn:()) {\n fn take_copyable(_: &fn:Copy()) {\n }\n \n-fn take_copyable_owned(_: &fn:Copy+Owned()) {\n+fn take_copyable_owned(_: &fn:Copy+Send()) {\n }\n \n-fn take_const_owned(_: &fn:Const+Owned()) {\n+fn take_const_owned(_: &fn:Freeze+Send()) {\n }\n \n fn give_any(f: &fn:()) {\n     take_any(f);\n     take_copyable(f); //~ ERROR expected bounds `Copy` but found no bounds\n-    take_copyable_owned(f); //~ ERROR expected bounds `Copy+Owned` but found no bounds\n+    take_copyable_owned(f); //~ ERROR expected bounds `Copy+Send` but found no bounds\n }\n \n fn give_copyable(f: &fn:Copy()) {\n     take_any(f);\n     take_copyable(f);\n-    take_copyable_owned(f); //~ ERROR expected bounds `Copy+Owned` but found bounds `Copy`\n+    take_copyable_owned(f); //~ ERROR expected bounds `Copy+Send` but found bounds `Copy`\n }\n \n-fn give_owned(f: &fn:Owned()) {\n+fn give_owned(f: &fn:Send()) {\n     take_any(f);\n-    take_copyable(f); //~ ERROR expected bounds `Copy` but found bounds `Owned`\n-    take_copyable_owned(f); //~ ERROR expected bounds `Copy+Owned` but found bounds `Owned`\n+    take_copyable(f); //~ ERROR expected bounds `Copy` but found bounds `Send`\n+    take_copyable_owned(f); //~ ERROR expected bounds `Copy+Send` but found bounds `Send`\n }\n \n-fn give_copyable_owned(f: &fn:Copy+Owned()) {\n+fn give_copyable_owned(f: &fn:Copy+Send()) {\n     take_any(f);\n     take_copyable(f);\n     take_copyable_owned(f);\n-    take_const_owned(f); //~ ERROR expected bounds `Owned+Const` but found bounds `Copy+Owned`\n+    take_const_owned(f); //~ ERROR expected bounds `Send+Freeze` but found bounds `Copy+Send`\n }\n \n fn main() {}"}, {"sha": "c6ce4d04e10866951d30c17fadb8c4dfefb1e56b", "filename": "src/test/compile-fail/impl-duplicate-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-duplicate-methods.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -11,7 +11,7 @@\n struct Foo;\n impl Foo {\n     fn orange(&self){}\n-    fn orange(&self){}   //~ ERROR error: duplicate definition of method `orange`\n+    fn orange(&self){}   //~ ERROR error: duplicate definition of value `orange`\n }\n \n fn main() {}"}, {"sha": "b5a5eed6a35a21ba723fbb9f58ebc1806ffbd7bd", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -15,7 +15,7 @@ trait vec_monad<A> {\n impl<A> vec_monad<A> for ~[A] {\n     fn bind<B>(&self, f: &fn(A) -> ~[B]) {\n         let mut r = fail!();\n-        for self.iter().advance |elt| { r += f(*elt); }\n+        for self.iter().advance |elt| { r = r + f(*elt); }\n         //~^ WARNING unreachable expression\n         //~^^ ERROR the type of this value must be known\n    }"}, {"sha": "531d4eab53578a4657f58241067be0ebc6d96334", "filename": "src/test/compile-fail/issue-2611-4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2611-4.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -20,7 +20,7 @@ struct E {\n }\n \n impl A for E {\n-  fn b<F:Copy + Const,G>(_x: F) -> F { fail!() } //~ ERROR type parameter 0 requires `Const`\n+  fn b<F:Copy + Freeze,G>(_x: F) -> F { fail!() } //~ ERROR type parameter 0 requires `Freeze`\n }\n \n fn main() {}"}, {"sha": "c5d13c81b7c5928c6aae80adc9967028f2907fa3", "filename": "src/test/compile-fail/issue-2766-a.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2766-a.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -9,12 +9,12 @@\n // except according to those terms.\n \n pub mod stream {\n-    pub enum Stream<T:Owned> { send(T, ::stream::server::Stream<T>), }\n+    pub enum Stream<T:Send> { send(T, ::stream::server::Stream<T>), }\n     pub mod server {\n         use std::option;\n         use std::pipes;\n \n-        impl<T:Owned> Stream<T> {\n+        impl<T:Send> Stream<T> {\n             pub fn recv() -> extern fn(v: Stream<T>) -> ::stream::Stream<T> {\n               // resolve really should report just one error here.\n               // Change the test case when it changes.\n@@ -28,7 +28,7 @@ pub mod stream {\n             }\n         }\n \n-        pub type Stream<T:Owned> = pipes::RecvPacket<::stream::Stream<T>>;\n+        pub type Stream<T:Send> = pipes::RecvPacket<::stream::Stream<T>>;\n     }\n }\n "}, {"sha": "180f13d03719529ce41a74f5116be50658d35b85", "filename": "src/test/compile-fail/issue-3177-mutable-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fissue-3177-mutable-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fissue-3177-mutable-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3177-mutable-struct.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -10,7 +10,7 @@\n \n // xfail-test\n // error-pattern: instantiating a type parameter with an incompatible type\n-struct S<T:Const> {\n+struct S<T:Freeze> {\n     s: T,\n     cant_nest: ()\n }"}, {"sha": "07adc3d81e5f3a8a8324bf9d36d0814ef6c139c7", "filename": "src/test/compile-fail/kindck-destructor-owned.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-destructor-owned.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -2,7 +2,7 @@ struct Foo {\n     f: @mut int,\n }\n \n-impl Drop for Foo { //~ ERROR cannot implement a destructor on a struct that is not Owned\n+impl Drop for Foo { //~ ERROR cannot implement a destructor on a structure that does not satisfy Send\n     fn drop(&self) {\n         *self.f = 10;\n     }"}, {"sha": "99057ba940c56dfea151a600533c9647f49e7c3a", "filename": "src/test/compile-fail/kindck-nonsendable-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-nonsendable-1.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -12,7 +12,7 @@ fn foo(_x: @uint) {}\n \n fn main() {\n     let x = @3u;\n-    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Owned`\n-    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Owned`\n-    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Owned`\n+    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Send`\n+    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Send`\n+    let _: ~fn() = || foo(x); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "72555d7e85119ca71c146dcbcc1558cf9fd61966", "filename": "src/test/compile-fail/liveness-use-after-send.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-use-after-send.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn send<T:Owned>(ch: _chan<T>, data: T) {\n+fn send<T:Send>(ch: _chan<T>, data: T) {\n     debug!(ch);\n     debug!(data);\n     fail!();"}, {"sha": "db2172b2e570faadb2fce855e3fe5e82822be72b", "filename": "src/test/compile-fail/mutable-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fmutable-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fmutable-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-enum.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -11,9 +11,9 @@\n #[mutable]\n enum Foo { A }\n \n-fn bar<T: Const>(_: T) {}\n+fn bar<T: Freeze>(_: T) {}\n \n fn main() {\n     let x = A;\n-    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Const`\n+    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Freeze`\n }"}, {"sha": "8511bcdcd3501182964924edb563feb0c13a4de6", "filename": "src/test/compile-fail/mutable-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fmutable-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fmutable-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmutable-struct.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -11,9 +11,9 @@\n #[mutable]\n struct Foo { a: int }\n \n-fn bar<T: Const>(_: T) {}\n+fn bar<T: Freeze>(_: T) {}\n \n fn main() {\n     let x = Foo { a: 5 };\n-    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Const`\n+    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Freeze`\n }"}, {"sha": "5f0d4bc60ac01b41db7bb5e7fafa29965ba588d8", "filename": "src/test/compile-fail/no-send-res-ports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-send-res-ports.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -32,7 +32,7 @@ fn main() {\n     let x = Cell::new(foo(Port(@())));\n \n     do task::spawn {\n-        let y = x.take();   //~ ERROR does not fulfill `Owned`\n+        let y = x.take();   //~ ERROR does not fulfill `Send`\n         error!(y);\n     }\n }"}, {"sha": "20b571ad614103dedf9cf927f1ec0bd2caedd667", "filename": "src/test/compile-fail/non_owned-enum.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fnon_owned-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fnon_owned-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon_owned-enum.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[non_owned]\n+#[non_sendable]\n enum Foo { A }\n \n-fn bar<T: Owned>(_: T) {}\n+fn bar<T: Send>(_: T) {}\n \n fn main() {\n     let x = A;\n-    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Owned`\n+    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Send`\n }"}, {"sha": "d4b8e6755a1265ebabb693ef57e613c6d467392e", "filename": "src/test/compile-fail/non_owned-struct.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fnon_owned-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Fnon_owned-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon_owned-struct.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -8,12 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#[non_owned]\n+#[non_sendable]\n struct Foo { a: int }\n \n-fn bar<T: Owned>(_: T) {}\n+fn bar<T: Send>(_: T) {}\n \n fn main() {\n     let x = Foo { a: 5 };\n-    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Owned`\n+    bar(x); //~ ERROR instantiating a type parameter with an incompatible type `Foo`, which does not fulfill `Send`\n }"}, {"sha": "45cb137b08459a7dfc24b801ca9a54839dd2105d", "filename": "src/test/compile-fail/rcmut-not-const-and-not-owned.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frcmut-not-const-and-not-owned.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -10,11 +10,11 @@\n \n extern mod extra;\n \n-fn o<T: Owned>(_: &T) {}\n-fn c<T: Const>(_: &T) {}\n+fn o<T: Send>(_: &T) {}\n+fn c<T: Freeze>(_: &T) {}\n \n fn main() {\n     let x = extra::rc::rc_mut_from_owned(0);\n-    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `extra::rc::RcMut<int>`, which does not fulfill `Owned`\n-    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `extra::rc::RcMut<int>`, which does not fulfill `Const`\n+    o(&x); //~ ERROR instantiating a type parameter with an incompatible type `extra::rc::RcMut<int>`, which does not fulfill `Send`\n+    c(&x); //~ ERROR instantiating a type parameter with an incompatible type `extra::rc::RcMut<int>`, which does not fulfill `Freeze`\n }"}, {"sha": "a96da398f5a1195dd27c9455619d561681df0523", "filename": "src/test/compile-fail/trait-bounds-cant-coerce.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-cant-coerce.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -11,14 +11,14 @@\n trait Foo {\n }\n \n-fn a(_x: ~Foo:Owned) {\n+fn a(_x: ~Foo:Send) {\n }\n \n-fn b(_x: ~Foo:Owned+Copy) {\n+fn b(_x: ~Foo:Send+Copy) {\n }\n \n-fn c(x: ~Foo:Const+Owned) {\n-    b(x); //~ ERROR expected bounds `Copy+Owned`\n+fn c(x: ~Foo:Freeze+Send) {\n+    b(x); //~ ERROR expected bounds `Copy+Send`\n }\n \n fn d(x: ~Foo:) {"}, {"sha": "d7c98ec4e9d242bc3ac556c5ddbeebc872e6dd90", "filename": "src/test/compile-fail/trait-bounds-not-on-bare-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-bare-trait.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -13,7 +13,7 @@ trait Foo {\n \n // This should emit the less confusing error, not the more confusing one.\n \n-fn foo(_x: Foo:Owned) { //~ERROR reference to trait `Foo` where a type is expected\n+fn foo(_x: Foo:Send) { //~ERROR reference to trait `Foo` where a type is expected\n }\n \n fn main() { }"}, {"sha": "ebffd0303e0478d31104e42bd578c22116e0b7c1", "filename": "src/test/compile-fail/trait-bounds-not-on-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-not-on-struct.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -10,6 +10,6 @@\n \n struct Foo;\n \n-fn foo(_x: ~Foo:Owned) { } //~ ERROR kind bounds can only be used on trait types\n+fn foo(_x: ~Foo:Send) { } //~ ERROR kind bounds can only be used on trait types\n \n fn main() { }"}, {"sha": "68a0ae90014266c9de62f5cead8a392c5060bc66", "filename": "src/test/compile-fail/trait-bounds-sugar.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-bounds-sugar.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -13,7 +13,7 @@\n trait Foo {\n }\n \n-fn a(_x: ~Foo) { // should be same as ~Foo:Owned\n+fn a(_x: ~Foo) { // should be same as ~Foo:Send\n }\n \n fn b(_x: @Foo) { // should be same as ~Foo:'static\n@@ -22,15 +22,15 @@ fn b(_x: @Foo) { // should be same as ~Foo:'static\n fn c(_x: &'static Foo) { // should be same as &'static Foo:'static\n }\n \n-fn d(x: ~Foo:Const) {\n-    a(x); //~ ERROR expected bounds `Owned`\n+fn d(x: ~Foo:Freeze) {\n+    a(x); //~ ERROR expected bounds `Send`\n }\n \n-fn e(x: @Foo:Const) {\n+fn e(x: @Foo:Freeze) {\n     b(x); //~ ERROR expected bounds `'static`\n }\n \n-fn f(x: &'static Foo:Const) {\n+fn f(x: &'static Foo:Freeze) {\n     c(x); //~ ERROR expected bounds `'static`\n }\n "}, {"sha": "ba8101d16ab0f170239a811f14c718abcb0ec5fe", "filename": "src/test/compile-fail/trait-duplicate-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-duplicate-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-duplicate-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-duplicate-methods.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -10,7 +10,7 @@\n \n trait Foo {\n     fn orange(&self);\n-    fn orange(&self);   //~ ERROR error: duplicate definition of method `orange`\n+    fn orange(&self);   //~ ERROR error: duplicate definition of value `orange`\n }\n \n fn main() {}"}, {"sha": "c44887593ab3c425956eee07bf010612501ae336", "filename": "src/test/compile-fail/trait-or-new-type-instead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-or-new-type-instead.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: implement a trait or new type instead\n+// error-pattern: found value name used as a type\n impl<T> Option<T> {\n     pub fn foo(&self) { }\n }"}, {"sha": "d51df4979e35246d536b18e06c85f47d9e36bc23", "filename": "src/test/compile-fail/unique-unique-kind.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-unique-kind.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn f<T:Owned>(_i: T) {\n+fn f<T:Send>(_i: T) {\n }\n \n fn main() {\n     let i = ~@100;\n-    f(i); //~ ERROR does not fulfill `Owned`\n+    f(i); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "de089dcf914b9676a1f22cf4f3918776f9998511", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -27,6 +27,6 @@ fn foo(i:int, j: @~str) -> foo {\n \n fn main() {\n   let cat = ~\"kitty\";\n-    let (_, ch) = comm::stream(); //~ ERROR does not fulfill `Owned`\n-  ch.send(foo(42, @(cat))); //~ ERROR does not fulfill `Owned`\n+    let (_, ch) = comm::stream(); //~ ERROR does not fulfill `Send`\n+  ch.send(foo(42, @(cat))); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "992747187f6353e476451517af9b6b9301847fe7", "filename": "src/test/run-fail/bug-811.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-fail%2Fbug-811.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-fail%2Fbug-811.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fbug-811.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -19,6 +19,6 @@ struct chan_t<T> {\n     port: port_id,\n }\n \n-fn send<T:Owned>(ch: chan_t<T>, data: T) { fail!(); }\n+fn send<T:Send>(ch: chan_t<T>, data: T) { fail!(); }\n \n fn main() { fail!(\"quux\"); }"}, {"sha": "caee00027883a58eb1088de5bf59e7183caca97e", "filename": "src/test/run-fail/issue-3029.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-fail%2Fissue-3029.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fissue-3029.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -10,9 +10,9 @@\n \n // error-pattern:so long\n fn main() {\n-    let x = ~[];\n+    let mut x = ~[];\n     let y = ~[3];\n     fail!(\"so long\");\n-    x += y;\n+    x.push_all_move(y);\n     ~\"good\" + ~\"bye\";\n }"}, {"sha": "24709fb297400a0d4e148cfdcbd653bddc14cb46", "filename": "src/test/run-pass/alignment-gep-tup-like-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falignment-gep-tup-like-2.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -23,7 +23,7 @@ fn make_cycle<A:Copy>(a: A) {\n     g.rec = Some(g);\n }\n \n-fn f<A:Owned + Copy,B:Owned + Copy>(a: A, b: B) -> @fn() -> (A, B) {\n+fn f<A:Send + Copy,B:Send + Copy>(a: A, b: B) -> @fn() -> (A, B) {\n     let result: @fn() -> (A, B) = || (copy a, copy b);\n     result\n }"}, {"sha": "95b0c9d79b7cb8ebd9bdc32e964b1c8f5d2b56ea", "filename": "src/test/run-pass/closure-bounds-can-capture-chan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -10,7 +10,7 @@\n \n use std::comm;\n \n-fn foo(blk: ~fn:Owned()) {\n+fn foo(blk: ~fn:Send()) {\n     blk();\n }\n "}, {"sha": "05f586f76e950302ea8ce54567874fe92d9538b0", "filename": "src/test/run-pass/const-bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fconst-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-bound.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -12,7 +12,7 @@\n // are const.\n \n \n-fn foo<T:Copy + Const>(x: T) -> T { x }\n+fn foo<T:Copy + Freeze>(x: T) -> T { x }\n \n struct F { field: int }\n "}, {"sha": "c7b64fde3fd5af2f4154eb31e719dce8e12ffc99", "filename": "src/test/run-pass/fixed-point-bind-unique.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffixed-point-bind-unique.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -10,11 +10,11 @@\n \n // xfail-fast\n \n-fn fix_help<A:'static,B:Owned>(f: extern fn(@fn(A) -> B, A) -> B, x: A) -> B {\n+fn fix_help<A:'static,B:Send>(f: extern fn(@fn(A) -> B, A) -> B, x: A) -> B {\n     return f(|a| fix_help(f, a), x);\n }\n \n-fn fix<A:'static,B:Owned>(f: extern fn(@fn(A) -> B, A) -> B) -> @fn(A) -> B {\n+fn fix<A:'static,B:Send>(f: extern fn(@fn(A) -> B, A) -> B) -> @fn(A) -> B {\n     return |a| fix_help(f, a);\n }\n "}, {"sha": "e9954be93575ca21eb346a5688fcfd94b77ebf03", "filename": "src/test/run-pass/fn-bare-spawn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-bare-spawn.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -10,7 +10,7 @@\n \n // This is what the signature to spawn should look like with bare functions\n \n-fn spawn<T:Owned>(val: T, f: extern fn(T)) {\n+fn spawn<T:Send>(val: T, f: extern fn(T)) {\n     f(val);\n }\n "}, {"sha": "815cc1bc79bcd53abbbc7936be834a9681ceaacb", "filename": "src/test/run-pass/generic-alias-unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-alias-unique.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -10,7 +10,7 @@\n \n \n \n-fn id<T:Copy + Owned>(t: T) -> T { return t; }\n+fn id<T:Copy + Send>(t: T) -> T { return t; }\n \n pub fn main() {\n     let expected = ~100;"}, {"sha": "7f6535526312a4c57173bd349d7aa093476fd86e", "filename": "src/test/run-pass/issue-2611-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fissue-2611-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fissue-2611-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611-3.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -12,7 +12,7 @@\n // than the traits require.\n \n trait A {\n-  fn b<C:Copy + Const,D>(x: C) -> C;\n+  fn b<C:Copy + Freeze,D>(x: C) -> C;\n }\n \n struct E {"}, {"sha": "14915555889d0da74d0d851f5f94da5c1ca782c1", "filename": "src/test/run-pass/issue-2718.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fissue-2718.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2718.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -39,7 +39,7 @@ pub mod pipes {\n         payload: Option<T>\n     }\n \n-    pub fn packet<T:Owned>() -> *packet<T> {\n+    pub fn packet<T:Send>() -> *packet<T> {\n         unsafe {\n             let p: *packet<T> = cast::transmute(~Stuff{\n                 state: empty,\n@@ -74,7 +74,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub fn send<T:Owned>(mut p: send_packet<T>, payload: T) {\n+    pub fn send<T:Send>(mut p: send_packet<T>, payload: T) {\n         let mut p = p.unwrap();\n         let mut p = unsafe { uniquify(p) };\n         assert!((*p).payload.is_none());\n@@ -100,7 +100,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub fn recv<T:Owned>(mut p: recv_packet<T>) -> Option<T> {\n+    pub fn recv<T:Send>(mut p: recv_packet<T>) -> Option<T> {\n         let mut p = p.unwrap();\n         let mut p = unsafe { uniquify(p) };\n         loop {\n@@ -120,7 +120,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub fn sender_terminate<T:Owned>(mut p: *packet<T>) {\n+    pub fn sender_terminate<T:Send>(mut p: *packet<T>) {\n         let mut p = unsafe { uniquify(p) };\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty | blocked => {\n@@ -137,7 +137,7 @@ pub mod pipes {\n         }\n     }\n \n-    pub fn receiver_terminate<T:Owned>(mut p: *packet<T>) {\n+    pub fn receiver_terminate<T:Send>(mut p: *packet<T>) {\n         let mut p = unsafe { uniquify(p) };\n         match swap_state_rel(&mut (*p).state, terminated) {\n           empty => {\n@@ -159,7 +159,7 @@ pub mod pipes {\n     }\n \n     #[unsafe_destructor]\n-    impl<T:Owned> Drop for send_packet<T> {\n+    impl<T:Send> Drop for send_packet<T> {\n         fn drop(&self) {\n             unsafe {\n                 if self.p != None {\n@@ -172,13 +172,13 @@ pub mod pipes {\n         }\n     }\n \n-    impl<T:Owned> send_packet<T> {\n+    impl<T:Send> send_packet<T> {\n         pub fn unwrap(&mut self) -> *packet<T> {\n             util::replace(&mut self.p, None).unwrap()\n         }\n     }\n \n-    pub fn send_packet<T:Owned>(p: *packet<T>) -> send_packet<T> {\n+    pub fn send_packet<T:Send>(p: *packet<T>) -> send_packet<T> {\n         send_packet {\n             p: Some(p)\n         }\n@@ -189,7 +189,7 @@ pub mod pipes {\n     }\n \n     #[unsafe_destructor]\n-    impl<T:Owned> Drop for recv_packet<T> {\n+    impl<T:Send> Drop for recv_packet<T> {\n         fn drop(&self) {\n             unsafe {\n                 if self.p != None {\n@@ -202,19 +202,19 @@ pub mod pipes {\n         }\n     }\n \n-    impl<T:Owned> recv_packet<T> {\n+    impl<T:Send> recv_packet<T> {\n         pub fn unwrap(&mut self) -> *packet<T> {\n             util::replace(&mut self.p, None).unwrap()\n         }\n     }\n \n-    pub fn recv_packet<T:Owned>(p: *packet<T>) -> recv_packet<T> {\n+    pub fn recv_packet<T:Send>(p: *packet<T>) -> recv_packet<T> {\n         recv_packet {\n             p: Some(p)\n         }\n     }\n \n-    pub fn entangle<T:Owned>() -> (send_packet<T>, recv_packet<T>) {\n+    pub fn entangle<T:Send>() -> (send_packet<T>, recv_packet<T>) {\n         let p = packet();\n         (send_packet(p), recv_packet(p))\n     }"}, {"sha": "b0ddccf28944b05425614f90ac9330c6c709edcd", "filename": "src/test/run-pass/issue-2834.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fissue-2834.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fissue-2834.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2834.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -12,7 +12,7 @@\n //\n \n proto! streamp (\n-    open:send<T:Owned> {\n+    open:send<T:Send> {\n         data(T) -> open<T>\n     }\n )"}, {"sha": "10a19d62bd97b97922fbcf7a78c57cc1bb519554", "filename": "src/test/run-pass/issue-2930.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fissue-2930.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2930.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n proto! stream (\n-    Stream:send<T:Owned> {\n+    Stream:send<T:Send> {\n         send(T) -> Stream<T>\n     }\n )"}, {"sha": "ab89a357d349c2172903d2bf4ec3326d684b6227", "filename": "src/test/run-pass/istr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fistr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fistr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fistr.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -44,19 +44,19 @@ fn test_heap_add() {\n \n fn test_append() {\n     let mut s = ~\"\";\n-    s += ~\"a\";\n+    s.push_str(~\"a\");\n     assert_eq!(s, ~\"a\");\n \n     let mut s = ~\"a\";\n-    s += ~\"b\";\n+    s.push_str(~\"b\");\n     debug!(s.clone());\n     assert_eq!(s, ~\"ab\");\n \n     let mut s = ~\"c\";\n-    s += ~\"offee\";\n+    s.push_str(~\"offee\");\n     assert!(s == ~\"coffee\");\n \n-    s += ~\"&tea\";\n+    s.push_str(~\"&tea\");\n     assert!(s == ~\"coffee&tea\");\n }\n "}, {"sha": "2615396653d3a7f29e27fc91641d85ba10b916d4", "filename": "src/test/run-pass/let-destruct-fresh-mem.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Flet-destruct-fresh-mem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Flet-destruct-fresh-mem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flet-destruct-fresh-mem.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -13,7 +13,9 @@ struct A { a: int }\n \n pub fn main() {\n     let u = X {x: 10, y: @A {a: 20}};\n-    let mut X {x: x, y: @A {a: a}} = u;\n+    let X {x: x, y: @A {a: a}} = u;\n+    let mut x = x;\n+    let mut a = a;\n     x = 100;\n     a = 100;\n     assert_eq!(x, 100);"}, {"sha": "d910ac9a4e77ab21645b59bd1d3cf4251a438ec6", "filename": "src/test/run-pass/liveness-move-in-loop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fliveness-move-in-loop.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -15,7 +15,7 @@ fn the_loop() {\n     loop {\n         let x = 5;\n         if x > 3 {\n-            list += ~[take(x)];\n+            list.push(take(x));\n         } else {\n             break;\n         }"}, {"sha": "5ac62bae39224f569b45766d11195934156e384e", "filename": "src/test/run-pass/match-join.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fmatch-join.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fmatch-join.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-join.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -23,7 +23,7 @@ fn foo<T>(y: Option<T>) {\n           None::<T> => x = 17,\n           _ => x = 42\n         }\n-        rs += ~[x];\n+        rs.push(x);\n     }\n     return;\n }"}, {"sha": "fe06c973dbfd815d92371c1fab6d02d83c12a1d3", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -19,7 +19,9 @@ trait vec_monad<A> {\n impl<A> vec_monad<A> for ~[A] {\n     fn bind<B:Copy>(&self, f: &fn(&A) -> ~[B]) -> ~[B] {\n         let mut r = ~[];\n-        for self.iter().advance |elt| { r += f(elt); }\n+        for self.iter().advance |elt| {\n+            r.push_all_move(f(elt));\n+        }\n         r\n     }\n }"}, {"sha": "538aedcf7c8879f27614e5a3bef6a154edf5555f", "filename": "src/test/run-pass/mutable-alias-vec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-alias-vec.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -13,7 +13,9 @@ extern mod extra;\n \n use std::vec;\n \n-fn grow(v: &mut ~[int]) { *v += ~[1]; }\n+fn grow(v: &mut ~[int]) {\n+    v.push(1);\n+}\n \n pub fn main() {\n     let mut v: ~[int] = ~[];"}, {"sha": "05aa1e7460839a0b08b4c53278e3ef6a2efa1382", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -57,7 +57,7 @@ impl cmp::Eq for Point {\n \n pub fn main() {\n     let mut p = Point {x: 10, y: 20};\n-    p += Point {x: 101, y: 102};\n+    p = p + Point {x: 101, y: 102};\n     p = p - Point {x: 100, y: 100};\n     assert_eq!(p + Point {x: 5, y: 5}, Point {x: 16, y: 27});\n     assert_eq!(-p, Point {x: -11, y: -22});"}, {"sha": "11c43b9390198a85f64a6fe2ab29ff7a947789f8", "filename": "src/test/run-pass/pipe-bank-proto.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-bank-proto.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -45,8 +45,8 @@ proto! bank (\n     }\n )\n \n-fn switch<T:Owned,U>(endp: pipes::RecvPacket<T>,\n-                     f: &fn(v: Option<T>) -> U) -> U {\n+fn switch<T:Send,U>(endp: pipes::RecvPacket<T>,\n+                    f: &fn(v: Option<T>) -> U) -> U {\n     f(pipes::try_recv(endp))\n }\n "}, {"sha": "cbc822060cec2b327c9f9ccb0455b274ed3073f0", "filename": "src/test/run-pass/pipe-peek.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fpipe-peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-peek.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -22,7 +22,9 @@ proto! oneshot (\n )\n \n pub fn main() {\n-    let mut (p, c) = oneshot::init();\n+    let (p, c) = oneshot::init();\n+    let mut p = p;\n+    let mut c = c;\n \n     assert!(!pipes::peek(&mut p));\n "}, {"sha": "36f144152f2a3357866966aecca5b4cf3a30d508", "filename": "src/test/run-pass/pipe-select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fpipe-select.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-select.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -29,12 +29,12 @@ proto! oneshot (\n )\n \n proto! stream (\n-    Stream:send<T:Owned> {\n+    Stream:send<T:Send> {\n         send(T) -> Stream<T>\n     }\n )\n \n-pub fn spawn_service<T:Owned,Tb:Owned>(\n+pub fn spawn_service<T:Send,Tb:Send>(\n             init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                                   SendPacketBuffered<T, Tb>),\n             service: ~fn(v: RecvPacketBuffered<T, Tb>))"}, {"sha": "dbf860cd040750ec8fae9998cad13284f1f58e10", "filename": "src/test/run-pass/pipe-sleep.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpipe-sleep.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -33,7 +33,7 @@ endpoint. The send endpoint is returned to the caller and the receive\n endpoint is passed to the new task.\n \n */\n-pub fn spawn_service<T:Owned,Tb:Owned>(\n+pub fn spawn_service<T:Send,Tb:Send>(\n             init: extern fn() -> (RecvPacketBuffered<T, Tb>,\n                                   SendPacketBuffered<T, Tb>),\n             service: ~fn(v: RecvPacketBuffered<T, Tb>))"}, {"sha": "4fcbc789f57b25927fd959aaad183a28d80bc9ae", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -16,7 +16,7 @@ struct Command<K, V> {\n     val: V\n }\n \n-fn cache_server<K:Owned,V:Owned>(c: Chan<Chan<Command<K, V>>>) {\n+fn cache_server<K:Send,V:Send>(c: Chan<Chan<Command<K, V>>>) {\n     let (ctrl_port, ctrl_chan) = stream();\n     c.send(ctrl_chan);\n }"}, {"sha": "d0c58b50e2cec179494520aef9d3c0fb5c2e0909", "filename": "src/test/run-pass/shadow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fshadow.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -19,7 +19,7 @@ fn foo(c: ~[int]) {\n             for c.iter().advance |i| {\n                 debug!(a);\n                 let a = 17;\n-                b += ~[a];\n+                b.push(a);\n             }\n         }\n         _ => { }"}, {"sha": "0ddc39d6b18cc7eda81e94fc6fe3936267bffa69", "filename": "src/test/run-pass/static-impl.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fstatic-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-impl.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -51,7 +51,9 @@ impl<T> vec_utils<T> for ~[T] {\n     fn iter_(&self, f: &fn(&T)) { for self.iter().advance |x| { f(x); } }\n     fn map_<U:Copy>(&self, f: &fn(&T) -> U) -> ~[U] {\n         let mut r = ~[];\n-        for self.iter().advance |elt| { r += ~[f(elt)]; }\n+        for self.iter().advance |elt| {\n+            r.push(f(elt));\n+        }\n         r\n     }\n }"}, {"sha": "556247eb4260ee62b2613ed07718501250d78595", "filename": "src/test/run-pass/str-append.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -15,7 +15,7 @@ extern mod extra;\n \n fn test1() {\n     let mut s: ~str = ~\"hello\";\n-    s += ~\"world\";\n+    s.push_str(\"world\");\n     debug!(s.clone());\n     assert_eq!(s[9], 'd' as u8);\n }"}, {"sha": "0cdf1841331a8d36fbac057fbeaf9782dec85257", "filename": "src/test/run-pass/str-growth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fstr-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fstr-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-growth.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -12,11 +12,11 @@\n \n pub fn main() {\n     let mut s = ~\"a\";\n-    s += ~\"b\";\n+    s.push_char('b');\n     assert_eq!(s[0], 'a' as u8);\n     assert_eq!(s[1], 'b' as u8);\n-    s += ~\"c\";\n-    s += ~\"d\";\n+    s.push_char('c');\n+    s.push_char('d');\n     assert_eq!(s[0], 'a' as u8);\n     assert_eq!(s[1], 'b' as u8);\n     assert_eq!(s[2], 'c' as u8);"}, {"sha": "e0d60d62bb5824798003a3f926a93b4d8433eb2b", "filename": "src/test/run-pass/trait-bounds-basic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-basic.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -14,14 +14,14 @@ trait Foo {\n fn a(_x: ~Foo:) {\n }\n \n-fn b(_x: ~Foo:Owned) {\n+fn b(_x: ~Foo:Send) {\n }\n \n-fn c(x: ~Foo:Const+Owned) {\n+fn c(x: ~Foo:Freeze+Send) {\n     a(x);\n }\n \n-fn d(x: ~Foo:Owned+Copy) {\n+fn d(x: ~Foo:Send+Copy) {\n     b(x);\n }\n "}, {"sha": "a3b2ea02db35867b966a328bd61b115e12d7d704", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // Tests that a heterogeneous list of existential types can be put inside an ARC\n-// and shared between tasks as long as all types fulfill Const+Owned.\n+// and shared between tasks as long as all types fulfill Freeze+Send.\n \n // xfail-fast\n \n@@ -64,10 +64,10 @@ fn main() {\n     let dogge1 = Dogge { bark_decibels: 100, tricks_known: 42, name: ~\"alan_turing\" };\n     let dogge2 = Dogge { bark_decibels: 55,  tricks_known: 11, name: ~\"albert_einstein\" };\n     let fishe = Goldfyshe { swim_speed: 998, name: ~\"alec_guinness\" };\n-    let arc = arc::ARC(~[~catte  as ~Pet:Const+Owned,\n-                         ~dogge1 as ~Pet:Const+Owned,\n-                         ~fishe  as ~Pet:Const+Owned,\n-                         ~dogge2 as ~Pet:Const+Owned]);\n+    let arc = arc::ARC(~[~catte  as ~Pet:Freeze+Send,\n+                         ~dogge1 as ~Pet:Freeze+Send,\n+                         ~fishe  as ~Pet:Freeze+Send,\n+                         ~dogge2 as ~Pet:Freeze+Send]);\n     let (p1,c1) = comm::stream();\n     let arc1 = cell::Cell::new(arc.clone());\n     do task::spawn { check_legs(arc1.take()); c1.send(()); }\n@@ -82,21 +82,21 @@ fn main() {\n     p3.recv();\n }\n \n-fn check_legs(arc: arc::ARC<~[~Pet:Const+Owned]>) {\n+fn check_legs(arc: arc::ARC<~[~Pet:Freeze+Send]>) {\n     let mut legs = 0;\n     for arc.get().iter().advance |pet| {\n         legs += pet.num_legs();\n     }\n     assert!(legs == 12);\n }\n-fn check_names(arc: arc::ARC<~[~Pet:Const+Owned]>) {\n+fn check_names(arc: arc::ARC<~[~Pet:Freeze+Send]>) {\n     for arc.get().iter().advance |pet| {\n         do pet.name |name| {\n             assert!(name[0] == 'a' as u8 && name[1] == 'l' as u8);\n         }\n     }\n }\n-fn check_pedigree(arc: arc::ARC<~[~Pet:Const+Owned]>) {\n+fn check_pedigree(arc: arc::ARC<~[~Pet:Freeze+Send]>) {\n     for arc.get().iter().advance |pet| {\n         assert!(pet.of_good_pedigree());\n     }"}, {"sha": "f6c119c4faeb32a7f64c7707f768b8fc76f851a1", "filename": "src/test/run-pass/trait-default-method-xc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-default-method-xc.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -44,12 +44,12 @@ fn main () {\n     let a = thing { x: 0 };\n     let b = thing { x: 1 };\n \n-    assert_eq!(0i.g(), 10);\n+    //assert_eq!(0i.g(), 10);\n     assert_eq!(a.g(), 10);\n     assert_eq!(a.h(), 10);\n \n \n-    assert_eq!(0i.thing(3.14, 1), (3.14, 1));\n+    //assert_eq!(0i.thing(3.14, 1), (3.14, 1));\n \n     assert_eq!(g(0i, 3.14, 1), (3.14, 1));\n     assert_eq!(g(false, 3.14, 1), (3.14, 1));\n@@ -59,8 +59,8 @@ fn main () {\n \n \n     // Trying out a real one\n-    assert!(12.test_neq(&10));\n-    assert!(!10.test_neq(&10));\n+    //assert!(12.test_neq(&10));\n+    //assert!(!10.test_neq(&10));\n     assert!(a.test_neq(&b));\n     assert!(!a.test_neq(&a));\n "}, {"sha": "5952afa6676b7134a7e053c1697b896afbefdecf", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -33,7 +33,7 @@ impl<T> map<T> for ~[T] {\n         let mut r = ~[];\n         // FIXME: #7355 generates bad code with Iterator\n         for std::uint::range(0, self.len()) |i| {\n-            r += ~[f(&self[i])];\n+            r.push(f(&self[i]));\n         }\n         r\n     }"}, {"sha": "216a7a939fe0546a34f5c9aa378dcfd8c85d88d7", "filename": "src/test/run-pass/type-param-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-param-constraints.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -12,7 +12,7 @@\n \n fn p_foo<T>(pinned: T) { }\n fn s_foo<T:Copy>(shared: T) { }\n-fn u_foo<T:Owned>(unique: T) { }\n+fn u_foo<T:Send>(unique: T) { }\n \n struct r {\n   i: int,"}, {"sha": "2c3424d1f06fd3db8458105c6eeebb85ae564087", "filename": "src/test/run-pass/uniq-cc-generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funiq-cc-generic.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -20,7 +20,7 @@ struct Pointy {\n     d : ~fn() -> uint,\n }\n \n-fn make_uniq_closure<A:Owned + Copy>(a: A) -> ~fn() -> uint {\n+fn make_uniq_closure<A:Send + Copy>(a: A) -> ~fn() -> uint {\n     let result: ~fn() -> uint = || ptr::to_unsafe_ptr(&a) as uint;\n     result\n }"}, {"sha": "391881deff66812e931d0449c74c928a9af13382", "filename": "src/test/run-pass/unique-kinds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Funique-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-kinds.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -12,11 +12,11 @@ use std::cmp::Eq;\n \n fn sendable() {\n \n-    fn f<T:Owned + Eq>(i: T, j: T) {\n+    fn f<T:Send + Eq>(i: T, j: T) {\n         assert_eq!(i, j);\n     }\n \n-    fn g<T:Owned + Eq>(i: T, j: T) {\n+    fn g<T:Send + Eq>(i: T, j: T) {\n         assert!(i != j);\n     }\n "}, {"sha": "c9a4c57cc9d36e55d472d4bfa76fbe04e9176c36", "filename": "src/test/run-pass/vec-growth.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fvec-growth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-growth.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -12,10 +12,10 @@\n \n pub fn main() {\n     let mut v = ~[1];\n-    v += ~[2];\n-    v += ~[3];\n-    v += ~[4];\n-    v += ~[5];\n+    v.push(2);\n+    v.push(3);\n+    v.push(4);\n+    v.push(5);\n     assert_eq!(v[0], 1);\n     assert_eq!(v[1], 2);\n     assert_eq!(v[2], 3);"}, {"sha": "503e37fcd76ea32cdb8e71bc7ac3ff0ed98d800d", "filename": "src/test/run-pass/while-prelude-drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f44b951a1ea40b61508b2d0abb3f239797f885c5/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs?ref=f44b951a1ea40b61508b2d0abb3f239797f885c5", "patch": "@@ -17,7 +17,7 @@ fn make(i: int) -> t {\n     let mut s = ~\"hello\";\n     // Ensure s is non-const.\n \n-    s += ~\"there\";\n+    s.push_str(\"there\");\n     return b(s);\n }\n "}]}