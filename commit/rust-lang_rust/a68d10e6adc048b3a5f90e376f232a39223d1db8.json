{"sha": "a68d10e6adc048b3a5f90e376f232a39223d1db8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2OGQxMGU2YWRjMDQ4YjNhNWY5MGUzNzZmMjMyYTM5MjIzZDFkYjg=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-16T05:11:47Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2014-02-18T10:55:53Z"}, "message": "std::str: safen and optimize is_utf8.\n\nThis uses a vector iterator to avoid the necessity for unsafe indexing,\nand makes this function slightly faster. Unfortunately #11751 means that\nthe iterator comes with repeated `null` checks which means the\npure-ASCII case still has room for significant improvement (and the\nother cases too, but it's most significant for just ASCII).\n\nBefore:\n\n    is_utf8_100_ascii             ... bench:       143 ns/iter (+/- 6)\n    is_utf8_100_multibyte         ... bench:       134 ns/iter (+/- 4)\n\nAfter:\n\n    is_utf8_100_ascii             ... bench:       123 ns/iter (+/- 4)\n    is_utf8_100_multibyte         ... bench:       115 ns/iter (+/- 5)", "tree": {"sha": "9c97b3429fd7e79aa88c7ecaaa51151475ac0253", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c97b3429fd7e79aa88c7ecaaa51151475ac0253"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a68d10e6adc048b3a5f90e376f232a39223d1db8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a68d10e6adc048b3a5f90e376f232a39223d1db8", "html_url": "https://github.com/rust-lang/rust/commit/a68d10e6adc048b3a5f90e376f232a39223d1db8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a68d10e6adc048b3a5f90e376f232a39223d1db8/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8489069b43191c5298f17430933b3b88fb79c3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8489069b43191c5298f17430933b3b88fb79c3c", "html_url": "https://github.com/rust-lang/rust/commit/c8489069b43191c5298f17430933b3b88fb79c3c"}], "stats": {"total": 79, "additions": 77, "deletions": 2}, "files": [{"sha": "570df45e08070a0360555d5c5d058cc09baa7127", "filename": "src/libstd/str.rs", "status": "modified", "additions": 77, "deletions": 2, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a68d10e6adc048b3a5f90e376f232a39223d1db8/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a68d10e6adc048b3a5f90e376f232a39223d1db8/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=a68d10e6adc048b3a5f90e376f232a39223d1db8", "patch": "@@ -731,9 +731,84 @@ pub fn eq(a: &~str, b: &~str) -> bool {\n Section: Misc\n */\n \n-/// Determines if a vector of bytes contains valid UTF-8\n+/// Walk through `iter` checking that it's a valid UTF-8 sequence,\n+/// returning `true` in that case, or, if it is invalid, `false` with\n+/// `iter` reset such that it is pointing at the first byte in the\n+/// invalid sequence.\n+#[inline(always)]\n+fn run_utf8_validation_iterator(iter: &mut vec::Items<u8>) -> bool {\n+    loop {\n+        // save the current thing we're pointing at.\n+        let old = *iter;\n+\n+        // restore the iterator we had at the start of this codepoint.\n+        macro_rules! err ( () => { {*iter = old; return false} });\n+        macro_rules! next ( () => {\n+                match iter.next() {\n+                    Some(a) => *a,\n+                    // we needed data, but there was none: error!\n+                    None => err!()\n+                }\n+            });\n+\n+        let first = match iter.next() {\n+            Some(&b) => b,\n+            // we're at the end of the iterator and a codepoint\n+            // boundary at the same time, so this string is valid.\n+            None => return true\n+        };\n+\n+        // ASCII characters are always valid, so only large\n+        // bytes need more examination.\n+        if first >= 128 {\n+            let w = utf8_char_width(first);\n+            let second = next!();\n+            // 2-byte encoding is for codepoints  \\u0080 to  \\u07ff\n+            //        first  C2 80        last DF BF\n+            // 3-byte encoding is for codepoints  \\u0800 to  \\uffff\n+            //        first  E0 A0 80     last EF BF BF\n+            //   excluding surrogates codepoints  \\ud800 to  \\udfff\n+            //               ED A0 80 to       ED BF BF\n+            // 4-byte encoding is for codepoints \\u10000 to \\u10ffff\n+            //        first  F0 90 80 80  last F4 8F BF BF\n+            //\n+            // Use the UTF-8 syntax from the RFC\n+            //\n+            // https://tools.ietf.org/html/rfc3629\n+            // UTF8-1      = %x00-7F\n+            // UTF8-2      = %xC2-DF UTF8-tail\n+            // UTF8-3      = %xE0 %xA0-BF UTF8-tail / %xE1-EC 2( UTF8-tail ) /\n+            //               %xED %x80-9F UTF8-tail / %xEE-EF 2( UTF8-tail )\n+            // UTF8-4      = %xF0 %x90-BF 2( UTF8-tail ) / %xF1-F3 3( UTF8-tail ) /\n+            //               %xF4 %x80-8F 2( UTF8-tail )\n+            match w {\n+                2 => if second & 192 != TAG_CONT_U8 {err!()},\n+                3 => {\n+                    match (first, second, next!() & 192) {\n+                        (0xE0        , 0xA0 .. 0xBF, TAG_CONT_U8) |\n+                        (0xE1 .. 0xEC, 0x80 .. 0xBF, TAG_CONT_U8) |\n+                        (0xED        , 0x80 .. 0x9F, TAG_CONT_U8) |\n+                        (0xEE .. 0xEF, 0x80 .. 0xBF, TAG_CONT_U8) => {}\n+                        _ => err!()\n+                    }\n+                }\n+                4 => {\n+                    match (first, second, next!() & 192, next!() & 192) {\n+                        (0xF0        , 0x90 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n+                        (0xF1 .. 0xF3, 0x80 .. 0xBF, TAG_CONT_U8, TAG_CONT_U8) |\n+                        (0xF4        , 0x80 .. 0x8F, TAG_CONT_U8, TAG_CONT_U8) => {}\n+                        _ => err!()\n+                    }\n+                }\n+                _ => err!()\n+            }\n+        }\n+    }\n+}\n+\n+/// Determines if a vector of bytes contains valid UTF-8.\n pub fn is_utf8(v: &[u8]) -> bool {\n-    first_non_utf8_index(v).is_none()\n+    run_utf8_validation_iterator(&mut v.iter())\n }\n \n #[inline(always)]"}]}