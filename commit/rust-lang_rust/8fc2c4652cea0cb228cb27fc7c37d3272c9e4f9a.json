{"sha": "8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmYzJjNDY1MmNlYTBjYjIyOGNiMjdmYzdjMzdkMzI3MmM5ZTRmOWE=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-16T23:10:22Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-05-11T01:14:58Z"}, "message": "regionck: Use methods on RegionCtxt instead of free functions.", "tree": {"sha": "466be6ceaa5101a3869d4f8a2236bc11b3ed075a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/466be6ceaa5101a3869d4f8a2236bc11b3ed075a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a", "html_url": "https://github.com/rust-lang/rust/commit/8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8ea24edc8b663c5acbe252936aa375f1d3a944e", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8ea24edc8b663c5acbe252936aa375f1d3a944e", "html_url": "https://github.com/rust-lang/rust/commit/f8ea24edc8b663c5acbe252936aa375f1d3a944e"}], "stats": {"total": 734, "additions": 353, "deletions": 381}, "files": [{"sha": "9d4a58aab0629de8e8cb1145c99bf3cdf97aa276", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use CrateCtxt;\n-use check::regionck::{self, Rcx};\n+use check::regionck::RegionCtxt;\n \n use hir::def_id::DefId;\n use middle::free_region::FreeRegionMap;\n@@ -274,7 +274,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'a, 'tcx>(\n /// ensuring that they do not access data nor invoke methods of\n /// values that have been previously dropped).\n ///\n-pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n+pub fn check_safety_of_destructor_if_necessary<'a, 'tcx>(rcx: &mut RegionCtxt<'a, 'tcx>,\n                                                          typ: ty::Ty<'tcx>,\n                                                          span: Span,\n                                                          scope: region::CodeExtent) {\n@@ -344,7 +344,7 @@ enum TypeContext {\n }\n \n struct DropckContext<'a, 'b: 'a, 'tcx: 'b> {\n-    rcx: &'a mut Rcx<'b, 'tcx>,\n+    rcx: &'a mut RegionCtxt<'b, 'tcx>,\n     /// types that have already been traversed\n     breadcrumbs: FnvHashSet<Ty<'tcx>>,\n     /// span for error reporting\n@@ -416,10 +416,8 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'b, 'tcx>(\n                (0..depth).map(|_| ' ').collect::<String>(),\n                ty);\n \n-        regionck::type_must_outlive(cx.rcx,\n-                                    infer::SubregionOrigin::SafeDestructor(cx.span),\n-                                    ty,\n-                                    ty::ReScope(cx.parent_scope));\n+        cx.rcx.type_must_outlive(infer::SubregionOrigin::SafeDestructor(cx.span),\n+                                 ty, ty::ReScope(cx.parent_scope));\n \n         return Ok(());\n     }"}, {"sha": "3af0a3f66e67a8ac4fba66424cb1e50c5f36b72c", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 348, "deletions": 374, "changes": 722, "blob_url": "https://github.com/rust-lang/rust/blob/8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=8fc2c4652cea0cb228cb27fc7c37d3272c9e4f9a", "patch": "@@ -114,7 +114,7 @@ macro_rules! ignore_err {\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n pub fn regionck_expr(&self, e: &hir::Expr) {\n-    let mut rcx = Rcx::new(self, RepeatingScope(e.id), e.id, Subject(e.id));\n+    let mut rcx = RegionCtxt::new(self, RepeatingScope(e.id), e.id, Subject(e.id));\n     if self.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n         rcx.visit_expr(e);\n@@ -130,7 +130,7 @@ pub fn regionck_item(&self,\n                      span: Span,\n                      wf_tys: &[Ty<'tcx>]) {\n     debug!(\"regionck_item(item.id={:?}, wf_tys={:?}\", item_id, wf_tys);\n-    let mut rcx = Rcx::new(self, RepeatingScope(item_id), item_id, Subject(item_id));\n+    let mut rcx = RegionCtxt::new(self, RepeatingScope(item_id), item_id, Subject(item_id));\n     rcx.free_region_map.relate_free_regions_from_predicates(\n         &self.infcx().parameter_environment.caller_bounds);\n     rcx.relate_free_regions(wf_tys, item_id, span);\n@@ -144,7 +144,7 @@ pub fn regionck_fn(&self,\n                    decl: &hir::FnDecl,\n                    blk: &hir::Block) {\n     debug!(\"regionck_fn(id={})\", fn_id);\n-    let mut rcx = Rcx::new(self, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n+    let mut rcx = RegionCtxt::new(self, RepeatingScope(blk.id), blk.id, Subject(fn_id));\n \n     if self.err_count_since_creation() == 0 {\n         // regionck assumes typeck succeeded\n@@ -166,7 +166,7 @@ pub fn regionck_fn(&self,\n ///////////////////////////////////////////////////////////////////////////\n // INTERNALS\n \n-pub struct Rcx<'a, 'tcx: 'a> {\n+pub struct RegionCtxt<'a, 'tcx: 'a> {\n     pub fcx: &'a FnCtxt<'a, 'tcx>,\n \n     region_bound_pairs: Vec<(ty::Region, GenericKind<'tcx>)>,\n@@ -190,19 +190,20 @@ pub struct Rcx<'a, 'tcx: 'a> {\n pub struct RepeatingScope(ast::NodeId);\n pub enum SubjectNode { Subject(ast::NodeId), None }\n \n-impl<'a, 'tcx> Rcx<'a, 'tcx> {\n+impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n     pub fn new(fcx: &'a FnCtxt<'a, 'tcx>,\n                initial_repeating_scope: RepeatingScope,\n                initial_body_id: ast::NodeId,\n-               subject: SubjectNode) -> Rcx<'a, 'tcx> {\n+               subject: SubjectNode) -> RegionCtxt<'a, 'tcx> {\n         let RepeatingScope(initial_repeating_scope) = initial_repeating_scope;\n-        Rcx { fcx: fcx,\n-              repeating_scope: initial_repeating_scope,\n-              body_id: initial_body_id,\n-              call_site_scope: None,\n-              subject: subject,\n-              region_bound_pairs: Vec::new(),\n-              free_region_map: FreeRegionMap::new(),\n+        RegionCtxt {\n+            fcx: fcx,\n+            repeating_scope: initial_repeating_scope,\n+            body_id: initial_body_id,\n+            call_site_scope: None,\n+            subject: subject,\n+            region_bound_pairs: Vec::new(),\n+            free_region_map: FreeRegionMap::new(),\n         }\n     }\n \n@@ -316,19 +317,17 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n \n         let old_body_id = self.set_body_id(body.id);\n         self.relate_free_regions(&fn_sig_tys[..], body.id, span);\n-        link_fn_args(self,\n-                     self.tcx().region_maps.node_extent(body.id),\n-                     &fn_decl.inputs[..]);\n+        self.link_fn_args(self.tcx().region_maps.node_extent(body.id),\n+                          &fn_decl.inputs[..]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n \n         let call_site_scope = self.call_site_scope.unwrap();\n         debug!(\"visit_fn_body body.id {} call_site_scope: {:?}\",\n                body.id, call_site_scope);\n-        type_of_node_must_outlive(self,\n-                                  infer::CallReturn(span),\n-                                  body.id,\n-                                  ty::ReScope(call_site_scope));\n+        self.type_of_node_must_outlive(infer::CallReturn(span),\n+                                       body.id,\n+                                       ty::ReScope(call_site_scope));\n \n         self.region_bound_pairs.truncate(old_region_bounds_pairs_len);\n \n@@ -360,7 +359,7 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n                    r_o, r_o.cause);\n             let sup_type = self.resolve_type(r_o.sup_type);\n             let origin = self.code_to_origin(r_o.cause.span, sup_type, &r_o.cause.code);\n-            type_must_outlive(self, origin, sup_type, r_o.sub_region);\n+            self.type_must_outlive(origin, sup_type, r_o.sub_region);\n         }\n \n         // Processing the region obligations should not cause the list to grow further:\n@@ -451,55 +450,9 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n         self.fcx.infcx().resolve_regions_and_report_errors(&self.free_region_map,\n                                                            subject_node_id);\n     }\n-}\n-\n-impl<'a, 'tcx, 'v> Visitor<'v> for Rcx<'a, 'tcx> {\n-    // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n-    // However, right now we run into an issue whereby some free\n-    // regions are not properly related if they appear within the\n-    // types of arguments that must be inferred. This could be\n-    // addressed by deferring the construction of the region\n-    // hierarchy, and in particular the relationships between free\n-    // regions, until regionck, as described in #3238.\n-\n-    fn visit_fn(&mut self, _fk: intravisit::FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, span: Span, id: ast::NodeId) {\n-        self.visit_fn_body(id, fd, b, span)\n-    }\n-\n-    fn visit_expr(&mut self, ex: &hir::Expr) { visit_expr(self, ex); }\n \n-    //visit_pat: visit_pat, // (..) see above\n-\n-    fn visit_arm(&mut self, a: &hir::Arm) { visit_arm(self, a); }\n-\n-    fn visit_local(&mut self, l: &hir::Local) { visit_local(self, l); }\n-\n-    fn visit_block(&mut self, b: &hir::Block) { visit_block(self, b); }\n-}\n-\n-fn visit_block(rcx: &mut Rcx, b: &hir::Block) {\n-    intravisit::walk_block(rcx, b);\n-}\n-\n-fn visit_arm(rcx: &mut Rcx, arm: &hir::Arm) {\n-    // see above\n-    for p in &arm.pats {\n-        constrain_bindings_in_pat(&p, rcx);\n-    }\n-\n-    intravisit::walk_arm(rcx, arm);\n-}\n-\n-fn visit_local(rcx: &mut Rcx, l: &hir::Local) {\n-    // see above\n-    constrain_bindings_in_pat(&l.pat, rcx);\n-    link_local(rcx, l);\n-    intravisit::walk_local(rcx, l);\n-}\n-\n-fn constrain_bindings_in_pat(pat: &hir::Pat, rcx: &mut Rcx) {\n-    let tcx = rcx.fcx.tcx();\n+fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {\n+    let tcx = self.fcx.tcx();\n     debug!(\"regionck::visit_pat(pat={:?})\", pat);\n     pat_util::pat_bindings(&tcx.def_map, pat, |_, id, span, _| {\n         // If we have a variable that contains region'd data, that\n@@ -528,27 +481,59 @@ fn constrain_bindings_in_pat(pat: &hir::Pat, rcx: &mut Rcx) {\n         let var_scope = tcx.region_maps.var_scope(id);\n \n         let origin = infer::BindingTypeIsNotValidAtDecl(span);\n-        type_of_node_must_outlive(rcx, origin, id, ty::ReScope(var_scope));\n+        self.type_of_node_must_outlive(origin, id, ty::ReScope(var_scope));\n \n-        let typ = rcx.resolve_node_type(id);\n-        dropck::check_safety_of_destructor_if_necessary(rcx, typ, span, var_scope);\n+        let typ = self.resolve_node_type(id);\n+        dropck::check_safety_of_destructor_if_necessary(self, typ, span, var_scope);\n     })\n }\n+}\n \n-fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n+impl<'a, 'tcx, 'v> Visitor<'v> for RegionCtxt<'a, 'tcx> {\n+    // (..) FIXME(#3238) should use visit_pat, not visit_arm/visit_local,\n+    // However, right now we run into an issue whereby some free\n+    // regions are not properly related if they appear within the\n+    // types of arguments that must be inferred. This could be\n+    // addressed by deferring the construction of the region\n+    // hierarchy, and in particular the relationships between free\n+    // regions, until regionck, as described in #3238.\n+\n+    fn visit_fn(&mut self, _fk: intravisit::FnKind<'v>, fd: &'v hir::FnDecl,\n+                b: &'v hir::Block, span: Span, id: ast::NodeId) {\n+        self.visit_fn_body(id, fd, b, span)\n+    }\n+\n+    //visit_pat: visit_pat, // (..) see above\n+\n+    fn visit_arm(&mut self, arm: &hir::Arm) {\n+        // see above\n+        for p in &arm.pats {\n+            self.constrain_bindings_in_pat(p);\n+        }\n+        intravisit::walk_arm(self, arm);\n+    }\n+\n+    fn visit_local(&mut self, l: &hir::Local) {\n+        // see above\n+        self.constrain_bindings_in_pat(&l.pat);\n+        self.link_local(l);\n+        intravisit::walk_local(self, l);\n+    }\n+\n+fn visit_expr(&mut self, expr: &hir::Expr) {\n     debug!(\"regionck::visit_expr(e={:?}, repeating_scope={})\",\n-           expr, rcx.repeating_scope);\n+           expr, self.repeating_scope);\n \n     // No matter what, the type of each expression must outlive the\n     // scope of that expression. This also guarantees basic WF.\n-    let expr_ty = rcx.resolve_node_type(expr.id);\n+    let expr_ty = self.resolve_node_type(expr.id);\n     // the region corresponding to this expression\n-    let expr_region = ty::ReScope(rcx.tcx().region_maps.node_extent(expr.id));\n-    type_must_outlive(rcx, infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n-                      expr_ty, expr_region);\n+    let expr_region = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n+    self.type_must_outlive(infer::ExprTypeIsNotInScope(expr_ty, expr.span),\n+                           expr_ty, expr_region);\n \n     let method_call = MethodCall::expr(expr.id);\n-    let opt_method_callee = rcx.fcx.inh.tables.borrow().method_map.get(&method_call).cloned();\n+    let opt_method_callee = self.fcx.inh.tables.borrow().method_map.get(&method_call).cloned();\n     let has_method_map = opt_method_callee.is_some();\n \n     // If we are calling a method (either explicitly or via an\n@@ -565,41 +550,40 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n                 infer::ParameterOrigin::OverloadedOperator\n         };\n \n-        substs_wf_in_scope(rcx, origin, &callee.substs, expr.span, expr_region);\n-        type_must_outlive(rcx, infer::ExprTypeIsNotInScope(callee.ty, expr.span),\n-                          callee.ty, expr_region);\n+        self.substs_wf_in_scope(origin, &callee.substs, expr.span, expr_region);\n+        self.type_must_outlive(infer::ExprTypeIsNotInScope(callee.ty, expr.span),\n+                               callee.ty, expr_region);\n     }\n \n     // Check any autoderefs or autorefs that appear.\n-    let adjustment = rcx.fcx.inh.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n+    let adjustment = self.fcx.inh.tables.borrow().adjustments.get(&expr.id).map(|a| a.clone());\n     if let Some(adjustment) = adjustment {\n         debug!(\"adjustment={:?}\", adjustment);\n         match adjustment {\n             adjustment::AdjustDerefRef(adjustment::AutoDerefRef {\n                 autoderefs, ref autoref, ..\n             }) => {\n-                let expr_ty = rcx.resolve_node_type(expr.id);\n-                constrain_autoderefs(rcx, expr, autoderefs, expr_ty);\n+                let expr_ty = self.resolve_node_type(expr.id);\n+                self.constrain_autoderefs(expr, autoderefs, expr_ty);\n                 if let Some(ref autoref) = *autoref {\n-                    link_autoref(rcx, expr, autoderefs, autoref);\n+                    self.link_autoref(expr, autoderefs, autoref);\n \n                     // Require that the resulting region encompasses\n                     // the current node.\n                     //\n                     // FIXME(#6268) remove to support nested method calls\n-                    type_of_node_must_outlive(\n-                        rcx, infer::AutoBorrow(expr.span),\n-                        expr.id, expr_region);\n+                    self.type_of_node_must_outlive(infer::AutoBorrow(expr.span),\n+                                                   expr.id, expr_region);\n                 }\n             }\n             /*\n             adjustment::AutoObject(_, ref bounds, _, _) => {\n                 // Determine if we are casting `expr` to a trait\n                 // instance. If so, we have to be sure that the type\n                 // of the source obeys the new region bound.\n-                let source_ty = rcx.resolve_node_type(expr.id);\n-                type_must_outlive(rcx, infer::RelateObjectBound(expr.span),\n-                                  source_ty, bounds.region_bound);\n+                let source_ty = self.resolve_node_type(expr.id);\n+                self.type_must_outlive(infer::RelateObjectBound(expr.span),\n+                                       source_ty, bounds.region_bound);\n             }\n             */\n             _ => {}\n@@ -608,17 +592,16 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n         // If necessary, constrain destructors in the unadjusted form of this\n         // expression.\n         let cmt_result = {\n-            let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n+            let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n             mc.cat_expr_unadjusted(expr)\n         };\n         match cmt_result {\n             Ok(head_cmt) => {\n-                check_safety_of_rvalue_destructor_if_necessary(rcx,\n-                                                               head_cmt,\n-                                                               expr.span);\n+                self.check_safety_of_rvalue_destructor_if_necessary(head_cmt,\n+                                                                    expr.span);\n             }\n             Err(..) => {\n-                let tcx = rcx.fcx.tcx();\n+                let tcx = self.fcx.tcx();\n                 tcx.sess.delay_span_bug(expr.span, \"cat_expr_unadjusted Errd\");\n             }\n         }\n@@ -627,63 +610,63 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n     // If necessary, constrain destructors in this expression. This will be\n     // the adjusted form if there is an adjustment.\n     let cmt_result = {\n-        let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n+        let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n         mc.cat_expr(expr)\n     };\n     match cmt_result {\n         Ok(head_cmt) => {\n-            check_safety_of_rvalue_destructor_if_necessary(rcx, head_cmt, expr.span);\n+            self.check_safety_of_rvalue_destructor_if_necessary(head_cmt, expr.span);\n         }\n         Err(..) => {\n-            let tcx = rcx.fcx.tcx();\n+            let tcx = self.fcx.tcx();\n             tcx.sess.delay_span_bug(expr.span, \"cat_expr Errd\");\n         }\n     }\n \n     debug!(\"regionck::visit_expr(e={:?}, repeating_scope={}) - visiting subexprs\",\n-           expr, rcx.repeating_scope);\n+           expr, self.repeating_scope);\n     match expr.node {\n         hir::ExprPath(..) => {\n-            rcx.fcx.opt_node_ty_substs(expr.id, |item_substs| {\n+            self.fcx.opt_node_ty_substs(expr.id, |item_substs| {\n                 let origin = infer::ParameterOrigin::Path;\n-                substs_wf_in_scope(rcx, origin, &item_substs.substs, expr.span, expr_region);\n+                self.substs_wf_in_scope(origin, &item_substs.substs, expr.span, expr_region);\n             });\n         }\n \n         hir::ExprCall(ref callee, ref args) => {\n             if has_method_map {\n-                constrain_call(rcx, expr, Some(&callee),\n-                               args.iter().map(|e| &**e), false);\n+                self.constrain_call(expr, Some(&callee),\n+                                    args.iter().map(|e| &**e), false);\n             } else {\n-                constrain_callee(rcx, callee.id, expr, &callee);\n-                constrain_call(rcx, expr, None,\n-                               args.iter().map(|e| &**e), false);\n+                self.constrain_callee(callee.id, expr, &callee);\n+                self.constrain_call(expr, None,\n+                                    args.iter().map(|e| &**e), false);\n             }\n \n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprMethodCall(_, _, ref args) => {\n-            constrain_call(rcx, expr, Some(&args[0]),\n-                           args[1..].iter().map(|e| &**e), false);\n+            self.constrain_call(expr, Some(&args[0]),\n+                                args[1..].iter().map(|e| &**e), false);\n \n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprAssignOp(_, ref lhs, ref rhs) => {\n             if has_method_map {\n-                constrain_call(rcx, expr, Some(&lhs),\n-                               Some(&**rhs).into_iter(), false);\n+                self.constrain_call(expr, Some(&lhs),\n+                                    Some(&**rhs).into_iter(), false);\n             }\n \n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprIndex(ref lhs, ref rhs) if has_method_map => {\n-            constrain_call(rcx, expr, Some(&lhs),\n-                           Some(&**rhs).into_iter(), true);\n+            self.constrain_call(expr, Some(&lhs),\n+                                Some(&**rhs).into_iter(), true);\n \n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         },\n \n         hir::ExprBinary(op, ref lhs, ref rhs) if has_method_map => {\n@@ -693,75 +676,72 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             // overloaded op.  Note that we (sadly) currently use an\n             // implicit \"by ref\" sort of passing style here.  This\n             // should be converted to an adjustment!\n-            constrain_call(rcx, expr, Some(&lhs),\n-                           Some(&**rhs).into_iter(), implicitly_ref_args);\n+            self.constrain_call(expr, Some(&lhs),\n+                                Some(&**rhs).into_iter(), implicitly_ref_args);\n \n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprBinary(_, ref lhs, ref rhs) => {\n             // If you do `x OP y`, then the types of `x` and `y` must\n             // outlive the operation you are performing.\n-            let lhs_ty = rcx.resolve_expr_type_adjusted(&lhs);\n-            let rhs_ty = rcx.resolve_expr_type_adjusted(&rhs);\n+            let lhs_ty = self.resolve_expr_type_adjusted(&lhs);\n+            let rhs_ty = self.resolve_expr_type_adjusted(&rhs);\n             for &ty in &[lhs_ty, rhs_ty] {\n-                type_must_outlive(rcx,\n-                                  infer::Operand(expr.span),\n-                                  ty,\n-                                  expr_region);\n+                self.type_must_outlive(infer::Operand(expr.span),\n+                                       ty, expr_region);\n             }\n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprUnary(op, ref lhs) if has_method_map => {\n             let implicitly_ref_args = !op.is_by_value();\n \n             // As above.\n-            constrain_call(rcx, expr, Some(&lhs),\n-                           None::<hir::Expr>.iter(), implicitly_ref_args);\n+            self.constrain_call(expr, Some(&lhs),\n+                                None::<hir::Expr>.iter(), implicitly_ref_args);\n \n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprUnary(hir::UnDeref, ref base) => {\n             // For *a, the lifetime of a must enclose the deref\n             let method_call = MethodCall::expr(expr.id);\n-            let base_ty = match rcx.fcx.inh.tables.borrow().method_map.get(&method_call) {\n+            let base_ty = match self.fcx.inh.tables.borrow().method_map.get(&method_call) {\n                 Some(method) => {\n-                    constrain_call(rcx, expr, Some(&base),\n-                                   None::<hir::Expr>.iter(), true);\n+                    self.constrain_call(expr, Some(&base),\n+                                        None::<hir::Expr>.iter(), true);\n                     let fn_ret = // late-bound regions in overloaded method calls are instantiated\n-                        rcx.tcx().no_late_bound_regions(&method.ty.fn_ret()).unwrap();\n+                        self.tcx().no_late_bound_regions(&method.ty.fn_ret()).unwrap();\n                     fn_ret.unwrap()\n                 }\n-                None => rcx.resolve_node_type(base.id)\n+                None => self.resolve_node_type(base.id)\n             };\n             if let ty::TyRef(r_ptr, _) = base_ty.sty {\n-                mk_subregion_due_to_dereference(\n-                    rcx, expr.span, expr_region, *r_ptr);\n+                self.mk_subregion_due_to_dereference(expr.span, expr_region, *r_ptr);\n             }\n \n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprIndex(ref vec_expr, _) => {\n             // For a[b], the lifetime of a must enclose the deref\n-            let vec_type = rcx.resolve_expr_type_adjusted(&vec_expr);\n-            constrain_index(rcx, expr, vec_type);\n+            let vec_type = self.resolve_expr_type_adjusted(&vec_expr);\n+            self.constrain_index(expr, vec_type);\n \n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprCast(ref source, _) => {\n             // Determine if we are casting `source` to a trait\n             // instance.  If so, we have to be sure that the type of\n             // the source obeys the trait's region bound.\n-            constrain_cast(rcx, expr, &source);\n-            intravisit::walk_expr(rcx, expr);\n+            self.constrain_cast(expr, &source);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprAddrOf(m, ref base) => {\n-            link_addr_of(rcx, expr, m, &base);\n+            self.link_addr_of(expr, m, &base);\n \n             // Require that when you write a `&expr` expression, the\n             // resulting pointer has a lifetime that encompasses the\n@@ -770,113 +750,114 @@ fn visit_expr(rcx: &mut Rcx, expr: &hir::Expr) {\n             // adjustments*.\n             //\n             // FIXME(#6268) nested method calls requires that this rule change\n-            let ty0 = rcx.resolve_node_type(expr.id);\n-            type_must_outlive(rcx, infer::AddrOf(expr.span), ty0, expr_region);\n-            intravisit::walk_expr(rcx, expr);\n+            let ty0 = self.resolve_node_type(expr.id);\n+            self.type_must_outlive(infer::AddrOf(expr.span), ty0, expr_region);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprMatch(ref discr, ref arms, _) => {\n-            link_match(rcx, &discr, &arms[..]);\n+            self.link_match(&discr, &arms[..]);\n \n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         }\n \n         hir::ExprClosure(_, _, ref body, _) => {\n-            check_expr_fn_block(rcx, expr, &body);\n+            self.check_expr_fn_block(expr, &body);\n         }\n \n         hir::ExprLoop(ref body, _) => {\n-            let repeating_scope = rcx.set_repeating_scope(body.id);\n-            intravisit::walk_expr(rcx, expr);\n-            rcx.set_repeating_scope(repeating_scope);\n+            let repeating_scope = self.set_repeating_scope(body.id);\n+            intravisit::walk_expr(self, expr);\n+            self.set_repeating_scope(repeating_scope);\n         }\n \n         hir::ExprWhile(ref cond, ref body, _) => {\n-            let repeating_scope = rcx.set_repeating_scope(cond.id);\n-            rcx.visit_expr(&cond);\n+            let repeating_scope = self.set_repeating_scope(cond.id);\n+            self.visit_expr(&cond);\n \n-            rcx.set_repeating_scope(body.id);\n-            rcx.visit_block(&body);\n+            self.set_repeating_scope(body.id);\n+            self.visit_block(&body);\n \n-            rcx.set_repeating_scope(repeating_scope);\n+            self.set_repeating_scope(repeating_scope);\n         }\n \n         hir::ExprRet(Some(ref ret_expr)) => {\n-            let call_site_scope = rcx.call_site_scope;\n+            let call_site_scope = self.call_site_scope;\n             debug!(\"visit_expr ExprRet ret_expr.id {} call_site_scope: {:?}\",\n                    ret_expr.id, call_site_scope);\n-            type_of_node_must_outlive(rcx,\n-                                      infer::CallReturn(ret_expr.span),\n-                                      ret_expr.id,\n-                                      ty::ReScope(call_site_scope.unwrap()));\n-            intravisit::walk_expr(rcx, expr);\n+            self.type_of_node_must_outlive(infer::CallReturn(ret_expr.span),\n+                                           ret_expr.id,\n+                                           ty::ReScope(call_site_scope.unwrap()));\n+            intravisit::walk_expr(self, expr);\n         }\n \n         _ => {\n-            intravisit::walk_expr(rcx, expr);\n+            intravisit::walk_expr(self, expr);\n         }\n     }\n }\n+}\n \n-fn constrain_cast(rcx: &mut Rcx,\n+impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n+fn constrain_cast(&mut self,\n                   cast_expr: &hir::Expr,\n                   source_expr: &hir::Expr)\n {\n     debug!(\"constrain_cast(cast_expr={:?}, source_expr={:?})\",\n            cast_expr,\n            source_expr);\n \n-    let source_ty = rcx.resolve_node_type(source_expr.id);\n-    let target_ty = rcx.resolve_node_type(cast_expr.id);\n+    let source_ty = self.resolve_node_type(source_expr.id);\n+    let target_ty = self.resolve_node_type(cast_expr.id);\n \n-    walk_cast(rcx, cast_expr, source_ty, target_ty);\n+    self.walk_cast(cast_expr, source_ty, target_ty);\n+}\n \n-    fn walk_cast<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n-                           cast_expr: &hir::Expr,\n-                           from_ty: Ty<'tcx>,\n-                           to_ty: Ty<'tcx>) {\n+    fn walk_cast(&mut self,\n+                 cast_expr: &hir::Expr,\n+                 from_ty: Ty<'tcx>,\n+                 to_ty: Ty<'tcx>) {\n         debug!(\"walk_cast(from_ty={:?}, to_ty={:?})\",\n                from_ty,\n                to_ty);\n         match (&from_ty.sty, &to_ty.sty) {\n             /*From:*/ (&ty::TyRef(from_r, ref from_mt),\n             /*To:  */  &ty::TyRef(to_r, ref to_mt)) => {\n                 // Target cannot outlive source, naturally.\n-                rcx.fcx.infcx().sub_regions(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n-                walk_cast(rcx, cast_expr, from_mt.ty, to_mt.ty);\n+                self.fcx.infcx().sub_regions(infer::Reborrow(cast_expr.span), *to_r, *from_r);\n+                self.walk_cast(cast_expr, from_mt.ty, to_mt.ty);\n             }\n \n             /*From:*/ (_,\n             /*To:  */  &ty::TyTrait(box ty::TraitTy { ref bounds, .. })) => {\n                 // When T is existentially quantified as a trait\n                 // `Foo+'to`, it must outlive the region bound `'to`.\n-                type_must_outlive(rcx, infer::RelateObjectBound(cast_expr.span),\n-                                  from_ty, bounds.region_bound);\n+                self.type_must_outlive(infer::RelateObjectBound(cast_expr.span),\n+                                       from_ty, bounds.region_bound);\n             }\n \n             /*From:*/ (&ty::TyBox(from_referent_ty),\n             /*To:  */  &ty::TyBox(to_referent_ty)) => {\n-                walk_cast(rcx, cast_expr, from_referent_ty, to_referent_ty);\n+                self.walk_cast(cast_expr, from_referent_ty, to_referent_ty);\n             }\n \n             _ => { }\n         }\n     }\n-}\n \n-fn check_expr_fn_block(rcx: &mut Rcx,\n+fn check_expr_fn_block(&mut self,\n                        expr: &hir::Expr,\n                        body: &hir::Block) {\n-    let repeating_scope = rcx.set_repeating_scope(body.id);\n-    intravisit::walk_expr(rcx, expr);\n-    rcx.set_repeating_scope(repeating_scope);\n+    let repeating_scope = self.set_repeating_scope(body.id);\n+    intravisit::walk_expr(self, expr);\n+    self.set_repeating_scope(repeating_scope);\n }\n \n-fn constrain_callee(rcx: &mut Rcx,\n+fn constrain_callee(&mut self,\n                     callee_id: ast::NodeId,\n                     _call_expr: &hir::Expr,\n                     _callee_expr: &hir::Expr) {\n-    let callee_ty = rcx.resolve_node_type(callee_id);\n+    let callee_ty = self.resolve_node_type(callee_id);\n     match callee_ty.sty {\n         ty::TyFnDef(..) | ty::TyFnPtr(_) => { }\n         _ => {\n@@ -891,7 +872,7 @@ fn constrain_callee(rcx: &mut Rcx,\n     }\n }\n \n-fn constrain_call<'a, I: Iterator<Item=&'a hir::Expr>>(rcx: &mut Rcx,\n+fn constrain_call<'b, I: Iterator<Item=&'b hir::Expr>>(&mut self,\n                                                        call_expr: &hir::Expr,\n                                                        receiver: Option<&hir::Expr>,\n                                                        arg_exprs: I,\n@@ -912,7 +893,7 @@ fn constrain_call<'a, I: Iterator<Item=&'a hir::Expr>>(rcx: &mut Rcx,\n     // call occurs.\n     //\n     // FIXME(#6268) to support nested method calls, should be callee_id\n-    let callee_scope = rcx.tcx().region_maps.node_extent(call_expr.id);\n+    let callee_scope = self.tcx().region_maps.node_extent(call_expr.id);\n     let callee_region = ty::ReScope(callee_scope);\n \n     debug!(\"callee_region={:?}\", callee_region);\n@@ -922,64 +903,62 @@ fn constrain_call<'a, I: Iterator<Item=&'a hir::Expr>>(rcx: &mut Rcx,\n \n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n-        type_of_node_must_outlive(\n-            rcx, infer::CallArg(arg_expr.span),\n-            arg_expr.id, callee_region);\n+        self.type_of_node_must_outlive(infer::CallArg(arg_expr.span),\n+                                       arg_expr.id, callee_region);\n \n         // unfortunately, there are two means of taking implicit\n         // references, and we need to propagate constraints as a\n         // result. modes are going away and the \"DerefArgs\" code\n         // should be ported to use adjustments\n         if implicitly_ref_args {\n-            link_by_ref(rcx, arg_expr, callee_scope);\n+            self.link_by_ref(arg_expr, callee_scope);\n         }\n     }\n \n     // as loop above, but for receiver\n     if let Some(r) = receiver {\n         debug!(\"receiver: {:?}\", r);\n-        type_of_node_must_outlive(\n-            rcx, infer::CallRcvr(r.span),\n-            r.id, callee_region);\n+        self.type_of_node_must_outlive(infer::CallRcvr(r.span),\n+                                       r.id, callee_region);\n         if implicitly_ref_args {\n-            link_by_ref(rcx, &r, callee_scope);\n+            self.link_by_ref(&r, callee_scope);\n         }\n     }\n }\n \n /// Invoked on any auto-dereference that occurs. Checks that if this is a region pointer being\n /// dereferenced, the lifetime of the pointer includes the deref expr.\n-fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n-                                  deref_expr: &hir::Expr,\n-                                  derefs: usize,\n-                                  mut derefd_ty: Ty<'tcx>)\n+fn constrain_autoderefs(&mut self,\n+                        deref_expr: &hir::Expr,\n+                        derefs: usize,\n+                        mut derefd_ty: Ty<'tcx>)\n {\n     debug!(\"constrain_autoderefs(deref_expr={:?}, derefs={}, derefd_ty={:?})\",\n            deref_expr,\n            derefs,\n            derefd_ty);\n \n-    let s_deref_expr = rcx.tcx().region_maps.node_extent(deref_expr.id);\n+    let s_deref_expr = self.tcx().region_maps.node_extent(deref_expr.id);\n     let r_deref_expr = ty::ReScope(s_deref_expr);\n     for i in 0..derefs {\n         let method_call = MethodCall::autoderef(deref_expr.id, i as u32);\n         debug!(\"constrain_autoderefs: method_call={:?} (of {:?} total)\", method_call, derefs);\n \n-        let method = rcx.fcx.inh.tables.borrow().method_map.get(&method_call).map(|m| m.clone());\n+        let method = self.fcx.inh.tables.borrow().method_map.get(&method_call).map(|m| m.clone());\n \n         derefd_ty = match method {\n             Some(method) => {\n                 debug!(\"constrain_autoderefs: #{} is overloaded, method={:?}\",\n                        i, method);\n \n                 let origin = infer::ParameterOrigin::OverloadedDeref;\n-                substs_wf_in_scope(rcx, origin, method.substs, deref_expr.span, r_deref_expr);\n+                self.substs_wf_in_scope(origin, method.substs, deref_expr.span, r_deref_expr);\n \n                 // Treat overloaded autoderefs as if an AutoRef adjustment\n                 // was applied on the base type, as that is always the case.\n                 let fn_sig = method.ty.fn_sig();\n                 let fn_sig = // late-bound regions should have been instantiated\n-                    rcx.tcx().no_late_bound_regions(fn_sig).unwrap();\n+                    self.tcx().no_late_bound_regions(fn_sig).unwrap();\n                 let self_ty = fn_sig.inputs[0];\n                 let (m, r) = match self_ty.sty {\n                     ty::TyRef(r, ref m) => (m.mutbl, r),\n@@ -995,21 +974,21 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                        r, m);\n \n                 {\n-                    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n+                    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n                     let self_cmt = ignore_err!(mc.cat_expr_autoderefd(deref_expr, i));\n                     debug!(\"constrain_autoderefs: self_cmt={:?}\",\n                            self_cmt);\n-                    link_region(rcx, deref_expr.span, r,\n-                                ty::BorrowKind::from_mutbl(m), self_cmt);\n+                    self.link_region(deref_expr.span, r,\n+                                     ty::BorrowKind::from_mutbl(m), self_cmt);\n                 }\n \n                 // Specialized version of constrain_call.\n-                type_must_outlive(rcx, infer::CallRcvr(deref_expr.span),\n-                                  self_ty, r_deref_expr);\n+                self.type_must_outlive(infer::CallRcvr(deref_expr.span),\n+                                       self_ty, r_deref_expr);\n                 match fn_sig.output {\n                     ty::FnConverging(return_type) => {\n-                        type_must_outlive(rcx, infer::CallReturn(deref_expr.span),\n-                                          return_type, r_deref_expr);\n+                        self.type_must_outlive(infer::CallReturn(deref_expr.span),\n+                                               return_type, r_deref_expr);\n                         return_type\n                     }\n                     ty::FnDiverging => bug!()\n@@ -1019,8 +998,8 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n         };\n \n         if let ty::TyRef(r_ptr, _) =  derefd_ty.sty {\n-            mk_subregion_due_to_dereference(rcx, deref_expr.span,\n-                                            r_deref_expr, *r_ptr);\n+            self.mk_subregion_due_to_dereference(deref_expr.span,\n+                                                 r_deref_expr, *r_ptr);\n         }\n \n         match derefd_ty.builtin_deref(true, ty::NoPreference) {\n@@ -1032,23 +1011,23 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n     }\n }\n \n-pub fn mk_subregion_due_to_dereference(rcx: &mut Rcx,\n+pub fn mk_subregion_due_to_dereference(&mut self,\n                                        deref_span: Span,\n                                        minimum_lifetime: ty::Region,\n                                        maximum_lifetime: ty::Region) {\n-    rcx.fcx.infcx().sub_regions(infer::DerefPointer(deref_span),\n-                                minimum_lifetime, maximum_lifetime)\n+    self.fcx.infcx().sub_regions(infer::DerefPointer(deref_span),\n+                                 minimum_lifetime, maximum_lifetime)\n }\n \n-fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n-                                                            cmt: mc::cmt<'tcx>,\n-                                                            span: Span) {\n+fn check_safety_of_rvalue_destructor_if_necessary(&mut self,\n+                                                 cmt: mc::cmt<'tcx>,\n+                                                 span: Span) {\n     match cmt.cat {\n         Categorization::Rvalue(region) => {\n             match region {\n                 ty::ReScope(rvalue_scope) => {\n-                    let typ = rcx.resolve_type(cmt.ty);\n-                    dropck::check_safety_of_destructor_if_necessary(rcx,\n+                    let typ = self.resolve_type(cmt.ty);\n+                    dropck::check_safety_of_destructor_if_necessary(self,\n                                                                     typ,\n                                                                     span,\n                                                                     rvalue_scope);\n@@ -1068,19 +1047,19 @@ fn check_safety_of_rvalue_destructor_if_necessary<'a, 'tcx>(rcx: &mut Rcx<'a, 't\n \n /// Invoked on any index expression that occurs. Checks that if this is a slice being indexed, the\n /// lifetime of the pointer includes the deref expr.\n-fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n-                             index_expr: &hir::Expr,\n-                             indexed_ty: Ty<'tcx>)\n+fn constrain_index(&mut self,\n+                   index_expr: &hir::Expr,\n+                   indexed_ty: Ty<'tcx>)\n {\n     debug!(\"constrain_index(index_expr=?, indexed_ty={}\",\n-           rcx.fcx.infcx().ty_to_string(indexed_ty));\n+           self.fcx.infcx().ty_to_string(indexed_ty));\n \n-    let r_index_expr = ty::ReScope(rcx.tcx().region_maps.node_extent(index_expr.id));\n+    let r_index_expr = ty::ReScope(self.tcx().region_maps.node_extent(index_expr.id));\n     if let ty::TyRef(r_ptr, mt) = indexed_ty.sty {\n         match mt.ty.sty {\n             ty::TySlice(_) | ty::TyStr => {\n-                rcx.fcx.infcx().sub_regions(infer::IndexSlice(index_expr.span),\n-                                            r_index_expr, *r_ptr);\n+                self.fcx.infcx().sub_regions(infer::IndexSlice(index_expr.span),\n+                                             r_index_expr, *r_ptr);\n             }\n             _ => {}\n         }\n@@ -1089,116 +1068,114 @@ fn constrain_index<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n \n /// Guarantees that any lifetimes which appear in the type of the node `id` (after applying\n /// adjustments) are valid for at least `minimum_lifetime`\n-fn type_of_node_must_outlive<'a, 'tcx>(\n-    rcx: &mut Rcx<'a, 'tcx>,\n+fn type_of_node_must_outlive(&mut self,\n     origin: infer::SubregionOrigin<'tcx>,\n     id: ast::NodeId,\n     minimum_lifetime: ty::Region)\n {\n-    let tcx = rcx.fcx.tcx();\n+    let tcx = self.fcx.tcx();\n \n     // Try to resolve the type.  If we encounter an error, then typeck\n     // is going to fail anyway, so just stop here and let typeck\n     // report errors later on in the writeback phase.\n-    let ty0 = rcx.resolve_node_type(id);\n+    let ty0 = self.resolve_node_type(id);\n     let ty = ty0.adjust(tcx, origin.span(), id,\n-                        rcx.fcx.inh.tables.borrow().adjustments.get(&id),\n-                        |method_call| rcx.resolve_method_type(method_call));\n+                        self.fcx.inh.tables.borrow().adjustments.get(&id),\n+                        |method_call| self.resolve_method_type(method_call));\n     debug!(\"constrain_regions_in_type_of_node(\\\n             ty={}, ty0={}, id={}, minimum_lifetime={:?})\",\n             ty,  ty0,\n            id, minimum_lifetime);\n-    type_must_outlive(rcx, origin, ty, minimum_lifetime);\n+    self.type_must_outlive(origin, ty, minimum_lifetime);\n }\n \n /// Computes the guarantor for an expression `&base` and then ensures that the lifetime of the\n /// resulting pointer is linked to the lifetime of its guarantor (if any).\n-fn link_addr_of(rcx: &mut Rcx, expr: &hir::Expr,\n+fn link_addr_of(&mut self, expr: &hir::Expr,\n                 mutability: hir::Mutability, base: &hir::Expr) {\n     debug!(\"link_addr_of(expr={:?}, base={:?})\", expr, base);\n \n     let cmt = {\n-        let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n+        let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n         ignore_err!(mc.cat_expr(base))\n     };\n \n     debug!(\"link_addr_of: cmt={:?}\", cmt);\n \n-    link_region_from_node_type(rcx, expr.span, expr.id, mutability, cmt);\n+    self.link_region_from_node_type(expr.span, expr.id, mutability, cmt);\n }\n \n /// Computes the guarantors for any ref bindings in a `let` and\n /// then ensures that the lifetime of the resulting pointer is\n /// linked to the lifetime of the initialization expression.\n-fn link_local(rcx: &Rcx, local: &hir::Local) {\n+fn link_local(&self, local: &hir::Local) {\n     debug!(\"regionck::for_local()\");\n     let init_expr = match local.init {\n         None => { return; }\n         Some(ref expr) => &**expr,\n     };\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n+    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n     let discr_cmt = ignore_err!(mc.cat_expr(init_expr));\n-    link_pattern(rcx, mc, discr_cmt, &local.pat);\n+    self.link_pattern(mc, discr_cmt, &local.pat);\n }\n \n /// Computes the guarantors for any ref bindings in a match and\n /// then ensures that the lifetime of the resulting pointer is\n /// linked to the lifetime of its guarantor (if any).\n-fn link_match(rcx: &Rcx, discr: &hir::Expr, arms: &[hir::Arm]) {\n+fn link_match(&self, discr: &hir::Expr, arms: &[hir::Arm]) {\n     debug!(\"regionck::for_match()\");\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n+    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n     let discr_cmt = ignore_err!(mc.cat_expr(discr));\n     debug!(\"discr_cmt={:?}\", discr_cmt);\n     for arm in arms {\n         for root_pat in &arm.pats {\n-            link_pattern(rcx, mc, discr_cmt.clone(), &root_pat);\n+            self.link_pattern(mc, discr_cmt.clone(), &root_pat);\n         }\n     }\n }\n \n /// Computes the guarantors for any ref bindings in a match and\n /// then ensures that the lifetime of the resulting pointer is\n /// linked to the lifetime of its guarantor (if any).\n-fn link_fn_args(rcx: &Rcx, body_scope: CodeExtent, args: &[hir::Arg]) {\n+fn link_fn_args(&self, body_scope: CodeExtent, args: &[hir::Arg]) {\n     debug!(\"regionck::link_fn_args(body_scope={:?})\", body_scope);\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n+    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n     for arg in args {\n-        let arg_ty = rcx.fcx.node_ty(arg.id);\n+        let arg_ty = self.fcx.node_ty(arg.id);\n         let re_scope = ty::ReScope(body_scope);\n         let arg_cmt = mc.cat_rvalue(arg.id, arg.ty.span, re_scope, arg_ty);\n         debug!(\"arg_ty={:?} arg_cmt={:?} arg={:?}\",\n                arg_ty,\n                arg_cmt,\n                arg);\n-        link_pattern(rcx, mc, arg_cmt, &arg.pat);\n+        self.link_pattern(mc, arg_cmt, &arg.pat);\n     }\n }\n \n /// Link lifetimes of any ref bindings in `root_pat` to the pointers found in the discriminant, if\n /// needed.\n-fn link_pattern<'t, 'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                          mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n-                          discr_cmt: mc::cmt<'tcx>,\n-                          root_pat: &hir::Pat) {\n+fn link_pattern<'t>(&self,\n+                    mc: mc::MemCategorizationContext<'t, 'a, 'tcx>,\n+                    discr_cmt: mc::cmt<'tcx>,\n+                    root_pat: &hir::Pat) {\n     debug!(\"link_pattern(discr_cmt={:?}, root_pat={:?})\",\n            discr_cmt,\n            root_pat);\n     let _ = mc.cat_pattern(discr_cmt, root_pat, |mc, sub_cmt, sub_pat| {\n             match sub_pat.node {\n                 // `ref x` pattern\n                 PatKind::Ident(hir::BindByRef(mutbl), _, _) => {\n-                    link_region_from_node_type(\n-                        rcx, sub_pat.span, sub_pat.id,\n-                        mutbl, sub_cmt);\n+                    self.link_region_from_node_type(sub_pat.span, sub_pat.id,\n+                                                    mutbl, sub_cmt);\n                 }\n \n                 // `[_, ..slice, _]` pattern\n                 PatKind::Vec(_, Some(ref slice_pat), _) => {\n                     match mc.cat_slice_pattern(sub_cmt, &slice_pat) {\n                         Ok((slice_cmt, slice_mutbl, slice_r)) => {\n-                            link_region(rcx, sub_pat.span, &slice_r,\n-                                        ty::BorrowKind::from_mutbl(slice_mutbl),\n-                                        slice_cmt);\n+                            self.link_region(sub_pat.span, &slice_r,\n+                                             ty::BorrowKind::from_mutbl(slice_mutbl),\n+                                             slice_cmt);\n                         }\n                         Err(()) => {}\n                     }\n@@ -1210,73 +1187,73 @@ fn link_pattern<'t, 'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n /// Link lifetime of borrowed pointer resulting from autoref to lifetimes in the value being\n /// autoref'd.\n-fn link_autoref(rcx: &Rcx,\n+fn link_autoref(&self,\n                 expr: &hir::Expr,\n                 autoderefs: usize,\n                 autoref: &adjustment::AutoRef)\n {\n     debug!(\"link_autoref(autoref={:?})\", autoref);\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n+    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n     let expr_cmt = ignore_err!(mc.cat_expr_autoderefd(expr, autoderefs));\n     debug!(\"expr_cmt={:?}\", expr_cmt);\n \n     match *autoref {\n         adjustment::AutoPtr(r, m) => {\n-            link_region(rcx, expr.span, r,\n-                ty::BorrowKind::from_mutbl(m), expr_cmt);\n+            self.link_region(expr.span, r,\n+                             ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n \n         adjustment::AutoUnsafe(m) => {\n-            let r = ty::ReScope(rcx.tcx().region_maps.node_extent(expr.id));\n-            link_region(rcx, expr.span, &r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n+            let r = ty::ReScope(self.tcx().region_maps.node_extent(expr.id));\n+            self.link_region(expr.span, &r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n     }\n }\n \n /// Computes the guarantor for cases where the `expr` is being passed by implicit reference and\n /// must outlive `callee_scope`.\n-fn link_by_ref(rcx: &Rcx,\n+fn link_by_ref(&self,\n                expr: &hir::Expr,\n                callee_scope: CodeExtent) {\n     debug!(\"link_by_ref(expr={:?}, callee_scope={:?})\",\n            expr, callee_scope);\n-    let mc = mc::MemCategorizationContext::new(rcx.fcx.infcx());\n+    let mc = mc::MemCategorizationContext::new(self.fcx.infcx());\n     let expr_cmt = ignore_err!(mc.cat_expr(expr));\n     let borrow_region = ty::ReScope(callee_scope);\n-    link_region(rcx, expr.span, &borrow_region, ty::ImmBorrow, expr_cmt);\n+    self.link_region(expr.span, &borrow_region, ty::ImmBorrow, expr_cmt);\n }\n \n /// Like `link_region()`, except that the region is extracted from the type of `id`, which must be\n /// some reference (`&T`, `&str`, etc).\n-fn link_region_from_node_type<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                        span: Span,\n-                                        id: ast::NodeId,\n-                                        mutbl: hir::Mutability,\n-                                        cmt_borrowed: mc::cmt<'tcx>) {\n+fn link_region_from_node_type(&self,\n+                              span: Span,\n+                              id: ast::NodeId,\n+                              mutbl: hir::Mutability,\n+                              cmt_borrowed: mc::cmt<'tcx>) {\n     debug!(\"link_region_from_node_type(id={:?}, mutbl={:?}, cmt_borrowed={:?})\",\n            id, mutbl, cmt_borrowed);\n \n-    let rptr_ty = rcx.resolve_node_type(id);\n+    let rptr_ty = self.resolve_node_type(id);\n     if let ty::TyRef(&r, _) = rptr_ty.sty {\n         debug!(\"rptr_ty={}\",  rptr_ty);\n-        link_region(rcx, span, &r, ty::BorrowKind::from_mutbl(mutbl),\n-                    cmt_borrowed);\n+        self.link_region(span, &r, ty::BorrowKind::from_mutbl(mutbl),\n+                         cmt_borrowed);\n     }\n }\n \n /// Informs the inference engine that `borrow_cmt` is being borrowed with kind `borrow_kind` and\n /// lifetime `borrow_region`. In order to ensure borrowck is satisfied, this may create constraints\n /// between regions, as explained in `link_reborrowed_region()`.\n-fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                         span: Span,\n-                         borrow_region: &ty::Region,\n-                         borrow_kind: ty::BorrowKind,\n-                         borrow_cmt: mc::cmt<'tcx>) {\n+fn link_region(&self,\n+               span: Span,\n+               borrow_region: &ty::Region,\n+               borrow_kind: ty::BorrowKind,\n+               borrow_cmt: mc::cmt<'tcx>) {\n     let mut borrow_cmt = borrow_cmt;\n     let mut borrow_kind = borrow_kind;\n \n     let origin = infer::DataBorrowed(borrow_cmt.ty, span);\n-    type_must_outlive(rcx, origin, borrow_cmt.ty, *borrow_region);\n+    self.type_must_outlive(origin, borrow_cmt.ty, *borrow_region);\n \n     loop {\n         debug!(\"link_region(borrow_region={:?}, borrow_kind={:?}, borrow_cmt={:?})\",\n@@ -1288,10 +1265,10 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                   mc::Implicit(ref_kind, ref_region)) |\n             Categorization::Deref(ref_cmt, _,\n                                   mc::BorrowedPtr(ref_kind, ref_region)) => {\n-                match link_reborrowed_region(rcx, span,\n-                                             borrow_region, borrow_kind,\n-                                             ref_cmt, ref_region, ref_kind,\n-                                             borrow_cmt.note) {\n+                match self.link_reborrowed_region(span,\n+                                                  borrow_region, borrow_kind,\n+                                                  ref_cmt, ref_region, ref_kind,\n+                                                  borrow_cmt.note) {\n                     Some((c, k)) => {\n                         borrow_cmt = c;\n                         borrow_kind = k;\n@@ -1364,23 +1341,23 @@ fn link_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n ///\n /// The return value of this function indicates whether we need to\n /// recurse and process `ref_cmt` (see case 2 above).\n-fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                    span: Span,\n-                                    borrow_region: &ty::Region,\n-                                    borrow_kind: ty::BorrowKind,\n-                                    ref_cmt: mc::cmt<'tcx>,\n-                                    ref_region: ty::Region,\n-                                    mut ref_kind: ty::BorrowKind,\n-                                    note: mc::Note)\n-                                    -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n+fn link_reborrowed_region(&self,\n+                          span: Span,\n+                          borrow_region: &ty::Region,\n+                          borrow_kind: ty::BorrowKind,\n+                          ref_cmt: mc::cmt<'tcx>,\n+                          ref_region: ty::Region,\n+                          mut ref_kind: ty::BorrowKind,\n+                          note: mc::Note)\n+                          -> Option<(mc::cmt<'tcx>, ty::BorrowKind)>\n {\n     // Possible upvar ID we may need later to create an entry in the\n     // maybe link map.\n \n     // Detect by-ref upvar `x`:\n     let cause = match note {\n         mc::NoteUpvarRef(ref upvar_id) => {\n-            let upvar_capture_map = &rcx.fcx.inh.tables.borrow_mut().upvar_capture_map;\n+            let upvar_capture_map = &self.fcx.inh.tables.borrow_mut().upvar_capture_map;\n             match upvar_capture_map.get(upvar_id) {\n                 Some(&ty::UpvarCapture::ByRef(ref upvar_borrow)) => {\n                     // The mutability of the upvar may have been modified\n@@ -1408,7 +1385,7 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     debug!(\"link_reborrowed_region: {:?} <= {:?}\",\n            borrow_region,\n            ref_region);\n-    rcx.fcx.infcx().sub_regions(cause, *borrow_region, ref_region);\n+    self.fcx.infcx().sub_regions(cause, *borrow_region, ref_region);\n \n     // If we end up needing to recurse and establish a region link\n     // with `ref_cmt`, calculate what borrow kind we will end up\n@@ -1476,11 +1453,11 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n /// Checks that the values provided for type/region arguments in a given\n /// expression are well-formed and in-scope.\n-pub fn substs_wf_in_scope<'a,'tcx>(rcx: &mut Rcx<'a,'tcx>,\n-                                   origin: infer::ParameterOrigin,\n-                                   substs: &Substs<'tcx>,\n-                                   expr_span: Span,\n-                                   expr_region: ty::Region) {\n+fn substs_wf_in_scope(&mut self,\n+                      origin: infer::ParameterOrigin,\n+                      substs: &Substs<'tcx>,\n+                      expr_span: Span,\n+                      expr_region: ty::Region) {\n     debug!(\"substs_wf_in_scope(substs={:?}, \\\n             expr_region={:?}, \\\n             origin={:?}, \\\n@@ -1490,24 +1467,24 @@ pub fn substs_wf_in_scope<'a,'tcx>(rcx: &mut Rcx<'a,'tcx>,\n     let origin = infer::ParameterInScope(origin, expr_span);\n \n     for &region in &substs.regions {\n-        rcx.fcx.infcx().sub_regions(origin.clone(), expr_region, region);\n+        self.fcx.infcx().sub_regions(origin.clone(), expr_region, region);\n     }\n \n     for &ty in &substs.types {\n-        let ty = rcx.resolve_type(ty);\n-        type_must_outlive(rcx, origin.clone(), ty, expr_region);\n+        let ty = self.resolve_type(ty);\n+        self.type_must_outlive(origin.clone(), ty, expr_region);\n     }\n }\n \n /// Ensures that type is well-formed in `region`, which implies (among\n /// other things) that all borrowed data reachable via `ty` outlives\n /// `region`.\n-pub fn type_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                   origin: infer::SubregionOrigin<'tcx>,\n-                                   ty: Ty<'tcx>,\n-                                   region: ty::Region)\n+pub fn type_must_outlive(&self,\n+                         origin: infer::SubregionOrigin<'tcx>,\n+                         ty: Ty<'tcx>,\n+                         region: ty::Region)\n {\n-    let ty = rcx.resolve_type(ty);\n+    let ty = self.resolve_type(ty);\n \n     debug!(\"type_must_outlive(ty={:?}, region={:?}, origin={:?})\",\n            ty,\n@@ -1516,58 +1493,58 @@ pub fn type_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n \n     assert!(!ty.has_escaping_regions());\n \n-    let components = rcx.infcx().outlives_components(ty);\n-    components_must_outlive(rcx, origin, components, region);\n+    let components = self.infcx().outlives_components(ty);\n+    self.components_must_outlive(origin, components, region);\n }\n \n-fn components_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                     origin: infer::SubregionOrigin<'tcx>,\n-                                     components: Vec<ty::outlives::Component<'tcx>>,\n-                                     region: ty::Region)\n+fn components_must_outlive(&self,\n+                           origin: infer::SubregionOrigin<'tcx>,\n+                           components: Vec<ty::outlives::Component<'tcx>>,\n+                           region: ty::Region)\n {\n     for component in components {\n         let origin = origin.clone();\n         match component {\n             ty::outlives::Component::Region(region1) => {\n-                rcx.fcx.infcx().sub_regions(origin, region, region1);\n+                self.fcx.infcx().sub_regions(origin, region, region1);\n             }\n             ty::outlives::Component::Param(param_ty) => {\n-                param_ty_must_outlive(rcx, origin, region, param_ty);\n+                self.param_ty_must_outlive(origin, region, param_ty);\n             }\n             ty::outlives::Component::Projection(projection_ty) => {\n-                projection_must_outlive(rcx, origin, region, projection_ty);\n+                self.projection_must_outlive(origin, region, projection_ty);\n             }\n             ty::outlives::Component::EscapingProjection(subcomponents) => {\n-                components_must_outlive(rcx, origin, subcomponents, region);\n+                self.components_must_outlive(origin, subcomponents, region);\n             }\n             ty::outlives::Component::UnresolvedInferenceVariable(v) => {\n                 // ignore this, we presume it will yield an error\n                 // later, since if a type variable is not resolved by\n                 // this point it never will be\n-                rcx.tcx().sess.delay_span_bug(\n+                self.tcx().sess.delay_span_bug(\n                     origin.span(),\n                     &format!(\"unresolved inference variable in outlives: {:?}\", v));\n             }\n         }\n     }\n }\n \n-fn param_ty_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                   origin: infer::SubregionOrigin<'tcx>,\n-                                   region: ty::Region,\n-                                   param_ty: ty::ParamTy) {\n+fn param_ty_must_outlive(&self,\n+                         origin: infer::SubregionOrigin<'tcx>,\n+                         region: ty::Region,\n+                         param_ty: ty::ParamTy) {\n     debug!(\"param_ty_must_outlive(region={:?}, param_ty={:?}, origin={:?})\",\n            region, param_ty, origin);\n \n-    let verify_bound = param_bound(rcx, param_ty);\n+    let verify_bound = self.param_bound(param_ty);\n     let generic = GenericKind::Param(param_ty);\n-    rcx.fcx.infcx().verify_generic_bound(origin, generic, region, verify_bound);\n+    self.fcx.infcx().verify_generic_bound(origin, generic, region, verify_bound);\n }\n \n-fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                     origin: infer::SubregionOrigin<'tcx>,\n-                                     region: ty::Region,\n-                                     projection_ty: ty::ProjectionTy<'tcx>)\n+fn projection_must_outlive(&self,\n+                           origin: infer::SubregionOrigin<'tcx>,\n+                           region: ty::Region,\n+                           projection_ty: ty::ProjectionTy<'tcx>)\n {\n     debug!(\"projection_must_outlive(region={:?}, projection_ty={:?}, origin={:?})\",\n            region, projection_ty, origin);\n@@ -1589,7 +1566,7 @@ fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // Compute the bounds we can derive from the environment or trait\n     // definition.  We know that the projection outlives all the\n     // regions in this list.\n-    let env_bounds = projection_declared_bounds(rcx, origin.span(), projection_ty);\n+    let env_bounds = self.projection_declared_bounds(origin.span(), projection_ty);\n \n     debug!(\"projection_must_outlive: env_bounds={:?}\",\n            env_bounds);\n@@ -1623,11 +1600,11 @@ fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n         debug!(\"projection_must_outlive: no declared bounds\");\n \n         for &component_ty in &projection_ty.trait_ref.substs.types {\n-            type_must_outlive(rcx, origin.clone(), component_ty, region);\n+            self.type_must_outlive(origin.clone(), component_ty, region);\n         }\n \n         for &r in &projection_ty.trait_ref.substs.regions {\n-            rcx.fcx.infcx().sub_regions(origin.clone(), region, r);\n+            self.fcx.infcx().sub_regions(origin.clone(), region, r);\n         }\n \n         return;\n@@ -1648,7 +1625,7 @@ fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                                          .any(|r| env_bounds.contains(r))\n         {\n             debug!(\"projection_must_outlive: unique declared bound appears in trait ref\");\n-            rcx.fcx.infcx().sub_regions(origin.clone(), region, unique_bound);\n+            self.fcx.infcx().sub_regions(origin.clone(), region, unique_bound);\n             return;\n         }\n     }\n@@ -1658,33 +1635,33 @@ fn projection_must_outlive<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // projection outlive; in some cases, this may add insufficient\n     // edges into the inference graph, leading to inference failures\n     // even though a satisfactory solution exists.\n-    let verify_bound = projection_bound(rcx, origin.span(), env_bounds, projection_ty);\n+    let verify_bound = self.projection_bound(origin.span(), env_bounds, projection_ty);\n     let generic = GenericKind::Projection(projection_ty);\n-    rcx.fcx.infcx().verify_generic_bound(origin, generic.clone(), region, verify_bound);\n+    self.fcx.infcx().verify_generic_bound(origin, generic.clone(), region, verify_bound);\n }\n \n-fn type_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n+fn type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n     match ty.sty {\n         ty::TyParam(p) => {\n-            param_bound(rcx, p)\n+            self.param_bound(p)\n         }\n         ty::TyProjection(data) => {\n-            let declared_bounds = projection_declared_bounds(rcx, span, data);\n-            projection_bound(rcx, span, declared_bounds, data)\n+            let declared_bounds = self.projection_declared_bounds(span, data);\n+            self.projection_bound(span, declared_bounds, data)\n         }\n         _ => {\n-            recursive_type_bound(rcx, span, ty)\n+            self.recursive_type_bound(span, ty)\n         }\n     }\n }\n \n-fn param_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, param_ty: ty::ParamTy) -> VerifyBound {\n-    let param_env = &rcx.infcx().parameter_environment;\n+fn param_bound(&self, param_ty: ty::ParamTy) -> VerifyBound {\n+    let param_env = &self.infcx().parameter_environment;\n \n     debug!(\"param_bound(param_ty={:?})\",\n            param_ty);\n \n-    let mut param_bounds = declared_generic_bounds_from_env(rcx, GenericKind::Param(param_ty));\n+    let mut param_bounds = self.declared_generic_bounds_from_env(GenericKind::Param(param_ty));\n \n     // Add in the default bound of fn body that applies to all in\n     // scope type parameters:\n@@ -1693,46 +1670,43 @@ fn param_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>, param_ty: ty::ParamTy) -> VerifyBo\n     VerifyBound::AnyRegion(param_bounds)\n }\n \n-fn projection_declared_bounds<'a, 'tcx>(rcx: &Rcx<'a,'tcx>,\n-                                        span: Span,\n-                                        projection_ty: ty::ProjectionTy<'tcx>)\n-                                        -> Vec<ty::Region>\n+fn projection_declared_bounds(&self,\n+                              span: Span,\n+                              projection_ty: ty::ProjectionTy<'tcx>)\n+                              -> Vec<ty::Region>\n {\n     // First assemble bounds from where clauses and traits.\n \n     let mut declared_bounds =\n-        declared_generic_bounds_from_env(rcx, GenericKind::Projection(projection_ty));\n+        self.declared_generic_bounds_from_env(GenericKind::Projection(projection_ty));\n \n     declared_bounds.extend_from_slice(\n-        &declared_projection_bounds_from_trait(rcx, span, projection_ty));\n+        &self.declared_projection_bounds_from_trait(span, projection_ty));\n \n     declared_bounds\n }\n \n-fn projection_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                              span: Span,\n-                              declared_bounds: Vec<ty::Region>,\n-                              projection_ty: ty::ProjectionTy<'tcx>)\n-                              -> VerifyBound {\n+fn projection_bound(&self,\n+                    span: Span,\n+                    declared_bounds: Vec<ty::Region>,\n+                    projection_ty: ty::ProjectionTy<'tcx>)\n+                    -> VerifyBound {\n     debug!(\"projection_bound(declared_bounds={:?}, projection_ty={:?})\",\n            declared_bounds, projection_ty);\n \n     // see the extensive comment in projection_must_outlive\n \n-    let ty = rcx.tcx().mk_projection(projection_ty.trait_ref, projection_ty.item_name);\n-    let recursive_bound = recursive_type_bound(rcx, span, ty);\n+    let ty = self.tcx().mk_projection(projection_ty.trait_ref, projection_ty.item_name);\n+    let recursive_bound = self.recursive_type_bound(span, ty);\n \n     VerifyBound::AnyRegion(declared_bounds).or(recursive_bound)\n }\n \n-fn recursive_type_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                  span: Span,\n-                                  ty: Ty<'tcx>)\n-                                  -> VerifyBound {\n+fn recursive_type_bound(&self, span: Span, ty: Ty<'tcx>) -> VerifyBound {\n     let mut bounds = vec![];\n \n     for subty in ty.walk_shallow() {\n-        bounds.push(type_bound(rcx, span, subty));\n+        bounds.push(self.type_bound(span, subty));\n     }\n \n     let mut regions = ty.regions();\n@@ -1749,15 +1723,14 @@ fn recursive_type_bound<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     }\n }\n \n-fn declared_generic_bounds_from_env<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                              generic: GenericKind<'tcx>)\n-                                              -> Vec<ty::Region>\n+fn declared_generic_bounds_from_env(&self, generic: GenericKind<'tcx>)\n+                                    -> Vec<ty::Region>\n {\n-    let param_env = &rcx.infcx().parameter_environment;\n+    let param_env = &self.infcx().parameter_environment;\n \n     // To start, collect bounds from user:\n-    let mut param_bounds = rcx.tcx().required_region_bounds(generic.to_ty(rcx.tcx()),\n-                                                            param_env.caller_bounds.clone());\n+    let mut param_bounds = self.tcx().required_region_bounds(generic.to_ty(self.tcx()),\n+                                                             param_env.caller_bounds.clone());\n \n     // Next, collect regions we scraped from the well-formedness\n     // constraints in the fn signature. To do that, we walk the list\n@@ -1770,7 +1743,7 @@ fn declared_generic_bounds_from_env<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // The problem is that the type of `x` is `&'a A`. To be\n     // well-formed, then, A must be lower-generic by `'a`, but we\n     // don't know that this holds from first principles.\n-    for &(r, p) in &rcx.region_bound_pairs {\n+    for &(r, p) in &self.region_bound_pairs {\n         debug!(\"generic={:?} p={:?}\",\n                generic,\n                p);\n@@ -1782,12 +1755,12 @@ fn declared_generic_bounds_from_env<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n     param_bounds\n }\n \n-fn declared_projection_bounds_from_trait<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n-                                                  span: Span,\n-                                                  projection_ty: ty::ProjectionTy<'tcx>)\n-                                                  -> Vec<ty::Region>\n+fn declared_projection_bounds_from_trait(&self,\n+                                         span: Span,\n+                                         projection_ty: ty::ProjectionTy<'tcx>)\n+                                         -> Vec<ty::Region>\n {\n-    let fcx = rcx.fcx;\n+    let fcx = self.fcx;\n     let tcx = fcx.tcx();\n     let infcx = fcx.infcx();\n \n@@ -1855,3 +1828,4 @@ fn declared_projection_bounds_from_trait<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n         })\n         .collect()\n }\n+}"}]}