{"sha": "ec6c2c3fc57170719d7bcfbdc40536c73b550824", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjNmMyYzNmYzU3MTcwNzE5ZDdiY2ZiZGM0MDUzNmM3M2I1NTA4MjQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-01T19:10:40Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-01T19:10:40Z"}, "message": "Rollup merge of #23932 - steveklabnik:doc_std_path, r=flaper87", "tree": {"sha": "af78e6734cd6948923545646e5ae1fcbd9a5bee8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af78e6734cd6948923545646e5ae1fcbd9a5bee8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec6c2c3fc57170719d7bcfbdc40536c73b550824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec6c2c3fc57170719d7bcfbdc40536c73b550824", "html_url": "https://github.com/rust-lang/rust/commit/ec6c2c3fc57170719d7bcfbdc40536c73b550824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec6c2c3fc57170719d7bcfbdc40536c73b550824/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "77112bbe4fe3910d93466bca9892790726a078cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/77112bbe4fe3910d93466bca9892790726a078cb", "html_url": "https://github.com/rust-lang/rust/commit/77112bbe4fe3910d93466bca9892790726a078cb"}, {"sha": "8ded1562658915f6160f5b83e5036c6900c139e3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8ded1562658915f6160f5b83e5036c6900c139e3", "html_url": "https://github.com/rust-lang/rust/commit/8ded1562658915f6160f5b83e5036c6900c139e3"}], "stats": {"total": 213, "additions": 213, "deletions": 0}, "files": [{"sha": "889381da28e92c74f3d438d5a93e1e84b60c45fd", "filename": "src/libstd/path.rs", "status": "modified", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/ec6c2c3fc57170719d7bcfbdc40536c73b550824/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6c2c3fc57170719d7bcfbdc40536c73b550824/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=ec6c2c3fc57170719d7bcfbdc40536c73b550824", "patch": "@@ -343,6 +343,15 @@ impl<'a> Prefix<'a> {\n \n /// Determine whether the character is one of the permitted path\n /// separators for the current platform.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::path;\n+///\n+/// assert!(path::is_separator('/'));\n+/// assert!(!path::is_separator('\u2764'));\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn is_separator(c: char) -> bool {\n     use ascii::*;\n@@ -539,6 +548,18 @@ impl<'a> AsRef<OsStr> for Component<'a> {\n ///\n /// See the module documentation for an in-depth explanation of components and\n /// their role in the API.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::path::Path;\n+///\n+/// let path = Path::new(\"/tmp/foo/bar.txt\");\n+///\n+/// for component in path.components() {\n+///     println!(\"{:?}\", component);\n+/// }\n+/// ```\n #[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Components<'a> {\n@@ -609,6 +630,16 @@ impl<'a> Components<'a> {\n     }\n \n     /// Extract a slice corresponding to the portion of the path remaining for iteration.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo/bar.txt\");\n+    ///\n+    /// println!(\"{:?}\", path.components().as_path());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_path(&self) -> &'a Path {\n         let mut comps = self.clone();\n@@ -1210,12 +1241,28 @@ impl Path {\n     /// Directly wrap a string slice as a `Path` slice.\n     ///\n     /// This is a cost-free conversion.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// Path::new(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new<S: AsRef<OsStr> + ?Sized>(s: &S) -> &Path {\n         unsafe { mem::transmute(s.as_ref()) }\n     }\n \n     /// Yield the underlying `OsStr` slice.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let os_str = Path::new(\"foo.txt\").as_os_str();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn as_os_str(&self) -> &OsStr {\n         &self.inner\n@@ -1224,6 +1271,14 @@ impl Path {\n     /// Yield a `&str` slice if the `Path` is valid unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path_str = Path::new(\"foo.txt\").to_str();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_str(&self) -> Option<&str> {\n         self.inner.to_str()\n@@ -1232,12 +1287,28 @@ impl Path {\n     /// Convert a `Path` to a `Cow<str>`.\n     ///\n     /// Any non-Unicode sequences are replaced with U+FFFD REPLACEMENT CHARACTER.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path_str = Path::new(\"foo.txt\").to_string_lossy();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_string_lossy(&self) -> Cow<str> {\n         self.inner.to_string_lossy()\n     }\n \n     /// Convert a `Path` to an owned `PathBuf`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path_str = Path::new(\"foo.txt\").to_path_buf();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn to_path_buf(&self) -> PathBuf {\n         PathBuf::from(self.inner.to_os_string())\n@@ -1251,13 +1322,29 @@ impl Path {\n     /// * On Windows, a path is absolute if it has a prefix and starts with the\n     /// root: `c:\\windows` is absolute, while `c:temp` and `\\temp` are not. In\n     /// other words, `path.is_absolute() == path.prefix().is_some() && path.has_root()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// assert_eq!(false, Path::new(\"foo.txt\").is_absolute());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_absolute(&self) -> bool {\n         self.has_root() &&\n             (cfg!(unix) || self.prefix().is_some())\n     }\n \n     /// A path is *relative* if it is not absolute.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// assert!(Path::new(\"foo.txt\").is_relative());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_relative(&self) -> bool {\n         !self.is_absolute()\n@@ -1281,6 +1368,14 @@ impl Path {\n     ///     * has no prefix and begins with a separator, e.g. `\\\\windows`\n     ///     * has a prefix followed by a separator, e.g. `c:\\windows` but not `c:windows`\n     ///     * has any non-disk prefix, e.g. `\\\\server\\share`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// assert!(Path::new(\"/etc/passwd\").has_root());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn has_root(&self) -> bool {\n          self.components().has_root()\n@@ -1297,8 +1392,11 @@ impl Path {\n     ///\n     /// let path = Path::new(\"/foo/bar\");\n     /// let foo = path.parent().unwrap();\n+    ///\n     /// assert!(foo == Path::new(\"/foo\"));\n+    ///\n     /// let root = foo.parent().unwrap();\n+    ///\n     /// assert!(root == Path::new(\"/\"));\n     /// assert!(root.parent() == None);\n     /// ```\n@@ -1318,6 +1416,17 @@ impl Path {\n     ///\n     /// If the path terminates in `.`, `..`, or consists solely or a root of\n     /// prefix, `file_name` will return `None`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"hello_world.rs\");\n+    /// let filename = \"hello_world.rs\";\n+    ///\n+    /// assert_eq!(filename, path.file_name().unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_name(&self) -> Option<&OsStr> {\n         self.components().next_back().and_then(|p| match p {\n@@ -1337,12 +1446,32 @@ impl Path {\n     }\n \n     /// Determines whether `base` is a prefix of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/etc/passwd\");\n+    ///\n+    /// assert!(path.starts_with(\"/etc\"));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn starts_with<P: AsRef<Path>>(&self, base: P) -> bool {\n         iter_after(self.components(), base.as_ref().components()).is_some()\n     }\n \n     /// Determines whether `child` is a suffix of `self`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/etc/passwd\");\n+    ///\n+    /// assert!(path.ends_with(\"passwd\"));\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn ends_with<P: AsRef<Path>>(&self, child: P) -> bool {\n         iter_after(self.components().rev(), child.as_ref().components().rev()).is_some()\n@@ -1356,6 +1485,16 @@ impl Path {\n     /// * The entire file name if there is no embedded `.`;\n     /// * The entire file name if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name before the final `.`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"foo.rs\");\n+    ///\n+    /// assert_eq!(\"foo\", path.file_stem().unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn file_stem(&self) -> Option<&OsStr> {\n         self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.or(after))\n@@ -1369,6 +1508,16 @@ impl Path {\n     /// * None, if there is no embedded `.`;\n     /// * None, if the file name begins with `.` and has no other `.`s within;\n     /// * Otherwise, the portion of the file name after the final `.`\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"foo.rs\");\n+    ///\n+    /// assert_eq!(\"rs\", path.extension().unwrap());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn extension(&self) -> Option<&OsStr> {\n         self.file_name().map(split_file_at_dot).and_then(|(before, after)| before.and(after))\n@@ -1377,6 +1526,16 @@ impl Path {\n     /// Creates an owned `PathBuf` with `path` adjoined to `self`.\n     ///\n     /// See `PathBuf::push` for more details on what it means to adjoin a path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp\");\n+    ///\n+    /// let new_path = path.join(\"foo\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn join<P: AsRef<Path>>(&self, path: P) -> PathBuf {\n         let mut buf = self.to_path_buf();\n@@ -1387,6 +1546,16 @@ impl Path {\n     /// Creates an owned `PathBuf` like `self` but with the given file name.\n     ///\n     /// See `PathBuf::set_file_name` for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// let new_path = path.with_file_name(\"bar.rs\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_file_name<S: AsRef<OsStr>>(&self, file_name: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n@@ -1397,6 +1566,16 @@ impl Path {\n     /// Creates an owned `PathBuf` like `self` but with the given extension.\n     ///\n     /// See `PathBuf::set_extension` for more details.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// let new_path = path.with_extension(\"foo.txt\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn with_extension<S: AsRef<OsStr>>(&self, extension: S) -> PathBuf {\n         let mut buf = self.to_path_buf();\n@@ -1405,6 +1584,18 @@ impl Path {\n     }\n \n     /// Produce an iterator over the components of the path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// for component in path.components() {\n+    ///     println!(\"{:?}\", component);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn components(&self) -> Components {\n         let prefix = parse_prefix(self.as_os_str());\n@@ -1418,13 +1609,35 @@ impl Path {\n     }\n \n     /// Produce an iterator over the path's components viewed as `OsStr` slices.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// for component in path.iter() {\n+    ///     println!(\"{:?}\", component);\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter {\n         Iter { inner: self.components() }\n     }\n \n     /// Returns an object that implements `Display` for safely printing paths\n     /// that may contain non-Unicode data.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::path::Path;\n+    ///\n+    /// let path = Path::new(\"/tmp/foo.rs\");\n+    ///\n+    /// println!(\"{}\", path.display());\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn display(&self) -> Display {\n         Display { path: self }"}]}