{"sha": "864cca14ee00082f67bbf92b60802195ab1c4d38", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2NGNjYTE0ZWUwMDA4MmY2N2JiZjkyYjYwODAyMTk1YWIxYzRkMzg=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-16T01:06:20Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-16T01:06:20Z"}, "message": "docs: Make supplemental tutorials testable", "tree": {"sha": "270645ab3013ba86f0c0261d2fe3d277f8745b86", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/270645ab3013ba86f0c0261d2fe3d277f8745b86"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/864cca14ee00082f67bbf92b60802195ab1c4d38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/864cca14ee00082f67bbf92b60802195ab1c4d38", "html_url": "https://github.com/rust-lang/rust/commit/864cca14ee00082f67bbf92b60802195ab1c4d38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/864cca14ee00082f67bbf92b60802195ab1c4d38/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82e79f765ce81442f7dd3e2c878f055e95d2a34f", "url": "https://api.github.com/repos/rust-lang/rust/commits/82e79f765ce81442f7dd3e2c878f055e95d2a34f", "html_url": "https://github.com/rust-lang/rust/commit/82e79f765ce81442f7dd3e2c878f055e95d2a34f"}], "stats": {"total": 212, "additions": 182, "deletions": 30}, "files": [{"sha": "632768a5f867f0f301f415eba917f4626afeee30", "filename": "configure", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/864cca14ee00082f67bbf92b60802195ab1c4d38/configure", "raw_url": "https://github.com/rust-lang/rust/raw/864cca14ee00082f67bbf92b60802195ab1c4d38/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=864cca14ee00082f67bbf92b60802195ab1c4d38", "patch": "@@ -505,6 +505,9 @@ do\n     make_dir $h/test/perf\n     make_dir $h/test/pretty\n     make_dir $h/test/doc-tutorial\n+    make_dir $h/test/doc-tutorial-ffi\n+    make_dir $h/test/doc-tutorial-macros\n+    make_dir $h/test/doc-tutorial-borrowed-ptr\n     make_dir $h/test/doc-ref\n done\n "}, {"sha": "4c187ca622c76f08ebab66fe8adc73d09c91193e", "filename": "doc/tutorial-borrowed-ptr.md", "status": "modified", "additions": 85, "deletions": 21, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/864cca14ee00082f67bbf92b60802195ab1c4d38/doc%2Ftutorial-borrowed-ptr.md", "raw_url": "https://github.com/rust-lang/rust/raw/864cca14ee00082f67bbf92b60802195ab1c4d38/doc%2Ftutorial-borrowed-ptr.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-borrowed-ptr.md?ref=864cca14ee00082f67bbf92b60802195ab1c4d38", "patch": "@@ -40,6 +40,7 @@ example, in this code, each of these three local variables contains a\n point, but allocated in a different place:\n \n ~~~\n+# type point = {x: float, y: float};\n let on_the_stack : point  =  {x: 3.0, y: 4.0};\n let shared_box   : @point = @{x: 5.0, y: 1.0};\n let unique_box   : ~point = ~{x: 7.0, y: 9.0};\n@@ -58,6 +59,8 @@ define a function that takes the points by pointer. We can use\n borrowed pointers to do this:\n \n ~~~\n+# type point = {x: float, y: float};\n+# fn sqrt(f: float) -> float { 0f }\n fn compute_distance(p1: &point, p2: &point) -> float {\n     let x_d = p1.x - p2.x;\n     let y_d = p1.y - p2.y;\n@@ -67,7 +70,12 @@ fn compute_distance(p1: &point, p2: &point) -> float {\n \n Now we can call `compute_distance()` in various ways:\n \n-~~~\n+~~~ {.xfail-test}\n+# type point = {x: float, y: float};\n+# let on_the_stack : point  =  {x: 3.0, y: 4.0};\n+# let shared_box   : @point = @{x: 5.0, y: 1.0};\n+# let unique_box   : ~point = ~{x: 7.0, y: 9.0};\n+# fn compute_distance(p1: &point, p2: &point) -> float { 0f }\n compute_distance(&on_the_stack, shared_box)\n compute_distance(shared_box, unique_box)\n ~~~\n@@ -100,6 +108,7 @@ it again.\n In the previous example, the value `on_the_stack` was defined like so:\n \n ~~~\n+# type point = {x: float, y: float};\n let on_the_stack : point = {x: 3.0, y: 4.0};\n ~~~\n \n@@ -109,13 +118,15 @@ pointer. Sometimes however it is more convenient to move the &\n operator into the definition of `on_the_stack`:\n \n ~~~\n+# type point = {x: float, y: float};\n let on_the_stack2 : &point = &{x: 3.0, y: 4.0};\n ~~~\n \n Applying `&` to an rvalue (non-assignable location) is just a convenient\n shorthand for creating a temporary and taking its address:\n \n ~~~\n+# type point = {x: float, y: float};\n let tmp = {x: 3.0, y: 4.0};\n let on_the_stack2 : &point = &tmp;\n ~~~\n@@ -144,7 +155,14 @@ let rect_unique = ~{origin: {x: 5, y: 6}, size: {w: 3, h: 4}};\n In each case I can use the `&` operator to extact out individual\n subcomponents. For example, I could write:\n \n-~~~\n+~~~ {.xfail-test}\n+# type point = {x: float, y: float};\n+# type size = {w: float, h: float}; // as before\n+# type rectangle = {origin: point, size: size};\n+# let rect_stack  = &{origin: {x: 1, y: 2}, size: {w: 3, h: 4}};\n+# let rect_shared = @{origin: {x: 3, y: 4}, size: {w: 3, h: 4}};\n+# let rect_unique = ~{origin: {x: 5, y: 6}, size: {w: 3, h: 4}};\n+# fn compute_distance(p1: &point, p2: &point) -> float { 0f }\n compute_distance(&rect_stack.origin, &rect_shared.origin);\n ~~~\n \n@@ -238,14 +256,16 @@ mean that the unique box is stored in immutable memory. For example,\n the following function is legal:\n \n ~~~\n+# fn some_condition() -> bool { true }\n fn example3() -> int {\n     let mut x = ~{f: 3};\n-    if some_condition {\n+    if some_condition() {\n         let y = &x.f;      // -+ L\n-        ret *y;            //  |\n+        return *y;         //  |\n     }                      // -+\n     x = ~{f: 4};\n     ...\n+# return 0;\n }\n ~~~\n \n@@ -261,7 +281,7 @@ _as soon as their owning reference is changed or goes out of\n scope_. Therefore, a program like this is illegal (and would be\n rejected by the compiler):\n \n-~~~\n+~~~ {.xfail-test}\n fn example3() -> int {\n     let mut x = ~{f: 3};\n     let y = &x.f;\n@@ -308,7 +328,7 @@ frame_. So we could modify the previous example to introduce\n additional unique pointers and records, and the compiler will still be\n able to detect possible mutations:\n \n-~~~\n+~~~ {.xfail-test}\n fn example3() -> int {\n     let mut x = ~{mut f: ~{g: 3}};\n     let y = &x.f.g;\n@@ -326,8 +346,8 @@ Things get tricker when the unique box is not uniquely owned by the\n stack frame (or when the compiler doesn\u2019t know who the owner\n is). Consider a program like this:\n \n-~~~\n-fn example5a(x: @{mut f: ~{g: int}}, ...) -> int {\n+~~~ {.xfail-test}\n+fn example5a(x: @{mut f: ~{g: int}} ...) -> int {\n     let y = &x.f.g;   // Error reported here.\n     ...\n }\n@@ -359,9 +379,10 @@ unique found in aliasable memory is to ensure that it is stored within\n unique fields, as in the following example:\n \n ~~~\n-fn example5b(x: @{f: ~{g: int}}, ...) -> int {\n+fn example5b(x: @{f: ~{g: int}}) -> int {\n     let y = &x.f.g;\n     ...\n+# return 0;\n }\n ~~~\n \n@@ -373,13 +394,15 @@ If you do have a unique box in a mutable field, and you wish to borrow\n it, one option is to use the swap operator to bring that unique box\n onto your stack:\n \n-~~~\n-fn example5c(x: @{mut f: ~int}, ...) -> int {\n+~~~ {.xfail-test}\n+fn example5c(x: @{mut f: ~int}) -> int {\n     let mut v = ~0;\n     v <-> x.f;         // Swap v and x.f\n     let y = &v;\n     ...\n     x.f <- v;          // Replace x.f\n+    ...\n+# return 0;\n }\n ~~~\n \n@@ -412,8 +435,15 @@ function takes a borrowed pointer to a shape to avoid the need of\n copying them.\n \n ~~~\n+# type point = {x: float, y: float}; // as before\n+# type size = {w: float, h: float}; // as before\n+# enum shape {\n+#     circle(point, float),   // origin, radius\n+#     rectangle(point, size)  // upper-left, dimensions\n+# }\n+# const tau: float = 6.28f;\n fn compute_area(shape: &shape) -> float {\n-    alt *shape {\n+    match *shape {\n         circle(_, radius) => 0.5 * tau * radius * radius,\n         rectangle(_, ref size) => size.w * size.h\n     }\n@@ -502,7 +532,7 @@ but as we\u2019ll see this is more limited.\n \n For example, we could write a subroutine like this:\n \n-~~~\n+~~~ {.xfail-test}\n type point = {x: float, y: float};\n fn get_x(p: &point) -> &float { &p.x }\n ~~~\n@@ -535,7 +565,7 @@ the compiler is satisfied with the function `get_x()`.\n To drill in this point, let\u2019s look at a variation on the example, this\n time one which does not compile:\n \n-~~~\n+~~~ {.xfail-test}\n type point = {x: float, y: float};\n fn get_x_sh(p: @point) -> &float {\n     &p.x // Error reported here\n@@ -574,7 +604,14 @@ pointer. However, sometimes if a function takes many parameters, it is\n useful to be able to group those parameters by lifetime. For example,\n consider this function:\n \n-~~~\n+~~~ {.xfail-test}\n+# type point = {x: float, y: float}; // as before\n+# type size = {w: float, h: float}; // as before\n+# enum shape {\n+#     circle(point, float),   // origin, radius\n+#     rectangle(point, size)  // upper-left, dimensions\n+# }\n+# fn compute_area(shape: &shape) -> float { 0f }\n fn select<T>(shape: &shape, threshold: float,\n              a: &T, b: &T) -> &T {\n     if compute_area(shape) > threshold {a} else {b}\n@@ -588,7 +625,19 @@ lifetime of the returned value will be the intersection of the\n lifetime of the three region parameters. This may be overloy\n conservative, as in this example:\n \n-~~~\n+~~~ {.xfail-test}\n+# type point = {x: float, y: float}; // as before\n+# type size = {w: float, h: float}; // as before\n+# enum shape {\n+#     circle(point, float),   // origin, radius\n+#     rectangle(point, size)  // upper-left, dimensions\n+# }\n+# fn compute_area(shape: &shape) -> float { 0f }\n+# fn select<T>(shape: &shape, threshold: float,\n+#              a: &T, b: &T) -> &T {\n+#     if compute_area(shape) > threshold {a} else {b}\n+# }\n+\n                                               // -+ L\n fn select_based_on_unit_circle<T>(            //  |-+ B\n     threshold: float, a: &T, b: &T) -> &T {   //  | |\n@@ -618,7 +667,14 @@ second lifetime parameter for the function; named lifetime parameters\n do not need to be declared, you just use them. Here is how the new\n `select()` might look:\n \n-~~~\n+~~~ {.xfail-test}\n+# type point = {x: float, y: float}; // as before\n+# type size = {w: float, h: float}; // as before\n+# enum shape {\n+#     circle(point, float),   // origin, radius\n+#     rectangle(point, size)  // upper-left, dimensions\n+# }\n+# fn compute_area(shape: &shape) -> float { 0f }\n fn select<T>(shape: &tmp/shape, threshold: float,\n              a: &T, b: &T) -> &T {\n     if compute_area(shape) > threshold {a} else {b}\n@@ -632,7 +688,14 @@ lifetime parameter.\n You could also write `select()` using all named lifetime parameters,\n which might look like:\n \n-~~~\n+~~~ {.xfail-test}\n+# type point = {x: float, y: float}; // as before\n+# type size = {w: float, h: float}; // as before\n+# enum shape {\n+#     circle(point, float),   // origin, radius\n+#     rectangle(point, size)  // upper-left, dimensions\n+# }\n+# fn compute_area(shape: &shape) -> float { 0f }\n fn select<T>(shape: &tmp/shape, threshold: float,\n              a: &r/T, b: &r/T) -> &r/T {\n     if compute_area(shape) > threshold {a} else {b}\n@@ -658,7 +721,7 @@ a unique box found in an aliasable, mutable location, only now we\u2019ve\n replaced the `...` with some specific code:\n \n ~~~\n-fn example5a(x: @{mut f: ~{g: int}}, ...) -> int {\n+fn example5a(x: @{mut f: ~{g: int}} ...) -> int {\n     let y = &x.f.g;   // Unsafe\n     *y + 1        \n }\n@@ -676,8 +739,9 @@ fn add_one(x: &int) -> int { *x + 1 }\n \n We can now update `example5a()` to use `add_one()`:\n \n-~~~\n-fn example5a(x: @{mut f: ~{g: int}}, ...) -> int {\n+~~~ {.xfail-test}\n+# fn add_one(x: &int) -> int { *x + 1 }\n+fn example5a(x: @{mut f: ~{g: int}} ...) -> int {\n     let y = &x.f.g;\n     add_one(y)        // Error reported here\n }"}, {"sha": "c51d12aff8dede6bba08d00dd1ab55b4dde919e7", "filename": "doc/tutorial-ffi.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/864cca14ee00082f67bbf92b60802195ab1c4d38/doc%2Ftutorial-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/864cca14ee00082f67bbf92b60802195ab1c4d38/doc%2Ftutorial-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-ffi.md?ref=864cca14ee00082f67bbf92b60802195ab1c4d38", "patch": "@@ -28,9 +28,9 @@ fn as_hex(data: ~[u8]) -> ~str {\n \n fn sha1(data: ~str) -> ~str unsafe {\n     let bytes = str::to_bytes(data);\n-    let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n+    let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n                             vec::len(bytes) as c_uint, ptr::null());\n-    return as_hex(vec::unsafe::from_buf(hash, 20u));\n+    return as_hex(vec::raw::from_buf(hash, 20u));\n }\n \n fn main(args: ~[~str]) {\n@@ -128,9 +128,9 @@ The `sha1` function is the most obscure part of the program.\n fn sha1(data: ~str) -> ~str {\n     unsafe {\n         let bytes = str::to_bytes(data);\n-        let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n+        let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n                                 vec::len(bytes), ptr::null());\n-        return as_hex(vec::unsafe::from_buf(hash, 20u));\n+        return as_hex(vec::raw::from_buf(hash, 20u));\n     }\n }\n ~~~~\n@@ -171,15 +171,15 @@ Let's look at our `sha1` function again.\n # fn x(data: ~str) -> ~str {\n # unsafe {\n let bytes = str::to_bytes(data);\n-let hash = crypto::SHA1(vec::unsafe::to_ptr(bytes),\n+let hash = crypto::SHA1(vec::raw::to_ptr(bytes),\n                         vec::len(bytes), ptr::null());\n-return as_hex(vec::unsafe::from_buf(hash, 20u));\n+return as_hex(vec::raw::from_buf(hash, 20u));\n # }\n # }\n ~~~~\n \n The `str::to_bytes` function is perfectly safe: it converts a string to\n-a `[u8]`. This byte array is then fed to `vec::unsafe::to_ptr`, which\n+a `[u8]`. This byte array is then fed to `vec::raw::to_ptr`, which\n returns an unsafe pointer to its contents.\n \n This pointer will become invalid as soon as the vector it points into\n@@ -193,7 +193,7 @@ unsafe null pointer of the correct type (Rust generics are awesome\n like that\u2014they can take the right form depending on the type that they\n are expected to return).\n \n-Finally, `vec::unsafe::from_buf` builds up a new `[u8]` from the\n+Finally, `vec::raw::from_buf` builds up a new `[u8]` from the\n unsafe pointer that was returned by `SHA1`. SHA1 digests are always\n twenty bytes long, so we can pass `20u` for the length of the new\n vector."}, {"sha": "3b092833cad3e964a74f114e6cffbc5783abdc00", "filename": "mk/tests.mk", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/864cca14ee00082f67bbf92b60802195ab1c4d38/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/864cca14ee00082f67bbf92b60802195ab1c4d38/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=864cca14ee00082f67bbf92b60802195ab1c4d38", "patch": "@@ -164,6 +164,21 @@ doc-tutorial-extract$(1):\n \t$$(Q)rm -f $(1)/test/doc-tutorial/*.rs\n \t$$(Q)$$(EXTRACT_TESTS) $$(S)doc/tutorial.md $(1)/test/doc-tutorial\n \n+doc-tutorial-ffi-extract$(1):\n+\t@$$(call E, extract: tutorial-ffi tests)\n+\t$$(Q)rm -f $(1)/test/doc-tutorial-ffi/*.rs\n+\t$$(Q)$$(EXTRACT_TESTS) $$(S)doc/tutorial-ffi.md $(1)/test/doc-tutorial-ffi\n+\n+doc-tutorial-macros-extract$(1):\n+\t@$$(call E, extract: tutorial-macros tests)\n+\t$$(Q)rm -f $(1)/test/doc-tutorial-macros/*.rs\n+\t$$(Q)$$(EXTRACT_TESTS) $$(S)doc/tutorial-macros.md $(1)/test/doc-tutorial-macros\n+\n+doc-tutorial-borrowed-ptr-extract$(1):\n+\t@$$(call E, extract: tutorial-borrowed-ptr tests)\n+\t$$(Q)rm -f $(1)/test/doc-tutorial-borrowed-ptr/*.rs\n+\t$$(Q)$$(EXTRACT_TESTS) $$(S)doc/tutorial-borrowed-ptr.md $(1)/test/doc-tutorial-borrowed-ptr\n+\n doc-ref-extract$(1):\n \t@$$(call E, extract: ref tests)\n \t$$(Q)rm -f $(1)/test/doc-ref/*.rs\n@@ -211,6 +226,9 @@ check-stage$(1)-T-$(2)-H-$(3):     \t\t\t\t\\\n     check-stage$(1)-T-$(2)-H-$(3)-rustdoc       \\\n     check-stage$(1)-T-$(2)-H-$(3)-cargo       \\\n     check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial  \\\n+    check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-ffi  \\\n+    check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-macros  \\\n+    check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-borrowed-ptr  \\\n     check-stage$(1)-T-$(2)-H-$(3)-doc-ref\n \n check-stage$(1)-T-$(2)-H-$(3)-core:\t\t\t\t\\\n@@ -271,6 +289,15 @@ check-stage$(1)-T-$(2)-H-$(3)-cargo:\t\t\t\t\\\n check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-dummy\n \n+check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-ffi: \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-ffi-dummy\n+\n+check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-macros: \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-macros-dummy\n+\n+check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-borrowed-ptr: \\\n+\tcheck-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-borrowed-ptr-dummy\n+\n check-stage$(1)-T-$(2)-H-$(3)-doc-ref: \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-doc-ref-dummy\n \n@@ -440,6 +467,24 @@ DOC_TUTORIAL_ARGS$(1)-T-$(2)-H-$(3) :=\t\t\t\\\n         --build-base $(3)/test/doc-tutorial/\t\t\\\n         --mode run-pass\n \n+DOC_TUTORIAL_FFI_ARGS$(1)-T-$(2)-H-$(3) :=\t\t\\\n+\t\t$$(CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3))\t\\\n+        --src-base $(3)/test/doc-tutorial-ffi/\t\t\\\n+        --build-base $(3)/test/doc-tutorial-ffi/\t\\\n+        --mode run-pass\n+\n+DOC_TUTORIAL_MACROS_ARGS$(1)-T-$(2)-H-$(3) :=\t\t\\\n+\t\t$$(CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3))\t\\\n+        --src-base $(3)/test/doc-tutorial-macros/\t\\\n+        --build-base $(3)/test/doc-tutorial-macros/\t\\\n+        --mode run-pass\n+\n+DOC_TUTORIAL_BORROWED_PTR_ARGS$(1)-T-$(2)-H-$(3) :=\t\\\n+\t\t$$(CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3))\t\\\n+        --src-base $(3)/test/doc-tutorial-borrowed-ptr/\t\\\n+        --build-base $(3)/test/doc-tutorial-borrowed-ptr/ \\\n+        --mode run-pass\n+\n DOC_REF_ARGS$(1)-T-$(2)-H-$(3) :=\t\t\t\\\n \t\t$$(CTEST_COMMON_ARGS$(1)-T-$(2)-H-$(3))\t\\\n         --src-base $(3)/test/doc-ref/\t\t\t\\\n@@ -542,6 +587,30 @@ check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-dummy:       \\\n                 $$(DOC_TUTORIAL_ARGS$(1)-T-$(2)-H-$(3)) \\\n \t\t--logfile tmp/check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial.log\n \n+check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-ffi-dummy:       \\\n+\t        $$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\\\n+                doc-tutorial-ffi-extract$(3)\n+\t@$$(call E, run doc-tutorial-ffi: $$<)\n+\t$$(Q)$$(call CFG_RUN_CTEST,$(1),$$<,$(3)) \\\n+                $$(DOC_TUTORIAL_FFI_ARGS$(1)-T-$(2)-H-$(3)) \\\n+\t\t--logfile tmp/check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-ffi.log\n+\n+check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-macros-dummy:       \\\n+\t        $$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\\\n+                doc-tutorial-macros-extract$(3)\n+\t@$$(call E, run doc-tutorial-macros: $$<)\n+\t$$(Q)$$(call CFG_RUN_CTEST,$(1),$$<,$(3)) \\\n+                $$(DOC_TUTORIAL_MACROS_ARGS$(1)-T-$(2)-H-$(3)) \\\n+\t\t--logfile tmp/check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-macros.log\n+\n+check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-borrowed-ptr-dummy:       \\\n+\t        $$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\\\n+                doc-tutorial-borrowed-ptr-extract$(3)\n+\t@$$(call E, run doc-tutorial-borrowed-ptr: $$<)\n+\t$$(Q)$$(call CFG_RUN_CTEST,$(1),$$<,$(3)) \\\n+                $$(DOC_TUTORIAL_BORROWED_PTR_ARGS$(1)-T-$(2)-H-$(3)) \\\n+\t\t--logfile tmp/check-stage$(1)-T-$(2)-H-$(3)-doc-tutorial-borrowed-ptr.log\n+\n check-stage$(1)-T-$(2)-H-$(3)-doc-ref-dummy:            \\\n \t        $$(TEST_SREQ$(1)_T_$(2)_H_$(3))\t\t\\\n                 doc-ref-extract$(3)\n@@ -670,6 +739,15 @@ check-stage$(1)-H-$(2)-cargo:\t\t\t\t\t\\\n check-stage$(1)-H-$(2)-doc-tutorial:\t\t\t\t\\\n \t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n \t check-stage$(1)-T-$$(target)-H-$(2)-doc-tutorial)\n+check-stage$(1)-H-$(2)-doc-tutorial-ffi:\t\t\t\\\n+\t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n+\t check-stage$(1)-T-$$(target)-H-$(2)-doc-tutorial-ffi)\n+check-stage$(1)-H-$(2)-doc-tutorial-macros:\t\t\t\\\n+\t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n+\t check-stage$(1)-T-$$(target)-H-$(2)-doc-tutorial-macros)\n+check-stage$(1)-H-$(2)-doc-tutorial-borrowed-ptr:\t\t\\\n+\t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n+\t check-stage$(1)-T-$$(target)-H-$(2)-doc-tutorial-borrowed-ptr)\n check-stage$(1)-H-$(2)-doc-ref:\t\t\t\t\\\n \t$$(foreach target,$$(CFG_TARGET_TRIPLES),\t\\\n \t check-stage$(1)-T-$$(target)-H-$(2)-doc-ref)\n@@ -778,6 +856,9 @@ check-stage$(1)-pretty-pretty: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-pretty-pret\n check-stage$(1)-rustdoc: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-rustdoc\n check-stage$(1)-cargo: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-cargo\n check-stage$(1)-doc-tutorial: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-tutorial\n+check-stage$(1)-doc-tutorial-ffi: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-tutorial-ffi\n+check-stage$(1)-doc-tutorial-macros: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-tutorial-macros\n+check-stage$(1)-doc-tutorial-borrowed-ptr: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-tutorial-borrowed-ptr\n check-stage$(1)-doc-ref: check-stage$(1)-H-$$(CFG_HOST_TRIPLE)-doc-ref\n \n endef"}, {"sha": "9308bf6d5ee04a244623548a6bd96ea296856f4c", "filename": "src/etc/extract-tests.py", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/864cca14ee00082f67bbf92b60802195ab1c4d38/src%2Fetc%2Fextract-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/864cca14ee00082f67bbf92b60802195ab1c4d38/src%2Fetc%2Fextract-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fextract-tests.py?ref=864cca14ee00082f67bbf92b60802195ab1c4d38", "patch": "@@ -47,7 +47,11 @@\n             if re.match(\"~~~\", line):\n                 break\n             else:\n-                block += re.sub(\"^# \", \"\", line)\n+                # Lines beginning with '# ' are turned into valid code\n+                line = re.sub(\"^# \", \"\", line)\n+                # Allow elipses in code snippets\n+                line = re.sub(\"\\.\\.\\.\", \"/*...*/\", line)\n+                block += line\n         if not ignore:\n             if not re.search(r\"\\bfn main\\b\", block):\n                 block = \"fn main() {\\n\" + block + \"\\n}\\n\""}]}