{"sha": "eaf5d32ac732e704d59748a6f56c17989fbd2bac", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhZjVkMzJhYzczMmU3MDRkNTk3NDhhNmY1NmMxNzk4OWZiZDJiYWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-08T12:28:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-08T12:28:08Z"}, "message": "Auto merge of #1501 - samrat:fix-fs-error-handling, r=RalfJung\n\nBubble up errors from FileDescriptor::as_file_handle\n\nInstead of indicating incorrectly that a handle was not found, return the error from `as_file_handle` indicating the operation is not supported on the FD.\n\nAddresses some comments in #1495", "tree": {"sha": "2530773f0a6e6bec8593309060d05eb5e60bec3a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2530773f0a6e6bec8593309060d05eb5e60bec3a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eaf5d32ac732e704d59748a6f56c17989fbd2bac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eaf5d32ac732e704d59748a6f56c17989fbd2bac", "html_url": "https://github.com/rust-lang/rust/commit/eaf5d32ac732e704d59748a6f56c17989fbd2bac", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eaf5d32ac732e704d59748a6f56c17989fbd2bac/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "302ccf4ef6caefc1a2c5441eed4054b55aeb137c", "url": "https://api.github.com/repos/rust-lang/rust/commits/302ccf4ef6caefc1a2c5441eed4054b55aeb137c", "html_url": "https://github.com/rust-lang/rust/commit/302ccf4ef6caefc1a2c5441eed4054b55aeb137c"}, {"sha": "1069f6b17468a48af5a8ab441bf355ac955f4596", "url": "https://api.github.com/repos/rust-lang/rust/commits/1069f6b17468a48af5a8ab441bf355ac955f4596", "html_url": "https://github.com/rust-lang/rust/commit/1069f6b17468a48af5a8ab441bf355ac955f4596"}], "stats": {"total": 130, "additions": 55, "deletions": 75}, "files": [{"sha": "e0b2837cae908f0c8ee198a334e2a1aa09a7c1f7", "filename": "src/shims/posix/fs.rs", "status": "modified", "additions": 55, "deletions": 75, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/eaf5d32ac732e704d59748a6f56c17989fbd2bac/src%2Fshims%2Fposix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eaf5d32ac732e704d59748a6f56c17989fbd2bac/src%2Fshims%2Fposix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fposix%2Ffs.rs?ref=eaf5d32ac732e704d59748a6f56c17989fbd2bac", "patch": "@@ -484,9 +484,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             let fh = &mut this.machine.file_handler;\n             let (file_result, writable) = match fh.handles.get(&fd) {\n-                Some(file_descriptor) => match file_descriptor.as_file_handle() {\n-                    Ok(FileHandle { file, writable }) => (file.try_clone(), *writable),\n-                    Err(_) => return this.handle_not_found(),\n+                Some(file_descriptor) => {\n+                    // FIXME: Support \"dup\" for all FDs(stdin, etc)\n+                    let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n+                    (file.try_clone(), *writable)\n                 },\n                 None => return this.handle_not_found(),\n             };\n@@ -499,13 +500,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         {\n             let &[_, _] = check_arg_count(args)?;\n             if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n-                match file_descriptor.as_file_handle() {\n-                    Ok(FileHandle { file, writable }) => {\n-                        let io_result = maybe_sync_file(&file, *writable, File::sync_all);\n-                        this.try_unwrap_io_result(io_result)\n-                    },\n-                    Err(_) => this.handle_not_found(),\n-                }\n+                // FIXME: Support fullfsync for all FDs\n+                let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n+                let io_result = maybe_sync_file(&file, *writable, File::sync_all);\n+                this.try_unwrap_io_result(io_result)\n             } else {\n                 this.handle_not_found()\n             }\n@@ -522,28 +520,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n \n         if let Some(file_descriptor) = this.machine.file_handler.handles.remove(&fd) {\n-            match file_descriptor.as_file_handle() {\n-                Ok(FileHandle { file, writable }) => {\n-                    // We sync the file if it was opened in a mode different than read-only.\n-                    if *writable {\n-                        // `File::sync_all` does the checks that are done when closing a file. We do this to\n-                        // to handle possible errors correctly.\n-                        let result = this.try_unwrap_io_result(file.sync_all().map(|_| 0i32));\n-                        // Now we actually close the file.\n-                        drop(file);\n-                        // And return the result.\n-                        result\n-                    } else {\n-                        // We drop the file, this closes it but ignores any errors produced when closing\n-                        // it. This is done because `File::sync_all` cannot be done over files like\n-                        // `/dev/urandom` which are read-only. Check\n-                        // https://github.com/rust-lang/miri/issues/999#issuecomment-568920439 for a deeper\n-                        // discussion.\n-                        drop(file);\n-                        Ok(0)\n-                    }\n-                },\n-                Err(_) => this.handle_not_found()\n+            // FIXME: Support `close` for all FDs(stdin, etc)\n+            let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n+            // We sync the file if it was opened in a mode different than read-only.\n+            if *writable {\n+                // `File::sync_all` does the checks that are done when closing a file. We do this to\n+                // to handle possible errors correctly.\n+                let result = this.try_unwrap_io_result(file.sync_all().map(|_| 0i32));\n+                // Now we actually close the file.\n+                drop(file);\n+                // And return the result.\n+                result\n+            } else {\n+                // We drop the file, this closes it but ignores any errors produced when closing\n+                // it. This is done because `File::sync_all` cannot be done over files like\n+                // `/dev/urandom` which are read-only. Check\n+                // https://github.com/rust-lang/miri/issues/999#issuecomment-568920439 for a deeper\n+                // discussion.\n+                drop(file);\n+                Ok(0)\n             }\n         } else {\n             this.handle_not_found()\n@@ -1223,25 +1218,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         let length = this.read_scalar(length_op)?.to_i64()?;\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get_mut(&fd) {\n-            match file_descriptor.as_file_handle() {\n-                Ok(FileHandle { file, writable }) => {\n-                    if *writable {\n-                        if let Ok(length) = length.try_into() {\n-                            let result = file.set_len(length);\n-                            this.try_unwrap_io_result(result.map(|_| 0i32))\n-                        } else {\n-                            let einval = this.eval_libc(\"EINVAL\")?;\n-                            this.set_last_error(einval)?;\n-                            Ok(-1)\n-                        }\n-                    } else {\n-                        // The file is not writable\n-                        let einval = this.eval_libc(\"EINVAL\")?;\n-                        this.set_last_error(einval)?;\n-                        Ok(-1)\n-                    }\n+            // FIXME: Support ftruncate64 for all FDs\n+            let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n+            if *writable {\n+                if let Ok(length) = length.try_into() {\n+                    let result = file.set_len(length);\n+                    this.try_unwrap_io_result(result.map(|_| 0i32))\n+                } else {\n+                    let einval = this.eval_libc(\"EINVAL\")?;\n+                    this.set_last_error(einval)?;\n+                    Ok(-1)\n                 }\n-                Err(_) => this.handle_not_found()\n+            } else {\n+                // The file is not writable\n+                let einval = this.eval_libc(\"EINVAL\")?;\n+                this.set_last_error(einval)?;\n+                Ok(-1)\n             }\n         } else {\n             this.handle_not_found()\n@@ -1260,13 +1252,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n-            match file_descriptor.as_file_handle() {\n-                Ok(FileHandle { file, writable }) => {\n-                    let io_result = maybe_sync_file(&file, *writable, File::sync_all);\n-                    this.try_unwrap_io_result(io_result)\n-                }\n-                Err(_) => this.handle_not_found()\n-            }\n+            // FIXME: Support fsync for all FDs\n+            let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n+            let io_result = maybe_sync_file(&file, *writable, File::sync_all);\n+            this.try_unwrap_io_result(io_result)\n         } else {\n             this.handle_not_found()\n         }\n@@ -1279,13 +1268,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n-            match file_descriptor.as_file_handle() {\n-                Ok(FileHandle { file, writable }) => {\n-                    let io_result = maybe_sync_file(&file, *writable, File::sync_data);\n-                    this.try_unwrap_io_result(io_result)\n-                }\n-                Err(_) => this.handle_not_found()\n-            }\n+            // FIXME: Support fdatasync for all FDs\n+            let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n+            let io_result = maybe_sync_file(&file, *writable, File::sync_data);\n+            this.try_unwrap_io_result(io_result)\n         } else {\n             this.handle_not_found()\n         }\n@@ -1322,13 +1308,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         if let Some(file_descriptor) = this.machine.file_handler.handles.get(&fd) {\n-            match file_descriptor.as_file_handle() {\n-                Ok(FileHandle { file, writable }) => {\n-                    let io_result = maybe_sync_file(&file, *writable, File::sync_data);\n-                    this.try_unwrap_io_result(io_result)\n-                },\n-                Err(_) => this.handle_not_found()\n-            }\n+            // FIXME: Support sync_data_range for all FDs\n+            let FileHandle { file, writable } = file_descriptor.as_file_handle()?;\n+            let io_result = maybe_sync_file(&file, *writable, File::sync_data);\n+            this.try_unwrap_io_result(io_result)\n         } else {\n             this.handle_not_found()\n         }\n@@ -1378,10 +1361,7 @@ impl FileMetadata {\n     ) -> InterpResult<'tcx, Option<FileMetadata>> {\n         let option = ecx.machine.file_handler.handles.get(&fd);\n         let file = match option {\n-            Some(file_descriptor) => match file_descriptor.as_file_handle() {\n-                Ok(FileHandle { file, writable: _ }) => file,\n-                Err(_) => return ecx.handle_not_found().map(|_: i32| None),\n-            },\n+            Some(file_descriptor) => &file_descriptor.as_file_handle()?.file,\n             None => return ecx.handle_not_found().map(|_: i32| None),\n         };\n         let metadata = file.metadata();"}]}