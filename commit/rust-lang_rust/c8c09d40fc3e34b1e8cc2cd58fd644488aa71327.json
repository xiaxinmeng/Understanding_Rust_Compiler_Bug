{"sha": "c8c09d40fc3e34b1e8cc2cd58fd644488aa71327", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YzA5ZDQwZmMzZTM0YjFlOGNjMmNkNThmZDY0NDQ4OGFhNzEzMjc=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-08T22:34:10Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-08-12T17:54:21Z"}, "message": "Reorganise Select traits to not expose internal runtime types. Close #5160. Pending #8215.", "tree": {"sha": "5abd079db59371e46d89479329867c3e96e715f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5abd079db59371e46d89479329867c3e96e715f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327", "html_url": "https://github.com/rust-lang/rust/commit/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee5cfb0c2dae046bac18e42231074d5063b1e740", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee5cfb0c2dae046bac18e42231074d5063b1e740", "html_url": "https://github.com/rust-lang/rust/commit/ee5cfb0c2dae046bac18e42231074d5063b1e740"}], "stats": {"total": 661, "additions": 348, "deletions": 313}, "files": [{"sha": "f43d1c74eaec82158e3109e7b0cebbcc2a939680", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=c8c09d40fc3e34b1e8cc2cd58fd644488aa71327", "patch": "@@ -18,7 +18,8 @@ use kinds::Send;\n use rt;\n use rt::sched::Scheduler;\n use rt::local::Local;\n-use rt::select::{Select, SelectPort};\n+use rt::select::{SelectInner, SelectPortInner};\n+use select::{Select, SelectPort};\n use unstable::atomics::{AtomicUint, AtomicOption, Acquire, Relaxed, SeqCst};\n use unstable::sync::UnsafeAtomicRcBox;\n use util::Void;\n@@ -215,7 +216,7 @@ impl<T> PortOne<T> {\n     }\n }\n \n-impl<T> Select for PortOne<T> {\n+impl<T> SelectInner for PortOne<T> {\n     #[inline] #[cfg(not(test))]\n     fn optimistic_check(&mut self) -> bool {\n         unsafe { (*self.packet()).state.load(Acquire) == STATE_ONE }\n@@ -318,7 +319,9 @@ impl<T> Select for PortOne<T> {\n     }\n }\n \n-impl<T> SelectPort<T> for PortOne<T> {\n+impl<T> Select for PortOne<T> { }\n+\n+impl<T> SelectPortInner<T> for PortOne<T> {\n     fn recv_ready(self) -> Option<T> {\n         let mut this = self;\n         let packet = this.packet();\n@@ -349,6 +352,8 @@ impl<T> SelectPort<T> for PortOne<T> {\n     }\n }\n \n+impl<T> SelectPort<T> for PortOne<T> { }\n+\n impl<T> Peekable<T> for PortOne<T> {\n     fn peek(&self) -> bool {\n         unsafe {\n@@ -513,7 +518,7 @@ impl<T> Peekable<T> for Port<T> {\n // of them, but a &Port<T> should also be selectable so you can select2 on it\n // alongside a PortOne<U> without passing the port by value in recv_ready.\n \n-impl<'self, T> Select for &'self Port<T> {\n+impl<'self, T> SelectInner for &'self Port<T> {\n     #[inline]\n     fn optimistic_check(&mut self) -> bool {\n         do self.next.with_mut_ref |pone| { pone.optimistic_check() }\n@@ -531,7 +536,9 @@ impl<'self, T> Select for &'self Port<T> {\n     }\n }\n \n-impl<T> Select for Port<T> {\n+impl<'self, T> Select for &'self Port<T> { }\n+\n+impl<T> SelectInner for Port<T> {\n     #[inline]\n     fn optimistic_check(&mut self) -> bool {\n         (&*self).optimistic_check()\n@@ -548,7 +555,9 @@ impl<T> Select for Port<T> {\n     }\n }\n \n-impl<'self, T> SelectPort<T> for &'self Port<T> {\n+impl<T> Select for Port<T> { }\n+\n+impl<'self, T> SelectPortInner<T> for &'self Port<T> {\n     fn recv_ready(self) -> Option<T> {\n         match self.next.take().recv_ready() {\n             Some(StreamPayload { val, next }) => {\n@@ -560,6 +569,8 @@ impl<'self, T> SelectPort<T> for &'self Port<T> {\n     }\n }\n \n+impl<'self, T> SelectPort<T> for &'self Port<T> { }\n+\n pub struct SharedChan<T> {\n     // Just like Chan, but a shared AtomicOption instead of Cell\n     priv next: UnsafeAtomicRcBox<AtomicOption<StreamChanOne<T>>>"}, {"sha": "3a991e92b0b5f1c421dd48772e01c07e6d74ed5f", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=c8c09d40fc3e34b1e8cc2cd58fd644488aa71327", "patch": "@@ -142,8 +142,7 @@ pub mod tube;\n /// Simple reimplementation of core::comm\n pub mod comm;\n \n-/// Routines for select()ing on pipes.\n-pub mod select;\n+mod select;\n \n // FIXME #5248 shouldn't be pub\n /// The runtime needs to be able to put a pointer into thread-local storage."}, {"sha": "19a4948af3c5ae8e8582536b9776ef999127b982", "filename": "src/libstd/rt/select.rs", "status": "modified", "additions": 5, "deletions": 305, "changes": 310, "blob_url": "https://github.com/rust-lang/rust/blob/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/src%2Flibstd%2Frt%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/src%2Flibstd%2Frt%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fselect.rs?ref=c8c09d40fc3e34b1e8cc2cd58fd644488aa71327", "patch": "@@ -8,14 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use option::*;\n-// use either::{Either, Left, Right};\n+//! Module for private, abstraction-leaking select traits. Wrapped in std::select.\n+\n use rt::kill::BlockedTask;\n use rt::sched::Scheduler;\n-use rt::local::Local;\n+use option::Option;\n \n-/// Trait for message-passing primitives that can be select()ed on.\n-pub trait Select {\n+pub trait SelectInner {\n     // Returns true if data was available.\n     fn optimistic_check(&mut self) -> bool;\n     // Returns true if data was available. If so, shall also wake() the task.\n@@ -24,305 +23,6 @@ pub trait Select {\n     fn unblock_from(&mut self) -> bool;\n }\n \n-/// Trait for message-passing primitives that can use the select2() convenience wrapper.\n-// (This is separate from the above trait to enable heterogeneous lists of ports\n-// that implement Select on different types to use select().)\n-pub trait SelectPort<T> : Select {\n+pub trait SelectPortInner<T> {\n     fn recv_ready(self) -> Option<T>;\n }\n-\n-/// Receive a message from any one of many ports at once.\n-pub fn select<A: Select>(ports: &mut [A]) -> uint {\n-    if ports.is_empty() {\n-        fail!(\"can't select on an empty list\");\n-    }\n-\n-    for (index, port) in ports.mut_iter().enumerate() {\n-        if port.optimistic_check() {\n-            return index;\n-        }\n-    }\n-\n-    // If one of the ports already contains data when we go to block on it, we\n-    // don't bother enqueueing on the rest of them, so we shouldn't bother\n-    // unblocking from it either. This is just for efficiency, not correctness.\n-    // (If not, we need to unblock from all of them. Length is a placeholder.)\n-    let mut ready_index = ports.len();\n-\n-    let sched = Local::take::<Scheduler>();\n-    do sched.deschedule_running_task_and_then |sched, task| {\n-        let task_handles = task.make_selectable(ports.len());\n-\n-        for (index, (port, task_handle)) in\n-                ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n-            // If one of the ports has data by now, it will wake the handle.\n-            if port.block_on(sched, task_handle) {\n-                ready_index = index;\n-                break;\n-            }\n-        }\n-    }\n-\n-    // Task resumes. Now unblock ourselves from all the ports we blocked on.\n-    // If the success index wasn't reset, 'take' will just take all of them.\n-    // Iterate in reverse so the 'earliest' index that's ready gets returned.\n-    for (index, port) in ports.mut_slice(0, ready_index).mut_rev_iter().enumerate() {\n-        if port.unblock_from() {\n-            ready_index = index;\n-        }\n-    }\n-\n-    assert!(ready_index < ports.len());\n-    return ready_index;\n-}\n-\n-/* FIXME(#5121, #7914) This all should be legal, but rust is not clever enough yet.\n-\n-impl <'self> Select for &'self mut Select {\n-    fn optimistic_check(&mut self) -> bool { self.optimistic_check() }\n-    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n-        self.block_on(sched, task)\n-    }\n-    fn unblock_from(&mut self) -> bool { self.unblock_from() }\n-}\n-\n-pub fn select2<TA, A: SelectPort<TA>, TB, B: SelectPort<TB>>(mut a: A, mut b: B)\n-        -> Either<(Option<TA>, B), (A, Option<TB>)> {\n-    let result = {\n-        let mut ports = [&mut a as &mut Select, &mut b as &mut Select];\n-        select(ports)\n-    };\n-    match result {\n-        0 => Left ((a.recv_ready(), b)),\n-        1 => Right((a, b.recv_ready())),\n-        x => fail!(\"impossible case in select2: %?\", x)\n-    }\n-}\n-\n-*/\n-\n-#[cfg(test)]\n-mod test {\n-    use super::*;\n-    use option::*;\n-    use rt::comm::*;\n-    use rt::test::*;\n-    use vec::*;\n-    use comm::GenericChan;\n-    use task;\n-    use cell::Cell;\n-    use iterator::{Iterator, range};\n-\n-    #[test] #[ignore(cfg(windows))] #[should_fail]\n-    fn select_doesnt_get_trolled() {\n-        select::<PortOne<()>>([]);\n-    }\n-\n-    /* non-blocking select tests */\n-\n-    #[cfg(test)]\n-    fn select_helper(num_ports: uint, send_on_chans: &[uint]) {\n-        // Unfortunately this does not actually test the block_on early-break\n-        // codepath in select -- racing between the sender and the receiver in\n-        // separate tasks is necessary to get around the optimistic check.\n-        let (ports, chans) = unzip(from_fn(num_ports, |_| oneshot::<()>()));\n-        let mut dead_chans = ~[];\n-        let mut ports = ports;\n-        for (i, chan) in chans.move_iter().enumerate() {\n-            if send_on_chans.contains(&i) {\n-                chan.send(());\n-            } else {\n-                dead_chans.push(chan);\n-            }\n-        }\n-        let ready_index = select(ports);\n-        assert!(send_on_chans.contains(&ready_index));\n-        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n-        let _ = dead_chans;\n-\n-        // Same thing with streams instead.\n-        // FIXME(#7971): This should be in a macro but borrowck isn't smart enough.\n-        let (ports, chans) = unzip(from_fn(num_ports, |_| stream::<()>()));\n-        let mut dead_chans = ~[];\n-        let mut ports = ports;\n-        for (i, chan) in chans.move_iter().enumerate() {\n-            if send_on_chans.contains(&i) {\n-                chan.send(());\n-            } else {\n-                dead_chans.push(chan);\n-            }\n-        }\n-        let ready_index = select(ports);\n-        assert!(send_on_chans.contains(&ready_index));\n-        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n-        let _ = dead_chans;\n-    }\n-\n-    #[test]\n-    fn select_one() {\n-        do run_in_newsched_task { select_helper(1, [0]) }\n-    }\n-\n-    #[test]\n-    fn select_two() {\n-        // NB. I would like to have a test that tests the first one that is\n-        // ready is the one that's returned, but that can't be reliably tested\n-        // with the randomized behaviour of optimistic_check.\n-        do run_in_newsched_task { select_helper(2, [1]) }\n-        do run_in_newsched_task { select_helper(2, [0]) }\n-        do run_in_newsched_task { select_helper(2, [1,0]) }\n-    }\n-\n-    #[test]\n-    fn select_a_lot() {\n-        do run_in_newsched_task { select_helper(12, [7,8,9]) }\n-    }\n-\n-    #[test]\n-    fn select_stream() {\n-        use util;\n-        use comm::GenericChan;\n-        use iter::Times;\n-\n-        // Sends 10 buffered packets, and uses select to retrieve them all.\n-        // Puts the port in a different spot in the vector each time.\n-        do run_in_newsched_task {\n-            let (ports, _) = unzip(from_fn(10, |_| stream()));\n-            let (port, chan) = stream();\n-            do 10.times { chan.send(31337); }\n-            let mut ports = ports;\n-            let mut port = Some(port);\n-            let order = [5u,0,4,3,2,6,9,8,7,1];\n-            for &index in order.iter() {\n-                // put the port in the vector at any index\n-                util::swap(port.get_mut_ref(), &mut ports[index]);\n-                assert!(select(ports) == index);\n-                // get it back out\n-                util::swap(port.get_mut_ref(), &mut ports[index]);\n-                // NB. Not recv(), because optimistic_check randomly fails.\n-                assert!(port.get_ref().recv_ready().unwrap() == 31337);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn select_unkillable() {\n-        do run_in_newsched_task {\n-            do task::unkillable { select_helper(2, [1]) }\n-        }\n-    }\n-\n-    /* blocking select tests */\n-\n-    #[test]\n-    fn select_blocking() {\n-        select_blocking_helper(true);\n-        select_blocking_helper(false);\n-\n-        fn select_blocking_helper(killable: bool) {\n-            do run_in_newsched_task {\n-                let (p1,_c) = oneshot();\n-                let (p2,c2) = oneshot();\n-                let mut ports = [p1,p2];\n-\n-                let (p3,c3) = oneshot();\n-                let (p4,c4) = oneshot();\n-\n-                let x = Cell::new((c2, p3, c4));\n-                do task::spawn {\n-                    let (c2, p3, c4) = x.take();\n-                    p3.recv();   // handshake parent\n-                    c4.send(()); // normal receive\n-                    task::yield();\n-                    c2.send(()); // select receive\n-                }\n-\n-                // Try to block before child sends on c2.\n-                c3.send(());\n-                p4.recv();\n-                if killable {\n-                    assert!(select(ports) == 1);\n-                } else {\n-                    do task::unkillable { assert!(select(ports) == 1); }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn select_racing_senders() {\n-        static NUM_CHANS: uint = 10;\n-\n-        select_racing_senders_helper(true,  ~[0,1,2,3,4,5,6,7,8,9]);\n-        select_racing_senders_helper(false, ~[0,1,2,3,4,5,6,7,8,9]);\n-        select_racing_senders_helper(true,  ~[0,1,2]);\n-        select_racing_senders_helper(false, ~[0,1,2]);\n-        select_racing_senders_helper(true,  ~[3,4,5,6]);\n-        select_racing_senders_helper(false, ~[3,4,5,6]);\n-        select_racing_senders_helper(true,  ~[7,8,9]);\n-        select_racing_senders_helper(false, ~[7,8,9]);\n-\n-        fn select_racing_senders_helper(killable: bool, send_on_chans: ~[uint]) {\n-            use rt::test::spawntask_random;\n-            use iter::Times;\n-\n-            do run_in_newsched_task {\n-                // A bit of stress, since ordinarily this is just smoke and mirrors.\n-                do 4.times {\n-                    let send_on_chans = send_on_chans.clone();\n-                    do task::spawn {\n-                        let mut ports = ~[];\n-                        for i in range(0u, NUM_CHANS) {\n-                            let (p,c) = oneshot();\n-                            ports.push(p);\n-                            if send_on_chans.contains(&i) {\n-                                let c = Cell::new(c);\n-                                do spawntask_random {\n-                                    task::yield();\n-                                    c.take().send(());\n-                                }\n-                            }\n-                        }\n-                        // nondeterministic result, but should succeed\n-                        if killable {\n-                            select(ports);\n-                        } else {\n-                            do task::unkillable { select(ports); }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test] #[ignore(cfg(windows))]\n-    fn select_killed() {\n-        do run_in_newsched_task {\n-            let (success_p, success_c) = oneshot::<bool>();\n-            let success_c = Cell::new(success_c);\n-            do task::try {\n-                let success_c = Cell::new(success_c.take());\n-                do task::unkillable {\n-                    let (p,c) = oneshot();\n-                    let c = Cell::new(c);\n-                    do task::spawn {\n-                        let (dead_ps, dead_cs) = unzip(from_fn(5, |_| oneshot::<()>()));\n-                        let mut ports = dead_ps;\n-                        select(ports); // should get killed; nothing should leak\n-                        c.take().send(()); // must not happen\n-                        // Make sure dead_cs doesn't get closed until after select.\n-                        let _ = dead_cs;\n-                    }\n-                    do task::spawn {\n-                        fail!(); // should kill sibling awake\n-                    }\n-\n-                    // wait for killed selector to close (NOT send on) its c.\n-                    // hope to send 'true'.\n-                    success_c.take().send(p.try_recv().is_none());\n-                }\n-            };\n-            assert!(success_p.recv());\n-        }\n-    }\n-}"}, {"sha": "2053c971bceff9a300b292d8fa51549610df87d3", "filename": "src/libstd/select.rs", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/src%2Flibstd%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/src%2Flibstd%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fselect.rs?ref=c8c09d40fc3e34b1e8cc2cd58fd644488aa71327", "patch": "@@ -0,0 +1,324 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use container::Container;\n+use iterator::Iterator;\n+use option::*;\n+// use either::{Either, Left, Right};\n+// use rt::kill::BlockedTask;\n+use rt::sched::Scheduler;\n+use rt::select::{SelectInner, SelectPortInner};\n+use rt::local::Local;\n+use vec::{OwnedVector, MutableVector};\n+\n+/// Trait for message-passing primitives that can be select()ed on.\n+pub trait Select : SelectInner { }\n+\n+/// Trait for message-passing primitives that can use the select2() convenience wrapper.\n+// (This is separate from the above trait to enable heterogeneous lists of ports\n+// that implement Select on different types to use select().)\n+pub trait SelectPort<T> : SelectPortInner<T> { }\n+\n+/// Receive a message from any one of many ports at once. Returns the index of the\n+/// port whose data is ready. (If multiple are ready, returns the lowest index.)\n+pub fn select<A: Select>(ports: &mut [A]) -> uint {\n+    if ports.is_empty() {\n+        fail!(\"can't select on an empty list\");\n+    }\n+\n+    for (index, port) in ports.mut_iter().enumerate() {\n+        if port.optimistic_check() {\n+            return index;\n+        }\n+    }\n+\n+    // If one of the ports already contains data when we go to block on it, we\n+    // don't bother enqueueing on the rest of them, so we shouldn't bother\n+    // unblocking from it either. This is just for efficiency, not correctness.\n+    // (If not, we need to unblock from all of them. Length is a placeholder.)\n+    let mut ready_index = ports.len();\n+\n+    let sched = Local::take::<Scheduler>();\n+    do sched.deschedule_running_task_and_then |sched, task| {\n+        let task_handles = task.make_selectable(ports.len());\n+\n+        for (index, (port, task_handle)) in\n+                ports.mut_iter().zip(task_handles.move_iter()).enumerate() {\n+            // If one of the ports has data by now, it will wake the handle.\n+            if port.block_on(sched, task_handle) {\n+                ready_index = index;\n+                break;\n+            }\n+        }\n+    }\n+\n+    // Task resumes. Now unblock ourselves from all the ports we blocked on.\n+    // If the success index wasn't reset, 'take' will just take all of them.\n+    // Iterate in reverse so the 'earliest' index that's ready gets returned.\n+    for (index, port) in ports.mut_slice(0, ready_index).mut_rev_iter().enumerate() {\n+        if port.unblock_from() {\n+            ready_index = index;\n+        }\n+    }\n+\n+    assert!(ready_index < ports.len());\n+    return ready_index;\n+}\n+\n+/* FIXME(#5121, #7914) This all should be legal, but rust is not clever enough yet.\n+\n+impl <'self> Select for &'self mut Select {\n+    fn optimistic_check(&mut self) -> bool { self.optimistic_check() }\n+    fn block_on(&mut self, sched: &mut Scheduler, task: BlockedTask) -> bool {\n+        self.block_on(sched, task)\n+    }\n+    fn unblock_from(&mut self) -> bool { self.unblock_from() }\n+}\n+\n+pub fn select2<TA, A: SelectPort<TA>, TB, B: SelectPort<TB>>(mut a: A, mut b: B)\n+        -> Either<(Option<TA>, B), (A, Option<TB>)> {\n+    let result = {\n+        let mut ports = [&mut a as &mut Select, &mut b as &mut Select];\n+        select(ports)\n+    };\n+    match result {\n+        0 => Left ((a.recv_ready(), b)),\n+        1 => Right((a, b.recv_ready())),\n+        x => fail!(\"impossible case in select2: %?\", x)\n+    }\n+}\n+\n+*/\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use clone::Clone;\n+    use iter::Times;\n+    use option::*;\n+    use rt::comm::*;\n+    use rt::test::*;\n+    use vec::*;\n+    use comm::GenericChan;\n+    use task;\n+    use cell::Cell;\n+    use iterator::{Iterator, range};\n+\n+    #[test] #[ignore(cfg(windows))] #[should_fail]\n+    fn select_doesnt_get_trolled() {\n+        select::<PortOne<()>>([]);\n+    }\n+\n+    /* non-blocking select tests */\n+\n+    #[cfg(test)]\n+    fn select_helper(num_ports: uint, send_on_chans: &[uint]) {\n+        // Unfortunately this does not actually test the block_on early-break\n+        // codepath in select -- racing between the sender and the receiver in\n+        // separate tasks is necessary to get around the optimistic check.\n+        let (ports, chans) = unzip(from_fn(num_ports, |_| oneshot::<()>()));\n+        let mut dead_chans = ~[];\n+        let mut ports = ports;\n+        for (i, chan) in chans.move_iter().enumerate() {\n+            if send_on_chans.contains(&i) {\n+                chan.send(());\n+            } else {\n+                dead_chans.push(chan);\n+            }\n+        }\n+        let ready_index = select(ports);\n+        assert!(send_on_chans.contains(&ready_index));\n+        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n+        let _ = dead_chans;\n+\n+        // Same thing with streams instead.\n+        // FIXME(#7971): This should be in a macro but borrowck isn't smart enough.\n+        let (ports, chans) = unzip(from_fn(num_ports, |_| stream::<()>()));\n+        let mut dead_chans = ~[];\n+        let mut ports = ports;\n+        for (i, chan) in chans.move_iter().enumerate() {\n+            if send_on_chans.contains(&i) {\n+                chan.send(());\n+            } else {\n+                dead_chans.push(chan);\n+            }\n+        }\n+        let ready_index = select(ports);\n+        assert!(send_on_chans.contains(&ready_index));\n+        assert!(ports.swap_remove(ready_index).recv_ready().is_some());\n+        let _ = dead_chans;\n+    }\n+\n+    #[test]\n+    fn select_one() {\n+        do run_in_newsched_task { select_helper(1, [0]) }\n+    }\n+\n+    #[test]\n+    fn select_two() {\n+        // NB. I would like to have a test that tests the first one that is\n+        // ready is the one that's returned, but that can't be reliably tested\n+        // with the randomized behaviour of optimistic_check.\n+        do run_in_newsched_task { select_helper(2, [1]) }\n+        do run_in_newsched_task { select_helper(2, [0]) }\n+        do run_in_newsched_task { select_helper(2, [1,0]) }\n+    }\n+\n+    #[test]\n+    fn select_a_lot() {\n+        do run_in_newsched_task { select_helper(12, [7,8,9]) }\n+    }\n+\n+    #[test]\n+    fn select_stream() {\n+        use util;\n+        use comm::GenericChan;\n+\n+        // Sends 10 buffered packets, and uses select to retrieve them all.\n+        // Puts the port in a different spot in the vector each time.\n+        do run_in_newsched_task {\n+            let (ports, _) = unzip(from_fn(10, |_| stream()));\n+            let (port, chan) = stream();\n+            do 10.times { chan.send(31337); }\n+            let mut ports = ports;\n+            let mut port = Some(port);\n+            let order = [5u,0,4,3,2,6,9,8,7,1];\n+            for &index in order.iter() {\n+                // put the port in the vector at any index\n+                util::swap(port.get_mut_ref(), &mut ports[index]);\n+                assert!(select(ports) == index);\n+                // get it back out\n+                util::swap(port.get_mut_ref(), &mut ports[index]);\n+                // NB. Not recv(), because optimistic_check randomly fails.\n+                assert!(port.get_ref().recv_ready().unwrap() == 31337);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn select_unkillable() {\n+        do run_in_newsched_task {\n+            do task::unkillable { select_helper(2, [1]) }\n+        }\n+    }\n+\n+    /* blocking select tests */\n+\n+    #[test]\n+    fn select_blocking() {\n+        select_blocking_helper(true);\n+        select_blocking_helper(false);\n+\n+        fn select_blocking_helper(killable: bool) {\n+            do run_in_newsched_task {\n+                let (p1,_c) = oneshot();\n+                let (p2,c2) = oneshot();\n+                let mut ports = [p1,p2];\n+\n+                let (p3,c3) = oneshot();\n+                let (p4,c4) = oneshot();\n+\n+                let x = Cell::new((c2, p3, c4));\n+                do task::spawn {\n+                    let (c2, p3, c4) = x.take();\n+                    p3.recv();   // handshake parent\n+                    c4.send(()); // normal receive\n+                    task::yield();\n+                    c2.send(()); // select receive\n+                }\n+\n+                // Try to block before child sends on c2.\n+                c3.send(());\n+                p4.recv();\n+                if killable {\n+                    assert!(select(ports) == 1);\n+                } else {\n+                    do task::unkillable { assert!(select(ports) == 1); }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn select_racing_senders() {\n+        static NUM_CHANS: uint = 10;\n+\n+        select_racing_senders_helper(true,  ~[0,1,2,3,4,5,6,7,8,9]);\n+        select_racing_senders_helper(false, ~[0,1,2,3,4,5,6,7,8,9]);\n+        select_racing_senders_helper(true,  ~[0,1,2]);\n+        select_racing_senders_helper(false, ~[0,1,2]);\n+        select_racing_senders_helper(true,  ~[3,4,5,6]);\n+        select_racing_senders_helper(false, ~[3,4,5,6]);\n+        select_racing_senders_helper(true,  ~[7,8,9]);\n+        select_racing_senders_helper(false, ~[7,8,9]);\n+\n+        fn select_racing_senders_helper(killable: bool, send_on_chans: ~[uint]) {\n+            use rt::test::spawntask_random;\n+\n+            do run_in_newsched_task {\n+                // A bit of stress, since ordinarily this is just smoke and mirrors.\n+                do 4.times {\n+                    let send_on_chans = send_on_chans.clone();\n+                    do task::spawn {\n+                        let mut ports = ~[];\n+                        for i in range(0u, NUM_CHANS) {\n+                            let (p,c) = oneshot();\n+                            ports.push(p);\n+                            if send_on_chans.contains(&i) {\n+                                let c = Cell::new(c);\n+                                do spawntask_random {\n+                                    task::yield();\n+                                    c.take().send(());\n+                                }\n+                            }\n+                        }\n+                        // nondeterministic result, but should succeed\n+                        if killable {\n+                            select(ports);\n+                        } else {\n+                            do task::unkillable { select(ports); }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test] #[ignore(cfg(windows))]\n+    fn select_killed() {\n+        do run_in_newsched_task {\n+            let (success_p, success_c) = oneshot::<bool>();\n+            let success_c = Cell::new(success_c);\n+            do task::try {\n+                let success_c = Cell::new(success_c.take());\n+                do task::unkillable {\n+                    let (p,c) = oneshot();\n+                    let c = Cell::new(c);\n+                    do task::spawn {\n+                        let (dead_ps, dead_cs) = unzip(from_fn(5, |_| oneshot::<()>()));\n+                        let mut ports = dead_ps;\n+                        select(ports); // should get killed; nothing should leak\n+                        c.take().send(()); // must not happen\n+                        // Make sure dead_cs doesn't get closed until after select.\n+                        let _ = dead_cs;\n+                    }\n+                    do task::spawn {\n+                        fail!(); // should kill sibling awake\n+                    }\n+\n+                    // wait for killed selector to close (NOT send on) its c.\n+                    // hope to send 'true'.\n+                    success_c.take().send(p.try_recv().is_none());\n+                }\n+            };\n+            assert!(success_p.recv());\n+        }\n+    }\n+}"}, {"sha": "c4bd0a6d043544c8807002675b6e93fb1ae5f369", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8c09d40fc3e34b1e8cc2cd58fd644488aa71327/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=c8c09d40fc3e34b1e8cc2cd58fd644488aa71327", "patch": "@@ -164,6 +164,7 @@ pub mod trie;\n \n pub mod task;\n pub mod comm;\n+pub mod select;\n pub mod local_data;\n \n "}]}