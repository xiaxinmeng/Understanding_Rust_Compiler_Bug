{"sha": "476ea9ef1c0ba7250e369a2ec7205506b09474b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NmVhOWVmMWMwYmE3MjUwZTM2OWEyZWM3MjA1NTA2YjA5NDc0Yjc=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-05-13T05:37:04Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-05-13T05:52:04Z"}, "message": "Always try to project predicates when finding auto traits in rustdoc\n\nFixes #60726\n\nPrevious, AutoTraitFinder would only try to project predicates when the\npredicate type contained an inference variable. When finding auto\ntraits, we only project to try to unify inference variables - we don't\notherwise learn any new information about the required bounds.\n\nHowever, this lead to failing to properly generate a negative auto trait\nimpl (indicating that a type never implements a certain auto trait) in\nthe following unusual scenario:\n\nIn almost all cases, a type has an (implicit) negative impl of an auto\ntrait due some other type having an explicit *negative* impl of that\nauto trait. For example:\n\nstruct MyType<T> {\n    field: *const T\n}\n\nhas an implicit 'impl<T> !Send for MyType<T>', due to the explicit\nnegative impl (in libcore) 'impl<T: ?Sized> !Send for *const T'.\n\nHowever, as exposed by the 'abi_stable' crate, this isn't always the\ncase. This minimzed example shows how a type can never implement\n'Send', due to a projection error:\n\n```\npub struct True;\npub struct False;\n\npub trait MyTrait {\n    type Project;\n}\n\npub struct MyStruct<T> {\n    field: T\n}\n\nimpl MyTrait for u8 {\n    type Project = False;\n}\n\nunsafe impl<T> Send for MyStruct<T>\n    where T: MyTrait<Project=True> {}\n\npub struct Wrapper {\n    inner: MyStruct<u8>\n}\n```\n\nIn this example, `<u8 as MyTrait>::Project == True'\nmust hold for 'MyStruct<u8>: Send' to hold.\nHowever, '<u8 as MyTrait>::Project == False' holds instead\n\nTo properly account for this unusual case, we need to call\n'poly_project_and_unify' on *all* predicates, not just those with\ninference variables. This ensures that we catch the projection error\nthat occurs above, and don't incorrectly determine that 'Wrapper: Send'\nholds.", "tree": {"sha": "5f62732311572962485a06e89f16d519b5ab5b4e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f62732311572962485a06e89f16d519b5ab5b4e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/476ea9ef1c0ba7250e369a2ec7205506b09474b7", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAlzZBgcACgkQtAh+UQ6Y\nsWRVEQ/8CuewXu2Aj1ENyLIKrEPKXNsWfUJPURh1+aKt+Aa582seDNpeFvVoYBdV\noohg/j6hWrNIJmA2Hq62y7oggSTd6aMmm8KTcXs1nFIZD1wVv74rR7dMoS4YWyt3\nUnDajnEmABPvt8iZtHkuCya/pZ37lNfa2zdfr5/7qNUVz0g965fSM17FFQmy7HJf\nylZdFl0/PPTNSUrIjaeccRnYqOLhOxWyvI9JyFJmtknnoxejZgzVxkJ44Y3pDA83\nJRFBWtHozHt9a/2p8FHkO14WAMp+seEcV6rXBcqDCjLkj3Y6xWCuHwqjGYe2pvB6\nAQfCBM2VViXmr8ZeE0KTpfGhE0ggOz4W1NSz9sexBN0+NOAFAdt87tGS4UGWOWg0\nH2QnDn+WcwDWpoQNm7beLY7apJlKIHASbInbKWa5/sTl2LpeP+/rbeSyrdLYZDR6\nEk/arJ9AkGXMCKC5ohLnAirhZT/afM9/NPRCjHBlpaROH4AybIp2q7LXZ2yojBJq\ncRhQJEHir0UtNU9UQsUQSWrDQXI63KlC2bX7Vc0FGXor9QbutlOPKVcTYqkGkoeC\nHPaIN/aa2FlLcXKxHmwLsh9RYBqP2jiP4q0GZjeyHsPK6kGsEKwEzKyemO9w1ert\nwd04SUDl6rzbhreOwhLzHjjGIMU9OBfv24PVwuYZXzPxZa5+Vgk=\n=rC0S\n-----END PGP SIGNATURE-----", "payload": "tree 5f62732311572962485a06e89f16d519b5ab5b4e\nparent af39a1fd73de7f4b9c895d3377e03f8fa3221449\nauthor Aaron Hill <aa1ronham@gmail.com> 1557725824 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1557726724 -0400\n\nAlways try to project predicates when finding auto traits in rustdoc\n\nFixes #60726\n\nPrevious, AutoTraitFinder would only try to project predicates when the\npredicate type contained an inference variable. When finding auto\ntraits, we only project to try to unify inference variables - we don't\notherwise learn any new information about the required bounds.\n\nHowever, this lead to failing to properly generate a negative auto trait\nimpl (indicating that a type never implements a certain auto trait) in\nthe following unusual scenario:\n\nIn almost all cases, a type has an (implicit) negative impl of an auto\ntrait due some other type having an explicit *negative* impl of that\nauto trait. For example:\n\nstruct MyType<T> {\n    field: *const T\n}\n\nhas an implicit 'impl<T> !Send for MyType<T>', due to the explicit\nnegative impl (in libcore) 'impl<T: ?Sized> !Send for *const T'.\n\nHowever, as exposed by the 'abi_stable' crate, this isn't always the\ncase. This minimzed example shows how a type can never implement\n'Send', due to a projection error:\n\n```\npub struct True;\npub struct False;\n\npub trait MyTrait {\n    type Project;\n}\n\npub struct MyStruct<T> {\n    field: T\n}\n\nimpl MyTrait for u8 {\n    type Project = False;\n}\n\nunsafe impl<T> Send for MyStruct<T>\n    where T: MyTrait<Project=True> {}\n\npub struct Wrapper {\n    inner: MyStruct<u8>\n}\n```\n\nIn this example, `<u8 as MyTrait>::Project == True'\nmust hold for 'MyStruct<u8>: Send' to hold.\nHowever, '<u8 as MyTrait>::Project == False' holds instead\n\nTo properly account for this unusual case, we need to call\n'poly_project_and_unify' on *all* predicates, not just those with\ninference variables. This ensures that we catch the projection error\nthat occurs above, and don't incorrectly determine that 'Wrapper: Send'\nholds.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/476ea9ef1c0ba7250e369a2ec7205506b09474b7", "html_url": "https://github.com/rust-lang/rust/commit/476ea9ef1c0ba7250e369a2ec7205506b09474b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/476ea9ef1c0ba7250e369a2ec7205506b09474b7/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af39a1fd73de7f4b9c895d3377e03f8fa3221449", "url": "https://api.github.com/repos/rust-lang/rust/commits/af39a1fd73de7f4b9c895d3377e03f8fa3221449", "html_url": "https://github.com/rust-lang/rust/commit/af39a1fd73de7f4b9c895d3377e03f8fa3221449"}], "stats": {"total": 120, "additions": 103, "deletions": 17}, "files": [{"sha": "2fa896962daf9f6c5442241ee41188b62bdd0409", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 68, "deletions": 17, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/476ea9ef1c0ba7250e369a2ec7205506b09474b7/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476ea9ef1c0ba7250e369a2ec7205506b09474b7/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=476ea9ef1c0ba7250e369a2ec7205506b09474b7", "patch": "@@ -700,22 +700,64 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                             }\n                     }\n \n-                    // We can only call poly_project_and_unify_type when our predicate's\n-                    // Ty contains an inference variable - otherwise, there won't be anything to\n-                    // unify\n-                    if p.ty().skip_binder().has_infer_types() {\n-                        debug!(\"Projecting and unifying projection predicate {:?}\",\n-                               predicate);\n-                        match poly_project_and_unify_type(select, &obligation.with(p)) {\n-                            Err(e) => {\n-                                debug!(\n-                                    \"evaluate_nested_obligations: Unable to unify predicate \\\n-                                     '{:?}' '{:?}', bailing out\",\n-                                    ty, e\n-                                );\n-                                return false;\n-                            }\n-                            Ok(Some(v)) => {\n+                    // There are three possible cases when we project a predicate:\n+                    //\n+                    // 1. We encounter an error. This means that it's impossible for\n+                    // our current type to implement the auto trait - there's bound\n+                    // that we could add to our ParamEnv that would 'fix' this kind\n+                    // of error, as it's not caused by an unimplemented type.\n+                    //\n+                    // 2. We succesfully project the predicate (Ok(Some(_))), generating\n+                    //  some subobligations. We then process these subobligations\n+                    //  like any other generated sub-obligations.\n+                    //\n+                    // 3. We receieve an 'ambiguous' result (Ok(None))\n+                    // If we were actually trying to compile a crate,\n+                    // we would need to re-process this obligation later.\n+                    // However, all we care about is finding out what bounds\n+                    // are needed for our type to implement a particular auto trait.\n+                    // We've already added this obligation to our computed ParamEnv\n+                    // above (if it was necessary). Therefore, we don't need\n+                    // to do any further processing of the obligation.\n+                    //\n+                    // Note that we *must* try to project *all* projection predicates\n+                    // we encounter, even ones without inference variable.\n+                    // This ensures that we detect any projection errors,\n+                    // which indicate that our type can *never* implement the given\n+                    // auto trait. In that case, we will generate an explicit negative\n+                    // impl (e.g. 'impl !Send for MyType'). However, we don't\n+                    // try to process any of the generated subobligations -\n+                    // they contain no new information, since we already know\n+                    // that our type implements the projected-through trait,\n+                    // and can lead to weird region issues.\n+                    //\n+                    // Normally, we'll generate a negative impl as a result of encountering\n+                    // a type with an explicit negative impl of an auto trait\n+                    // (for example, raw pointers have !Send and !Sync impls)\n+                    // However, through some **interesting** manipulations of the type\n+                    // system, it's actually possible to write a type that never\n+                    // implements an auto trait due to a projection error, not a normal\n+                    // negative impl error. To properly handle this case, we need\n+                    // to ensure that we catch any potential projection errors,\n+                    // and turn them into an explicit negative impl for our type.\n+                    debug!(\"Projecting and unifying projection predicate {:?}\",\n+                           predicate);\n+\n+                    match poly_project_and_unify_type(select, &obligation.with(p)) {\n+                        Err(e) => {\n+                            debug!(\n+                                \"evaluate_nested_obligations: Unable to unify predicate \\\n+                                 '{:?}' '{:?}', bailing out\",\n+                                ty, e\n+                            );\n+                            return false;\n+                        }\n+                        Ok(Some(v)) => {\n+                            // We only care about sub-obligations\n+                            // when we started out trying to unify\n+                            // some inference variables. See the comment above\n+                            // for more infomration\n+                            if p.ty().skip_binder().has_infer_types() {\n                                 if !self.evaluate_nested_obligations(\n                                     ty,\n                                     v.clone().iter().cloned(),\n@@ -728,7 +770,16 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                     return false;\n                                 }\n                             }\n-                            Ok(None) => {\n+                        }\n+                        Ok(None) => {\n+                            // It's ok not to make progress when hvave no inference variables -\n+                            // in that case, we were only performing unifcation to check if an\n+                            // error occured (which would indicate that it's impossible for our\n+                            // type to implement the auto trait).\n+                            // However, we should always make progress (either by generating\n+                            // subobligations or getting an error) when we started off with\n+                            // inference variables\n+                            if p.ty().skip_binder().has_infer_types() {\n                                 panic!(\"Unexpected result when selecting {:?} {:?}\", ty, obligation)\n                             }\n                         }"}, {"sha": "6acc86277385de125041e9e09f4f45c7dbadadd4", "filename": "src/test/rustdoc/issue-60726.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/476ea9ef1c0ba7250e369a2ec7205506b09474b7/src%2Ftest%2Frustdoc%2Fissue-60726.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476ea9ef1c0ba7250e369a2ec7205506b09474b7/src%2Ftest%2Frustdoc%2Fissue-60726.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-60726.rs?ref=476ea9ef1c0ba7250e369a2ec7205506b09474b7", "patch": "@@ -0,0 +1,35 @@\n+use std::marker::PhantomData;\n+\n+pub struct True;\n+pub struct False;\n+\n+pub trait InterfaceType{\n+    type Send;\n+}\n+\n+\n+pub struct FooInterface<T>(PhantomData<fn()->T>);\n+\n+impl<T> InterfaceType for FooInterface<T> {\n+    type Send=False;\n+}\n+\n+\n+pub struct DynTrait<I>{\n+    _interface:PhantomData<fn()->I>,\n+    _unsync_unsend:PhantomData<::std::rc::Rc<()>>,\n+}\n+\n+unsafe impl<I> Send for DynTrait<I>\n+where\n+    I:InterfaceType<Send=True>\n+{}\n+\n+// @has issue_60726/struct.IntoIter.html\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> !Send for \\\n+// IntoIter<T>\"\n+// @has - '//*[@id=\"synthetic-implementations-list\"]/*[@class=\"impl\"]//code' \"impl<T> !Sync for \\\n+// IntoIter<T>\"\n+pub struct IntoIter<T>{\n+    hello:DynTrait<FooInterface<T>>,\n+}"}]}