{"sha": "b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI0ZTY3NGY2ZTY2MmJjODBmMmU3YTVhMWE5ODM0ZjIxNTJmMDhkMzI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-06-28T00:41:35Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-07-17T21:56:42Z"}, "message": "librustc: Add a lint mode for unnecessary `copy` and remove a bunch of them.", "tree": {"sha": "1b567620d7ea1641fa58338b8f6e5c68bb324248", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b567620d7ea1641fa58338b8f6e5c68bb324248"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "html_url": "https://github.com/rust-lang/rust/commit/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c082658bed1877d5741f7badceb8efc3015598d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c082658bed1877d5741f7badceb8efc3015598d", "html_url": "https://github.com/rust-lang/rust/commit/8c082658bed1877d5741f7badceb8efc3015598d"}], "stats": {"total": 491, "additions": 256, "deletions": 235}, "files": [{"sha": "4ada3bcb6b591c951a74e82d192028e6e3492d79", "filename": "src/libextra/arena.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibextra%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibextra%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farena.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -177,7 +177,7 @@ impl Arena {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.pod_head.data);\n         let new_min_chunk_size = num::max(n_bytes, chunk_size);\n-        self.chunks = @mut MutCons(copy self.pod_head, self.chunks);\n+        self.chunks = @mut MutCons(self.pod_head, self.chunks);\n         self.pod_head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), true);\n \n@@ -219,7 +219,7 @@ impl Arena {\n         // Allocate a new chunk.\n         let chunk_size = at_vec::capacity(self.head.data);\n         let new_min_chunk_size = num::max(n_bytes, chunk_size);\n-        self.chunks = @mut MutCons(copy self.head, self.chunks);\n+        self.chunks = @mut MutCons(self.head, self.chunks);\n         self.head =\n             chunk(uint::next_power_of_two(new_min_chunk_size + 1u), false);\n "}, {"sha": "1ad44c5e28c9d5385925d80d27c444224bd9df4d", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -318,8 +318,12 @@ pub mod reader {\n             let TaggedDoc { tag: r_tag, doc: r_doc } =\n                 doc_at(self.parent.data, self.pos);\n             debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n-                   copy self.parent.start, copy self.parent.end,\n-                   copy self.pos, r_tag, r_doc.start, r_doc.end);\n+                   self.parent.start,\n+                   self.parent.end,\n+                   self.pos,\n+                   r_tag,\n+                   r_doc.start,\n+                   r_doc.end);\n             if r_tag != (exp_tag as uint) {\n                 fail!(\"expected EBML doc with tag %? but found tag %?\", exp_tag, r_tag);\n             }"}, {"sha": "f6516fad6b85b9a97359d4f1ad7ae6cfb9dbff3c", "filename": "src/libextra/net/ip.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibextra%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibextra%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Fip.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -240,7 +240,7 @@ pub mod v4 {\n                     err_msg: ~\"uv_ip4_name produced invalid result.\",\n                 })\n             } else {\n-                Ok(Ipv4(copy(new_addr)))\n+                Ok(Ipv4(new_addr))\n             }\n         }\n     }\n@@ -312,12 +312,10 @@ extern fn get_addr_cb(handle: *uv_getaddrinfo_t,\n                 let mut curr_addr = res;\n                 loop {\n                     let new_ip_addr = if ll::is_ipv4_addrinfo(curr_addr) {\n-                        Ipv4(copy((\n-                            *ll::addrinfo_as_sockaddr_in(curr_addr))))\n+                        Ipv4(*ll::addrinfo_as_sockaddr_in(curr_addr))\n                     }\n                     else if ll::is_ipv6_addrinfo(curr_addr) {\n-                        Ipv6(copy((\n-                            *ll::addrinfo_as_sockaddr_in6(curr_addr))))\n+                        Ipv6(*ll::addrinfo_as_sockaddr_in6(curr_addr))\n                     }\n                     else {\n                         debug!(\"curr_addr is not of family AF_INET or \\"}, {"sha": "d262304298d7c6ce59c6137fe27c3a80417c5ff9", "filename": "src/libextra/net/tcp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibextra%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibextra%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet%2Ftcp.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -682,8 +682,8 @@ fn listen_common(host_ip: ip::IpAddr,\n     // will defeat a move sigil, as is done to the host_ip\n     // arg above.. this same pattern works w/o complaint in\n     // tcp::connect (because the iotask::interact cb isn't\n-    // nested within a std::comm::listen block)\n-    let loc_ip = copy(host_ip);\n+    // nested within a core::comm::listen block)\n+    let loc_ip = host_ip;\n     do iotask::interact(iotask) |loop_ptr| {\n         unsafe {\n             match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {"}, {"sha": "670ece11dbdab8ce8405bbeaef38c011b3422e74", "filename": "src/librust/rust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrust%2Frust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrust%2Frust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -124,7 +124,7 @@ fn rustc_help() {\n fn find_cmd(command_string: &str) -> Option<Command> {\n     do COMMANDS.iter().find_ |command| {\n         command.cmd == command_string\n-    }.map_consume(|x| copy *x)\n+    }.map_consume(|x| *x)\n }\n \n fn cmd_help(args: &[~str]) -> ValidUsage {"}, {"sha": "0768d674671fc1ca3048fc274f24d0c8612c6f09", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -35,11 +35,9 @@ pub fn strip_items(crate: &ast::crate, in_cfg: in_cfg_pred)\n           fold_mod: |a,b| fold_mod(ctxt, a, b),\n           fold_block: |a,b| fold_block(ctxt, a, b),\n           fold_foreign_mod: |a,b| fold_foreign_mod(ctxt, a, b),\n-          fold_item_underscore: |a,b| {\n-            // Bad copy.\n-            fold_item_underscore(ctxt, copy a, b)\n-          },\n-          .. *fold::default_ast_fold()};\n+          fold_item_underscore: |a,b| fold_item_underscore(ctxt, a, b),\n+          .. *fold::default_ast_fold()\n+    };\n \n     let fold = fold::make_fold(precursor);\n     @fold.fold_crate(crate)"}, {"sha": "2eafc1965b2327dc67e2688a26e589e3327a5e2b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -538,14 +538,12 @@ impl<'self> EachItemContext<'self> {\n \n     fn each_item_of_module(&mut self, def_id: ast::def_id) -> bool {\n         // This item might not be in this crate. If it's not, look it up.\n-        let (_cdata, items) = if def_id.crate == self.cdata.cnum {\n-            let items = reader::get_doc(reader::Doc(self.cdata.data),\n-                                        tag_items);\n-            (self.cdata, items)\n+        let items = if def_id.crate == self.cdata.cnum {\n+            reader::get_doc(reader::Doc(self.cdata.data), tag_items)\n         } else {\n             let crate_data = (self.get_crate_data)(def_id.crate);\n             let root = reader::Doc(crate_data.data);\n-            (crate_data, reader::get_doc(root, tag_items))\n+            reader::get_doc(root, tag_items)\n         };\n \n         // Look up the item.\n@@ -717,14 +715,14 @@ pub fn maybe_get_item_ast(cdata: cmd, tcx: ty::ctxt,\n         item_path.init().to_owned()\n     };\n     match decode_inlined_item(cdata, tcx, copy path, item_doc) {\n-      Some(ref ii) => csearch::found((/*bad*/copy *ii)),\n+      Some(ref ii) => csearch::found(*ii),\n       None => {\n         match item_parent_item(item_doc) {\n           Some(did) => {\n             let did = translate_def_id(cdata, did);\n             let parent_item = lookup_item(did.node, cdata.data);\n             match decode_inlined_item(cdata, tcx, path, parent_item) {\n-              Some(ref ii) => csearch::found_parent(did, (/*bad*/copy *ii)),\n+              Some(ref ii) => csearch::found_parent(did, *ii),\n               None => csearch::not_found\n             }\n           }"}, {"sha": "1dead50b01a517af0e35597fa14a9e85243c1670", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -780,8 +780,12 @@ fn encode_info_for_method(ecx: &EncodeContext,\n     }\n \n     let mut combined_ty_params = opt_vec::Empty;\n-    for owner_generics.ty_params.iter().advance |x| { combined_ty_params.push(copy *x) }\n-    for method_generics.ty_params.iter().advance |x| { combined_ty_params.push(copy *x) }\n+    for owner_generics.ty_params.iter().advance |x| {\n+        combined_ty_params.push(copy *x)\n+    }\n+    for method_generics.ty_params.iter().advance |x| {\n+        combined_ty_params.push(copy *x)\n+    }\n     let len = combined_ty_params.len();\n     encode_type_param_bounds(ebml_w, ecx, &combined_ty_params);\n \n@@ -1392,14 +1396,14 @@ fn synthesize_crate_attrs(ecx: &EncodeContext,\n     for crate.node.attrs.iter().advance |attr| {\n         attrs.push(\n             if \"link\" != attr::get_attr_name(attr)  {\n-                copy *attr\n+                *attr\n             } else {\n                 match attr.node.value.node {\n                   meta_list(_, ref l) => {\n                     found_link_attr = true;;\n                     synthesize_link_attr(ecx, /*bad*/copy *l)\n                   }\n-                  _ => copy *attr\n+                  _ => *attr\n                 }\n             });\n     }"}, {"sha": "cc91140ffa504718a7ec387fa6a5c3e673d99e59", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -371,7 +371,10 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         match st.tcx.rcache.find(&key) {\n           Some(&tt) => return tt,\n           None => {\n-            let mut ps = PState {pos: pos ,.. copy *st};\n+            let mut ps = PState {\n+                pos: pos,\n+                .. *st\n+            };\n             let tt = parse_ty(&mut ps, conv);\n             st.tcx.rcache.insert(key, tt);\n             return tt;"}, {"sha": "558b184a75aea03174a55b1f5f34765696ad764d", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -218,15 +218,15 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                                           val(const_bool(false)),\n                                           0u, left_ty)\n                   }\n-                  ref u => (/*bad*/copy *u)\n+                  ref u => *u,\n                 }\n               }\n               ty::ty_enum(eid, _) => {\n                 for (*ty::enum_variants(cx.tcx, eid)).iter().advance |va| {\n                     match is_useful_specialized(cx, m, v, variant(va.id),\n                                                 va.args.len(), left_ty) {\n                       not_useful => (),\n-                      ref u => return (/*bad*/copy *u)\n+                      ref u => return *u,\n                     }\n                 }\n                 not_useful\n@@ -243,7 +243,7 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n                 for uint::range(0, max_len + 1) |n| {\n                   match is_useful_specialized(cx, m, v, vec(n), n, left_ty) {\n                     not_useful => (),\n-                    ref u => return (/*bad*/copy *u)\n+                    ref u => return *u,\n                   }\n                 }\n                 not_useful\n@@ -258,15 +258,15 @@ pub fn is_useful(cx: &MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n             match is_useful(cx,\n                             &m.iter().filter_map(|r| default(cx, *r)).collect::<matrix>(),\n                             v.tail()) {\n-              useful_ => useful(left_ty, /*bad*/copy *ctor),\n-              ref u => (/*bad*/copy *u)\n+              useful_ => useful(left_ty, *ctor),\n+              ref u => *u,\n             }\n           }\n         }\n       }\n       Some(ref v0_ctor) => {\n         let arity = ctor_arity(cx, v0_ctor, left_ty);\n-        is_useful_specialized(cx, m, v, /*bad*/copy *v0_ctor, arity, left_ty)\n+        is_useful_specialized(cx, m, v, *v0_ctor, arity, left_ty)\n       }\n     }\n }\n@@ -283,7 +283,7 @@ pub fn is_useful_specialized(cx: &MatchCheckCtxt,\n         cx, &ms, specialize(cx, v, &ctor, arity, lty).get());\n     match could_be_useful {\n       useful_ => useful(lty, ctor),\n-      ref u => (/*bad*/copy *u)\n+      ref u => *u,\n     }\n }\n \n@@ -355,7 +355,7 @@ pub fn missing_ctor(cx: &MatchCheckCtxt,\n             let r = pat_ctor_id(cx, r[0]);\n             for r.iter().advance |id| {\n                 if !found.contains(id) {\n-                    found.push(/*bad*/copy *id);\n+                    found.push(*id);\n                 }\n             }\n         }\n@@ -680,9 +680,8 @@ pub fn specialize(cx: &MatchCheckCtxt,\n             }\n             pat_range(lo, hi) => {\n                 let (c_lo, c_hi) = match *ctor_id {\n-                    val(ref v) => ((/*bad*/copy *v), (/*bad*/copy *v)),\n-                    range(ref lo, ref hi) =>\n-                        ((/*bad*/copy *lo), (/*bad*/copy *hi)),\n+                    val(ref v) => (*v, *v),\n+                    range(ref lo, ref hi) => (*lo, *hi),\n                     single => return Some(r.tail().to_owned()),\n                     _ => fail!(\"type error\")\n                 };"}, {"sha": "992eb28bda8df124a471290fc0a55e70e124b636", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -83,6 +83,7 @@ pub enum lint {\n     type_limits,\n     default_methods,\n     unused_unsafe,\n+    copy_implicitly_copyable,\n \n     managed_heap_memory,\n     owned_heap_memory,\n@@ -259,6 +260,14 @@ static lint_table: &'static [(&'static str, LintSpec)] = &[\n         default: warn\n     }),\n \n+    (\"copy_implicitly_copyable\",\n+     LintSpec {\n+        lint: copy_implicitly_copyable,\n+        desc: \"detect unnecessary uses of `copy` on implicitly copyable \\\n+               values\",\n+        default: warn\n+    }),\n+\n     (\"unused_variable\",\n      LintSpec {\n         lint: unused_variable,\n@@ -514,7 +523,7 @@ impl Context {\n             // item_stopping_visitor has overridden visit_fn(&fk_method(... ))\n             // to be a no-op, so manually invoke visit_fn.\n             Method(m) => {\n-                let fk = visit::fk_method(copy m.ident, &m.generics, m);\n+                let fk = visit::fk_method(m.ident, &m.generics, m);\n                 for self.visitors.iter().advance |&(orig, stopping)| {\n                     (orig.visit_fn)(&fk, &m.decl, &m.body, m.span, m.id,\n                                     (self, stopping));\n@@ -935,6 +944,26 @@ fn lint_unused_unsafe() -> visit::vt<@mut Context> {\n     })\n }\n \n+fn lint_copy_implicitly_copyable() -> visit::vt<@mut Context> {\n+    visit::mk_vt(@visit::Visitor {\n+        visit_expr: |e, (cx, vt): (@mut Context, visit::vt<@mut Context>)| {\n+            match e.node {\n+                ast::expr_copy(subexpr) => {\n+                    let ty = ty::expr_ty(cx.tcx, subexpr);\n+                    if !ty::type_moves_by_default(cx.tcx, ty) {\n+                        cx.span_lint(copy_implicitly_copyable,\n+                                     e.span,\n+                                     \"unnecessary `copy`; this value is implicitly copyable\");\n+                    }\n+                }\n+                _ => ()\n+            }\n+            visit::visit_expr(e, (cx, vt));\n+        },\n+        .. *visit::default_visitor()\n+    })\n+}\n+\n fn lint_unused_mut() -> visit::vt<@mut Context> {\n     fn check_pat(cx: &Context, p: @ast::pat) {\n         let mut used = false;\n@@ -1147,6 +1176,7 @@ pub fn check_crate(tcx: ty::ctxt, crate: @ast::crate) {\n     cx.add_lint(lint_heap());\n     cx.add_lint(lint_type_limits());\n     cx.add_lint(lint_unused_unsafe());\n+    cx.add_lint(lint_copy_implicitly_copyable());\n     cx.add_lint(lint_unused_mut());\n     cx.add_lint(lint_session());\n     cx.add_lint(lint_unnecessary_allocations());"}, {"sha": "f0ad8a339b1069a998779b18d1505b74dcebc139", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -680,7 +680,7 @@ impl Liveness {\n     */\n     pub fn live_on_exit(&self, ln: LiveNode, var: Variable)\n                         -> Option<LiveNodeKind> {\n-        self.live_on_entry(copy self.successors[*ln], var)\n+        self.live_on_entry(self.successors[*ln], var)\n     }\n \n     pub fn used_on_entry(&self, ln: LiveNode, var: Variable) -> bool {\n@@ -697,7 +697,7 @@ impl Liveness {\n \n     pub fn assigned_on_exit(&self, ln: LiveNode, var: Variable)\n                             -> Option<LiveNodeKind> {\n-        self.assigned_on_entry(copy self.successors[*ln], var)\n+        self.assigned_on_entry(self.successors[*ln], var)\n     }\n \n     pub fn indices(&self, ln: LiveNode, op: &fn(uint)) {\n@@ -768,14 +768,14 @@ impl Liveness {\n             wr.write_str(\"[ln(\");\n             wr.write_uint(*ln);\n             wr.write_str(\") of kind \");\n-            wr.write_str(fmt!(\"%?\", copy self.ir.lnks[*ln]));\n+            wr.write_str(fmt!(\"%?\", self.ir.lnks[*ln]));\n             wr.write_str(\" reads\");\n             self.write_vars(wr, ln, |idx| self.users[idx].reader );\n             wr.write_str(\"  writes\");\n             self.write_vars(wr, ln, |idx| self.users[idx].writer );\n             wr.write_str(\" \");\n             wr.write_str(\" precedes \");\n-            wr.write_str((copy self.successors[*ln]).to_str());\n+            wr.write_str((self.successors[*ln]).to_str());\n             wr.write_str(\"]\");\n         }\n     }\n@@ -813,9 +813,9 @@ impl Liveness {\n         let mut changed = false;\n         do self.indices2(ln, succ_ln) |idx, succ_idx| {\n             let users = &mut *self.users;\n-            changed |= copy_if_invalid(copy users[succ_idx].reader,\n+            changed |= copy_if_invalid(users[succ_idx].reader,\n                                        &mut users[idx].reader);\n-            changed |= copy_if_invalid(copy users[succ_idx].writer,\n+            changed |= copy_if_invalid(users[succ_idx].writer,\n                                        &mut users[idx].writer);\n             if users[succ_idx].used && !users[idx].used {\n                 users[idx].used = true;"}, {"sha": "d1ada030da4b55e2cf7fd37ab30a2fc6c03922bf", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -604,7 +604,7 @@ impl DetermineRpCtxt {\n                                        token::get_ident_interner()),\n                ast_map::node_id_to_str(self.ast_map, self.item_id,\n                                        token::get_ident_interner()),\n-               copy self.ambient_variance);\n+               self.ambient_variance);\n         let vec = do self.dep_map.find_or_insert_with(from) |_| {\n             @mut ~[]\n         };"}, {"sha": "cd846067a9526f4a68b44e906eb59129c8b38c7f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -394,8 +394,8 @@ impl ImportResolution {\n     pub fn target_for_namespace(&self, namespace: Namespace)\n                                 -> Option<Target> {\n         match namespace {\n-            TypeNS      => return copy self.type_target,\n-            ValueNS     => return copy self.value_target\n+            TypeNS      => return self.type_target,\n+            ValueNS     => return self.value_target,\n         }\n     }\n \n@@ -795,7 +795,7 @@ pub fn Resolver(session: Session,\n \n     let this = Resolver {\n         session: @session,\n-        lang_items: copy lang_items,\n+        lang_items: lang_items,\n         crate: crate,\n \n         // The outermost module has def ID 0; this is not reflected in the\n@@ -2477,9 +2477,9 @@ impl Resolver {\n                     let new_import_resolution =\n                         @mut ImportResolution(privacy, id);\n                     new_import_resolution.value_target =\n-                        copy target_import_resolution.value_target;\n+                        target_import_resolution.value_target;\n                     new_import_resolution.type_target =\n-                        copy target_import_resolution.type_target;\n+                        target_import_resolution.type_target;\n \n                     module_.import_resolutions.insert\n                         (*ident, new_import_resolution);\n@@ -2531,7 +2531,7 @@ impl Resolver {\n                    self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_),\n-                   copy dest_import_resolution.privacy);\n+                   dest_import_resolution.privacy);\n \n             // Merge the child item into the import resolution.\n             if name_bindings.defined_in_public_namespace(ValueNS) {\n@@ -2810,7 +2810,7 @@ impl Resolver {\n                         debug!(\"(resolving item in lexical scope) using \\\n                                 import resolution\");\n                         self.used_imports.insert(import_resolution.id(namespace));\n-                        return Success(copy target);\n+                        return Success(target);\n                     }\n                 }\n             }\n@@ -2888,7 +2888,7 @@ impl Resolver {\n                 }\n                 Success(target) => {\n                     // We found the module.\n-                    return Success(copy target);\n+                    return Success(target);\n                 }\n             }\n         }\n@@ -3079,7 +3079,7 @@ impl Resolver {\n                         debug!(\"(resolving name in module) resolved to \\\n                                 import\");\n                         self.used_imports.insert(import_resolution.id(namespace));\n-                        return Success(copy target);\n+                        return Success(target);\n                     }\n                     Some(_) => {\n                         debug!(\"(resolving name in module) name found, \\\n@@ -3204,7 +3204,7 @@ impl Resolver {\n         let mut exports2 = ~[];\n \n         self.add_exports_for_module(&mut exports2, module_);\n-        match /*bad*/copy module_.def_id {\n+        match module_.def_id {\n             Some(def_id) => {\n                 self.export_map2.insert(def_id.node, exports2);\n                 debug!(\"(computing exports) writing exports for %d (some)\","}, {"sha": "c9631f03475ed9a6cd8d26b39d4ce07c77812790", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -2953,7 +2953,7 @@ pub fn trans_crate(sess: session::Session,\n                    -> (ContextRef, ModuleRef, LinkMeta) {\n     // Before we touch LLVM, make sure that multithreading is enabled.\n     if unsafe { !llvm::LLVMRustStartMultithreading() } {\n-        sess.bug(\"couldn't enable multi-threaded LLVM\");\n+        //sess.bug(\"couldn't enable multi-threaded LLVM\");\n     }\n \n     let mut symbol_hasher = hash::default_state();"}, {"sha": "ddac647dced57d0a65ebfedc97b3853e033e47ee", "filename": "src/librustc/middle/trans/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbuild.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -59,7 +59,7 @@ pub fn count_insn(cx: block, category: &str) {\n         let len = v.len();\n         let mut i = 0u;\n         while i < len {\n-            mm.insert(copy v[i], i);\n+            mm.insert(v[i], i);\n             i += 1u;\n         }\n "}, {"sha": "337f5b2bbada7ea5c8e7fb7d4ef7bf13024e0442", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -696,7 +696,7 @@ pub fn trans_call_inner(in_cx: block,\n             let ret_flag_result = bool_to_i1(bcx, Load(bcx, ret_flag.get()));\n             bcx = do with_cond(bcx, ret_flag_result) |bcx| {\n                 {\n-                    let r = (copy bcx.fcx.loop_ret);\n+                    let r = bcx.fcx.loop_ret;\n                     for r.iter().advance |&(flagptr, _)| {\n                         Store(bcx, C_bool(true), flagptr);\n                         Store(bcx, C_bool(false), bcx.fcx.llretptr.get());"}, {"sha": "01347af63eff6dfde110867de8a3b0f6462df7ce", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -459,7 +459,7 @@ pub fn trans_expr_fn(bcx: block,\n                           body,\n                           llfn,\n                           no_self,\n-                          /*bad*/ copy bcx.fcx.param_substs,\n+                          bcx.fcx.param_substs,\n                           user_id,\n                           [],\n                           real_return_type,"}, {"sha": "3c103a13d610553095cf57613cfedf21ab8b0c14", "filename": "src/librustc/middle/trans/controlflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcontrolflow.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -351,7 +351,7 @@ pub fn trans_cont(bcx: block, label_opt: Option<ident>) -> block {\n pub fn trans_ret(bcx: block, e: Option<@ast::expr>) -> block {\n     let _icx = push_ctxt(\"trans_ret\");\n     let mut bcx = bcx;\n-    let dest = match copy bcx.fcx.loop_ret {\n+    let dest = match bcx.fcx.loop_ret {\n       Some((flagptr, retptr)) => {\n         // This is a loop body return. Must set continue flag (our retptr)\n         // to false, return flag to true, and then store the value in the"}, {"sha": "d3fc8ec670a3c268d977c0e477c28008e8bae3ba", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -393,7 +393,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n \n         precise_param_ids.iter().zip(uses_iter).transform(|(id, uses)| {\n             if ccx.sess.no_monomorphic_collapse() {\n-                match copy *id {\n+                match *id {\n                     (a, b) => mono_precise(a, b)\n                 }\n             } else {\n@@ -432,7 +432,7 @@ pub fn make_mono_id(ccx: @mut CrateContext,\n       }\n       None => {\n           precise_param_ids.iter().transform(|x| {\n-              let (a, b) = copy *x;\n+              let (a, b) = *x;\n               mono_precise(a, b)\n           }).collect()\n       }"}, {"sha": "fe32c2f7c4a911926451f8b0cfaca48cd3e418ba", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -63,7 +63,7 @@ use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n-use middle::typeck::infer::unify::{InferCtxtMethods};\n+use middle::typeck::infer::unify::InferCtxtMethods;\n use middle::typeck::infer::{InferCtxt, cres, ures};\n use middle::typeck::infer::{TypeTrace};\n use util::common::indent;"}, {"sha": "53ae03922dc608a13647cee8429315bfe5e8d0d6", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -511,8 +511,7 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n             debug!(\"bnd=None\");\n             let a_bounds = this.with_bnd(a_bounds, copy *b);\n             do this.combine_fields().bnds(&a_bounds.lb, &a_bounds.ub).then {\n-                this.infcx().set(copy a_id,\n-                                 Root(copy a_bounds, copy nde_a.rank));\n+                this.infcx().set(copy a_id, Root(copy a_bounds, nde_a.rank));\n                 Ok(copy *b)\n             }\n         }"}, {"sha": "9aaee7c7ce0b7ecdc7675d04a3e837ec8a2951e8", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -77,11 +77,11 @@ impl Combine for Sub {\n           m_mutbl => {\n             // If supertype is mut, subtype must match exactly\n             // (i.e., invariant if mut):\n-            eq_tys(self, a.ty, b.ty).then(|| Ok(copy *a) )\n+            eq_tys(self, a.ty, b.ty).then(|| Ok(*a))\n           }\n           m_imm | m_const => {\n             // Otherwise we can be covariant:\n-            self.tys(a.ty, b.ty).chain(|_t| Ok(copy *a) )\n+            self.tys(a.ty, b.ty).chain(|_t| Ok(*a) )\n           }\n         }\n     }"}, {"sha": "202177b5cfc98b63a14099ca165c65dfe64539da", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -33,18 +33,18 @@ impl<T:Clone> Clone for Fold<T> {\n     fn clone(&self) -> Fold<T> {\n         Fold {\n             ctxt: self.ctxt.clone(),\n-            fold_doc: copy self.fold_doc,\n-            fold_crate: copy self.fold_crate,\n-            fold_item: copy self.fold_item,\n-            fold_mod: copy self.fold_mod,\n-            fold_nmod: copy self.fold_nmod,\n-            fold_fn: copy self.fold_fn,\n-            fold_const: copy self.fold_const,\n-            fold_enum: copy self.fold_enum,\n-            fold_trait: copy self.fold_trait,\n-            fold_impl: copy self.fold_impl,\n-            fold_type: copy self.fold_type,\n-            fold_struct: copy self.fold_struct\n+            fold_doc: self.fold_doc,\n+            fold_crate: self.fold_crate,\n+            fold_item: self.fold_item,\n+            fold_mod: self.fold_mod,\n+            fold_nmod: self.fold_nmod,\n+            fold_fn: self.fold_fn,\n+            fold_const: self.fold_const,\n+            fold_enum: self.fold_enum,\n+            fold_trait: self.fold_trait,\n+            fold_impl: self.fold_impl,\n+            fold_type: self.fold_type,\n+            fold_struct: self.fold_struct\n         }\n     }\n }"}, {"sha": "453c40af915b96b763f3ead0962d8cadf18cd67b", "filename": "src/librustdoc/text_pass.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustdoc%2Ftext_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustdoc%2Ftext_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftext_pass.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -63,9 +63,9 @@ fn fold_item(\n     let doc = fold::default_seq_fold_item(fold, doc);\n \n     doc::ItemDoc {\n-        brief: maybe_apply_op(copy fold.ctxt, &doc.brief),\n-        desc: maybe_apply_op(copy fold.ctxt, &doc.desc),\n-        sections: apply_to_sections(copy fold.ctxt, copy doc.sections),\n+        brief: maybe_apply_op(fold.ctxt, &doc.brief),\n+        desc: maybe_apply_op(fold.ctxt, &doc.desc),\n+        sections: apply_to_sections(fold.ctxt, copy doc.sections),\n         .. doc\n     }\n }\n@@ -84,12 +84,12 @@ fn fold_enum(\n     fold: &fold::Fold<NominalOp<Op>>,\n     doc: doc::EnumDoc) -> doc::EnumDoc {\n     let doc = fold::default_seq_fold_enum(fold, doc);\n-    let fold_copy = copy *fold;\n+    let fold_copy = *fold;\n \n     doc::EnumDoc {\n         variants: do doc.variants.map |variant| {\n             doc::VariantDoc {\n-                desc: maybe_apply_op(copy fold_copy.ctxt, &variant.desc),\n+                desc: maybe_apply_op(fold_copy.ctxt, &variant.desc),\n                 .. copy *variant\n             }\n         },\n@@ -104,7 +104,7 @@ fn fold_trait(\n     let doc = fold::default_seq_fold_trait(fold, doc);\n \n     doc::TraitDoc {\n-        methods: apply_to_methods(copy fold.ctxt, copy doc.methods),\n+        methods: apply_to_methods(fold.ctxt, copy doc.methods),\n         .. doc\n     }\n }\n@@ -113,12 +113,11 @@ fn apply_to_methods(\n     op: NominalOp<Op>,\n     docs: ~[doc::MethodDoc]\n ) -> ~[doc::MethodDoc] {\n-    let op = copy op;\n     do docs.map |doc| {\n         doc::MethodDoc {\n-            brief: maybe_apply_op(copy op, &doc.brief),\n-            desc: maybe_apply_op(copy op, &doc.desc),\n-            sections: apply_to_sections(copy op, copy doc.sections),\n+            brief: maybe_apply_op(op, &doc.brief),\n+            desc: maybe_apply_op(op, &doc.desc),\n+            sections: apply_to_sections(op, copy doc.sections),\n             .. copy *doc\n         }\n     }\n@@ -131,7 +130,7 @@ fn fold_impl(\n     let doc = fold::default_seq_fold_impl(fold, doc);\n \n     doc::ImplDoc {\n-        methods: apply_to_methods(copy fold.ctxt, copy doc.methods),\n+        methods: apply_to_methods(fold.ctxt, copy doc.methods),\n         .. doc\n     }\n }"}, {"sha": "4a2c2549b0e61d5c80e9960b7a1f90261082b936", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -327,7 +327,7 @@ pub fn find_and_install_dependencies(ctxt: &Ctx,\n     // :-(\n     debug!(\"In find_and_install_dependencies...\");\n     let my_workspace = copy *workspace;\n-    let my_ctxt      = copy *ctxt;\n+    let my_ctxt      = *ctxt;\n     for c.each_view_item() |vi: &ast::view_item| {\n         debug!(\"A view item!\");\n         match vi.node {"}, {"sha": "353038a1a19eac73ac6d4ab244e9ce00c945ef63", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -38,9 +38,9 @@ unsafe fn each_live_alloc(read_next_before: bool,\n     use rt::local_heap;\n \n     let box = local_heap::live_allocs();\n-    let mut box: *mut BoxRepr = transmute(copy box);\n+    let mut box: *mut BoxRepr = transmute(box);\n     while box != mut_null() {\n-        let next_before = transmute(copy (*box).header.next);\n+        let next_before = transmute((*box).header.next);\n         let uniq =\n             (*box).header.ref_count == managed::raw::RC_MANAGED_UNIQUE;\n \n@@ -51,7 +51,7 @@ unsafe fn each_live_alloc(read_next_before: bool,\n         if read_next_before {\n             box = next_before;\n         } else {\n-            box = transmute(copy (*box).header.next);\n+            box = transmute((*box).header.next);\n         }\n     }\n     return true;\n@@ -126,7 +126,7 @@ pub unsafe fn annihilate() {\n     // callback, as the original value may have been freed.\n     for each_live_alloc(false) |box, uniq| {\n         if !uniq {\n-            let tydesc: *TyDesc = transmute(copy (*box).header.type_desc);\n+            let tydesc: *TyDesc = transmute((*box).header.type_desc);\n             let data = transmute(&(*box).data);\n             call_drop_glue(tydesc, data);\n         }"}, {"sha": "8f43e847c24bb3a6a510bd0f3dde84fd725388d9", "filename": "src/libstd/pipes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibstd%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibstd%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpipes.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -476,7 +476,7 @@ fn try_recv_<T:Send>(p: &mut Packet<T>) -> Option<T> {\n                 // sometimes blocking the thing we are waiting on.\n                 task::yield();\n             }\n-            debug!(\"woke up, p.state = %?\", copy p.header.state);\n+            debug!(\"woke up, p.state = %?\", p.header.state);\n           }\n           Blocked => if first {\n             fail!(\"blocking on already blocked packet\")"}, {"sha": "feadf3fdbf3f13f505fa5132af33f4d29879a595", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -27,7 +27,9 @@ pub fn path_name_i(idents: &[ident]) -> ~str {\n     idents.map(|i| token::interner_get(i.name)).connect(\"::\")\n }\n \n-pub fn path_to_ident(p: &Path) -> ident { copy *p.idents.last() }\n+pub fn path_to_ident(p: &Path) -> ident {\n+    *p.idents.last()\n+}\n \n pub fn local_def(id: node_id) -> def_id {\n     ast::def_id { crate: local_crate, node: id }\n@@ -297,9 +299,9 @@ pub trait inlined_item_utils {\n impl inlined_item_utils for inlined_item {\n     fn ident(&self) -> ident {\n         match *self {\n-            ii_item(i) => /* FIXME (#2543) */ copy i.ident,\n-            ii_foreign(i) => /* FIXME (#2543) */ copy i.ident,\n-            ii_method(_, _, m) => /* FIXME (#2543) */ copy m.ident,\n+            ii_item(i) => i.ident,\n+            ii_foreign(i) => i.ident,\n+            ii_method(_, _, m) => m.ident,\n         }\n     }\n "}, {"sha": "18bef1ea17e1aafa30423adf277cc69577a81d83", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -269,7 +269,7 @@ pub fn sort_meta_items(items: &[@ast::meta_item]) -> ~[@ast::meta_item] {\n                     .. /*bad*/ copy **m\n                 }\n             }\n-            _ => /*bad*/ copy *m\n+            _ => *m\n         }\n     }\n }"}, {"sha": "dcd9615ffd0577ce4937b33d8acbfc59862f1790", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -354,7 +354,7 @@ impl CodeMap {\n \n     pub fn span_to_filename(&self, sp: span) -> FileName {\n         let lo = self.lookup_char_pos(sp.lo);\n-        return /* FIXME (#2543) */ copy lo.file.name;\n+        lo.file.name\n     }\n \n     pub fn span_to_lines(&self, sp: span) -> @FileLines {"}, {"sha": "0e464208de3d939dea2354c41200cbf715776849", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -257,7 +257,7 @@ impl ExtCtxt {\n                     Some(@ExpnInfo {\n                         call_site: span {lo: cs.lo, hi: cs.hi,\n                                          expn_info: *self.backtrace},\n-                        callee: copy *callee});\n+                        callee: *callee});\n             }\n         }\n     }"}, {"sha": "89290b78b72a5fdb9482e22059fab965ded5e05a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -347,7 +347,7 @@ impl AstBuilder for @ExtCtxt {\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {\n         let new_params = do generics.ty_params.map |ty_param| {\n-            ast::TyParam { bounds: opt_vec::Empty, ..copy *ty_param }\n+            ast::TyParam { bounds: opt_vec::Empty, ..*ty_param }\n         };\n         Generics {\n             ty_params: new_params,\n@@ -611,13 +611,13 @@ impl AstBuilder for @ExtCtxt {\n     }\n     fn lambda0(&self, _span: span, blk: ast::blk) -> @ast::expr {\n         let ext_cx = *self;\n-        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n+        let blk_e = self.expr(blk.span, ast::expr_block(copy blk));\n         quote_expr!(|| $blk_e )\n     }\n \n     fn lambda1(&self, _span: span, blk: ast::blk, ident: ast::ident) -> @ast::expr {\n         let ext_cx = *self;\n-        let blk_e = self.expr(copy blk.span, ast::expr_block(copy blk));\n+        let blk_e = self.expr(blk.span, ast::expr_block(copy blk));\n         quote_expr!(|$ident| $blk_e )\n     }\n "}, {"sha": "f90ee1f8d79e4c980ed3ea3be0b600bb76eee0f7", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -323,7 +323,7 @@ impl<'self> TraitDef<'self> {\n         let mut trait_generics = self.generics.to_generics(cx, span, type_ident, generics);\n         // Copy the lifetimes\n         for generics.lifetimes.iter().advance |l| {\n-            trait_generics.lifetimes.push(copy *l)\n+            trait_generics.lifetimes.push(*l)\n         };\n         // Create the type parameters.\n         for generics.ty_params.iter().advance |ty_param| {"}, {"sha": "6a8f3c89a2f1fd1a238430e5cac5ef1307684a08", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -45,7 +45,7 @@ use extra::bitv::Bitv;\n pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n-    let mut colive: ~[~Bitv] = do (copy proto.states).iter().transform() |state| {\n+    let mut colive: ~[~Bitv] = do proto.states.iter().transform() |state| {\n         let mut bv = ~Bitv::new(num_states, false);\n         for state.reachable |s| {\n             bv.set(s.id, true);\n@@ -85,10 +85,11 @@ pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n     }\n \n     if self_live.len() > 0 {\n-        let states = self_live.map(|s| copy s.name).connect(\" \");\n+        let states = self_live.map(|s| s.name).connect(\" \");\n \n         debug!(\"protocol %s is unbounded due to loops involving: %s\",\n-               copy proto.name, states);\n+               proto.name,\n+               states);\n \n         // Someday this will be configurable with a warning\n         //cx.span_warn(empty_span(),\n@@ -98,9 +99,8 @@ pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n         //                   states));\n \n         proto.bounded = Some(false);\n-    }\n-    else {\n-        debug!(\"protocol %s is bounded. yay!\", copy proto.name);\n+    } else {\n+        debug!(\"protocol %s is bounded. yay!\", proto.name);\n         proto.bounded = Some(true);\n     }\n }"}, {"sha": "73c6c6d5fff2c26acb17f061a7db1ef5750c8626", "filename": "src/libsyntax/ext/pipes/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fmod.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -65,7 +65,7 @@ pub fn expand_proto(cx: @ExtCtxt, _sp: span, id: ast::ident,\n                     tt: ~[ast::token_tree]) -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n-    let tt_rdr = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n+    let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n                                None,\n                                copy tt);\n     let rdr = tt_rdr as @reader;"}, {"sha": "e5581cada3778198f1f540c8160c93ff936ce2bb", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -382,7 +382,7 @@ impl gen_init for protocol {\n \n         cx.ty_path(path(~[cx.ident_of(\"super\"),\n                           cx.ident_of(\"__Buffer\")],\n-                        copy self.span)\n+                        self.span)\n                    .add_tys(cx.ty_vars_global(&params)), None)\n     }\n \n@@ -432,7 +432,7 @@ impl gen_init for protocol {\n         let mut client_states = ~[];\n         let mut server_states = ~[];\n \n-        for (copy self.states).iter().advance |s| {\n+        for self.states.iter().advance |s| {\n             items.push_all_move(s.to_type_decls(cx));\n \n             client_states.push_all_move(s.to_endpoint_decls(cx, send));\n@@ -443,24 +443,23 @@ impl gen_init for protocol {\n             items.push(self.gen_buffer_type(cx))\n         }\n \n-        items.push(cx.item_mod(copy self.span,\n+        items.push(cx.item_mod(self.span,\n                                cx.ident_of(\"client\"),\n                                ~[], ~[],\n                                client_states));\n-        items.push(cx.item_mod(copy self.span,\n+        items.push(cx.item_mod(self.span,\n                                cx.ident_of(\"server\"),\n                                ~[], ~[],\n                                server_states));\n \n         // XXX: Would be nice if our generated code didn't violate\n         // Rust coding conventions\n         let allows = cx.attribute(\n-            copy self.span,\n-            cx.meta_list(copy self.span,\n+            self.span,\n+            cx.meta_list(self.span,\n                          @\"allow\",\n-                         ~[cx.meta_word(copy self.span, @\"non_camel_case_types\"),\n-                           cx.meta_word(copy self.span, @\"unused_mut\")]));\n-        cx.item_mod(copy self.span, cx.ident_of(copy self.name),\n-                    ~[allows], ~[], items)\n+                         ~[cx.meta_word(self.span, @\"non_camel_case_types\"),\n+                           cx.meta_word(self.span, @\"unused_mut\")]));\n+        cx.item_mod(self.span, cx.ident_of(self.name), ~[allows], ~[], items)\n     }\n }"}, {"sha": "92e1b2bd09f291aa67de3e8957c76eadd442d326", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -214,9 +214,8 @@ pub trait visitor<Tproto, Tstate, Tmessage> {\n pub fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n     proto: protocol, visitor: V) -> Tproto {\n \n-    // the copy keywords prevent recursive use of dvec\n-    let states: ~[Tstate] = do (copy proto.states).iter().transform |&s| {\n-        let messages: ~[Tmessage] = do (copy s.messages).iter().transform |m| {\n+    let states: ~[Tstate] = do proto.states.iter().transform |&s| {\n+        let messages: ~[Tmessage] = do s.messages.iter().transform |m| {\n             let message(name, span, tys, this, next) = copy *m;\n             visitor.visit_message(name, span, tys, this, next)\n         }.collect();"}, {"sha": "5c6032785e398674cc43b8a409ec135c94fe8715", "filename": "src/libsyntax/ext/trace_macros.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftrace_macros.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -22,11 +22,9 @@ pub fn expand_trace_macros(cx: @ExtCtxt,\n                         -> base::MacResult {\n     let sess = cx.parse_sess();\n     let cfg = cx.cfg();\n-    let tt_rdr = new_tt_reader(\n-        copy cx.parse_sess().span_diagnostic,\n-        None,\n-        tt.to_owned()\n-    );\n+    let tt_rdr = new_tt_reader(cx.parse_sess().span_diagnostic,\n+                               None,\n+                               tt.to_owned());\n     let rdr = tt_rdr as @reader;\n     let rust_parser = Parser(\n         sess,"}, {"sha": "6b3ce1c9a2f0aa7d1cfce9e63f0952e6faf698fa", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -53,8 +53,9 @@ pub fn add_new_extension(cx: @ExtCtxt,\n \n \n     // Parse the macro_rules! invocation (`none` is for no interpolations):\n-    let arg_reader = new_tt_reader(copy cx.parse_sess().span_diagnostic,\n-                                   None, copy arg);\n+    let arg_reader = new_tt_reader(cx.parse_sess().span_diagnostic,\n+                                   None,\n+                                   copy arg);\n     let argument_map = parse_or_else(cx.parse_sess(),\n                                      cx.cfg(),\n                                      arg_reader as @reader,"}, {"sha": "94ecff178eaa87f1508219eae54838798997c916", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -285,7 +285,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n               }\n               matched_seq(*) => {\n                 r.sp_diag.span_fatal(\n-                    copy r.cur_span, /* blame the macro writer */\n+                    r.cur_span, /* blame the macro writer */\n                     fmt!(\"variable '%s' is still repeating at this depth\",\n                          ident_to_str(&ident)));\n               }"}, {"sha": "11c29c73a2b179ffe3aa1fd0d7e5399b6b3ca554", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -87,7 +87,7 @@ fn fold_meta_item_(mi: @meta_item, fld: @ast_fold) -> @meta_item {\n                     )\n                 }\n                 meta_name_value(id, s) => {\n-                    meta_name_value(id, /* FIXME (#2543) */ copy s)\n+                    meta_name_value(id, s)\n                 }\n             },\n         span: fld.new_span(mi.span) }\n@@ -258,11 +258,15 @@ fn noop_fold_struct_field(sf: @struct_field, fld: @ast_fold)\n                        -> @struct_field {\n     let fold_attribute = |x| fold_attribute_(x, fld);\n \n-    @spanned { node: ast::struct_field_ { kind: copy sf.node.kind,\n-                                          id: sf.node.id,\n-                                          ty: fld.fold_ty(&sf.node.ty),\n-                                          attrs: sf.node.attrs.map(|e| fold_attribute(*e)) },\n-               span: sf.span }\n+    @spanned {\n+        node: ast::struct_field_ {\n+            kind: sf.node.kind,\n+            id: sf.node.id,\n+            ty: fld.fold_ty(&sf.node.ty),\n+            attrs: sf.node.attrs.map(|e| fold_attribute(*e))\n+        },\n+        span: sf.span\n+    }\n }\n \n pub fn noop_fold_item_underscore(i: &item_, fld: @ast_fold) -> item_ {\n@@ -346,7 +350,7 @@ fn fold_trait_ref(p: &trait_ref, fld: @ast_fold) -> trait_ref {\n fn fold_struct_field(f: @struct_field, fld: @ast_fold) -> @struct_field {\n     @spanned {\n         node: ast::struct_field_ {\n-            kind: copy f.node.kind,\n+            kind: f.node.kind,\n             id: fld.new_id(f.node.id),\n             ty: fld.fold_ty(&f.node.ty),\n             attrs: /* FIXME (#2543) */ copy f.node.attrs,\n@@ -439,7 +443,7 @@ pub fn noop_fold_pat(p: &pat_, fld: @ast_fold) -> pat_ {\n             let pth_ = fld.fold_path(pth);\n             let fs = do fields.map |f| {\n                 ast::field_pat {\n-                    ident: /* FIXME (#2543) */ copy f.ident,\n+                    ident: f.ident,\n                     pat: fld.fold_pat(f.pat)\n                 }\n             };\n@@ -743,7 +747,7 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n       None => None\n     };\n     ast::variant_ {\n-        name: /* FIXME (#2543) */ copy v.name,\n+        name: v.name,\n         attrs: attrs,\n         kind: kind,\n         id: fld.new_id(v.id),\n@@ -753,7 +757,7 @@ fn noop_fold_variant(v: &variant_, fld: @ast_fold) -> variant_ {\n }\n \n fn noop_fold_ident(i: ident, _fld: @ast_fold) -> ident {\n-    /* FIXME (#2543) */ copy i\n+    i\n }\n \n fn noop_fold_path(p: &Path, fld: @ast_fold) -> Path {\n@@ -837,7 +841,7 @@ impl ast_fold for AstFoldFns {\n     fn fold_struct_field(@self, sf: @struct_field) -> @struct_field {\n         @spanned {\n             node: ast::struct_field_ {\n-                kind: copy sf.node.kind,\n+                kind: sf.node.kind,\n                 id: sf.node.id,\n                 ty: self.fold_ty(&sf.node.ty),\n                 attrs: copy sf.node.attrs,"}, {"sha": "22e0a150a197835bbc06d79b785bf11540610045", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -94,7 +94,7 @@ fn dup_string_reader(r: @mut StringReader) -> @mut StringReader {\n         curr: r.curr,\n         filemap: r.filemap,\n         peek_tok: copy r.peek_tok,\n-        peek_span: copy r.peek_span\n+        peek_span: r.peek_span\n     }\n }\n \n@@ -103,20 +103,20 @@ impl reader for StringReader {\n     // return the next token. EFFECT: advances the string_reader.\n     fn next_token(@mut self) -> TokenAndSpan {\n         let ret_val = TokenAndSpan {\n-            tok: copy self.peek_tok,\n-            sp: copy self.peek_span,\n+            tok: /*bad*/copy self.peek_tok,\n+            sp: self.peek_span,\n         };\n         string_advance_token(self);\n         ret_val\n     }\n     fn fatal(@mut self, m: ~str) -> ! {\n-        self.span_diagnostic.span_fatal(copy self.peek_span, m)\n+        self.span_diagnostic.span_fatal(self.peek_span, m)\n     }\n     fn span_diag(@mut self) -> @span_handler { self.span_diagnostic }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n-            tok: copy self.peek_tok,\n-            sp: copy self.peek_span,\n+            tok: /*bad*/copy self.peek_tok,\n+            sp: self.peek_span,\n         }\n     }\n     fn dup(@mut self) -> @reader { dup_string_reader(self) as @reader }\n@@ -126,13 +126,13 @@ impl reader for TtReader {\n     fn is_eof(@mut self) -> bool { self.cur_tok == token::EOF }\n     fn next_token(@mut self) -> TokenAndSpan { tt_next_token(self) }\n     fn fatal(@mut self, m: ~str) -> ! {\n-        self.sp_diag.span_fatal(copy self.cur_span, m);\n+        self.sp_diag.span_fatal(self.cur_span, m);\n     }\n     fn span_diag(@mut self) -> @span_handler { self.sp_diag }\n     fn peek(@mut self) -> TokenAndSpan {\n         TokenAndSpan {\n             tok: copy self.cur_tok,\n-            sp: copy self.cur_span,\n+            sp: self.cur_span,\n         }\n     }\n     fn dup(@mut self) -> @reader { dup_tt_reader(self) as @reader }\n@@ -144,7 +144,7 @@ fn string_advance_token(r: @mut StringReader) {\n     match (consume_whitespace_and_comments(r)) {\n         Some(comment) => {\n             r.peek_tok = copy comment.tok;\n-            r.peek_span = copy comment.sp;\n+            r.peek_span = comment.sp;\n         },\n         None => {\n             if is_eof(r) {"}, {"sha": "84cc49192ed6fdc427f25bbfd3ee34300b018363", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -307,7 +307,7 @@ pub fn filemap_to_tts(sess: @mut ParseSess, filemap: @FileMap)\n     // it appears to me that the cfg doesn't matter here... indeed,\n     // parsing tt's probably shouldn't require a parser at all.\n     let cfg = ~[];\n-    let srdr = lexer::new_string_reader(copy sess.span_diagnostic, filemap);\n+    let srdr = lexer::new_string_reader(sess.span_diagnostic, filemap);\n     let p1 = Parser(sess, cfg, srdr as @reader);\n     p1.parse_all_token_trees()\n }\n@@ -316,11 +316,7 @@ pub fn filemap_to_tts(sess: @mut ParseSess, filemap: @FileMap)\n pub fn tts_to_parser(sess: @mut ParseSess,\n                      tts: ~[ast::token_tree],\n                      cfg: ast::crate_cfg) -> Parser {\n-    let trdr = lexer::new_tt_reader(\n-        copy sess.span_diagnostic,\n-        None,\n-        tts\n-    );\n+    let trdr = lexer::new_tt_reader(sess.span_diagnostic, None, tts);\n     Parser(sess, cfg, trdr as @reader)\n }\n "}, {"sha": "01ed6531273f77f49384d5c887e56f96739d32d9", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -329,8 +329,9 @@ impl ParserObsoleteMethods for Parser {\n \n     pub fn try_parse_obsolete_priv_section(&self, attrs: &[attribute])\n                                            -> bool {\n-        if self.is_keyword(keywords::Priv) && self.look_ahead(1) == token::LBRACE {\n-            self.obsolete(copy *self.span, ObsoletePrivSection);\n+        if self.is_keyword(keywords::Priv) && self.look_ahead(1) ==\n+                token::LBRACE {\n+            self.obsolete(*self.span, ObsoletePrivSection);\n             self.eat_keyword(keywords::Priv);\n             self.bump();\n             while *self.token != token::RBRACE {"}, {"sha": "497000a6cbfb4bbd8a65fa928848b537280794ed", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 27, "deletions": 38, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -236,8 +236,8 @@ pub fn Parser(sess: @mut ParseSess,\n         sess: sess,\n         cfg: cfg,\n         token: @mut copy tok0.tok,\n-        span: @mut copy tok0.sp,\n-        last_span: @mut copy tok0.sp,\n+        span: @mut tok0.sp,\n+        last_span: @mut tok0.sp,\n         buffer: @mut ([copy tok0, .. 4]),\n         buffer_start: @mut 0,\n         buffer_end: @mut 0,\n@@ -530,16 +530,16 @@ impl Parser {\n \n     // advance the parser by one token\n     pub fn bump(&self) {\n-        *self.last_span = copy *self.span;\n+        *self.last_span = *self.span;\n         let next = if *self.buffer_start == *self.buffer_end {\n             self.reader.next_token()\n         } else {\n             let next = copy self.buffer[*self.buffer_start];\n             *self.buffer_start = (*self.buffer_start + 1) & 3;\n             next\n         };\n-        *self.token = copy next.tok;\n-        *self.span = copy next.sp;\n+        *self.token = /*bad*/copy next.tok;\n+        *self.span = next.sp;\n         *self.tokens_consumed += 1u;\n     }\n     // EFFECT: replace the current token and span with the given one\n@@ -565,7 +565,7 @@ impl Parser {\n         return copy self.buffer[(*self.buffer_start + dist - 1) & 3].tok;\n     }\n     pub fn fatal(&self, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_fatal(*copy self.span, m)\n+        self.sess.span_diagnostic.span_fatal(*self.span, m)\n     }\n     pub fn span_fatal(&self, sp: span, m: &str) -> ! {\n         self.sess.span_diagnostic.span_fatal(sp, m)\n@@ -574,10 +574,10 @@ impl Parser {\n         self.sess.span_diagnostic.span_note(sp, m)\n     }\n     pub fn bug(&self, m: &str) -> ! {\n-        self.sess.span_diagnostic.span_bug(*copy self.span, m)\n+        self.sess.span_diagnostic.span_bug(*self.span, m)\n     }\n     pub fn warn(&self, m: &str) {\n-        self.sess.span_diagnostic.span_warn(*copy self.span, m)\n+        self.sess.span_diagnostic.span_warn(*self.span, m)\n     }\n     pub fn span_err(&self, sp: span, m: &str) {\n         self.sess.span_diagnostic.span_err(sp, m)\n@@ -608,7 +608,7 @@ impl Parser {\n \n     pub fn get_lifetime(&self, tok: &token::Token) -> ast::ident {\n         match *tok {\n-            token::LIFETIME(ref ident) => copy *ident,\n+            token::LIFETIME(ref ident) => *ident,\n             _ => self.bug(\"not a lifetime\"),\n         }\n     }\n@@ -1259,7 +1259,7 @@ impl Parser {\n                 self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n                 match *self.token {\n                     token::IDENT(sid, _) => {\n-                        let span = copy self.span;\n+                        let span = self.span;\n                         self.bump();\n                         Some(ast::Lifetime {\n                             id: self.get_id(),\n@@ -1347,7 +1347,7 @@ impl Parser {\n     pub fn parse_lifetime(&self) -> ast::Lifetime {\n         match *self.token {\n             token::LIFETIME(i) => {\n-                let span = copy self.span;\n+                let span = self.span;\n                 self.bump();\n                 return ast::Lifetime {\n                     id: self.get_id(),\n@@ -1358,7 +1358,7 @@ impl Parser {\n \n             // Also accept the (obsolete) syntax `foo/`\n             token::IDENT(i, _) => {\n-                let span = copy self.span;\n+                let span = self.span;\n                 self.bump();\n                 self.expect(&token::BINOP(token::SLASH));\n                 self.obsolete(*self.last_span, ObsoleteLifetimeNotation);\n@@ -2981,7 +2981,7 @@ impl Parser {\n \n         let lo = self.span.lo;\n         if self.eat_keyword(keywords::Unsafe) {\n-            self.obsolete(copy *self.span, ObsoleteUnsafeBlock);\n+            self.obsolete(*self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(&token::LBRACE);\n \n@@ -2996,7 +2996,7 @@ impl Parser {\n \n         let lo = self.span.lo;\n         if self.eat_keyword(keywords::Unsafe) {\n-            self.obsolete(copy *self.span, ObsoleteUnsafeBlock);\n+            self.obsolete(*self.span, ObsoleteUnsafeBlock);\n         }\n         self.expect(&token::LBRACE);\n         let (inner, next) = self.parse_inner_attrs_and_next();\n@@ -3581,7 +3581,7 @@ impl Parser {\n             ty = self.parse_ty(false);\n             opt_trait_ref\n         } else if self.eat(&token::COLON) {\n-            self.obsolete(copy *self.span, ObsoleteImplSyntax);\n+            self.obsolete(*self.span, ObsoleteImplSyntax);\n             Some(self.parse_trait_ref())\n         } else {\n             None\n@@ -3626,7 +3626,7 @@ impl Parser {\n         self.parse_region_param();\n         let generics = self.parse_generics();\n         if self.eat(&token::COLON) {\n-            self.obsolete(copy *self.span, ObsoleteClassTraits);\n+            self.obsolete(*self.span, ObsoleteClassTraits);\n             let _ = self.parse_trait_ref_list(&token::LBRACE);\n         }\n \n@@ -3710,21 +3710,17 @@ impl Parser {\n         let a_var = self.parse_name_and_ty(vis, attrs);\n         match *self.token {\n             token::SEMI => {\n-                self.obsolete(copy *self.span, ObsoleteFieldTerminator);\n+                self.obsolete(*self.span, ObsoleteFieldTerminator);\n                 self.bump();\n             }\n             token::COMMA => {\n                 self.bump();\n             }\n             token::RBRACE => {}\n             _ => {\n-                self.span_fatal(\n-                    copy *self.span,\n-                    fmt!(\n-                        \"expected `,`, or '}' but found `%s`\",\n-                        self.this_token_to_str()\n-                    )\n-                );\n+                self.span_fatal(*self.span,\n+                                fmt!(\"expected `,`, or '}' but found `%s`\",\n+                                     self.this_token_to_str()));\n             }\n         }\n         a_var\n@@ -4043,26 +4039,19 @@ impl Parser {\n             must_be_named_mod = true;\n             self.expect_keyword(keywords::Mod);\n         } else if *self.token != token::LBRACE {\n-            self.span_fatal(\n-                copy *self.span,\n-                fmt!(\n-                    \"expected `{` or `mod` but found `%s`\",\n-                    self.this_token_to_str()\n-                )\n-            );\n+            self.span_fatal(*self.span,\n+                            fmt!(\"expected `{` or `mod` but found `%s`\",\n+                                 self.this_token_to_str()));\n         }\n \n         let (sort, ident) = match *self.token {\n             token::IDENT(*) => (ast::named, self.parse_ident()),\n             _ => {\n                 if must_be_named_mod {\n-                    self.span_fatal(\n-                        copy *self.span,\n-                        fmt!(\n-                            \"expected foreign module name but found `%s`\",\n-                            self.this_token_to_str()\n-                        )\n-                    );\n+                    self.span_fatal(*self.span,\n+                                    fmt!(\"expected foreign module name but \\\n+                                          found `%s`\",\n+                                         self.this_token_to_str()));\n                 }\n \n                 (ast::anonymous,"}, {"sha": "8889fe91cc5921e3c51ac756c1ae6444032b61e1", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -424,7 +424,7 @@ impl Printer {\n     pub fn check_stack(&mut self, k: int) {\n         if !self.scan_stack_empty {\n             let x = self.scan_top();\n-            match copy self.token[x] {\n+            match self.token[x] {\n               BEGIN(_) => {\n                 if k > 0 {\n                     self.size[self.scan_pop()] = self.size[x] +"}, {"sha": "5b4a6d15a120683657df7ec997b56eb4fc95e2c1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -803,9 +803,17 @@ pub fn print_ty_method(s: @ps, m: &ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     maybe_print_comment(s, m.span.lo);\n     print_outer_attributes(s, m.attrs);\n-    print_ty_fn(s, None, None, &None, m.purity, ast::Many,\n-                &m.decl, Some(m.ident), &None, Some(&m.generics),\n-                Some(/*bad*/ copy m.explicit_self.node));\n+    print_ty_fn(s,\n+                None,\n+                None,\n+                &None,\n+                m.purity,\n+                ast::Many,\n+                &m.decl,\n+                Some(m.ident),\n+                &None,\n+                Some(&m.generics),\n+                Some(m.explicit_self.node));\n     word(s.s, \";\");\n }\n "}, {"sha": "5c5d154a4454b4182f3db088974f4a032cbe9922", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -361,18 +361,12 @@ pub fn visit_fn_decl<E: Copy>(fd: &fn_decl, (e, v): (E, vt<E>)) {\n // because it is not a default impl of any method, though I doubt that really\n // clarifies anything. - Niko\n pub fn visit_method_helper<E: Copy>(m: &method, (e, v): (E, vt<E>)) {\n-    (v.visit_fn)(\n-        &fk_method(\n-            /* FIXME (#2543) */ copy m.ident,\n-            &m.generics,\n-            m\n-        ),\n-        &m.decl,\n-        &m.body,\n-        m.span,\n-        m.id,\n-        (e, v)\n-    );\n+    (v.visit_fn)(&fk_method(m.ident, &m.generics, m),\n+                 &m.decl,\n+                 &m.body,\n+                 m.span,\n+                 m.id,\n+                 (e, v));\n }\n \n pub fn visit_fn<E: Copy>(fk: &fn_kind, decl: &fn_decl, body: &blk, _sp: span,"}, {"sha": "56c70e78092d122bb07d0d2cc4ddfaddb18e3f65", "filename": "src/test/run-pass/class-cast-to-trait-multiple-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-cast-to-trait-multiple-types.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -89,7 +89,7 @@ pub fn main() {\n   let nyan : cat  = cat(0u, 2, ~\"nyan\");\n   let whitefang : dog = dog();\n   annoy_neighbors(@(copy nyan) as @noisy);\n-  annoy_neighbors(@(copy whitefang) as @noisy);\n+  annoy_neighbors(@whitefang as @noisy);\n   assert_eq!(nyan.meow_count(), 10u);\n   assert_eq!(*whitefang.volume, 1);\n }"}, {"sha": "9a4519786e9a0a773930cd21ec8dc15678d36fc3", "filename": "src/test/run-pass/explicit-self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fexplicit-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -50,7 +50,7 @@ struct A { a: @int }\n \n fn thing(x: A) -> thing {\n     thing {\n-        x: copy x\n+        x: x\n     }\n }\n "}, {"sha": "4bc8d1f86de4258d378e7598151ec35a9523c82d", "filename": "src/test/run-pass/expr-copy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fexpr-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fexpr-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-copy.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -21,7 +21,7 @@ pub fn main() {\n     f(&mut x);\n     assert_eq!(x.a, 100);\n     x.a = 20;\n-    let mut y = copy x;\n+    let mut y = x;\n     f(&mut y);\n     assert_eq!(x.a, 20);\n }"}, {"sha": "5c94f059b49fa037c02500be9eaf395b5418d406", "filename": "src/test/run-pass/expr-repeat-vstore.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-repeat-vstore.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -14,9 +14,9 @@ fn main() {\n     println(v[3].to_str());\n     println(v[4].to_str());\n     let v: @mut [int] = @mut [ 3, ..5 ];\n-    println((copy v[0]).to_str());\n-    println((copy v[1]).to_str());\n-    println((copy v[2]).to_str());\n-    println((copy v[3]).to_str());\n-    println((copy v[4]).to_str());\n+    println((v[0]).to_str());\n+    println((v[1]).to_str());\n+    println((v[2]).to_str());\n+    println((v[3]).to_str());\n+    println((v[4]).to_str());\n }"}, {"sha": "43f14b790acda74f2e9ff33af84eeb8e10dae387", "filename": "src/test/run-pass/exterior.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexterior.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -18,7 +18,7 @@ fn f(p: @mut Point) { assert!((p.z == 12)); p.z = 13; assert!((p.z == 13)); }\n \n pub fn main() {\n     let a: Point = Point {x: 10, y: 11, z: 12};\n-    let b: @mut Point = @mut copy a;\n+    let b: @mut Point = @mut a;\n     assert_eq!(b.z, 12);\n     f(b);\n     assert_eq!(a.z, 12);"}, {"sha": "c86ce953de5e43e40ff2f39e1b7e7cc41161442e", "filename": "src/test/run-pass/issue-2633.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fissue-2633.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fissue-2633.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2633.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -27,5 +27,5 @@ fn nyan(kitty: cat, _kitty_info: KittyInfo) {\n \n pub fn main() {\n     let mut kitty = cat();\n-    nyan(copy kitty, KittyInfo {kitty: copy kitty});\n+    nyan(kitty, KittyInfo {kitty: kitty});\n }"}, {"sha": "590be377691a5218876bf438d8de761f52f7f922", "filename": "src/test/run-pass/ivec-add.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fivec-add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fivec-add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-add.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -10,7 +10,7 @@\n \n fn double<T:Copy>(a: T) -> ~[T] { return ~[copy a] + ~[a]; }\n \n-fn double_int(a: int) -> ~[int] { return ~[copy a] + ~[a]; }\n+fn double_int(a: int) -> ~[int] { return ~[a] + ~[a]; }\n \n pub fn main() {\n     let mut d = double(1);"}, {"sha": "056e3a4ff490f374d219130959e2eadf8f6fa47d", "filename": "src/test/run-pass/lambda-infer-unresolved.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flambda-infer-unresolved.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -16,6 +16,6 @@ struct Refs { refs: ~[int], n: int }\n \n pub fn main() {\n     let e = @mut Refs{refs: ~[], n: 0};\n-    let f: @fn() = || error!(copy e.n);\n+    let f: @fn() = || error!(e.n);\n     e.refs.push(1);\n }"}, {"sha": "b7612592830ee098fc401ac5d602dbbdbbdb519e", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -43,7 +43,7 @@ fn runtest2(f: extern fn(), frame_backoff: u32, last_stk: *u8) -> u32 {\n             // We switched stacks, go back and try to hit the dynamic linker\n             frame_backoff\n         } else {\n-            let frame_backoff = runtest2(copy f, frame_backoff, curr_stk);\n+            let frame_backoff = runtest2(f, frame_backoff, curr_stk);\n             if frame_backoff > 1u32 {\n                 frame_backoff - 1u32\n             } else if frame_backoff == 1u32 {"}, {"sha": "e557fae7ac933d9d225f6a0cf5ad16e5fed59622", "filename": "src/test/run-pass/nullable-pointer-iotareduction.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4e674f6e662bc80f2e7a5a1a9834f2152f08d32/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnullable-pointer-iotareduction.rs?ref=b4e674f6e662bc80f2e7a5a1a9834f2152f08d32", "patch": "@@ -36,7 +36,6 @@ impl<T> E<T> {\n \n macro_rules! check_option {\n     ($e:expr: $T:ty) => {{\n-        // FIXME #6000: remove the copy\n         check_option!(copy $e: $T, |ptr| assert!(*ptr == $e));\n     }};\n     ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{\n@@ -49,7 +48,6 @@ macro_rules! check_option {\n \n macro_rules! check_fancy {\n     ($e:expr: $T:ty) => {{\n-        // FIXME #6000: remove the copy\n         check_fancy!(copy $e: $T, |ptr| assert!(*ptr == $e));\n     }};\n     ($e:expr: $T:ty, |$v:ident| $chk:expr) => {{"}]}