{"sha": "918ef671b04398560d8860363736ba120825e6fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxOGVmNjcxYjA0Mzk4NTYwZDg4NjAzNjM3MzZiYTEyMDgyNWU2ZmU=", "commit": {"author": {"name": "boats", "email": "boats@mozilla.com", "date": "2018-03-14T22:57:25Z"}, "committer": {"name": "boats", "email": "boats@mozilla.com", "date": "2018-03-14T22:57:25Z"}, "message": "Pin and Unpin in libcore.", "tree": {"sha": "c2f9323fe99b237cc8015ff54a095e94decd8130", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2f9323fe99b237cc8015ff54a095e94decd8130"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/918ef671b04398560d8860363736ba120825e6fe", "comment_count": 0, "verification": {"verified": false, "reason": "no_user", "signature": "-----BEGIN PGP SIGNATURE-----\n\niHUEABYIAB0WIQSrtBlUz85gHk4onJKSU3shEQpoSwUCWqmo2gAKCRCSU3shEQpo\nS3cnAPwOWRuX2bZsU79Lq0QRHfguT3Jag86dqOhOM3i2XeRRkQD/W4eh4d6TURa7\nDJ6KxXOLAnDt5TKW2Cb07AhXlhxdCgA=\n=XxPi\n-----END PGP SIGNATURE-----", "payload": "tree c2f9323fe99b237cc8015ff54a095e94decd8130\nparent c9334404f06a188854af33835a0efe1e834e4ac4\nauthor boats <boats@mozilla.com> 1521068245 -0700\ncommitter boats <boats@mozilla.com> 1521068245 -0700\n\nPin and Unpin in libcore.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/918ef671b04398560d8860363736ba120825e6fe", "html_url": "https://github.com/rust-lang/rust/commit/918ef671b04398560d8860363736ba120825e6fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/918ef671b04398560d8860363736ba120825e6fe/comments", "author": null, "committer": null, "parents": [{"sha": "c9334404f06a188854af33835a0efe1e834e4ac4", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9334404f06a188854af33835a0efe1e834e4ac4", "html_url": "https://github.com/rust-lang/rust/commit/c9334404f06a188854af33835a0efe1e834e4ac4"}], "stats": {"total": 121, "additions": 119, "deletions": 2}, "files": [{"sha": "7b67404db5d968d8d6cf3fe27531b8e756bc69c5", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/918ef671b04398560d8860363736ba120825e6fe/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918ef671b04398560d8860363736ba120825e6fe/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=918ef671b04398560d8860363736ba120825e6fe", "patch": "@@ -565,3 +565,13 @@ unsafe impl<T: ?Sized> Freeze for *const T {}\n unsafe impl<T: ?Sized> Freeze for *mut T {}\n unsafe impl<'a, T: ?Sized> Freeze for &'a T {}\n unsafe impl<'a, T: ?Sized> Freeze for &'a mut T {}\n+\n+/// Types which can be moved out of a `Pin`.\n+///\n+/// The `Unpin` trait is used to control the behavior of the [`Pin`] type. If a\n+/// type implements `Unpin`, it is safe to move a value of that type out of the\n+/// `Pin` pointer.\n+///\n+/// This trait is automatically implemented for almost every type.\n+#[unstable(feature = \"pin\", issue = \"0\")]\n+pub unsafe auto trait Unpin {}"}, {"sha": "792d71732e665f651a4919d335ce8814c20faa0d", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 109, "deletions": 2, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/918ef671b04398560d8860363736ba120825e6fe/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/918ef671b04398560d8860363736ba120825e6fe/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=918ef671b04398560d8860363736ba120825e6fe", "patch": "@@ -20,9 +20,9 @@ use cmp;\n use fmt;\n use hash;\n use intrinsics;\n-use marker::{Copy, PhantomData, Sized};\n+use marker::{Copy, PhantomData, Sized, Unpin, Unsize};\n use ptr;\n-use ops::{Deref, DerefMut};\n+use ops::{Deref, DerefMut, CoerceUnsized};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use intrinsics::transmute;\n@@ -1105,3 +1105,110 @@ impl<T: ::hash::Hash> ::hash::Hash for ManuallyDrop<T> {\n pub unsafe fn unreachable() -> ! {\n     intrinsics::unreachable()\n }\n+\n+/// A pinned reference.\n+///\n+/// A pinned reference is a lot like a mutable reference, except that it is not\n+/// safe to move a value out of a pinned reference unless the type of that\n+/// value implements the `Unpin` trait.\n+#[unstable(feature = \"pin\", issue = \"0\")]\n+pub struct Pin<'a, T: ?Sized + 'a> {\n+    inner: &'a mut T,\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"0\")]\n+impl<'a, T: ?Sized + Unpin> Pin<'a, T> {\n+    /// Construct a new `Pin` around a reference to some data of a type that\n+    /// implements `Unpin`.\n+    #[unstable(feature = \"pin\", issue = \"0\")]\n+    pub fn new(reference: &'a mut T) -> Pin<'a, T> {\n+        Pin { inner: reference }\n+    }\n+}\n+\n+\n+#[unstable(feature = \"pin\", issue = \"0\")]\n+impl<'a, T: ?Sized> Pin<'a, T> {\n+    /// Construct a new `Pin` around a reference to some data of a type that\n+    /// may or may not implement `Unpin`.\n+    ///\n+    /// This constructor is unsafe because we do not know what will happen with\n+    /// that data after the reference ends. If you cannot guarantee that the\n+    /// data will never move again, calling this constructor is invalid.\n+    #[unstable(feature = \"pin\", issue = \"0\")]\n+    pub unsafe fn new_unchecked(reference: &'a mut T) -> Pin<'a, T> {\n+        Pin { inner: reference }\n+    }\n+\n+    /// Borrow a Pin for a shorter lifetime than it already has.\n+    #[unstable(feature = \"pin\", issue = \"0\")]\n+    pub fn borrow<'b>(this: &'b mut Pin<'a, T>) -> Pin<'b, T> {\n+        Pin { inner: this.inner }\n+    }\n+\n+    /// Get a mutable reference to the data inside of this `Pin`.\n+    ///\n+    /// This function is unsafe. You must guarantee that you will never move\n+    /// the data out of the mutable reference you receive when you call this\n+    /// function.\n+    #[unstable(feature = \"pin\", issue = \"0\")]\n+    pub unsafe fn get_mut<'b>(this: &'b mut Pin<'a, T>) -> &'b mut T {\n+        this.inner\n+    }\n+\n+    /// Construct a new pin by mapping the interior value.\n+    ///\n+    /// For example, if you  wanted to get a `Pin` of a field of something, you\n+    /// could use this to get access to that field in one line of code.\n+    ///\n+    /// This function is unsafe. You must guarantee that the data you return\n+    /// will not move so long as the argument value does not move (for example,\n+    /// because it is one of the fields of that value), and also that you do\n+    /// not move out of the argument you receive to the interior function.\n+    #[unstable(feature = \"pin\", issue = \"0\")]\n+    pub unsafe fn map<'b, U, F>(this: &'b mut Pin<'a, T>, f: F) -> Pin<'b, U> where\n+        F: FnOnce(&mut T) -> &mut U\n+    {\n+        Pin { inner: f(this.inner) }\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"0\")]\n+impl<'a, T: ?Sized> Deref for Pin<'a, T> {\n+    type Target = T;\n+\n+    fn deref(&self) -> &T {\n+        &*self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"0\")]\n+impl<'a, T: ?Sized + Unpin> DerefMut for Pin<'a, T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        self.inner\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"0\")]\n+impl<'a, T: fmt::Debug + ?Sized> fmt::Debug for Pin<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&**self, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"0\")]\n+impl<'a, T: fmt::Display + ?Sized> fmt::Display for Pin<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&**self, f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"0\")]\n+impl<'a, T: ?Sized> fmt::Pointer for Pin<'a, T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Pointer::fmt(&(&*self.inner as *const T), f)\n+    }\n+}\n+\n+#[unstable(feature = \"pin\", issue = \"0\")]\n+impl<'a, T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Pin<'a, U>> for Pin<'a, T> {}"}]}