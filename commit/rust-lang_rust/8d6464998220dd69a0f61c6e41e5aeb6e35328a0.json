{"sha": "8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkNjQ2NDk5ODIyMGRkNjlhMGY2MWM2ZTQxZTVhZWI2ZTM1MzI4YTA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-09-04T02:22:35Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-09-04T10:02:53Z"}, "message": "Rollup merge of #36132 - nrc:save-std, r=@eddyb\n\nAdd --Zsave-analysis-api\n\nThis is a save-analysis variation which can be used with libraries distributed without their source (e.g., libstd). It will allow IDEs and other tools to get info about types and create URLs to docs and source, without the unnecessary clutter of internal-only save-analysis info. I'm sure we'll iterate somewhat on the design, but this is a first draft.", "tree": {"sha": "d1cbd613bee8663394d36f37d3b20d767460be30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1cbd613bee8663394d36f37d3b20d767460be30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "html_url": "https://github.com/rust-lang/rust/commit/8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b889154e116951e6c121a2628acbb6d3f340793", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b889154e116951e6c121a2628acbb6d3f340793", "html_url": "https://github.com/rust-lang/rust/commit/4b889154e116951e6c121a2628acbb6d3f340793"}, {"sha": "377be7a5014052766784b2dda1d5b5e33e191b6b", "url": "https://api.github.com/repos/rust-lang/rust/commits/377be7a5014052766784b2dda1d5b5e33e191b6b", "html_url": "https://github.com/rust-lang/rust/commit/377be7a5014052766784b2dda1d5b5e33e191b6b"}], "stats": {"total": 691, "additions": 608, "deletions": 83}, "files": [{"sha": "e80f004f150a2b196326722946c60ad5803c94fe", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "patch": "@@ -849,9 +849,13 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     ls: bool = (false, parse_bool, [UNTRACKED],\n         \"list the symbols defined by a library crate\"),\n     save_analysis: bool = (false, parse_bool, [UNTRACKED],\n-        \"write syntax and type analysis (in JSON format) information in addition to normal output\"),\n+        \"write syntax and type analysis (in JSON format) information, in \\\n+         addition to normal output\"),\n     save_analysis_csv: bool = (false, parse_bool, [UNTRACKED],\n-        \"write syntax and type analysis (in CSV format) information in addition to normal output\"),\n+        \"write syntax and type analysis (in CSV format) information, in addition to normal output\"),\n+    save_analysis_api: bool = (false, parse_bool, [UNTRACKED],\n+        \"write syntax and type analysis information for opaque libraries (in JSON format), \\\n+         in addition to normal output\"),\n     print_move_fragments: bool = (false, parse_bool, [UNTRACKED],\n         \"print out move-fragment data for every fn\"),\n     flowgraph_print_loans: bool = (false, parse_bool, [UNTRACKED],\n@@ -2365,6 +2369,8 @@ mod tests {\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.save_analysis_csv = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n+        opts.debugging_opts.save_analysis_api = true;\n+        assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.print_move_fragments = true;\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n         opts.debugging_opts.flowgraph_print_loans = true;"}, {"sha": "e059b6445c120ce633222935f643a2a86a7f0f67", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "patch": "@@ -250,7 +250,8 @@ fn keep_hygiene_data(sess: &Session) -> bool {\n fn keep_ast(sess: &Session) -> bool {\n     sess.opts.debugging_opts.keep_ast ||\n     sess.opts.debugging_opts.save_analysis ||\n-    sess.opts.debugging_opts.save_analysis_csv\n+    sess.opts.debugging_opts.save_analysis_csv ||\n+    sess.opts.debugging_opts.save_analysis_api\n }\n \n /// The name used for source code that doesn't originate in a file"}, {"sha": "ef2234a5f6192ae7c42139831f1a73a0381a34b0", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "patch": "@@ -555,14 +555,17 @@ impl<'a> CompilerCalls<'a> for RustcDefaultCalls {\n \n fn save_analysis(sess: &Session) -> bool {\n     sess.opts.debugging_opts.save_analysis ||\n-    sess.opts.debugging_opts.save_analysis_csv\n+    sess.opts.debugging_opts.save_analysis_csv ||\n+    sess.opts.debugging_opts.save_analysis_api\n }\n \n fn save_analysis_format(sess: &Session) -> save::Format {\n     if sess.opts.debugging_opts.save_analysis {\n         save::Format::Json\n     } else if sess.opts.debugging_opts.save_analysis_csv {\n         save::Format::Csv\n+    } else if sess.opts.debugging_opts.save_analysis_api {\n+        save::Format::JsonApi\n     } else {\n         unreachable!();\n     }"}, {"sha": "a58cce0745f304c5a3b37cc1b12635944c723e59", "filename": "src/librustc_save_analysis/data.rs", "status": "modified", "additions": 50, "deletions": 6, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_save_analysis%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_save_analysis%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdata.rs?ref=8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "patch": "@@ -13,8 +13,9 @@\n //! The `Dump` trait can be used together with `DumpVisitor` in order to\n //! retrieve the data from a crate.\n \n+use rustc::hir;\n use rustc::hir::def_id::DefId;\n-use syntax::ast::{CrateNum, NodeId};\n+use syntax::ast::{self, CrateNum, NodeId};\n use syntax_pos::Span;\n \n pub struct CrateData {\n@@ -76,6 +77,35 @@ pub enum Data {\n     VariableRefData(VariableRefData),\n }\n \n+#[derive(Eq, PartialEq, Clone, Copy, Debug, RustcEncodable)]\n+pub enum Visibility {\n+    Public,\n+    Restricted,\n+    Inherited,\n+}\n+\n+impl<'a> From<&'a ast::Visibility> for Visibility {\n+    fn from(v: &'a ast::Visibility) -> Visibility {\n+        match *v {\n+            ast::Visibility::Public => Visibility::Public,\n+            ast::Visibility::Crate(_) => Visibility::Restricted,\n+            ast::Visibility::Restricted { .. } => Visibility::Restricted,\n+            ast::Visibility::Inherited => Visibility::Inherited,\n+        }\n+    }\n+}\n+\n+impl<'a> From<&'a hir::Visibility> for Visibility {\n+    fn from(v: &'a hir::Visibility) -> Visibility {\n+        match *v {\n+            hir::Visibility::Public => Visibility::Public,\n+            hir::Visibility::Crate => Visibility::Restricted,\n+            hir::Visibility::Restricted { .. } => Visibility::Restricted,\n+            hir::Visibility::Inherited => Visibility::Inherited,\n+        }\n+    }\n+}\n+\n /// Data for the prelude of a crate.\n #[derive(Debug, RustcEncodable)]\n pub struct CratePreludeData {\n@@ -103,7 +133,7 @@ pub struct EnumData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub variants: Vec<NodeId>,\n-\n+    pub visibility: Visibility,\n }\n \n /// Data for extern crates.\n@@ -135,6 +165,8 @@ pub struct FunctionData {\n     pub span: Span,\n     pub scope: NodeId,\n     pub value: String,\n+    pub visibility: Visibility,\n+    pub parent: Option<NodeId>,\n }\n \n /// Data about a function call.\n@@ -215,6 +247,7 @@ pub struct MethodData {\n     pub scope: NodeId,\n     pub value: String,\n     pub decl_id: Option<DefId>,\n+    pub visibility: Visibility,\n }\n \n /// Data for modules.\n@@ -227,6 +260,7 @@ pub struct ModData {\n     pub scope: NodeId,\n     pub filename: String,\n     pub items: Vec<NodeId>,\n+    pub visibility: Visibility,\n }\n \n /// Data for a reference to a module.\n@@ -248,6 +282,7 @@ pub struct StructData {\n     pub scope: NodeId,\n     pub value: String,\n     pub fields: Vec<NodeId>,\n+    pub visibility: Visibility,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -258,7 +293,8 @@ pub struct StructVariantData {\n     pub qualname: String,\n     pub type_value: String,\n     pub value: String,\n-    pub scope: NodeId\n+    pub scope: NodeId,\n+    pub parent: Option<NodeId>,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -270,6 +306,7 @@ pub struct TraitData {\n     pub scope: NodeId,\n     pub value: String,\n     pub items: Vec<NodeId>,\n+    pub visibility: Visibility,\n }\n \n #[derive(Debug, RustcEncodable)]\n@@ -280,7 +317,8 @@ pub struct TupleVariantData {\n     pub qualname: String,\n     pub type_value: String,\n     pub value: String,\n-    pub scope: NodeId\n+    pub scope: NodeId,\n+    pub parent: Option<NodeId>,\n }\n \n /// Data for a typedef.\n@@ -291,6 +329,8 @@ pub struct TypeDefData {\n     pub span: Span,\n     pub qualname: String,\n     pub value: String,\n+    pub visibility: Visibility,\n+    pub parent: Option<NodeId>,\n }\n \n /// Data for a reference to a type or trait.\n@@ -308,15 +348,17 @@ pub struct UseData {\n     pub span: Span,\n     pub name: String,\n     pub mod_id: Option<DefId>,\n-    pub scope: NodeId\n+    pub scope: NodeId,\n+    pub visibility: Visibility,\n }\n \n #[derive(Debug, RustcEncodable)]\n pub struct UseGlobData {\n     pub id: NodeId,\n     pub span: Span,\n     pub names: Vec<String>,\n-    pub scope: NodeId\n+    pub scope: NodeId,\n+    pub visibility: Visibility,\n }\n \n /// Data for local and global variables (consts and statics).\n@@ -328,8 +370,10 @@ pub struct VariableData {\n     pub qualname: String,\n     pub span: Span,\n     pub scope: NodeId,\n+    pub parent: Option<NodeId>,\n     pub value: String,\n     pub type_value: String,\n+    pub visibility: Visibility,\n }\n \n #[derive(Debug, RustcEncodable)]"}, {"sha": "a695a07066205b4e26971951bf2a44720336f047", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 91, "deletions": 63, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "patch": "@@ -365,7 +365,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                         qualname: format!(\"{}::{}\", qualname, path_to_string(p)),\n                         type_value: typ,\n                         value: String::new(),\n-                        scope: 0\n+                        scope: 0,\n+                        parent: None,\n+                        visibility: Visibility::Inherited,\n                     }.lower(self.tcx));\n                 }\n             }\n@@ -377,6 +379,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                       body: Option<&ast::Block>,\n                       id: ast::NodeId,\n                       name: ast::Name,\n+                      vis: Visibility,\n                       span: Span) {\n         debug!(\"process_method: {}:{}\", id, name);\n \n@@ -417,6 +420,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     qualname: method_data.qualname.clone(),\n                     value: sig_str,\n                     decl_id: decl_id,\n+                    visibility: vis,\n                 }.lower(self.tcx));\n             }\n \n@@ -484,7 +488,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     name: name,\n                     id: param.id,\n                     qualname: qualname,\n-                    value: String::new()\n+                    value: String::new(),\n+                    visibility: Visibility::Inherited,\n+                    parent: None,\n                 }.lower(self.tcx));\n             }\n         }\n@@ -528,12 +534,14 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         self.visit_expr(expr);\n     }\n \n-    fn process_const(&mut self,\n-                     id: ast::NodeId,\n-                     name: ast::Name,\n-                     span: Span,\n-                     typ: &ast::Ty,\n-                     expr: &ast::Expr) {\n+    fn process_assoc_const(&mut self,\n+                           id: ast::NodeId,\n+                           name: ast::Name,\n+                           span: Span,\n+                           typ: &ast::Ty,\n+                           expr: &ast::Expr,\n+                           parent_id: NodeId,\n+                           vis: Visibility) {\n         let qualname = format!(\"::{}\", self.tcx.node_path_str(id));\n \n         let sub_span = self.span.sub_span_after_keyword(span, keywords::Const);\n@@ -547,7 +555,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 qualname: qualname,\n                 value: self.span.snippet(expr.span),\n                 type_value: ty_to_string(&typ),\n-                scope: self.cur_scope\n+                scope: self.cur_scope,\n+                parent: Some(parent_id),\n+                visibility: vis,\n             }.lower(self.tcx));\n         }\n \n@@ -589,6 +599,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 scope: self.cur_scope,\n                 value: val,\n                 fields: fields,\n+                visibility: From::from(&item.vis),\n             }.lower(self.tcx));\n         }\n \n@@ -640,7 +651,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             qualname: qualname,\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n-                            scope: enum_data.scope\n+                            scope: enum_data.scope,\n+                            parent: Some(item.id),\n                         }.lower(self.tcx));\n                     }\n                 }\n@@ -663,7 +675,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                             qualname: qualname,\n                             type_value: enum_data.qualname.clone(),\n                             value: val,\n-                            scope: enum_data.scope\n+                            scope: enum_data.scope,\n+                            parent: Some(item.id),\n                         }.lower(self.tcx));\n                     }\n                 }\n@@ -716,7 +729,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         }\n         self.process_generic_params(type_parameters, item.span, \"\", item.id);\n         for impl_item in impl_items {\n-            self.visit_impl_item(impl_item);\n+            self.process_impl_item(impl_item, item.id);\n         }\n     }\n \n@@ -745,6 +758,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                 scope: self.cur_scope,\n                 value: val,\n                 items: methods.iter().map(|i| i.id).collect(),\n+                visibility: From::from(&item.vis),\n             }.lower(self.tcx));\n         }\n \n@@ -785,7 +799,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n         // walk generics and methods\n         self.process_generic_params(generics, item.span, &qualname, item.id);\n         for method in methods {\n-            self.visit_trait_item(method)\n+            self.process_trait_item(method, item.id)\n         }\n     }\n \n@@ -990,7 +1004,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                     qualname: format!(\"{}${}\", path_to_string(p), id),\n                     value: value,\n                     type_value: typ,\n-                    scope: 0\n+                    scope: 0,\n+                    parent: None,\n+                    visibility: Visibility::Inherited,\n                 }.lower(self.tcx));\n             }\n         }\n@@ -1038,6 +1054,57 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n             }\n         }\n     }\n+\n+    fn process_trait_item(&mut self, trait_item: &ast::TraitItem, trait_id: NodeId) {\n+        self.process_macro_use(trait_item.span, trait_item.id);\n+        match trait_item.node {\n+            ast::TraitItemKind::Const(ref ty, Some(ref expr)) => {\n+                self.process_assoc_const(trait_item.id,\n+                                         trait_item.ident.name,\n+                                         trait_item.span,\n+                                         &ty,\n+                                         &expr,\n+                                         trait_id,\n+                                         Visibility::Public);\n+            }\n+            ast::TraitItemKind::Method(ref sig, ref body) => {\n+                self.process_method(sig,\n+                                    body.as_ref().map(|x| &**x),\n+                                    trait_item.id,\n+                                    trait_item.ident.name,\n+                                    Visibility::Public,\n+                                    trait_item.span);\n+            }\n+            ast::TraitItemKind::Const(_, None) |\n+            ast::TraitItemKind::Type(..) |\n+            ast::TraitItemKind::Macro(_) => {}\n+        }\n+    }\n+\n+    fn process_impl_item(&mut self, impl_item: &ast::ImplItem, impl_id: NodeId) {\n+        self.process_macro_use(impl_item.span, impl_item.id);\n+        match impl_item.node {\n+            ast::ImplItemKind::Const(ref ty, ref expr) => {\n+                self.process_assoc_const(impl_item.id,\n+                                         impl_item.ident.name,\n+                                         impl_item.span,\n+                                         &ty,\n+                                         &expr,\n+                                         impl_id,\n+                                         From::from(&impl_item.vis));\n+            }\n+            ast::ImplItemKind::Method(ref sig, ref body) => {\n+                self.process_method(sig,\n+                                    Some(body),\n+                                    impl_item.id,\n+                                    impl_item.ident.name,\n+                                    From::from(&impl_item.vis),\n+                                    impl_item.span);\n+            }\n+            ast::ImplItemKind::Type(_) |\n+            ast::ImplItemKind::Macro(_) => {}\n+        }\n+    }\n }\n \n impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D> {\n@@ -1073,7 +1140,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                                 id: item.id,\n                                 mod_id: mod_id,\n                                 name: ident.to_string(),\n-                                scope: self.cur_scope\n+                                scope: self.cur_scope,\n+                                visibility: From::from(&item.vis),\n                             }.lower(self.tcx));\n                         }\n                         self.write_sub_paths_truncated(path, true);\n@@ -1096,7 +1164,8 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                                 span: sub_span.expect(\"No span found for use glob\"),\n                                 id: item.id,\n                                 names: names,\n-                                scope: self.cur_scope\n+                                scope: self.cur_scope,\n+                                visibility: From::from(&item.vis),\n                             }.lower(self.tcx));\n                         }\n                         self.write_sub_paths(path, true);\n@@ -1168,7 +1237,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                         name: item.ident.to_string(),\n                         id: item.id,\n                         qualname: qualname.clone(),\n-                        value: value\n+                        value: value,\n+                        visibility: From::from(&item.vis),\n+                        parent: None,\n                     }.lower(self.tcx));\n                 }\n \n@@ -1193,51 +1264,6 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n         }\n     }\n \n-    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n-        self.process_macro_use(trait_item.span, trait_item.id);\n-        match trait_item.node {\n-            ast::TraitItemKind::Const(ref ty, Some(ref expr)) => {\n-                self.process_const(trait_item.id,\n-                                   trait_item.ident.name,\n-                                   trait_item.span,\n-                                   &ty,\n-                                   &expr);\n-            }\n-            ast::TraitItemKind::Method(ref sig, ref body) => {\n-                self.process_method(sig,\n-                                    body.as_ref().map(|x| &**x),\n-                                    trait_item.id,\n-                                    trait_item.ident.name,\n-                                    trait_item.span);\n-            }\n-            ast::TraitItemKind::Const(_, None) |\n-            ast::TraitItemKind::Type(..) |\n-            ast::TraitItemKind::Macro(_) => {}\n-        }\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &ast::ImplItem) {\n-        self.process_macro_use(impl_item.span, impl_item.id);\n-        match impl_item.node {\n-            ast::ImplItemKind::Const(ref ty, ref expr) => {\n-                self.process_const(impl_item.id,\n-                                   impl_item.ident.name,\n-                                   impl_item.span,\n-                                   &ty,\n-                                   &expr);\n-            }\n-            ast::ImplItemKind::Method(ref sig, ref body) => {\n-                self.process_method(sig,\n-                                    Some(body),\n-                                    impl_item.id,\n-                                    impl_item.ident.name,\n-                                    impl_item.span);\n-            }\n-            ast::ImplItemKind::Type(_) |\n-            ast::ImplItemKind::Macro(_) => {}\n-        }\n-    }\n-\n     fn visit_ty(&mut self, t: &ast::Ty) {\n         self.process_macro_use(t.span, t.id);\n         match t.node {\n@@ -1400,7 +1426,9 @@ impl<'l, 'tcx: 'l, 'll, D: Dump +'ll> Visitor for DumpVisitor<'l, 'tcx, 'll, D>\n                             qualname: format!(\"{}${}\", path_to_string(p), id),\n                             value: value,\n                             type_value: String::new(),\n-                            scope: 0\n+                            scope: 0,\n+                            parent: None,\n+                            visibility: Visibility::Inherited,\n                         }.lower(self.tcx));\n                     }\n                 }"}, {"sha": "4333c6dd18e60bb522ec05c892ba29261c468a0e", "filename": "src/librustc_save_analysis/external_data.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_save_analysis%2Fexternal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fexternal_data.rs?ref=8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "patch": "@@ -15,7 +15,7 @@ use syntax::ast::{CrateNum, NodeId};\n use syntax::codemap::CodeMap;\n use syntax_pos::Span;\n \n-use data;\n+use data::{self, Visibility};\n \n // FIXME: this should be pub(crate), but the current snapshot doesn't allow it yet\n pub trait Lower {\n@@ -91,7 +91,8 @@ pub struct EnumData {\n     pub qualname: String,\n     pub span: SpanData,\n     pub scope: DefId,\n-    pub variants: Vec<DefId>\n+    pub variants: Vec<DefId>,\n+    pub visibility: Visibility,\n }\n \n impl Lower for data::EnumData {\n@@ -106,6 +107,7 @@ impl Lower for data::EnumData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n             variants: self.variants.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n+            visibility: self.visibility,\n         }\n     }\n }\n@@ -166,6 +168,8 @@ pub struct FunctionData {\n     pub span: SpanData,\n     pub scope: DefId,\n     pub value: String,\n+    pub visibility: Visibility,\n+    pub parent: Option<DefId>,\n }\n \n impl Lower for data::FunctionData {\n@@ -180,6 +184,8 @@ impl Lower for data::FunctionData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             scope: make_def_id(self.scope, &tcx.map),\n             value: self.value,\n+            visibility: self.visibility,\n+            parent: self.parent.map(|id| make_def_id(id, &tcx.map)),\n         }\n     }\n }\n@@ -323,6 +329,8 @@ pub struct MethodData {\n     pub scope: DefId,\n     pub value: String,\n     pub decl_id: Option<DefId>,\n+    pub visibility: Visibility,\n+    pub parent: Option<DefId>\n }\n \n impl Lower for data::MethodData {\n@@ -337,6 +345,8 @@ impl Lower for data::MethodData {\n             qualname: self.qualname,\n             value: self.value,\n             decl_id: self.decl_id,\n+            visibility: self.visibility,\n+            parent: Some(make_def_id(self.scope, &tcx.map)),\n         }\n     }\n }\n@@ -351,6 +361,7 @@ pub struct ModData {\n     pub scope: DefId,\n     pub filename: String,\n     pub items: Vec<DefId>,\n+    pub visibility: Visibility,\n }\n \n impl Lower for data::ModData {\n@@ -365,6 +376,7 @@ impl Lower for data::ModData {\n             scope: make_def_id(self.scope, &tcx.map),\n             filename: self.filename,\n             items: self.items.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n+            visibility: self.visibility,\n         }\n     }\n }\n@@ -401,6 +413,7 @@ pub struct StructData {\n     pub scope: DefId,\n     pub value: String,\n     pub fields: Vec<DefId>,\n+    pub visibility: Visibility,\n }\n \n impl Lower for data::StructData {\n@@ -416,6 +429,7 @@ impl Lower for data::StructData {\n             scope: make_def_id(self.scope, &tcx.map),\n             value: self.value,\n             fields: self.fields.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n+            visibility: self.visibility,\n         }\n     }\n }\n@@ -428,7 +442,8 @@ pub struct StructVariantData {\n     pub qualname: String,\n     pub type_value: String,\n     pub value: String,\n-    pub scope: DefId\n+    pub scope: DefId,\n+    pub parent: Option<DefId>,\n }\n \n impl Lower for data::StructVariantData {\n@@ -443,6 +458,7 @@ impl Lower for data::StructVariantData {\n             type_value: self.type_value,\n             value: self.value,\n             scope: make_def_id(self.scope, &tcx.map),\n+            parent: self.parent.map(|id| make_def_id(id, &tcx.map)),\n         }\n     }\n }\n@@ -456,6 +472,7 @@ pub struct TraitData {\n     pub scope: DefId,\n     pub value: String,\n     pub items: Vec<DefId>,\n+    pub visibility: Visibility,\n }\n \n impl Lower for data::TraitData {\n@@ -470,6 +487,7 @@ impl Lower for data::TraitData {\n             scope: make_def_id(self.scope, &tcx.map),\n             value: self.value,\n             items: self.items.into_iter().map(|id| make_def_id(id, &tcx.map)).collect(),\n+            visibility: self.visibility,\n         }\n     }\n }\n@@ -483,6 +501,7 @@ pub struct TupleVariantData {\n     pub type_value: String,\n     pub value: String,\n     pub scope: DefId,\n+    pub parent: Option<DefId>,\n }\n \n impl Lower for data::TupleVariantData {\n@@ -497,6 +516,7 @@ impl Lower for data::TupleVariantData {\n             type_value: self.type_value,\n             value: self.value,\n             scope: make_def_id(self.scope, &tcx.map),\n+            parent: self.parent.map(|id| make_def_id(id, &tcx.map)),\n         }\n     }\n }\n@@ -509,6 +529,8 @@ pub struct TypeDefData {\n     pub span: SpanData,\n     pub qualname: String,\n     pub value: String,\n+    pub visibility: Visibility,\n+    pub parent: Option<DefId>,\n }\n \n impl Lower for data::TypeDefData {\n@@ -521,6 +543,8 @@ impl Lower for data::TypeDefData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             qualname: self.qualname,\n             value: self.value,\n+            visibility: self.visibility,\n+            parent: self.parent.map(|id| make_def_id(id, &tcx.map)),\n         }\n     }\n }\n@@ -553,7 +577,8 @@ pub struct UseData {\n     pub span: SpanData,\n     pub name: String,\n     pub mod_id: Option<DefId>,\n-    pub scope: DefId\n+    pub scope: DefId,\n+    pub visibility: Visibility,\n }\n \n impl Lower for data::UseData {\n@@ -566,6 +591,7 @@ impl Lower for data::UseData {\n             name: self.name,\n             mod_id: self.mod_id,\n             scope: make_def_id(self.scope, &tcx.map),\n+            visibility: self.visibility,\n         }\n     }\n }\n@@ -575,7 +601,8 @@ pub struct UseGlobData {\n     pub id: DefId,\n     pub span: SpanData,\n     pub names: Vec<String>,\n-    pub scope: DefId\n+    pub scope: DefId,\n+    pub visibility: Visibility,\n }\n \n impl Lower for data::UseGlobData {\n@@ -587,6 +614,7 @@ impl Lower for data::UseGlobData {\n             span: SpanData::from_span(self.span, tcx.sess.codemap()),\n             names: self.names,\n             scope: make_def_id(self.scope, &tcx.map),\n+            visibility: self.visibility,\n         }\n     }\n }\n@@ -602,6 +630,8 @@ pub struct VariableData {\n     pub scope: DefId,\n     pub value: String,\n     pub type_value: String,\n+    pub parent: Option<DefId>,\n+    pub visibility: Visibility,\n }\n \n impl Lower for data::VariableData {\n@@ -617,6 +647,8 @@ impl Lower for data::VariableData {\n             scope: make_def_id(self.scope, &tcx.map),\n             value: self.value,\n             type_value: self.type_value,\n+            parent: self.parent.map(|id| make_def_id(id, &tcx.map)),\n+            visibility: self.visibility,\n         }\n     }\n }"}, {"sha": "874babb907e4c8085d4d6b01e51313050acdc5e1", "filename": "src/librustc_save_analysis/json_api_dumper.rs", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/rust-lang/rust/blob/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fjson_api_dumper.rs?ref=8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "patch": "@@ -0,0 +1,393 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::io::Write;\n+\n+use rustc::hir::def_id::DefId;\n+use rustc_serialize::json::as_json;\n+\n+use external_data::*;\n+use data::{VariableKind, Visibility};\n+use dump::Dump;\n+\n+// A dumper to dump a restricted set of JSON information, designed for use with\n+// libraries distributed without their source. Clients are likely to use type\n+// information here, and (for example) generate Rustdoc URLs, but don't need\n+// information for navigating the source of the crate.\n+// Relative to the regular JSON save-analysis info, this form is filtered to\n+// remove non-visible items, but includes some extra info for items (e.g., the\n+// parent field for finding the struct to which a field belongs).\n+pub struct JsonApiDumper<'b, W: Write + 'b> {\n+    output: &'b mut W,\n+    result: Analysis,\n+}\n+\n+impl<'b, W: Write> JsonApiDumper<'b, W> {\n+    pub fn new(writer: &'b mut W) -> JsonApiDumper<'b, W> {\n+        JsonApiDumper { output: writer, result: Analysis::new() }\n+    }\n+}\n+\n+impl<'b, W: Write> Drop for JsonApiDumper<'b, W> {\n+    fn drop(&mut self) {\n+        if let Err(_) = write!(self.output, \"{}\", as_json(&self.result)) {\n+            error!(\"Error writing output\");\n+        }\n+    }\n+}\n+\n+macro_rules! impl_fn {\n+    ($fn_name: ident, $data_type: ident, $bucket: ident) => {\n+        fn $fn_name(&mut self, data: $data_type) {\n+            if let Some(datum) = From::from(data) {\n+                self.result.$bucket.push(datum);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'b, W: Write + 'b> Dump for JsonApiDumper<'b, W> {\n+    fn crate_prelude(&mut self, data: CratePreludeData) {\n+        self.result.prelude = Some(data)\n+    }\n+\n+    impl_fn!(use_data, UseData, imports);\n+    impl_fn!(use_glob, UseGlobData, imports);\n+\n+    impl_fn!(enum_data, EnumData, defs);\n+    impl_fn!(tuple_variant, TupleVariantData, defs);\n+    impl_fn!(struct_variant, StructVariantData, defs);\n+    impl_fn!(struct_data, StructData, defs);\n+    impl_fn!(trait_data, TraitData, defs);\n+    impl_fn!(function, FunctionData, defs);\n+    impl_fn!(method, MethodData, defs);\n+    impl_fn!(macro_data, MacroData, defs);\n+    impl_fn!(mod_data, ModData, defs);\n+    impl_fn!(typedef, TypeDefData, defs);\n+    impl_fn!(variable, VariableData, defs);\n+}\n+\n+// FIXME methods. The defs have information about possible overriding and the\n+// refs have decl information (e.g., a trait method where we know the required\n+// method, but not the supplied method). In both cases, we are currently\n+// ignoring it.\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Analysis {\n+    prelude: Option<CratePreludeData>,\n+    imports: Vec<Import>,\n+    defs: Vec<Def>,\n+}\n+\n+impl Analysis {\n+    fn new() -> Analysis {\n+        Analysis {\n+            prelude: None,\n+            imports: vec![],\n+            defs: vec![],\n+        }\n+    }\n+}\n+\n+// DefId::index is a newtype and so the JSON serialisation is ugly. Therefore\n+// we use our own Id which is the same, but without the newtype.\n+#[derive(Debug, RustcEncodable)]\n+struct Id {\n+    krate: u32,\n+    index: u32,\n+}\n+\n+impl From<DefId> for Id {\n+    fn from(id: DefId) -> Id {\n+        Id {\n+            krate: id.krate,\n+            index: id.index.as_u32(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Import {\n+    kind: ImportKind,\n+    id: Id,\n+    span: SpanData,\n+    name: String,\n+    value: String,\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+enum ImportKind {\n+    Use,\n+    GlobUse,\n+}\n+\n+impl From<UseData> for Option<Import> {\n+    fn from(data: UseData) -> Option<Import> {\n+        match data.visibility {\n+            Visibility::Public => Some(Import {\n+                kind: ImportKind::Use,\n+                id: From::from(data.id),\n+                span: data.span,\n+                name: data.name,\n+                value: String::new(),\n+            }),\n+            _ => None,\n+        }\n+    }\n+}\n+impl From<UseGlobData> for Option<Import> {\n+    fn from(data: UseGlobData) -> Option<Import> {\n+        match data.visibility {\n+            Visibility::Public => Some(Import {\n+                kind: ImportKind::GlobUse,\n+                id: From::from(data.id),\n+                span: data.span,\n+                name: \"*\".to_owned(),\n+                value: data.names.join(\", \"),\n+            }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+struct Def {\n+    kind: DefKind,\n+    id: Id,\n+    span: SpanData,\n+    name: String,\n+    qualname: String,\n+    value: String,\n+    parent: Option<Id>,\n+    children: Vec<Id>,\n+    decl_id: Option<Id>,\n+}\n+\n+#[derive(Debug, RustcEncodable)]\n+enum DefKind {\n+    // value = variant names\n+    Enum,\n+    // value = enum name + variant name + types\n+    Tuple,\n+    // value = [enum name +] name + fields\n+    Struct,\n+    // value = signature\n+    Trait,\n+    // value = type + generics\n+    Function,\n+    // value = type + generics\n+    Method,\n+    // No id, no value.\n+    Macro,\n+    // value = file_name\n+    Mod,\n+    // value = aliased type\n+    Type,\n+    // value = type and init expression (for all variable kinds).\n+    Static,\n+    Const,\n+    Field,\n+}\n+\n+impl From<EnumData> for Option<Def> {\n+    fn from(data: EnumData) -> Option<Def> {\n+        match data.visibility {\n+            Visibility::Public => Some(Def {\n+                kind: DefKind::Enum,\n+                id: From::from(data.id),\n+                span: data.span,\n+                name: data.name,\n+                qualname: data.qualname,\n+                value: data.value,\n+                parent: None,\n+                children: data.variants.into_iter().map(|id| From::from(id)).collect(),\n+                decl_id: None,\n+            }),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl From<TupleVariantData> for Option<Def> {\n+    fn from(data: TupleVariantData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Tuple,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            parent: data.parent.map(|id| From::from(id)),\n+            children: vec![],\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<StructVariantData> for Option<Def> {\n+    fn from(data: StructVariantData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Struct,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            parent: data.parent.map(|id| From::from(id)),\n+            children: vec![],\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<StructData> for Option<Def> {\n+    fn from(data: StructData) -> Option<Def> {\n+        match data.visibility {\n+            Visibility::Public => Some(Def {\n+            kind: DefKind::Struct,\n+            id: From::from(data.id),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: data.value,\n+            parent: None,\n+            children: data.fields.into_iter().map(|id| From::from(id)).collect(),\n+            decl_id: None,\n+        }),\n+            _ => None,\n+        }\n+    }\n+}\n+impl From<TraitData> for Option<Def> {\n+    fn from(data: TraitData) -> Option<Def> {\n+        match data.visibility {\n+            Visibility::Public => Some(Def {\n+                kind: DefKind::Trait,\n+                id: From::from(data.id),\n+                span: data.span,\n+                name: data.name,\n+                qualname: data.qualname,\n+                value: data.value,\n+                children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+                parent: None,\n+                decl_id: None,\n+            }),\n+            _ => None,\n+        }\n+    }\n+}\n+impl From<FunctionData> for Option<Def> {\n+    fn from(data: FunctionData) -> Option<Def> {\n+        match data.visibility {\n+            Visibility::Public => Some(Def {\n+                kind: DefKind::Function,\n+                id: From::from(data.id),\n+                span: data.span,\n+                name: data.name,\n+                qualname: data.qualname,\n+                value: data.value,\n+                children: vec![],\n+                parent: data.parent.map(|id| From::from(id)),\n+                decl_id: None,\n+            }),\n+            _ => None,\n+        }\n+    }\n+}\n+impl From<MethodData> for Option<Def> {\n+    fn from(data: MethodData) -> Option<Def> {\n+        match data.visibility {\n+            Visibility::Public => Some(Def {\n+                kind: DefKind::Method,\n+                id: From::from(data.id),\n+                span: data.span,\n+                name: data.name,\n+                qualname: data.qualname,\n+                value: data.value,\n+                children: vec![],\n+                parent: data.parent.map(|id| From::from(id)),\n+                decl_id: data.decl_id.map(|id| From::from(id)),\n+            }),\n+            _ => None,\n+        }\n+    }\n+}\n+impl From<MacroData> for Option<Def> {\n+    fn from(data: MacroData) -> Option<Def> {\n+        Some(Def {\n+            kind: DefKind::Macro,\n+            id: From::from(null_def_id()),\n+            span: data.span,\n+            name: data.name,\n+            qualname: data.qualname,\n+            value: String::new(),\n+            children: vec![],\n+            parent: None,\n+            decl_id: None,\n+        })\n+    }\n+}\n+impl From<ModData> for Option<Def> {\n+    fn from(data:ModData) -> Option<Def> {\n+        match data.visibility {\n+            Visibility::Public => Some(Def {\n+                kind: DefKind::Mod,\n+                id: From::from(data.id),\n+                span: data.span,\n+                name: data.name,\n+                qualname: data.qualname,\n+                value: data.filename,\n+                children: data.items.into_iter().map(|id| From::from(id)).collect(),\n+                parent: None,\n+                decl_id: None,\n+            }),\n+            _ => None,\n+        }\n+    }\n+}\n+impl From<TypeDefData> for Option<Def> {\n+    fn from(data: TypeDefData) -> Option<Def> {\n+        match data.visibility {\n+            Visibility::Public => Some(Def {\n+                kind: DefKind::Type,\n+                id: From::from(data.id),\n+                span: data.span,\n+                name: data.name,\n+                qualname: data.qualname,\n+                value: data.value,\n+                children: vec![],\n+                parent: data.parent.map(|id| From::from(id)),\n+                decl_id: None,\n+            }),\n+            _ => None,\n+        }\n+    }\n+}\n+impl From<VariableData> for Option<Def> {\n+    fn from(data: VariableData) -> Option<Def> {\n+        match data.visibility {\n+            Visibility::Public => Some(Def {\n+                kind: match data.kind {\n+                    VariableKind::Static => DefKind::Static,\n+                    VariableKind::Const => DefKind::Const,\n+                    VariableKind::Local => { return None }\n+                    VariableKind::Field => DefKind::Field,\n+                },\n+                id: From::from(data.id),\n+                span: data.span,\n+                name: data.name,\n+                qualname: data.qualname,\n+                value: data.value,\n+                children: vec![],\n+                parent: data.parent.map(|id| From::from(id)),\n+                decl_id: None,\n+            }),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "f32baf30ff42e4517c24ec4790eb61f381c05b0b", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "patch": "@@ -30,6 +30,7 @@ extern crate serialize as rustc_serialize;\n extern crate syntax_pos;\n \n mod csv_dumper;\n+mod json_api_dumper;\n mod json_dumper;\n mod data;\n mod dump;\n@@ -57,6 +58,7 @@ use syntax::codemap::MacroAttribute;\n use syntax_pos::*;\n \n pub use self::csv_dumper::CsvDumper;\n+pub use self::json_api_dumper::JsonApiDumper;\n pub use self::json_dumper::JsonDumper;\n pub use self::data::*;\n pub use self::dump::Dump;\n@@ -138,6 +140,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n                     value: make_signature(decl, generics),\n+                    visibility: From::from(&item.vis),\n+                    parent: None,\n                 }))\n             }\n             ast::ItemKind::Static(ref typ, mt, ref expr) => {\n@@ -160,8 +164,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n+                    parent: None,\n                     value: value,\n                     type_value: ty_to_string(&typ),\n+                    visibility: From::from(&item.vis),\n                 }))\n             }\n             ast::ItemKind::Const(ref typ, ref expr) => {\n@@ -175,8 +181,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     qualname: qualname,\n                     span: sub_span.unwrap(),\n                     scope: self.enclosing_scope(item.id),\n+                    parent: None,\n                     value: self.span_utils.snippet(expr.span),\n                     type_value: ty_to_string(&typ),\n+                    visibility: From::from(&item.vis),\n                 }))\n             }\n             ast::ItemKind::Mod(ref m) => {\n@@ -195,6 +203,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     scope: self.enclosing_scope(item.id),\n                     filename: filename,\n                     items: m.items.iter().map(|i| i.id).collect(),\n+                    visibility: From::from(&item.vis),\n                 }))\n             }\n             ast::ItemKind::Enum(ref def, _) => {\n@@ -215,6 +224,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     qualname: qualname,\n                     scope: self.enclosing_scope(item.id),\n                     variants: def.variants.iter().map(|v| v.node.data.id()).collect(),\n+                    visibility: From::from(&item.vis),\n                 }))\n             }\n             ast::ItemKind::Impl(_, _, _, ref trait_ref, ref typ, _) => {\n@@ -277,8 +287,10 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                 qualname: qualname,\n                 span: sub_span.unwrap(),\n                 scope: scope,\n+                parent: Some(scope),\n                 value: \"\".to_owned(),\n                 type_value: typ,\n+                visibility: From::from(&field.vis),\n             })\n         } else {\n             None\n@@ -291,7 +303,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                            name: ast::Name, span: Span) -> Option<FunctionData> {\n         // The qualname for a method is the trait name or name of the struct in an impl in\n         // which the method is declared in, followed by the method's name.\n-        let qualname = match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n+        let (qualname, vis) = match self.tcx.impl_of_method(self.tcx.map.local_def_id(id)) {\n             Some(impl_id) => match self.tcx.map.get_if_local(impl_id) {\n                 Some(NodeItem(item)) => {\n                     match item.node {\n@@ -304,7 +316,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 result.push_str(&self.tcx.item_path_str(def_id));\n                             }\n                             result.push_str(\">\");\n-                            result\n+                            (result, From::from(&item.vis))\n                         }\n                         _ => {\n                             span_bug!(span,\n@@ -325,8 +337,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             None => match self.tcx.trait_of_item(self.tcx.map.local_def_id(id)) {\n                 Some(def_id) => {\n                     match self.tcx.map.get_if_local(def_id) {\n-                        Some(NodeItem(_)) => {\n-                            format!(\"::{}\", self.tcx.item_path_str(def_id))\n+                        Some(NodeItem(item)) => {\n+                            (format!(\"::{}\", self.tcx.item_path_str(def_id)), From::from(&item.vis))\n                         }\n                         r => {\n                             span_bug!(span,\n@@ -358,6 +370,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n         let sub_span = self.span_utils.sub_span_after_keyword(span, keywords::Fn);\n         filter!(self.span_utils, sub_span, span, None);\n+        let parent_scope = self.enclosing_scope(id);\n         Some(FunctionData {\n             id: id,\n             name: name.to_string(),\n@@ -367,6 +380,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             scope: self.enclosing_scope(id),\n             // FIXME you get better data here by using the visitor.\n             value: String::new(),\n+            visibility: vis,\n+            parent: Some(parent_scope),\n         })\n     }\n \n@@ -728,13 +743,14 @@ impl Visitor for PathCollector {\n pub enum Format {\n     Csv,\n     Json,\n+    JsonApi,\n }\n \n impl Format {\n     fn extension(&self) -> &'static str {\n         match *self {\n             Format::Csv => \".csv\",\n-            Format::Json => \".json\",\n+            Format::Json | Format::JsonApi => \".json\",\n         }\n     }\n }\n@@ -804,6 +820,7 @@ pub fn process_crate<'l, 'tcx>(tcx: TyCtxt<'l, 'tcx, 'tcx>,\n     match format {\n         Format::Csv => dump!(CsvDumper::new(output)),\n         Format::Json => dump!(JsonDumper::new(output)),\n+        Format::JsonApi => dump!(JsonApiDumper::new(output)),\n     }\n }\n "}, {"sha": "3711b6ea8959b7548bd3c5b5134a2dee4e6004fd", "filename": "src/test/run-make/save-analysis/Makefile", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8d6464998220dd69a0f61c6e41e5aeb6e35328a0/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2FMakefile?ref=8d6464998220dd69a0f61c6e41e5aeb6e35328a0", "patch": "@@ -5,3 +5,4 @@ krate2: krate2.rs\n code: foo.rs krate2\n \t$(RUSTC) foo.rs -Zsave-analysis-csv\n \t$(RUSTC) foo.rs -Zsave-analysis\n+\t$(RUSTC) foo.rs -Zsave-analysis-api"}]}