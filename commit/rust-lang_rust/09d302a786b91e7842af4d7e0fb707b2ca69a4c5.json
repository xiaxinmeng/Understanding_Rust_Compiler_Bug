{"sha": "09d302a786b91e7842af4d7e0fb707b2ca69a4c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZDMwMmE3ODZiOTFlNzg0MmFmNGQ3ZTBmYjcwN2IyY2E2OWE0YzU=", "commit": {"author": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2019-08-23T05:26:24Z"}, "committer": {"name": "Lzu Tao", "email": "taolzu@gmail.com", "date": "2019-08-23T09:16:50Z"}, "message": "Re-factor useless_format lint", "tree": {"sha": "556a4798f79bfb20a2f0a7def4383627a00a26ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/556a4798f79bfb20a2f0a7def4383627a00a26ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09d302a786b91e7842af4d7e0fb707b2ca69a4c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09d302a786b91e7842af4d7e0fb707b2ca69a4c5", "html_url": "https://github.com/rust-lang/rust/commit/09d302a786b91e7842af4d7e0fb707b2ca69a4c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09d302a786b91e7842af4d7e0fb707b2ca69a4c5/comments", "author": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tesuji", "id": 15225902, "node_id": "MDQ6VXNlcjE1MjI1OTAy", "avatar_url": "https://avatars.githubusercontent.com/u/15225902?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tesuji", "html_url": "https://github.com/tesuji", "followers_url": "https://api.github.com/users/tesuji/followers", "following_url": "https://api.github.com/users/tesuji/following{/other_user}", "gists_url": "https://api.github.com/users/tesuji/gists{/gist_id}", "starred_url": "https://api.github.com/users/tesuji/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tesuji/subscriptions", "organizations_url": "https://api.github.com/users/tesuji/orgs", "repos_url": "https://api.github.com/users/tesuji/repos", "events_url": "https://api.github.com/users/tesuji/events{/privacy}", "received_events_url": "https://api.github.com/users/tesuji/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e4aa666b3f75821b778f283478fe1e8ddee35fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e4aa666b3f75821b778f283478fe1e8ddee35fb", "html_url": "https://github.com/rust-lang/rust/commit/6e4aa666b3f75821b778f283478fe1e8ddee35fb"}], "stats": {"total": 202, "additions": 106, "deletions": 96}, "files": [{"sha": "d0da224e6e9e79195fe605da8ec6ce46abb4c335", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 101, "deletions": 92, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/09d302a786b91e7842af4d7e0fb707b2ca69a4c5/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d302a786b91e7842af4d7e0fb707b2ca69a4c5/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=09d302a786b91e7842af4d7e0fb707b2ca69a4c5", "patch": "@@ -1,11 +1,8 @@\n use crate::utils::paths;\n-use crate::utils::{\n-    is_expn_of, last_path_segment, match_def_path, match_type, resolve_node, snippet, span_lint_and_then, walk_ptrs_ty,\n-};\n+use crate::utils::{is_expn_of, last_path_segment, match_def_path, resolve_node, snippet, span_lint_and_then};\n use if_chain::if_chain;\n use rustc::hir::*;\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintContext, LintPass};\n-use rustc::ty;\n use rustc::{declare_lint_pass, declare_tool_lint};\n use rustc_errors::Applicability;\n use syntax::ast::LitKind;\n@@ -38,56 +35,16 @@ declare_lint_pass!(UselessFormat => [USELESS_FORMAT]);\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UselessFormat {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let Some(span) = is_expn_of(expr.span, \"format\") {\n-            if span.from_expansion() {\n-                return;\n-            }\n-            match expr.node {\n-                // `format!(\"{}\", foo)` expansion\n-                ExprKind::Call(ref fun, ref args) => {\n-                    if_chain! {\n-                        if let ExprKind::Path(ref qpath) = fun.node;\n-                        if let Some(fun_def_id) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n-                        let new_v1 = match_def_path(cx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n-                        let new_v1_fmt = match_def_path(cx,\n-                            fun_def_id,\n-                            &paths::FMT_ARGUMENTS_NEWV1FORMATTED\n-                        );\n-                        if new_v1 || new_v1_fmt;\n-                        if check_single_piece(&args[0]);\n-                        if let Some(format_arg) = get_single_string_arg(cx, &args[1]);\n-                        if new_v1 || check_unformatted(&args[2]);\n-                        if let ExprKind::AddrOf(_, ref format_arg) = format_arg.node;\n-                        then {\n-                            let (message, sugg) = if_chain! {\n-                                if let ExprKind::MethodCall(ref path, _, _) = format_arg.node;\n-                                if path.ident.as_interned_str().as_symbol() == sym!(to_string);\n-                                then {\n-                                    (\"`to_string()` is enough\",\n-                                    snippet(cx, format_arg.span, \"<arg>\").to_string())\n-                                } else {\n-                                    (\"consider using .to_string()\",\n-                                    format!(\"{}.to_string()\", snippet(cx, format_arg.span, \"<arg>\")))\n-                                }\n-                            };\n+        let span = match is_expn_of(expr.span, \"format\") {\n+            Some(s) if !s.from_expansion() => s,\n+            _ => return,\n+        };\n \n-                            span_useless_format(cx, span, message, sugg);\n-                        }\n-                    }\n-                },\n-                // `format!(\"foo\")` expansion contains `match () { () => [], }`\n-                ExprKind::Match(ref matchee, _, _) => {\n-                    if let ExprKind::Tup(ref tup) = matchee.node {\n-                        if tup.is_empty() {\n-                            let actual_snippet = snippet(cx, expr.span, \"<expr>\").to_string();\n-                            let actual_snippet = actual_snippet.replace(\"{{}}\", \"{}\");\n-                            let sugg = format!(\"{}.to_string()\", actual_snippet);\n-                            span_useless_format(cx, span, \"consider using .to_string()\", sugg);\n-                        }\n-                    }\n-                },\n-                _ => (),\n-            }\n+        // Operate on the only argument of `alloc::fmt::format`.\n+        if let Some(sugg) = on_new_v1(cx, expr) {\n+            span_useless_format(cx, span, \"consider using .to_string()\", sugg);\n+        } else if let Some(sugg) = on_new_v1_fmt(cx, expr) {\n+            span_useless_format(cx, span, \"consider using .to_string()\", sugg);\n         }\n     }\n }\n@@ -111,56 +68,105 @@ fn span_useless_format<T: LintContext>(cx: &T, span: Span, help: &str, mut sugg:\n     });\n }\n \n-/// Checks if the expressions matches `&[\"\"]`\n-fn check_single_piece(expr: &Expr) -> bool {\n+fn on_argumentv1_new<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, arms: &'a [Arm]) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::AddrOf(_, ref expr) = expr.node; // &[\"\"]\n-        if let ExprKind::Array(ref exprs) = expr.node; // [\"\"]\n-        if exprs.len() == 1;\n-        if let ExprKind::Lit(ref lit) = exprs[0].node;\n-        if let LitKind::Str(ref lit, _) = lit.node;\n+        if let ExprKind::AddrOf(_, ref format_args) = expr.node;\n+        if let ExprKind::Array(ref elems) = arms[0].body.node;\n+        if elems.len() == 1;\n+        if let ExprKind::Call(ref fun, ref args) = elems[0].node;\n+        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::FMT_ARGUMENTV1_NEW);\n+        // matches `core::fmt::Display::fmt`\n+        if args.len() == 2;\n+        if let ExprKind::Path(ref qpath) = args[1].node;\n+        if let Some(did) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::DISPLAY_FMT_METHOD);\n+        if arms[0].pats.len() == 1;\n+        // check `(arg0,)` in match block\n+        if let PatKind::Tuple(ref pats, None) = arms[0].pats[0].node;\n+        if pats.len() == 1;\n         then {\n-            return lit.as_str().is_empty();\n+            if let ExprKind::Lit(ref lit) = format_args.node {\n+                if let LitKind::Str(ref s, _) = lit.node {\n+                    let snip = s.as_str().replace(\"{{}}\", \"{}\");\n+                    let sugg = format!(\"\\\"{}\\\".to_string()\", snip);\n+                    return Some(sugg);\n+                }\n+                return None;\n+            } else {\n+                let snip = snippet(cx, format_args.span, \"<arg>\");\n+                if let ExprKind::MethodCall(ref path, _, _) = format_args.node {\n+                    if path.ident.name == sym!(to_string) {\n+                        return Some(format!(\"{}\", snip));\n+                    }\n+                }\n+                return Some(format!(\"{}.to_string()\", snip));\n+            }\n         }\n     }\n-\n-    false\n+    None\n }\n \n-/// Checks if the expressions matches\n-/// ```rust,ignore\n-/// &match (&\"arg\",) {\n-/// (__arg0,) => [::std::fmt::ArgumentV1::new(__arg0,\n-/// ::std::fmt::Display::fmt)],\n-/// }\n-/// ```\n-/// and that the type of `__arg0` is `&str` or `String`,\n-/// then returns the span of first element of the matched tuple.\n-fn get_single_string_arg<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option<&'a Expr> {\n+fn on_new_v1<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n     if_chain! {\n-        if let ExprKind::AddrOf(_, ref expr) = expr.node;\n-        if let ExprKind::Match(ref match_expr, ref arms, _) = expr.node;\n-        if arms.len() == 1;\n-        if arms[0].pats.len() == 1;\n-        if let PatKind::Tuple(ref pat, None) = arms[0].pats[0].node;\n-        if pat.len() == 1;\n-        if let ExprKind::Array(ref exprs) = arms[0].body.node;\n-        if exprs.len() == 1;\n-        if let ExprKind::Call(_, ref args) = exprs[0].node;\n+        if let ExprKind::Call(ref fun, ref args) = expr.node;\n         if args.len() == 2;\n-        if let ExprKind::Path(ref qpath) = args[1].node;\n-        if let Some(fun_def_id) = resolve_node(cx, qpath, args[1].hir_id).opt_def_id();\n-        if match_def_path(cx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n+        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::FMT_ARGUMENTS_NEW_V1);\n+        // Argument 1 in `new_v1()`\n+        if let ExprKind::AddrOf(_, ref arr) = args[0].node;\n+        if let ExprKind::Array(ref pieces) = arr.node;\n+        if pieces.len() == 1;\n+        if let ExprKind::Lit(ref lit) = pieces[0].node;\n+        if let LitKind::Str(ref s, _) = lit.node;\n+        // Argument 2 in `new_v1()`\n+        if let ExprKind::AddrOf(_, ref arg1) = args[1].node;\n+        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.node;\n+        if arms.len() == 1;\n+        if let ExprKind::Tup(ref tup) = matchee.node;\n         then {\n-            let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n-            if ty.sty == ty::Str || match_type(cx, ty, &paths::STRING) {\n-                if let ExprKind::Tup(ref values) = match_expr.node {\n-                    return Some(&values[0]);\n+            // `format!(\"foo\")` expansion contains `match () { () => [], }`\n+            if tup.is_empty() {\n+                let snip = s.as_str().replace(\"{{}}\", \"{}\");\n+                let sugg = format!(\"\\\"{}\\\".to_string()\", snip);\n+                return Some(sugg);\n+            } else {\n+                if s.as_str().is_empty() {\n+                    return on_argumentv1_new(cx, &tup[0], arms);\n+                } else {\n+                    return None;\n                 }\n             }\n         }\n     }\n+    None\n+}\n \n+fn on_new_v1_fmt<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) -> Option<String> {\n+    if_chain! {\n+        if let ExprKind::Call(ref fun, ref args) = expr.node;\n+        if args.len() == 3;\n+        if let ExprKind::Path(ref qpath) = fun.node;\n+        if let Some(did) = resolve_node(cx, qpath, fun.hir_id).opt_def_id();\n+        if match_def_path(cx, did, &paths::FMT_ARGUMENTS_NEW_V1_FORMATTED);\n+        if check_unformatted(&args[2]);\n+        // Argument 1 in `new_v1_formatted()`\n+        if let ExprKind::AddrOf(_, ref arr) = args[0].node;\n+        if let ExprKind::Array(ref pieces) = arr.node;\n+        if pieces.len() == 1;\n+        if let ExprKind::Lit(ref lit) = pieces[0].node;\n+        if let LitKind::Str(..) = lit.node;\n+        // Argument 2 in `new_v1_formatted()`\n+        if let ExprKind::AddrOf(_, ref arg1) = args[1].node;\n+        if let ExprKind::Match(ref matchee, ref arms, MatchSource::Normal) = arg1.node;\n+        if arms.len() == 1;\n+        if let ExprKind::Tup(ref tup) = matchee.node;\n+        then {\n+            return on_argumentv1_new(cx, &tup[0], arms);\n+        }\n+    }\n     None\n }\n \n@@ -169,6 +175,7 @@ fn get_single_string_arg<'a>(cx: &LateContext<'_, '_>, expr: &'a Expr) -> Option\n /// &[_ {\n ///    format: _ {\n ///         width: _::Implied,\n+///         precision: _::Implied,\n ///         ...\n ///    },\n ///    ...,\n@@ -179,15 +186,17 @@ fn check_unformatted(expr: &Expr) -> bool {\n         if let ExprKind::AddrOf(_, ref expr) = expr.node;\n         if let ExprKind::Array(ref exprs) = expr.node;\n         if exprs.len() == 1;\n+        // struct `core::fmt::rt::v1::Argument`\n         if let ExprKind::Struct(_, ref fields, _) = exprs[0].node;\n         if let Some(format_field) = fields.iter().find(|f| f.ident.name == sym!(format));\n+        // struct `core::fmt::rt::v1::FormatSpec`\n         if let ExprKind::Struct(_, ref fields, _) = format_field.expr.node;\n-        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n-        if let ExprKind::Path(ref width_qpath) = width_field.expr.node;\n-        if last_path_segment(width_qpath).ident.name == sym!(Implied);\n         if let Some(precision_field) = fields.iter().find(|f| f.ident.name == sym!(precision));\n         if let ExprKind::Path(ref precision_path) = precision_field.expr.node;\n         if last_path_segment(precision_path).ident.name == sym!(Implied);\n+        if let Some(width_field) = fields.iter().find(|f| f.ident.name == sym!(width));\n+        if let ExprKind::Path(ref width_qpath) = width_field.expr.node;\n+        if last_path_segment(width_qpath).ident.name == sym!(Implied);\n         then {\n             return true;\n         }"}, {"sha": "55e1387fe99eb3e2459112802303fb44a5e4d149", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/09d302a786b91e7842af4d7e0fb707b2ca69a4c5/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09d302a786b91e7842af4d7e0fb707b2ca69a4c5/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=09d302a786b91e7842af4d7e0fb707b2ca69a4c5", "patch": "@@ -27,8 +27,9 @@ pub const DROP: [&str; 3] = [\"core\", \"mem\", \"drop\"];\n pub const DROP_TRAIT: [&str; 4] = [\"core\", \"ops\", \"drop\", \"Drop\"];\n pub const DURATION: [&str; 3] = [\"core\", \"time\", \"Duration\"];\n pub const EARLY_CONTEXT: [&str; 4] = [\"rustc\", \"lint\", \"context\", \"EarlyContext\"];\n-pub const FMT_ARGUMENTS_NEWV1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n-pub const FMT_ARGUMENTS_NEWV1FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n+pub const FMT_ARGUMENTS_NEW_V1: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1\"];\n+pub const FMT_ARGUMENTS_NEW_V1_FORMATTED: [&str; 4] = [\"core\", \"fmt\", \"Arguments\", \"new_v1_formatted\"];\n+pub const FMT_ARGUMENTV1_NEW: [&str; 4] = [\"core\", \"fmt\", \"ArgumentV1\", \"new\"];\n pub const FROM_FROM: [&str; 4] = [\"core\", \"convert\", \"From\", \"from\"];\n pub const FROM_TRAIT: [&str; 3] = [\"core\", \"convert\", \"From\"];\n pub const HASH: [&str; 2] = [\"hash\", \"Hash\"];"}, {"sha": "d81f48b0864cc2afedb5eae08e9eefec4dc4386b", "filename": "tests/ui/format.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09d302a786b91e7842af4d7e0fb707b2ca69a4c5/tests%2Fui%2Fformat.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/09d302a786b91e7842af4d7e0fb707b2ca69a4c5/tests%2Fui%2Fformat.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fformat.stderr?ref=09d302a786b91e7842af4d7e0fb707b2ca69a4c5", "patch": "@@ -58,13 +58,13 @@ error: useless use of `format!`\n   --> $DIR/format.rs:59:5\n    |\n LL |     format!(\"{}\", 42.to_string());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: `to_string()` is enough: `42.to_string();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `42.to_string();`\n \n error: useless use of `format!`\n   --> $DIR/format.rs:61:5\n    |\n LL |     format!(\"{}\", x.display().to_string());\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: `to_string()` is enough: `x.display().to_string();`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using .to_string(): `x.display().to_string();`\n \n error: aborting due to 11 previous errors\n "}]}