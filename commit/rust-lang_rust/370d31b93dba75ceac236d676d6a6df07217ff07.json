{"sha": "370d31b93dba75ceac236d676d6a6df07217ff07", "node_id": "C_kwDOAAsO6NoAKDM3MGQzMWI5M2RiYTc1Y2VhYzIzNmQ2NzZkNmE2ZGYwNzIxN2ZmMDc", "commit": {"author": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-05-04T21:26:19Z"}, "committer": {"name": "Scott McMurray", "email": "scottmcm@users.noreply.github.com", "date": "2023-05-04T21:30:20Z"}, "message": "Constify `[u8]::is_ascii` (unstably)\n\nUTF-8 checking in `const fn`-stabilized back in 1.63, but apparently somehow ASCII checking was never const-ified, despite being simpler.", "tree": {"sha": "0971030054ef705bd5ccb817947d7be70a28beb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0971030054ef705bd5ccb817947d7be70a28beb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/370d31b93dba75ceac236d676d6a6df07217ff07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/370d31b93dba75ceac236d676d6a6df07217ff07", "html_url": "https://github.com/rust-lang/rust/commit/370d31b93dba75ceac236d676d6a6df07217ff07", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/370d31b93dba75ceac236d676d6a6df07217ff07/comments", "author": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "scottmcm", "id": 18526288, "node_id": "MDQ6VXNlcjE4NTI2Mjg4", "avatar_url": "https://avatars.githubusercontent.com/u/18526288?v=4", "gravatar_id": "", "url": "https://api.github.com/users/scottmcm", "html_url": "https://github.com/scottmcm", "followers_url": "https://api.github.com/users/scottmcm/followers", "following_url": "https://api.github.com/users/scottmcm/following{/other_user}", "gists_url": "https://api.github.com/users/scottmcm/gists{/gist_id}", "starred_url": "https://api.github.com/users/scottmcm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/scottmcm/subscriptions", "organizations_url": "https://api.github.com/users/scottmcm/orgs", "repos_url": "https://api.github.com/users/scottmcm/repos", "events_url": "https://api.github.com/users/scottmcm/events{/privacy}", "received_events_url": "https://api.github.com/users/scottmcm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb7a7434215dd9d4b7cc18746ad1d0e531c25325", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb7a7434215dd9d4b7cc18746ad1d0e531c25325", "html_url": "https://github.com/rust-lang/rust/commit/eb7a7434215dd9d4b7cc18746ad1d0e531c25325"}], "stats": {"total": 50, "additions": 35, "deletions": 15}, "files": [{"sha": "a942b9e4ae3f57e43e83ceecb36a27333a956571", "filename": "library/core/src/array/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/370d31b93dba75ceac236d676d6a6df07217ff07/library%2Fcore%2Fsrc%2Farray%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/370d31b93dba75ceac236d676d6a6df07217ff07/library%2Fcore%2Fsrc%2Farray%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fascii.rs?ref=370d31b93dba75ceac236d676d6a6df07217ff07", "patch": "@@ -7,7 +7,7 @@ impl<const N: usize> [u8; N] {\n     #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n     #[must_use]\n     #[inline]\n-    pub fn as_ascii(&self) -> Option<&[ascii::Char; N]> {\n+    pub const fn as_ascii(&self) -> Option<&[ascii::Char; N]> {\n         if self.is_ascii() {\n             // SAFETY: Just checked that it's ASCII\n             Some(unsafe { self.as_ascii_unchecked() })"}, {"sha": "01cc137c24e452fa3478dfcfd3fe7f1ca599214d", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/370d31b93dba75ceac236d676d6a6df07217ff07/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/370d31b93dba75ceac236d676d6a6df07217ff07/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=370d31b93dba75ceac236d676d6a6df07217ff07", "patch": "@@ -149,6 +149,7 @@\n #![feature(const_slice_from_raw_parts_mut)]\n #![feature(const_slice_from_ref)]\n #![feature(const_slice_index)]\n+#![feature(const_slice_is_ascii)]\n #![feature(const_slice_ptr_len)]\n #![feature(const_slice_split_at_mut)]\n #![feature(const_str_from_utf8_unchecked_mut)]"}, {"sha": "6a6c0c9ba8ba10ef443847249ad3358967003adc", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/370d31b93dba75ceac236d676d6a6df07217ff07/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/370d31b93dba75ceac236d676d6a6df07217ff07/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=370d31b93dba75ceac236d676d6a6df07217ff07", "patch": "@@ -10,9 +10,10 @@ use crate::ops;\n impl [u8] {\n     /// Checks if all bytes in this slice are within the ASCII range.\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_is_ascii\", issue = \"111090\")]\n     #[must_use]\n     #[inline]\n-    pub fn is_ascii(&self) -> bool {\n+    pub const fn is_ascii(&self) -> bool {\n         is_ascii(self)\n     }\n \n@@ -21,7 +22,7 @@ impl [u8] {\n     #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n     #[must_use]\n     #[inline]\n-    pub fn as_ascii(&self) -> Option<&[ascii::Char]> {\n+    pub const fn as_ascii(&self) -> Option<&[ascii::Char]> {\n         if self.is_ascii() {\n             // SAFETY: Just checked that it's ASCII\n             Some(unsafe { self.as_ascii_unchecked() })\n@@ -262,7 +263,7 @@ impl<'a> fmt::Debug for EscapeAscii<'a> {\n /// Returns `true` if any byte in the word `v` is nonascii (>= 128). Snarfed\n /// from `../str/mod.rs`, which does something similar for utf8 validation.\n #[inline]\n-fn contains_nonascii(v: usize) -> bool {\n+const fn contains_nonascii(v: usize) -> bool {\n     const NONASCII_MASK: usize = usize::repeat_u8(0x80);\n     (NONASCII_MASK & v) != 0\n }\n@@ -280,7 +281,7 @@ fn contains_nonascii(v: usize) -> bool {\n /// If any of these loads produces something for which `contains_nonascii`\n /// (above) returns true, then we know the answer is false.\n #[inline]\n-fn is_ascii(s: &[u8]) -> bool {\n+const fn is_ascii(s: &[u8]) -> bool {\n     const USIZE_SIZE: usize = mem::size_of::<usize>();\n \n     let len = s.len();\n@@ -292,7 +293,16 @@ fn is_ascii(s: &[u8]) -> bool {\n     // We also do this for architectures where `size_of::<usize>()` isn't\n     // sufficient alignment for `usize`, because it's a weird edge case.\n     if len < USIZE_SIZE || len < align_offset || USIZE_SIZE < mem::align_of::<usize>() {\n-        return s.iter().all(|b| b.is_ascii());\n+        // FIXME: once iterators and closures can be used in `const fn`,\n+        // return s.iter().all(|b| b.is_ascii());\n+        let mut i = 0;\n+        while i < len {\n+            if !s[i].is_ascii() {\n+                return false;\n+            }\n+            i += 1;\n+        }\n+        return true;\n     }\n \n     // We always read the first word unaligned, which means `align_offset` is\n@@ -321,18 +331,26 @@ fn is_ascii(s: &[u8]) -> bool {\n     // Paranoia check about alignment, since we're about to do a bunch of\n     // unaligned loads. In practice this should be impossible barring a bug in\n     // `align_offset` though.\n-    debug_assert_eq!(word_ptr.addr() % mem::align_of::<usize>(), 0);\n+    // While this method is allowed to spuriously fail in CTFE, if it doesn't\n+    // have alignment information it should have given a `usize::MAX` for\n+    // `align_offset` earlier, sending things through the scalar path instead of\n+    // this one, so this check should pass if it's reachable.\n+    debug_assert!(word_ptr.is_aligned_to(mem::align_of::<usize>()));\n \n     // Read subsequent words until the last aligned word, excluding the last\n     // aligned word by itself to be done in tail check later, to ensure that\n     // tail is always one `usize` at most to extra branch `byte_pos == len`.\n     while byte_pos < len - USIZE_SIZE {\n-        debug_assert!(\n-            // Sanity check that the read is in bounds\n-            (word_ptr.addr() + USIZE_SIZE) <= start.addr().wrapping_add(len) &&\n-            // And that our assumptions about `byte_pos` hold.\n-            (word_ptr.addr() - start.addr()) == byte_pos\n-        );\n+        // Sanity check that the read is in bounds\n+        debug_assert!(byte_pos + USIZE_SIZE <= len);\n+        // And that our assumptions about `byte_pos` hold.\n+        debug_assert!(matches!(\n+            word_ptr.cast::<u8>().guaranteed_eq(start.wrapping_add(byte_pos)),\n+            // These are from the same allocation, so will hopefully always be\n+            // known to match even in CTFE, but if it refuses to compare them\n+            // that's ok since it's just a debug check anyway.\n+            None | Some(true),\n+        ));\n \n         // SAFETY: We know `word_ptr` is properly aligned (because of\n         // `align_offset`), and we know that we have enough bytes between `word_ptr` and the end"}, {"sha": "ef05b25fdd06ce4df659a78b1eab3a0652ffd8b9", "filename": "library/core/src/str/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/370d31b93dba75ceac236d676d6a6df07217ff07/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/370d31b93dba75ceac236d676d6a6df07217ff07/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstr%2Fmod.rs?ref=370d31b93dba75ceac236d676d6a6df07217ff07", "patch": "@@ -2358,9 +2358,10 @@ impl str {\n     /// assert!(!non_ascii.is_ascii());\n     /// ```\n     #[stable(feature = \"ascii_methods_on_intrinsics\", since = \"1.23.0\")]\n+    #[rustc_const_unstable(feature = \"const_slice_is_ascii\", issue = \"111090\")]\n     #[must_use]\n     #[inline]\n-    pub fn is_ascii(&self) -> bool {\n+    pub const fn is_ascii(&self) -> bool {\n         // We can treat each byte as character here: all multibyte characters\n         // start with a byte that is not in the ASCII range, so we will stop\n         // there already.\n@@ -2372,7 +2373,7 @@ impl str {\n     #[unstable(feature = \"ascii_char\", issue = \"110998\")]\n     #[must_use]\n     #[inline]\n-    pub fn as_ascii(&self) -> Option<&[ascii::Char]> {\n+    pub const fn as_ascii(&self) -> Option<&[ascii::Char]> {\n         // Like in `is_ascii`, we can work on the bytes directly.\n         self.as_bytes().as_ascii()\n     }"}]}