{"sha": "c91821d356b87dcbede651a1130ea758bf6a5265", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5MTgyMWQzNTZiODdkY2JlZGU2NTFhMTEzMGVhNzU4YmY2YTUyNjU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-27T00:20:14Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2012-09-27T00:21:09Z"}, "message": "libcore: De-export cleanup, cmath, future, gc, hash, iter-trait, mutable, and private", "tree": {"sha": "becae156bb4becb0e4d5e51611ef4b39ef588320", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/becae156bb4becb0e4d5e51611ef4b39ef588320"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c91821d356b87dcbede651a1130ea758bf6a5265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c91821d356b87dcbede651a1130ea758bf6a5265", "html_url": "https://github.com/rust-lang/rust/commit/c91821d356b87dcbede651a1130ea758bf6a5265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c91821d356b87dcbede651a1130ea758bf6a5265/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25715bd59eb339fd37f979a425651802702b4618", "url": "https://api.github.com/repos/rust-lang/rust/commits/25715bd59eb339fd37f979a425651802702b4618", "html_url": "https://github.com/rust-lang/rust/commit/25715bd59eb339fd37f979a425651802702b4618"}], "stats": {"total": 285, "additions": 123, "deletions": 162}, "files": [{"sha": "df6074e32009d5b09abe182a42731268bede3dd3", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=c91821d356b87dcbede651a1130ea758bf6a5265", "patch": "@@ -10,8 +10,6 @@ use repr::BoxRepr;\n use sys::TypeDesc;\n use cast::transmute;\n \n-export annihilate;\n-\n /**\n  * Runtime structures\n  *"}, {"sha": "9a9a7cb3112114f08d1760106096eb730f905174", "filename": "src/libcore/cmath.rs", "status": "modified", "additions": 50, "deletions": 58, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fcmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fcmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmath.rs?ref=c91821d356b87dcbede651a1130ea758bf6a5265", "patch": "@@ -3,10 +3,6 @@\n #[forbid(deprecated_mode)];\n #[forbid(deprecated_pattern)];\n \n-// uncomment once #1433 is fixed\n-// FIXME (#1433): export c_float_math_consts;\n-// FIXME (#1433): export c_double_math_consts;\n-\n use libc::c_int;\n use libc::c_float;\n use libc::c_double;\n@@ -193,66 +189,62 @@ pub mod c_double_targ_consts {\n \n FIXME use these once they can be parsed (see Issue #1433)\n \n-mod c_float_math_consts {\n-    #[legacy_exports];\n-    const pi: c_float = 0x1.921fb6p+1_f32;\n-    const div_1_pi: c_float = 0x1.45f306p-2_f32;\n-    const div_2_pi: c_float = 0x1.45f306p-1_f32;\n-    const div_pi_2: c_float = 0x1.921fb6p+0_f32;\n-    const div_pi_4: c_float = 0x1.921fb6p-1_f32;\n-    const div_2_sqrtpi: c_float = 0x1.20dd76p+0_f32;\n-    const e: c_float = 0x1.5bf0a8p+1_f32;\n-    const log2_e: c_float = 0x1.715476p+0_f32;\n-    const log10_e: c_float = 0x1.bcb7b2p-2_f32;\n-    const ln_2: c_float = 0x1.62e43p-1_f32;\n-    const ln_10: c_float = 0x1.26bb1cp+1_f32;\n-    const sqrt2: c_float = 0x1.6a09e6p+0_f32;\n-    const div_1_sqrt2: c_float = 0x1.6a09e6p-1_f32;\n+pub mod c_float_math_consts {\n+    pub const pi: c_float = 0x1.921fb6p+1_f32;\n+    pub const div_1_pi: c_float = 0x1.45f306p-2_f32;\n+    pub const div_2_pi: c_float = 0x1.45f306p-1_f32;\n+    pub const div_pi_2: c_float = 0x1.921fb6p+0_f32;\n+    pub const div_pi_4: c_float = 0x1.921fb6p-1_f32;\n+    pub const div_2_sqrtpi: c_float = 0x1.20dd76p+0_f32;\n+    pub const e: c_float = 0x1.5bf0a8p+1_f32;\n+    pub const log2_e: c_float = 0x1.715476p+0_f32;\n+    pub const log10_e: c_float = 0x1.bcb7b2p-2_f32;\n+    pub const ln_2: c_float = 0x1.62e43p-1_f32;\n+    pub const ln_10: c_float = 0x1.26bb1cp+1_f32;\n+    pub const sqrt2: c_float = 0x1.6a09e6p+0_f32;\n+    pub const div_1_sqrt2: c_float = 0x1.6a09e6p-1_f32;\n }\n \n-mod c_double_math_consts {\n-    #[legacy_exports];\n-    const pi: c_double = 0x1.921fb54442d18p+1_f64;\n-    const div_1_pi: c_double = 0x1.45f306dc9c883p-2_f64;\n-    const div_2_pi: c_double = 0x1.45f306dc9c883p-1_f64;\n-    const div_pi_2: c_double = 0x1.921fb54442d18p+0_f64;\n-    const div_pi_4: c_double = 0x1.921fb54442d18p-1_f64;\n-    const div_2_sqrtpi: c_double = 0x1.20dd750429b6dp+0_f64;\n-    const e: c_double = 0x1.5bf0a8b145769p+1_f64;\n-    const log2_e: c_double = 0x1.71547652b82fep+0_f64;\n-    const log10_e: c_double = 0x1.bcb7b1526e50ep-2_f64;\n-    const ln_2: c_double = 0x1.62e42fefa39efp-1_f64;\n-    const ln_10: c_double = 0x1.26bb1bbb55516p+1_f64;\n-    const sqrt2: c_double = 0x1.6a09e667f3bcdp+0_f64;\n-    const div_1_sqrt2: c_double = 0x1.6a09e667f3bcdp-1_f64;\n+pub mod c_double_math_consts {\n+    pub const pi: c_double = 0x1.921fb54442d18p+1_f64;\n+    pub const div_1_pi: c_double = 0x1.45f306dc9c883p-2_f64;\n+    pub const div_2_pi: c_double = 0x1.45f306dc9c883p-1_f64;\n+    pub const div_pi_2: c_double = 0x1.921fb54442d18p+0_f64;\n+    pub const div_pi_4: c_double = 0x1.921fb54442d18p-1_f64;\n+    pub const div_2_sqrtpi: c_double = 0x1.20dd750429b6dp+0_f64;\n+    pub const e: c_double = 0x1.5bf0a8b145769p+1_f64;\n+    pub const log2_e: c_double = 0x1.71547652b82fep+0_f64;\n+    pub const log10_e: c_double = 0x1.bcb7b1526e50ep-2_f64;\n+    pub const ln_2: c_double = 0x1.62e42fefa39efp-1_f64;\n+    pub const ln_10: c_double = 0x1.26bb1bbb55516p+1_f64;\n+    pub const sqrt2: c_double = 0x1.6a09e667f3bcdp+0_f64;\n+    pub const div_1_sqrt2: c_double = 0x1.6a09e667f3bcdp-1_f64;\n }\n \n-mod c_float_targ_consts {\n-    #[legacy_exports];\n-    const radix: uint = 2u;\n-    const mantissa_digits: uint = 24u;\n-    const digits: uint = 6u;\n-    const min_exp: int = -125;\n-    const max_exp: int = 128;\n-    const min_10_exp: int = -37;\n-    const max_10_exp: int = 38;\n-    const min_value: c_float = 0x1p-126_f32;\n-    const max_value: c_float = 0x1.fffffep+127_f32;\n-    const epsilon: c_float = 0x1p-23_f32;\n+pub mod c_float_targ_consts {\n+    pub const radix: uint = 2u;\n+    pub const mantissa_digits: uint = 24u;\n+    pub const digits: uint = 6u;\n+    pub const min_exp: int = -125;\n+    pub const max_exp: int = 128;\n+    pub const min_10_exp: int = -37;\n+    pub const max_10_exp: int = 38;\n+    pub const min_value: c_float = 0x1p-126_f32;\n+    pub const max_value: c_float = 0x1.fffffep+127_f32;\n+    pub const epsilon: c_float = 0x1p-23_f32;\n }\n \n-mod c_double_targ_consts {\n-    #[legacy_exports];\n-    const radix: uint = 2u;\n-    const mantissa_digits: uint = 53u;\n-    const digits: uint = 15u;\n-    const min_exp: int = -1021;\n-    const max_exp: int = 1024;\n-    const min_10_exp: int = -307;\n-    const max_10_exp: int = 308;\n-    const min_value: c_double = 0x1p-1022_f64;\n-    const max_value: c_double = 0x1.fffffffffffffp+1023_f64;\n-    const epsilon: c_double = 0x1p-52_f64;\n+pub mod c_double_targ_consts {\n+    pub const radix: uint = 2u;\n+    pub const mantissa_digits: uint = 53u;\n+    pub const digits: uint = 15u;\n+    pub const min_exp: int = -1021;\n+    pub const max_exp: int = 1024;\n+    pub const min_10_exp: int = -307;\n+    pub const max_10_exp: int = 308;\n+    pub const min_value: c_double = 0x1p-1022_f64;\n+    pub const max_value: c_double = 0x1.fffffffffffffp+1023_f64;\n+    pub const epsilon: c_double = 0x1p-52_f64;\n }\n \n */"}, {"sha": "db311ea3e8237aadcde9752ca4cf171a503fbb03", "filename": "src/libcore/future.rs", "status": "modified", "additions": 21, "deletions": 33, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture.rs?ref=c91821d356b87dcbede651a1130ea758bf6a5265", "patch": "@@ -19,20 +19,8 @@ use either::Either;\n use pipes::recv;\n use cast::copy_lifetime;\n \n-export Future;\n-export extensions;\n-export from_value;\n-export from_port;\n-export from_fn;\n-export get;\n-export with;\n-export spawn;\n-\n-// for task.rs\n-export future_pipe;\n-\n #[doc = \"The future type\"]\n-struct Future<A> {\n+pub struct Future<A> {\n     /*priv*/ mut state: FutureState<A>,\n \n     // FIXME(#2829) -- futures should not be copyable, because they close\n@@ -67,7 +55,7 @@ impl<A> Future<A> {\n     }\n }\n \n-fn from_value<A>(+val: A) -> Future<A> {\n+pub fn from_value<A>(+val: A) -> Future<A> {\n     /*!\n      * Create a future from a value\n      *\n@@ -78,7 +66,8 @@ fn from_value<A>(+val: A) -> Future<A> {\n     Future {state: Forced(~(move val))}\n }\n \n-fn from_port<A:Send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n+pub fn from_port<A:Send>(+port: future_pipe::client::waiting<A>) ->\n+        Future<A> {\n     /*!\n      * Create a future from a port\n      *\n@@ -97,7 +86,7 @@ fn from_port<A:Send>(+port: future_pipe::client::waiting<A>) -> Future<A> {\n     }\n }\n \n-fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n+pub fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n     /*!\n      * Create a future from a function.\n      *\n@@ -109,7 +98,7 @@ fn from_fn<A>(+f: ~fn() -> A) -> Future<A> {\n     Future {state: Pending(move f)}\n }\n \n-fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n+pub fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n     /*!\n      * Create a future from a unique closure.\n      *\n@@ -122,7 +111,7 @@ fn spawn<A:Send>(+blk: fn~() -> A) -> Future<A> {\n     }))\n }\n \n-fn get_ref<A>(future: &r/Future<A>) -> &r/A {\n+pub fn get_ref<A>(future: &r/Future<A>) -> &r/A {\n     /*!\n      * Executes the future's closure and then returns a borrowed\n      * pointer to the result.  The borrowed pointer lasts as long as\n@@ -160,13 +149,13 @@ fn get_ref<A>(future: &r/Future<A>) -> &r/A {\n     }\n }\n \n-fn get<A:Copy>(future: &Future<A>) -> A {\n+pub fn get<A:Copy>(future: &Future<A>) -> A {\n     //! Get the value of the future\n \n     *get_ref(future)\n }\n \n-fn with<A,B>(future: &Future<A>, blk: fn((&A)) -> B) -> B {\n+pub fn with<A,B>(future: &Future<A>, blk: fn((&A)) -> B) -> B {\n     //! Work with the value without copying it\n \n     blk(get_ref(future))\n@@ -179,74 +168,73 @@ proto! future_pipe (\n )\n \n #[allow(non_implicitly_copyable_typarams)]\n-mod test {\n-    #[legacy_exports];\n+pub mod test {\n     #[test]\n-    fn test_from_value() {\n+    pub fn test_from_value() {\n         let f = from_value(~\"snail\");\n         assert get(&f) == ~\"snail\";\n     }\n \n     #[test]\n-    fn test_from_port() {\n+    pub fn test_from_port() {\n         let (po, ch) = future_pipe::init();\n         future_pipe::server::completed(ch, ~\"whale\");\n         let f = from_port(po);\n         assert get(&f) == ~\"whale\";\n     }\n \n     #[test]\n-    fn test_from_fn() {\n+    pub fn test_from_fn() {\n         let f = from_fn(|| ~\"brail\");\n         assert get(&f) == ~\"brail\";\n     }\n \n     #[test]\n-    fn test_interface_get() {\n+    pub fn test_interface_get() {\n         let f = from_value(~\"fail\");\n         assert f.get() == ~\"fail\";\n     }\n \n     #[test]\n-    fn test_with() {\n+    pub fn test_with() {\n         let f = from_value(~\"nail\");\n         assert with(&f, |v| copy *v) == ~\"nail\";\n     }\n \n     #[test]\n-    fn test_get_ref_method() {\n+    pub fn test_get_ref_method() {\n         let f = from_value(22);\n         assert *f.get_ref() == 22;\n     }\n \n     #[test]\n-    fn test_get_ref_fn() {\n+    pub fn test_get_ref_fn() {\n         let f = from_value(22);\n         assert *get_ref(&f) == 22;\n     }\n \n     #[test]\n-    fn test_interface_with() {\n+    pub fn test_interface_with() {\n         let f = from_value(~\"kale\");\n         assert f.with(|v| copy *v) == ~\"kale\";\n     }\n \n     #[test]\n-    fn test_spawn() {\n+    pub fn test_spawn() {\n         let f = spawn(|| ~\"bale\");\n         assert get(&f) == ~\"bale\";\n     }\n \n     #[test]\n     #[should_fail]\n     #[ignore(cfg(target_os = \"win32\"))]\n-    fn test_futurefail() {\n+    pub fn test_futurefail() {\n         let f = spawn(|| fail);\n         let _x: ~str = get(&f);\n     }\n \n     #[test]\n-    fn test_sendable_future() {\n+    pub fn test_sendable_future() {\n         let expected = ~\"schlorf\";\n         let f = do spawn |copy expected| { copy expected };\n         do task::spawn {"}, {"sha": "a60dbe5e03ae0f647e914a9f30e1e37dd1c8077b", "filename": "src/libcore/gc.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fgc.rs?ref=c91821d356b87dcbede651a1130ea758bf6a5265", "patch": "@@ -34,10 +34,6 @@ use libc::size_t;\n use libc::uintptr_t;\n use send_map::linear::LinearMap;\n \n-export Word;\n-export gc;\n-export cleanup_stack_for_failure;\n-\n // Mirrors rust_stack.h stk_seg\n struct StackSegment {\n     prev: *StackSegment,\n@@ -268,7 +264,7 @@ unsafe fn walk_gc_roots(mem: Memory, sentinel: **Word, visitor: Visitor) {\n     }\n }\n \n-fn gc() {\n+pub fn gc() {\n     unsafe {\n         // Abort when GC is disabled.\n         if get_safe_point_count() == 0 {\n@@ -301,7 +297,7 @@ fn expect_sentinel() -> bool { false }\n // This should only be called from fail, as it will drop the roots\n // which are *live* on the stack, rather than dropping those that are\n // dead.\n-fn cleanup_stack_for_failure() {\n+pub fn cleanup_stack_for_failure() {\n     unsafe {\n         // Abort when GC is disabled.\n         if get_safe_point_count() == 0 {"}, {"sha": "6703006650b030e109e74f62b7784900668409a0", "filename": "src/libcore/hash.rs", "status": "modified", "additions": 13, "deletions": 16, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash.rs?ref=c91821d356b87dcbede651a1130ea758bf6a5265", "patch": "@@ -17,9 +17,6 @@ use io::Writer;\n use io::WriterUtil;\n use to_bytes::IterBytes;\n \n-export Streaming, State, Hash, HashUtil;\n-export default_state;\n-\n /**\n  * Types that can meaningfully be hashed should implement this.\n  *\n@@ -32,7 +29,7 @@ export default_state;\n  * the rest. This is the recommended approach, since constructing\n  * good keyed hash functions is quite difficult.\n  */\n-trait Hash {\n+pub trait Hash {\n     /**\n      * Compute a \"keyed\" hash of the value implementing the trait,\n      * taking `k0` and `k1` as \"keying\" parameters that randomize or\n@@ -49,7 +46,7 @@ trait Hash {\n }\n \n // When we have default methods, won't need this.\n-trait HashUtil {\n+pub trait HashUtil {\n     pure fn hash() -> u64;\n }\n \n@@ -59,7 +56,7 @@ impl <A: Hash> A: HashUtil {\n }\n \n /// Streaming hash-functions should implement this.\n-trait Streaming {\n+pub trait Streaming {\n     fn input((&[const u8]));\n     // These can be refactored some when we have default methods.\n     fn result_bytes() -> ~[u8];\n@@ -139,15 +136,15 @@ pure fn hash_keyed_5<A: IterBytes,\n \n // Implement State as SipState\n \n-type State = SipState;\n+pub type State = SipState;\n \n #[inline(always)]\n-fn State(k0: u64, k1: u64) -> State {\n+pub fn State(k0: u64, k1: u64) -> State {\n     SipState(k0, k1)\n }\n \n #[inline(always)]\n-fn default_state() -> State {\n+pub fn default_state() -> State {\n     State(0,0)\n }\n \n@@ -361,7 +358,7 @@ impl &SipState : Streaming {\n }\n \n #[test]\n-fn test_siphash() {\n+pub fn test_siphash() {\n     let vecs : [[u8]/8]/64 = [\n         [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ]/_,\n         [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ]/_,\n@@ -468,34 +465,34 @@ fn test_siphash() {\n }\n \n #[test] #[cfg(target_arch = \"arm\")]\n-fn test_hash_uint() {\n+pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n     assert (val as u64).hash() != (val as uint).hash();\n     assert (val as u32).hash() == (val as uint).hash();\n }\n #[test] #[cfg(target_arch = \"x86_64\")]\n-fn test_hash_uint() {\n+pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n     assert (val as u64).hash() == (val as uint).hash();\n     assert (val as u32).hash() != (val as uint).hash();\n }\n #[test] #[cfg(target_arch = \"x86\")]\n-fn test_hash_uint() {\n+pub fn test_hash_uint() {\n     let val = 0xdeadbeef_deadbeef_u64;\n     assert (val as u64).hash() != (val as uint).hash();\n     assert (val as u32).hash() == (val as uint).hash();\n }\n \n #[test]\n-fn test_hash_idempotent() {\n+pub fn test_hash_idempotent() {\n     let val64 = 0xdeadbeef_deadbeef_u64;\n     val64.hash() == val64.hash();\n     let val32 = 0xdeadbeef_u32;\n     val32.hash() == val32.hash();\n }\n \n #[test]\n-fn test_hash_no_bytes_dropped_64() {\n+pub fn test_hash_no_bytes_dropped_64() {\n     let val = 0xdeadbeef_deadbeef_u64;\n \n     assert val.hash() != zero_byte(val, 0).hash();\n@@ -514,7 +511,7 @@ fn test_hash_no_bytes_dropped_64() {\n }\n \n #[test]\n-fn test_hash_no_bytes_dropped_32() {\n+pub fn test_hash_no_bytes_dropped_32() {\n     let val = 0xdeadbeef_u32;\n \n     assert val.hash() != zero_byte(val, 0).hash();"}, {"sha": "4cf2002adaae557fe0594c22c69ae175d3d756fa", "filename": "src/libcore/iter-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fiter-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fiter-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter-trait.rs?ref=c91821d356b87dcbede651a1130ea758bf6a5265", "patch": "@@ -6,7 +6,6 @@\n \n use cmp::{Eq, Ord};\n use inst::{IMPL_T, EACH, SIZE_HINT};\n-export extensions;\n \n impl<A> IMPL_T<A>: iter::BaseIter<A> {\n     pure fn each(blk: fn(v: &A) -> bool) { EACH(&self, blk) }"}, {"sha": "65907cc1827acdccdbbd6e2d4797b731a06f1b88", "filename": "src/libcore/mutable.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fmutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fmutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmutable.rs?ref=c91821d356b87dcbede651a1130ea758bf6a5265", "patch": "@@ -15,22 +15,20 @@ mutation when the data structure should be immutable.\n use util::with;\n use cast::transmute_immut;\n \n-export Mut;\n-\n enum Mode { ReadOnly, Mutable, Immutable }\n \n struct Data<T> {\n     priv mut value: T,\n     priv mut mode: Mode\n }\n \n-type Mut<T> = Data<T>;\n+pub type Mut<T> = Data<T>;\n \n-fn Mut<T>(+t: T) -> Mut<T> {\n+pub fn Mut<T>(+t: T) -> Mut<T> {\n     Data {value: t, mode: ReadOnly}\n }\n \n-fn unwrap<T>(+m: Mut<T>) -> T {\n+pub fn unwrap<T>(+m: Mut<T>) -> T {\n     // Borrowck should prevent us from calling unwrap while the value\n     // is in use, as that would be a move from a borrowed value.\n     assert (m.mode as uint) == (ReadOnly as uint);\n@@ -71,7 +69,7 @@ impl<T> Data<T> {\n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n-fn test_mut_in_imm() {\n+pub fn test_mut_in_imm() {\n     let m = @Mut(1);\n     do m.borrow_imm |_p| {\n         do m.borrow_mut |_q| {\n@@ -83,7 +81,7 @@ fn test_mut_in_imm() {\n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n-fn test_imm_in_mut() {\n+pub fn test_imm_in_mut() {\n     let m = @Mut(1);\n     do m.borrow_mut |_p| {\n         do m.borrow_imm |_q| {\n@@ -93,7 +91,7 @@ fn test_imm_in_mut() {\n }\n \n #[test]\n-fn test_const_in_mut() {\n+pub fn test_const_in_mut() {\n     let m = @Mut(1);\n     do m.borrow_mut |p| {\n         do m.borrow_const |q| {\n@@ -105,7 +103,7 @@ fn test_const_in_mut() {\n }\n \n #[test]\n-fn test_mut_in_const() {\n+pub fn test_mut_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_mut |q| {\n@@ -117,7 +115,7 @@ fn test_mut_in_const() {\n }\n \n #[test]\n-fn test_imm_in_const() {\n+pub fn test_imm_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |p| {\n         do m.borrow_imm |q| {\n@@ -127,7 +125,7 @@ fn test_imm_in_const() {\n }\n \n #[test]\n-fn test_const_in_imm() {\n+pub fn test_const_in_imm() {\n     let m = @Mut(1);\n     do m.borrow_imm |p| {\n         do m.borrow_const |q| {\n@@ -140,7 +138,7 @@ fn test_const_in_imm() {\n #[test]\n #[ignore(cfg(windows))]\n #[should_fail]\n-fn test_mut_in_imm_in_const() {\n+pub fn test_mut_in_imm_in_const() {\n     let m = @Mut(1);\n     do m.borrow_const |_p| {\n         do m.borrow_imm |_q| {\n@@ -149,3 +147,4 @@ fn test_mut_in_imm_in_const() {\n         }\n     }\n }\n+"}, {"sha": "4021ad5e88ff23fa1bdab45dff1baf703e205d72", "filename": "src/libcore/private.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fprivate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c91821d356b87dcbede651a1130ea758bf6a5265/src%2Flibcore%2Fprivate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprivate.rs?ref=c91821d356b87dcbede651a1130ea758bf6a5265", "patch": "@@ -4,13 +4,6 @@\n \n #[doc(hidden)];\n \n-export chan_from_global_ptr, weaken_task;\n-\n-export SharedMutableState, shared_mutable_state, clone_shared_mutable_state;\n-export get_shared_mutable_state, get_shared_immutable_state;\n-export unwrap_shared_mutable_state;\n-export Exclusive, exclusive, unwrap_exclusive;\n-\n use compare_and_swap = rustrt::rust_compare_and_swap_ptr;\n use task::TaskBuilder;\n use task::atomically;\n@@ -49,7 +42,7 @@ type GlobalPtr = *libc::uintptr_t;\n  * or, if no channel exists creates and installs a new channel and sets up a\n  * new task to receive from it.\n  */\n-unsafe fn chan_from_global_ptr<T: Send>(\n+pub unsafe fn chan_from_global_ptr<T: Send>(\n     global: GlobalPtr,\n     task_fn: fn() -> task::TaskBuilder,\n     +f: fn~(comm::Port<T>)\n@@ -110,7 +103,7 @@ unsafe fn chan_from_global_ptr<T: Send>(\n }\n \n #[test]\n-fn test_from_global_chan1() {\n+pub fn test_from_global_chan1() {\n \n     // This is unreadable, right?\n \n@@ -147,7 +140,7 @@ fn test_from_global_chan1() {\n }\n \n #[test]\n-fn test_from_global_chan2() {\n+pub fn test_from_global_chan2() {\n \n     for iter::repeat(100u) {\n         // The global channel\n@@ -208,7 +201,7 @@ fn test_from_global_chan2() {\n  * * Weak tasks must not be supervised. A supervised task keeps\n  *   a reference to its parent, so the parent will not die.\n  */\n-unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n+pub unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n     let po = comm::Port();\n     let ch = comm::Chan(po);\n     unsafe {\n@@ -232,7 +225,7 @@ unsafe fn weaken_task(f: fn(comm::Port<()>)) {\n }\n \n #[test]\n-fn test_weaken_task_then_unweaken() {\n+pub fn test_weaken_task_then_unweaken() {\n     do task::try {\n         unsafe {\n             do weaken_task |_po| {\n@@ -242,7 +235,7 @@ fn test_weaken_task_then_unweaken() {\n }\n \n #[test]\n-fn test_weaken_task_wait() {\n+pub fn test_weaken_task_wait() {\n     do task::spawn_unlinked {\n         unsafe {\n             do weaken_task |po| {\n@@ -253,7 +246,7 @@ fn test_weaken_task_wait() {\n }\n \n #[test]\n-fn test_weaken_task_stress() {\n+pub fn test_weaken_task_stress() {\n     // Create a bunch of weak tasks\n     for iter::repeat(100u) {\n         do task::spawn {\n@@ -275,7 +268,7 @@ fn test_weaken_task_stress() {\n \n #[test]\n #[ignore(cfg(windows))]\n-fn test_weaken_task_fail() {\n+pub fn test_weaken_task_fail() {\n     let res = do task::try {\n         unsafe {\n             do weaken_task |_po| {\n@@ -347,7 +340,7 @@ fn ArcDestruct<T>(data: *libc::c_void) -> ArcDestruct<T> {\n     }\n }\n \n-unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n+pub unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n         -> T {\n     struct DeathThroes<T> {\n         mut ptr:      Option<~ArcData<T>>,\n@@ -418,9 +411,10 @@ unsafe fn unwrap_shared_mutable_state<T: Send>(+rc: SharedMutableState<T>)\n  * Data races between tasks can result in crashes and, with sufficient\n  * cleverness, arbitrary type coercion.\n  */\n-type SharedMutableState<T: Send> = ArcDestruct<T>;\n+pub type SharedMutableState<T: Send> = ArcDestruct<T>;\n \n-unsafe fn shared_mutable_state<T: Send>(+data: T) -> SharedMutableState<T> {\n+pub unsafe fn shared_mutable_state<T: Send>(+data: T) ->\n+        SharedMutableState<T> {\n     let data = ~ArcData { count: 1, unwrapper: 0, data: Some(move data) };\n     unsafe {\n         let ptr = cast::transmute(move data);\n@@ -429,7 +423,7 @@ unsafe fn shared_mutable_state<T: Send>(+data: T) -> SharedMutableState<T> {\n }\n \n #[inline(always)]\n-unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n+pub unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n         -> &a/mut T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n@@ -441,8 +435,8 @@ unsafe fn get_shared_mutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n     }\n }\n #[inline(always)]\n-unsafe fn get_shared_immutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n-        -> &a/T {\n+pub unsafe fn get_shared_immutable_state<T: Send>(\n+        rc: &a/SharedMutableState<T>) -> &a/T {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n         assert ptr.count > 0;\n@@ -453,7 +447,7 @@ unsafe fn get_shared_immutable_state<T: Send>(rc: &a/SharedMutableState<T>)\n     }\n }\n \n-unsafe fn clone_shared_mutable_state<T: Send>(rc: &SharedMutableState<T>)\n+pub unsafe fn clone_shared_mutable_state<T: Send>(rc: &SharedMutableState<T>)\n         -> SharedMutableState<T> {\n     unsafe {\n         let ptr: ~ArcData<T> = cast::reinterpret_cast(&(*rc).data);\n@@ -506,9 +500,9 @@ struct ExData<T: Send> { lock: LittleLock, mut failed: bool, mut data: T, }\n /**\n  * An arc over mutable data that is protected by a lock. For library use only.\n  */\n-struct Exclusive<T: Send> { x: SharedMutableState<ExData<T>> }\n+pub struct Exclusive<T: Send> { x: SharedMutableState<ExData<T>> }\n \n-fn exclusive<T:Send >(+user_data: T) -> Exclusive<T> {\n+pub fn exclusive<T:Send >(+user_data: T) -> Exclusive<T> {\n     let data = ExData {\n         lock: LittleLock(), mut failed: false, mut data: user_data\n     };\n@@ -550,19 +544,17 @@ impl<T: Send> Exclusive<T> {\n }\n \n // FIXME(#2585) make this a by-move method on the exclusive\n-fn unwrap_exclusive<T: Send>(+arc: Exclusive<T>) -> T {\n+pub fn unwrap_exclusive<T: Send>(+arc: Exclusive<T>) -> T {\n     let Exclusive { x: x } <- arc;\n     let inner = unsafe { unwrap_shared_mutable_state(move x) };\n     let ExData { data: data, _ } <- inner;\n     move data\n }\n \n #[cfg(test)]\n-mod tests {\n-    #[legacy_exports];\n-\n+pub mod tests {\n     #[test]\n-    fn exclusive_arc() {\n+    pub fn exclusive_arc() {\n         let mut futures = ~[];\n \n         let num_tasks = 10u;\n@@ -589,7 +581,7 @@ mod tests {\n     }\n \n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn exclusive_poison() {\n+    pub fn exclusive_poison() {\n         // Tests that if one task fails inside of an exclusive, subsequent\n         // accesses will also fail.\n         let x = exclusive(1);\n@@ -605,13 +597,13 @@ mod tests {\n     }\n \n     #[test]\n-    fn exclusive_unwrap_basic() {\n+    pub fn exclusive_unwrap_basic() {\n         let x = exclusive(~~\"hello\");\n         assert unwrap_exclusive(x) == ~~\"hello\";\n     }\n \n     #[test]\n-    fn exclusive_unwrap_contended() {\n+    pub fn exclusive_unwrap_contended() {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         do task::spawn {\n@@ -636,7 +628,7 @@ mod tests {\n     }\n \n     #[test] #[should_fail] #[ignore(cfg(windows))]\n-    fn exclusive_unwrap_conflict() {\n+    pub fn exclusive_unwrap_conflict() {\n         let x = exclusive(~~\"hello\");\n         let x2 = ~mut Some(x.clone());\n         let mut res = None;\n@@ -650,7 +642,7 @@ mod tests {\n     }\n \n     #[test] #[ignore(cfg(windows))]\n-    fn exclusive_unwrap_deadlock() {\n+    pub fn exclusive_unwrap_deadlock() {\n         // This is not guaranteed to get to the deadlock before being killed,\n         // but it will show up sometimes, and if the deadlock were not there,\n         // the test would nondeterministically fail."}]}