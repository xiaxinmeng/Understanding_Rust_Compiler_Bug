{"sha": "f2af07e6d5254ca7b2bb5791afe5314fe6947128", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyYWYwN2U2ZDUyNTRjYTdiMmJiNTc5MWFmZTUzMTRmZTY5NDcxMjg=", "commit": {"author": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-11-27T16:45:50Z"}, "committer": {"name": "Jorge Aparicio", "email": "japaricious@gmail.com", "date": "2014-12-07T00:05:58Z"}, "message": "libcollections: remove unnecessary `as_slice()` calls", "tree": {"sha": "71c522be7e17e7248700d67b111eee54ed324ae1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71c522be7e17e7248700d67b111eee54ed324ae1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f2af07e6d5254ca7b2bb5791afe5314fe6947128", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f2af07e6d5254ca7b2bb5791afe5314fe6947128", "html_url": "https://github.com/rust-lang/rust/commit/f2af07e6d5254ca7b2bb5791afe5314fe6947128", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f2af07e6d5254ca7b2bb5791afe5314fe6947128/comments", "author": null, "committer": null, "parents": [{"sha": "de83d7dd191bf5564855057a29f9b5d9dcfcb201", "url": "https://api.github.com/repos/rust-lang/rust/commits/de83d7dd191bf5564855057a29f9b5d9dcfcb201", "html_url": "https://github.com/rust-lang/rust/commit/de83d7dd191bf5564855057a29f9b5d9dcfcb201"}], "stats": {"total": 249, "additions": 123, "deletions": 126}, "files": [{"sha": "53d20aab24d61bece6430de05071e24c1b1ce53d", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -769,8 +769,8 @@ mod tests {\n         v.sort();\n         data.sort();\n \n-        assert_eq!(v.as_slice(), data.as_slice());\n-        assert_eq!(heap.into_sorted_vec().as_slice(), data.as_slice());\n+        assert_eq!(v, data);\n+        assert_eq!(heap.into_sorted_vec(), data);\n     }\n \n     #[test]\n@@ -812,7 +812,7 @@ mod tests {\n     fn test_from_iter() {\n         let xs = vec!(9u, 8, 7, 6, 5, 4, 3, 2, 1);\n \n-        let mut q: BinaryHeap<uint> = xs.as_slice().iter().rev().map(|&x| x).collect();\n+        let mut q: BinaryHeap<uint> = xs.iter().rev().map(|&x| x).collect();\n \n         for &x in xs.iter() {\n             assert_eq!(q.pop().unwrap(), x);"}, {"sha": "953e432fd4a75029e5cf5ac7589a3dced54d0be2", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -1692,10 +1692,10 @@ mod tests {\n     #[test]\n     fn test_to_str() {\n         let zerolen = Bitv::new();\n-        assert_eq!(zerolen.to_string().as_slice(), \"\");\n+        assert_eq!(zerolen.to_string(), \"\");\n \n         let eightbits = Bitv::with_capacity(8u, false);\n-        assert_eq!(eightbits.to_string().as_slice(), \"00000000\")\n+        assert_eq!(eightbits.to_string(), \"00000000\")\n     }\n \n     #[test]\n@@ -1718,7 +1718,7 @@ mod tests {\n         let mut b = bitv::Bitv::with_capacity(2, false);\n         b.set(0, true);\n         b.set(1, false);\n-        assert_eq!(b.to_string().as_slice(), \"10\");\n+        assert_eq!(b.to_string(), \"10\");\n     }\n \n     #[test]\n@@ -2029,7 +2029,7 @@ mod tests {\n     fn test_from_bytes() {\n         let bitv = from_bytes(&[0b10110110, 0b00000000, 0b11111111]);\n         let str = format!(\"{}{}{}\", \"10110110\", \"00000000\", \"11111111\");\n-        assert_eq!(bitv.to_string().as_slice(), str.as_slice());\n+        assert_eq!(bitv.to_string(), str);\n     }\n \n     #[test]\n@@ -2048,7 +2048,7 @@ mod tests {\n     fn test_from_bools() {\n         let bools = vec![true, false, true, true];\n         let bitv: Bitv = bools.iter().map(|n| *n).collect();\n-        assert_eq!(bitv.to_string().as_slice(), \"1011\");\n+        assert_eq!(bitv.to_string(), \"1011\");\n     }\n \n     #[test]\n@@ -2207,7 +2207,7 @@ mod tests {\n \n         let expected = [3, 5, 11, 77];\n         let actual = a.intersection(&b).collect::<Vec<uint>>();\n-        assert_eq!(actual.as_slice(), expected.as_slice());\n+        assert_eq!(actual, expected);\n     }\n \n     #[test]\n@@ -2226,7 +2226,7 @@ mod tests {\n \n         let expected = [1, 5, 500];\n         let actual = a.difference(&b).collect::<Vec<uint>>();\n-        assert_eq!(actual.as_slice(), expected.as_slice());\n+        assert_eq!(actual, expected);\n     }\n \n     #[test]\n@@ -2247,7 +2247,7 @@ mod tests {\n \n         let expected = [1, 5, 11, 14, 220];\n         let actual = a.symmetric_difference(&b).collect::<Vec<uint>>();\n-        assert_eq!(actual.as_slice(), expected.as_slice());\n+        assert_eq!(actual, expected);\n     }\n \n     #[test]\n@@ -2272,7 +2272,7 @@ mod tests {\n \n         let expected = [1, 3, 5, 9, 11, 13, 19, 24, 160, 200];\n         let actual = a.union(&b).collect::<Vec<uint>>();\n-        assert_eq!(actual.as_slice(), expected.as_slice());\n+        assert_eq!(actual, expected);\n     }\n \n     #[test]"}, {"sha": "2c681b6b1d354a44967c74ee4335885817e15389", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -169,22 +169,22 @@ impl <K, V> Node<K, V> {\n \n     /// Get the node's value at the given index\n     pub fn val(&self, index: uint) -> Option<&V> {\n-        self.vals.as_slice().get(index)\n+        self.vals.get(index)\n     }\n \n     /// Get the node's value at the given index\n     pub fn val_mut(&mut self, index: uint) -> Option<&mut V> {\n-        self.vals.as_mut_slice().get_mut(index)\n+        self.vals.get_mut(index)\n     }\n \n     /// Get the node's value mutably without any bounds checks.\n     pub unsafe fn unsafe_val_mut(&mut self, index: uint) -> &mut V {\n-        self.vals.as_mut_slice().unsafe_mut(index)\n+        self.vals.unsafe_mut(index)\n     }\n \n     /// Get the node's edge at the given index\n     pub fn edge(&self, index: uint) -> Option<&Node<K,V>> {\n-        self.edges.as_slice().get(index)\n+        self.edges.get(index)\n     }\n \n     /// Get the node's edge mutably at the given index\n@@ -281,8 +281,8 @@ impl <K, V> Node<K, V> {\n     pub fn iter<'a>(&'a self) -> Traversal<'a, K, V> {\n         let is_leaf = self.is_leaf();\n         Traversal {\n-            elems: self.keys.as_slice().iter().zip(self.vals.as_slice().iter()),\n-            edges: self.edges.as_slice().iter(),\n+            elems: self.keys.iter().zip(self.vals.iter()),\n+            edges: self.edges.iter(),\n             head_is_edge: true,\n             tail_is_edge: true,\n             has_edges: !is_leaf,\n@@ -292,7 +292,7 @@ impl <K, V> Node<K, V> {\n     pub fn iter_mut<'a>(&'a mut self) -> MutTraversal<'a, K, V> {\n         let is_leaf = self.is_leaf();\n         MutTraversal {\n-            elems: self.keys.as_slice().iter().zip(self.vals.as_mut_slice().iter_mut()),\n+            elems: self.keys.iter().zip(self.vals.as_mut_slice().iter_mut()),\n             edges: self.edges.as_mut_slice().iter_mut(),\n             head_is_edge: true,\n             tail_is_edge: true,\n@@ -477,7 +477,7 @@ fn split<T>(left: &mut Vec<T>) -> Vec<T> {\n     let left_len = len - right_len;\n     let mut right = Vec::with_capacity(left.capacity());\n     unsafe {\n-        let left_ptr = left.as_slice().unsafe_get(left_len) as *const _;\n+        let left_ptr = left.unsafe_get(left_len) as *const _;\n         let right_ptr = right.as_mut_slice().as_mut_ptr();\n         ptr::copy_nonoverlapping_memory(right_ptr, left_ptr, right_len);\n         left.set_len(left_len);"}, {"sha": "a30bb9e978b508c6644acd6826bf63c1b8c66058", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -926,7 +926,7 @@ mod tests {\n         let mut m = list_from(v.as_slice());\n         m.prepend(list_from(u.as_slice()));\n         check_links(&m);\n-        u.extend(v.as_slice().iter().map(|&b| b));\n+        u.extend(v.iter().map(|&b| b));\n         assert_eq!(u.len(), m.len());\n         for elt in u.into_iter() {\n             assert_eq!(m.pop_front(), Some(elt))\n@@ -1133,7 +1133,7 @@ mod tests {\n         spawn(proc() {\n             check_links(&n);\n             let a: &[_] = &[&1,&2,&3];\n-            assert_eq!(a, n.iter().collect::<Vec<&int>>().as_slice());\n+            assert_eq!(a, n.iter().collect::<Vec<&int>>());\n         });\n     }\n \n@@ -1224,12 +1224,12 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let list: DList<int> = range(0i, 10).collect();\n-        assert!(list.to_string().as_slice() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert!(list.to_string() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: DList<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                    .map(|&s| s)\n                                                                    .collect();\n-        assert!(list.to_string().as_slice() == \"[just, one, test, more]\");\n+        assert!(list.to_string() == \"[just, one, test, more]\");\n     }\n \n     #[cfg(test)]"}, {"sha": "5e77cf66726a872c557409b81b2374c850a55cab", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -288,11 +288,11 @@ mod test {\n     #[test]\n     fn test_show() {\n         let mut e = EnumSet::new();\n-        assert_eq!(\"{}\", e.to_string().as_slice());\n+        assert_eq!(\"{}\", e.to_string());\n         e.insert(A);\n-        assert_eq!(\"{A}\", e.to_string().as_slice());\n+        assert_eq!(\"{A}\", e.to_string());\n         e.insert(C);\n-        assert_eq!(\"{A, C}\", e.to_string().as_slice());\n+        assert_eq!(\"{A, C}\", e.to_string());\n     }\n \n     #[test]"}, {"sha": "d9e5dde96ceee7693be941db311b068b517dc98b", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -1246,15 +1246,15 @@ mod tests {\n         }\n         {\n             let b: &[_] = &[&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), b);\n+            assert_eq!(d.iter().collect::<Vec<&int>>(), b);\n         }\n \n         for i in range(6i, 9) {\n             d.push_front(i);\n         }\n         {\n             let b: &[_] = &[&8,&7,&6,&0,&1,&2,&3,&4];\n-            assert_eq!(d.iter().collect::<Vec<&int>>().as_slice(), b);\n+            assert_eq!(d.iter().collect::<Vec<&int>>(), b);\n         }\n \n         let mut it = d.iter();\n@@ -1277,14 +1277,14 @@ mod tests {\n         }\n         {\n             let b: &[_] = &[&4,&3,&2,&1,&0];\n-            assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), b);\n+            assert_eq!(d.iter().rev().collect::<Vec<&int>>(), b);\n         }\n \n         for i in range(6i, 9) {\n             d.push_front(i);\n         }\n         let b: &[_] = &[&4,&3,&2,&1,&0,&6,&7,&8];\n-        assert_eq!(d.iter().rev().collect::<Vec<&int>>().as_slice(), b);\n+        assert_eq!(d.iter().rev().collect::<Vec<&int>>(), b);\n     }\n \n     #[test]\n@@ -1495,12 +1495,12 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let ringbuf: RingBuf<int> = range(0i, 10).collect();\n-        assert!(format!(\"{}\", ringbuf).as_slice() == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert!(format!(\"{}\", ringbuf) == \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let ringbuf: RingBuf<&str> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                         .map(|&s| s)\n                                                                         .collect();\n-        assert!(format!(\"{}\", ringbuf).as_slice() == \"[just, one, test, more]\");\n+        assert!(format!(\"{}\", ringbuf) == \"[just, one, test, more]\");\n     }\n \n     #[test]"}, {"sha": "57e16fd7454ff218e8097d119ef07d0c3099217a", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -1652,62 +1652,62 @@ mod tests {\n         let xs = &[1i,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1], &[3], &[5]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 1).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1,2,3,4], &[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 10).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[], &[], &[], &[], &[]];\n-        assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|_| true).collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.split(|x| *x == 5).collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_splitnator() {\n         let xs = &[1i,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.splitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1], &[3,4,5]];\n-        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.splitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[], &[], &[4,5]];\n-        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.splitn(3, |_| true).collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.splitn(1, |x| *x == 5).collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_splitnator_mut() {\n         let xs = &mut [1i,2,3,4,5];\n \n         let splits: &[&mut [int]] = &[&mut [1,2,3,4,5]];\n-        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(0, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n                    splits);\n         let splits: &[&mut [int]] = &[&mut [1], &mut [3,4,5]];\n-        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(1, |x| *x % 2 == 0).collect::<Vec<&mut [int]>>(),\n                    splits);\n         let splits: &[&mut [int]] = &[&mut [], &mut [], &mut [], &mut [4,5]];\n-        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(3, |_| true).collect::<Vec<&mut [int]>>(),\n                    splits);\n \n         let xs: &mut [int] = &mut [];\n         let splits: &[&mut [int]] = &[&mut []];\n-        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<&mut [int]>>().as_slice(),\n+        assert_eq!(xs.splitn_mut(1, |x| *x == 5).collect::<Vec<&mut [int]>>(),\n                    splits);\n     }\n \n@@ -1716,50 +1716,50 @@ mod tests {\n         let xs = &[1i,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[5], &[3], &[1]];\n-        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x % 2 == 0).rev().collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[2,3,4,5], &[]];\n-        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 1).rev().collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[1,2,3,4]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.split(|x| *x == 10).rev().collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.split(|x| *x == 5).rev().collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_rsplitnator() {\n         let xs = &[1,2,3,4,5];\n \n         let splits: &[&[int]] = &[&[1,2,3,4,5]];\n-        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.rsplitn(0, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[5], &[1,2,3]];\n-        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.rsplitn(1, |x| *x % 2 == 0).collect::<Vec<&[int]>>(),\n                    splits);\n         let splits: &[&[int]] = &[&[], &[], &[], &[1,2]];\n-        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>().as_slice(),\n+        assert_eq!(xs.rsplitn(3, |_| true).collect::<Vec<&[int]>>(),\n                    splits);\n \n         let xs: &[int] = &[];\n         let splits: &[&[int]] = &[&[]];\n-        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>().as_slice(), splits);\n+        assert_eq!(xs.rsplitn(1, |x| *x == 5).collect::<Vec<&[int]>>(), splits);\n     }\n \n     #[test]\n     fn test_windowsator() {\n         let v = &[1i,2,3,4];\n \n         let wins: &[&[int]] = &[&[1,2], &[2,3], &[3,4]];\n-        assert_eq!(v.windows(2).collect::<Vec<&[int]>>().as_slice(), wins);\n+        assert_eq!(v.windows(2).collect::<Vec<&[int]>>(), wins);\n         let wins: &[&[int]] = &[&[1i,2,3], &[2,3,4]];\n-        assert_eq!(v.windows(3).collect::<Vec<&[int]>>().as_slice(), wins);\n+        assert_eq!(v.windows(3).collect::<Vec<&[int]>>(), wins);\n         assert!(v.windows(6).next().is_none());\n     }\n \n@@ -1775,14 +1775,14 @@ mod tests {\n         let v = &[1i,2,3,4,5];\n \n         let chunks: &[&[int]] = &[&[1i,2], &[3,4], &[5]];\n-        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(2).collect::<Vec<&[int]>>(), chunks);\n         let chunks: &[&[int]] = &[&[1i,2,3], &[4,5]];\n-        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(3).collect::<Vec<&[int]>>(), chunks);\n         let chunks: &[&[int]] = &[&[1i,2,3,4,5]];\n-        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(6).collect::<Vec<&[int]>>(), chunks);\n \n         let chunks: &[&[int]] = &[&[5i], &[3,4], &[1,2]];\n-        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>().as_slice(), chunks);\n+        assert_eq!(v.chunks(2).rev().collect::<Vec<&[int]>>(), chunks);\n         let mut it = v.chunks(2);\n         assert_eq!(it.indexable(), 3);\n         let chunk: &[int] = &[1,2];\n@@ -2081,7 +2081,7 @@ mod tests {\n     fn test_to_vec() {\n         let xs = box [1u, 2, 3];\n         let ys = xs.to_vec();\n-        assert_eq!(ys.as_slice(), [1u, 2, 3].as_slice());\n+        assert_eq!(ys, [1u, 2, 3]);\n     }\n }\n "}, {"sha": "6e26962950ba2d7b937360543ef123e4009185ac", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -215,7 +215,7 @@ pub struct Decompositions<'a> {\n impl<'a> Iterator<char> for Decompositions<'a> {\n     #[inline]\n     fn next(&mut self) -> Option<char> {\n-        match self.buffer.as_slice().head() {\n+        match self.buffer.head() {\n             Some(&(c, 0)) => {\n                 self.sorted = false;\n                 self.buffer.remove(0);\n@@ -913,18 +913,18 @@ mod tests {\n     #[test]\n     fn test_collect() {\n         let empty = String::from_str(\"\");\n-        let s: String = empty.as_slice().chars().collect();\n+        let s: String = empty.chars().collect();\n         assert_eq!(empty, s);\n         let data = String::from_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n-        let s: String = data.as_slice().chars().collect();\n+        let s: String = data.chars().collect();\n         assert_eq!(data, s);\n     }\n \n     #[test]\n     fn test_into_bytes() {\n         let data = String::from_str(\"asdf\");\n         let buf = data.into_bytes();\n-        assert_eq!(b\"asdf\", buf.as_slice());\n+        assert_eq!(b\"asdf\", buf);\n     }\n \n     #[test]\n@@ -941,21 +941,21 @@ mod tests {\n         let string = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n         let mut data = String::from_str(string);\n         data.push_str(string);\n-        assert!(data.as_slice().find_str(\"\u0e44\u0e17\u534e\").is_none());\n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\"), Some(0u));\n-        assert_eq!(data.as_slice().slice(6u, 43u).find_str(\"\"), Some(6u - 6u));\n+        assert!(data.find_str(\"\u0e44\u0e17\u534e\").is_none());\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\"), Some(0u));\n+        assert_eq!(data.slice(6u, 43u).find_str(\"\"), Some(6u - 6u));\n \n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0u));\n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\u0e17\u0e28\u0e44\"), Some(12u));\n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"\u0e22\u4e2d\"), Some(24u));\n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"i\u1ec7t\"), Some(34u));\n-        assert_eq!(data.as_slice().slice(0u, 43u).find_str(\"Nam\"), Some(40u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e1b\u0e23\u0e30\"), Some( 0u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e17\u0e28\u0e44\"), Some(12u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"\u0e22\u4e2d\"), Some(24u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"i\u1ec7t\"), Some(34u));\n+        assert_eq!(data.slice(0u, 43u).find_str(\"Nam\"), Some(40u));\n \n-        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"\u0e1b\u0e23\u0e30\"), Some(43u - 43u));\n-        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"\u0e17\u0e28\u0e44\"), Some(55u - 43u));\n-        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"\u0e22\u4e2d\"), Some(67u - 43u));\n-        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"i\u1ec7t\"), Some(77u - 43u));\n-        assert_eq!(data.as_slice().slice(43u, 86u).find_str(\"Nam\"), Some(83u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e1b\u0e23\u0e30\"), Some(43u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e17\u0e28\u0e44\"), Some(55u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"\u0e22\u4e2d\"), Some(67u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"i\u1ec7t\"), Some(77u - 43u));\n+        assert_eq!(data.slice(43u, 86u).find_str(\"Nam\"), Some(83u - 43u));\n     }\n \n     #[test]\n@@ -987,7 +987,7 @@ mod tests {\n         ($expected: expr, $string: expr) => {\n             {\n                 let s = $string.concat();\n-                assert_eq!($expected, s.as_slice());\n+                assert_eq!($expected, s);\n             }\n         }\n     }\n@@ -1025,7 +1025,7 @@ mod tests {\n         ($expected: expr, $string: expr, $delim: expr) => {\n             {\n                 let s = $string.connect($delim);\n-                assert_eq!($expected, s.as_slice());\n+                assert_eq!($expected, s);\n             }\n         }\n     }\n@@ -1146,7 +1146,7 @@ mod tests {\n \n         let a = \"\u0e1b\u0e23\u0e30\u0e40\";\n         let a2 = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(data.replace(a, repl).as_slice(), a2);\n+        assert_eq!(data.replace(a, repl), a2);\n     }\n \n     #[test]\n@@ -1156,7 +1156,7 @@ mod tests {\n \n         let b = \"\u0e30\u0e40\";\n         let b2 = \"\u0e1b\u0e23\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534e\";\n-        assert_eq!(data.replace(b, repl).as_slice(), b2);\n+        assert_eq!(data.replace(b, repl), b2);\n     }\n \n     #[test]\n@@ -1166,7 +1166,7 @@ mod tests {\n \n         let c = \"\u4e2d\u534e\";\n         let c2 = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n-        assert_eq!(data.replace(c, repl).as_slice(), c2);\n+        assert_eq!(data.replace(c, repl), c2);\n     }\n \n     #[test]\n@@ -1175,7 +1175,7 @@ mod tests {\n         let repl = \"\u062f\u0648\u0644\u0629 \u0627\u0644\u0643\u0648\u064a\u062a\";\n \n         let d = \"\u0e44\u0e17\u534e\";\n-        assert_eq!(data.replace(d, repl).as_slice(), data);\n+        assert_eq!(data.replace(d, repl), data);\n     }\n \n     #[test]\n@@ -1211,7 +1211,7 @@ mod tests {\n         }\n         let letters = a_million_letter_x();\n         assert!(half_a_million_letter_x() ==\n-            String::from_str(letters.as_slice().slice(0u, 3u * 500000u)));\n+            String::from_str(letters.slice(0u, 3u * 500000u)));\n     }\n \n     #[test]\n@@ -1450,7 +1450,7 @@ mod tests {\n         let b: &[u8] = &[];\n         assert_eq!(\"\".as_bytes(), b);\n         assert_eq!(\"abc\".as_bytes(), b\"abc\");\n-        assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v.as_slice());\n+        assert_eq!(\"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".as_bytes(), v);\n     }\n \n     #[test]\n@@ -1485,7 +1485,6 @@ mod tests {\n \n         let string = \"a\\nb\\nc\";\n         let lines: Vec<&str> = string.lines().collect();\n-        let lines = lines.as_slice();\n         assert_eq!(string.subslice_offset(lines[0]), 0);\n         assert_eq!(string.subslice_offset(lines[1]), 2);\n         assert_eq!(string.subslice_offset(lines[2]), 4);\n@@ -2181,10 +2180,10 @@ mod tests {\n         let s = \"a\u0310e\u0301o\u0308\u0332\\r\\n\";\n         let gr_inds = s.grapheme_indices(true).collect::<Vec<(uint, &str)>>();\n         let b: &[_] = &[(0u, \"a\u0310\"), (3, \"e\u0301\"), (6, \"o\u0308\u0332\"), (11, \"\\r\\n\")];\n-        assert_eq!(gr_inds.as_slice(), b);\n+        assert_eq!(gr_inds, b);\n         let gr_inds = s.grapheme_indices(true).rev().collect::<Vec<(uint, &str)>>();\n         let b: &[_] = &[(11, \"\\r\\n\"), (6, \"o\u0308\u0332\"), (3, \"e\u0301\"), (0u, \"a\u0310\")];\n-        assert_eq!(gr_inds.as_slice(), b);\n+        assert_eq!(gr_inds, b);\n         let mut gr_inds_iter = s.grapheme_indices(true);\n         {\n             let gr_inds = gr_inds_iter.by_ref();\n@@ -2200,14 +2199,14 @@ mod tests {\n         let s = \"\\n\\r\\n\\r\";\n         let gr = s.graphemes(true).rev().collect::<Vec<&str>>();\n         let b: &[_] = &[\"\\r\", \"\\r\\n\", \"\\n\"];\n-        assert_eq!(gr.as_slice(), b);\n+        assert_eq!(gr, b);\n     }\n \n     #[test]\n     fn test_split_strator() {\n         fn t(s: &str, sep: &str, u: &[&str]) {\n             let v: Vec<&str> = s.split_str(sep).collect();\n-            assert_eq!(v.as_slice(), u.as_slice());\n+            assert_eq!(v, u);\n         }\n         t(\"--1233345--\", \"12345\", &[\"--1233345--\"]);\n         t(\"abc::hello::there\", \"::\", &[\"abc\", \"hello\", \"there\"]);"}, {"sha": "a7545d069602718fbac4efad61f5ef6128c0eaa4", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -559,7 +559,7 @@ impl String {\n     #[inline]\n     #[unstable = \"the panic conventions for strings are under development\"]\n     pub fn truncate(&mut self, new_len: uint) {\n-        assert!(self.as_slice().is_char_boundary(new_len));\n+        assert!(self.is_char_boundary(new_len));\n         self.vec.truncate(new_len)\n     }\n \n@@ -583,7 +583,7 @@ impl String {\n             return None\n         }\n \n-        let CharRange {ch, next} = self.as_slice().char_range_at_reverse(len);\n+        let CharRange {ch, next} = self.char_range_at_reverse(len);\n         unsafe {\n             self.vec.set_len(next);\n         }\n@@ -618,7 +618,7 @@ impl String {\n         let len = self.len();\n         if idx >= len { return None }\n \n-        let CharRange { ch, next } = self.as_slice().char_range_at(idx);\n+        let CharRange { ch, next } = self.char_range_at(idx);\n         unsafe {\n             ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as int),\n                              self.vec.as_ptr().offset(next as int),\n@@ -643,7 +643,7 @@ impl String {\n     pub fn insert(&mut self, idx: uint, ch: char) {\n         let len = self.len();\n         assert!(idx <= len);\n-        assert!(self.as_slice().is_char_boundary(idx));\n+        assert!(self.is_char_boundary(idx));\n         self.vec.reserve(4);\n         let mut bits = [0, ..4];\n         let amt = ch.encode_utf8(&mut bits).unwrap();\n@@ -1092,7 +1092,7 @@ mod tests {\n \n         for p in pairs.iter() {\n             let (s, u) = (*p).clone();\n-            let s_as_utf16 = s.as_slice().utf16_units().collect::<Vec<u16>>();\n+            let s_as_utf16 = s.utf16_units().collect::<Vec<u16>>();\n             let u_as_string = String::from_utf16(u.as_slice()).unwrap();\n \n             assert!(str::is_utf16(u.as_slice()));\n@@ -1102,7 +1102,7 @@ mod tests {\n             assert_eq!(String::from_utf16_lossy(u.as_slice()), s);\n \n             assert_eq!(String::from_utf16(s_as_utf16.as_slice()).unwrap(), s);\n-            assert_eq!(u_as_string.as_slice().utf16_units().collect::<Vec<u16>>(), u);\n+            assert_eq!(u_as_string.utf16_units().collect::<Vec<u16>>(), u);\n         }\n     }\n \n@@ -1162,18 +1162,18 @@ mod tests {\n             let mv = s.as_mut_vec();\n             mv.push_all(&[b'D']);\n         }\n-        assert_eq!(s.as_slice(), \"ABCD\");\n+        assert_eq!(s, \"ABCD\");\n     }\n \n     #[test]\n     fn test_push_str() {\n         let mut s = String::new();\n         s.push_str(\"\");\n-        assert_eq!(s.as_slice().slice_from(0), \"\");\n+        assert_eq!(s.slice_from(0), \"\");\n         s.push_str(\"abc\");\n-        assert_eq!(s.as_slice().slice_from(0), \"abc\");\n+        assert_eq!(s.slice_from(0), \"abc\");\n         s.push_str(\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n-        assert_eq!(s.as_slice().slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n+        assert_eq!(s.slice_from(0), \"abc\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\");\n     }\n \n     #[test]\n@@ -1184,7 +1184,7 @@ mod tests {\n         data.push('\u00a2'); // 2 byte\n         data.push('\u20ac'); // 3 byte\n         data.push('\ud852\udf62'); // 4 byte\n-        assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n+        assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eb\u00a2\u20ac\ud852\udf62\");\n     }\n \n     #[test]\n@@ -1195,24 +1195,24 @@ mod tests {\n         assert_eq!(data.pop().unwrap(), '\u00a2'); // 2 bytes\n         assert_eq!(data.pop().unwrap(), 'b'); // 1 bytes\n         assert_eq!(data.pop().unwrap(), '\u534e');\n-        assert_eq!(data.as_slice(), \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n+        assert_eq!(data, \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\");\n     }\n \n     #[test]\n     fn test_str_truncate() {\n         let mut s = String::from_str(\"12345\");\n         s.truncate(5);\n-        assert_eq!(s.as_slice(), \"12345\");\n+        assert_eq!(s, \"12345\");\n         s.truncate(3);\n-        assert_eq!(s.as_slice(), \"123\");\n+        assert_eq!(s, \"123\");\n         s.truncate(0);\n-        assert_eq!(s.as_slice(), \"\");\n+        assert_eq!(s, \"\");\n \n         let mut s = String::from_str(\"12345\");\n-        let p = s.as_slice().as_ptr();\n+        let p = s.as_ptr();\n         s.truncate(3);\n         s.push_str(\"6\");\n-        let p_ = s.as_slice().as_ptr();\n+        let p_ = s.as_ptr();\n         assert_eq!(p_, p);\n     }\n \n@@ -1235,7 +1235,7 @@ mod tests {\n         let mut s = String::from_str(\"12345\");\n         s.clear();\n         assert_eq!(s.len(), 0);\n-        assert_eq!(s.as_slice(), \"\");\n+        assert_eq!(s, \"\");\n     }\n \n     #[test]\n@@ -1244,19 +1244,19 @@ mod tests {\n         let b = a + \"2\";\n         let b = b + String::from_str(\"2\");\n         assert_eq!(b.len(), 7);\n-        assert_eq!(b.as_slice(), \"1234522\");\n+        assert_eq!(b, \"1234522\");\n     }\n \n     #[test]\n     fn remove() {\n         let mut s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\".to_string();;\n         assert_eq!(s.remove(0), Some('\u0e28'));\n         assert_eq!(s.len(), 33);\n-        assert_eq!(s.as_slice(), \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n+        assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; foobar\");\n         assert_eq!(s.remove(33), None);\n         assert_eq!(s.remove(300), None);\n         assert_eq!(s.remove(17), Some('\u1ec7'));\n-        assert_eq!(s.as_slice(), \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n+        assert_eq!(s, \"\u0e44\u0e17\u0e22\u4e2d\u534eVit Nam; foobar\");\n     }\n \n     #[test] #[should_fail]\n@@ -1268,9 +1268,9 @@ mod tests {\n     fn insert() {\n         let mut s = \"foobar\".to_string();\n         s.insert(0, '\u1ec7');\n-        assert_eq!(s.as_slice(), \"\u1ec7foobar\");\n+        assert_eq!(s, \"\u1ec7foobar\");\n         s.insert(6, '\u0e22');\n-        assert_eq!(s.as_slice(), \"\u1ec7foo\u0e22bar\");\n+        assert_eq!(s, \"\u1ec7foo\u0e22bar\");\n     }\n \n     #[test] #[should_fail] fn insert_bad1() { \"\".to_string().insert(1, 't'); }"}, {"sha": "e2411ced632afae726a9dd312fec8305b71a9ef9", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -798,7 +798,7 @@ impl<T> Vec<T> {\n                 // decrement len before the read(), so a panic on Drop doesn't\n                 // re-drop the just-failed value.\n                 self.len -= 1;\n-                ptr::read(self.as_slice().unsafe_get(self.len));\n+                ptr::read(self.unsafe_get(self.len));\n             }\n         }\n     }\n@@ -1091,7 +1091,7 @@ impl<T> Vec<T> {\n         } else {\n             unsafe {\n                 self.len -= 1;\n-                Some(ptr::read(self.as_slice().unsafe_get(self.len())))\n+                Some(ptr::read(self.unsafe_get(self.len())))\n             }\n         }\n     }\n@@ -1779,7 +1779,7 @@ mod tests {\n     #[test]\n     fn test_as_vec() {\n         let xs = [1u8, 2u8, 3u8];\n-        assert_eq!(as_vec(&xs).as_slice(), xs.as_slice());\n+        assert_eq!(as_vec(&xs).as_slice(), xs);\n     }\n \n     #[test]\n@@ -1875,7 +1875,7 @@ mod tests {\n             }\n         }\n \n-        assert!(values.as_slice() == [1, 2, 5, 6, 7]);\n+        assert!(values == [1, 2, 5, 6, 7]);\n     }\n \n     #[test]\n@@ -1889,7 +1889,7 @@ mod tests {\n             }\n         }\n \n-        assert!(values.as_slice() == [2, 3, 3, 4, 5]);\n+        assert!(values == [2, 3, 3, 4, 5]);\n     }\n \n     #[test]\n@@ -2019,7 +2019,6 @@ mod tests {\n \n         let (left, right) = unzip(z1.iter().map(|&x| x));\n \n-        let (left, right) = (left.as_slice(), right.as_slice());\n         assert_eq!((1, 4), (left[0], right[0]));\n         assert_eq!((2, 5), (left[1], right[1]));\n         assert_eq!((3, 6), (left[2], right[2]));\n@@ -2153,15 +2152,15 @@ mod tests {\n     #[test]\n     fn test_map_in_place() {\n         let v = vec![0u, 1, 2];\n-        assert_eq!(v.map_in_place(|i: uint| i as int - 1).as_slice(), [-1i, 0, 1].as_slice());\n+        assert_eq!(v.map_in_place(|i: uint| i as int - 1), [-1i, 0, 1]);\n     }\n \n     #[test]\n     fn test_map_in_place_zero_sized() {\n         let v = vec![(), ()];\n         #[deriving(PartialEq, Show)]\n         struct ZeroSized;\n-        assert_eq!(v.map_in_place(|_| ZeroSized).as_slice(), [ZeroSized, ZeroSized].as_slice());\n+        assert_eq!(v.map_in_place(|_| ZeroSized), [ZeroSized, ZeroSized]);\n     }\n \n     #[test]\n@@ -2198,7 +2197,7 @@ mod tests {\n     fn test_into_boxed_slice() {\n         let xs = vec![1u, 2, 3];\n         let ys = xs.into_boxed_slice();\n-        assert_eq!(ys.as_slice(), [1u, 2, 3].as_slice());\n+        assert_eq!(ys.as_slice(), [1u, 2, 3]);\n     }\n \n     #[bench]"}, {"sha": "3be662c071c1606110dd82e14831c08ec1cef0b5", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f2af07e6d5254ca7b2bb5791afe5314fe6947128/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=f2af07e6d5254ca7b2bb5791afe5314fe6947128", "patch": "@@ -870,7 +870,6 @@ mod test_map {\n         map.insert(3, 4i);\n \n         let map_str = map.to_string();\n-        let map_str = map_str.as_slice();\n         assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n         assert_eq!(format!(\"{}\", empty), \"{}\".to_string());\n     }"}]}