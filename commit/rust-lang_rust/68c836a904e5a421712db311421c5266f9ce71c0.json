{"sha": "68c836a904e5a421712db311421c5266f9ce71c0", "node_id": "C_kwDOAAsO6NoAKDY4YzgzNmE5MDRlNWE0MjE3MTJkYjMxMTQyMWM1MjY2ZjljZTcxYzA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-29T14:14:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-29T14:14:08Z"}, "message": "Auto merge of #103727 - GuillaumeGomez:rollup-hfyxccr, r=GuillaumeGomez\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #102634 (compiletest: Refactor test rustcflags)\n - #102721 (Prevent foreign Rust exceptions from being caught)\n - #103415 (filter candidates in pick probe for diagnostics)\n - #103618 (Rename some `OwnerId` fields.)\n - #103625 (Accept `TyCtxt` instead of `TyCtxtAt` in `Ty::is_*` functions)\n - #103653 (Add missing impl blocks for item reexported from private mod in JSON output)\n - #103699 (Emit proper error when casting to `dyn*`)\n - #103719 (fix typo in `try_reserve` method from `HashMap` and `HashSet`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8504a616af8f9d1232c82b197b2deacd0372e6bc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8504a616af8f9d1232c82b197b2deacd0372e6bc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68c836a904e5a421712db311421c5266f9ce71c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68c836a904e5a421712db311421c5266f9ce71c0", "html_url": "https://github.com/rust-lang/rust/commit/68c836a904e5a421712db311421c5266f9ce71c0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68c836a904e5a421712db311421c5266f9ce71c0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33b530e04099465a8029ef581202d52f4075558e", "url": "https://api.github.com/repos/rust-lang/rust/commits/33b530e04099465a8029ef581202d52f4075558e", "html_url": "https://github.com/rust-lang/rust/commit/33b530e04099465a8029ef581202d52f4075558e"}, {"sha": "642576404504160d770c3e08c361bf3d703debee", "url": "https://api.github.com/repos/rust-lang/rust/commits/642576404504160d770c3e08c361bf3d703debee", "html_url": "https://github.com/rust-lang/rust/commit/642576404504160d770c3e08c361bf3d703debee"}], "stats": {"total": 1948, "additions": 1084, "deletions": 864}, "files": [{"sha": "f1851d7b40ea27a4dae8f979300d4e1892bc926d", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -112,19 +112,19 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n         debug!(\"visit_nested_item: {:?}\", item);\n-        self.insert_nested(item.def_id.def_id);\n+        self.insert_nested(item.owner_id.def_id);\n     }\n \n     fn visit_nested_trait_item(&mut self, item_id: TraitItemId) {\n-        self.insert_nested(item_id.def_id.def_id);\n+        self.insert_nested(item_id.owner_id.def_id);\n     }\n \n     fn visit_nested_impl_item(&mut self, item_id: ImplItemId) {\n-        self.insert_nested(item_id.def_id.def_id);\n+        self.insert_nested(item_id.owner_id.def_id);\n     }\n \n     fn visit_nested_foreign_item(&mut self, foreign_id: ForeignItemId) {\n-        self.insert_nested(foreign_id.def_id.def_id);\n+        self.insert_nested(foreign_id.owner_id.def_id);\n     }\n \n     fn visit_nested_body(&mut self, id: BodyId) {\n@@ -143,7 +143,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n-        debug_assert_eq!(i.def_id, self.owner);\n+        debug_assert_eq!(i.owner_id, self.owner);\n         self.with_parent(i.hir_id(), |this| {\n             if let ItemKind::Struct(ref struct_def, _) = i.kind {\n                 // If this is a tuple or unit-like struct, register the constructor.\n@@ -157,7 +157,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n-        debug_assert_eq!(fi.def_id, self.owner);\n+        debug_assert_eq!(fi.owner_id, self.owner);\n         self.with_parent(fi.hir_id(), |this| {\n             intravisit::walk_foreign_item(this, fi);\n         });\n@@ -176,15 +176,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n-        debug_assert_eq!(ti.def_id, self.owner);\n+        debug_assert_eq!(ti.owner_id, self.owner);\n         self.with_parent(ti.hir_id(), |this| {\n             intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n     #[instrument(level = \"debug\", skip(self))]\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n-        debug_assert_eq!(ii.def_id, self.owner);\n+        debug_assert_eq!(ii.owner_id, self.owner);\n         self.with_parent(ii.hir_id(), |this| {\n             intravisit::walk_impl_item(this, ii);\n         });"}, {"sha": "76316a574acb7033c2311b45e32d06a84e9f3a2d", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -178,7 +178,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     pub(super) fn lower_item_ref(&mut self, i: &Item) -> SmallVec<[hir::ItemId; 1]> {\n         let mut node_ids =\n-            smallvec![hir::ItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n+            smallvec![hir::ItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } }];\n         if let ItemKind::Use(ref use_tree) = &i.kind {\n             self.lower_item_id_use_tree(use_tree, i.id, &mut node_ids);\n         }\n@@ -195,7 +195,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             UseTreeKind::Nested(ref nested_vec) => {\n                 for &(ref nested, id) in nested_vec {\n                     vec.push(hir::ItemId {\n-                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                        owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n                     });\n                     self.lower_item_id_use_tree(nested, id, vec);\n                 }\n@@ -206,7 +206,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     iter::zip(self.expect_full_res_from_use(base_id).skip(1), &[id1, id2])\n                 {\n                     vec.push(hir::ItemId {\n-                        def_id: hir::OwnerId { def_id: self.local_def_id(id) },\n+                        owner_id: hir::OwnerId { def_id: self.local_def_id(id) },\n                     });\n                 }\n             }\n@@ -220,7 +220,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let attrs = self.lower_attrs(hir_id, &i.attrs);\n         let kind = self.lower_item_kind(i.span, i.id, hir_id, &mut ident, attrs, vis_span, &i.kind);\n         let item = hir::Item {\n-            def_id: hir_id.expect_owner(),\n+            owner_id: hir_id.expect_owner(),\n             ident: self.lower_ident(ident),\n             kind,\n             vis_span,\n@@ -562,7 +562,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: hir::OwnerId { def_id: new_id },\n+                            owner_id: hir::OwnerId { def_id: new_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -640,7 +640,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         }\n \n                         let item = hir::Item {\n-                            def_id: hir::OwnerId { def_id: new_hir_id },\n+                            owner_id: hir::OwnerId { def_id: new_hir_id },\n                             ident: this.lower_ident(ident),\n                             kind,\n                             vis_span,\n@@ -660,10 +660,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item(&mut self, i: &ForeignItem) -> &'hir hir::ForeignItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n-        let def_id = hir_id.expect_owner();\n+        let owner_id = hir_id.expect_owner();\n         self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::ForeignItem {\n-            def_id,\n+            owner_id,\n             ident: self.lower_ident(i.ident),\n             kind: match i.kind {\n                 ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n@@ -702,7 +702,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_foreign_item_ref(&mut self, i: &ForeignItem) -> hir::ForeignItemRef {\n         hir::ForeignItemRef {\n-            id: hir::ForeignItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n+            id: hir::ForeignItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n         }\n@@ -845,7 +845,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::TraitItem {\n-            def_id: trait_item_def_id,\n+            owner_id: trait_item_def_id,\n             ident: self.lower_ident(i.ident),\n             generics,\n             kind,\n@@ -864,7 +864,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::MacCall(..) => unimplemented!(),\n         };\n-        let id = hir::TraitItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } };\n+        let id = hir::TraitItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } };\n         hir::TraitItemRef {\n             id,\n             ident: self.lower_ident(i.ident),\n@@ -931,7 +931,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let hir_id = self.lower_node_id(i.id);\n         self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::ImplItem {\n-            def_id: hir_id.expect_owner(),\n+            owner_id: hir_id.expect_owner(),\n             ident: self.lower_ident(i.ident),\n             generics,\n             kind,\n@@ -944,7 +944,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_impl_item_ref(&mut self, i: &AssocItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n-            id: hir::ImplItemId { def_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n+            id: hir::ImplItemId { owner_id: hir::OwnerId { def_id: self.local_def_id(i.id) } },\n             ident: self.lower_ident(i.ident),\n             span: self.lower_span(i.span),\n             kind: match &i.kind {"}, {"sha": "ff29d15f1b525aae9208cd40bcbc5b15adef37ed", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -1574,7 +1574,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // `impl Trait` now just becomes `Foo<'a, 'b, ..>`.\n         hir::TyKind::OpaqueDef(\n-            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n+            hir::ItemId { owner_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n             lifetimes,\n             in_trait,\n         )\n@@ -1593,7 +1593,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // Generate an `type Foo = impl Trait;` declaration.\n         trace!(\"registering opaque type with id {:#?}\", opaque_ty_id);\n         let opaque_ty_item = hir::Item {\n-            def_id: hir::OwnerId { def_id: opaque_ty_id },\n+            owner_id: hir::OwnerId { def_id: opaque_ty_id },\n             ident: Ident::empty(),\n             kind: opaque_ty_item_kind,\n             vis_span: self.lower_span(span.shrink_to_lo()),\n@@ -2044,7 +2044,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // async fn, so the *type parameters* are inherited.  It's\n         // only the lifetime parameters that we must supply.\n         let opaque_ty_ref = hir::TyKind::OpaqueDef(\n-            hir::ItemId { def_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n+            hir::ItemId { owner_id: hir::OwnerId { def_id: opaque_ty_def_id } },\n             generic_args,\n             in_trait,\n         );"}, {"sha": "3c1c3ab45ce7a6639a74211a35be77ce01ddb07c", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -1783,7 +1783,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n         let erased_ty = tcx.erase_regions(ty);\n-        if !erased_ty.is_sized(tcx.at(span), self.param_env) {\n+        if !erased_ty.is_sized(tcx, self.param_env) {\n             // in current MIR construction, all non-control-flow rvalue\n             // expressions evaluate through `as_temp` or `into` a return\n             // slot or local, so to find all unsized rvalues it is enough"}, {"sha": "1db44502742e921b4bcbbdff9d76bce7e1e5e849", "filename": "compiler/rustc_codegen_cranelift/src/base.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fbase.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -770,11 +770,7 @@ fn codegen_stmt<'tcx>(\n                     lval.write_cvalue(fx, CValue::by_val(operand, box_layout));\n                 }\n                 Rvalue::NullaryOp(null_op, ty) => {\n-                    assert!(\n-                        lval.layout()\n-                            .ty\n-                            .is_sized(fx.tcx.at(stmt.source_info.span), ParamEnv::reveal_all())\n-                    );\n+                    assert!(lval.layout().ty.is_sized(fx.tcx, ParamEnv::reveal_all()));\n                     let layout = fx.layout_of(fx.monomorphize(ty));\n                     let val = match null_op {\n                         NullOp::SizeOf => layout.size.bytes(),"}, {"sha": "148b66d959e8a74126c5fdde83eb48f3a3de1290", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -5,7 +5,6 @@ use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::interpret::{\n     read_target_uint, AllocId, ConstAllocation, ConstValue, ErrorHandled, GlobalAlloc, Scalar,\n };\n-use rustc_span::DUMMY_SP;\n \n use cranelift_module::*;\n \n@@ -291,7 +290,7 @@ fn data_id_for_static(\n     let is_mutable = if tcx.is_mutable_static(def_id) {\n         true\n     } else {\n-        !ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all())\n+        !ty.is_freeze(tcx, ParamEnv::reveal_all())\n     };\n     let align = tcx.layout_of(ParamEnv::reveal_all().and(ty)).unwrap().align.pref.bytes();\n "}, {"sha": "bdc6a91cf6ab5f411cd61602e2920212dfb228eb", "filename": "compiler/rustc_codegen_ssa/src/traits/type_.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Ftype_.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -5,7 +5,6 @@ use crate::common::TypeKind;\n use crate::mir::place::PlaceRef;\n use rustc_middle::ty::layout::TyAndLayout;\n use rustc_middle::ty::{self, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::call::{ArgAbi, CastTarget, FnAbi, Reg};\n use rustc_target::abi::{AddressSpace, Integer};\n \n@@ -75,16 +74,16 @@ pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n     }\n \n     fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all())\n+        ty.is_sized(self.tcx(), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all())\n+        ty.is_freeze(self.tcx(), ty::ParamEnv::reveal_all())\n     }\n \n     fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n         let param_env = ty::ParamEnv::reveal_all();\n-        if ty.is_sized(self.tcx().at(DUMMY_SP), param_env) {\n+        if ty.is_sized(self.tcx(), param_env) {\n             return false;\n         }\n "}, {"sha": "f4da11883957a73f0376d35c2202c659a2d1a8ab", "filename": "compiler/rustc_const_eval/src/const_eval/valtrees.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fvaltrees.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -212,7 +212,7 @@ fn create_pointee_place<'tcx>(\n ) -> MPlaceTy<'tcx> {\n     let tcx = ecx.tcx.tcx;\n \n-    if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty()) {\n+    if !ty.is_sized(*ecx.tcx, ty::ParamEnv::empty()) {\n         // We need to create `Allocation`s for custom DSTs\n \n         let (unsized_inner_ty, num_elems) = get_info_on_unsized_field(ty, valtree, tcx);\n@@ -398,7 +398,7 @@ fn valtree_into_mplace<'tcx>(\n \n                 let mut place_inner = match ty.kind() {\n                     ty::Str | ty::Slice(_) => ecx.mplace_index(&place, i as u64).unwrap(),\n-                    _ if !ty.is_sized(ecx.tcx, ty::ParamEnv::empty())\n+                    _ if !ty.is_sized(*ecx.tcx, ty::ParamEnv::empty())\n                         && i == branches.len() - 1 =>\n                     {\n                         // Note: For custom DSTs we need to manually process the last unsized field."}, {"sha": "a9063ad31cfe65c8b9d631888538b076eeeb9cdd", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -468,7 +468,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(self.tcx, self.param_env)\n+        ty.is_freeze(*self.tcx, self.param_env)\n     }\n \n     pub fn load_mir("}, {"sha": "6809a42dc45364b78a5fecbc3bfa218f304daec9", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -114,7 +114,7 @@ fn intern_shallow<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_eval:\n     if let InternMode::Static(mutability) = mode {\n         // For this, we need to take into account `UnsafeCell`. When `ty` is `None`, we assume\n         // no interior mutability.\n-        let frozen = ty.map_or(true, |ty| ty.is_freeze(ecx.tcx, ecx.param_env));\n+        let frozen = ty.map_or(true, |ty| ty.is_freeze(*ecx.tcx, ecx.param_env));\n         // For statics, allocation mutability is the combination of place mutability and\n         // type mutability.\n         // The entire allocation needs to be mutable if it contains an `UnsafeCell` anywhere."}, {"sha": "8aa56c275d91b93c51b1618c87687a9146ca57c7", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -15,7 +15,6 @@ use rustc_middle::mir::interpret::InterpError;\n use rustc_middle::ty;\n use rustc_middle::ty::layout::{LayoutOf, TyAndLayout};\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::{Abi, Scalar as ScalarAbi, Size, VariantIdx, Variants, WrappingRange};\n \n use std::hash::Hash;\n@@ -726,7 +725,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n     ) -> InterpResult<'tcx> {\n         // Special check preventing `UnsafeCell` inside unions in the inner part of constants.\n         if matches!(self.ctfe_mode, Some(CtfeValidationMode::Const { inner: true, .. })) {\n-            if !op.layout.ty.is_freeze(self.ecx.tcx.at(DUMMY_SP), self.ecx.param_env) {\n+            if !op.layout.ty.is_freeze(*self.ecx.tcx, self.ecx.param_env) {\n                 throw_validation_failure!(self.path, { \"`UnsafeCell` in a `const`\" });\n             }\n         }"}, {"sha": "335992342a64756e393398380fea985ca93cbf6b", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -8,7 +8,6 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir;\n use rustc_middle::mir::*;\n use rustc_middle::ty::{self, subst::SubstsRef, AdtDef, Ty};\n-use rustc_span::DUMMY_SP;\n use rustc_trait_selection::traits::{\n     self, ImplSource, Obligation, ObligationCause, SelectionContext,\n };\n@@ -92,7 +91,7 @@ impl Qualif for HasMutInterior {\n     }\n \n     fn in_any_value_of_ty<'tcx>(cx: &ConstCx<'_, 'tcx>, ty: Ty<'tcx>) -> bool {\n-        !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n+        !ty.is_freeze(cx.tcx, cx.param_env)\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "805e6096b35c8577c2a033d3f999f26c462c5a55", "filename": "compiler/rustc_const_eval/src/transform/check_consts/resolver.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -8,7 +8,6 @@ use rustc_middle::mir::{self, BasicBlock, Local, Location, Statement, StatementK\n use rustc_mir_dataflow::fmt::DebugWithContext;\n use rustc_mir_dataflow::JoinSemiLattice;\n use rustc_mir_dataflow::{Analysis, AnalysisDomain, CallReturnPlaces};\n-use rustc_span::DUMMY_SP;\n \n use std::fmt;\n use std::marker::PhantomData;\n@@ -120,10 +119,7 @@ where\n     ///\n     /// [rust-lang/unsafe-code-guidelines#134]: https://github.com/rust-lang/unsafe-code-guidelines/issues/134\n     fn shared_borrow_allows_mutation(&self, place: mir::Place<'tcx>) -> bool {\n-        !place\n-            .ty(self.ccx.body, self.ccx.tcx)\n-            .ty\n-            .is_freeze(self.ccx.tcx.at(DUMMY_SP), self.ccx.param_env)\n+        !place.ty(self.ccx.body, self.ccx.tcx).ty.is_freeze(self.ccx.tcx, self.ccx.param_env)\n     }\n }\n "}, {"sha": "81b82a21fa1a7276796672a3980784bad79869ed", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -235,9 +235,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n             // `Operand::Copy` is only supposed to be used with `Copy` types.\n             if let Operand::Copy(place) = operand {\n                 let ty = place.ty(&self.body.local_decls, self.tcx).ty;\n-                let span = self.body.source_info(location).span;\n \n-                if !ty.is_copy_modulo_regions(self.tcx.at(span), self.param_env) {\n+                if !ty.is_copy_modulo_regions(self.tcx, self.param_env) {\n                     self.fail(location, format!(\"`Operand::Copy` with non-`Copy` type {}\", ty));\n                 }\n             }"}, {"sha": "ef00c1ffc302d9ab12e510db364b7357c2b0fe5c", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -2207,14 +2207,14 @@ pub struct FnSig<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct TraitItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl TraitItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n@@ -2225,7 +2225,7 @@ impl TraitItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct TraitItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: TraitItemKind<'hir>,\n     pub span: Span,\n@@ -2236,11 +2236,11 @@ impl TraitItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn trait_item_id(&self) -> TraitItemId {\n-        TraitItemId { def_id: self.def_id }\n+        TraitItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -2271,22 +2271,22 @@ pub enum TraitItemKind<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ImplItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl ImplItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n /// Represents anything within an `impl` block.\n #[derive(Debug, HashStable_Generic)]\n pub struct ImplItem<'hir> {\n     pub ident: Ident,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub generics: &'hir Generics<'hir>,\n     pub kind: ImplItemKind<'hir>,\n     pub defaultness: Defaultness,\n@@ -2298,11 +2298,11 @@ impl ImplItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn impl_item_id(&self) -> ImplItemId {\n-        ImplItemId { def_id: self.def_id }\n+        ImplItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -2914,14 +2914,14 @@ impl<'hir> VariantData<'hir> {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, Hash, HashStable_Generic)]\n pub struct ItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl ItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n@@ -2931,7 +2931,7 @@ impl ItemId {\n #[derive(Debug, HashStable_Generic)]\n pub struct Item<'hir> {\n     pub ident: Ident,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub kind: ItemKind<'hir>,\n     pub span: Span,\n     pub vis_span: Span,\n@@ -2941,11 +2941,11 @@ impl Item<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn item_id(&self) -> ItemId {\n-        ItemId { def_id: self.def_id }\n+        ItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -3158,14 +3158,14 @@ pub enum AssocItemKind {\n // so it can fetched later.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Debug, HashStable_Generic)]\n pub struct ForeignItemId {\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n }\n \n impl ForeignItemId {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n }\n \n@@ -3186,7 +3186,7 @@ pub struct ForeignItemRef {\n pub struct ForeignItem<'hir> {\n     pub ident: Ident,\n     pub kind: ForeignItemKind<'hir>,\n-    pub def_id: OwnerId,\n+    pub owner_id: OwnerId,\n     pub span: Span,\n     pub vis_span: Span,\n }\n@@ -3195,11 +3195,11 @@ impl ForeignItem<'_> {\n     #[inline]\n     pub fn hir_id(&self) -> HirId {\n         // Items are always HIR owners.\n-        HirId::make_owner(self.def_id.def_id)\n+        HirId::make_owner(self.owner_id.def_id)\n     }\n \n     pub fn foreign_item_id(&self) -> ForeignItemId {\n-        ForeignItemId { def_id: self.def_id }\n+        ForeignItemId { owner_id: self.owner_id }\n     }\n }\n \n@@ -3291,10 +3291,10 @@ impl<'hir> OwnerNode<'hir> {\n \n     pub fn def_id(self) -> OwnerId {\n         match self {\n-            OwnerNode::Item(Item { def_id, .. })\n-            | OwnerNode::TraitItem(TraitItem { def_id, .. })\n-            | OwnerNode::ImplItem(ImplItem { def_id, .. })\n-            | OwnerNode::ForeignItem(ForeignItem { def_id, .. }) => *def_id,\n+            OwnerNode::Item(Item { owner_id, .. })\n+            | OwnerNode::TraitItem(TraitItem { owner_id, .. })\n+            | OwnerNode::ImplItem(ImplItem { owner_id, .. })\n+            | OwnerNode::ForeignItem(ForeignItem { owner_id, .. }) => *owner_id,\n             OwnerNode::Crate(..) => crate::CRATE_HIR_ID.owner,\n         }\n     }"}, {"sha": "be77e6fd36a07ec858c9c524dae13e43c05d9ff5", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -912,7 +912,7 @@ pub fn walk_fn<'v, V: Visitor<'v>>(\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n-    let TraitItem { ident, generics, ref defaultness, ref kind, span, def_id: _ } = *trait_item;\n+    let TraitItem { ident, generics, ref defaultness, ref kind, span, owner_id: _ } = *trait_item;\n     let hir_id = trait_item.hir_id();\n     visitor.visit_ident(ident);\n     visitor.visit_generics(&generics);\n@@ -952,7 +952,7 @@ pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref:\n pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplItem<'v>) {\n     // N.B., deliberately force a compilation error if/when new fields are added.\n     let ImplItem {\n-        def_id: _,\n+        owner_id: _,\n         ident,\n         ref generics,\n         ref kind,"}, {"sha": "23423e8f3b3bff5f7121730e857a190e665d8667", "filename": "compiler/rustc_hir/src/stable_hash_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fstable_hash_impls.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -49,7 +49,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -58,7 +58,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for TraitItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -67,7 +67,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ImplItemId {\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n \n@@ -76,7 +76,7 @@ impl<HirCtx: crate::HashStableContext> ToStableHashKey<HirCtx> for ForeignItemId\n \n     #[inline]\n     fn to_stable_hash_key(&self, hcx: &HirCtx) -> DefPathHash {\n-        self.def_id.def_id.to_stable_hash_key(hcx)\n+        self.owner_id.def_id.to_stable_hash_key(hcx)\n     }\n }\n "}, {"sha": "38f195dabb90428cac239c1103fd115b2a473874", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -2661,7 +2661,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::OpaqueDef(item_id, lifetimes, in_trait) => {\n                 let opaque_ty = tcx.hir().item(item_id);\n-                let def_id = item_id.def_id.to_def_id();\n+                let def_id = item_id.owner_id.to_def_id();\n \n                 match opaque_ty.kind {\n                     hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) => {"}, {"sha": "b70ac02058d3dd3d5dccdcd58d129bcb0c30bee1", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -114,7 +114,7 @@ fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: LocalDefId) -> b\n                 _ => {\n                     // Fallback case: allow `ManuallyDrop` and things that are `Copy`.\n                     ty.ty_adt_def().is_some_and(|adt_def| adt_def.is_manually_drop())\n-                        || ty.is_copy_modulo_regions(tcx.at(span), param_env)\n+                        || ty.is_copy_modulo_regions(tcx, param_env)\n                 }\n             }\n         }\n@@ -227,17 +227,17 @@ fn check_opaque<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n         return;\n     }\n \n-    let substs = InternalSubsts::identity_for_item(tcx, item.def_id.to_def_id());\n-    let span = tcx.def_span(item.def_id.def_id);\n+    let substs = InternalSubsts::identity_for_item(tcx, item.owner_id.to_def_id());\n+    let span = tcx.def_span(item.owner_id.def_id);\n \n-    check_opaque_for_inheriting_lifetimes(tcx, item.def_id.def_id, span);\n-    if tcx.type_of(item.def_id.def_id).references_error() {\n+    check_opaque_for_inheriting_lifetimes(tcx, item.owner_id.def_id, span);\n+    if tcx.type_of(item.owner_id.def_id).references_error() {\n         return;\n     }\n-    if check_opaque_for_cycles(tcx, item.def_id.def_id, substs, span, &origin).is_err() {\n+    if check_opaque_for_cycles(tcx, item.owner_id.def_id, substs, span, &origin).is_err() {\n         return;\n     }\n-    check_opaque_meets_bounds(tcx, item.def_id.def_id, substs, span, &origin);\n+    check_opaque_meets_bounds(tcx, item.owner_id.def_id, substs, span, &origin);\n }\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n@@ -492,38 +492,38 @@ fn check_opaque_meets_bounds<'tcx>(\n fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n     debug!(\n         \"check_item_type(it.def_id={:?}, it.name={})\",\n-        id.def_id,\n-        tcx.def_path_str(id.def_id.to_def_id())\n+        id.owner_id,\n+        tcx.def_path_str(id.owner_id.to_def_id())\n     );\n     let _indenter = indenter();\n-    match tcx.def_kind(id.def_id) {\n+    match tcx.def_kind(id.owner_id) {\n         DefKind::Static(..) => {\n-            tcx.ensure().typeck(id.def_id.def_id);\n-            maybe_check_static_with_link_section(tcx, id.def_id.def_id);\n-            check_static_inhabited(tcx, id.def_id.def_id);\n+            tcx.ensure().typeck(id.owner_id.def_id);\n+            maybe_check_static_with_link_section(tcx, id.owner_id.def_id);\n+            check_static_inhabited(tcx, id.owner_id.def_id);\n         }\n         DefKind::Const => {\n-            tcx.ensure().typeck(id.def_id.def_id);\n+            tcx.ensure().typeck(id.owner_id.def_id);\n         }\n         DefKind::Enum => {\n             let item = tcx.hir().item(id);\n             let hir::ItemKind::Enum(ref enum_definition, _) = item.kind else {\n                 return;\n             };\n-            check_enum(tcx, &enum_definition.variants, item.def_id.def_id);\n+            check_enum(tcx, &enum_definition.variants, item.owner_id.def_id);\n         }\n         DefKind::Fn => {} // entirely within check_item_body\n         DefKind::Impl => {\n             let it = tcx.hir().item(id);\n             let hir::ItemKind::Impl(ref impl_) = it.kind else {\n                 return;\n             };\n-            debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.def_id);\n-            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.def_id) {\n+            debug!(\"ItemKind::Impl {} with id {:?}\", it.ident, it.owner_id);\n+            if let Some(impl_trait_ref) = tcx.impl_trait_ref(it.owner_id) {\n                 check_impl_items_against_trait(\n                     tcx,\n                     it.span,\n-                    it.def_id.def_id,\n+                    it.owner_id.def_id,\n                     impl_trait_ref,\n                     &impl_.items,\n                 );\n@@ -545,32 +545,32 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                         fn_maybe_err(tcx, item.ident.span, abi);\n                     }\n                     hir::TraitItemKind::Type(.., Some(default)) => {\n-                        let assoc_item = tcx.associated_item(item.def_id);\n+                        let assoc_item = tcx.associated_item(item.owner_id);\n                         let trait_substs =\n-                            InternalSubsts::identity_for_item(tcx, it.def_id.to_def_id());\n+                            InternalSubsts::identity_for_item(tcx, it.owner_id.to_def_id());\n                         let _: Result<_, rustc_errors::ErrorGuaranteed> = check_type_bounds(\n                             tcx,\n                             assoc_item,\n                             assoc_item,\n                             default.span,\n-                            ty::TraitRef { def_id: it.def_id.to_def_id(), substs: trait_substs },\n+                            ty::TraitRef { def_id: it.owner_id.to_def_id(), substs: trait_substs },\n                         );\n                     }\n                     _ => {}\n                 }\n             }\n         }\n         DefKind::Struct => {\n-            check_struct(tcx, id.def_id.def_id);\n+            check_struct(tcx, id.owner_id.def_id);\n         }\n         DefKind::Union => {\n-            check_union(tcx, id.def_id.def_id);\n+            check_union(tcx, id.owner_id.def_id);\n         }\n         DefKind::OpaqueTy => {\n             check_opaque(tcx, id);\n         }\n         DefKind::ImplTraitPlaceholder => {\n-            let parent = tcx.impl_trait_in_trait_parent(id.def_id.to_def_id());\n+            let parent = tcx.impl_trait_in_trait_parent(id.owner_id.to_def_id());\n             // Only check the validity of this opaque type if the function has a default body\n             if let hir::Node::TraitItem(hir::TraitItem {\n                 kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(_)),\n@@ -581,8 +581,8 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n             }\n         }\n         DefKind::TyAlias => {\n-            let pty_ty = tcx.type_of(id.def_id);\n-            let generics = tcx.generics_of(id.def_id);\n+            let pty_ty = tcx.type_of(id.owner_id);\n+            let generics = tcx.generics_of(id.owner_id);\n             check_type_params_are_used(tcx, &generics, pty_ty);\n         }\n         DefKind::ForeignMod => {\n@@ -604,7 +604,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n                 }\n             } else {\n                 for item in items {\n-                    let def_id = item.id.def_id.def_id;\n+                    let def_id = item.id.owner_id.def_id;\n                     let generics = tcx.generics_of(def_id);\n                     let own_counts = generics.own_counts();\n                     if generics.params.len() - own_counts.lifetimes != 0 {\n@@ -659,7 +659,7 @@ fn check_item_type<'tcx>(tcx: TyCtxt<'tcx>, id: hir::ItemId) {\n \n pub(super) fn check_on_unimplemented(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n     // an error would be reported if this fails.\n-    let _ = traits::OnUnimplementedDirective::of_item(tcx, item.def_id.to_def_id());\n+    let _ = traits::OnUnimplementedDirective::of_item(tcx, item.owner_id.to_def_id());\n }\n \n pub(super) fn check_specialization_validity<'tcx>(\n@@ -746,7 +746,7 @@ fn check_impl_items_against_trait<'tcx>(\n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n \n     for impl_item in impl_item_refs {\n-        let ty_impl_item = tcx.associated_item(impl_item.id.def_id);\n+        let ty_impl_item = tcx.associated_item(impl_item.id.owner_id);\n         let ty_trait_item = if let Some(trait_item_id) = ty_impl_item.trait_item_def_id {\n             tcx.associated_item(trait_item_id)\n         } else {\n@@ -758,7 +758,7 @@ fn check_impl_items_against_trait<'tcx>(\n         match impl_item_full.kind {\n             hir::ImplItemKind::Const(..) => {\n                 let _ = tcx.compare_assoc_const_impl_item_with_trait_item((\n-                    impl_item.id.def_id.def_id,\n+                    impl_item.id.owner_id.def_id,\n                     ty_impl_item.trait_item_def_id.unwrap(),\n                 ));\n             }"}, {"sha": "609095c9ceaa7511b8c0106a73c6202116116e86", "filename": "compiler/rustc_hir_analysis/src/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -26,7 +26,7 @@ fn equate_intrinsic_type<'tcx>(\n ) {\n     let (own_counts, span) = match &it.kind {\n         hir::ForeignItemKind::Fn(.., generics) => {\n-            let own_counts = tcx.generics_of(it.def_id.to_def_id()).own_counts();\n+            let own_counts = tcx.generics_of(it.owner_id.to_def_id()).own_counts();\n             (own_counts, generics.span)\n         }\n         _ => {\n@@ -57,7 +57,7 @@ fn equate_intrinsic_type<'tcx>(\n     {\n         let fty = tcx.mk_fn_ptr(sig);\n         let cause = ObligationCause::new(it.span, it.hir_id(), ObligationCauseCode::IntrinsicType);\n-        require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(it.def_id)), fty);\n+        require_same_types(tcx, &cause, tcx.mk_fn_ptr(tcx.fn_sig(it.owner_id)), fty);\n     }\n }\n \n@@ -129,7 +129,7 @@ pub fn intrinsic_operation_unsafety(tcx: TyCtxt<'_>, intrinsic_id: DefId) -> hir\n /// and in `library/core/src/intrinsics.rs`.\n pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)));\n-    let intrinsic_id = it.def_id.to_def_id();\n+    let intrinsic_id = it.owner_id.to_def_id();\n     let intrinsic_name = tcx.item_name(intrinsic_id);\n     let name_str = intrinsic_name.as_str();\n "}, {"sha": "17c4d0d482f2ab0b2a72e58c27aad8717f3decff", "filename": "compiler/rustc_hir_analysis/src/check/intrinsicck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fintrinsicck.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -33,7 +33,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n     fn is_thin_ptr_ty(&self, ty: Ty<'tcx>) -> bool {\n         // Type still may have region variables, but `Sized` does not depend\n         // on those, so just erase them before querying.\n-        if ty.is_sized(self.tcx.at(DUMMY_SP), self.param_env) {\n+        if ty.is_sized(self.tcx, self.param_env) {\n             return true;\n         }\n         if let ty::Foreign(..) = ty.kind() {\n@@ -128,7 +128,7 @@ impl<'a, 'tcx> InlineAsmCtxt<'a, 'tcx> {\n \n         // Check that the type implements Copy. The only case where this can\n         // possibly fail is for SIMD types which don't #[derive(Copy)].\n-        if !ty.is_copy_modulo_regions(self.tcx.at(expr.span), self.param_env) {\n+        if !ty.is_copy_modulo_regions(self.tcx, self.param_env) {\n             let msg = \"arguments for inline assembly must be copyable\";\n             let mut err = self.tcx.sess.struct_span_err(expr.span, msg);\n             err.note(&format!(\"`{ty}` does not implement the Copy trait\"));"}, {"sha": "a23575004655bdc28f84aebec9828dccabb3cc14", "filename": "compiler/rustc_hir_analysis/src/check/wfcheck.rs", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -147,10 +147,10 @@ fn check_well_formed(tcx: TyCtxt<'_>, def_id: hir::OwnerId) {\n /// the types first.\n #[instrument(skip(tcx), level = \"debug\")]\n fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-    let def_id = item.def_id.def_id;\n+    let def_id = item.owner_id.def_id;\n \n     debug!(\n-        ?item.def_id,\n+        ?item.owner_id,\n         item.name = ? tcx.def_path_str(def_id.to_def_id())\n     );\n \n@@ -246,10 +246,10 @@ fn check_item<'tcx>(tcx: TyCtxt<'tcx>, item: &'tcx hir::Item<'tcx>) {\n }\n \n fn check_foreign_item(tcx: TyCtxt<'_>, item: &hir::ForeignItem<'_>) {\n-    let def_id = item.def_id.def_id;\n+    let def_id = item.owner_id.def_id;\n \n     debug!(\n-        ?item.def_id,\n+        ?item.owner_id,\n         item.name = ? tcx.def_path_str(def_id.to_def_id())\n     );\n \n@@ -263,7 +263,7 @@ fn check_foreign_item(tcx: TyCtxt<'_>, item: &hir::ForeignItem<'_>) {\n }\n \n fn check_trait_item(tcx: TyCtxt<'_>, trait_item: &hir::TraitItem<'_>) {\n-    let def_id = trait_item.def_id.def_id;\n+    let def_id = trait_item.owner_id.def_id;\n \n     let (method_sig, span) = match trait_item.kind {\n         hir::TraitItemKind::Fn(ref sig, _) => (Some(sig), trait_item.span),\n@@ -275,7 +275,7 @@ fn check_trait_item(tcx: TyCtxt<'_>, trait_item: &hir::TraitItem<'_>) {\n \n     let encl_trait_def_id = tcx.local_parent(def_id);\n     let encl_trait = tcx.hir().expect_item(encl_trait_def_id);\n-    let encl_trait_def_id = encl_trait.def_id.to_def_id();\n+    let encl_trait_def_id = encl_trait.owner_id.to_def_id();\n     let fn_lang_item_name = if Some(encl_trait_def_id) == tcx.lang_items().fn_trait() {\n         Some(\"fn\")\n     } else if Some(encl_trait_def_id) == tcx.lang_items().fn_mut_trait() {\n@@ -348,7 +348,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n     loop {\n         let mut should_continue = false;\n         for gat_item in associated_items {\n-            let gat_def_id = gat_item.id.def_id;\n+            let gat_def_id = gat_item.id.owner_id;\n             let gat_item = tcx.associated_item(gat_def_id);\n             // If this item is not an assoc ty, or has no substs, then it's not a GAT\n             if gat_item.kind != ty::AssocKind::Type {\n@@ -365,7 +365,7 @@ fn check_gat_where_clauses(tcx: TyCtxt<'_>, associated_items: &[hir::TraitItemRe\n             // constrains the GAT with individually.\n             let mut new_required_bounds: Option<FxHashSet<ty::Predicate<'_>>> = None;\n             for item in associated_items {\n-                let item_def_id = item.id.def_id;\n+                let item_def_id = item.id.owner_id;\n                 // Skip our own GAT, since it does not constrain itself at all.\n                 if item_def_id == gat_def_id {\n                     continue;\n@@ -790,7 +790,7 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n     let (trait_name, trait_def_id) =\n         match tcx.hir().get_by_def_id(tcx.hir().get_parent_item(item.hir_id()).def_id) {\n             hir::Node::Item(item) => match item.kind {\n-                hir::ItemKind::Trait(..) => (item.ident, item.def_id),\n+                hir::ItemKind::Trait(..) => (item.ident, item.owner_id),\n                 _ => return,\n             },\n             _ => return,\n@@ -845,7 +845,7 @@ fn check_impl_item(tcx: TyCtxt<'_>, impl_item: &hir::ImplItem<'_>) {\n         _ => (None, impl_item.span),\n     };\n \n-    check_associated_item(tcx, impl_item.def_id.def_id, span, method_sig);\n+    check_associated_item(tcx, impl_item.owner_id.def_id, span, method_sig);\n }\n \n fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n@@ -1045,11 +1045,11 @@ fn check_type_defn<'tcx, F>(\n ) where\n     F: FnMut(&WfCheckingCtxt<'_, 'tcx>) -> Vec<AdtVariant<'tcx>>,\n {\n-    let _ = tcx.representability(item.def_id.def_id);\n+    let _ = tcx.representability(item.owner_id.def_id);\n \n-    enter_wf_checking_ctxt(tcx, item.span, item.def_id.def_id, |wfcx| {\n+    enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n         let variants = lookup_fields(wfcx);\n-        let packed = tcx.adt_def(item.def_id).repr().packed();\n+        let packed = tcx.adt_def(item.owner_id).repr().packed();\n \n         for variant in &variants {\n             // All field types must be well-formed.\n@@ -1073,7 +1073,7 @@ fn check_type_defn<'tcx, F>(\n                         // Just treat unresolved type expression as if it needs drop.\n                         true\n                     } else {\n-                        ty.needs_drop(tcx, tcx.param_env(item.def_id))\n+                        ty.needs_drop(tcx, tcx.param_env(item.owner_id))\n                     }\n                 }\n             };\n@@ -1121,15 +1121,15 @@ fn check_type_defn<'tcx, F>(\n             }\n         }\n \n-        check_where_clauses(wfcx, item.span, item.def_id.def_id);\n+        check_where_clauses(wfcx, item.span, item.owner_id.def_id);\n     });\n }\n \n #[instrument(skip(tcx, item))]\n fn check_trait(tcx: TyCtxt<'_>, item: &hir::Item<'_>) {\n-    debug!(?item.def_id);\n+    debug!(?item.owner_id);\n \n-    let def_id = item.def_id.def_id;\n+    let def_id = item.owner_id.def_id;\n     let trait_def = tcx.trait_def(def_id);\n     if trait_def.is_marker\n         || matches!(trait_def.specialization_kind, TraitSpecializationKind::Marker)\n@@ -1240,13 +1240,13 @@ fn check_impl<'tcx>(\n     ast_trait_ref: &Option<hir::TraitRef<'_>>,\n     constness: hir::Constness,\n ) {\n-    enter_wf_checking_ctxt(tcx, item.span, item.def_id.def_id, |wfcx| {\n+    enter_wf_checking_ctxt(tcx, item.span, item.owner_id.def_id, |wfcx| {\n         match *ast_trait_ref {\n             Some(ref ast_trait_ref) => {\n                 // `#[rustc_reservation_impl]` impls are not real impls and\n                 // therefore don't need to be WF (the trait's `Self: Trait` predicate\n                 // won't hold).\n-                let trait_ref = tcx.impl_trait_ref(item.def_id).unwrap();\n+                let trait_ref = tcx.impl_trait_ref(item.owner_id).unwrap();\n                 let trait_ref = wfcx.normalize(ast_trait_ref.path.span, None, trait_ref);\n                 let trait_pred = ty::TraitPredicate {\n                     trait_ref,\n@@ -1268,7 +1268,7 @@ fn check_impl<'tcx>(\n                 wfcx.register_obligations(obligations);\n             }\n             None => {\n-                let self_ty = tcx.type_of(item.def_id);\n+                let self_ty = tcx.type_of(item.owner_id);\n                 let self_ty = wfcx.normalize(\n                     item.span,\n                     Some(WellFormedLoc::Ty(item.hir_id().expect_owner().def_id)),\n@@ -1282,7 +1282,7 @@ fn check_impl<'tcx>(\n             }\n         }\n \n-        check_where_clauses(wfcx, item.span, item.def_id.def_id);\n+        check_where_clauses(wfcx, item.span, item.owner_id.def_id);\n     });\n }\n \n@@ -1778,14 +1778,14 @@ fn check_variances_for_type_defn<'tcx>(\n     item: &hir::Item<'tcx>,\n     hir_generics: &hir::Generics<'_>,\n ) {\n-    let ty = tcx.type_of(item.def_id);\n+    let ty = tcx.type_of(item.owner_id);\n     if tcx.has_error_field(ty) {\n         return;\n     }\n \n-    let ty_predicates = tcx.predicates_of(item.def_id);\n+    let ty_predicates = tcx.predicates_of(item.owner_id);\n     assert_eq!(ty_predicates.parent, None);\n-    let variances = tcx.variances_of(item.def_id);\n+    let variances = tcx.variances_of(item.owner_id);\n \n     let mut constrained_parameters: FxHashSet<_> = variances\n         .iter()\n@@ -1798,7 +1798,7 @@ fn check_variances_for_type_defn<'tcx>(\n \n     // Lazily calculated because it is only needed in case of an error.\n     let explicitly_bounded_params = LazyCell::new(|| {\n-        let icx = crate::collect::ItemCtxt::new(tcx, item.def_id.to_def_id());\n+        let icx = crate::collect::ItemCtxt::new(tcx, item.owner_id.to_def_id());\n         hir_generics\n             .predicates\n             .iter()\n@@ -1919,10 +1919,10 @@ impl<'tcx> WfCheckingCtxt<'_, 'tcx> {\n \n fn check_mod_type_wf(tcx: TyCtxt<'_>, module: LocalDefId) {\n     let items = tcx.hir_module_items(module);\n-    items.par_items(|item| tcx.ensure().check_well_formed(item.def_id));\n-    items.par_impl_items(|item| tcx.ensure().check_well_formed(item.def_id));\n-    items.par_trait_items(|item| tcx.ensure().check_well_formed(item.def_id));\n-    items.par_foreign_items(|item| tcx.ensure().check_well_formed(item.def_id));\n+    items.par_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n+    items.par_impl_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n+    items.par_trait_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n+    items.par_foreign_items(|item| tcx.ensure().check_well_formed(item.owner_id));\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "d0c31733481b63ef24e1f5a2e9cc54d37a6a03c9", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -90,11 +90,11 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     let mut crates_to_lint = vec![];\n \n     for id in tcx.hir().items() {\n-        if matches!(tcx.def_kind(id.def_id), DefKind::ExternCrate) {\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::ExternCrate) {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::ExternCrate(orig_name) = item.kind {\n                 crates_to_lint.push(ExternCrateToLint {\n-                    def_id: item.def_id.to_def_id(),\n+                    def_id: item.owner_id.to_def_id(),\n                     span: item.span,\n                     orig_name,\n                     warn_if_unused: !item.ident.as_str().starts_with('_'),"}, {"sha": "2890c149b3afe3f2ac1eba2ecc37a438e9824e75", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -58,7 +58,7 @@ const ADD_ATTR: &str =\n \n impl<'tcx> InherentCollect<'tcx> {\n     fn check_def_id(&mut self, item: &hir::Item<'_>, self_ty: Ty<'tcx>, def_id: DefId) {\n-        let impl_def_id = item.def_id;\n+        let impl_def_id = item.owner_id;\n         if let Some(def_id) = def_id.as_local() {\n             // Add the implementation to the mapping from implementation to base\n             // type def ID, if there is a base type for this implementation and\n@@ -89,7 +89,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             for impl_item in items {\n                 if !self\n                     .tcx\n-                    .has_attr(impl_item.id.def_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n+                    .has_attr(impl_item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n                 {\n                     struct_span_err!(\n                         self.tcx.sess,\n@@ -135,7 +135,7 @@ impl<'tcx> InherentCollect<'tcx> {\n                 for item in items {\n                     if !self\n                         .tcx\n-                        .has_attr(item.id.def_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n+                        .has_attr(item.id.owner_id.to_def_id(), sym::rustc_allow_incoherent_impl)\n                     {\n                         struct_span_err!(\n                             self.tcx.sess,\n@@ -177,7 +177,7 @@ impl<'tcx> InherentCollect<'tcx> {\n     }\n \n     fn check_item(&mut self, id: hir::ItemId) {\n-        if !matches!(self.tcx.def_kind(id.def_id), DefKind::Impl) {\n+        if !matches!(self.tcx.def_kind(id.owner_id), DefKind::Impl) {\n             return;\n         }\n \n@@ -186,7 +186,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             return;\n         };\n \n-        let self_ty = self.tcx.type_of(item.def_id);\n+        let self_ty = self.tcx.type_of(item.owner_id);\n         match *self_ty.kind() {\n             ty::Adt(def, _) => {\n                 self.check_def_id(item, self_ty, def.did());\n@@ -221,7 +221,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Never\n             | ty::FnPtr(_)\n             | ty::Tuple(..) => {\n-                self.check_primitive_impl(item.def_id.def_id, self_ty, items, ty.span)\n+                self.check_primitive_impl(item.owner_id.def_id, self_ty, items, ty.span)\n             }\n             ty::Projection(..) | ty::Opaque(..) | ty::Param(_) => {\n                 let mut err = struct_span_err!(\n@@ -243,7 +243,7 @@ impl<'tcx> InherentCollect<'tcx> {\n             | ty::Bound(..)\n             | ty::Placeholder(_)\n             | ty::Infer(_) => {\n-                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.def_id, self_ty);\n+                bug!(\"unexpected impl self type of impl: {:?} {:?}\", item.owner_id, self_ty);\n             }\n             ty::Error(_) => {}\n         }"}, {"sha": "972769eb1970735f7736ddf7168f94ac51072fa8", "filename": "compiler/rustc_hir_analysis/src/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Finherent_impls_overlap.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -156,14 +156,14 @@ impl<'tcx> InherentOverlapChecker<'tcx> {\n     }\n \n     fn check_item(&mut self, id: hir::ItemId) {\n-        let def_kind = self.tcx.def_kind(id.def_id);\n+        let def_kind = self.tcx.def_kind(id.owner_id);\n         if !matches!(def_kind, DefKind::Enum | DefKind::Struct | DefKind::Trait | DefKind::Union) {\n             return;\n         }\n \n-        let impls = self.tcx.inherent_impls(id.def_id);\n+        let impls = self.tcx.inherent_impls(id.owner_id);\n \n-        let overlap_mode = OverlapMode::get(self.tcx, id.def_id.to_def_id());\n+        let overlap_mode = OverlapMode::get(self.tcx, id.owner_id.to_def_id());\n \n         let impls_items = impls\n             .iter()"}, {"sha": "bb45c3823d839cb33d238c3c96c308fd00778be9", "filename": "compiler/rustc_hir_analysis/src/coherence/orphan.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Forphan.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -101,7 +101,7 @@ fn do_orphan_check_impl<'tcx>(\n         span_bug!(sp, \"opaque type not found, but `has_opaque_types` is set\")\n     }\n \n-    match traits::orphan_check(tcx, item.def_id.to_def_id()) {\n+    match traits::orphan_check(tcx, item.owner_id.to_def_id()) {\n         Ok(()) => {}\n         Err(err) => emit_orphan_check_error(\n             tcx,"}, {"sha": "a34815b45b3adeb7834cc163c66bbd5cbc7257fc", "filename": "compiler/rustc_hir_analysis/src/coherence/unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Funsafety.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -13,7 +13,7 @@ pub(super) fn check_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n     let item = tcx.hir().expect_item(def_id);\n     let hir::ItemKind::Impl(ref impl_) = item.kind else { bug!() };\n \n-    if let Some(trait_ref) = tcx.impl_trait_ref(item.def_id) {\n+    if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n         let trait_def = tcx.trait_def(trait_ref.def_id);\n         let unsafe_attr =\n             impl_.generics.params.iter().find(|p| p.pure_wrt_drop).map(|_| \"may_dangle\");"}, {"sha": "346d2e2fc4b18cb2a8c862cbeb0966d08e1ead30", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -571,7 +571,7 @@ fn get_new_lifetime_name<'tcx>(\n fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n     let it = tcx.hir().item(item_id);\n     debug!(\"convert: item {} with id {}\", it.ident, it.hir_id());\n-    let def_id = item_id.def_id.def_id;\n+    let def_id = item_id.owner_id.def_id;\n \n     match it.kind {\n         // These don't define types.\n@@ -583,11 +583,11 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n         hir::ItemKind::ForeignMod { items, .. } => {\n             for item in items {\n                 let item = tcx.hir().foreign_item(item.id);\n-                tcx.ensure().generics_of(item.def_id);\n-                tcx.ensure().type_of(item.def_id);\n-                tcx.ensure().predicates_of(item.def_id);\n+                tcx.ensure().generics_of(item.owner_id);\n+                tcx.ensure().type_of(item.owner_id);\n+                tcx.ensure().predicates_of(item.owner_id);\n                 match item.kind {\n-                    hir::ForeignItemKind::Fn(..) => tcx.ensure().fn_sig(item.def_id),\n+                    hir::ForeignItemKind::Fn(..) => tcx.ensure().fn_sig(item.owner_id),\n                     hir::ForeignItemKind::Static(..) => {\n                         let mut visitor = HirPlaceholderCollector::default();\n                         visitor.visit_foreign_item(item);\n@@ -683,7 +683,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n \n fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n     let trait_item = tcx.hir().trait_item(trait_item_id);\n-    let def_id = trait_item_id.def_id;\n+    let def_id = trait_item_id.owner_id;\n     tcx.ensure().generics_of(def_id);\n \n     match trait_item.kind {\n@@ -730,7 +730,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n }\n \n fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n-    let def_id = impl_item_id.def_id;\n+    let def_id = impl_item_id.owner_id;\n     tcx.ensure().generics_of(def_id);\n     tcx.ensure().type_of(def_id);\n     tcx.ensure().predicates_of(def_id);\n@@ -1010,7 +1010,7 @@ fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n \n                 match item {\n                     Some(item) if matches!(item.kind, hir::AssocItemKind::Fn { .. }) => {\n-                        if !tcx.impl_defaultness(item.id.def_id).has_value() {\n+                        if !tcx.impl_defaultness(item.id.owner_id).has_value() {\n                             tcx.sess\n                                 .struct_span_err(\n                                     item.span,"}, {"sha": "3f263a6de24ead04dc1cbaadf4d2a808d57bac12", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -331,8 +331,8 @@ fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetime\n /// `resolve_lifetimes`.\n fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: hir::OwnerId) -> &'tcx ResolveLifetimes {\n     let item_id = item_for(tcx, def_id.def_id);\n-    let local_def_id = item_id.def_id.def_id;\n-    if item_id.def_id == def_id {\n+    let local_def_id = item_id.owner_id.def_id;\n+    if item_id.owner_id == def_id {\n         let item = tcx.hir().item(item_id);\n         match item.kind {\n             hir::ItemKind::Trait(..) => tcx.resolve_lifetimes_trait_definition(local_def_id),\n@@ -557,11 +557,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 // their owner, we can keep going until we find the Item that owns that. We then\n                 // conservatively add all resolved lifetimes. Otherwise we run into problems in\n                 // cases like `type Foo<'a> = impl Bar<As = impl Baz + 'a>`.\n-                for (_hir_id, node) in self.tcx.hir().parent_iter(item.def_id.into()) {\n+                for (_hir_id, node) in self.tcx.hir().parent_iter(item.owner_id.into()) {\n                     match node {\n                         hir::Node::Item(parent_item) => {\n                             let resolved_lifetimes: &ResolveLifetimes = self.tcx.resolve_lifetimes(\n-                                item_for(self.tcx, parent_item.def_id.def_id).def_id.def_id,\n+                                item_for(self.tcx, parent_item.owner_id.def_id).owner_id.def_id,\n                             );\n                             // We need to add *all* deps, since opaque tys may want them from *us*\n                             for (&owner, defs) in resolved_lifetimes.defs.iter() {"}, {"sha": "c29a645eb4a888332f961c500e07d5b7c58d0b11", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -643,24 +643,24 @@ fn find_opaque_ty_constraints_for_tait(tcx: TyCtxt<'_>, def_id: LocalDefId) -> T\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.def_id);\n-            self.check(it.def_id.def_id);\n+            trace!(?it.owner_id);\n+            self.check(it.owner_id.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n     }\n@@ -778,24 +778,24 @@ fn find_opaque_ty_constraints_for_rpit(\n             intravisit::walk_expr(self, ex);\n         }\n         fn visit_item(&mut self, it: &'tcx Item<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_item(self, it);\n             }\n         }\n         fn visit_impl_item(&mut self, it: &'tcx ImplItem<'tcx>) {\n-            trace!(?it.def_id);\n+            trace!(?it.owner_id);\n             // The opaque type itself or its children are not within its reveal scope.\n-            if it.def_id.def_id != self.def_id {\n-                self.check(it.def_id.def_id);\n+            if it.owner_id.def_id != self.def_id {\n+                self.check(it.owner_id.def_id);\n                 intravisit::walk_impl_item(self, it);\n             }\n         }\n         fn visit_trait_item(&mut self, it: &'tcx TraitItem<'tcx>) {\n-            trace!(?it.def_id);\n-            self.check(it.def_id.def_id);\n+            trace!(?it.owner_id);\n+            self.check(it.owner_id.def_id);\n             intravisit::walk_trait_item(self, it);\n         }\n     }"}, {"sha": "136f6199911a0eeb9ba7ac07032bf630df2eef6a", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -55,10 +55,10 @@ fn check_mod_impl_wf(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n     let min_specialization = tcx.features().min_specialization;\n     let module = tcx.hir_module_items(module_def_id);\n     for id in module.items() {\n-        if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n-            enforce_impl_params_are_constrained(tcx, id.def_id.def_id);\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+            enforce_impl_params_are_constrained(tcx, id.owner_id.def_id);\n             if min_specialization {\n-                check_min_specialization(tcx, id.def_id.def_id);\n+                check_min_specialization(tcx, id.owner_id.def_id);\n             }\n         }\n     }"}, {"sha": "525cd24190a4c920db4a1fc0030ba56c31c54f18", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -381,7 +381,7 @@ fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: DefId) {\n                         error = true;\n                     }\n                     if let hir::IsAsync::Async = sig.header.asyncness {\n-                        let span = tcx.def_span(it.def_id);\n+                        let span = tcx.def_span(it.owner_id);\n                         struct_span_err!(\n                             tcx.sess,\n                             span,"}, {"sha": "90c6edb65e46faa6aac8214fb3587c9abd5a5723", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -29,7 +29,7 @@ pub(super) fn infer_predicates<'tcx>(\n \n         // Visit all the crates and infer predicates\n         for id in tcx.hir().items() {\n-            let item_did = id.def_id;\n+            let item_did = id.owner_id;\n \n             debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n "}, {"sha": "fa2ac56593bcf5c38d685bdf9023b60be02f626e", "filename": "compiler/rustc_hir_analysis/src/outlives/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Ftest.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -6,11 +6,11 @@ pub fn test_inferred_outlives(tcx: TyCtxt<'_>) {\n     for id in tcx.hir().items() {\n         // For unit testing: check for a special \"rustc_outlives\"\n         // attribute and report an error with various results if found.\n-        if tcx.has_attr(id.def_id.to_def_id(), sym::rustc_outlives) {\n-            let inferred_outlives_of = tcx.inferred_outlives_of(id.def_id);\n+        if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_outlives) {\n+            let inferred_outlives_of = tcx.inferred_outlives_of(id.owner_id);\n             struct_span_err!(\n                 tcx.sess,\n-                tcx.def_span(id.def_id),\n+                tcx.def_span(id.owner_id),\n                 E0640,\n                 \"{:?}\",\n                 inferred_outlives_of"}, {"sha": "83ed3e44b3d733ca28477c985a4674c1eb201041", "filename": "compiler/rustc_hir_analysis/src/variance/test.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Ftest.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -6,9 +6,10 @@ pub fn test_variance(tcx: TyCtxt<'_>) {\n     // For unit testing: check for a special \"rustc_variance\"\n     // attribute and report an error with various results if found.\n     for id in tcx.hir().items() {\n-        if tcx.has_attr(id.def_id.to_def_id(), sym::rustc_variance) {\n-            let variances_of = tcx.variances_of(id.def_id);\n-            struct_span_err!(tcx.sess, tcx.def_span(id.def_id), E0208, \"{:?}\", variances_of).emit();\n+        if tcx.has_attr(id.owner_id.to_def_id(), sym::rustc_variance) {\n+            let variances_of = tcx.variances_of(id.owner_id);\n+            struct_span_err!(tcx.sess, tcx.def_span(id.owner_id), E0208, \"{:?}\", variances_of)\n+                .emit();\n         }\n     }\n }"}, {"sha": "d1dab0540be956087c2236fa649818272eb1c251", "filename": "compiler/rustc_hir_typeck/src/cast.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcast.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -869,7 +869,13 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n \n             (Int(_) | Float, Int(_) | Float) => Ok(CastKind::NumericCast),\n \n-            (_, DynStar) | (DynStar, _) => bug!(\"should be handled by `try_coerce`\"),\n+            (_, DynStar) | (DynStar, _) => {\n+                if fcx.tcx.features().dyn_star {\n+                    bug!(\"should be handled by `try_coerce`\")\n+                } else {\n+                    Err(CastError::IllegalCast)\n+                }\n+            }\n         }\n     }\n "}, {"sha": "16febfc46da902ae3333a2bce5ab8add720ac206", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -530,24 +530,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         hir_id: hir::HirId,\n     ) -> Vec<AssocItem> {\n-        let mut methods =\n-            self.probe_for_return_type(span, probe::Mode::MethodCall, expected, checked_ty, hir_id);\n-        methods.retain(|m| {\n-            self.has_only_self_parameter(m)\n-                && self\n-                    .tcx\n-                    // This special internal attribute is used to permit\n-                    // \"identity-like\" conversion methods to be suggested here.\n-                    //\n-                    // FIXME (#46459 and #46460): ideally\n-                    // `std::convert::Into::into` and `std::borrow:ToOwned` would\n-                    // also be `#[rustc_conversion_suggestion]`, if not for\n-                    // method-probing false-positives and -negatives (respectively).\n-                    //\n-                    // FIXME? Other potential candidate methods: `as_ref` and\n-                    // `as_mut`?\n-                    .has_attr(m.def_id, sym::rustc_conversion_suggestion)\n-        });\n+        let methods = self.probe_for_return_type(\n+            span,\n+            probe::Mode::MethodCall,\n+            expected,\n+            checked_ty,\n+            hir_id,\n+            |m| {\n+                self.has_only_self_parameter(m)\n+                    && self\n+                        .tcx\n+                        // This special internal attribute is used to permit\n+                        // \"identity-like\" conversion methods to be suggested here.\n+                        //\n+                        // FIXME (#46459 and #46460): ideally\n+                        // `std::convert::Into::into` and `std::borrow:ToOwned` would\n+                        // also be `#[rustc_conversion_suggestion]`, if not for\n+                        // method-probing false-positives and -negatives (respectively).\n+                        //\n+                        // FIXME? Other potential candidate methods: `as_ref` and\n+                        // `as_mut`?\n+                        .has_attr(m.def_id, sym::rustc_conversion_suggestion)\n+            },\n+        );\n \n         methods\n     }"}, {"sha": "28aa2302f882f92a03e4aaea45318f32c2046942", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -252,14 +252,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// would result in an error (basically, the same criteria we\n     /// would use to decide if a method is a plausible fit for\n     /// ambiguity purposes).\n-    #[instrument(level = \"debug\", skip(self))]\n+    #[instrument(level = \"debug\", skip(self, candidate_filter))]\n     pub fn probe_for_return_type(\n         &self,\n         span: Span,\n         mode: Mode,\n         return_type: Ty<'tcx>,\n         self_ty: Ty<'tcx>,\n         scope_expr_id: hir::HirId,\n+        candidate_filter: impl Fn(&ty::AssocItem) -> bool,\n     ) -> Vec<ty::AssocItem> {\n         let method_names = self\n             .probe_op(\n@@ -271,7 +272,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self_ty,\n                 scope_expr_id,\n                 ProbeScope::AllTraits,\n-                |probe_cx| Ok(probe_cx.candidate_method_names()),\n+                |probe_cx| Ok(probe_cx.candidate_method_names(candidate_filter)),\n             )\n             .unwrap_or_default();\n         method_names\n@@ -966,12 +967,16 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn candidate_method_names(&self) -> Vec<Ident> {\n+    fn candidate_method_names(\n+        &self,\n+        candidate_filter: impl Fn(&ty::AssocItem) -> bool,\n+    ) -> Vec<Ident> {\n         let mut set = FxHashSet::default();\n         let mut names: Vec<_> = self\n             .inherent_candidates\n             .iter()\n             .chain(&self.extension_candidates)\n+            .filter(|candidate| candidate_filter(&candidate.item))\n             .filter(|candidate| {\n                 if let Some(return_ty) = self.return_type {\n                     self.matches_return_type(&candidate.item, None, return_ty)\n@@ -1689,7 +1694,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             pcx.allow_similar_names = true;\n             pcx.assemble_inherent_candidates();\n \n-            let method_names = pcx.candidate_method_names();\n+            let method_names = pcx.candidate_method_names(|_| true);\n             pcx.allow_similar_names = false;\n             let applicable_close_candidates: Vec<ty::AssocItem> = method_names\n                 .iter()"}, {"sha": "79e2d371ed37394c8a3e549a3d9be616452fe541", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -149,19 +149,19 @@ pub fn check_dirty_clean_annotations(tcx: TyCtxt<'_>) {\n         let crate_items = tcx.hir_crate_items(());\n \n         for id in crate_items.items() {\n-            dirty_clean_visitor.check_item(id.def_id.def_id);\n+            dirty_clean_visitor.check_item(id.owner_id.def_id);\n         }\n \n         for id in crate_items.trait_items() {\n-            dirty_clean_visitor.check_item(id.def_id.def_id);\n+            dirty_clean_visitor.check_item(id.owner_id.def_id);\n         }\n \n         for id in crate_items.impl_items() {\n-            dirty_clean_visitor.check_item(id.def_id.def_id);\n+            dirty_clean_visitor.check_item(id.owner_id.def_id);\n         }\n \n         for id in crate_items.foreign_items() {\n-            dirty_clean_visitor.check_item(id.def_id.def_id);\n+            dirty_clean_visitor.check_item(id.owner_id.def_id);\n         }\n \n         let mut all_attrs = FindAllAttrs { tcx, found_attrs: vec![] };"}, {"sha": "9bf755d7fcdf974855b4ac88687c671cd00669e7", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -306,7 +306,7 @@ pub fn suggest_new_region_bound(\n                 };\n \n                 // Get the identity type for this RPIT\n-                let did = item_id.def_id.to_def_id();\n+                let did = item_id.owner_id.to_def_id();\n                 let ty = tcx.mk_opaque(did, ty::InternalSubsts::identity_for_item(tcx, did));\n \n                 if let Some(span) = opaque"}, {"sha": "4c236c693d0feafed883e1dd2365ec050e58892b", "filename": "compiler/rustc_interface/src/proc_macro_decls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fproc_macro_decls.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -9,7 +9,7 @@ fn proc_macro_decls_static(tcx: TyCtxt<'_>, (): ()) -> Option<LocalDefId> {\n     for id in tcx.hir().items() {\n         let attrs = finder.tcx.hir().attrs(id.hir_id());\n         if finder.tcx.sess.contains_name(attrs, sym::rustc_proc_macro_decls) {\n-            finder.decls = Some(id.def_id.def_id);\n+            finder.decls = Some(id.owner_id.def_id);\n         }\n     }\n "}, {"sha": "d425adf47f06c10064d872790233d63d983dc4d1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -177,7 +177,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxPointers {\n             | hir::ItemKind::Enum(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Union(..) => {\n-                self.check_heap_type(cx, it.span, cx.tcx.type_of(it.def_id))\n+                self.check_heap_type(cx, it.span, cx.tcx.type_of(it.owner_id))\n             }\n             _ => (),\n         }\n@@ -606,9 +606,9 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         match it.kind {\n             hir::ItemKind::Trait(..) => {\n                 // Issue #11592: traits are always considered exported, even when private.\n-                if cx.tcx.visibility(it.def_id)\n+                if cx.tcx.visibility(it.owner_id)\n                     == ty::Visibility::Restricted(\n-                        cx.tcx.parent_module_from_def_id(it.def_id.def_id).to_def_id(),\n+                        cx.tcx.parent_module_from_def_id(it.owner_id.def_id).to_def_id(),\n                     )\n                 {\n                     return;\n@@ -627,15 +627,15 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             _ => return,\n         };\n \n-        let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(it.owner_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, it.def_id.def_id, article, desc);\n+        self.check_missing_docs_attrs(cx, it.owner_id.def_id, article, desc);\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, trait_item: &hir::TraitItem<'_>) {\n-        let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(trait_item.owner_id.to_def_id());\n \n-        self.check_missing_docs_attrs(cx, trait_item.def_id.def_id, article, desc);\n+        self.check_missing_docs_attrs(cx, trait_item.owner_id.def_id, article, desc);\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n@@ -662,13 +662,13 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             }\n         }\n \n-        let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, impl_item.def_id.def_id, article, desc);\n+        let (article, desc) = cx.tcx.article_and_description(impl_item.owner_id.to_def_id());\n+        self.check_missing_docs_attrs(cx, impl_item.owner_id.def_id, article, desc);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'_>) {\n-        let (article, desc) = cx.tcx.article_and_description(foreign_item.def_id.to_def_id());\n-        self.check_missing_docs_attrs(cx, foreign_item.def_id.def_id, article, desc);\n+        let (article, desc) = cx.tcx.article_and_description(foreign_item.owner_id.to_def_id());\n+        self.check_missing_docs_attrs(cx, foreign_item.owner_id.def_id, article, desc);\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, sf: &hir::FieldDef<'_>) {\n@@ -721,29 +721,29 @@ declare_lint_pass!(MissingCopyImplementations => [MISSING_COPY_IMPLEMENTATIONS])\n \n impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.effective_visibilities.is_reachable(item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_reachable(item.owner_id.def_id) {\n             return;\n         }\n         let (def, ty) = match item.kind {\n             hir::ItemKind::Struct(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(item.def_id);\n+                let def = cx.tcx.adt_def(item.owner_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Union(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(item.def_id);\n+                let def = cx.tcx.adt_def(item.owner_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             hir::ItemKind::Enum(_, ref ast_generics) => {\n                 if !ast_generics.params.is_empty() {\n                     return;\n                 }\n-                let def = cx.tcx.adt_def(item.def_id);\n+                let def = cx.tcx.adt_def(item.owner_id);\n                 (def, cx.tcx.mk_adt(def, cx.tcx.intern_substs(&[])))\n             }\n             _ => return,\n@@ -752,7 +752,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingCopyImplementations {\n             return;\n         }\n         let param_env = ty::ParamEnv::empty();\n-        if ty.is_copy_modulo_regions(cx.tcx.at(item.span), param_env) {\n+        if ty.is_copy_modulo_regions(cx.tcx, param_env) {\n             return;\n         }\n         if can_type_implement_copy(\n@@ -814,7 +814,7 @@ impl_lint_pass!(MissingDebugImplementations => [MISSING_DEBUG_IMPLEMENTATIONS]);\n \n impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &hir::Item<'_>) {\n-        if !cx.effective_visibilities.is_reachable(item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_reachable(item.owner_id.def_id) {\n             return;\n         }\n \n@@ -841,7 +841,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             debug!(\"{:?}\", self.impling_types);\n         }\n \n-        if !self.impling_types.as_ref().unwrap().contains(&item.def_id.def_id) {\n+        if !self.impling_types.as_ref().unwrap().contains(&item.owner_id.def_id) {\n             cx.struct_span_lint(\n                 MISSING_DEBUG_IMPLEMENTATIONS,\n                 item.span,\n@@ -1226,7 +1226,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                             check_no_mangle_on_generic_fn(\n                                 no_mangle_attr,\n                                 Some(generics),\n-                                cx.tcx.hir().get_generics(it.id.def_id.def_id).unwrap(),\n+                                cx.tcx.hir().get_generics(it.id.owner_id.def_id).unwrap(),\n                                 it.span,\n                             );\n                         }\n@@ -1415,11 +1415,11 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n         if let hir::ItemKind::Use(_, hir::UseKind::ListStem) = &item.kind {\n             return;\n         }\n-        self.perform_lint(cx, \"item\", item.def_id.def_id, item.vis_span, true);\n+        self.perform_lint(cx, \"item\", item.owner_id.def_id, item.vis_span, true);\n     }\n \n     fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'tcx>) {\n-        self.perform_lint(cx, \"item\", foreign_item.def_id.def_id, foreign_item.vis_span, true);\n+        self.perform_lint(cx, \"item\", foreign_item.owner_id.def_id, foreign_item.vis_span, true);\n     }\n \n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n@@ -1429,8 +1429,8 @@ impl<'tcx> LateLintPass<'tcx> for UnreachablePub {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n         // Only lint inherent impl items.\n-        if cx.tcx.associated_item(impl_item.def_id).trait_item_def_id.is_none() {\n-            self.perform_lint(cx, \"item\", impl_item.def_id.def_id, impl_item.vis_span, false);\n+        if cx.tcx.associated_item(impl_item.owner_id).trait_item_def_id.is_none() {\n+            self.perform_lint(cx, \"item\", impl_item.owner_id.def_id, impl_item.vis_span, false);\n         }\n     }\n }\n@@ -1639,7 +1639,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n         use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n-            let predicates = cx.tcx.predicates_of(item.def_id);\n+            let predicates = cx.tcx.predicates_of(item.owner_id);\n             for &(predicate, span) in predicates.predicates {\n                 let predicate_kind_name = match predicate.kind().skip_binder() {\n                     Trait(..) => \"trait\",\n@@ -1882,7 +1882,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n             if let hir::ItemKind::Mod(..) = it.kind {\n             } else {\n                 self.items_nameable = false;\n-                self.boundary = Some(it.def_id);\n+                self.boundary = Some(it.owner_id);\n             }\n             return;\n         }\n@@ -1899,7 +1899,7 @@ impl<'tcx> LateLintPass<'tcx> for UnnameableTestItems {\n     }\n \n     fn check_item_post(&mut self, _cx: &LateContext<'_>, it: &hir::Item<'_>) {\n-        if !self.items_nameable && self.boundary == Some(it.def_id) {\n+        if !self.items_nameable && self.boundary == Some(it.owner_id) {\n             self.items_nameable = true;\n         }\n     }\n@@ -2165,7 +2165,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n         use rustc_middle::middle::resolve_lifetime::Region;\n \n-        let def_id = item.def_id.def_id;\n+        let def_id = item.owner_id.def_id;\n         if let hir::ItemKind::Struct(_, ref hir_generics)\n         | hir::ItemKind::Enum(_, ref hir_generics)\n         | hir::ItemKind::Union(_, ref hir_generics) = item.kind\n@@ -2744,7 +2744,7 @@ impl ClashingExternDeclarations {\n     /// Insert a new foreign item into the seen set. If a symbol with the same name already exists\n     /// for the item, return its HirId without updating the set.\n     fn insert(&mut self, tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> Option<HirId> {\n-        let did = fi.def_id.to_def_id();\n+        let did = fi.owner_id.to_def_id();\n         let instance = Instance::new(did, ty::List::identity_for_item(tcx, did));\n         let name = Symbol::intern(tcx.symbol_name(instance).name);\n         if let Some(&hir_id) = self.seen_decls.get(&name) {\n@@ -2762,14 +2762,14 @@ impl ClashingExternDeclarations {\n     /// symbol's name.\n     fn name_of_extern_decl(tcx: TyCtxt<'_>, fi: &hir::ForeignItem<'_>) -> SymbolName {\n         if let Some((overridden_link_name, overridden_link_name_span)) =\n-            tcx.codegen_fn_attrs(fi.def_id).link_name.map(|overridden_link_name| {\n+            tcx.codegen_fn_attrs(fi.owner_id).link_name.map(|overridden_link_name| {\n                 // FIXME: Instead of searching through the attributes again to get span\n                 // information, we could have codegen_fn_attrs also give span information back for\n                 // where the attribute was defined. However, until this is found to be a\n                 // bottleneck, this does just fine.\n                 (\n                     overridden_link_name,\n-                    tcx.get_attr(fi.def_id.to_def_id(), sym::link_name).unwrap().span,\n+                    tcx.get_attr(fi.owner_id.to_def_id(), sym::link_name).unwrap().span,\n                 )\n             })\n         {\n@@ -2986,10 +2986,10 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n             let tcx = cx.tcx;\n             if let Some(existing_hid) = self.insert(tcx, this_fi) {\n                 let existing_decl_ty = tcx.type_of(tcx.hir().local_def_id(existing_hid));\n-                let this_decl_ty = tcx.type_of(this_fi.def_id);\n+                let this_decl_ty = tcx.type_of(this_fi.owner_id);\n                 debug!(\n                     \"ClashingExternDeclarations: Comparing existing {:?}: {:?} to this {:?}: {:?}\",\n-                    existing_hid, existing_decl_ty, this_fi.def_id, this_decl_ty\n+                    existing_hid, existing_decl_ty, this_fi.owner_id, this_decl_ty\n                 );\n                 // Check that the declarations match.\n                 if !Self::structurally_same_type("}, {"sha": "00bf287ba6bdd9a49031dd3a61c7ca34b67aa49c", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -61,7 +61,7 @@ declare_lint_pass!(OpaqueHiddenInferredBound => [OPAQUE_HIDDEN_INFERRED_BOUND]);\n impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         let hir::ItemKind::OpaqueTy(_) = &item.kind else { return; };\n-        let def_id = item.def_id.def_id.to_def_id();\n+        let def_id = item.owner_id.def_id.to_def_id();\n         let infcx = &cx.tcx.infer_ctxt().build();\n         // For every projection predicate in the opaque type's explicit bounds,\n         // check that the type that we're assigning actually satisfies the bounds"}, {"sha": "f22f38aa2cea2abb832921555ca592e765ece362", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::PredicateKind::*;\n \n-        let predicates = cx.tcx.explicit_predicates_of(item.def_id);\n+        let predicates = cx.tcx.explicit_predicates_of(item.owner_id);\n         for &(predicate, span) in predicates.predicates {\n             let Trait(trait_predicate) = predicate.kind().skip_binder() else {\n                 continue"}, {"sha": "37caab2da0f5b0e61e6f618882b1ba40cfae6e86", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -11,7 +11,7 @@ use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, AdtKind, DefIdTree, Ty, TyCtxt, TypeSuperVisitable, TypeVisitable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n-use rustc_span::{Span, Symbol, DUMMY_SP};\n+use rustc_span::{Span, Symbol};\n use rustc_target::abi::{Abi, WrappingRange};\n use rustc_target::abi::{Integer, TagEncoding, Variants};\n use rustc_target::spec::abi::Abi as SpecAbi;\n@@ -931,7 +931,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n         match *ty.kind() {\n             ty::Adt(def, substs) => {\n                 if def.is_box() && matches!(self.mode, CItemKind::Definition) {\n-                    if ty.boxed_ty().is_sized(tcx.at(DUMMY_SP), self.cx.param_env) {\n+                    if ty.boxed_ty().is_sized(tcx, self.cx.param_env) {\n                         return FfiSafe;\n                     } else {\n                         return FfiUnsafe {\n@@ -1082,7 +1082,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) | ty::Ref(_, ty, _)\n                 if {\n                     matches!(self.mode, CItemKind::Definition)\n-                        && ty.is_sized(self.cx.tcx.at(DUMMY_SP), self.cx.param_env)\n+                        && ty.is_sized(self.cx.tcx, self.cx.param_env)\n                 } =>\n             {\n                 FfiSafe\n@@ -1360,7 +1360,7 @@ declare_lint_pass!(VariantSizeDifferences => [VARIANT_SIZE_DIFFERENCES]);\n impl<'tcx> LateLintPass<'tcx> for VariantSizeDifferences {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &hir::Item<'_>) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.kind {\n-            let t = cx.tcx.type_of(it.def_id);\n+            let t = cx.tcx.type_of(it.owner_id);\n             let ty = cx.tcx.erase_regions(t);\n             let Ok(layout) = cx.layout_of(ty) else { return };\n             let Variants::Multiple {"}, {"sha": "d1c2f3104d072a34feb9806f5d468f1df136cbf7", "filename": "compiler/rustc_metadata/src/foreign_modules.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fforeign_modules.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -6,13 +6,13 @@ use rustc_session::cstore::ForeignModule;\n pub(crate) fn collect(tcx: TyCtxt<'_>) -> Vec<ForeignModule> {\n     let mut modules = Vec::new();\n     for id in tcx.hir().items() {\n-        if !matches!(tcx.def_kind(id.def_id), DefKind::ForeignMod) {\n+        if !matches!(tcx.def_kind(id.owner_id), DefKind::ForeignMod) {\n             continue;\n         }\n         let item = tcx.hir().item(id);\n         if let hir::ItemKind::ForeignMod { items, .. } = item.kind {\n-            let foreign_items = items.iter().map(|it| it.id.def_id.to_def_id()).collect();\n-            modules.push(ForeignModule { foreign_items, def_id: id.def_id.to_def_id() });\n+            let foreign_items = items.iter().map(|it| it.id.owner_id.to_def_id()).collect();\n+            modules.push(ForeignModule { foreign_items, def_id: id.owner_id.to_def_id() });\n         }\n     }\n     modules"}, {"sha": "20a2e78299aed0bb49dbe047f3befefc65e58046", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -98,7 +98,7 @@ struct Collector<'tcx> {\n \n impl<'tcx> Collector<'tcx> {\n     fn process_item(&mut self, id: rustc_hir::ItemId) {\n-        if !matches!(self.tcx.def_kind(id.def_id), DefKind::ForeignMod) {\n+        if !matches!(self.tcx.def_kind(id.owner_id), DefKind::ForeignMod) {\n             return;\n         }\n \n@@ -372,17 +372,17 @@ impl<'tcx> Collector<'tcx> {\n                 }\n                 _ => {\n                     for child_item in foreign_mod_items {\n-                        if self.tcx.def_kind(child_item.id.def_id).has_codegen_attrs()\n+                        if self.tcx.def_kind(child_item.id.owner_id).has_codegen_attrs()\n                             && self\n                                 .tcx\n-                                .codegen_fn_attrs(child_item.id.def_id)\n+                                .codegen_fn_attrs(child_item.id.owner_id)\n                                 .link_ordinal\n                                 .is_some()\n                         {\n                             let link_ordinal_attr = self\n                                 .tcx\n                                 .hir()\n-                                .attrs(child_item.id.def_id.into())\n+                                .attrs(child_item.id.owner_id.into())\n                                 .iter()\n                                 .find(|a| a.has_name(sym::link_ordinal))\n                                 .unwrap();\n@@ -402,7 +402,7 @@ impl<'tcx> Collector<'tcx> {\n                 filename,\n                 kind,\n                 cfg,\n-                foreign_module: Some(it.def_id.to_def_id()),\n+                foreign_module: Some(it.owner_id.to_def_id()),\n                 wasm_import_module: wasm_import_module.map(|(name, _)| name),\n                 verbatim,\n                 dll_imports,\n@@ -505,7 +505,7 @@ impl<'tcx> Collector<'tcx> {\n     fn i686_arg_list_size(&self, item: &hir::ForeignItemRef) -> usize {\n         let argument_types: &List<Ty<'_>> = self.tcx.erase_late_bound_regions(\n             self.tcx\n-                .type_of(item.id.def_id)\n+                .type_of(item.id.owner_id)\n                 .fn_sig(self.tcx)\n                 .inputs()\n                 .map_bound(|slice| self.tcx.mk_type_list(slice.iter())),\n@@ -557,7 +557,7 @@ impl<'tcx> Collector<'tcx> {\n             }\n         };\n \n-        let codegen_fn_attrs = self.tcx.codegen_fn_attrs(item.id.def_id);\n+        let codegen_fn_attrs = self.tcx.codegen_fn_attrs(item.id.owner_id);\n         let import_name_type = codegen_fn_attrs\n             .link_ordinal\n             .map_or(import_name_type, |ord| Some(PeImportNameType::Ordinal(ord)));\n@@ -567,7 +567,7 @@ impl<'tcx> Collector<'tcx> {\n             import_name_type,\n             calling_convention,\n             span: item.span,\n-            is_fn: self.tcx.def_kind(item.id.def_id).is_fn_like(),\n+            is_fn: self.tcx.def_kind(item.id.owner_id).is_fn_like(),\n         }\n     }\n }"}, {"sha": "049514ec7b240ab2fb0d6d83cb4b64ee94167a85", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -1290,21 +1290,21 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                         // from name resolution point of view.\n                         hir::ItemKind::ForeignMod { items, .. } => {\n                             for foreign_item in items {\n-                                yield foreign_item.id.def_id.def_id.local_def_index;\n+                                yield foreign_item.id.owner_id.def_id.local_def_index;\n                             }\n                         }\n                         // Only encode named non-reexport children, reexports are encoded\n                         // separately and unnamed items are not used by name resolution.\n                         hir::ItemKind::ExternCrate(..) => continue,\n                         hir::ItemKind::Struct(ref vdata, _) => {\n-                            yield item_id.def_id.def_id.local_def_index;\n+                            yield item_id.owner_id.def_id.local_def_index;\n                             // Encode constructors which take a separate slot in value namespace.\n                             if let Some(ctor_hir_id) = vdata.ctor_hir_id() {\n                                 yield tcx.hir().local_def_id(ctor_hir_id).local_def_index;\n                             }\n                         }\n-                        _ if tcx.def_key(item_id.def_id.to_def_id()).get_opt_name().is_some() => {\n-                            yield item_id.def_id.def_id.local_def_index;\n+                        _ if tcx.def_key(item_id.owner_id.to_def_id()).get_opt_name().is_some() => {\n+                            yield item_id.owner_id.def_id.local_def_index;\n                         }\n                         _ => continue,\n                     }\n@@ -1541,7 +1541,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 record!(self.tables.macro_definition[def_id] <- &*macro_def.body);\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                return self.encode_info_for_mod(item.def_id.def_id, m);\n+                return self.encode_info_for_mod(item.owner_id.def_id, m);\n             }\n             hir::ItemKind::OpaqueTy(..) => {\n                 self.encode_explicit_item_bounds(def_id);\n@@ -1673,7 +1673,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // normally in the visitor walk.\n         match item.kind {\n             hir::ItemKind::Enum(..) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n+                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n                 for (i, variant) in def.variants().iter_enumerated() {\n                     self.encode_enum_variant_info(def, i);\n \n@@ -1683,7 +1683,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Struct(ref struct_def, _) => {\n-                let def = self.tcx.adt_def(item.def_id.to_def_id());\n+                let def = self.tcx.adt_def(item.owner_id.to_def_id());\n                 // If the struct has a constructor, encode it.\n                 if let Some(ctor_hir_id) = struct_def.ctor_hir_id() {\n                     let ctor_def_id = self.tcx.hir().local_def_id(ctor_hir_id);\n@@ -1692,13 +1692,14 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             }\n             hir::ItemKind::Impl { .. } => {\n                 for &trait_item_def_id in\n-                    self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n+                    self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n                 {\n                     self.encode_info_for_impl_item(trait_item_def_id);\n                 }\n             }\n             hir::ItemKind::Trait(..) => {\n-                for &item_def_id in self.tcx.associated_item_def_ids(item.def_id.to_def_id()).iter()\n+                for &item_def_id in\n+                    self.tcx.associated_item_def_ids(item.owner_id.to_def_id()).iter()\n                 {\n                     self.encode_info_for_trait_item(item_def_id);\n                 }\n@@ -1939,8 +1940,8 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             FxHashMap::default();\n \n         for id in tcx.hir().items() {\n-            if matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n-                if let Some(trait_ref) = tcx.impl_trait_ref(id.def_id) {\n+            if matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n+                if let Some(trait_ref) = tcx.impl_trait_ref(id.owner_id) {\n                     let simplified_self_ty = fast_reject::simplify_type(\n                         self.tcx,\n                         trait_ref.self_ty(),\n@@ -1950,7 +1951,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     fx_hash_map\n                         .entry(trait_ref.def_id)\n                         .or_default()\n-                        .push((id.def_id.def_id.local_def_index, simplified_self_ty));\n+                        .push((id.owner_id.def_id.local_def_index, simplified_self_ty));\n                 }\n             }\n         }\n@@ -2091,12 +2092,12 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n         intravisit::walk_item(self, item);\n         match item.kind {\n             hir::ItemKind::ExternCrate(_) | hir::ItemKind::Use(..) => {} // ignore these\n-            _ => self.encode_info_for_item(item.def_id.to_def_id(), item),\n+            _ => self.encode_info_for_item(item.owner_id.to_def_id(), item),\n         }\n     }\n     fn visit_foreign_item(&mut self, ni: &'tcx hir::ForeignItem<'tcx>) {\n         intravisit::walk_foreign_item(self, ni);\n-        self.encode_info_for_foreign_item(ni.def_id.to_def_id(), ni);\n+        self.encode_info_for_foreign_item(ni.owner_id.to_def_id(), ni);\n     }\n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n         intravisit::walk_generics(self, generics);\n@@ -2315,8 +2316,8 @@ pub fn provide(providers: &mut Providers) {\n \n             let mut traits = Vec::new();\n             for id in tcx.hir().items() {\n-                if matches!(tcx.def_kind(id.def_id), DefKind::Trait | DefKind::TraitAlias) {\n-                    traits.push(id.def_id.to_def_id())\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::Trait | DefKind::TraitAlias) {\n+                    traits.push(id.owner_id.to_def_id())\n                 }\n             }\n "}, {"sha": "83a4d16d7a92578a40b5d3579a6132284a36e492", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -354,19 +354,19 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn item(self, id: ItemId) -> &'hir Item<'hir> {\n-        self.tcx.hir_owner(id.def_id).unwrap().node.expect_item()\n+        self.tcx.hir_owner(id.owner_id).unwrap().node.expect_item()\n     }\n \n     pub fn trait_item(self, id: TraitItemId) -> &'hir TraitItem<'hir> {\n-        self.tcx.hir_owner(id.def_id).unwrap().node.expect_trait_item()\n+        self.tcx.hir_owner(id.owner_id).unwrap().node.expect_trait_item()\n     }\n \n     pub fn impl_item(self, id: ImplItemId) -> &'hir ImplItem<'hir> {\n-        self.tcx.hir_owner(id.def_id).unwrap().node.expect_impl_item()\n+        self.tcx.hir_owner(id.owner_id).unwrap().node.expect_impl_item()\n     }\n \n     pub fn foreign_item(self, id: ForeignItemId) -> &'hir ForeignItem<'hir> {\n-        self.tcx.hir_owner(id.def_id).unwrap().node.expect_foreign_item()\n+        self.tcx.hir_owner(id.owner_id).unwrap().node.expect_foreign_item()\n     }\n \n     pub fn body(self, id: BodyId) -> &'hir Body<'hir> {\n@@ -1377,14 +1377,14 @@ impl<'hir> Visitor<'hir> for ItemCollector<'hir> {\n \n     fn visit_item(&mut self, item: &'hir Item<'hir>) {\n         if associated_body(Node::Item(item)).is_some() {\n-            self.body_owners.push(item.def_id.def_id);\n+            self.body_owners.push(item.owner_id.def_id);\n         }\n \n         self.items.push(item.item_id());\n \n         // Items that are modules are handled here instead of in visit_mod.\n         if let ItemKind::Mod(module) = &item.kind {\n-            self.submodules.push(item.def_id);\n+            self.submodules.push(item.owner_id);\n             // A module collector does not recurse inside nested modules.\n             if self.crate_collector {\n                 intravisit::walk_mod(self, module, item.hir_id());\n@@ -1413,7 +1413,7 @@ impl<'hir> Visitor<'hir> for ItemCollector<'hir> {\n \n     fn visit_trait_item(&mut self, item: &'hir TraitItem<'hir>) {\n         if associated_body(Node::TraitItem(item)).is_some() {\n-            self.body_owners.push(item.def_id.def_id);\n+            self.body_owners.push(item.owner_id.def_id);\n         }\n \n         self.trait_items.push(item.trait_item_id());\n@@ -1422,7 +1422,7 @@ impl<'hir> Visitor<'hir> for ItemCollector<'hir> {\n \n     fn visit_impl_item(&mut self, item: &'hir ImplItem<'hir>) {\n         if associated_body(Node::ImplItem(item)).is_some() {\n-            self.body_owners.push(item.def_id.def_id);\n+            self.body_owners.push(item.owner_id.def_id);\n         }\n \n         self.impl_items.push(item.impl_item_id());"}, {"sha": "1c6264ad036544e396a3f68016e4d47221f6068f", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -67,10 +67,10 @@ impl ModuleItems {\n     pub fn definitions(&self) -> impl Iterator<Item = LocalDefId> + '_ {\n         self.items\n             .iter()\n-            .map(|id| id.def_id.def_id)\n-            .chain(self.trait_items.iter().map(|id| id.def_id.def_id))\n-            .chain(self.impl_items.iter().map(|id| id.def_id.def_id))\n-            .chain(self.foreign_items.iter().map(|id| id.def_id.def_id))\n+            .map(|id| id.owner_id.def_id)\n+            .chain(self.trait_items.iter().map(|id| id.owner_id.def_id))\n+            .chain(self.impl_items.iter().map(|id| id.owner_id.def_id))\n+            .chain(self.foreign_items.iter().map(|id| id.owner_id.def_id))\n     }\n \n     pub fn par_items(&self, f: impl Fn(ItemId) + Send + Sync) {"}, {"sha": "15a24aa4ace512f1b453902ddca2e34d2033abab", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -81,7 +81,7 @@ impl<'tcx> MonoItem<'tcx> {\n             MonoItem::Fn(instance) => tcx.symbol_name(instance),\n             MonoItem::Static(def_id) => tcx.symbol_name(Instance::mono(tcx, def_id)),\n             MonoItem::GlobalAsm(item_id) => {\n-                SymbolName::new(tcx, &format!(\"global_asm_{:?}\", item_id.def_id))\n+                SymbolName::new(tcx, &format!(\"global_asm_{:?}\", item_id.owner_id))\n             }\n         }\n     }\n@@ -182,7 +182,7 @@ impl<'tcx> MonoItem<'tcx> {\n         match *self {\n             MonoItem::Fn(Instance { def, .. }) => def.def_id().as_local(),\n             MonoItem::Static(def_id) => def_id.as_local(),\n-            MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.def_id),\n+            MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.def_id),\n         }\n         .map(|def_id| tcx.def_span(def_id))\n     }\n@@ -373,7 +373,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                         }\n                     }\n                     MonoItem::Static(def_id) => def_id.as_local().map(Idx::index),\n-                    MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.def_id.index()),\n+                    MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.def_id.index()),\n                 },\n                 item.symbol_name(tcx),\n             )"}, {"sha": "4e6cdb786025e0bcd8f78e2d213e7b6758487476", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -872,9 +872,9 @@ fn foo(&self) -> Self::T { String::new() }\n                             // FIXME: account for returning some type in a trait fn impl that has\n                             // an assoc type as a return type (#72076).\n                             if let hir::Defaultness::Default { has_value: true } =\n-                                self.impl_defaultness(item.id.def_id)\n+                                self.impl_defaultness(item.id.owner_id)\n                             {\n-                                if self.type_of(item.id.def_id) == found {\n+                                if self.type_of(item.id.owner_id) == found {\n                                     diag.span_label(\n                                         item.span,\n                                         \"associated type defaults can't be assumed inside the \\\n@@ -894,7 +894,7 @@ fn foo(&self) -> Self::T { String::new() }\n             })) => {\n                 for item in &items[..] {\n                     if let hir::AssocItemKind::Type = item.kind {\n-                        if self.type_of(item.id.def_id) == found {\n+                        if self.type_of(item.id.owner_id) == found {\n                             diag.span_label(item.span, \"expected this associated type\");\n                             return true;\n                         }"}, {"sha": "3312f44c67b2a884319601a67df751396701b1f5", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -830,7 +830,7 @@ where\n                 } else {\n                     match mt {\n                         hir::Mutability::Not => {\n-                            if ty.is_freeze(tcx.at(DUMMY_SP), cx.param_env()) {\n+                            if ty.is_freeze(tcx, cx.param_env()) {\n                                 PointerKind::Frozen\n                             } else {\n                                 PointerKind::SharedMutable\n@@ -841,7 +841,7 @@ where\n                             // noalias, as another pointer to the structure can be obtained, that\n                             // is not based-on the original reference. We consider all !Unpin\n                             // types to be potentially self-referential here.\n-                            if ty.is_unpin(tcx.at(DUMMY_SP), cx.param_env()) {\n+                            if ty.is_unpin(tcx, cx.param_env()) {\n                                 PointerKind::UniqueBorrowed\n                             } else {\n                                 PointerKind::UniqueBorrowedPinned"}, {"sha": "ef9aa236bacfce7435126c5fd8933d2917ba9e6a", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -2740,7 +2740,7 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n     // Iterate all local crate items no matter where they are defined.\n     let hir = tcx.hir();\n     for id in hir.items() {\n-        if matches!(tcx.def_kind(id.def_id), DefKind::Use) {\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::Use) {\n             continue;\n         }\n \n@@ -2749,7 +2749,7 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n             continue;\n         }\n \n-        let def_id = item.def_id.to_def_id();\n+        let def_id = item.owner_id.to_def_id();\n         let ns = tcx.def_kind(def_id).ns().unwrap_or(Namespace::TypeNS);\n         collect_fn(&item.ident, ns, def_id);\n     }"}, {"sha": "f72e236eda1332cd4013315af28a120909cdfbfb", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -2,7 +2,6 @@\n \n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::ty::layout::IntegerExt;\n-use crate::ty::query::TyCtxtAt;\n use crate::ty::{\n     self, DefIdTree, FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeSuperFoldable,\n     TypeVisitable,\n@@ -821,12 +820,8 @@ impl<'tcx> Ty<'tcx> {\n     /// does copies even when the type actually doesn't satisfy the\n     /// full requirements for the `Copy` trait (cc #29149) -- this\n     /// winds up being reported as an error during NLL borrow check.\n-    pub fn is_copy_modulo_regions(\n-        self,\n-        tcx_at: TyCtxtAt<'tcx>,\n-        param_env: ty::ParamEnv<'tcx>,\n-    ) -> bool {\n-        self.is_trivially_pure_clone_copy() || tcx_at.is_copy_raw(param_env.and(self))\n+    pub fn is_copy_modulo_regions(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_pure_clone_copy() || tcx.is_copy_raw(param_env.and(self))\n     }\n \n     /// Checks whether values of this type `T` have a size known at\n@@ -835,8 +830,8 @@ impl<'tcx> Ty<'tcx> {\n     /// over-approximation in generic contexts, where one can have\n     /// strange rules like `<T as Foo<'static>>::Bar: Sized` that\n     /// actually carry lifetime requirements.\n-    pub fn is_sized(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        self.is_trivially_sized(tcx_at.tcx) || tcx_at.is_sized_raw(param_env.and(self))\n+    pub fn is_sized(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_sized(tcx) || tcx.is_sized_raw(param_env.and(self))\n     }\n \n     /// Checks whether values of this type `T` implement the `Freeze`\n@@ -846,8 +841,8 @@ impl<'tcx> Ty<'tcx> {\n     /// optimization as well as the rules around static values. Note\n     /// that the `Freeze` trait is not exposed to end users and is\n     /// effectively an implementation detail.\n-    pub fn is_freeze(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        self.is_trivially_freeze() || tcx_at.is_freeze_raw(param_env.and(self))\n+    pub fn is_freeze(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_freeze() || tcx.is_freeze_raw(param_env.and(self))\n     }\n \n     /// Fast path helper for testing if a type is `Freeze`.\n@@ -886,8 +881,8 @@ impl<'tcx> Ty<'tcx> {\n     }\n \n     /// Checks whether values of this type `T` implement the `Unpin` trait.\n-    pub fn is_unpin(self, tcx_at: TyCtxtAt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n-        self.is_trivially_unpin() || tcx_at.is_unpin_raw(param_env.and(self))\n+    pub fn is_unpin(self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n+        self.is_trivially_unpin() || tcx.is_unpin_raw(param_env.and(self))\n     }\n \n     /// Fast path helper for testing if a type is `Unpin`."}, {"sha": "c8610af7038d7f2c2b089cfbf1658055bd2d8115", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -153,12 +153,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         if tcx.features().unsized_fn_params {\n             let ty = expr.ty;\n-            let span = expr.span;\n             let param_env = this.param_env;\n \n-            if !ty.is_sized(tcx.at(span), param_env) {\n+            if !ty.is_sized(tcx, param_env) {\n                 // !sized means !copy, so this is an unsized move\n-                assert!(!ty.is_copy_modulo_regions(tcx.at(span), param_env));\n+                assert!(!ty.is_copy_modulo_regions(tcx, param_env));\n \n                 // As described above, detect the case where we are passing a value of unsized\n                 // type, and that value is coming from the deref of a box."}, {"sha": "fb1ea9ed300ad4f8c87a02d6c32718c614ceca21", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -260,7 +260,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                     };\n                     match borrow_kind {\n                         BorrowKind::Shallow | BorrowKind::Shared | BorrowKind::Unique => {\n-                            if !ty.is_freeze(self.tcx.at(pat.span), self.param_env) {\n+                            if !ty.is_freeze(self.tcx, self.param_env) {\n                                 self.requires_unsafe(pat.span, BorrowOfLayoutConstrainedField);\n                             }\n                         }\n@@ -457,9 +457,7 @@ impl<'a, 'tcx> Visitor<'a, 'tcx> for UnsafetyVisitor<'a, 'tcx> {\n                 if visitor.found {\n                     match borrow_kind {\n                         BorrowKind::Shallow | BorrowKind::Shared | BorrowKind::Unique\n-                            if !self.thir[arg]\n-                                .ty\n-                                .is_freeze(self.tcx.at(self.thir[arg].span), self.param_env) =>\n+                            if !self.thir[arg].ty.is_freeze(self.tcx, self.param_env) =>\n                         {\n                             self.requires_unsafe(expr.span, BorrowOfLayoutConstrainedField)\n                         }"}, {"sha": "858129c742dc672037333af168c1743f19b6d537", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -1004,8 +1004,8 @@ fn maybe_point_at_variant<'a, 'p: 'a, 'tcx: 'a>(\n }\n \n /// Check if a by-value binding is by-value. That is, check if the binding's type is not `Copy`.\n-fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId, span: Span) -> bool {\n-    !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx.at(span), cx.param_env)\n+fn is_binding_by_move(cx: &MatchVisitor<'_, '_, '_>, hir_id: HirId) -> bool {\n+    !cx.typeck_results.node_type(hir_id).is_copy_modulo_regions(cx.tcx, cx.param_env)\n }\n \n /// Check that there are no borrow or move conflicts in `binding @ subpat` patterns.\n@@ -1031,7 +1031,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n \n     // Get the binding move, extract the mutability if by-ref.\n     let mut_outer = match typeck_results.extract_binding_mode(sess, pat.hir_id, pat.span) {\n-        Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id, pat.span) => {\n+        Some(ty::BindByValue(_)) if is_binding_by_move(cx, pat.hir_id) => {\n             // We have `x @ pat` where `x` is by-move. Reject all borrows in `pat`.\n             let mut conflicts_ref = Vec::new();\n             sub.each_binding(|_, hir_id, span, _| {\n@@ -1070,7 +1070,7 @@ fn check_borrow_conflicts_in_at_patterns(cx: &MatchVisitor<'_, '_, '_>, pat: &Pa\n                 (Mutability::Mut, Mutability::Mut) => conflicts_mut_mut.push((span, name)), // 2x `ref mut`.\n                 _ => conflicts_mut_ref.push((span, name)), // `ref` + `ref mut` in either direction.\n             },\n-            Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id, span) => {\n+            Some(ty::BindByValue(_)) if is_binding_by_move(cx, hir_id) => {\n                 conflicts_move.push((span, name)) // `ref mut?` + by-move conflict.\n             }\n             Some(ty::BindByValue(_)) | None => {} // `ref mut?` + by-copy is fine."}, {"sha": "ad12e011621173c7ebd6866e494dec164d136126", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -506,7 +506,7 @@ impl<'tcx> ConstToPat<'tcx> {\n                 // convert the dereferenced constant to a pattern that is the sub-pattern of the\n                 // deref pattern.\n                 _ => {\n-                    if !pointee_ty.is_sized(tcx.at(span), param_env) {\n+                    if !pointee_ty.is_sized(tcx, param_env) {\n                         // `tcx.deref_mir_constant()` below will ICE with an unsized type\n                         // (except slices, which are handled in a separate arm above).\n                         let msg = format!(\"cannot use unsized non-slice type `{}` in constant patterns\", pointee_ty);\n@@ -534,7 +534,7 @@ impl<'tcx> ConstToPat<'tcx> {\n             ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::FnDef(..) => {\n                 PatKind::Constant { value: cv }\n             }\n-            ty::RawPtr(pointee) if pointee.ty.is_sized(tcx.at(span), param_env) => {\n+            ty::RawPtr(pointee) if pointee.ty.is_sized(tcx, param_env) => {\n                 PatKind::Constant { value: cv }\n             }\n             // FIXME: these can have very surprising behaviour where optimization levels or other"}, {"sha": "f8f04214a2ca55a34255d458455c6ffa04b44479", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -312,7 +312,7 @@ impl<'tcx> UnsafetyChecker<'_, 'tcx> {\n                             } else if !place\n                                 .ty(self.body, self.tcx)\n                                 .ty\n-                                .is_freeze(self.tcx.at(self.source_info.span), self.param_env)\n+                                .is_freeze(self.tcx, self.param_env)\n                             {\n                                 UnsafetyViolationDetails::BorrowOfLayoutConstrainedField\n                             } else {"}, {"sha": "4e4515888454b8a1038a583478ac845cbd868892", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -633,7 +633,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n         if !rvalue\n             .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n-            .is_sized(self.ecx.tcx, self.param_env)\n+            .is_sized(*self.ecx.tcx, self.param_env)\n         {\n             // the interpreter doesn't support unsized locals (only unsized arguments),\n             // but rustc does (in a kinda broken way), so we have to skip them here"}, {"sha": "479c4e577d4e3aad83e0098e3c18764cd654af67", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -500,7 +500,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n         if !rvalue\n             .ty(&self.ecx.frame().body.local_decls, *self.ecx.tcx)\n-            .is_sized(self.ecx.tcx, self.param_env)\n+            .is_sized(*self.ecx.tcx, self.param_env)\n         {\n             // the interpreter doesn't support unsized locals (only unsized arguments),\n             // but rustc does (in a kinda broken way), so we have to skip them here"}, {"sha": "28b1c5a48099bc9d8c14d9b1456b263ea568f531", "filename": "compiler/rustc_mir_transform/src/deduce_param_attrs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fdeduce_param_attrs.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -11,7 +11,6 @@ use rustc_middle::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::{Body, Local, Location, Operand, Terminator, TerminatorKind, RETURN_PLACE};\n use rustc_middle::ty::{self, DeducedParamAttrs, ParamEnv, Ty, TyCtxt};\n use rustc_session::config::OptLevel;\n-use rustc_span::DUMMY_SP;\n \n /// A visitor that determines which arguments have been mutated. We can't use the mutability field\n /// on LocalDecl for this because it has no meaning post-optimization.\n@@ -232,7 +231,7 @@ pub fn deduced_param_attrs<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx [Ded\n         body.local_decls.iter().skip(1).take(body.arg_count).enumerate().map(\n             |(arg_index, local_decl)| DeducedParamAttrs {\n                 read_only: !deduce_read_only.mutable_args.contains(arg_index)\n-                    && local_decl.ty.is_freeze(tcx.at(DUMMY_SP), ParamEnv::reveal_all()),\n+                    && local_decl.ty.is_freeze(tcx, ParamEnv::reveal_all()),\n             },\n         ),\n     );"}, {"sha": "4e8798b7a55d2a58c9680fae5a8c4329e2289ba4", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -312,7 +312,7 @@ fn build_clone_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, self_ty: Ty<'tcx>) -\n     let param_env = tcx.param_env(def_id);\n \n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n-    let is_copy = self_ty.is_copy_modulo_regions(tcx.at(builder.span), param_env);\n+    let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env);\n \n     let dest = Place::return_place();\n     let src = tcx.mk_place_deref(Place::from(Local::new(1 + 0)));"}, {"sha": "a71218e6997576bbff139ecbac5716b2f017f570", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -1067,7 +1067,7 @@ fn find_vtable_types_for_unsizing<'tcx>(\n     let ptr_vtable = |inner_source: Ty<'tcx>, inner_target: Ty<'tcx>| {\n         let param_env = ty::ParamEnv::reveal_all();\n         let type_has_metadata = |ty: Ty<'tcx>| -> bool {\n-            if ty.is_sized(tcx.at(DUMMY_SP), param_env) {\n+            if ty.is_sized(tcx, param_env) {\n                 return false;\n             }\n             let tail = tcx.struct_tail_erasing_lifetimes(ty, param_env);\n@@ -1192,7 +1192,7 @@ struct RootCollector<'a, 'tcx> {\n \n impl<'v> RootCollector<'_, 'v> {\n     fn process_item(&mut self, id: hir::ItemId) {\n-        match self.tcx.def_kind(id.def_id) {\n+        match self.tcx.def_kind(id.owner_id) {\n             DefKind::Enum | DefKind::Struct | DefKind::Union => {\n                 let item = self.tcx.hir().item(id);\n                 match item.kind {\n@@ -1203,12 +1203,14 @@ impl<'v> RootCollector<'_, 'v> {\n                             if self.mode == MonoItemCollectionMode::Eager {\n                                 debug!(\n                                     \"RootCollector: ADT drop-glue for {}\",\n-                                    self.tcx.def_path_str(item.def_id.to_def_id())\n+                                    self.tcx.def_path_str(item.owner_id.to_def_id())\n                                 );\n \n-                                let ty =\n-                                    Instance::new(item.def_id.to_def_id(), InternalSubsts::empty())\n-                                        .ty(self.tcx, ty::ParamEnv::reveal_all());\n+                                let ty = Instance::new(\n+                                    item.owner_id.to_def_id(),\n+                                    InternalSubsts::empty(),\n+                                )\n+                                .ty(self.tcx, ty::ParamEnv::reveal_all());\n                                 visit_drop_use(self.tcx, ty, true, DUMMY_SP, self.output);\n                             }\n                         }\n@@ -1219,23 +1221,23 @@ impl<'v> RootCollector<'_, 'v> {\n             DefKind::GlobalAsm => {\n                 debug!(\n                     \"RootCollector: ItemKind::GlobalAsm({})\",\n-                    self.tcx.def_path_str(id.def_id.to_def_id())\n+                    self.tcx.def_path_str(id.owner_id.to_def_id())\n                 );\n                 self.output.push(dummy_spanned(MonoItem::GlobalAsm(id)));\n             }\n             DefKind::Static(..) => {\n                 debug!(\n                     \"RootCollector: ItemKind::Static({})\",\n-                    self.tcx.def_path_str(id.def_id.to_def_id())\n+                    self.tcx.def_path_str(id.owner_id.to_def_id())\n                 );\n-                self.output.push(dummy_spanned(MonoItem::Static(id.def_id.to_def_id())));\n+                self.output.push(dummy_spanned(MonoItem::Static(id.owner_id.to_def_id())));\n             }\n             DefKind::Const => {\n                 // const items only generate mono items if they are\n                 // actually used somewhere. Just declaring them is insufficient.\n \n                 // but even just declaring them must collect the items they refer to\n-                if let Ok(val) = self.tcx.const_eval_poly(id.def_id.to_def_id()) {\n+                if let Ok(val) = self.tcx.const_eval_poly(id.owner_id.to_def_id()) {\n                     collect_const_value(self.tcx, val, &mut self.output);\n                 }\n             }\n@@ -1246,15 +1248,15 @@ impl<'v> RootCollector<'_, 'v> {\n                 }\n             }\n             DefKind::Fn => {\n-                self.push_if_root(id.def_id.def_id);\n+                self.push_if_root(id.owner_id.def_id);\n             }\n             _ => {}\n         }\n     }\n \n     fn process_impl_item(&mut self, id: hir::ImplItemId) {\n-        if matches!(self.tcx.def_kind(id.def_id), DefKind::AssocFn) {\n-            self.push_if_root(id.def_id.def_id);\n+        if matches!(self.tcx.def_kind(id.owner_id), DefKind::AssocFn) {\n+            self.push_if_root(id.owner_id.def_id);\n         }\n     }\n \n@@ -1352,13 +1354,13 @@ fn create_mono_items_for_default_impls<'tcx>(\n \n             debug!(\n                 \"create_mono_items_for_default_impls(item={})\",\n-                tcx.def_path_str(item.def_id.to_def_id())\n+                tcx.def_path_str(item.owner_id.to_def_id())\n             );\n \n-            if let Some(trait_ref) = tcx.impl_trait_ref(item.def_id) {\n+            if let Some(trait_ref) = tcx.impl_trait_ref(item.owner_id) {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let trait_ref = tcx.normalize_erasing_regions(param_env, trait_ref);\n-                let overridden_methods = tcx.impl_item_implementor_ids(item.def_id);\n+                let overridden_methods = tcx.impl_item_implementor_ids(item.owner_id);\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n                     if overridden_methods.contains_key(&method.def_id) {\n                         continue;"}, {"sha": "29009c48050e1b576e1c8ffe76c029f6378db6e5", "filename": "compiler/rustc_monomorphize/src/partitioning/default.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fdefault.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -319,7 +319,7 @@ fn characteristic_def_id_of_mono_item<'tcx>(\n             Some(def_id)\n         }\n         MonoItem::Static(def_id) => Some(def_id),\n-        MonoItem::GlobalAsm(item_id) => Some(item_id.def_id.to_def_id()),\n+        MonoItem::GlobalAsm(item_id) => Some(item_id.owner_id.to_def_id()),\n     }\n }\n \n@@ -411,9 +411,9 @@ fn mono_item_visibility<'tcx>(\n             };\n         }\n         MonoItem::GlobalAsm(item_id) => {\n-            return if tcx.is_reachable_non_generic(item_id.def_id) {\n+            return if tcx.is_reachable_non_generic(item_id.owner_id) {\n                 *can_be_internalized = false;\n-                default_visibility(tcx, item_id.def_id.to_def_id(), false)\n+                default_visibility(tcx, item_id.owner_id.to_def_id(), false)\n             } else {\n                 Visibility::Hidden\n             };"}, {"sha": "27a57adf964a30765ee67a9801b18e88d38e9ec6", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -2062,7 +2062,7 @@ impl<'tcx> Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n         // so this lets us continue to run them while maintaining backwards compatibility.\n         // In the long run, the checks should be harmonized.\n         if let ItemKind::Macro(ref macro_def, _) = item.kind {\n-            let def_id = item.def_id.to_def_id();\n+            let def_id = item.owner_id.to_def_id();\n             if macro_def.macro_rules && !self.tcx.has_attr(def_id, sym::macro_export) {\n                 check_non_exported_macro_for_invalid_attrs(self.tcx, item);\n             }"}, {"sha": "753d01f46cabdbec382c554d1278887171854841", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -280,8 +280,8 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     }\n \n     fn visit_node(&mut self, node: Node<'tcx>) {\n-        if let Node::ImplItem(hir::ImplItem { def_id, .. }) = node\n-            && self.should_ignore_item(def_id.to_def_id())\n+        if let Node::ImplItem(hir::ImplItem { owner_id, .. }) = node\n+            && self.should_ignore_item(owner_id.to_def_id())\n         {\n             return;\n         }\n@@ -293,7 +293,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n         match node {\n             Node::Item(item) => match item.kind {\n                 hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n-                    let def = self.tcx.adt_def(item.def_id);\n+                    let def = self.tcx.adt_def(item.owner_id);\n                     self.repr_has_repr_c = def.repr().c();\n                     self.repr_has_repr_simd = def.repr().simd();\n \n@@ -306,7 +306,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                 intravisit::walk_trait_item(self, trait_item);\n             }\n             Node::ImplItem(impl_item) => {\n-                let item = self.tcx.local_parent(impl_item.def_id.def_id);\n+                let item = self.tcx.local_parent(impl_item.owner_id.def_id);\n                 if self.tcx.impl_trait_ref(item).is_none() {\n                     //// If it's a type whose items are live, then it's live, too.\n                     //// This is done to handle the case where, for example, the static\n@@ -517,10 +517,10 @@ fn check_item<'tcx>(\n ) {\n     let allow_dead_code = has_allow_dead_code_or_lang_attr(tcx, id.hir_id());\n     if allow_dead_code {\n-        worklist.push(id.def_id.def_id);\n+        worklist.push(id.owner_id.def_id);\n     }\n \n-    match tcx.def_kind(id.def_id) {\n+    match tcx.def_kind(id.owner_id) {\n         DefKind::Enum => {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::Enum(ref enum_def, _) = item.kind {\n@@ -540,15 +540,15 @@ fn check_item<'tcx>(\n             }\n         }\n         DefKind::Impl => {\n-            let of_trait = tcx.impl_trait_ref(id.def_id);\n+            let of_trait = tcx.impl_trait_ref(id.owner_id);\n \n             if of_trait.is_some() {\n-                worklist.push(id.def_id.def_id);\n+                worklist.push(id.owner_id.def_id);\n             }\n \n             // get DefIds from another query\n             let local_def_ids = tcx\n-                .associated_item_def_ids(id.def_id)\n+                .associated_item_def_ids(id.owner_id)\n                 .iter()\n                 .filter_map(|def_id| def_id.as_local());\n \n@@ -566,25 +566,25 @@ fn check_item<'tcx>(\n             if let hir::ItemKind::Struct(ref variant_data, _) = item.kind\n                 && let Some(ctor_hir_id) = variant_data.ctor_hir_id()\n             {\n-                struct_constructors.insert(tcx.hir().local_def_id(ctor_hir_id), item.def_id.def_id);\n+                struct_constructors.insert(tcx.hir().local_def_id(ctor_hir_id), item.owner_id.def_id);\n             }\n         }\n         DefKind::GlobalAsm => {\n             // global_asm! is always live.\n-            worklist.push(id.def_id.def_id);\n+            worklist.push(id.owner_id.def_id);\n         }\n         _ => {}\n     }\n }\n \n fn check_trait_item<'tcx>(tcx: TyCtxt<'tcx>, worklist: &mut Vec<LocalDefId>, id: hir::TraitItemId) {\n     use hir::TraitItemKind::{Const, Fn};\n-    if matches!(tcx.def_kind(id.def_id), DefKind::AssocConst | DefKind::AssocFn) {\n+    if matches!(tcx.def_kind(id.owner_id), DefKind::AssocConst | DefKind::AssocFn) {\n         let trait_item = tcx.hir().trait_item(id);\n         if matches!(trait_item.kind, Const(_, Some(_)) | Fn(_, hir::TraitFn::Provided(_)))\n             && has_allow_dead_code_or_lang_attr(tcx, trait_item.hir_id())\n         {\n-            worklist.push(trait_item.def_id.def_id);\n+            worklist.push(trait_item.owner_id.def_id);\n         }\n     }\n }\n@@ -594,10 +594,10 @@ fn check_foreign_item<'tcx>(\n     worklist: &mut Vec<LocalDefId>,\n     id: hir::ForeignItemId,\n ) {\n-    if matches!(tcx.def_kind(id.def_id), DefKind::Static(_) | DefKind::Fn)\n+    if matches!(tcx.def_kind(id.owner_id), DefKind::Static(_) | DefKind::Fn)\n         && has_allow_dead_code_or_lang_attr(tcx, id.hir_id())\n     {\n-        worklist.push(id.def_id.def_id);\n+        worklist.push(id.owner_id.def_id);\n     }\n }\n \n@@ -861,19 +861,19 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n     let module_items = tcx.hir_module_items(module);\n \n     for item in module_items.items() {\n-        if !live_symbols.contains(&item.def_id.def_id) {\n-            let parent = tcx.local_parent(item.def_id.def_id);\n+        if !live_symbols.contains(&item.owner_id.def_id) {\n+            let parent = tcx.local_parent(item.owner_id.def_id);\n             if parent != module && !live_symbols.contains(&parent) {\n                 // We already have diagnosed something.\n                 continue;\n             }\n-            visitor.check_definition(item.def_id.def_id);\n+            visitor.check_definition(item.owner_id.def_id);\n             continue;\n         }\n \n-        let def_kind = tcx.def_kind(item.def_id);\n+        let def_kind = tcx.def_kind(item.owner_id);\n         if let DefKind::Struct | DefKind::Union | DefKind::Enum = def_kind {\n-            let adt = tcx.adt_def(item.def_id);\n+            let adt = tcx.adt_def(item.owner_id);\n             let mut dead_variants = Vec::new();\n \n             for variant in adt.variants() {\n@@ -917,7 +917,7 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n             }\n \n             visitor.warn_dead_fields_and_variants(\n-                item.def_id.def_id,\n+                item.owner_id.def_id,\n                 \"constructed\",\n                 dead_variants,\n                 false,\n@@ -926,11 +926,11 @@ fn check_mod_deathness(tcx: TyCtxt<'_>, module: LocalDefId) {\n     }\n \n     for impl_item in module_items.impl_items() {\n-        visitor.check_definition(impl_item.def_id.def_id);\n+        visitor.check_definition(impl_item.owner_id.def_id);\n     }\n \n     for foreign_item in module_items.foreign_items() {\n-        visitor.check_definition(foreign_item.def_id.def_id);\n+        visitor.check_definition(foreign_item.owner_id.def_id);\n     }\n \n     // We do not warn trait items."}, {"sha": "a72056e00b1e2feb610e17b36b5bf68273121982", "filename": "compiler/rustc_passes/src/diagnostic_items.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdiagnostic_items.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -73,19 +73,19 @@ fn diagnostic_items<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> DiagnosticItems\n     let crate_items = tcx.hir_crate_items(());\n \n     for id in crate_items.items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n     }\n \n     for id in crate_items.trait_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n     }\n \n     for id in crate_items.impl_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n     }\n \n     for id in crate_items.foreign_items() {\n-        observe_item(tcx, &mut diagnostic_items, id.def_id.def_id);\n+        observe_item(tcx, &mut diagnostic_items, id.owner_id.def_id);\n     }\n \n     diagnostic_items"}, {"sha": "5885f45ae45db788642b311f7245a98e8d70fcd3", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -62,7 +62,7 @@ fn entry_point_type(ctxt: &EntryContext<'_>, id: ItemId, at_root: bool) -> Entry\n     } else if ctxt.tcx.sess.contains_name(attrs, sym::rustc_main) {\n         EntryPointType::RustcMainAttr\n     } else {\n-        if let Some(name) = ctxt.tcx.opt_item_name(id.def_id.to_def_id())\n+        if let Some(name) = ctxt.tcx.opt_item_name(id.owner_id.to_def_id())\n             && name == sym::main {\n             if at_root {\n                 // This is a top-level function so can be `main`.\n@@ -82,15 +82,15 @@ fn attr_span_by_symbol(ctxt: &EntryContext<'_>, id: ItemId, sym: Symbol) -> Opti\n }\n \n fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n-    let at_root = ctxt.tcx.opt_local_parent(id.def_id.def_id) == Some(CRATE_DEF_ID);\n+    let at_root = ctxt.tcx.opt_local_parent(id.owner_id.def_id) == Some(CRATE_DEF_ID);\n \n     match entry_point_type(ctxt, id, at_root) {\n         EntryPointType::None => {\n             if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n                 ctxt.tcx.sess.emit_err(AttrOnlyOnMain { span, attr: sym::unix_sigpipe });\n             }\n         }\n-        _ if !matches!(ctxt.tcx.def_kind(id.def_id), DefKind::Fn) => {\n+        _ if !matches!(ctxt.tcx.def_kind(id.owner_id), DefKind::Fn) => {\n             for attr in [sym::start, sym::rustc_main] {\n                 if let Some(span) = attr_span_by_symbol(ctxt, id, attr) {\n                     ctxt.tcx.sess.emit_err(AttrOnlyInFunctions { span, attr });\n@@ -102,16 +102,16 @@ fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n             if let Some(span) = attr_span_by_symbol(ctxt, id, sym::unix_sigpipe) {\n                 ctxt.tcx.sess.emit_err(AttrOnlyOnRootMain { span, attr: sym::unix_sigpipe });\n             }\n-            ctxt.non_main_fns.push(ctxt.tcx.def_span(id.def_id));\n+            ctxt.non_main_fns.push(ctxt.tcx.def_span(id.owner_id));\n         }\n         EntryPointType::RustcMainAttr => {\n             if ctxt.attr_main_fn.is_none() {\n-                ctxt.attr_main_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n+                ctxt.attr_main_fn = Some((id.owner_id.def_id, ctxt.tcx.def_span(id.owner_id)));\n             } else {\n                 ctxt.tcx.sess.emit_err(MultipleRustcMain {\n-                    span: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    span: ctxt.tcx.def_span(id.owner_id.to_def_id()),\n                     first: ctxt.attr_main_fn.unwrap().1,\n-                    additional: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    additional: ctxt.tcx.def_span(id.owner_id.to_def_id()),\n                 });\n             }\n         }\n@@ -120,11 +120,11 @@ fn find_item(id: ItemId, ctxt: &mut EntryContext<'_>) {\n                 ctxt.tcx.sess.emit_err(AttrOnlyOnMain { span, attr: sym::unix_sigpipe });\n             }\n             if ctxt.start_fn.is_none() {\n-                ctxt.start_fn = Some((id.def_id.def_id, ctxt.tcx.def_span(id.def_id)));\n+                ctxt.start_fn = Some((id.owner_id.def_id, ctxt.tcx.def_span(id.owner_id)));\n             } else {\n                 ctxt.tcx.sess.emit_err(MultipleStartFunctions {\n-                    span: ctxt.tcx.def_span(id.def_id),\n-                    labeled: ctxt.tcx.def_span(id.def_id.to_def_id()),\n+                    span: ctxt.tcx.def_span(id.owner_id),\n+                    labeled: ctxt.tcx.def_span(id.owner_id.to_def_id()),\n                     previous: ctxt.start_fn.unwrap().1,\n                 });\n             }"}, {"sha": "88bb39debb114640e660f41c4174f1538fc5d055", "filename": "compiler/rustc_passes/src/hir_id_validator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_id_validator.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -126,7 +126,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n \n     fn visit_item(&mut self, i: &'hir hir::Item<'hir>) {\n         let mut inner_visitor = self.new_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_item(this, i));\n+        inner_visitor.check(i.owner_id, |this| intravisit::walk_item(this, i));\n     }\n \n     fn visit_id(&mut self, hir_id: HirId) {\n@@ -148,16 +148,16 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirIdValidator<'a, 'hir> {\n \n     fn visit_foreign_item(&mut self, i: &'hir hir::ForeignItem<'hir>) {\n         let mut inner_visitor = self.new_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_foreign_item(this, i));\n+        inner_visitor.check(i.owner_id, |this| intravisit::walk_foreign_item(this, i));\n     }\n \n     fn visit_trait_item(&mut self, i: &'hir hir::TraitItem<'hir>) {\n         let mut inner_visitor = self.new_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_trait_item(this, i));\n+        inner_visitor.check(i.owner_id, |this| intravisit::walk_trait_item(this, i));\n     }\n \n     fn visit_impl_item(&mut self, i: &'hir hir::ImplItem<'hir>) {\n         let mut inner_visitor = self.new_visitor(self.hir_map);\n-        inner_visitor.check(i.def_id, |this| intravisit::walk_impl_item(this, i));\n+        inner_visitor.check(i.owner_id, |this| intravisit::walk_impl_item(this, i));\n     }\n }"}, {"sha": "df811be2a7e443b9e4ed59c4e5af6d27acd26b79", "filename": "compiler/rustc_passes/src/lang_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flang_items.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -217,9 +217,9 @@ fn get_lang_items(tcx: TyCtxt<'_>, (): ()) -> LanguageItems {\n     let crate_items = tcx.hir_crate_items(());\n \n     for id in crate_items.items() {\n-        collector.check_for_lang(Target::from_def_kind(tcx.def_kind(id.def_id)), id.hir_id());\n+        collector.check_for_lang(Target::from_def_kind(tcx.def_kind(id.owner_id)), id.hir_id());\n \n-        if matches!(tcx.def_kind(id.def_id), DefKind::Enum) {\n+        if matches!(tcx.def_kind(id.owner_id), DefKind::Enum) {\n             let item = tcx.hir().item(id);\n             if let hir::ItemKind::Enum(def, ..) = &item.kind {\n                 for variant in def.variants {"}, {"sha": "5322baee7473a451f107903d9d46c45c42ece559", "filename": "compiler/rustc_passes/src/layout_test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flayout_test.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -15,11 +15,11 @@ pub fn test_layout(tcx: TyCtxt<'_>) {\n         // if the `rustc_attrs` feature is not enabled, don't bother testing layout\n         for id in tcx.hir().items() {\n             if matches!(\n-                tcx.def_kind(id.def_id),\n+                tcx.def_kind(id.owner_id),\n                 DefKind::TyAlias | DefKind::Enum | DefKind::Struct | DefKind::Union\n             ) {\n-                for attr in tcx.get_attrs(id.def_id.to_def_id(), sym::rustc_layout) {\n-                    dump_layout_of(tcx, id.def_id.def_id, attr);\n+                for attr in tcx.get_attrs(id.owner_id.to_def_id(), sym::rustc_layout) {\n+                    dump_layout_of(tcx, id.owner_id.def_id, attr);\n                 }\n             }\n         }"}, {"sha": "10d5fc5d6711018855962f03e0e856bce5ee1a87", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -29,7 +29,7 @@ fn item_might_be_inlined(tcx: TyCtxt<'_>, item: &hir::Item<'_>, attrs: &CodegenF\n     match item.kind {\n         hir::ItemKind::Fn(ref sig, ..) if sig.header.is_const() => true,\n         hir::ItemKind::Impl { .. } | hir::ItemKind::Fn(..) => {\n-            let generics = tcx.generics_of(item.def_id);\n+            let generics = tcx.generics_of(item.owner_id);\n             generics.requires_monomorphization(tcx)\n         }\n         _ => false,\n@@ -42,7 +42,7 @@ fn method_might_be_inlined(\n     impl_src: LocalDefId,\n ) -> bool {\n     let codegen_fn_attrs = tcx.codegen_fn_attrs(impl_item.hir_id().owner.to_def_id());\n-    let generics = tcx.generics_of(impl_item.def_id);\n+    let generics = tcx.generics_of(impl_item.owner_id);\n     if codegen_fn_attrs.requests_inline() || generics.requires_monomorphization(tcx) {\n         return true;\n     }\n@@ -216,7 +216,7 @@ impl<'tcx> ReachableContext<'tcx> {\n                         if item_might_be_inlined(\n                             self.tcx,\n                             &item,\n-                            self.tcx.codegen_fn_attrs(item.def_id),\n+                            self.tcx.codegen_fn_attrs(item.owner_id),\n                         ) {\n                             self.visit_nested_body(body);\n                         }\n@@ -305,11 +305,11 @@ fn check_item<'tcx>(\n     worklist: &mut Vec<LocalDefId>,\n     effective_visibilities: &privacy::EffectiveVisibilities,\n ) {\n-    if has_custom_linkage(tcx, id.def_id.def_id) {\n-        worklist.push(id.def_id.def_id);\n+    if has_custom_linkage(tcx, id.owner_id.def_id) {\n+        worklist.push(id.owner_id.def_id);\n     }\n \n-    if !matches!(tcx.def_kind(id.def_id), DefKind::Impl) {\n+    if !matches!(tcx.def_kind(id.owner_id), DefKind::Impl) {\n         return;\n     }\n \n@@ -318,8 +318,8 @@ fn check_item<'tcx>(\n     if let hir::ItemKind::Impl(hir::Impl { of_trait: Some(ref trait_ref), ref items, .. }) =\n         item.kind\n     {\n-        if !effective_visibilities.is_reachable(item.def_id.def_id) {\n-            worklist.extend(items.iter().map(|ii_ref| ii_ref.id.def_id.def_id));\n+        if !effective_visibilities.is_reachable(item.owner_id.def_id) {\n+            worklist.extend(items.iter().map(|ii_ref| ii_ref.id.owner_id.def_id));\n \n             let Res::Def(DefKind::Trait, trait_def_id) = trait_ref.path.res else {\n                 unreachable!();\n@@ -403,8 +403,8 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> FxHashSet<LocalDefId> {\n         }\n \n         for id in crate_items.impl_items() {\n-            if has_custom_linkage(tcx, id.def_id.def_id) {\n-                reachable_context.worklist.push(id.def_id.def_id);\n+            if has_custom_linkage(tcx, id.owner_id.def_id) {\n+                reachable_context.worklist.push(id.owner_id.def_id);\n             }\n         }\n     }"}, {"sha": "78afa2f25f8e10c97b265ece1540c7876ec28e43", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         }\n \n         self.annotate(\n-            i.def_id.def_id,\n+            i.owner_id.def_id,\n             i.span,\n             fn_sig,\n             kind,\n@@ -397,7 +397,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         };\n \n         self.annotate(\n-            ti.def_id.def_id,\n+            ti.owner_id.def_id,\n             ti.span,\n             fn_sig,\n             AnnotationKind::Required,\n@@ -420,7 +420,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n         };\n \n         self.annotate(\n-            ii.def_id.def_id,\n+            ii.owner_id.def_id,\n             ii.span,\n             fn_sig,\n             kind,\n@@ -478,7 +478,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n         self.annotate(\n-            i.def_id.def_id,\n+            i.owner_id.def_id,\n             i.span,\n             None,\n             AnnotationKind::Required,\n@@ -569,25 +569,25 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n             hir::ItemKind::Impl(hir::Impl { of_trait: None, .. })\n                 | hir::ItemKind::ForeignMod { .. }\n         ) {\n-            self.check_missing_stability(i.def_id.def_id, i.span);\n+            self.check_missing_stability(i.owner_id.def_id, i.span);\n         }\n \n         // Ensure stable `const fn` have a const stability attribute.\n-        self.check_missing_const_stability(i.def_id.def_id, i.span);\n+        self.check_missing_const_stability(i.owner_id.def_id, i.span);\n \n         intravisit::walk_item(self, i)\n     }\n \n     fn visit_trait_item(&mut self, ti: &'tcx hir::TraitItem<'tcx>) {\n-        self.check_missing_stability(ti.def_id.def_id, ti.span);\n+        self.check_missing_stability(ti.owner_id.def_id, ti.span);\n         intravisit::walk_trait_item(self, ti);\n     }\n \n     fn visit_impl_item(&mut self, ii: &'tcx hir::ImplItem<'tcx>) {\n         let impl_def_id = self.tcx.hir().get_parent_item(ii.hir_id());\n         if self.tcx.impl_trait_ref(impl_def_id).is_none() {\n-            self.check_missing_stability(ii.def_id.def_id, ii.span);\n-            self.check_missing_const_stability(ii.def_id.def_id, ii.span);\n+            self.check_missing_stability(ii.owner_id.def_id, ii.span);\n+            self.check_missing_const_stability(ii.owner_id.def_id, ii.span);\n         }\n         intravisit::walk_impl_item(self, ii);\n     }\n@@ -606,7 +606,7 @@ impl<'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, i: &'tcx hir::ForeignItem<'tcx>) {\n-        self.check_missing_stability(i.def_id.def_id, i.span);\n+        self.check_missing_stability(i.owner_id.def_id, i.span);\n         intravisit::walk_foreign_item(self, i);\n     }\n     // Note that we don't need to `check_missing_stability` for default generic parameters,\n@@ -712,7 +712,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                     return;\n                 }\n \n-                let Some(cnum) = self.tcx.extern_mod_stmt_cnum(item.def_id.def_id) else {\n+                let Some(cnum) = self.tcx.extern_mod_stmt_cnum(item.owner_id.def_id) else {\n                     return;\n                 };\n                 let def_id = cnum.as_def_id();\n@@ -765,7 +765,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'tcx> {\n                 }\n \n                 for impl_item_ref in *items {\n-                    let impl_item = self.tcx.associated_item(impl_item_ref.id.def_id);\n+                    let impl_item = self.tcx.associated_item(impl_item_ref.id.owner_id);\n \n                     if let Some(def_id) = impl_item.trait_item_def_id {\n                         // Pass `None` to skip deprecation warnings."}, {"sha": "959ee600c07096ce20ee923de37565f73b5cfdff", "filename": "compiler/rustc_passes/src/weak_lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fweak_lang_items.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -34,7 +34,7 @@ pub fn check_crate<'tcx>(tcx: TyCtxt<'tcx>, items: &mut lang_items::LanguageItem\n                     items.missing.push(item);\n                 }\n             } else {\n-                let span = tcx.def_span(id.def_id);\n+                let span = tcx.def_span(id.owner_id);\n                 tcx.sess.emit_err(UnknownExternLangItem { span, lang_item });\n             }\n         }"}, {"sha": "865d6306bd349953271cc3788ed6948da6a859ac", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 62, "deletions": 53, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -505,9 +505,9 @@ impl<'tcx> EmbargoVisitor<'tcx> {\n     fn update_macro_reachable_mod(&mut self, module_def_id: LocalDefId, defining_mod: LocalDefId) {\n         let module = self.tcx.hir().get_module(module_def_id).0;\n         for item_id in module.item_ids {\n-            let def_kind = self.tcx.def_kind(item_id.def_id);\n-            let vis = self.tcx.local_visibility(item_id.def_id.def_id);\n-            self.update_macro_reachable_def(item_id.def_id.def_id, def_kind, vis, defining_mod);\n+            let def_kind = self.tcx.def_kind(item_id.owner_id);\n+            let vis = self.tcx.local_visibility(item_id.owner_id.def_id);\n+            self.update_macro_reachable_def(item_id.owner_id.def_id, def_kind, vis, defining_mod);\n         }\n         if let Some(exports) = self.tcx.module_reexports(module_def_id) {\n             for export in exports {\n@@ -628,13 +628,13 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         let item_level = match item.kind {\n             hir::ItemKind::Impl { .. } => {\n                 let impl_level = Option::<Level>::of_impl(\n-                    item.def_id.def_id,\n+                    item.owner_id.def_id,\n                     self.tcx,\n                     &self.effective_visibilities,\n                 );\n-                self.update(item.def_id.def_id, impl_level)\n+                self.update(item.owner_id.def_id, impl_level)\n             }\n-            _ => self.get(item.def_id.def_id),\n+            _ => self.get(item.owner_id.def_id),\n         };\n \n         // Update levels of nested things.\n@@ -653,15 +653,15 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             hir::ItemKind::Impl(ref impl_) => {\n                 for impl_item_ref in impl_.items {\n                     if impl_.of_trait.is_some()\n-                        || self.tcx.visibility(impl_item_ref.id.def_id).is_public()\n+                        || self.tcx.visibility(impl_item_ref.id.owner_id).is_public()\n                     {\n-                        self.update(impl_item_ref.id.def_id.def_id, item_level);\n+                        self.update(impl_item_ref.id.owner_id.def_id, item_level);\n                     }\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 for trait_item_ref in trait_item_refs {\n-                    self.update(trait_item_ref.id.def_id.def_id, item_level);\n+                    self.update(trait_item_ref.id.owner_id.def_id, item_level);\n                 }\n             }\n             hir::ItemKind::Struct(ref def, _) | hir::ItemKind::Union(ref def, _) => {\n@@ -677,12 +677,12 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                 }\n             }\n             hir::ItemKind::Macro(ref macro_def, _) => {\n-                self.update_reachability_from_macro(item.def_id.def_id, macro_def);\n+                self.update_reachability_from_macro(item.owner_id.def_id, macro_def);\n             }\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    if self.tcx.visibility(foreign_item.id.def_id).is_public() {\n-                        self.update(foreign_item.id.def_id.def_id, item_level);\n+                    if self.tcx.visibility(foreign_item.id.owner_id).is_public() {\n+                        self.update(foreign_item.id.owner_id.def_id, item_level);\n                     }\n                 }\n             }\n@@ -719,7 +719,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     // in the reachability pass (`middle/reachable.rs`). Types are marked as link-time\n                     // reachable if they are returned via `impl Trait`, even from private functions.\n                     let exist_level = cmp::max(item_level, Some(Level::ReachableThroughImplTrait));\n-                    self.reach(item.def_id.def_id, exist_level).generics().predicates().ty();\n+                    self.reach(item.owner_id.def_id, exist_level).generics().predicates().ty();\n                 }\n             }\n             // Visit everything.\n@@ -728,20 +728,20 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             | hir::ItemKind::Fn(..)\n             | hir::ItemKind::TyAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level).generics().predicates().ty();\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates().ty();\n                 }\n             }\n             hir::ItemKind::Trait(.., trait_item_refs) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         let tcx = self.tcx;\n-                        let mut reach = self.reach(trait_item_ref.id.def_id.def_id, item_level);\n+                        let mut reach = self.reach(trait_item_ref.id.owner_id.def_id, item_level);\n                         reach.generics().predicates();\n \n                         if trait_item_ref.kind == AssocItemKind::Type\n-                            && !tcx.impl_defaultness(trait_item_ref.id.def_id).has_value()\n+                            && !tcx.impl_defaultness(trait_item_ref.id.owner_id).has_value()\n                         {\n                             // No type to visit.\n                         } else {\n@@ -752,22 +752,22 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             }\n             hir::ItemKind::TraitAlias(..) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                 }\n             }\n             // Visit everything except for private impl items.\n             hir::ItemKind::Impl(ref impl_) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level)\n+                    self.reach(item.owner_id.def_id, item_level)\n                         .generics()\n                         .predicates()\n                         .ty()\n                         .trait_ref();\n \n                     for impl_item_ref in impl_.items {\n-                        let impl_item_level = self.get(impl_item_ref.id.def_id.def_id);\n+                        let impl_item_level = self.get(impl_item_ref.id.owner_id.def_id);\n                         if impl_item_level.is_some() {\n-                            self.reach(impl_item_ref.id.def_id.def_id, impl_item_level)\n+                            self.reach(impl_item_ref.id.owner_id.def_id, impl_item_level)\n                                 .generics()\n                                 .predicates()\n                                 .ty();\n@@ -779,7 +779,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything, but enum variants have their own levels.\n             hir::ItemKind::Enum(ref def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                 }\n                 for variant in def.variants {\n                     let variant_level = self.get(self.tcx.hir().local_def_id(variant.id));\n@@ -790,23 +790,23 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                         }\n                         // Corner case: if the variant is reachable, but its\n                         // enum is not, make the enum reachable as well.\n-                        self.reach(item.def_id.def_id, variant_level).ty();\n+                        self.reach(item.owner_id.def_id, variant_level).ty();\n                     }\n                     if let Some(hir_id) = variant.data.ctor_hir_id() {\n                         let ctor_def_id = self.tcx.hir().local_def_id(hir_id);\n                         let ctor_level = self.get(ctor_def_id);\n                         if ctor_level.is_some() {\n-                            self.reach(item.def_id.def_id, ctor_level).ty();\n+                            self.reach(item.owner_id.def_id, ctor_level).ty();\n                         }\n                     }\n                 }\n             }\n             // Visit everything, but foreign items have their own levels.\n             hir::ItemKind::ForeignMod { items, .. } => {\n                 for foreign_item in items {\n-                    let foreign_item_level = self.get(foreign_item.id.def_id.def_id);\n+                    let foreign_item_level = self.get(foreign_item.id.owner_id.def_id);\n                     if foreign_item_level.is_some() {\n-                        self.reach(foreign_item.id.def_id.def_id, foreign_item_level)\n+                        self.reach(foreign_item.id.owner_id.def_id, foreign_item_level)\n                             .generics()\n                             .predicates()\n                             .ty();\n@@ -816,7 +816,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n             // Visit everything except for private fields.\n             hir::ItemKind::Struct(ref struct_def, _) | hir::ItemKind::Union(ref struct_def, _) => {\n                 if item_level.is_some() {\n-                    self.reach(item.def_id.def_id, item_level).generics().predicates();\n+                    self.reach(item.owner_id.def_id, item_level).generics().predicates();\n                     for field in struct_def.fields() {\n                         let def_id = self.tcx.hir().local_def_id(field.hir_id);\n                         let field_level = self.get(def_id);\n@@ -829,7 +829,7 @@ impl<'tcx> Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     let ctor_def_id = self.tcx.hir().local_def_id(hir_id);\n                     let ctor_level = self.get(ctor_def_id);\n                     if ctor_level.is_some() {\n-                        self.reach(item.def_id.def_id, ctor_level).ty();\n+                        self.reach(item.owner_id.def_id, ctor_level).ty();\n                     }\n                 }\n             }\n@@ -952,7 +952,7 @@ impl<'tcx, 'a> TestReachabilityVisitor<'tcx, 'a> {\n \n impl<'tcx, 'a> Visitor<'tcx> for TestReachabilityVisitor<'tcx, 'a> {\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        self.effective_visibility_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.owner_id.def_id);\n \n         match item.kind {\n             hir::ItemKind::Enum(ref def, _) => {\n@@ -976,13 +976,13 @@ impl<'tcx, 'a> Visitor<'tcx> for TestReachabilityVisitor<'tcx, 'a> {\n     }\n \n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem<'tcx>) {\n-        self.effective_visibility_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.owner_id.def_id);\n     }\n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem<'tcx>) {\n-        self.effective_visibility_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.owner_id.def_id);\n     }\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        self.effective_visibility_diagnostic(item.def_id.def_id);\n+        self.effective_visibility_diagnostic(item.owner_id.def_id);\n     }\n }\n \n@@ -1065,7 +1065,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n     }\n \n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(&mut self.current_item, item.def_id.def_id);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.owner_id.def_id);\n         intravisit::walk_item(self, item);\n         self.current_item = orig_current_item;\n     }\n@@ -1368,7 +1368,7 @@ impl<'tcx> Visitor<'tcx> for TypePrivacyVisitor<'tcx> {\n \n     // Check types in item interfaces.\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n-        let orig_current_item = mem::replace(&mut self.current_item, item.def_id.def_id);\n+        let orig_current_item = mem::replace(&mut self.current_item, item.owner_id.def_id);\n         let old_maybe_typeck_results = self.maybe_typeck_results.take();\n         intravisit::walk_item(self, item);\n         self.maybe_typeck_results = old_maybe_typeck_results;\n@@ -1512,7 +1512,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::ForeignMod { .. } => {}\n \n             hir::ItemKind::Trait(.., bounds, _) => {\n-                if !self.trait_is_public(item.def_id.def_id) {\n+                if !self.trait_is_public(item.owner_id.def_id) {\n                     return;\n                 }\n \n@@ -1574,7 +1574,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         match impl_item.kind {\n                             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..) => self\n                                 .effective_visibilities\n-                                .is_reachable(impl_item_ref.id.def_id.def_id),\n+                                .is_reachable(impl_item_ref.id.owner_id.def_id),\n                             hir::ImplItemKind::Type(_) => false,\n                         }\n                     });\n@@ -1593,7 +1593,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                                 let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                                 match impl_item.kind {\n                                     hir::ImplItemKind::Const(..) | hir::ImplItemKind::Fn(..)\n-                                        if self.item_is_public(impl_item.def_id.def_id) =>\n+                                        if self.item_is_public(impl_item.owner_id.def_id) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -1634,8 +1634,10 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                     // methods will be visible as `Public::foo`.\n                     let mut found_pub_static = false;\n                     for impl_item_ref in impl_.items {\n-                        if self.effective_visibilities.is_reachable(impl_item_ref.id.def_id.def_id)\n-                            || self.tcx.visibility(impl_item_ref.id.def_id).is_public()\n+                        if self\n+                            .effective_visibilities\n+                            .is_reachable(impl_item_ref.id.owner_id.def_id)\n+                            || self.tcx.visibility(impl_item_ref.id.owner_id).is_public()\n                         {\n                             let impl_item = self.tcx.hir().impl_item(impl_item_ref.id);\n                             match impl_item_ref.kind {\n@@ -1663,7 +1665,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             hir::ItemKind::TyAlias(..) => return,\n \n             // Not at all public, so we don't care.\n-            _ if !self.item_is_public(item.def_id.def_id) => {\n+            _ if !self.item_is_public(item.owner_id.def_id) => {\n                 return;\n             }\n \n@@ -1694,7 +1696,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        if self.effective_visibilities.is_reachable(item.def_id.def_id) {\n+        if self.effective_visibilities.is_reachable(item.owner_id.def_id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n@@ -1931,7 +1933,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n \n     pub fn check_item(&mut self, id: ItemId) {\n         let tcx = self.tcx;\n-        let def_id = id.def_id.def_id;\n+        let def_id = id.owner_id.def_id;\n         let item_visibility = tcx.local_visibility(def_id);\n         let def_kind = tcx.def_kind(def_id);\n \n@@ -1947,17 +1949,17 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n             DefKind::Trait => {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Trait(.., trait_item_refs) = item.kind {\n-                    self.check(item.def_id.def_id, item_visibility).generics().predicates();\n+                    self.check(item.owner_id.def_id, item_visibility).generics().predicates();\n \n                     for trait_item_ref in trait_item_refs {\n                         self.check_assoc_item(\n-                            trait_item_ref.id.def_id.def_id,\n+                            trait_item_ref.id.owner_id.def_id,\n                             trait_item_ref.kind,\n                             item_visibility,\n                         );\n \n                         if let AssocItemKind::Type = trait_item_ref.kind {\n-                            self.check(trait_item_ref.id.def_id.def_id, item_visibility).bounds();\n+                            self.check(trait_item_ref.id.owner_id.def_id, item_visibility).bounds();\n                         }\n                     }\n                 }\n@@ -1968,7 +1970,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n             DefKind::Enum => {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Enum(ref def, _) = item.kind {\n-                    self.check(item.def_id.def_id, item_visibility).generics().predicates();\n+                    self.check(item.owner_id.def_id, item_visibility).generics().predicates();\n \n                     for variant in def.variants {\n                         for field in variant.data.fields() {\n@@ -1983,8 +1985,11 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::ForeignMod { items, .. } = item.kind {\n                     for foreign_item in items {\n-                        let vis = tcx.local_visibility(foreign_item.id.def_id.def_id);\n-                        self.check(foreign_item.id.def_id.def_id, vis).generics().predicates().ty();\n+                        let vis = tcx.local_visibility(foreign_item.id.owner_id.def_id);\n+                        self.check(foreign_item.id.owner_id.def_id, vis)\n+                            .generics()\n+                            .predicates()\n+                            .ty();\n                     }\n                 }\n             }\n@@ -1994,7 +1999,7 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n                 if let hir::ItemKind::Struct(ref struct_def, _)\n                 | hir::ItemKind::Union(ref struct_def, _) = item.kind\n                 {\n-                    self.check(item.def_id.def_id, item_visibility).generics().predicates();\n+                    self.check(item.owner_id.def_id, item_visibility).generics().predicates();\n \n                     for field in struct_def.fields() {\n                         let def_id = tcx.hir().local_def_id(field.hir_id);\n@@ -2011,20 +2016,24 @@ impl<'tcx> PrivateItemsInPublicInterfacesChecker<'tcx> {\n                 let item = tcx.hir().item(id);\n                 if let hir::ItemKind::Impl(ref impl_) = item.kind {\n                     let impl_vis =\n-                        ty::Visibility::of_impl(item.def_id.def_id, tcx, &Default::default());\n+                        ty::Visibility::of_impl(item.owner_id.def_id, tcx, &Default::default());\n                     // check that private components do not appear in the generics or predicates of inherent impls\n                     // this check is intentionally NOT performed for impls of traits, per #90586\n                     if impl_.of_trait.is_none() {\n-                        self.check(item.def_id.def_id, impl_vis).generics().predicates();\n+                        self.check(item.owner_id.def_id, impl_vis).generics().predicates();\n                     }\n                     for impl_item_ref in impl_.items {\n                         let impl_item_vis = if impl_.of_trait.is_none() {\n-                            min(tcx.local_visibility(impl_item_ref.id.def_id.def_id), impl_vis, tcx)\n+                            min(\n+                                tcx.local_visibility(impl_item_ref.id.owner_id.def_id),\n+                                impl_vis,\n+                                tcx,\n+                            )\n                         } else {\n                             impl_vis\n                         };\n                         self.check_assoc_item(\n-                            impl_item_ref.id.def_id.def_id,\n+                            impl_item_ref.id.owner_id.def_id,\n                             impl_item_ref.kind,\n                             impl_item_vis,\n                         );"}, {"sha": "df5d992f66330efefe3bcbee717a4e972070c069", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -345,14 +345,14 @@ impl<'tcx> DumpVisitor<'tcx> {\n         body: hir::BodyId,\n     ) {\n         let map = self.tcx.hir();\n-        self.nest_typeck_results(item.def_id.def_id, |v| {\n+        self.nest_typeck_results(item.owner_id.def_id, |v| {\n             let body = map.body(body);\n             if let Some(fn_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(fn_data, DefData, item.span);\n                 v.process_formals(body.params, &fn_data.qualname);\n                 v.process_generic_params(ty_params, &fn_data.qualname, item.hir_id());\n \n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id.def_id), fn_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item.owner_id.def_id), fn_data);\n             }\n \n             for arg in decl.inputs {\n@@ -373,10 +373,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n         typ: &'tcx hir::Ty<'tcx>,\n         expr: &'tcx hir::Expr<'tcx>,\n     ) {\n-        self.nest_typeck_results(item.def_id.def_id, |v| {\n+        self.nest_typeck_results(item.owner_id.def_id, |v| {\n             if let Some(var_data) = v.save_ctxt.get_item_data(item) {\n                 down_cast_data!(var_data, DefData, item.span);\n-                v.dumper.dump_def(&access_from!(v.save_ctxt, item.def_id.def_id), var_data);\n+                v.dumper.dump_def(&access_from!(v.save_ctxt, item.owner_id.def_id), var_data);\n             }\n             v.visit_ty(&typ);\n             v.visit_expr(expr);\n@@ -436,7 +436,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n     ) {\n         debug!(\"process_struct {:?} {:?}\", item, item.span);\n         let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n \n         let kind = match item.kind {\n             hir::ItemKind::Struct(_, _) => DefKind::Struct,\n@@ -473,10 +473,10 @@ impl<'tcx> DumpVisitor<'tcx> {\n             let span = self.span_from_span(item.ident.span);\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item.def_id.def_id),\n+                &access_from!(self.save_ctxt, item.owner_id.def_id),\n                 Def {\n                     kind,\n-                    id: id_from_def_id(item.def_id.to_def_id()),\n+                    id: id_from_def_id(item.owner_id.to_def_id()),\n                     span,\n                     name,\n                     qualname: qualname.clone(),\n@@ -491,7 +491,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n             );\n         }\n \n-        self.nest_typeck_results(item.def_id.def_id, |v| {\n+        self.nest_typeck_results(item.owner_id.def_id, |v| {\n             for field in def.fields() {\n                 v.process_struct_field_def(field, item.hir_id());\n                 v.visit_ty(&field.ty);\n@@ -513,7 +513,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         };\n         down_cast_data!(enum_data, DefData, item.span);\n \n-        let access = access_from!(self.save_ctxt, item.def_id.def_id);\n+        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n \n         for variant in enum_definition.variants {\n             let name = variant.ident.name.to_string();\n@@ -528,7 +528,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n                         let id = id_from_hir_id(variant.id, &self.save_ctxt);\n-                        let parent = Some(id_from_def_id(item.def_id.to_def_id()));\n+                        let parent = Some(id_from_def_id(item.owner_id.to_def_id()));\n                         let attrs = self.tcx.hir().attrs(variant.id);\n \n                         self.dumper.dump_def(\n@@ -566,7 +566,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n                         let id = id_from_hir_id(variant.id, &self.save_ctxt);\n-                        let parent = Some(id_from_def_id(item.def_id.to_def_id()));\n+                        let parent = Some(id_from_def_id(item.owner_id.to_def_id()));\n                         let attrs = self.tcx.hir().attrs(variant.id);\n \n                         self.dumper.dump_def(\n@@ -612,14 +612,14 @@ impl<'tcx> DumpVisitor<'tcx> {\n         }\n \n         let map = self.tcx.hir();\n-        self.nest_typeck_results(item.def_id.def_id, |v| {\n+        self.nest_typeck_results(item.owner_id.def_id, |v| {\n             v.visit_ty(&impl_.self_ty);\n             if let Some(trait_ref) = &impl_.of_trait {\n                 v.process_path(trait_ref.hir_ref_id, &hir::QPath::Resolved(None, &trait_ref.path));\n             }\n             v.process_generic_params(&impl_.generics, \"\", item.hir_id());\n             for impl_item in impl_.items {\n-                v.process_impl_item(map.impl_item(impl_item.id), item.def_id.to_def_id());\n+                v.process_impl_item(map.impl_item(impl_item.id), item.owner_id.to_def_id());\n             }\n         });\n     }\n@@ -632,7 +632,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         methods: &'tcx [hir::TraitItemRef],\n     ) {\n         let name = item.ident.to_string();\n-        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n+        let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n         let mut val = name.clone();\n         if !generics.params.is_empty() {\n             val.push_str(&generic_params_to_string(generics.params));\n@@ -642,13 +642,13 @@ impl<'tcx> DumpVisitor<'tcx> {\n             val.push_str(&bounds_to_string(trait_refs));\n         }\n         if !self.span.filter_generated(item.ident.span) {\n-            let id = id_from_def_id(item.def_id.to_def_id());\n+            let id = id_from_def_id(item.owner_id.to_def_id());\n             let span = self.span_from_span(item.ident.span);\n             let children =\n-                methods.iter().map(|i| id_from_def_id(i.id.def_id.to_def_id())).collect();\n+                methods.iter().map(|i| id_from_def_id(i.id.owner_id.to_def_id())).collect();\n             let attrs = self.tcx.hir().attrs(item.hir_id());\n             self.dumper.dump_def(\n-                &access_from!(self.save_ctxt, item.def_id.def_id),\n+                &access_from!(self.save_ctxt, item.owner_id.def_id),\n                 Def {\n                     kind: DefKind::Trait,\n                     id,\n@@ -692,7 +692,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                         kind: RelationKind::SuperTrait,\n                         span,\n                         from: id_from_def_id(id),\n-                        to: id_from_def_id(item.def_id.to_def_id()),\n+                        to: id_from_def_id(item.owner_id.to_def_id()),\n                     });\n                 }\n             }\n@@ -702,15 +702,15 @@ impl<'tcx> DumpVisitor<'tcx> {\n         self.process_generic_params(generics, &qualname, item.hir_id());\n         for method in methods {\n             let map = self.tcx.hir();\n-            self.process_trait_item(map.trait_item(method.id), item.def_id.to_def_id())\n+            self.process_trait_item(map.trait_item(method.id), item.owner_id.to_def_id())\n         }\n     }\n \n     // `item` is the module in question, represented as an( item.\n     fn process_mod(&mut self, item: &'tcx hir::Item<'tcx>) {\n         if let Some(mod_data) = self.save_ctxt.get_item_data(item) {\n             down_cast_data!(mod_data, DefData, item.span);\n-            self.dumper.dump_def(&access_from!(self.save_ctxt, item.def_id.def_id), mod_data);\n+            self.dumper.dump_def(&access_from!(self.save_ctxt, item.owner_id.def_id), mod_data);\n         }\n     }\n \n@@ -981,7 +981,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let body = body.map(|b| self.tcx.hir().body(b).value);\n                 let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n                 self.process_assoc_const(\n-                    trait_item.def_id.def_id,\n+                    trait_item.owner_id.def_id,\n                     trait_item.ident,\n                     &ty,\n                     body,\n@@ -995,7 +995,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     body,\n-                    trait_item.def_id.def_id,\n+                    trait_item.owner_id.def_id,\n                     trait_item.ident,\n                     &trait_item.generics,\n                     trait_item.span,\n@@ -1005,11 +1005,11 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 // FIXME do something with _bounds (for type refs)\n                 let name = trait_item.ident.name.to_string();\n                 let qualname =\n-                    format!(\"::{}\", self.tcx.def_path_str(trait_item.def_id.to_def_id()));\n+                    format!(\"::{}\", self.tcx.def_path_str(trait_item.owner_id.to_def_id()));\n \n                 if !self.span.filter_generated(trait_item.ident.span) {\n                     let span = self.span_from_span(trait_item.ident.span);\n-                    let id = id_from_def_id(trait_item.def_id.to_def_id());\n+                    let id = id_from_def_id(trait_item.owner_id.to_def_id());\n                     let attrs = self.tcx.hir().attrs(trait_item.hir_id());\n \n                     self.dumper.dump_def(\n@@ -1051,7 +1051,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 let body = self.tcx.hir().body(body);\n                 let attrs = self.tcx.hir().attrs(impl_item.hir_id());\n                 self.process_assoc_const(\n-                    impl_item.def_id.def_id,\n+                    impl_item.owner_id.def_id,\n                     impl_item.ident,\n                     &ty,\n                     Some(&body.value),\n@@ -1063,7 +1063,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n                 self.process_method(\n                     sig,\n                     Some(body),\n-                    impl_item.def_id.def_id,\n+                    impl_item.owner_id.def_id,\n                     impl_item.ident,\n                     &impl_item.generics,\n                     impl_item.span,\n@@ -1088,7 +1088,7 @@ impl<'tcx> DumpVisitor<'tcx> {\n         let filename = sm.span_to_filename(krate_mod.spans.inner_span);\n         let data_id = id_from_hir_id(id, &self.save_ctxt);\n         let children =\n-            krate_mod.item_ids.iter().map(|i| id_from_def_id(i.def_id.to_def_id())).collect();\n+            krate_mod.item_ids.iter().map(|i| id_from_def_id(i.owner_id.to_def_id())).collect();\n         let span = self.span_from_span(krate_mod.spans.inner_span);\n         let attrs = self.tcx.hir().attrs(id);\n \n@@ -1137,10 +1137,10 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             hir::ItemKind::Use(path, hir::UseKind::Single) => {\n                 let sub_span = path.segments.last().unwrap().ident.span;\n                 if !self.span.filter_generated(sub_span) {\n-                    let access = access_from!(self.save_ctxt, item.def_id.def_id);\n+                    let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n                     let ref_id = self.lookup_def_id(item.hir_id()).map(id_from_def_id);\n                     let span = self.span_from_span(sub_span);\n-                    let parent = self.save_ctxt.tcx.local_parent(item.def_id.def_id);\n+                    let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n                     self.dumper.import(\n                         &access,\n                         Import {\n@@ -1158,16 +1158,16 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::ItemKind::Use(path, hir::UseKind::Glob) => {\n                 // Make a comma-separated list of names of imported modules.\n-                let names = self.tcx.names_imported_by_glob_use(item.def_id.def_id);\n+                let names = self.tcx.names_imported_by_glob_use(item.owner_id.def_id);\n                 let names: Vec<_> = names.iter().map(|n| n.to_string()).collect();\n \n                 // Otherwise it's a span with wrong macro expansion info, which\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n                 if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n-                        let access = access_from!(self.save_ctxt, item.def_id.def_id);\n+                        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n                         let span = self.span_from_span(sub_span);\n-                        let parent = self.save_ctxt.tcx.local_parent(item.def_id.def_id);\n+                        let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n                         self.dumper.import(\n                             &access,\n                             Import {\n@@ -1188,7 +1188,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 let name_span = item.ident.span;\n                 if !self.span.filter_generated(name_span) {\n                     let span = self.span_from_span(name_span);\n-                    let parent = self.save_ctxt.tcx.local_parent(item.def_id.def_id);\n+                    let parent = self.save_ctxt.tcx.local_parent(item.owner_id.def_id);\n                     self.dumper.import(\n                         &Access { public: false, reachable: false },\n                         Import {\n@@ -1228,15 +1228,15 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n                 intravisit::walk_mod(self, m, item.hir_id());\n             }\n             hir::ItemKind::TyAlias(ty, ref generics) => {\n-                let qualname = format!(\"::{}\", self.tcx.def_path_str(item.def_id.to_def_id()));\n+                let qualname = format!(\"::{}\", self.tcx.def_path_str(item.owner_id.to_def_id()));\n                 let value = ty_to_string(&ty);\n                 if !self.span.filter_generated(item.ident.span) {\n                     let span = self.span_from_span(item.ident.span);\n-                    let id = id_from_def_id(item.def_id.to_def_id());\n+                    let id = id_from_def_id(item.owner_id.to_def_id());\n                     let attrs = self.tcx.hir().attrs(item.hir_id());\n \n                     self.dumper.dump_def(\n-                        &access_from!(self.save_ctxt, item.def_id.def_id),\n+                        &access_from!(self.save_ctxt, item.owner_id.def_id),\n                         Def {\n                             kind: DefKind::Type,\n                             id,\n@@ -1324,7 +1324,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             }\n             hir::TyKind::OpaqueDef(item_id, _, _) => {\n                 let item = self.tcx.hir().item(item_id);\n-                self.nest_typeck_results(item_id.def_id.def_id, |v| v.visit_item(item));\n+                self.nest_typeck_results(item_id.owner_id.def_id, |v| v.visit_item(item));\n             }\n             _ => intravisit::walk_ty(self, t),\n         }\n@@ -1431,7 +1431,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n-        let access = access_from!(self.save_ctxt, item.def_id.def_id);\n+        let access = access_from!(self.save_ctxt, item.owner_id.def_id);\n \n         match item.kind {\n             hir::ForeignItemKind::Fn(decl, _, ref generics) => {"}, {"sha": "d0155c908a2b85893924a8e662a504579035e5af", "filename": "compiler/rustc_save_analysis/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Flib.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -141,7 +141,7 @@ impl<'tcx> SaveContext<'tcx> {\n     }\n \n     pub fn get_extern_item_data(&self, item: &hir::ForeignItem<'_>) -> Option<Data> {\n-        let def_id = item.def_id.to_def_id();\n+        let def_id = item.owner_id.to_def_id();\n         let qualname = format!(\"::{}\", self.tcx.def_path_str(def_id));\n         let attrs = self.tcx.hir().attrs(item.hir_id());\n         match item.kind {\n@@ -205,7 +205,7 @@ impl<'tcx> SaveContext<'tcx> {\n     }\n \n     pub fn get_item_data(&self, item: &hir::Item<'_>) -> Option<Data> {\n-        let def_id = item.def_id.to_def_id();\n+        let def_id = item.owner_id.to_def_id();\n         let attrs = self.tcx.hir().attrs(item.hir_id());\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, ref generics, _) => {\n@@ -297,7 +297,7 @@ impl<'tcx> SaveContext<'tcx> {\n                     children: m\n                         .item_ids\n                         .iter()\n-                        .map(|i| id_from_def_id(i.def_id.to_def_id()))\n+                        .map(|i| id_from_def_id(i.owner_id.to_def_id()))\n                         .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(attrs),\n@@ -363,7 +363,7 @@ impl<'tcx> SaveContext<'tcx> {\n                             parent: None,\n                             children: items\n                                 .iter()\n-                                .map(|i| id_from_def_id(i.id.def_id.to_def_id()))\n+                                .map(|i| id_from_def_id(i.id.owner_id.to_def_id()))\n                                 .collect(),\n                             docs: String::new(),\n                             sig: None,"}, {"sha": "83c51d213be35ed38ea2e1a5c175ab61db094df1", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -337,7 +337,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 }\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_def_id(self.def_id.to_def_id()),\n+                    id: id_from_def_id(self.owner_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -359,7 +359,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = \"const \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_def_id(self.def_id.to_def_id()),\n+                    id: id_from_def_id(self.owner_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -428,7 +428,7 @@ impl<'hir> Sig for hir::Item<'hir> {\n                 let mut text = \"mod \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_def_id(self.def_id.to_def_id()),\n+                    id: id_from_def_id(self.owner_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -764,7 +764,7 @@ impl<'hir> Sig for hir::ForeignItem<'hir> {\n                 }\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_def_id(self.def_id.to_def_id()),\n+                    id: id_from_def_id(self.owner_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];\n@@ -780,7 +780,7 @@ impl<'hir> Sig for hir::ForeignItem<'hir> {\n                 let mut text = \"type \".to_owned();\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n-                    id: id_from_def_id(self.def_id.to_def_id()),\n+                    id: id_from_def_id(self.owner_id.to_def_id()),\n                     start: offset + text.len(),\n                     end: offset + text.len() + name.len(),\n                 }];"}, {"sha": "150459ce0f53181898bbdf09d1f793abbc0a5762", "filename": "compiler/rustc_symbol_mangling/src/test.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Ftest.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -26,19 +26,19 @@ pub fn report_symbol_names(tcx: TyCtxt<'_>) {\n         let crate_items = tcx.hir_crate_items(());\n \n         for id in crate_items.items() {\n-            symbol_names.process_attrs(id.def_id.def_id);\n+            symbol_names.process_attrs(id.owner_id.def_id);\n         }\n \n         for id in crate_items.trait_items() {\n-            symbol_names.process_attrs(id.def_id.def_id);\n+            symbol_names.process_attrs(id.owner_id.def_id);\n         }\n \n         for id in crate_items.impl_items() {\n-            symbol_names.process_attrs(id.def_id.def_id);\n+            symbol_names.process_attrs(id.owner_id.def_id);\n         }\n \n         for id in crate_items.foreign_items() {\n-            symbol_names.process_attrs(id.def_id.def_id);\n+            symbol_names.process_attrs(id.owner_id.def_id);\n         }\n     })\n }"}, {"sha": "a335f8e06bc944b1258a42043ae036530ae40932", "filename": "compiler/rustc_trait_selection/src/infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Finfer.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -69,7 +69,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n         let ty = self.resolve_vars_if_possible(ty);\n \n         if !(param_env, ty).needs_infer() {\n-            return ty.is_copy_modulo_regions(self.tcx.at(span), param_env);\n+            return ty.is_copy_modulo_regions(self.tcx, param_env);\n         }\n \n         let copy_def_id = self.tcx.require_lang_item(LangItem::Copy, None);"}, {"sha": "8908fe230b0ebeee9de7da80ef350a111ed2ee5e", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -214,7 +214,9 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n         trait_ref, item, cause, pred\n     );\n     let (items, impl_def_id) = match item {\n-        Some(hir::Item { kind: hir::ItemKind::Impl(impl_), def_id, .. }) => (impl_.items, *def_id),\n+        Some(hir::Item { kind: hir::ItemKind::Impl(impl_), owner_id, .. }) => {\n+            (impl_.items, *owner_id)\n+        }\n         _ => return,\n     };\n     let fix_span =\n@@ -236,7 +238,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&projection_ty.item_def_id)\n                 && let Some(impl_item_span) = items\n                     .iter()\n-                    .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                    .find(|item| item.id.owner_id.to_def_id() == impl_item_id)\n                     .map(fix_span)\n             {\n                 cause.span = impl_item_span;\n@@ -251,7 +253,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                     tcx.impl_item_implementor_ids(impl_def_id).get(&item_def_id)\n                 && let Some(impl_item_span) = items\n                     .iter()\n-                    .find(|item| item.id.def_id.to_def_id() == impl_item_id)\n+                    .find(|item| item.id.owner_id.to_def_id() == impl_item_id)\n                     .map(fix_span)\n             {\n                 cause.span = impl_item_span;"}, {"sha": "424b52309d3af8bcc58bf1a1164d9a4f18c0839c", "filename": "compiler/rustc_ty_utils/src/assoc.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fassoc.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -17,10 +17,10 @@ fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n     let item = tcx.hir().expect_item(def_id.expect_local());\n     match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n-            trait_item_refs.iter().map(|trait_item_ref| trait_item_ref.id.def_id.to_def_id()),\n+            trait_item_refs.iter().map(|trait_item_ref| trait_item_ref.id.owner_id.to_def_id()),\n         ),\n         hir::ItemKind::Impl(ref impl_) => tcx.arena.alloc_from_iter(\n-            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.def_id.to_def_id()),\n+            impl_.items.iter().map(|impl_item_ref| impl_item_ref.id.owner_id.to_def_id()),\n         ),\n         hir::ItemKind::TraitAlias(..) => &[],\n         _ => span_bug!(item.span, \"associated_item_def_ids: not impl or trait\"),\n@@ -46,7 +46,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n     match parent_item.kind {\n         hir::ItemKind::Impl(ref impl_) => {\n             if let Some(impl_item_ref) =\n-                impl_.items.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n+                impl_.items.iter().find(|i| i.id.owner_id.to_def_id() == def_id)\n             {\n                 let assoc_item = associated_item_from_impl_item_ref(impl_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n@@ -56,7 +56,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n \n         hir::ItemKind::Trait(.., ref trait_item_refs) => {\n             if let Some(trait_item_ref) =\n-                trait_item_refs.iter().find(|i| i.id.def_id.to_def_id() == def_id)\n+                trait_item_refs.iter().find(|i| i.id.owner_id.to_def_id() == def_id)\n             {\n                 let assoc_item = associated_item_from_trait_item_ref(trait_item_ref);\n                 debug_assert_eq!(assoc_item.def_id, def_id);\n@@ -75,7 +75,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n }\n \n fn associated_item_from_trait_item_ref(trait_item_ref: &hir::TraitItemRef) -> ty::AssocItem {\n-    let def_id = trait_item_ref.id.def_id;\n+    let owner_id = trait_item_ref.id.owner_id;\n     let (kind, has_self) = match trait_item_ref.kind {\n         hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n         hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),\n@@ -85,15 +85,15 @@ fn associated_item_from_trait_item_ref(trait_item_ref: &hir::TraitItemRef) -> ty\n     ty::AssocItem {\n         name: trait_item_ref.ident.name,\n         kind,\n-        def_id: def_id.to_def_id(),\n-        trait_item_def_id: Some(def_id.to_def_id()),\n+        def_id: owner_id.to_def_id(),\n+        trait_item_def_id: Some(owner_id.to_def_id()),\n         container: ty::TraitContainer,\n         fn_has_self_parameter: has_self,\n     }\n }\n \n fn associated_item_from_impl_item_ref(impl_item_ref: &hir::ImplItemRef) -> ty::AssocItem {\n-    let def_id = impl_item_ref.id.def_id;\n+    let def_id = impl_item_ref.id.owner_id;\n     let (kind, has_self) = match impl_item_ref.kind {\n         hir::AssocItemKind::Const => (ty::AssocKind::Const, false),\n         hir::AssocItemKind::Fn { has_self } => (ty::AssocKind::Fn, has_self),"}, {"sha": "6436713b3881154043bf4288158472c3a2d28df5", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -4,7 +4,7 @@ use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::traits::CodegenObligationError;\n use rustc_middle::ty::subst::SubstsRef;\n use rustc_middle::ty::{self, Instance, TyCtxt, TypeVisitable};\n-use rustc_span::{sym, DUMMY_SP};\n+use rustc_span::sym;\n use rustc_trait_selection::traits;\n use traits::{translate_substs, Reveal};\n \n@@ -236,7 +236,7 @@ fn resolve_associated_item<'tcx>(\n                 if name == sym::clone {\n                     let self_ty = trait_ref.self_ty();\n \n-                    let is_copy = self_ty.is_copy_modulo_regions(tcx.at(DUMMY_SP), param_env);\n+                    let is_copy = self_ty.is_copy_modulo_regions(tcx, param_env);\n                     match self_ty.kind() {\n                         _ if is_copy => (),\n                         ty::Generator(..)"}, {"sha": "52ba0eee97cd5e4d526383e09bf240c0a6d298b2", "filename": "compiler/rustc_ty_utils/src/layout.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Flayout.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -399,7 +399,7 @@ fn layout_of_uncached<'tcx>(\n             }\n \n             let pointee = tcx.normalize_erasing_regions(param_env, pointee);\n-            if pointee.is_sized(tcx.at(DUMMY_SP), param_env) {\n+            if pointee.is_sized(tcx, param_env) {\n                 return Ok(tcx.intern_layout(LayoutS::scalar(cx, data_ptr)));\n             }\n \n@@ -755,8 +755,7 @@ fn layout_of_uncached<'tcx>(\n                 } else {\n                     let param_env = tcx.param_env(def.did());\n                     let last_field = def.variant(v).fields.last().unwrap();\n-                    let always_sized =\n-                        tcx.type_of(last_field.did).is_sized(tcx.at(DUMMY_SP), param_env);\n+                    let always_sized = tcx.type_of(last_field.did).is_sized(tcx, param_env);\n                     if !always_sized { StructKind::MaybeUnsized } else { StructKind::AlwaysSized }\n                 };\n "}, {"sha": "024dcd591bd77d68d321bb27a7016ee9b1b544e7", "filename": "compiler/rustc_ty_utils/src/needs_drop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fneeds_drop.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -109,7 +109,7 @@ where\n \n             for component in components {\n                 match *component.kind() {\n-                    _ if component.is_copy_modulo_regions(tcx.at(DUMMY_SP), self.param_env) => (),\n+                    _ if component.is_copy_modulo_regions(tcx, self.param_env) => (),\n \n                     ty::Closure(_, substs) => {\n                         queue_type(self, substs.as_closure().tupled_upvars_ty());"}, {"sha": "c6d42308596cb2f51ba91c7bc3485a16872413c1", "filename": "library/panic_unwind/src/emcc.rs", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/library%2Fpanic_unwind%2Fsrc%2Femcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Femcc.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -47,7 +47,12 @@ static EXCEPTION_TYPE_INFO: TypeInfo = TypeInfo {\n     name: b\"rust_panic\\0\".as_ptr(),\n };\n \n+// NOTE(nbdd0121): The `canary` field will be part of stable ABI after `c_unwind` stabilization.\n+#[repr(C)]\n struct Exception {\n+    // See `gcc.rs` on why this is present. We already have a static here so just use it.\n+    canary: *const TypeInfo,\n+\n     // This is necessary because C++ code can capture our exception with\n     // std::exception_ptr and rethrow it multiple times, possibly even in\n     // another thread.\n@@ -70,27 +75,38 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     let catch_data = &*(ptr as *mut CatchData);\n \n     let adjusted_ptr = __cxa_begin_catch(catch_data.ptr as *mut libc::c_void) as *mut Exception;\n-    let out = if catch_data.is_rust_panic {\n-        let was_caught = (*adjusted_ptr).caught.swap(true, Ordering::SeqCst);\n-        if was_caught {\n-            // Since cleanup() isn't allowed to panic, we just abort instead.\n-            intrinsics::abort();\n-        }\n-        (*adjusted_ptr).data.take().unwrap()\n-    } else {\n+    if !catch_data.is_rust_panic {\n         super::__rust_foreign_exception();\n-    };\n+    }\n+\n+    let canary = ptr::addr_of!((*adjusted_ptr).canary).read();\n+    if !ptr::eq(canary, &EXCEPTION_TYPE_INFO) {\n+        super::__rust_foreign_exception();\n+    }\n+\n+    let was_caught = (*adjusted_ptr).caught.swap(true, Ordering::SeqCst);\n+    if was_caught {\n+        // Since cleanup() isn't allowed to panic, we just abort instead.\n+        intrinsics::abort();\n+    }\n+    let out = (*adjusted_ptr).data.take().unwrap();\n     __cxa_end_catch();\n     out\n }\n \n pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n-    let sz = mem::size_of_val(&data);\n-    let exception = __cxa_allocate_exception(sz) as *mut Exception;\n+    let exception = __cxa_allocate_exception(mem::size_of::<Exception>()) as *mut Exception;\n     if exception.is_null() {\n         return uw::_URC_FATAL_PHASE1_ERROR as u32;\n     }\n-    ptr::write(exception, Exception { caught: AtomicBool::new(false), data: Some(data) });\n+    ptr::write(\n+        exception,\n+        Exception {\n+            canary: &EXCEPTION_TYPE_INFO,\n+            caught: AtomicBool::new(false),\n+            data: Some(data),\n+        },\n+    );\n     __cxa_throw(exception as *mut _, &EXCEPTION_TYPE_INFO, exception_cleanup);\n }\n "}, {"sha": "0b7a873a691cc020f70e693307e624f00dbaaef1", "filename": "library/panic_unwind/src/gcc.rs", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fgcc.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -38,12 +38,23 @@\n \n use alloc::boxed::Box;\n use core::any::Any;\n+use core::ptr;\n \n use unwind as uw;\n \n+// In case where multiple copies of std exist in a single process,\n+// we use address of this static variable to distinguish an exception raised by\n+// this copy and some other copy (which needs to be treated as foreign exception).\n+static CANARY: u8 = 0;\n+\n+// NOTE(nbdd0121)\n+// Once `c_unwind` feature is stabilized, there will be ABI stability requirement\n+// on this struct. The first two field must be `_Unwind_Exception` and `canary`,\n+// as it may be accessed by a different version of the std with a different compiler.\n #[repr(C)]\n struct Exception {\n     _uwe: uw::_Unwind_Exception,\n+    canary: *const u8,\n     cause: Box<dyn Any + Send>,\n }\n \n@@ -54,6 +65,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n             exception_cleanup,\n             private: [0; uw::unwinder_private_data_size],\n         },\n+        canary: &CANARY,\n         cause: data,\n     });\n     let exception_param = Box::into_raw(exception) as *mut uw::_Unwind_Exception;\n@@ -75,10 +87,22 @@ pub unsafe fn cleanup(ptr: *mut u8) -> Box<dyn Any + Send> {\n     if (*exception).exception_class != rust_exception_class() {\n         uw::_Unwind_DeleteException(exception);\n         super::__rust_foreign_exception();\n-    } else {\n-        let exception = Box::from_raw(exception as *mut Exception);\n-        exception.cause\n     }\n+\n+    let exception = exception.cast::<Exception>();\n+    // Just access the canary field, avoid accessing the entire `Exception` as\n+    // it can be a foreign Rust exception.\n+    let canary = ptr::addr_of!((*exception).canary).read();\n+    if !ptr::eq(canary, &CANARY) {\n+        // A foreign Rust exception, treat it slightly differently from other\n+        // foreign exceptions, because call into `_Unwind_DeleteException` will\n+        // call into `__rust_drop_panic` which produces a confusing\n+        // \"Rust panic must be rethrown\" message.\n+        super::__rust_foreign_exception();\n+    }\n+\n+    let exception = Box::from_raw(exception as *mut Exception);\n+    exception.cause\n }\n \n // Rust's exception class identifier.  This is used by personality routines to"}, {"sha": "651115a8248ac50886c88de41fc1cabc71f66626", "filename": "library/panic_unwind/src/seh.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/library%2Fpanic_unwind%2Fsrc%2Fseh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_unwind%2Fsrc%2Fseh.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -49,9 +49,15 @@\n use alloc::boxed::Box;\n use core::any::Any;\n use core::mem::{self, ManuallyDrop};\n+use core::ptr;\n use libc::{c_int, c_uint, c_void};\n \n+// NOTE(nbdd0121): The `canary` field will be part of stable ABI after `c_unwind` stabilization.\n+#[repr(C)]\n struct Exception {\n+    // See `gcc.rs` on why this is present. We already have a static here so just use it.\n+    canary: *const _TypeDescriptor,\n+\n     // This needs to be an Option because we catch the exception by reference\n     // and its destructor is executed by the C++ runtime. When we take the Box\n     // out of the exception, we need to leave the exception in a valid state\n@@ -235,7 +241,7 @@ static mut TYPE_DESCRIPTOR: _TypeDescriptor = _TypeDescriptor {\n macro_rules! define_cleanup {\n     ($abi:tt $abi2:tt) => {\n         unsafe extern $abi fn exception_cleanup(e: *mut Exception) {\n-            if let Exception { data: Some(b) } = e.read() {\n+            if let Exception { data: Some(b), .. } = e.read() {\n                 drop(b);\n                 super::__rust_drop_panic();\n             }\n@@ -265,7 +271,7 @@ pub unsafe fn panic(data: Box<dyn Any + Send>) -> u32 {\n     // The ManuallyDrop is needed here since we don't want Exception to be\n     // dropped when unwinding. Instead it will be dropped by exception_cleanup\n     // which is invoked by the C++ runtime.\n-    let mut exception = ManuallyDrop::new(Exception { data: Some(data) });\n+    let mut exception = ManuallyDrop::new(Exception { canary: &TYPE_DESCRIPTOR, data: Some(data) });\n     let throw_ptr = &mut exception as *mut _ as *mut _;\n \n     // This... may seems surprising, and justifiably so. On 32-bit MSVC the\n@@ -321,8 +327,12 @@ pub unsafe fn cleanup(payload: *mut u8) -> Box<dyn Any + Send> {\n     // __rust_try. This happens when a non-Rust foreign exception is caught.\n     if payload.is_null() {\n         super::__rust_foreign_exception();\n-    } else {\n-        let exception = &mut *(payload as *mut Exception);\n-        exception.data.take().unwrap()\n     }\n+    let exception = payload as *mut Exception;\n+    let canary = ptr::addr_of!((*exception).canary).read();\n+    if !ptr::eq(canary, &TYPE_DESCRIPTOR) {\n+        // A foreign Rust exception.\n+        super::__rust_foreign_exception();\n+    }\n+    (*exception).data.take().unwrap()\n }"}, {"sha": "708edc5de4751f0232f04ca98e1d7f6acbf3cc87", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -759,7 +759,7 @@ where\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n     /// in the `HashMap`. The collection may reserve more space to speculatively\n-    /// avoid frequent reallocations. After calling `reserve`,\n+    /// avoid frequent reallocations. After calling `try_reserve`,\n     /// capacity will be greater than or equal to `self.len() + additional` if\n     /// it returns `Ok(())`.\n     /// Does nothing if capacity is already sufficient."}, {"sha": "cee884145c7116fd3f695389b94a4ad3501475ca", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -462,7 +462,7 @@ where\n \n     /// Tries to reserve capacity for at least `additional` more elements to be inserted\n     /// in the `HashSet`. The collection may reserve more space to speculatively\n-    /// avoid frequent reallocations. After calling `reserve`,\n+    /// avoid frequent reallocations. After calling `try_reserve`,\n     /// capacity will be greater than or equal to `self.len() + additional` if\n     /// it returns `Ok(())`.\n     /// Does nothing if capacity is already sufficient."}, {"sha": "7edd3c12041436aaff4b1334228719fbe0c4324e", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -1418,7 +1418,7 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n         }\n         let mut flags = if is_rustdoc { Vec::new() } else { vec![\"-Crpath\".to_string()] };\n         flags.push(format!(\"-Cdebuginfo={}\", builder.config.rust_debuginfo_level_tests));\n-        flags.push(builder.config.cmd.rustc_args().join(\" \"));\n+        flags.extend(builder.config.cmd.rustc_args().iter().map(|s| s.to_string()));\n \n         if let Some(linker) = builder.linker(target) {\n             cmd.arg(\"--linker\").arg(linker);\n@@ -1427,12 +1427,16 @@ note: if you're sure you want to do this, please open an issue as to why. In the\n         let mut hostflags = flags.clone();\n         hostflags.push(format!(\"-Lnative={}\", builder.test_helpers_out(compiler.host).display()));\n         hostflags.extend(builder.lld_flags(compiler.host));\n-        cmd.arg(\"--host-rustcflags\").arg(hostflags.join(\" \"));\n+        for flag in hostflags {\n+            cmd.arg(\"--host-rustcflags\").arg(flag);\n+        }\n \n         let mut targetflags = flags;\n         targetflags.push(format!(\"-Lnative={}\", builder.test_helpers_out(target).display()));\n         targetflags.extend(builder.lld_flags(target));\n-        cmd.arg(\"--target-rustcflags\").arg(targetflags.join(\" \"));\n+        for flag in targetflags {\n+            cmd.arg(\"--target-rustcflags\").arg(flag);\n+        }\n \n         cmd.arg(\"--python\").arg(builder.python());\n "}, {"sha": "764a6d3aa48cf4eb5d917a4ac46ad6386f143556", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -148,7 +148,7 @@ where\n             })\n             .collect();\n         // We are only interested in case the type *doesn't* implement the Sized trait.\n-        if !ty.is_sized(tcx.at(rustc_span::DUMMY_SP), param_env) {\n+        if !ty.is_sized(tcx, param_env) {\n             // In case `#![no_core]` is used, `sized_trait` returns nothing.\n             if let Some(item) = tcx.lang_items().sized_trait().and_then(|sized_trait_did| {\n                 self.generate_for_trait(ty, sized_trait_did, param_env, item_def_id, &f, true)"}, {"sha": "64a18757b26e5f166770913e93b732b00c012460", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -1042,7 +1042,7 @@ fn clean_poly_trait_ref<'tcx>(\n }\n \n fn clean_trait_item<'tcx>(trait_item: &hir::TraitItem<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n-    let local_did = trait_item.def_id.to_def_id();\n+    let local_did = trait_item.owner_id.to_def_id();\n     cx.with_param_env(local_did, |cx| {\n         let inner = match trait_item.kind {\n             hir::TraitItemKind::Const(ty, Some(default)) => AssocConstItem(\n@@ -1094,7 +1094,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n     impl_: &hir::ImplItem<'tcx>,\n     cx: &mut DocContext<'tcx>,\n ) -> Item {\n-    let local_did = impl_.def_id.to_def_id();\n+    let local_did = impl_.owner_id.to_def_id();\n     cx.with_param_env(local_did, |cx| {\n         let inner = match impl_.kind {\n             hir::ImplItemKind::Const(ty, expr) => {\n@@ -1103,7 +1103,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n             }\n             hir::ImplItemKind::Fn(ref sig, body) => {\n                 let m = clean_function(cx, sig, impl_.generics, body);\n-                let defaultness = cx.tcx.impl_defaultness(impl_.def_id);\n+                let defaultness = cx.tcx.impl_defaultness(impl_.owner_id);\n                 MethodItem(m, Some(defaultness))\n             }\n             hir::ImplItemKind::Type(hir_ty) => {\n@@ -1120,7 +1120,7 @@ pub(crate) fn clean_impl_item<'tcx>(\n         let mut what_rustc_thinks =\n             Item::from_def_id_and_parts(local_did, Some(impl_.ident.name), inner, cx);\n \n-        let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(impl_.def_id.def_id));\n+        let impl_ref = cx.tcx.impl_trait_ref(cx.tcx.local_parent(impl_.owner_id.def_id));\n \n         // Trait impl items always inherit the impl's visibility --\n         // we don't want to show `pub`.\n@@ -1958,7 +1958,7 @@ fn clean_maybe_renamed_item<'tcx>(\n ) -> Vec<Item> {\n     use hir::ItemKind;\n \n-    let def_id = item.def_id.to_def_id();\n+    let def_id = item.owner_id.to_def_id();\n     let mut name = renamed.unwrap_or_else(|| cx.tcx.hir().name(item.hir_id()));\n     cx.with_param_env(def_id, |cx| {\n         let kind = match item.kind {\n@@ -2100,11 +2100,11 @@ fn clean_extern_crate<'tcx>(\n     cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     // this is the ID of the `extern crate` statement\n-    let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id.def_id).unwrap_or(LOCAL_CRATE);\n+    let cnum = cx.tcx.extern_mod_stmt_cnum(krate.owner_id.def_id).unwrap_or(LOCAL_CRATE);\n     // this is the ID of the crate itself\n     let crate_def_id = cnum.as_def_id();\n     let attrs = cx.tcx.hir().attrs(krate.hir_id());\n-    let ty_vis = cx.tcx.visibility(krate.def_id);\n+    let ty_vis = cx.tcx.visibility(krate.owner_id);\n     let please_inline = ty_vis.is_public()\n         && attrs.iter().any(|a| {\n             a.has_name(sym::doc)\n@@ -2122,7 +2122,7 @@ fn clean_extern_crate<'tcx>(\n         if let Some(items) = inline::try_inline(\n             cx,\n             cx.tcx.parent_module(krate.hir_id()).to_def_id(),\n-            Some(krate.def_id.to_def_id()),\n+            Some(krate.owner_id.to_def_id()),\n             res,\n             name,\n             Some(attrs),\n@@ -2158,11 +2158,11 @@ fn clean_use_statement<'tcx>(\n         return Vec::new();\n     }\n \n-    let visibility = cx.tcx.visibility(import.def_id);\n+    let visibility = cx.tcx.visibility(import.owner_id);\n     let attrs = cx.tcx.hir().attrs(import.hir_id());\n     let inline_attr = attrs.lists(sym::doc).get_word_attr(sym::inline);\n     let pub_underscore = visibility.is_public() && name == kw::Underscore;\n-    let current_mod = cx.tcx.parent_module_from_def_id(import.def_id.def_id);\n+    let current_mod = cx.tcx.parent_module_from_def_id(import.owner_id.def_id);\n \n     // The parent of the module in which this import resides. This\n     // is the same as `current_mod` if that's already the top\n@@ -2233,7 +2233,7 @@ fn clean_use_statement<'tcx>(\n         }\n         if !denied {\n             let mut visited = FxHashSet::default();\n-            let import_def_id = import.def_id.to_def_id();\n+            let import_def_id = import.owner_id.to_def_id();\n \n             if let Some(mut items) = inline::try_inline(\n                 cx,\n@@ -2256,15 +2256,15 @@ fn clean_use_statement<'tcx>(\n         Import::new_simple(name, resolve_use_source(cx, path), true)\n     };\n \n-    vec![Item::from_def_id_and_parts(import.def_id.to_def_id(), None, ImportItem(inner), cx)]\n+    vec![Item::from_def_id_and_parts(import.owner_id.to_def_id(), None, ImportItem(inner), cx)]\n }\n \n fn clean_maybe_renamed_foreign_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::ForeignItem<'tcx>,\n     renamed: Option<Symbol>,\n ) -> Item {\n-    let def_id = item.def_id.to_def_id();\n+    let def_id = item.owner_id.to_def_id();\n     cx.with_param_env(def_id, |cx| {\n         let kind = match item.kind {\n             hir::ForeignItemKind::Fn(decl, names, generics) => {"}, {"sha": "cd1f972dce8441b0b0c7407bc1a6b65522310ee2", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -240,13 +240,13 @@ impl ExternalCrate {\n                     let item = tcx.hir().item(id);\n                     match item.kind {\n                         hir::ItemKind::Mod(_) => {\n-                            as_keyword(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                            as_keyword(Res::Def(DefKind::Mod, id.owner_id.to_def_id()))\n                         }\n                         hir::ItemKind::Use(path, hir::UseKind::Single)\n-                            if tcx.visibility(id.def_id).is_public() =>\n+                            if tcx.visibility(id.owner_id).is_public() =>\n                         {\n                             as_keyword(path.res.expect_non_local())\n-                                .map(|(_, prim)| (id.def_id.to_def_id(), prim))\n+                                .map(|(_, prim)| (id.owner_id.to_def_id(), prim))\n                         }\n                         _ => None,\n                     }\n@@ -308,14 +308,14 @@ impl ExternalCrate {\n                     let item = tcx.hir().item(id);\n                     match item.kind {\n                         hir::ItemKind::Mod(_) => {\n-                            as_primitive(Res::Def(DefKind::Mod, id.def_id.to_def_id()))\n+                            as_primitive(Res::Def(DefKind::Mod, id.owner_id.to_def_id()))\n                         }\n                         hir::ItemKind::Use(path, hir::UseKind::Single)\n-                            if tcx.visibility(id.def_id).is_public() =>\n+                            if tcx.visibility(id.owner_id).is_public() =>\n                         {\n                             as_primitive(path.res.expect_non_local()).map(|(_, prim)| {\n                                 // Pretend the primitive is local.\n-                                (id.def_id.to_def_id(), prim)\n+                                (id.owner_id.to_def_id(), prim)\n                             })\n                         }\n                         _ => None,"}, {"sha": "0089ce63d07ba0c801a401a205cd1a5e6c5665ea", "filename": "src/librustdoc/passes/stripper.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Flibrustdoc%2Fpasses%2Fstripper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fstripper.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -1,9 +1,11 @@\n //! A collection of utility functions for the `strip_*` passes.\n use rustc_hir::def_id::DefId;\n use rustc_middle::middle::privacy::EffectiveVisibilities;\n+use rustc_span::symbol::sym;\n+\n use std::mem;\n \n-use crate::clean::{self, Item, ItemId, ItemIdSet};\n+use crate::clean::{self, Item, ItemId, ItemIdSet, NestedAttributesExt};\n use crate::fold::{strip_item, DocFolder};\n use crate::formats::cache::Cache;\n \n@@ -151,6 +153,22 @@ pub(crate) struct ImplStripper<'a> {\n     pub(crate) document_private: bool,\n }\n \n+impl<'a> ImplStripper<'a> {\n+    #[inline]\n+    fn should_keep_impl(&self, item: &Item, for_def_id: DefId) -> bool {\n+        if !for_def_id.is_local() || self.retained.contains(&for_def_id.into()) {\n+            true\n+        } else if self.is_json_output {\n+            // If the \"for\" item is exported and the impl block isn't `#[doc(hidden)]`, then we\n+            // need to keep it.\n+            self.cache.effective_visibilities.is_exported(for_def_id)\n+                && !item.attrs.lists(sym::doc).has_word(sym::hidden)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n impl<'a> DocFolder for ImplStripper<'a> {\n     fn fold_item(&mut self, i: Item) -> Option<Item> {\n         if let clean::ImplItem(ref imp) = *i.kind {\n@@ -178,23 +196,25 @@ impl<'a> DocFolder for ImplStripper<'a> {\n                     return None;\n                 }\n             }\n+            // Because we don't inline in `maybe_inline_local` if the output format is JSON,\n+            // we need to make a special check for JSON output: we want to keep it unless it has\n+            // a `#[doc(hidden)]` attribute if the `for_` type is exported.\n             if let Some(did) = imp.for_.def_id(self.cache) {\n-                if did.is_local() && !imp.for_.is_assoc_ty() && !self.retained.contains(&did.into())\n-                {\n+                if !imp.for_.is_assoc_ty() && !self.should_keep_impl(&i, did) {\n                     debug!(\"ImplStripper: impl item for stripped type; removing\");\n                     return None;\n                 }\n             }\n             if let Some(did) = imp.trait_.as_ref().map(|t| t.def_id()) {\n-                if did.is_local() && !self.retained.contains(&did.into()) {\n+                if !self.should_keep_impl(&i, did) {\n                     debug!(\"ImplStripper: impl item for stripped trait; removing\");\n                     return None;\n                 }\n             }\n             if let Some(generics) = imp.trait_.as_ref().and_then(|t| t.generics()) {\n                 for typaram in generics {\n                     if let Some(did) = typaram.def_id(self.cache) {\n-                        if did.is_local() && !self.retained.contains(&did.into()) {\n+                        if !self.should_keep_impl(&i, did) {\n                             debug!(\n                                 \"ImplStripper: stripped item in trait's generics; removing impl\"\n                             );"}, {"sha": "06dffce555f956579444c0cecb90ea956906966e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -295,11 +295,11 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n \n-        let def_id = item.def_id.to_def_id();\n+        let def_id = item.owner_id.to_def_id();\n         let is_pub = self.cx.tcx.visibility(def_id).is_public();\n \n         if is_pub {\n-            self.store_path(item.def_id.to_def_id());\n+            self.store_path(item.owner_id.to_def_id());\n         }\n \n         match item.kind {\n@@ -360,7 +360,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 // 3. We're inlining, since a reexport where inlining has been requested\n                 //    should be inlined even if it is also documented at the top level.\n \n-                let def_id = item.def_id.to_def_id();\n+                let def_id = item.owner_id.to_def_id();\n                 let is_macro_2_0 = !macro_def.macro_rules;\n                 let nonexported = !self.cx.tcx.has_attr(def_id, sym::macro_export);\n \n@@ -405,7 +405,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om: &mut Module<'tcx>,\n     ) {\n         // If inlining we only want to include public functions.\n-        if !self.inlining || self.cx.tcx.visibility(item.def_id).is_public() {\n+        if !self.inlining || self.cx.tcx.visibility(item.owner_id).is_public() {\n             om.foreigns.push((item, renamed));\n         }\n     }"}, {"sha": "50fca7f24e616d70b91028681ca0c901810987fc", "filename": "src/test/run-make-fulldeps/foreign-rust-exceptions/Makefile", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2FMakefile?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -0,0 +1,11 @@\n+# ignore-i686-pc-windows-gnu\n+\n+# This test doesn't work on 32-bit MinGW as cdylib has its own copy of unwinder\n+# so cross-DLL unwinding does not work.\n+\n+include ../tools.mk\n+\n+all:\n+\t$(RUSTC) bar.rs --crate-type=cdylib\n+\t$(RUSTC) foo.rs\n+\t$(call RUN,foo) 2>&1 | $(CGREP) \"Rust cannot catch foreign exceptions\""}, {"sha": "5f9efe323609b8d857fb90de218fcfb93e72ba42", "filename": "src/test/run-make-fulldeps/foreign-rust-exceptions/bar.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Fbar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Fbar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Fbar.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -0,0 +1,7 @@\n+#![crate_type = \"cdylib\"]\n+#![feature(c_unwind)]\n+\n+#[no_mangle]\n+extern \"C-unwind\" fn panic() {\n+    panic!();\n+}"}, {"sha": "266987c5b6d63b117c1deeeb37535b917e52730e", "filename": "src/test/run-make-fulldeps/foreign-rust-exceptions/foo.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fforeign-rust-exceptions%2Ffoo.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -0,0 +1,13 @@\n+#![feature(c_unwind)]\n+\n+#[cfg_attr(not(windows), link(name = \"bar\"))]\n+#[cfg_attr(windows, link(name = \"bar.dll\"))]\n+extern \"C-unwind\" {\n+    fn panic();\n+}\n+\n+fn main() {\n+    let _ = std::panic::catch_unwind(|| {\n+        unsafe { panic() };\n+    });\n+}"}, {"sha": "a6c60df83a63c7b9fb9e011ab40fc2a4210a8087", "filename": "src/test/run-make-fulldeps/obtain-borrowck/driver.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fobtain-borrowck%2Fdriver.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -69,25 +69,25 @@ impl rustc_driver::Callbacks for CompilerCalls {\n \n             let crate_items = tcx.hir_crate_items(());\n             for id in crate_items.items() {\n-                if matches!(tcx.def_kind(id.def_id), DefKind::Fn) {\n-                    bodies.push(id.def_id);\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::Fn) {\n+                    bodies.push(id.owner_id);\n                 }\n             }\n \n             for id in crate_items.trait_items() {\n-                if matches!(tcx.def_kind(id.def_id), DefKind::AssocFn) {\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::AssocFn) {\n                     let trait_item = hir.trait_item(id);\n                     if let rustc_hir::TraitItemKind::Fn(_, trait_fn) = &trait_item.kind {\n                         if let rustc_hir::TraitFn::Provided(_) = trait_fn {\n-                            bodies.push(trait_item.def_id);\n+                            bodies.push(trait_item.owner_id);\n                         }\n                     }\n                 }\n             }\n \n             for id in crate_items.impl_items() {\n-                if matches!(tcx.def_kind(id.def_id), DefKind::AssocFn) {\n-                    bodies.push(id.def_id);\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::AssocFn) {\n+                    bodies.push(id.owner_id);\n                 }\n             }\n "}, {"sha": "239b1a23b43d7e0e8c017cd8b5b2d40246c64861", "filename": "src/test/rustdoc-json/reexport/reexport_method_from_private_module.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Frustdoc-json%2Freexport%2Freexport_method_from_private_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Frustdoc-json%2Freexport%2Freexport_method_from_private_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-json%2Freexport%2Freexport_method_from_private_module.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for <https://github.com/rust-lang/rust/issues/102583>.\n+\n+// @set impl_S = \"$.index[*][?(@.docs=='impl S')].id\"\n+// @has \"$.index[*][?(@.name=='S')].inner.impls[*]\" $impl_S\n+// @set is_present = \"$.index[*][?(@.name=='is_present')].id\"\n+// @is \"$.index[*][?(@.docs=='impl S')].inner.items[*]\" $is_present\n+// @!has \"$.index[*][?(@.name=='hidden_impl')]\"\n+// @!has \"$.index[*][?(@.name=='hidden_fn')]\"\n+\n+#![no_std]\n+\n+mod private_mod {\n+    pub struct S;\n+\n+    /// impl S\n+    impl S {\n+        pub fn is_present() {}\n+        #[doc(hidden)]\n+        pub fn hidden_fn() {}\n+    }\n+\n+    #[doc(hidden)]\n+    impl S {\n+        pub fn hidden_impl() {}\n+    }\n+}\n+\n+pub use private_mod::*;"}, {"sha": "67240c8e8da064fa4a7efc004e1fcbe8d4fb7150", "filename": "src/test/ui/dyn-star/no-explicit-dyn-star-cast.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star-cast.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -0,0 +1,13 @@\n+use std::fmt::Debug;\n+\n+fn make_dyn_star() {\n+    let i = 42usize;\n+    let dyn_i: dyn* Debug = i as dyn* Debug;\n+    //~^ ERROR casting `usize` as `dyn* Debug` is invalid\n+    //~| ERROR dyn* trait objects are unstable\n+    //~| ERROR dyn* trait objects are unstable\n+}\n+\n+fn main() {\n+    make_dyn_star();\n+}"}, {"sha": "687d7db046478b5d0b551ae3754a712ca704b812", "filename": "src/test/ui/dyn-star/no-explicit-dyn-star-cast.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star-cast.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star-cast.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star-cast.stderr?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -0,0 +1,28 @@\n+error[E0658]: dyn* trait objects are unstable\n+  --> $DIR/no-explicit-dyn-star-cast.rs:5:16\n+   |\n+LL |     let dyn_i: dyn* Debug = i as dyn* Debug;\n+   |                ^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = help: add `#![feature(dyn_star)]` to the crate attributes to enable\n+\n+error[E0658]: dyn* trait objects are unstable\n+  --> $DIR/no-explicit-dyn-star-cast.rs:5:34\n+   |\n+LL |     let dyn_i: dyn* Debug = i as dyn* Debug;\n+   |                                  ^^^^^^^^^^\n+   |\n+   = note: see issue #91611 <https://github.com/rust-lang/rust/issues/91611> for more information\n+   = help: add `#![feature(dyn_star)]` to the crate attributes to enable\n+\n+error[E0606]: casting `usize` as `dyn* Debug` is invalid\n+  --> $DIR/no-explicit-dyn-star-cast.rs:5:29\n+   |\n+LL |     let dyn_i: dyn* Debug = i as dyn* Debug;\n+   |                             ^^^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0606, E0658.\n+For more information about an error, try `rustc --explain E0606`."}, {"sha": "4f726b7c6a69f815ebc7c8e0e19a08995896de2b", "filename": "src/test/ui/dyn-star/no-explicit-dyn-star.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -0,0 +1,8 @@\n+// aux-build:dyn-star-foreign.rs\n+\n+extern crate dyn_star_foreign;\n+\n+fn main() {\n+    dyn_star_foreign::require_dyn_star_display(1usize as _);\n+    //~^ ERROR casting `usize` as `dyn* std::fmt::Display` is invalid\n+}"}, {"sha": "49706fae19e235959710020b81170b84535ab5ff", "filename": "src/test/ui/dyn-star/no-explicit-dyn-star.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdyn-star%2Fno-explicit-dyn-star.stderr?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -0,0 +1,9 @@\n+error[E0606]: casting `usize` as `dyn* std::fmt::Display` is invalid\n+  --> $DIR/no-explicit-dyn-star.rs:6:48\n+   |\n+LL |     dyn_star_foreign::require_dyn_star_display(1usize as _);\n+   |                                                ^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0606`."}, {"sha": "b9509ca656f7a170117e115cf0a6cd47023eee80", "filename": "src/tools/clippy/clippy_lints/src/casts/ptr_as_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcasts%2Fptr_as_ptr.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -26,7 +26,7 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, msrv: Option<RustcVer\n             (Mutability::Not, Mutability::Not) | (Mutability::Mut, Mutability::Mut));\n         // The `U` in `pointer::cast` have to be `Sized`\n         // as explained here: https://github.com/rust-lang/rust/issues/60602.\n-        if to_pointee_ty.is_sized(cx.tcx.at(expr.span), cx.param_env);\n+        if to_pointee_ty.is_sized(cx.tcx, cx.param_env);\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let cast_expr_sugg = Sugg::hir_with_applicability(cx, cast_expr, \"_\", &mut applicability);"}, {"sha": "e38f77268530113414767597feb7ccb767804ae2", "filename": "src/tools/clippy/clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -43,7 +43,7 @@ impl<'tcx> LateLintPass<'tcx> for CopyIterator {\n                 of_trait: Some(ref trait_ref),\n                 ..\n             }) = item.kind;\n-            let ty = cx.tcx.type_of(item.def_id);\n+            let ty = cx.tcx.type_of(item.owner_id);\n             if is_copy(cx, ty);\n             if let Some(trait_id) = trait_ref.trait_def_id();\n             if cx.tcx.is_diagnostic_item(sym::Iterator, trait_id);"}, {"sha": "dec357ab75c3662064a0e1794758b9abb005f037", "filename": "src/tools/clippy/clippy_lints/src/default_union_representation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_union_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_union_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdefault_union_representation.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -61,7 +61,7 @@ impl<'tcx> LateLintPass<'tcx> for DefaultUnionRepresentation {\n                 None,\n                 &format!(\n                     \"consider annotating `{}` with `#[repr(C)]` to explicitly specify memory layout\",\n-                    cx.tcx.def_path_str(item.def_id.to_def_id())\n+                    cx.tcx.def_path_str(item.owner_id.to_def_id())\n                 ),\n             );\n         }"}, {"sha": "a37ee82d4c8ac16c22df9be5e589f5abcf396ac3", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -29,7 +29,7 @@ use rustc_middle::ty::{\n };\n use rustc_semver::RustcVersion;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::{symbol::sym, Span, Symbol, DUMMY_SP};\n+use rustc_span::{symbol::sym, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::{query::evaluate_obligation::InferCtxtExt as _, Obligation, ObligationCause};\n use std::collections::VecDeque;\n@@ -715,47 +715,47 @@ fn walk_parents<'tcx>(\n             },\n             Node::Item(&Item {\n                 kind: ItemKind::Static(..) | ItemKind::Const(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             })\n             | Node::TraitItem(&TraitItem {\n                 kind: TraitItemKind::Const(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             })\n             | Node::ImplItem(&ImplItem {\n                 kind: ImplItemKind::Const(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             }) if span.ctxt() == ctxt => {\n-                let ty = cx.tcx.type_of(def_id.def_id);\n+                let ty = cx.tcx.type_of(owner_id.def_id);\n                 Some(ty_auto_deref_stability(cx, ty, precedence).position_for_result(cx))\n             },\n \n             Node::Item(&Item {\n                 kind: ItemKind::Fn(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             })\n             | Node::TraitItem(&TraitItem {\n                 kind: TraitItemKind::Fn(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             })\n             | Node::ImplItem(&ImplItem {\n                 kind: ImplItemKind::Fn(..),\n-                def_id,\n+                owner_id,\n                 span,\n                 ..\n             }) if span.ctxt() == ctxt => {\n                 let output = cx\n                     .tcx\n-                    .erase_late_bound_regions(cx.tcx.fn_sig(def_id.to_def_id()).output());\n+                    .erase_late_bound_regions(cx.tcx.fn_sig(owner_id.to_def_id()).output());\n                 Some(ty_auto_deref_stability(cx, output, precedence).position_for_result(cx))\n             },\n \n@@ -990,7 +990,7 @@ fn binding_ty_auto_deref_stability<'tcx>(\n                                 cx.typeck_results().node_type(ty.ty.hir_id),\n                                 binder_args,\n                             ))\n-                            .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                            .is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n                     )\n                 }\n             },\n@@ -1005,7 +1005,7 @@ fn binding_ty_auto_deref_stability<'tcx>(\n                         cx.typeck_results().node_type(ty.ty.hir_id),\n                         binder_args,\n                     ))\n-                    .is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                    .is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n             ),\n             TyKind::OpaqueDef(..) | TyKind::Infer | TyKind::Typeof(..) | TyKind::TraitObject(..) | TyKind::Err => {\n                 Position::ReborrowStable(precedence)\n@@ -1297,7 +1297,7 @@ impl<'tcx> TyPosition<'tcx> {\n     fn position_for_result(self, cx: &LateContext<'tcx>) -> Position {\n         match (self.position, self.ty) {\n             (Position::ReborrowStable(precedence), Some(ty)) => {\n-                Position::DerefStable(precedence, ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env))\n+                Position::DerefStable(precedence, ty.is_sized(cx.tcx, cx.param_env))\n             },\n             (position, _) => position,\n         }\n@@ -1348,7 +1348,7 @@ fn ty_auto_deref_stability<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, precedenc\n             | ty::Tuple(_)\n             | ty::Projection(_) => Position::DerefStable(\n                 precedence,\n-                ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env.without_caller_bounds()),\n+                ty.is_sized(cx.tcx, cx.param_env.without_caller_bounds()),\n             )\n             .into(),\n         };"}, {"sha": "ae8f6b794499fc47439d2a093fc45944dc47452a", "filename": "src/tools/clippy/clippy_lints/src/derivable_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderivable_impls.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -70,15 +70,15 @@ impl<'tcx> LateLintPass<'tcx> for DerivableImpls {\n                 self_ty,\n                 ..\n             }) = item.kind;\n-            if !cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n+            if !cx.tcx.has_attr(item.owner_id.to_def_id(), sym::automatically_derived);\n             if !item.span.from_expansion();\n             if let Some(def_id) = trait_ref.trait_def_id();\n             if cx.tcx.is_diagnostic_item(sym::Default, def_id);\n             if let impl_item_hir = child.id.hir_id();\n             if let Some(Node::ImplItem(impl_item)) = cx.tcx.hir().find(impl_item_hir);\n             if let ImplItemKind::Fn(_, b) = &impl_item.kind;\n             if let Body { value: func_expr, .. } = cx.tcx.hir().body(*b);\n-            if let Some(adt_def) = cx.tcx.type_of(item.def_id).ty_adt_def();\n+            if let Some(adt_def) = cx.tcx.type_of(item.owner_id).ty_adt_def();\n             if let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|attr| attr.doc_str().is_some());\n             if let child_attrs = cx.tcx.hir().attrs(impl_item_hir);"}, {"sha": "102a02138bc87e783bf179bc0d7da5a6ae6044e2", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -210,8 +210,8 @@ impl<'tcx> LateLintPass<'tcx> for Derive {\n             ..\n         }) = item.kind\n         {\n-            let ty = cx.tcx.type_of(item.def_id);\n-            let is_automatically_derived = cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n+            let ty = cx.tcx.type_of(item.owner_id);\n+            let is_automatically_derived = cx.tcx.has_attr(item.owner_id.to_def_id(), sym::automatically_derived);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);\n             check_ord_partial_ord(cx, item.span, trait_ref, ty, is_automatically_derived);"}, {"sha": "24d6a6951af8b3aaa7320ccb32cf314bc5857530", "filename": "src/tools/clippy/clippy_lints/src/doc.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdoc.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -257,17 +257,17 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         let headers = check_attrs(cx, &self.valid_idents, attrs);\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, _, body_id) => {\n-                if !(is_entrypoint_fn(cx, item.def_id.to_def_id()) || in_external_macro(cx.tcx.sess, item.span)) {\n+                if !(is_entrypoint_fn(cx, item.owner_id.to_def_id()) || in_external_macro(cx.tcx.sess, item.span)) {\n                     let body = cx.tcx.hir().body(body_id);\n                     let mut fpu = FindPanicUnwrap {\n                         cx,\n-                        typeck_results: cx.tcx.typeck(item.def_id.def_id),\n+                        typeck_results: cx.tcx.typeck(item.owner_id.def_id),\n                         panic_span: None,\n                     };\n                     fpu.visit_expr(body.value);\n                     lint_for_missing_headers(\n                         cx,\n-                        item.def_id.def_id,\n+                        item.owner_id.def_id,\n                         item.span,\n                         sig,\n                         headers,\n@@ -304,7 +304,7 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n         let headers = check_attrs(cx, &self.valid_idents, attrs);\n         if let hir::TraitItemKind::Fn(ref sig, ..) = item.kind {\n             if !in_external_macro(cx.tcx.sess, item.span) {\n-                lint_for_missing_headers(cx, item.def_id.def_id, item.span, sig, headers, None, None);\n+                lint_for_missing_headers(cx, item.owner_id.def_id, item.span, sig, headers, None, None);\n             }\n         }\n     }\n@@ -319,13 +319,13 @@ impl<'tcx> LateLintPass<'tcx> for DocMarkdown {\n             let body = cx.tcx.hir().body(body_id);\n             let mut fpu = FindPanicUnwrap {\n                 cx,\n-                typeck_results: cx.tcx.typeck(item.def_id.def_id),\n+                typeck_results: cx.tcx.typeck(item.owner_id.def_id),\n                 panic_span: None,\n             };\n             fpu.visit_expr(body.value);\n             lint_for_missing_headers(\n                 cx,\n-                item.def_id.def_id,\n+                item.owner_id.def_id,\n                 item.span,\n                 sig,\n                 headers,"}, {"sha": "0570c2a1013890545e493dbd7c369ee8569859fc", "filename": "src/tools/clippy/clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fempty_enum.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -49,7 +49,7 @@ impl<'tcx> LateLintPass<'tcx> for EmptyEnum {\n         }\n \n         if let ItemKind::Enum(..) = item.kind {\n-            let ty = cx.tcx.type_of(item.def_id);\n+            let ty = cx.tcx.type_of(item.owner_id);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");\n             if adt.variants().is_empty() {\n                 span_lint_and_help("}, {"sha": "223545fa79846cb4b5ac40f90a4e37571debfa39", "filename": "src/tools/clippy/clippy_lints/src/enum_variants.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fenum_variants.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -265,7 +265,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n                     }\n                     // The `module_name_repetitions` lint should only trigger if the item has the module in its\n                     // name. Having the same name is accepted.\n-                    if cx.tcx.visibility(item.def_id).is_public() && item_camel.len() > mod_camel.len() {\n+                    if cx.tcx.visibility(item.owner_id).is_public() && item_camel.len() > mod_camel.len() {\n                         let matching = count_match_start(mod_camel, &item_camel);\n                         let rmatching = count_match_end(mod_camel, &item_camel);\n                         let nchars = mod_camel.chars().count();\n@@ -296,7 +296,7 @@ impl LateLintPass<'_> for EnumVariantNames {\n             }\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n-            if !(self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(item.def_id.def_id)) {\n+            if !(self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(item.owner_id.def_id)) {\n                 check_variant(cx, self.threshold, def, item_name, item.span);\n             }\n         }"}, {"sha": "7f1a4c4beb1f2dfeded29686c799bd3faac32762", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -88,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for BoxedLocal {\n                         // be sure we have `self` parameter in this function\n                         if trait_item.kind == (AssocItemKind::Fn { has_self: true }) {\n                             trait_self_ty = Some(\n-                                TraitRef::identity(cx.tcx, trait_item.id.def_id.to_def_id())\n+                                TraitRef::identity(cx.tcx, trait_item.id.owner_id.to_def_id())\n                                     .self_ty()\n                                     .skip_binder(),\n                             );"}, {"sha": "1fece5d1c480917f606856b1896611b8f3d2016e", "filename": "src/tools/clippy/clippy_lints/src/exhaustive_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fexhaustive_items.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -73,7 +73,7 @@ impl LateLintPass<'_> for ExhaustiveItems {\n     fn check_item(&mut self, cx: &LateContext<'_>, item: &Item<'_>) {\n         if_chain! {\n             if let ItemKind::Enum(..) | ItemKind::Struct(..) = item.kind;\n-            if cx.effective_visibilities.is_exported(item.def_id.def_id);\n+            if cx.effective_visibilities.is_exported(item.owner_id.def_id);\n             let attrs = cx.tcx.hir().attrs(item.hir_id());\n             if !attrs.iter().any(|a| a.has_name(sym::non_exhaustive));\n             then {"}, {"sha": "0a633f242a5f1672a7d6c48ff680402685bc7e9a", "filename": "src/tools/clippy/clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -55,7 +55,7 @@ impl<'tcx> LateLintPass<'tcx> for FallibleImplFrom {\n         // check for `impl From<???> for ..`\n         if_chain! {\n             if let hir::ItemKind::Impl(impl_) = &item.kind;\n-            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id);\n             if cx.tcx.is_diagnostic_item(sym::From, impl_trait_ref.def_id);\n             then {\n                 lint_impl_body(cx, item.span, impl_.items);\n@@ -107,7 +107,7 @@ fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_items: &[h\n                 let body = cx.tcx.hir().body(body_id);\n                 let mut fpu = FindPanicUnwrap {\n                     lcx: cx,\n-                    typeck_results: cx.tcx.typeck(impl_item.id.def_id.def_id),\n+                    typeck_results: cx.tcx.typeck(impl_item.id.owner_id.def_id),\n                     result: Vec::new(),\n                 };\n                 fpu.visit_expr(body.value);"}, {"sha": "8b24a4962fb296ca4366c36e933206b987d1fa25", "filename": "src/tools/clippy/clippy_lints/src/from_over_into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffrom_over_into.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for FromOverInto {\n             && let Some(into_trait_seg) = hir_trait_ref.path.segments.last()\n             // `impl Into<target_ty> for self_ty`\n             && let Some(GenericArgs { args: [GenericArg::Type(target_ty)], .. }) = into_trait_seg.args\n-            && let Some(middle_trait_ref) = cx.tcx.impl_trait_ref(item.def_id)\n+            && let Some(middle_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id)\n             && cx.tcx.is_diagnostic_item(sym::Into, middle_trait_ref.def_id)\n         {\n             span_lint_and_then("}, {"sha": "bff69f9151846d6bfa4831a75a8f2e175951b5fc", "filename": "src/tools/clippy/clippy_lints/src/functions/must_use.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fmust_use.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -22,9 +22,9 @@ use super::{DOUBLE_MUST_USE, MUST_USE_CANDIDATE, MUST_USE_UNIT};\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>) {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n-    let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n+    let attr = cx.tcx.get_attr(item.owner_id.to_def_id(), sym::must_use);\n     if let hir::ItemKind::Fn(ref sig, _generics, ref body_id) = item.kind {\n-        let is_public = cx.effective_visibilities.is_exported(item.def_id.def_id);\n+        let is_public = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n@@ -34,7 +34,7 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n                 sig.decl,\n                 cx.tcx.hir().body(*body_id),\n                 item.span,\n-                item.def_id.def_id,\n+                item.owner_id.def_id,\n                 item.span.with_hi(sig.decl.output.span().hi()),\n                 \"this function could have a `#[must_use]` attribute\",\n             );\n@@ -44,20 +44,20 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Item<'_>\n \n pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'_>) {\n     if let hir::ImplItemKind::Fn(ref sig, ref body_id) = item.kind {\n-        let is_public = cx.effective_visibilities.is_exported(item.def_id.def_id);\n+        let is_public = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n+        let attr = cx.tcx.get_attr(item.owner_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n-        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.def_id.def_id).is_none()\n+        } else if is_public && !is_proc_macro(cx.sess(), attrs) && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n         {\n             check_must_use_candidate(\n                 cx,\n                 sig.decl,\n                 cx.tcx.hir().body(*body_id),\n                 item.span,\n-                item.def_id.def_id,\n+                item.owner_id.def_id,\n                 item.span.with_hi(sig.decl.output.span().hi()),\n                 \"this method could have a `#[must_use]` attribute\",\n             );\n@@ -67,11 +67,11 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Imp\n \n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, ref eid) = item.kind {\n-        let is_public = cx.effective_visibilities.is_exported(item.def_id.def_id);\n+        let is_public = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n \n         let attrs = cx.tcx.hir().attrs(item.hir_id());\n-        let attr = cx.tcx.get_attr(item.def_id.to_def_id(), sym::must_use);\n+        let attr = cx.tcx.get_attr(item.owner_id.to_def_id(), sym::must_use);\n         if let Some(attr) = attr {\n             check_needless_must_use(cx, sig.decl, item.hir_id(), item.span, fn_header_span, attr);\n         } else if let hir::TraitFn::Provided(eid) = *eid {\n@@ -82,7 +82,7 @@ pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::Tr\n                     sig.decl,\n                     body,\n                     item.span,\n-                    item.def_id.def_id,\n+                    item.owner_id.def_id,\n                     item.span.with_hi(sig.decl.output.span().hi()),\n                     \"this method could have a `#[must_use]` attribute\",\n                 );\n@@ -188,7 +188,7 @@ fn is_mutable_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span, tys: &m\n         // primitive types are never mutable\n         ty::Bool | ty::Char | ty::Int(_) | ty::Uint(_) | ty::Float(_) | ty::Str => false,\n         ty::Adt(adt, substs) => {\n-            tys.insert(adt.did()) && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+            tys.insert(adt.did()) && !ty.is_freeze(cx.tcx, cx.param_env)\n                 || KNOWN_WRAPPER_TYS\n                     .iter()\n                     .any(|&sym| cx.tcx.is_diagnostic_item(sym, adt.did()))"}, {"sha": "2c0bf551fd7e2b790c5c5896b85d3e327740d79d", "filename": "src/tools/clippy/clippy_lints/src/functions/not_unsafe_ptr_arg_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fnot_unsafe_ptr_arg_deref.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -31,7 +31,7 @@ pub(super) fn check_fn<'tcx>(\n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &'tcx hir::TraitItem<'_>) {\n     if let hir::TraitItemKind::Fn(ref sig, hir::TraitFn::Provided(eid)) = item.kind {\n         let body = cx.tcx.hir().body(eid);\n-        check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.def_id.def_id);\n+        check_raw_ptr(cx, sig.header.unsafety, sig.decl, body, item.owner_id.def_id);\n     }\n }\n "}, {"sha": "5c63fb2acb117f08f729c1658edcd6ff9041aa4e", "filename": "src/tools/clippy/clippy_lints/src/functions/result.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions%2Fresult.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -34,9 +34,9 @@ fn result_err_ty<'tcx>(\n \n pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::Item<'tcx>, large_err_threshold: u64) {\n     if let hir::ItemKind::Fn(ref sig, _generics, _) = item.kind\n-        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span)\n+        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.owner_id.def_id, item.span)\n     {\n-        if cx.effective_visibilities.is_exported(item.def_id.def_id) {\n+        if cx.effective_visibilities.is_exported(item.owner_id.def_id) {\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             check_result_unit_err(cx, err_ty, fn_header_span);\n         }\n@@ -47,10 +47,10 @@ pub(super) fn check_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::Item<'tcx>, l\n pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::ImplItem<'tcx>, large_err_threshold: u64) {\n     // Don't lint if method is a trait's implementation, we can't do anything about those\n     if let hir::ImplItemKind::Fn(ref sig, _) = item.kind\n-        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span)\n-        && trait_ref_of_method(cx, item.def_id.def_id).is_none()\n+        && let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.owner_id.def_id, item.span)\n+        && trait_ref_of_method(cx, item.owner_id.def_id).is_none()\n     {\n-        if cx.effective_visibilities.is_exported(item.def_id.def_id) {\n+        if cx.effective_visibilities.is_exported(item.owner_id.def_id) {\n             let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n             check_result_unit_err(cx, err_ty, fn_header_span);\n         }\n@@ -61,8 +61,8 @@ pub(super) fn check_impl_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::ImplItem\n pub(super) fn check_trait_item<'tcx>(cx: &LateContext<'tcx>, item: &hir::TraitItem<'tcx>, large_err_threshold: u64) {\n     if let hir::TraitItemKind::Fn(ref sig, _) = item.kind {\n         let fn_header_span = item.span.with_hi(sig.decl.output.span().hi());\n-        if let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.def_id.def_id, item.span) {\n-            if cx.effective_visibilities.is_exported(item.def_id.def_id) {\n+        if let Some((hir_ty, err_ty)) = result_err_ty(cx, sig.decl, item.owner_id.def_id, item.span) {\n+            if cx.effective_visibilities.is_exported(item.owner_id.def_id) {\n                 check_result_unit_err(cx, err_ty, fn_header_span);\n             }\n             check_result_large_err(cx, err_ty, hir_ty.span, large_err_threshold);"}, {"sha": "94e06cf704ba24c4845ddae70501bc75babd33df", "filename": "src/tools/clippy/clippy_lints/src/implicit_hasher.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fimplicit_hasher.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -111,7 +111,7 @@ impl<'tcx> LateLintPass<'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.effective_visibilities.is_exported(item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_exported(item.owner_id.def_id) {\n             return;\n         }\n "}, {"sha": "14a37f535b46c9e711cd23436ba89bf445f736be", "filename": "src/tools/clippy/clippy_lints/src/inherent_to_string.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Finherent_to_string.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -108,7 +108,7 @@ impl<'tcx> LateLintPass<'tcx> for InherentToString {\n             if is_type_diagnostic_item(cx, return_ty(cx, impl_item.hir_id()), sym::String);\n \n             // Filters instances of to_string which are required by a trait\n-            if trait_ref_of_method(cx, impl_item.def_id.def_id).is_none();\n+            if trait_ref_of_method(cx, impl_item.owner_id.def_id).is_none();\n \n             then {\n                 show_lint(cx, impl_item);\n@@ -124,7 +124,7 @@ fn show_lint(cx: &LateContext<'_>, item: &ImplItem<'_>) {\n         .expect(\"Failed to get trait ID of `Display`!\");\n \n     // Get the real type of 'self'\n-    let self_type = cx.tcx.fn_sig(item.def_id).input(0);\n+    let self_type = cx.tcx.fn_sig(item.owner_id).input(0);\n     let self_type = self_type.skip_binder().peel_refs();\n \n     // Emit either a warning or an error"}, {"sha": "e76de77f195d7aedd1357fdaafbcfeb253c3feaf", "filename": "src/tools/clippy/clippy_lints/src/iter_not_returning_iterator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fiter_not_returning_iterator.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -44,7 +44,7 @@ impl<'tcx> LateLintPass<'tcx> for IterNotReturningIterator {\n         let name = item.ident.name.as_str();\n         if matches!(name, \"iter\" | \"iter_mut\") {\n             if let TraitItemKind::Fn(fn_sig, _) = &item.kind {\n-                check_sig(cx, name, fn_sig, item.def_id.def_id);\n+                check_sig(cx, name, fn_sig, item.owner_id.def_id);\n             }\n         }\n     }\n@@ -58,7 +58,7 @@ impl<'tcx> LateLintPass<'tcx> for IterNotReturningIterator {\n             )\n         {\n             if let ImplItemKind::Fn(fn_sig, _) = &item.kind {\n-                check_sig(cx, name, fn_sig, item.def_id.def_id);\n+                check_sig(cx, name, fn_sig, item.owner_id.def_id);\n             }\n         }\n     }"}, {"sha": "06e957285499cc49f382f3cf5cee0d1e54b2e89e", "filename": "src/tools/clippy/clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -123,7 +123,7 @@ impl<'tcx> LateLintPass<'tcx> for LargeEnumVariant {\n             return;\n         }\n         if let ItemKind::Enum(ref def, _) = item.kind {\n-            let ty = cx.tcx.type_of(item.def_id);\n+            let ty = cx.tcx.type_of(item.owner_id);\n             let Adt(adt, subst) = ty.kind() else {\n                 panic!(\"already checked whether this is an enum\")\n             };"}, {"sha": "b0cba40c27a5d5ccdaca7a0166cbef37fb3eb6b4", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -134,7 +134,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if item.ident.name == sym::len;\n             if let ImplItemKind::Fn(sig, _) = &item.kind;\n             if sig.decl.implicit_self.has_implicit_self();\n-            if cx.effective_visibilities.is_exported(item.def_id.def_id);\n+            if cx.effective_visibilities.is_exported(item.owner_id.def_id);\n             if matches!(sig.decl.output, FnRetTy::Return(_));\n             if let Some(imp) = get_parent_as_impl(cx.tcx, item.hir_id());\n             if imp.of_trait.is_none();\n@@ -143,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for LenZero {\n             if let Some(local_id) = ty_id.as_local();\n             let ty_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n             if !is_lint_allowed(cx, LEN_WITHOUT_IS_EMPTY, ty_hir_id);\n-            if let Some(output) = parse_len_output(cx, cx.tcx.fn_sig(item.def_id).skip_binder());\n+            if let Some(output) = parse_len_output(cx, cx.tcx.fn_sig(item.owner_id).skip_binder());\n             then {\n                 let (name, kind) = match cx.tcx.hir().find(ty_hir_id) {\n                     Some(Node::ForeignItem(x)) => (x.ident.name, \"extern type\"),\n@@ -195,7 +195,7 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n     fn is_named_self(cx: &LateContext<'_>, item: &TraitItemRef, name: Symbol) -> bool {\n         item.ident.name == name\n             && if let AssocItemKind::Fn { has_self } = item.kind {\n-                has_self && { cx.tcx.fn_sig(item.id.def_id).inputs().skip_binder().len() == 1 }\n+                has_self && { cx.tcx.fn_sig(item.id.owner_id).inputs().skip_binder().len() == 1 }\n             } else {\n                 false\n             }\n@@ -210,11 +210,11 @@ fn check_trait_items(cx: &LateContext<'_>, visited_trait: &Item<'_>, trait_items\n         }\n     }\n \n-    if cx.effective_visibilities.is_exported(visited_trait.def_id.def_id)\n+    if cx.effective_visibilities.is_exported(visited_trait.owner_id.def_id)\n         && trait_items.iter().any(|i| is_named_self(cx, i, sym::len))\n     {\n         let mut current_and_super_traits = DefIdSet::default();\n-        fill_trait_set(visited_trait.def_id.to_def_id(), &mut current_and_super_traits, cx);\n+        fill_trait_set(visited_trait.owner_id.to_def_id(), &mut current_and_super_traits, cx);\n         let is_empty = sym!(is_empty);\n \n         let is_empty_method_found = current_and_super_traits"}, {"sha": "db41bc67da1a7f34f1d57eef78db8d0c8f29b780", "filename": "src/tools/clippy/clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_if_seq.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> LateLintPass<'tcx> for LetIfSeq {\n                     let span = stmt.span.to(if_.span);\n \n                     let has_interior_mutability = !cx.typeck_results().node_type(canonical_id).is_freeze(\n-                        cx.tcx.at(span),\n+                        cx.tcx,\n                         cx.param_env,\n                     );\n                     if has_interior_mutability { return; }"}, {"sha": "3bf2d7e4ea4e6cc98cc6229ab8169cf3fb460ff5", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -102,7 +102,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n         if let ImplItemKind::Fn(ref sig, id) = item.kind {\n-            let report_extra_lifetimes = trait_ref_of_method(cx, item.def_id.def_id).is_none();\n+            let report_extra_lifetimes = trait_ref_of_method(cx, item.owner_id.def_id).is_none();\n             check_fn_inner(\n                 cx,\n                 sig.decl,"}, {"sha": "6806c1466968de17328ad8928f98fc9de8979505", "filename": "src/tools/clippy/clippy_lints/src/manual_non_exhaustive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmanual_non_exhaustive.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -166,7 +166,7 @@ impl<'tcx> LateLintPass<'tcx> for ManualNonExhaustiveEnum {\n             if let Some((id, span)) = iter.next()\n                 && iter.next().is_none()\n             {\n-                self.potential_enums.push((item.def_id.def_id, id, item.span, span));\n+                self.potential_enums.push((item.owner_id.def_id, id, item.span, span));\n             }\n         }\n     }"}, {"sha": "8a76ba0b064b547b9d0579f8efc6ccfcb549311c", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -3250,15 +3250,15 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n         let name = impl_item.ident.name.as_str();\n         let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n         let item = cx.tcx.hir().expect_item(parent);\n-        let self_ty = cx.tcx.type_of(item.def_id);\n+        let self_ty = cx.tcx.type_of(item.owner_id);\n \n         let implements_trait = matches!(item.kind, hir::ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }));\n         if let hir::ImplItemKind::Fn(ref sig, id) = impl_item.kind {\n-            let method_sig = cx.tcx.fn_sig(impl_item.def_id);\n+            let method_sig = cx.tcx.fn_sig(impl_item.owner_id);\n             let method_sig = cx.tcx.erase_late_bound_regions(method_sig);\n             let first_arg_ty_opt = method_sig.inputs().iter().next().copied();\n             // if this impl block implements a trait, lint in trait definition instead\n-            if !implements_trait && cx.effective_visibilities.is_exported(impl_item.def_id.def_id) {\n+            if !implements_trait && cx.effective_visibilities.is_exported(impl_item.owner_id.def_id) {\n                 // check missing trait implementations\n                 for method_config in &TRAIT_METHODS {\n                     if name == method_config.method_name\n@@ -3292,7 +3292,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n             if sig.decl.implicit_self.has_implicit_self()\n                     && !(self.avoid_breaking_exported_api\n-                    && cx.effective_visibilities.is_exported(impl_item.def_id.def_id))\n+                    && cx.effective_visibilities.is_exported(impl_item.owner_id.def_id))\n                     && let Some(first_arg) = iter_input_pats(sig.decl, cx.tcx.hir().body(id)).next()\n                     && let Some(first_arg_ty) = first_arg_ty_opt\n                 {\n@@ -3370,7 +3370,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             then {\n                 let first_arg_span = first_arg_ty.span;\n                 let first_arg_ty = hir_ty_to_ty(cx.tcx, first_arg_ty);\n-                let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id())\n+                let self_ty = TraitRef::identity(cx.tcx, item.owner_id.to_def_id())\n                     .self_ty()\n                     .skip_binder();\n                 wrong_self_convention::check(\n@@ -3389,7 +3389,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if item.ident.name == sym::new;\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id());\n-            let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id())\n+            let self_ty = TraitRef::identity(cx.tcx, item.owner_id.to_def_id())\n                 .self_ty()\n                 .skip_binder();\n             if !ret_ty.contains(self_ty);"}, {"sha": "2a63681db60e55df076f5a3bc93d77f5f7f684a0", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -131,7 +131,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == sym::main {\n-                    let at_root = cx.tcx.local_parent(it.def_id.def_id) == CRATE_DEF_ID;\n+                    let at_root = cx.tcx.local_parent(it.owner_id.def_id) == CRATE_DEF_ID;\n                     if at_root {\n                         return;\n                     }\n@@ -155,7 +155,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             | hir::ItemKind::Use(..) => return,\n         };\n \n-        let (article, desc) = cx.tcx.article_and_description(it.def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(it.owner_id.to_def_id());\n \n         let attrs = cx.tcx.hir().attrs(it.hir_id());\n         if !is_from_proc_macro(cx, it) {\n@@ -164,7 +164,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, trait_item: &'tcx hir::TraitItem<'_>) {\n-        let (article, desc) = cx.tcx.article_and_description(trait_item.def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(trait_item.owner_id.to_def_id());\n \n         let attrs = cx.tcx.hir().attrs(trait_item.hir_id());\n         if !is_from_proc_macro(cx, trait_item) {\n@@ -174,15 +174,15 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, impl_item: &'tcx hir::ImplItem<'_>) {\n         // If the method is an impl for a trait, don't doc.\n-        if let Some(cid) = cx.tcx.associated_item(impl_item.def_id).impl_container(cx.tcx) {\n+        if let Some(cid) = cx.tcx.associated_item(impl_item.owner_id).impl_container(cx.tcx) {\n             if cx.tcx.impl_trait_ref(cid).is_some() {\n                 return;\n             }\n         } else {\n             return;\n         }\n \n-        let (article, desc) = cx.tcx.article_and_description(impl_item.def_id.to_def_id());\n+        let (article, desc) = cx.tcx.article_and_description(impl_item.owner_id.to_def_id());\n         let attrs = cx.tcx.hir().attrs(impl_item.hir_id());\n         if !is_from_proc_macro(cx, impl_item) {\n             self.check_missing_docs_attrs(cx, attrs, impl_item.span, article, desc);"}, {"sha": "758ce47cf114b8dc3aba594b3ba2ad3d24710a72", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -88,7 +88,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.effective_visibilities.is_exported(it.def_id.def_id) {\n+        if !cx.effective_visibilities.is_exported(it.owner_id.def_id) {\n             return;\n         }\n         match it.kind {\n@@ -105,7 +105,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n                     match tit_.kind {\n                         hir::TraitItemKind::Const(..) | hir::TraitItemKind::Type(..) => {},\n                         hir::TraitItemKind::Fn(..) => {\n-                            if cx.tcx.impl_defaultness(tit.id.def_id).has_value() {\n+                            if cx.tcx.impl_defaultness(tit.id.owner_id).has_value() {\n                                 // trait method with default body needs inline in case\n                                 // an impl is not provided\n                                 let desc = \"a default trait method\";\n@@ -142,7 +142,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n         }\n \n         // If the item being implemented is not exported, then we don't need #[inline]\n-        if !cx.effective_visibilities.is_exported(impl_item.def_id.def_id) {\n+        if !cx.effective_visibilities.is_exported(impl_item.owner_id.def_id) {\n             return;\n         }\n \n@@ -151,15 +151,15 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(_) => return,\n         };\n \n-        let assoc_item = cx.tcx.associated_item(impl_item.def_id);\n+        let assoc_item = cx.tcx.associated_item(impl_item.owner_id);\n         let container_id = assoc_item.container_id(cx.tcx);\n         let trait_def_id = match assoc_item.container {\n             TraitContainer => Some(container_id),\n             ImplContainer => cx.tcx.impl_trait_ref(container_id).map(|t| t.def_id),\n         };\n \n         if let Some(trait_def_id) = trait_def_id {\n-            if trait_def_id.is_local() && !cx.effective_visibilities.is_exported(impl_item.def_id.def_id) {\n+            if trait_def_id.is_local() && !cx.effective_visibilities.is_exported(impl_item.owner_id.def_id) {\n                 // If a trait is being implemented for an item, and the\n                 // trait is not exported, we don't need #[inline]\n                 return;"}, {"sha": "4b62dcdffe2fcf68a2481cac8bdc6af55b19c817", "filename": "src/tools/clippy/clippy_lints/src/mut_key.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmut_key.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for MutableKeyType {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::ImplItem<'tcx>) {\n         if let hir::ImplItemKind::Fn(ref sig, ..) = item.kind {\n-            if trait_ref_of_method(cx, item.def_id.def_id).is_none() {\n+            if trait_ref_of_method(cx, item.owner_id.def_id).is_none() {\n                 check_sig(cx, item.hir_id(), sig.decl);\n             }\n         }\n@@ -136,12 +136,14 @@ fn check_ty<'tcx>(cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n /// [`Hash`] or [`Ord`].\n fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Span) -> bool {\n     match *ty.kind() {\n-        Ref(_, inner_ty, mutbl) => mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span),\n+        Ref(_, inner_ty, mutbl) => {\n+            mutbl == hir::Mutability::Mut || is_interior_mutable_type(cx, inner_ty, span)\n+        }\n         Slice(inner_ty) => is_interior_mutable_type(cx, inner_ty, span),\n         Array(inner_ty, size) => {\n             size.try_eval_usize(cx.tcx, cx.param_env).map_or(true, |u| u != 0)\n                 && is_interior_mutable_type(cx, inner_ty, span)\n-        },\n+        }\n         Tuple(fields) => fields.iter().any(|ty| is_interior_mutable_type(cx, ty, span)),\n         Adt(def, substs) => {\n             // Special case for collections in `std` who's impl of `Hash` or `Ord` delegates to\n@@ -167,9 +169,9 @@ fn is_interior_mutable_type<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, span: Sp\n             } else {\n                 !ty.has_escaping_bound_vars()\n                     && cx.tcx.layout_of(cx.param_env.and(ty)).is_ok()\n-                    && !ty.is_freeze(cx.tcx.at(span), cx.param_env)\n+                    && !ty.is_freeze(cx.tcx, cx.param_env)\n             }\n-        },\n+        }\n         _ => false,\n     }\n }"}, {"sha": "b2e9ce5c94d65db825d650b25e27505c93f48fc3", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::mir::FakeReadCause;\n use rustc_middle::ty::{self, TypeVisitable};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::kw;\n-use rustc_span::{sym, Span, DUMMY_SP};\n+use rustc_span::{sym, Span};\n use rustc_target::spec::abi::Abi;\n use rustc_trait_selection::traits;\n use rustc_trait_selection::traits::misc::can_type_implement_copy;\n@@ -184,7 +184,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n                 if !is_self(arg);\n                 if !ty.is_mutable_ptr();\n                 if !is_copy(cx, ty);\n-                if ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env);\n+                if ty.is_sized(cx.tcx, cx.param_env);\n                 if !allowed_traits.iter().any(|&t| implements_trait(cx, ty, t, &[]));\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;"}, {"sha": "54a3c82b713daa36684d2da864cbeedc93b5abfc", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -84,7 +84,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // can't be implemented for unsafe new\n                             return;\n                         }\n-                        if cx.tcx.is_doc_hidden(impl_item.def_id.def_id) {\n+                        if cx.tcx.is_doc_hidden(impl_item.owner_id.def_id) {\n                             // shouldn't be implemented when it is hidden in docs\n                             return;\n                         }\n@@ -96,7 +96,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                         if_chain! {\n                             if sig.decl.inputs.is_empty();\n                             if name == sym::new;\n-                            if cx.effective_visibilities.is_reachable(impl_item.def_id.def_id);\n+                            if cx.effective_visibilities.is_reachable(impl_item.owner_id.def_id);\n                             let self_def_id = cx.tcx.hir().get_parent_item(id);\n                             let self_ty = cx.tcx.type_of(self_def_id);\n                             if self_ty == return_ty(cx, id);"}, {"sha": "2a3bd4ee6ce65cadcedac6ac19558d43ac6b269a", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -20,7 +20,7 @@ use rustc_middle::mir::interpret::{ConstValue, ErrorHandled};\n use rustc_middle::ty::adjustment::Adjust;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{sym, InnerSpan, Span, DUMMY_SP};\n+use rustc_span::{sym, InnerSpan, Span};\n \n // FIXME: this is a correctness problem but there's no suitable\n // warn-by-default category.\n@@ -136,7 +136,7 @@ fn is_unfrozen<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n     // since it works when a pointer indirection involves (`Cell<*const T>`).\n     // Making up a `ParamEnv` where every generic params and assoc types are `Freeze`is another option;\n     // but I'm not sure whether it's a decent way, if possible.\n-    cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx.at(DUMMY_SP), cx.param_env)\n+    cx.tcx.layout_of(cx.param_env.and(ty)).is_ok() && !ty.is_freeze(cx.tcx, cx.param_env)\n }\n \n fn is_value_unfrozen_raw<'tcx>(\n@@ -303,7 +303,7 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n                         if let Some(of_trait_def_id) = of_trait_ref.trait_def_id();\n                         if let Some(of_assoc_item) = cx\n                             .tcx\n-                            .associated_item(impl_item.def_id)\n+                            .associated_item(impl_item.owner_id)\n                             .trait_item_def_id;\n                         if cx\n                             .tcx"}, {"sha": "714c0ff227bf829d01f535ea5fc89a944d362b91", "filename": "src/tools/clippy/clippy_lints/src/non_send_fields_in_send_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_send_fields_in_send_ty.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -89,7 +89,7 @@ impl<'tcx> LateLintPass<'tcx> for NonSendFieldInSendTy {\n             if let Some(trait_id) = trait_ref.trait_def_id();\n             if send_trait == trait_id;\n             if hir_impl.polarity == ImplPolarity::Positive;\n-            if let Some(ty_trait_ref) = cx.tcx.impl_trait_ref(item.def_id);\n+            if let Some(ty_trait_ref) = cx.tcx.impl_trait_ref(item.owner_id);\n             if let self_ty = ty_trait_ref.self_ty();\n             if let ty::Adt(adt_def, impl_trait_substs) = self_ty.kind();\n             then {"}, {"sha": "7722a476d7b4e5182abeea83af939b5653c7bc32", "filename": "src/tools/clippy/clippy_lints/src/only_used_in_recursion.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fonly_used_in_recursion.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -227,33 +227,33 @@ impl<'tcx> LateLintPass<'tcx> for OnlyUsedInRecursion {\n         // `skip_params` is either `0` or `1` to skip the `self` parameter in trait functions.\n         // It can't be renamed, and it can't be removed without removing it from multiple functions.\n         let (fn_id, fn_kind, skip_params) = match get_parent_node(cx.tcx, body.value.hir_id) {\n-            Some(Node::Item(i)) => (i.def_id.to_def_id(), FnKind::Fn, 0),\n+            Some(Node::Item(i)) => (i.owner_id.to_def_id(), FnKind::Fn, 0),\n             Some(Node::TraitItem(&TraitItem {\n                 kind: TraitItemKind::Fn(ref sig, _),\n-                def_id,\n+                owner_id,\n                 ..\n             })) => (\n-                def_id.to_def_id(),\n+                owner_id.to_def_id(),\n                 FnKind::TraitFn,\n                 usize::from(sig.decl.implicit_self.has_implicit_self()),\n             ),\n             Some(Node::ImplItem(&ImplItem {\n                 kind: ImplItemKind::Fn(ref sig, _),\n-                def_id,\n+                owner_id,\n                 ..\n             })) => {\n                 #[allow(trivial_casts)]\n-                if let Some(Node::Item(item)) = get_parent_node(cx.tcx, def_id.into())\n-                    && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.def_id)\n-                    && let Some(trait_item_id) = cx.tcx.associated_item(def_id).trait_item_def_id\n+                if let Some(Node::Item(item)) = get_parent_node(cx.tcx, owner_id.into())\n+                    && let Some(trait_ref) = cx.tcx.impl_trait_ref(item.owner_id)\n+                    && let Some(trait_item_id) = cx.tcx.associated_item(owner_id).trait_item_def_id\n                 {\n                     (\n                         trait_item_id,\n                         FnKind::ImplTraitFn(cx.tcx.erase_regions(trait_ref.substs) as *const _ as usize),\n                         usize::from(sig.decl.implicit_self.has_implicit_self()),\n                     )\n                 } else {\n-                    (def_id.to_def_id(), FnKind::Fn, 0)\n+                    (owner_id.to_def_id(), FnKind::Fn, 0)\n                 }\n             },\n             _ => return,"}, {"sha": "71b31b5e4a562604efc96a1d30c2e6945f137b2d", "filename": "src/tools/clippy/clippy_lints/src/operators/op_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foperators%2Fop_ref.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -204,7 +204,7 @@ fn are_equal<'tcx>(cx: &LateContext<'tcx>, middle_ty: Ty<'_>, hir_ty: &rustc_hir\n         if let ty::Adt(adt_def, _) = middle_ty.kind();\n         if let Some(local_did) = adt_def.did().as_local();\n         let item = cx.tcx.hir().expect_item(local_did);\n-        let middle_ty_id = item.def_id.to_def_id();\n+        let middle_ty_id = item.owner_id.to_def_id();\n         if let TyKind::Path(QPath::Resolved(_, path)) = hir_ty.kind;\n         if let Res::Def(_, hir_ty_id) = path.res;\n "}, {"sha": "5aa3c6f2f9346b5dc39e810d751a90dba91e16c1", "filename": "src/tools/clippy/clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -36,7 +36,7 @@ impl<'tcx> LateLintPass<'tcx> for PartialEqNeImpl {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         if_chain! {\n             if let ItemKind::Impl(Impl { of_trait: Some(ref trait_ref), items: impl_items, .. }) = item.kind;\n-            if !cx.tcx.has_attr(item.def_id.to_def_id(), sym::automatically_derived);\n+            if !cx.tcx.has_attr(item.owner_id.to_def_id(), sym::automatically_derived);\n             if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n             if trait_ref.path.res.def_id() == eq_trait;\n             then {"}, {"sha": "f9fd3645668a9959ee25a48f9fe46ba1fb9d5300", "filename": "src/tools/clippy/clippy_lints/src/pass_by_ref_or_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpass_by_ref_or_value.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -261,7 +261,7 @@ impl<'tcx> LateLintPass<'tcx> for PassByRefOrValue {\n         }\n \n         if let hir::TraitItemKind::Fn(method_sig, _) = &item.kind {\n-            self.check_poly_fn(cx, item.def_id.def_id, method_sig.decl, None);\n+            self.check_poly_fn(cx, item.owner_id.def_id, method_sig.decl, None);\n         }\n     }\n "}, {"sha": "0d74c90a834f7bcab9ff8484518bd9597c432d00", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -164,7 +164,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n             check_mut_from_ref(cx, sig, None);\n             for arg in check_fn_args(\n                 cx,\n-                cx.tcx.fn_sig(item.def_id).skip_binder().inputs(),\n+                cx.tcx.fn_sig(item.owner_id).skip_binder().inputs(),\n                 sig.decl.inputs,\n                 &[],\n             )\n@@ -188,7 +188,7 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n         let (item_id, sig, is_trait_item) = match parents.next() {\n             Some((_, Node::Item(i))) => {\n                 if let ItemKind::Fn(sig, ..) = &i.kind {\n-                    (i.def_id, sig, false)\n+                    (i.owner_id, sig, false)\n                 } else {\n                     return;\n                 }\n@@ -200,14 +200,14 @@ impl<'tcx> LateLintPass<'tcx> for Ptr {\n                     return;\n                 }\n                 if let ImplItemKind::Fn(sig, _) = &i.kind {\n-                    (i.def_id, sig, false)\n+                    (i.owner_id, sig, false)\n                 } else {\n                     return;\n                 }\n             },\n             Some((_, Node::TraitItem(i))) => {\n                 if let TraitItemKind::Fn(sig, _) = &i.kind {\n-                    (i.def_id, sig, true)\n+                    (i.owner_id, sig, true)\n                 } else {\n                     return;\n                 }"}, {"sha": "bb86fb3b7d42f43858db4b853f7fe3cbcb6ca8f6", "filename": "src/tools/clippy/clippy_lints/src/question_mark.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fquestion_mark.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -94,7 +94,7 @@ fn check_is_none_or_err_and_early_return<'tcx>(cx: &LateContext<'tcx>, expr: &Ex\n         then {\n             let mut applicability = Applicability::MachineApplicable;\n             let receiver_str = snippet_with_applicability(cx, caller.span, \"..\", &mut applicability);\n-            let by_ref = !caller_ty.is_copy_modulo_regions(cx.tcx.at(caller.span), cx.param_env) &&\n+            let by_ref = !caller_ty.is_copy_modulo_regions(cx.tcx, cx.param_env) &&\n                 !matches!(caller.kind, ExprKind::Call(..) | ExprKind::MethodCall(..));\n             let sugg = if let Some(else_inner) = r#else {\n                 if eq_expr_value(cx, caller, peel_blocks(else_inner)) {"}, {"sha": "26075e9f70faa498d456dde4b9fbff350ab27b71", "filename": "src/tools/clippy/clippy_lints/src/redundant_pub_crate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pub_crate.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -46,12 +46,12 @@ impl_lint_pass!(RedundantPubCrate => [REDUNDANT_PUB_CRATE]);\n impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'tcx>) {\n         if_chain! {\n-            if cx.tcx.visibility(item.def_id.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id());\n-            if !cx.effective_visibilities.is_exported(item.def_id.def_id) && self.is_exported.last() == Some(&false);\n+            if cx.tcx.visibility(item.owner_id.def_id) == ty::Visibility::Restricted(CRATE_DEF_ID.to_def_id());\n+            if !cx.effective_visibilities.is_exported(item.owner_id.def_id) && self.is_exported.last() == Some(&false);\n             if is_not_macro_export(item);\n             then {\n                 let span = item.span.with_hi(item.ident.span.hi());\n-                let descr = cx.tcx.def_kind(item.def_id).descr(item.def_id.to_def_id());\n+                let descr = cx.tcx.def_kind(item.owner_id).descr(item.owner_id.to_def_id());\n                 span_lint_and_then(\n                     cx,\n                     REDUNDANT_PUB_CRATE,\n@@ -70,7 +70,7 @@ impl<'tcx> LateLintPass<'tcx> for RedundantPubCrate {\n         }\n \n         if let ItemKind::Mod { .. } = item.kind {\n-            self.is_exported.push(cx.effective_visibilities.is_exported(item.def_id.def_id));\n+            self.is_exported.push(cx.effective_visibilities.is_exported(item.owner_id.def_id));\n         }\n     }\n "}, {"sha": "b77faf7322bd00c054a275f4249e844ec9866455", "filename": "src/tools/clippy/clippy_lints/src/return_self_not_must_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturn_self_not_must_use.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> LateLintPass<'tcx> for ReturnSelfNotMustUse {\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'tcx>) {\n         if let TraitItemKind::Fn(ref sig, _) = item.kind {\n-            check_method(cx, sig.decl, item.def_id.def_id, item.span, item.hir_id());\n+            check_method(cx, sig.decl, item.owner_id.def_id, item.span, item.hir_id());\n         }\n     }\n }"}, {"sha": "caab5851bafc94ffe51fafb7d3ebf3d23f518fcc", "filename": "src/tools/clippy/clippy_lints/src/same_name_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fsame_name_method.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -52,7 +52,7 @@ impl<'tcx> LateLintPass<'tcx> for SameNameMethod {\n         let mut map = FxHashMap::<Res, ExistingName>::default();\n \n         for id in cx.tcx.hir().items() {\n-            if matches!(cx.tcx.def_kind(id.def_id), DefKind::Impl)\n+            if matches!(cx.tcx.def_kind(id.owner_id), DefKind::Impl)\n                 && let item = cx.tcx.hir().item(id)\n                 && let ItemKind::Impl(Impl {\n                   items,"}, {"sha": "71b387c66a33084845f4b9adcb8ab930b138f672", "filename": "src/tools/clippy/clippy_lints/src/self_named_constructors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for SelfNamedConstructors {\n \n         let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n         let item = cx.tcx.hir().expect_item(parent);\n-        let self_ty = cx.tcx.type_of(item.def_id);\n+        let self_ty = cx.tcx.type_of(item.owner_id);\n         let ret_ty = return_ty(cx, impl_item.hir_id());\n \n         // Do not check trait impls"}, {"sha": "8cf3efc8dc73e8df43334c4aa3d73bfd4d094371", "filename": "src/tools/clippy/clippy_lints/src/trailing_empty_array.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrailing_empty_array.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> LateLintPass<'tcx> for TrailingEmptyArray {\n                 None,\n                 &format!(\n                     \"consider annotating `{}` with `#[repr(C)]` or another `repr` attribute\",\n-                    cx.tcx.def_path_str(item.def_id.to_def_id())\n+                    cx.tcx.def_path_str(item.owner_id.to_def_id())\n                 ),\n             );\n         }"}, {"sha": "3d4bbbf648c65bbfdc37ee89d0e8b4f412cb18e5", "filename": "src/tools/clippy/clippy_lints/src/transmute/transmute_undefined_repr.rs", "status": "modified", "additions": 98, "deletions": 67, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftransmute%2Ftransmute_undefined_repr.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -5,7 +5,6 @@ use rustc_hir::Expr;\n use rustc_lint::LateContext;\n use rustc_middle::ty::SubstsRef;\n use rustc_middle::ty::{self, IntTy, Ty, TypeAndMut, UintTy};\n-use rustc_span::DUMMY_SP;\n \n #[expect(clippy::too_many_lines)]\n pub(super) fn check<'tcx>(\n@@ -28,24 +27,32 @@ pub(super) fn check<'tcx>(\n \n             // `Repr(C)` <-> unordered type.\n             // If the first field of the `Repr(C)` type matches then the transmute is ok\n-            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::UnorderedFields(to_sub_ty))\n-            | (ReducedTy::UnorderedFields(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty))) => {\n+            (\n+                ReducedTy::OrderedFields(_, Some(from_sub_ty)),\n+                ReducedTy::UnorderedFields(to_sub_ty),\n+            )\n+            | (\n+                ReducedTy::UnorderedFields(from_sub_ty),\n+                ReducedTy::OrderedFields(_, Some(to_sub_ty)),\n+            ) => {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n-            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::Other(to_sub_ty)) if reduced_tys.to_fat_ptr => {\n+            }\n+            (ReducedTy::OrderedFields(_, Some(from_sub_ty)), ReducedTy::Other(to_sub_ty))\n+                if reduced_tys.to_fat_ptr =>\n+            {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n+            }\n             (ReducedTy::Other(from_sub_ty), ReducedTy::OrderedFields(_, Some(to_sub_ty)))\n                 if reduced_tys.from_fat_ptr =>\n             {\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n+            }\n \n             // ptr <-> ptr\n             (ReducedTy::Other(from_sub_ty), ReducedTy::Other(to_sub_ty))\n@@ -55,19 +62,19 @@ pub(super) fn check<'tcx>(\n                 from_ty = from_sub_ty;\n                 to_ty = to_sub_ty;\n                 continue;\n-            },\n+            }\n \n             // fat ptr <-> (*size, *size)\n             (ReducedTy::Other(_), ReducedTy::UnorderedFields(to_ty))\n                 if reduced_tys.from_fat_ptr && is_size_pair(to_ty) =>\n             {\n                 return false;\n-            },\n+            }\n             (ReducedTy::UnorderedFields(from_ty), ReducedTy::Other(_))\n                 if reduced_tys.to_fat_ptr && is_size_pair(from_ty) =>\n             {\n                 return false;\n-            },\n+            }\n \n             // fat ptr -> some struct | some struct -> fat ptr\n             (ReducedTy::Other(_), _) if reduced_tys.from_fat_ptr => {\n@@ -78,12 +85,14 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute from `{from_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if from_ty_orig.peel_refs() != from_ty.peel_refs() {\n-                            diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{from_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (_, ReducedTy::Other(_)) if reduced_tys.to_fat_ptr => {\n                 span_lint_and_then(\n                     cx,\n@@ -92,14 +101,18 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute to `{to_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if to_ty_orig.peel_refs() != to_ty.peel_refs() {\n-                            diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{to_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n \n-            (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty)) if from_ty != to_ty => {\n+            (ReducedTy::UnorderedFields(from_ty), ReducedTy::UnorderedFields(to_ty))\n+                if from_ty != to_ty =>\n+            {\n                 let same_adt_did = if let (ty::Adt(from_def, from_subs), ty::Adt(to_def, to_subs))\n                         = (from_ty.kind(), to_ty.kind())\n                         && from_def == to_def\n@@ -126,19 +139,25 @@ pub(super) fn check<'tcx>(\n                             ));\n                         } else {\n                             if from_ty_orig.peel_refs() != from_ty {\n-                                diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n+                                diag.note(&format!(\n+                                    \"the contained type `{from_ty}` has an undefined layout\"\n+                                ));\n                             }\n                             if to_ty_orig.peel_refs() != to_ty {\n-                                diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n+                                diag.note(&format!(\n+                                    \"the contained type `{to_ty}` has an undefined layout\"\n+                                ));\n                             }\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (\n                 ReducedTy::UnorderedFields(from_ty),\n-                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::Other(_)\n+                | ReducedTy::OrderedFields(..)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n             ) => {\n                 span_lint_and_then(\n                     cx,\n@@ -147,14 +166,18 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute from `{from_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if from_ty_orig.peel_refs() != from_ty {\n-                            diag.note(&format!(\"the contained type `{from_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{from_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (\n-                ReducedTy::Other(_) | ReducedTy::OrderedFields(..) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::Other(_)\n+                | ReducedTy::OrderedFields(..)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n                 ReducedTy::UnorderedFields(to_ty),\n             ) => {\n                 span_lint_and_then(\n@@ -164,19 +187,25 @@ pub(super) fn check<'tcx>(\n                     &format!(\"transmute into `{to_ty_orig}` which has an undefined layout\"),\n                     |diag| {\n                         if to_ty_orig.peel_refs() != to_ty {\n-                            diag.note(&format!(\"the contained type `{to_ty}` has an undefined layout\"));\n+                            diag.note(&format!(\n+                                \"the contained type `{to_ty}` has an undefined layout\"\n+                            ));\n                         }\n                     },\n                 );\n                 return true;\n-            },\n+            }\n             (\n-                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n-                ReducedTy::OrderedFields(..) | ReducedTy::Other(_) | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::OrderedFields(..)\n+                | ReducedTy::Other(_)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n+                ReducedTy::OrderedFields(..)\n+                | ReducedTy::Other(_)\n+                | ReducedTy::TypeErasure { raw_ptr_only: true },\n             )\n             | (ReducedTy::UnorderedFields(_), ReducedTy::UnorderedFields(_)) => {\n                 break;\n-            },\n+            }\n         }\n     }\n \n@@ -194,42 +223,38 @@ struct ReducedTys<'tcx> {\n }\n \n /// Remove references so long as both types are references.\n-fn reduce_refs<'tcx>(cx: &LateContext<'tcx>, mut from_ty: Ty<'tcx>, mut to_ty: Ty<'tcx>) -> ReducedTys<'tcx> {\n+fn reduce_refs<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    mut from_ty: Ty<'tcx>,\n+    mut to_ty: Ty<'tcx>,\n+) -> ReducedTys<'tcx> {\n     let mut from_raw_ptr = false;\n     let mut to_raw_ptr = false;\n-    let (from_fat_ptr, to_fat_ptr) = loop {\n-        break match (from_ty.kind(), to_ty.kind()) {\n-            (\n-                &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n-                &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n-            ) => {\n-                from_raw_ptr = matches!(*from_ty.kind(), ty::RawPtr(_));\n-                from_ty = from_sub_ty;\n-                to_raw_ptr = matches!(*to_ty.kind(), ty::RawPtr(_));\n-                to_ty = to_sub_ty;\n-                continue;\n-            },\n-            (&(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })), _)\n-                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n-            {\n-                (true, false)\n-            },\n-            (_, &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })))\n-                if !unsized_ty.is_sized(cx.tcx.at(DUMMY_SP), cx.param_env) =>\n-            {\n-                (false, true)\n-            },\n-            _ => (false, false),\n+    let (from_fat_ptr, to_fat_ptr) =\n+        loop {\n+            break match (from_ty.kind(), to_ty.kind()) {\n+                (\n+                    &(ty::Ref(_, from_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: from_sub_ty, .. })),\n+                    &(ty::Ref(_, to_sub_ty, _) | ty::RawPtr(TypeAndMut { ty: to_sub_ty, .. })),\n+                ) => {\n+                    from_raw_ptr = matches!(*from_ty.kind(), ty::RawPtr(_));\n+                    from_ty = from_sub_ty;\n+                    to_raw_ptr = matches!(*to_ty.kind(), ty::RawPtr(_));\n+                    to_ty = to_sub_ty;\n+                    continue;\n+                }\n+                (\n+                    &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })),\n+                    _,\n+                ) if !unsized_ty.is_sized(cx.tcx, cx.param_env) => (true, false),\n+                (\n+                    _,\n+                    &(ty::Ref(_, unsized_ty, _) | ty::RawPtr(TypeAndMut { ty: unsized_ty, .. })),\n+                ) if !unsized_ty.is_sized(cx.tcx, cx.param_env) => (false, true),\n+                _ => (false, false),\n+            };\n         };\n-    };\n-    ReducedTys {\n-        from_ty,\n-        to_ty,\n-        from_raw_ptr,\n-        to_raw_ptr,\n-        from_fat_ptr,\n-        to_fat_ptr,\n-    }\n+    ReducedTys { from_ty, to_ty, from_raw_ptr, to_raw_ptr, from_fat_ptr, to_fat_ptr }\n }\n \n enum ReducedTy<'tcx> {\n@@ -252,11 +277,11 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n         return match *ty.kind() {\n             ty::Array(sub_ty, _) if matches!(sub_ty.kind(), ty::Int(_) | ty::Uint(_)) => {\n                 ReducedTy::TypeErasure { raw_ptr_only: false }\n-            },\n+            }\n             ty::Array(sub_ty, _) | ty::Slice(sub_ty) => {\n                 ty = sub_ty;\n                 continue;\n-            },\n+            }\n             ty::Tuple(args) if args.is_empty() => ReducedTy::TypeErasure { raw_ptr_only: false },\n             ty::Tuple(args) => {\n                 let mut iter = args.iter();\n@@ -268,7 +293,7 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                     continue;\n                 }\n                 ReducedTy::UnorderedFields(ty)\n-            },\n+            }\n             ty::Adt(def, substs) if def.is_struct() => {\n                 let mut iter = def\n                     .non_enum_variant()\n@@ -287,10 +312,12 @@ fn reduce_ty<'tcx>(cx: &LateContext<'tcx>, mut ty: Ty<'tcx>) -> ReducedTy<'tcx>\n                 } else {\n                     ReducedTy::UnorderedFields(ty)\n                 }\n-            },\n-            ty::Adt(def, _) if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) => {\n+            }\n+            ty::Adt(def, _)\n+                if def.is_enum() && (def.variants().is_empty() || is_c_void(cx, ty)) =>\n+            {\n                 ReducedTy::TypeErasure { raw_ptr_only: false }\n-            },\n+            }\n             // TODO: Check if the conversion to or from at least one of a union's fields is valid.\n             ty::Adt(def, _) if def.is_union() => ReducedTy::TypeErasure { raw_ptr_only: false },\n             ty::Foreign(_) | ty::Param(_) => ReducedTy::TypeErasure { raw_ptr_only: false },\n@@ -329,7 +356,11 @@ fn same_except_params<'tcx>(subs1: SubstsRef<'tcx>, subs2: SubstsRef<'tcx>) -> b\n     for (ty1, ty2) in subs1.types().zip(subs2.types()).filter(|(ty1, ty2)| ty1 != ty2) {\n         match (ty1.kind(), ty2.kind()) {\n             (ty::Param(_), _) | (_, ty::Param(_)) => (),\n-            (ty::Adt(adt1, subs1), ty::Adt(adt2, subs2)) if adt1 == adt2 && same_except_params(subs1, subs2) => (),\n+            (ty::Adt(adt1, subs1), ty::Adt(adt2, subs2))\n+                if adt1 == adt2 && same_except_params(subs1, subs2) =>\n+            {\n+                ()\n+            }\n             _ => return false,\n         }\n     }"}, {"sha": "f6de87b0526cd2fe0b8a7ee70c1d23d0353b1d7c", "filename": "src/tools/clippy/clippy_lints/src/types/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -333,7 +333,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        let is_exported = cx.effective_visibilities.is_exported(item.def_id.def_id);\n+        let is_exported = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n \n         match item.kind {\n             ItemKind::Static(ty, _, _) | ItemKind::Const(ty, _) => self.check_ty(\n@@ -392,7 +392,7 @@ impl<'tcx> LateLintPass<'tcx> for Types {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &TraitItem<'_>) {\n-        let is_exported = cx.effective_visibilities.is_exported(item.def_id.def_id);\n+        let is_exported = cx.effective_visibilities.is_exported(item.owner_id.def_id);\n \n         let context = CheckTyContext {\n             is_exported,"}, {"sha": "2b964b64a3305d702ea51f8684316d61fc758738", "filename": "src/tools/clippy/clippy_lints/src/types/redundant_allocation.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -9,7 +9,12 @@ use rustc_span::symbol::sym;\n \n use super::{utils, REDUNDANT_ALLOCATION};\n \n-pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) -> bool {\n+pub(super) fn check(\n+    cx: &LateContext<'_>,\n+    hir_ty: &hir::Ty<'_>,\n+    qpath: &QPath<'_>,\n+    def_id: DefId,\n+) -> bool {\n     let mut applicability = Applicability::MaybeIncorrect;\n     let outer_sym = if Some(def_id) == cx.tcx.lang_items().owned_box() {\n         \"Box\"\n@@ -29,7 +34,12 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n             hir_ty.span,\n             &format!(\"usage of `{outer_sym}<{generic_snippet}>`\"),\n             |diag| {\n-                diag.span_suggestion(hir_ty.span, \"try\", format!(\"{generic_snippet}\"), applicability);\n+                diag.span_suggestion(\n+                    hir_ty.span,\n+                    \"try\",\n+                    format!(\"{generic_snippet}\"),\n+                    applicability,\n+                );\n                 diag.note(&format!(\n                     \"`{generic_snippet}` is already a pointer, `{outer_sym}<{generic_snippet}>` allocates a pointer on the heap\"\n                 ));\n@@ -55,11 +65,11 @@ pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_\n             // Reallocation of a fat pointer causes it to become thin. `hir_ty_to_ty` is safe to use\n             // here because `mod.rs` guarantees this lint is only run on types outside of bodies and\n             // is not run on locals.\n-            if !hir_ty_to_ty(cx.tcx, ty).is_sized(cx.tcx.at(ty.span), cx.param_env) {\n+            if !hir_ty_to_ty(cx.tcx, ty).is_sized(cx.tcx, cx.param_env) {\n                 return false;\n             }\n             ty.span\n-        },\n+        }\n         None => return false,\n     };\n     if inner_sym == outer_sym {"}, {"sha": "9ad2cb853d39a474255c0256dd2e30e5ce778ecf", "filename": "src/tools/clippy/clippy_lints/src/types/vec_box.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fvec_box.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -40,7 +40,7 @@ pub(super) fn check(\n             });\n             let ty_ty = hir_ty_to_ty(cx.tcx, boxed_ty);\n             if !ty_ty.has_escaping_bound_vars();\n-            if ty_ty.is_sized(cx.tcx.at(ty.span), cx.param_env);\n+            if ty_ty.is_sized(cx.tcx, cx.param_env);\n             if let Ok(ty_ty_size) = cx.layout_of(ty_ty).map(|l| l.size.bytes());\n             if ty_ty_size <= box_size_threshold;\n             then {"}, {"sha": "42bccc7212b3026216cabd16adefa30286f722db", "filename": "src/tools/clippy/clippy_lints/src/unused_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funused_self.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -56,12 +56,12 @@ impl<'tcx> LateLintPass<'tcx> for UnusedSelf {\n         }\n         let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id()).def_id;\n         let parent_item = cx.tcx.hir().expect_item(parent);\n-        let assoc_item = cx.tcx.associated_item(impl_item.def_id);\n+        let assoc_item = cx.tcx.associated_item(impl_item.owner_id);\n         if_chain! {\n             if let ItemKind::Impl(Impl { of_trait: None, .. }) = parent_item.kind;\n             if assoc_item.fn_has_self_parameter;\n             if let ImplItemKind::Fn(.., body_id) = &impl_item.kind;\n-            if !cx.effective_visibilities.is_exported(impl_item.def_id.def_id) || !self.avoid_breaking_exported_api;\n+            if !cx.effective_visibilities.is_exported(impl_item.owner_id.def_id) || !self.avoid_breaking_exported_api;\n             let body = cx.tcx.hir().body(*body_id);\n             if let [self_param, ..] = body.params;\n             if !is_local_used(cx, body, self_param.pat.hir_id);"}, {"sha": "f3611d174340458fa97177f28b63ddb8ab997b2d", "filename": "src/tools/clippy/clippy_lints/src/unwrap_in_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funwrap_in_result.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> LateLintPass<'tcx> for UnwrapInResult {\n fn lint_impl_body<'tcx>(cx: &LateContext<'tcx>, impl_span: Span, impl_item: &'tcx hir::ImplItem<'_>) {\n     if let ImplItemKind::Fn(_, body_id) = impl_item.kind {\n         let body = cx.tcx.hir().body(body_id);\n-        let typeck = cx.tcx.typeck(impl_item.def_id.def_id);\n+        let typeck = cx.tcx.typeck(impl_item.owner_id.def_id);\n         let mut result = Vec::new();\n         let _: Option<!> = for_each_expr(body.value, |e| {\n             // check for `expect`"}, {"sha": "1d2d3eb12e1147fd71a1bb14191e77f9da6972b3", "filename": "src/tools/clippy/clippy_lints/src/upper_case_acronyms.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fupper_case_acronyms.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -105,7 +105,7 @@ impl LateLintPass<'_> for UpperCaseAcronyms {\n     fn check_item(&mut self, cx: &LateContext<'_>, it: &Item<'_>) {\n         // do not lint public items or in macros\n         if in_external_macro(cx.sess(), it.span)\n-            || (self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(it.def_id.def_id))\n+            || (self.avoid_breaking_exported_api && cx.effective_visibilities.is_exported(it.owner_id.def_id))\n         {\n             return;\n         }"}, {"sha": "c6cdf3f85fc3dd891445c71db7a53847ea485ff8", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -106,7 +106,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             if !is_from_proc_macro(cx, item); // expensive, should be last check\n             then {\n                 StackItem::Check {\n-                    impl_id: item.def_id.def_id,\n+                    impl_id: item.owner_id.def_id,\n                     in_body: 0,\n                     types_to_skip: std::iter::once(self_ty.hir_id).collect(),\n                 }\n@@ -143,7 +143,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 // trait, not in the impl of the trait.\n                 let trait_method = cx\n                     .tcx\n-                    .associated_item(impl_item.def_id)\n+                    .associated_item(impl_item.owner_id)\n                     .trait_item_def_id\n                     .expect(\"impl method matches a trait method\");\n                 let trait_method_sig = cx.tcx.fn_sig(trait_method);"}, {"sha": "be98344470b9c5dbc2a6635b9657c820c201a47d", "filename": "src/tools/clippy/clippy_lints/src/wildcard_imports.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwildcard_imports.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -120,14 +120,14 @@ impl LateLintPass<'_> for WildcardImports {\n         if is_test_module_or_function(cx.tcx, item) {\n             self.test_modules_deep = self.test_modules_deep.saturating_add(1);\n         }\n-        let module = cx.tcx.parent_module_from_def_id(item.def_id.def_id);\n-        if cx.tcx.visibility(item.def_id.def_id) != ty::Visibility::Restricted(module.to_def_id()) {\n+        let module = cx.tcx.parent_module_from_def_id(item.owner_id.def_id);\n+        if cx.tcx.visibility(item.owner_id.def_id) != ty::Visibility::Restricted(module.to_def_id()) {\n             return;\n         }\n         if_chain! {\n             if let ItemKind::Use(use_path, UseKind::Glob) = &item.kind;\n             if self.warn_on_all || !self.check_exceptions(item, use_path.segments);\n-            let used_imports = cx.tcx.names_imported_by_glob_use(item.def_id.def_id);\n+            let used_imports = cx.tcx.names_imported_by_glob_use(item.owner_id.def_id);\n             if !used_imports.is_empty(); // Already handled by `unused_imports`\n             then {\n                 let mut applicability = Applicability::MachineApplicable;"}, {"sha": "3ebfc5e00e1426e8a63a83b3a09da3890655fd53", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -2281,7 +2281,7 @@ fn with_test_item_names(tcx: TyCtxt<'_>, module: LocalDefId, f: impl Fn(&[Symbol\n         Entry::Vacant(entry) => {\n             let mut names = Vec::new();\n             for id in tcx.hir().module_items(module) {\n-                if matches!(tcx.def_kind(id.def_id), DefKind::Const)\n+                if matches!(tcx.def_kind(id.owner_id), DefKind::Const)\n                     && let item = tcx.hir().item(id)\n                     && let ItemKind::Const(ty, _body) = item.kind {\n                     if let TyKind::Path(QPath::Resolved(_, path)) = ty.kind {"}, {"sha": "4e024ce4017932c2948c7095f510b4c594ee85cc", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -18,7 +18,7 @@ use rustc_middle::ty::{\n };\n use rustc_middle::ty::{GenericArg, GenericArgKind};\n use rustc_span::symbol::Ident;\n-use rustc_span::{sym, Span, Symbol, DUMMY_SP};\n+use rustc_span::{sym, Span, Symbol};\n use rustc_target::abi::{Size, VariantIdx};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n@@ -28,7 +28,7 @@ use crate::{match_def_path, path_res, paths};\n \n // Checks if the given type implements copy.\n pub fn is_copy<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n-    ty.is_copy_modulo_regions(cx.tcx.at(DUMMY_SP), cx.param_env)\n+    ty.is_copy_modulo_regions(cx.tcx, cx.param_env)\n }\n \n /// This checks whether a given type is known to implement Debug."}, {"sha": "0260f684838644a47cda01a7e5b0e638f738a15f", "filename": "src/tools/compiletest/src/common.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fcommon.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -269,10 +269,10 @@ pub struct Config {\n     pub runtool: Option<String>,\n \n     /// Flags to pass to the compiler when building for the host\n-    pub host_rustcflags: Option<String>,\n+    pub host_rustcflags: Vec<String>,\n \n     /// Flags to pass to the compiler when building for the target\n-    pub target_rustcflags: Option<String>,\n+    pub target_rustcflags: Vec<String>,\n \n     /// Whether tests should be optimized by default. Individual test-suites and test files may\n     /// override this setting.\n@@ -457,12 +457,12 @@ pub enum Endian {\n }\n \n impl TargetCfg {\n-    fn new(rustc_path: &Path, target: &str, target_rustcflags: &Option<String>) -> TargetCfg {\n+    fn new(rustc_path: &Path, target: &str, target_rustcflags: &Vec<String>) -> TargetCfg {\n         let output = match Command::new(rustc_path)\n             .arg(\"--print=cfg\")\n             .arg(\"--target\")\n             .arg(target)\n-            .args(target_rustcflags.into_iter().map(|s| s.split_whitespace()).flatten())\n+            .args(target_rustcflags)\n             .output()\n         {\n             Ok(output) => output,"}, {"sha": "19cf54780c1f90c7219a83188d287f94eaf155a1", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -254,8 +254,8 @@ pub fn parse_config(args: Vec<String>) -> Config {\n         }),\n         logfile: matches.opt_str(\"logfile\").map(|s| PathBuf::from(&s)),\n         runtool: matches.opt_str(\"runtool\"),\n-        host_rustcflags: Some(matches.opt_strs(\"host-rustcflags\").join(\" \")),\n-        target_rustcflags: Some(matches.opt_strs(\"target-rustcflags\").join(\" \")),\n+        host_rustcflags: matches.opt_strs(\"host-rustcflags\"),\n+        target_rustcflags: matches.opt_strs(\"target-rustcflags\"),\n         optimize_tests: matches.opt_present(\"optimize-tests\"),\n         target,\n         host: opt_str2(matches.opt_str(\"host\")),\n@@ -322,8 +322,8 @@ pub fn log_config(config: &Config) {\n         format!(\"force_pass_mode: {}\", opt_str(&config.force_pass_mode.map(|m| format!(\"{}\", m))),),\n     );\n     logv(c, format!(\"runtool: {}\", opt_str(&config.runtool)));\n-    logv(c, format!(\"host-rustcflags: {}\", opt_str(&config.host_rustcflags)));\n-    logv(c, format!(\"target-rustcflags: {}\", opt_str(&config.target_rustcflags)));\n+    logv(c, format!(\"host-rustcflags: {:?}\", config.host_rustcflags));\n+    logv(c, format!(\"target-rustcflags: {:?}\", config.target_rustcflags));\n     logv(c, format!(\"target: {}\", config.target));\n     logv(c, format!(\"host: {}\", config.host));\n     logv(c, format!(\"android-cross-path: {:?}\", config.android_cross_path.display()));"}, {"sha": "8af5f1da694b9f59bd87a7611495c10f1f70b9ea", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 7, "deletions": 28, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -558,10 +558,7 @@ impl<'test> TestCx<'test> {\n             .arg(&aux_dir)\n             .args(&self.props.compile_flags)\n             .envs(self.props.rustc_env.clone());\n-        self.maybe_add_external_args(\n-            &mut rustc,\n-            self.split_maybe_args(&self.config.target_rustcflags),\n-        );\n+        self.maybe_add_external_args(&mut rustc, &self.config.target_rustcflags);\n \n         let src = match read_from {\n             ReadFrom::Stdin(src) => Some(src),\n@@ -629,10 +626,7 @@ impl<'test> TestCx<'test> {\n             .arg(\"-L\")\n             .arg(aux_dir);\n         self.set_revision_flags(&mut rustc);\n-        self.maybe_add_external_args(\n-            &mut rustc,\n-            self.split_maybe_args(&self.config.target_rustcflags),\n-        );\n+        self.maybe_add_external_args(&mut rustc, &self.config.target_rustcflags);\n         rustc.args(&self.props.compile_flags);\n \n         self.compose_and_run_compiler(rustc, Some(src))\n@@ -1186,23 +1180,14 @@ impl<'test> TestCx<'test> {\n         ProcRes { status, stdout: out, stderr: err, cmdline: format!(\"{:?}\", cmd) }\n     }\n \n-    fn cleanup_debug_info_options(&self, options: &Option<String>) -> Option<String> {\n-        if options.is_none() {\n-            return None;\n-        }\n-\n+    fn cleanup_debug_info_options(&self, options: &Vec<String>) -> Vec<String> {\n         // Remove options that are either unwanted (-O) or may lead to duplicates due to RUSTFLAGS.\n         let options_to_remove = [\"-O\".to_owned(), \"-g\".to_owned(), \"--debuginfo\".to_owned()];\n-        let new_options = self\n-            .split_maybe_args(options)\n-            .into_iter()\n-            .filter(|x| !options_to_remove.contains(x))\n-            .collect::<Vec<String>>();\n \n-        Some(new_options.join(\" \"))\n+        options.iter().filter(|x| !options_to_remove.contains(x)).map(|x| x.clone()).collect()\n     }\n \n-    fn maybe_add_external_args(&self, cmd: &mut Command, args: Vec<String>) {\n+    fn maybe_add_external_args(&self, cmd: &mut Command, args: &Vec<String>) {\n         // Filter out the arguments that should not be added by runtest here.\n         //\n         // Notable use-cases are: do not add our optimisation flag if\n@@ -2035,15 +2020,9 @@ impl<'test> TestCx<'test> {\n         }\n \n         if self.props.force_host {\n-            self.maybe_add_external_args(\n-                &mut rustc,\n-                self.split_maybe_args(&self.config.host_rustcflags),\n-            );\n+            self.maybe_add_external_args(&mut rustc, &self.config.host_rustcflags);\n         } else {\n-            self.maybe_add_external_args(\n-                &mut rustc,\n-                self.split_maybe_args(&self.config.target_rustcflags),\n-            );\n+            self.maybe_add_external_args(&mut rustc, &self.config.target_rustcflags);\n             if !is_rustdoc {\n                 if let Some(ref linker) = self.config.linker {\n                     rustc.arg(format!(\"-Clinker={}\", linker));"}, {"sha": "5ec787dd44113ae9618cf639ac7e7134cc8b984b", "filename": "src/tools/miri/src/stacked_borrows/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68c836a904e5a421712db311421c5266f9ce71c0/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fstacked_borrows%2Fmod.rs?ref=68c836a904e5a421712db311421c5266f9ce71c0", "patch": "@@ -16,7 +16,6 @@ use rustc_middle::ty::{\n     layout::{HasParamEnv, LayoutOf},\n     Ty,\n };\n-use rustc_span::DUMMY_SP;\n use rustc_target::abi::Abi;\n use rustc_target::abi::Size;\n use smallvec::SmallVec;\n@@ -714,12 +713,12 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n                 let mut kind_str = format!(\"{kind}\");\n                 match kind {\n                     RefKind::Unique { two_phase: false }\n-                        if !ty.is_unpin(this.tcx.at(DUMMY_SP), this.param_env()) =>\n+                        if !ty.is_unpin(*this.tcx, this.param_env()) =>\n                     {\n                         write!(kind_str, \" (!Unpin pointee type {ty})\").unwrap()\n                     },\n                     RefKind::Shared\n-                        if !ty.is_freeze(this.tcx.at(DUMMY_SP), this.param_env()) =>\n+                        if !ty.is_freeze(*this.tcx, this.param_env()) =>\n                     {\n                         write!(kind_str, \" (!Freeze pointee type {ty})\").unwrap()\n                     },\n@@ -834,7 +833,7 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n         let perm = match kind {\n             RefKind::Unique { two_phase: false }\n-                if place.layout.ty.is_unpin(this.tcx.at(DUMMY_SP), this.param_env()) =>\n+                if place.layout.ty.is_unpin(*this.tcx, this.param_env()) =>\n             {\n                 // Only if the type is unpin do we actually enforce uniqueness\n                 Permission::Unique"}]}