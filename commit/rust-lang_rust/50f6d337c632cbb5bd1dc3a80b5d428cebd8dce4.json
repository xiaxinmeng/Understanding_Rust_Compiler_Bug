{"sha": "50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4", "node_id": "C_kwDOAAsO6NoAKDUwZjZkMzM3YzYzMmNiYjViZDFkYzNhODBiNWQ0MjhjZWJkOGRjZTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-12T10:51:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-12T10:51:31Z"}, "message": "Auto merge of #102460 - flba-eb:fix_85261_prevent_alloc_after_fork, r=thomcc\n\nPrevent UB in child process after calling libc::fork\n\nAfter calling libc::fork, the child process tried to access a TLS variable when processing a panic. This caused a memory allocation which is UB in the child.\nTo prevent this from happening, the panic handler will not access the TLS variable in case `panic::always_abort` was called before.\n\nFixes #85261 (not only on Android systems, but also on Linux/QNX with TLS disabled, see issue for more details)\n\nMain drawbacks of this fix:\n* Panic messages can incorrectly omit `core::panic::PanicInfo` struct in case several panics (of multiple threads) occur at the same time. The handler cannot distinguish between multiple panics in different threads or recursive ones in the same thread, but the message will contain a hint about the uncertainty.\n* `panic_count::increase()` will be a bit slower as it has an additional `if`, but this should be irrelevant as it is only called in case of a panic.", "tree": {"sha": "c241dcdf7f0df64cbd1ecdfdf055f905182b11ac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c241dcdf7f0df64cbd1ecdfdf055f905182b11ac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4", "html_url": "https://github.com/rust-lang/rust/commit/50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e6ce5627a9e8af9ae4673a390954fffaf526e5cc", "html_url": "https://github.com/rust-lang/rust/commit/e6ce5627a9e8af9ae4673a390954fffaf526e5cc"}, {"sha": "4c5d6bb490af0b046c4e445ae90edc0c38623591", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c5d6bb490af0b046c4e445ae90edc0c38623591", "html_url": "https://github.com/rust-lang/rust/commit/4c5d6bb490af0b046c4e445ae90edc0c38623591"}], "stats": {"total": 70, "additions": 65, "deletions": 5}, "files": [{"sha": "d4976a469cc15d4acbcec47ea13108c97cbb00ea", "filename": "library/std/src/panicking.rs", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4/library%2Fstd%2Fsrc%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4/library%2Fstd%2Fsrc%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanicking.rs?ref=50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4", "patch": "@@ -308,6 +308,14 @@ pub mod panic_count {\n     // Additionally, the top bit of GLOBAL_PANIC_COUNT (GLOBAL_ALWAYS_ABORT_FLAG)\n     // records whether panic::always_abort() has been called.  This can only be\n     // set, never cleared.\n+    // panic::always_abort() is usually called to prevent memory allocations done by\n+    // the panic handling in the child created by `libc::fork`.\n+    // Memory allocations performed in  a child created with `libc::fork` are undefined\n+    // behavior in most operating systems.\n+    // Accessing LOCAL_PANIC_COUNT in a child created by `libc::fork` would lead to a memory\n+    // allocation. Only GLOBAL_PANIC_COUNT can be accessed in this situation. This is\n+    // sufficient because a child process will always have exactly one thread only.\n+    // See also #85261 for details.\n     //\n     // This could be viewed as a struct containing a single bit and an n-1-bit\n     // value, but if we wrote it like that it would be more than a single word,\n@@ -318,15 +326,26 @@ pub mod panic_count {\n     // panicking thread consumes at least 2 bytes of address space.\n     static GLOBAL_PANIC_COUNT: AtomicUsize = AtomicUsize::new(0);\n \n+    // Return the state of the ALWAYS_ABORT_FLAG and number of panics.\n+    //\n+    // If ALWAYS_ABORT_FLAG is not set, the number is determined on a per-thread\n+    // base (stored in LOCAL_PANIC_COUNT), i.e. it is the amount of recursive calls\n+    // of the calling thread.\n+    // If ALWAYS_ABORT_FLAG is set, the number equals the *global* number of panic\n+    // calls. See above why LOCAL_PANIC_COUNT is not used.\n     pub fn increase() -> (bool, usize) {\n-        (\n-            GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed) & ALWAYS_ABORT_FLAG != 0,\n+        let global_count = GLOBAL_PANIC_COUNT.fetch_add(1, Ordering::Relaxed);\n+        let must_abort = global_count & ALWAYS_ABORT_FLAG != 0;\n+        let panics = if must_abort {\n+            global_count & !ALWAYS_ABORT_FLAG\n+        } else {\n             LOCAL_PANIC_COUNT.with(|c| {\n                 let next = c.get() + 1;\n                 c.set(next);\n                 next\n-            }),\n-        )\n+            })\n+        };\n+        (must_abort, panics)\n     }\n \n     pub fn decrease() {"}, {"sha": "6d4d24922253d112720cc54e916cb58f75fc5760", "filename": "src/test/ui/process/process-panic-after-fork.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprocess%2Fprocess-panic-after-fork.rs?ref=50f6d337c632cbb5bd1dc3a80b5d428cebd8dce4", "patch": "@@ -5,7 +5,6 @@\n // ignore-sgx no libc\n // ignore-emscripten no processes\n // ignore-sgx no processes\n-// ignore-android: FIXME(#85261)\n // ignore-fuchsia no fork\n \n #![feature(rustc_private)]\n@@ -79,7 +78,49 @@ unsafe impl<A:GlobalAlloc> GlobalAlloc for PidChecking<A> {\n fn expect_aborted(status: ExitStatus) {\n     dbg!(status);\n     let signal = status.signal().expect(\"expected child process to die of signal\");\n+\n+    #[cfg(not(target_os = \"android\"))]\n     assert!(signal == libc::SIGABRT || signal == libc::SIGILL || signal == libc::SIGTRAP);\n+\n+    #[cfg(target_os = \"android\")]\n+    {\n+        // Android signals an abort() call with SIGSEGV at address 0xdeadbaad\n+        // See e.g. https://groups.google.com/g/android-ndk/c/laW1CJc7Icc\n+        assert!(signal == libc::SIGSEGV);\n+\n+        // Additional checks performed:\n+        // 1. Find last tombstone (similar to coredump but in text format) from the\n+        //    same executable (path) as we are (must be because of usage of fork):\n+        //    This ensures that we look into the correct tombstone.\n+        // 2. Cause of crash is a SIGSEGV with address 0xdeadbaad.\n+        // 3. libc::abort call is in one of top two functions on callstack.\n+        // The last two steps distinguish between a normal SIGSEGV and one caused\n+        // by libc::abort.\n+\n+        let this_exe = std::env::current_exe().unwrap().into_os_string().into_string().unwrap();\n+        let exe_string = format!(\">>> {this_exe} <<<\");\n+        let tombstone = (0..100)\n+            .map(|n| format!(\"/data/tombstones/tombstone_{n:02}\"))\n+            .filter(|f| std::path::Path::new(&f).exists())\n+            .map(|f| std::fs::read_to_string(&f).expect(\"Cannot read tombstone file\"))\n+            .filter(|f| f.contains(&exe_string))\n+            .last()\n+            .expect(\"no tombstone found\");\n+\n+        println!(\"Content of tombstone:\\n{tombstone}\");\n+\n+        assert!(\n+            tombstone.contains(\"signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr deadbaad\")\n+        );\n+        let abort_on_top = tombstone\n+            .lines()\n+            .skip_while(|l| !l.contains(\"backtrace:\"))\n+            .skip(1)\n+            .take_while(|l| l.starts_with(\"    #\"))\n+            .take(2)\n+            .any(|f| f.contains(\"/system/lib/libc.so (abort\"));\n+        assert!(abort_on_top);\n+    }\n }\n \n fn main() {"}]}