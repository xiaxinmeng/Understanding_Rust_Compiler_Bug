{"sha": "875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg3NWIzMWMzM2Y2YjBjY2JiODU5MGMyYjNjOWNiZjFiMTFlZDYxNjU=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-03-08T02:15:56Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-04-09T20:31:03Z"}, "message": "Implement reductions", "tree": {"sha": "dd46e6671fd39e00a20e50556387615044919046", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd46e6671fd39e00a20e50556387615044919046"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "html_url": "https://github.com/rust-lang/rust/commit/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "926cf3aba3fe453e36bc7e56b2b8b8894fca5377", "url": "https://api.github.com/repos/rust-lang/rust/commits/926cf3aba3fe453e36bc7e56b2b8b8894fca5377", "html_url": "https://github.com/rust-lang/rust/commit/926cf3aba3fe453e36bc7e56b2b8b8894fca5377"}], "stats": {"total": 405, "additions": 288, "deletions": 117}, "files": [{"sha": "0fc2641516dd66dacf0e69b2dc113d3b77ace7d4", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "patch": "@@ -11,6 +11,8 @@ mod first;\n mod permute;\n #[macro_use]\n mod transmute;\n+#[macro_use]\n+mod reduction;\n \n mod comparisons;\n mod fmt;"}, {"sha": "1d25db46742f66122da949c60a3bff420e3b26c2", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "patch": "@@ -3,7 +3,7 @@ use crate::LanesAtMost32;\n /// A mask where each lane is represented by a single bit.\n #[derive(Copy, Clone, Debug)]\n #[repr(transparent)]\n-pub struct BitMask<const LANES: usize>(u64)\n+pub struct BitMask<const LANES: usize>(pub(crate) u64)\n where\n     BitMask<LANES>: LanesAtMost32;\n "}, {"sha": "a6689ce48c665668375ce74ffb44aa2c52ba9f66", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 72, "deletions": 56, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "patch": "@@ -14,36 +14,41 @@ impl core::fmt::Display for TryFromMaskError {\n }\n \n macro_rules! define_mask {\n-    { $(#[$attr:meta])* struct $name:ident<const $lanes:ident: usize>($type:ty); } => {\n+    {\n+        $(#[$attr:meta])*\n+        struct $name:ident<const $lanes:ident: usize>(\n+            crate::$type:ident<$lanes2:ident>\n+        );\n+    } => {\n         $(#[$attr])*\n         #[derive(Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n         #[repr(transparent)]\n-        pub struct $name<const $lanes: usize>($type)\n+        pub struct $name<const $lanes: usize>(crate::$type<$lanes2>)\n         where\n-            $type: crate::LanesAtMost32;\n+            crate::$type<LANES>: crate::LanesAtMost32;\n \n         impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {}\n \n         impl<const LANES: usize> Clone for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n         }\n \n-        impl<const $lanes: usize> $name<$lanes>\n+        impl<const LANES: usize> $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n-                Self(<$type>::splat(\n+                Self(<crate::$type<LANES>>::splat(\n                     if value {\n                         -1\n                     } else {\n@@ -76,64 +81,73 @@ macro_rules! define_mask {\n                 }\n             }\n \n-            /// Creates a mask from an integer vector.\n+            /// Converts the mask to the equivalent integer representation, where -1 represents\n+            /// \"set\" and 0 represents \"unset\".\n+            #[inline]\n+            pub fn to_int(self) -> crate::$type<LANES> {\n+                self.0\n+            }\n+\n+            /// Creates a  mask from the equivalent integer representation, where -1 represents\n+            /// \"set\" and 0 represents \"unset\".\n             ///\n-            /// # Safety\n-            /// All lanes must be either 0 or -1.\n+            /// Each provided lane must be either 0 or -1.\n             #[inline]\n-            pub unsafe fn from_int_unchecked(value: $type) -> Self {\n+            pub unsafe fn from_int_unchecked(value: crate::$type<LANES>) -> Self {\n                 Self(value)\n             }\n \n-            /// Creates a mask from an integer vector.\n+            /// Creates a mask from the equivalent integer representation, where -1 represents\n+            /// \"set\" and 0 represents \"unset\".\n             ///\n             /// # Panics\n             /// Panics if any lane is not 0 or -1.\n             #[inline]\n-            pub fn from_int(value: $type) -> Self {\n+            pub fn from_int(value: crate::$type<LANES>) -> Self {\n                 use core::convert::TryInto;\n                 value.try_into().unwrap()\n             }\n         }\n \n-        impl<const $lanes: usize> core::convert::From<bool> for $name<$lanes>\n+        impl<const LANES: usize> core::convert::From<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn from(value: bool) -> Self {\n                 Self::splat(value)\n             }\n         }\n \n-        impl<const $lanes: usize> core::convert::TryFrom<$type> for $name<$lanes>\n+        impl<const LANES: usize> core::convert::TryFrom<crate::$type<LANES>> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Error = TryFromMaskError;\n-            fn try_from(value: $type) -> Result<Self, Self::Error> {\n-                if value.as_slice().iter().all(|x| *x == 0 || *x == -1) {\n+            fn try_from(value: crate::$type<LANES>) -> Result<Self, Self::Error> {\n+                let valid = (value.lanes_eq(crate::$type::<LANES>::splat(0)) | value.lanes_eq(crate::$type::<LANES>::splat(-1))).all();\n+                if valid {\n                     Ok(Self(value))\n                 } else {\n                     Err(TryFromMaskError(()))\n                 }\n             }\n         }\n \n-        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for $type\n+        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::$type<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n-            fn from(value: $name<$lanes>) -> Self {\n+            fn from(value: $name<LANES>) -> Self {\n                 value.0\n             }\n         }\n \n-        impl<const $lanes: usize> core::convert::From<crate::BitMask<$lanes>> for $name<$lanes>\n+        impl<const LANES: usize> core::convert::From<crate::BitMask<LANES>> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n-            crate::BitMask<$lanes>: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::BitMask<LANES>: crate::LanesAtMost32,\n         {\n-            fn from(value: crate::BitMask<$lanes>) -> Self {\n+            fn from(value: crate::BitMask<LANES>) -> Self {\n                 // TODO use an intrinsic to do this efficiently (with LLVM's sext instruction)\n                 let mut mask = Self::splat(false);\n                 for lane in 0..LANES {\n@@ -143,10 +157,10 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for crate::BitMask<$lanes>\n+        impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::BitMask<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n-            crate::BitMask<$lanes>: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n+            crate::BitMask<LANES>: crate::LanesAtMost32,\n         {\n             fn from(value: $name<$lanes>) -> Self {\n                 // TODO use an intrinsic to do this efficiently (with LLVM's trunc instruction)\n@@ -158,9 +172,9 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 f.debug_list()\n@@ -169,36 +183,36 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::Binary for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::Binary for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::Binary::fmt(&self.0, f)\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::Octal for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::Octal for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::Octal::fmt(&self.0, f)\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::LowerHex for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::LowerHex for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::LowerHex::fmt(&self.0, f)\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::UpperHex for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::UpperHex for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::UpperHex::fmt(&self.0, f)\n@@ -207,7 +221,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -218,7 +232,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -229,7 +243,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -240,7 +254,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -251,7 +265,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -262,7 +276,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -273,7 +287,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -284,7 +298,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -295,7 +309,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -306,7 +320,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -317,7 +331,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n@@ -327,7 +341,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n@@ -337,7 +351,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n@@ -347,7 +361,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n@@ -357,7 +371,7 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n@@ -367,13 +381,15 @@ macro_rules! define_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n         where\n-            $type: crate::LanesAtMost32,\n+            crate::$type<LANES>: crate::LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n                 *self ^= Self::splat(rhs);\n             }\n         }\n+\n+        impl_full_mask_reductions! { $name, $type }\n     }\n }\n "}, {"sha": "4503187e4b8a857c1cd63ff1358c4a82d5d4d050", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 68, "deletions": 60, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "patch": "@@ -7,25 +7,27 @@ pub use full_masks::*;\n mod bitmask;\n pub use bitmask::*;\n \n-use crate::LanesAtMost32;\n+use crate::{LanesAtMost32, SimdI128, SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize};\n \n macro_rules! define_opaque_mask {\n     {\n         $(#[$attr:meta])*\n-        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n-        @bits $bits_ty:ty\n+        struct $name:ident<const $lanes:ident: usize>($inner_ty:ident<$lanes2:ident>);\n+        @bits $bits_ty:ident\n     } => {\n         $(#[$attr])*\n         #[allow(non_camel_case_types)]\n-        pub struct $name<const $lanes: usize>($inner_ty) where $bits_ty: LanesAtMost32;\n+        pub struct $name<const LANES: usize>($inner_ty<LANES>) where $bits_ty<LANES>: LanesAtMost32;\n \n-        impl<const $lanes: usize> $name<$lanes>\n+        impl_opaque_mask_reductions! { $name, $inner_ty, $bits_ty }\n+\n+        impl<const LANES: usize> $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32\n+            $bits_ty<LANES>: LanesAtMost32\n         {\n             /// Construct a mask by setting all lanes to the given value.\n             pub fn splat(value: bool) -> Self {\n-                Self(<$inner_ty>::splat(value))\n+                Self(<$inner_ty<LANES>>::splat(value))\n             }\n \n             /// Converts an array to a SIMD vector.\n@@ -69,106 +71,112 @@ macro_rules! define_opaque_mask {\n             }\n         }\n \n-        impl<const $lanes: usize> From<BitMask<$lanes>> for $name<$lanes>\n+        impl<const LANES: usize> From<BitMask<LANES>> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n-            BitMask<$lanes>: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n+            BitMask<LANES>: LanesAtMost32,\n         {\n-            fn from(value: BitMask<$lanes>) -> Self {\n+            fn from(value: BitMask<LANES>) -> Self {\n                 Self(value.into())\n             }\n         }\n \n-        impl<const $lanes: usize> From<$name<$lanes>> for crate::BitMask<$lanes>\n+        impl<const LANES: usize> From<$name<LANES>> for crate::BitMask<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n-            BitMask<$lanes>: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n+            BitMask<LANES>: LanesAtMost32,\n         {\n-            fn from(value: $name<$lanes>) -> Self {\n+            fn from(value: $name<LANES>) -> Self {\n                 value.0.into()\n             }\n         }\n \n-        impl<const $lanes: usize> From<$inner_ty> for $name<$lanes>\n+        impl<const LANES: usize> From<$inner_ty<LANES>> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n-            fn from(value: $inner_ty) -> Self {\n+            fn from(value: $inner_ty<LANES>) -> Self {\n                 Self(value)\n             }\n         }\n \n-        impl<const $lanes: usize> From<$name<$lanes>> for $inner_ty\n+        impl<const LANES: usize> From<$name<LANES>> for $inner_ty<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n-            fn from(value: $name<$lanes>) -> Self {\n+            fn from(value: $name<LANES>) -> Self {\n                 value.0\n             }\n         }\n \n         // vector/array conversion\n-        impl<const $lanes: usize> From<[bool; $lanes]> for $name<$lanes> where $bits_ty: crate::LanesAtMost32 {\n-            fn from(array: [bool; $lanes]) -> Self {\n+        impl<const LANES: usize> From<[bool; LANES]> for $name<LANES>\n+        where\n+            $bits_ty<LANES>: crate::LanesAtMost32\n+        {\n+            fn from(array: [bool; LANES]) -> Self {\n                 Self::from_array(array)\n             }\n         }\n \n-        impl <const $lanes: usize> From<$name<$lanes>> for [bool; $lanes] where $bits_ty: crate::LanesAtMost32 {\n-            fn from(vector: $name<$lanes>) -> Self {\n+        impl <const LANES: usize> From<$name<LANES>> for [bool; LANES]\n+        where\n+            $bits_ty<LANES>: crate::LanesAtMost32\n+        {\n+            fn from(vector: $name<LANES>) -> Self {\n                 vector.to_array()\n             }\n         }\n \n-        impl<const $lanes: usize> Copy for $name<$lanes>\n+        impl<const LANES: usize> Copy for $name<LANES>\n         where\n-            $inner_ty: Copy,\n-            $bits_ty: LanesAtMost32,\n+            $inner_ty<LANES>: Copy,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {}\n \n-        impl<const $lanes: usize> Clone for $name<$lanes>\n+        impl<const LANES: usize> Clone for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn clone(&self) -> Self {\n                 *self\n             }\n         }\n \n-        impl<const $lanes: usize> Default for $name<$lanes>\n+        impl<const LANES: usize> Default for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn default() -> Self {\n                 Self::splat(false)\n             }\n         }\n \n-        impl<const $lanes: usize> PartialEq for $name<$lanes>\n+        impl<const LANES: usize> PartialEq for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn eq(&self, other: &Self) -> bool {\n                 self.0 == other.0\n             }\n         }\n \n-        impl<const $lanes: usize> PartialOrd for $name<$lanes>\n+        impl<const LANES: usize> PartialOrd for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n                 self.0.partial_cmp(&other.0)\n             }\n         }\n \n-        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes>\n+        impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                 core::fmt::Debug::fmt(&self.0, f)\n@@ -177,7 +185,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -188,7 +196,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -199,7 +207,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -210,7 +218,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -221,7 +229,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -232,7 +240,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -243,7 +251,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -254,7 +262,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = Self;\n             #[inline]\n@@ -265,7 +273,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -276,7 +284,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::Not for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             type Output = $name<LANES>;\n             #[inline]\n@@ -287,7 +295,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n@@ -297,7 +305,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n@@ -307,7 +315,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n@@ -317,7 +325,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n@@ -327,7 +335,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n@@ -337,7 +345,7 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES>\n         where\n-            $bits_ty: LanesAtMost32,\n+            $bits_ty<LANES>: LanesAtMost32,\n         {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n@@ -352,47 +360,47 @@ define_opaque_mask! {\n     ///\n     /// The layout of this type is unspecified.\n     struct Mask8<const LANES: usize>(SimdMask8<LANES>);\n-    @bits crate::SimdI8<LANES>\n+    @bits SimdI8\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 16-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n     struct Mask16<const LANES: usize>(SimdMask16<LANES>);\n-    @bits crate::SimdI16<LANES>\n+    @bits SimdI16\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 32-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n     struct Mask32<const LANES: usize>(SimdMask32<LANES>);\n-    @bits crate::SimdI32<LANES>\n+    @bits SimdI32\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 64-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n     struct Mask64<const LANES: usize>(SimdMask64<LANES>);\n-    @bits crate::SimdI64<LANES>\n+    @bits SimdI64\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` 128-bit elements.\n     ///\n     /// The layout of this type is unspecified.\n     struct Mask128<const LANES: usize>(SimdMask128<LANES>);\n-    @bits crate::SimdI128<LANES>\n+    @bits SimdI128\n }\n \n define_opaque_mask! {\n     /// Mask for vectors with `LANES` pointer-width elements.\n     ///\n     /// The layout of this type is unspecified.\n     struct MaskSize<const LANES: usize>(SimdMaskSize<LANES>);\n-    @bits crate::SimdIsize<LANES>\n+    @bits SimdIsize\n }\n \n /// Vector of eight 8-bit masks"}, {"sha": "0c6d91a2befe1d0dc416c229165d39a4b1d4a71f", "filename": "crates/core_simd/src/reduction.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Freduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Freduction.rs?ref=875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "patch": "@@ -0,0 +1,142 @@\n+macro_rules! impl_integer_reductions {\n+    { $name:ident, $scalar:ty } => {\n+        impl<const LANES: usize> crate::$name<LANES>\n+        where\n+            Self: crate::LanesAtMost32\n+        {\n+            /// Produces the sum of the lanes of the vector, with wrapping addition.\n+            #[inline]\n+            pub fn wrapping_sum(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_add_ordered(self, 0) }\n+            }\n+\n+            /// Produces the sum of the lanes of the vector, with wrapping multiplication.\n+            #[inline]\n+            pub fn wrapping_product(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_mul_ordered(self, 1) }\n+            }\n+\n+            /// Sequentially performs bitwise \"and\" between the lanes of the vector.\n+            #[inline]\n+            pub fn and_lanes(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_and(self) }\n+            }\n+\n+            /// Sequentially performs bitwise \"or\" between the lanes of the vector.\n+            #[inline]\n+            pub fn or_lanes(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_or(self) }\n+            }\n+\n+            /// Sequentially performs bitwise \"xor\" between the lanes of the vector.\n+            #[inline]\n+            pub fn xor_lanes(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_xor(self) }\n+            }\n+\n+            /// Returns the maximum lane in the vector.\n+            #[inline]\n+            pub fn max_lane(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            /// Returns the minimum lane in the vector.\n+            #[inline]\n+            pub fn min_lane(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_min(self) }\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! impl_float_reductions {\n+    { $name:ident, $scalar:ty } => {\n+        impl<const LANES: usize> crate::$name<LANES>\n+        where\n+            Self: crate::LanesAtMost32\n+        {\n+            /// Produces the sum of the lanes of the vector.\n+            #[inline]\n+            pub fn sum(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_add_ordered(self, 0.) }\n+            }\n+\n+            /// Produces the sum of the lanes of the vector.\n+            #[inline]\n+            pub fn product(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_mul_ordered(self, 1.) }\n+            }\n+\n+            /// Returns the maximum lane in the vector.\n+            #[inline]\n+            pub fn max_lane(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_max(self) }\n+            }\n+\n+            /// Returns the minimum lane in the vector.\n+            #[inline]\n+            pub fn min_lane(self) -> $scalar {\n+                unsafe { crate::intrinsics::simd_reduce_min(self) }\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! impl_full_mask_reductions {\n+    { $name:ident, $inner:ident } => {\n+        impl<const LANES: usize> crate::$name<LANES>\n+        where\n+            crate::$inner<LANES>: crate::LanesAtMost32\n+        {\n+            /// Returns true if any lane is set, or false otherwise.\n+            #[inline]\n+            pub fn any(self) -> bool {\n+                unsafe { crate::intrinsics::simd_reduce_any(self.to_int()) }\n+            }\n+\n+            /// Returns true if all lanes are set, or false otherwise.\n+            #[inline]\n+            pub fn all(self) -> bool {\n+                unsafe { crate::intrinsics::simd_reduce_all(self.to_int()) }\n+            }\n+        }\n+    }\n+}\n+\n+macro_rules! impl_opaque_mask_reductions {\n+    { $name:ident, $inner:ident, $bits_ty:ident } => {\n+        impl<const LANES: usize> $name<LANES>\n+        where\n+            $bits_ty<LANES>: crate::LanesAtMost32\n+        {\n+            /// Returns true if any lane is set, or false otherwise.\n+            #[inline]\n+            pub fn any(self) -> bool {\n+                self.0.any()\n+            }\n+\n+            /// Returns true if all lanes are set, or false otherwise.\n+            #[inline]\n+            pub fn all(self) -> bool {\n+                self.0.all()\n+            }\n+        }\n+    }\n+}\n+\n+impl<const LANES: usize> crate::BitMask<LANES>\n+where\n+    crate::BitMask<LANES>: crate::LanesAtMost32,\n+{\n+    /// Returns true if any lane is set, or false otherwise.\n+    #[inline]\n+    pub fn any(self) -> bool {\n+        self.0 != 0\n+    }\n+\n+    /// Returns true if all lanes are set, or false otherwise.\n+    #[inline]\n+    pub fn all(self) -> bool {\n+        self.0 == (!0) >> (64 - LANES)\n+    }\n+}"}, {"sha": "91585b46946161dc719be88eefcec229ff18df92", "filename": "crates/core_simd/src/vector/float.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Ffloat.rs?ref=875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "patch": "@@ -6,6 +6,7 @@\n macro_rules! impl_float_vector {\n     { $name:ident, $type:ty, $bits_ty:ident, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n+        impl_float_reductions! { $name, $type }\n \n         impl<const LANES: usize> $name<LANES>\n         where"}, {"sha": "24f77cb3e106a357baf90e6fb5f57772158212bb", "filename": "crates/core_simd/src/vector/int.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fint.rs?ref=875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "patch": "@@ -4,6 +4,7 @@\n macro_rules! impl_integer_vector {\n     { $name:ident, $type:ty, $mask_ty:ident, $mask_impl_ty:ident } => {\n         impl_vector! { $name, $type }\n+        impl_integer_reductions! { $name, $type }\n \n         impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost32 {}\n "}, {"sha": "3866b9ca5c6ef150d2f330baa64d2a23ee92a30e", "filename": "crates/core_simd/src/vector/uint.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector%2Fuint.rs?ref=875b31c33f6b0ccbb8590c2b3c9cbf1b11ed6165", "patch": "@@ -5,6 +5,7 @@\n macro_rules! impl_unsigned_vector {\n     { $name:ident, $type:ty } => {\n         impl_vector! { $name, $type }\n+        impl_integer_reductions! { $name, $type }\n \n         impl<const LANES: usize> Eq for $name<LANES> where Self: crate::LanesAtMost32 {}\n "}]}