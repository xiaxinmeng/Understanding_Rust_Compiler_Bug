{"sha": "a07290047e6b27638f491ee7ebb90e20fece2a79", "node_id": "C_kwDOAAsO6NoAKGEwNzI5MDA0N2U2YjI3NjM4ZjQ5MWVlN2ViYjkwZTIwZmVjZTJhNzk", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-05-07T20:41:53Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-04T13:28:15Z"}, "message": "Compute lifetimes in scope at diagnostic time.", "tree": {"sha": "122b053ed54a3422253a96bbffd4ff4b9dfcdcc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/122b053ed54a3422253a96bbffd4ff4b9dfcdcc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a07290047e6b27638f491ee7ebb90e20fece2a79", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a07290047e6b27638f491ee7ebb90e20fece2a79", "html_url": "https://github.com/rust-lang/rust/commit/a07290047e6b27638f491ee7ebb90e20fece2a79", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a07290047e6b27638f491ee7ebb90e20fece2a79/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb0584f86b8cfa952dffad55f7d83bd90765120f", "url": "https://api.github.com/repos/rust-lang/rust/commits/cb0584f86b8cfa952dffad55f7d83bd90765120f", "html_url": "https://github.com/rust-lang/rust/commit/cb0584f86b8cfa952dffad55f7d83bd90765120f"}], "stats": {"total": 195, "additions": 101, "deletions": 94}, "files": [{"sha": "4da09c4ef486ee55c0c5fd8ffbf4d2ba8685c4e3", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=a07290047e6b27638f491ee7ebb90e20fece2a79", "patch": "@@ -313,6 +313,13 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    fn visit_assoc_type_binding(&mut self, type_binding: &'hir TypeBinding<'hir>) {\n+        self.insert(type_binding.span, type_binding.hir_id, Node::TypeBinding(type_binding));\n+        self.with_parent(type_binding.hir_id, |this| {\n+            intravisit::walk_assoc_type_binding(this, type_binding)\n+        })\n+    }\n+\n     fn visit_trait_item_ref(&mut self, ii: &'hir TraitItemRef) {\n         // Do not visit the duplicate information in TraitItemRef. We want to\n         // map the actual nodes, not the duplicate ones in the *Ref."}, {"sha": "01cedccf997cde64c99bf17dccd33dee6bdaa336", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=a07290047e6b27638f491ee7ebb90e20fece2a79", "patch": "@@ -3302,6 +3302,7 @@ pub enum Node<'hir> {\n     Stmt(&'hir Stmt<'hir>),\n     PathSegment(&'hir PathSegment<'hir>),\n     Ty(&'hir Ty<'hir>),\n+    TypeBinding(&'hir TypeBinding<'hir>),\n     TraitRef(&'hir TraitRef<'hir>),\n     Binding(&'hir Pat<'hir>),\n     Pat(&'hir Pat<'hir>),\n@@ -3347,6 +3348,7 @@ impl<'hir> Node<'hir> {\n             | Node::PathSegment(PathSegment { ident, .. }) => Some(*ident),\n             Node::Lifetime(lt) => Some(lt.name.ident()),\n             Node::GenericParam(p) => Some(p.name.ident()),\n+            Node::TypeBinding(b) => Some(b.ident),\n             Node::Param(..)\n             | Node::AnonConst(..)\n             | Node::Expr(..)"}, {"sha": "fb40008d60b5d1d04e761bee7b1e8785c3811ba5", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=a07290047e6b27638f491ee7ebb90e20fece2a79", "patch": "@@ -85,6 +85,7 @@ impl<'a> State<'a> {\n             Node::Stmt(a) => self.print_stmt(&a),\n             Node::PathSegment(a) => self.print_path_segment(&a),\n             Node::Ty(a) => self.print_type(&a),\n+            Node::TypeBinding(a) => self.print_type_binding(&a),\n             Node::TraitRef(a) => self.print_trait_ref(&a),\n             Node::Binding(a) | Node::Pat(a) => self.print_pat(&a),\n             Node::Arm(a) => self.print_arm(&a),\n@@ -1703,21 +1704,7 @@ impl<'a> State<'a> {\n \n             for binding in generic_args.bindings.iter() {\n                 start_or_comma(self);\n-                self.print_ident(binding.ident);\n-                self.print_generic_args(binding.gen_args, false, false);\n-                self.space();\n-                match generic_args.bindings[0].kind {\n-                    hir::TypeBindingKind::Equality { ref term } => {\n-                        self.word_space(\"=\");\n-                        match term {\n-                            Term::Ty(ref ty) => self.print_type(ty),\n-                            Term::Const(ref c) => self.print_anon_const(c),\n-                        }\n-                    }\n-                    hir::TypeBindingKind::Constraint { bounds } => {\n-                        self.print_bounds(\":\", bounds);\n-                    }\n-                }\n+                self.print_type_binding(binding);\n             }\n \n             if !empty.get() {\n@@ -1726,6 +1713,24 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    pub fn print_type_binding(&mut self, binding: &hir::TypeBinding<'_>) {\n+        self.print_ident(binding.ident);\n+        self.print_generic_args(binding.gen_args, false, false);\n+        self.space();\n+        match binding.kind {\n+            hir::TypeBindingKind::Equality { ref term } => {\n+                self.word_space(\"=\");\n+                match term {\n+                    Term::Ty(ref ty) => self.print_type(ty),\n+                    Term::Const(ref c) => self.print_anon_const(c),\n+                }\n+            }\n+            hir::TypeBindingKind::Constraint { bounds } => {\n+                self.print_bounds(\":\", bounds);\n+            }\n+        }\n+    }\n+\n     pub fn print_pat(&mut self, pat: &hir::Pat<'_>) {\n         self.maybe_print_comment(pat.span.lo());\n         self.ann.pre(self, AnnNode::Pat(pat));"}, {"sha": "ebda9f7588d5d48c40125a0c521a83b2d1aac33a", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=a07290047e6b27638f491ee7ebb90e20fece2a79", "patch": "@@ -298,6 +298,7 @@ impl<'hir> Map<'hir> {\n             Node::Stmt(_)\n             | Node::PathSegment(_)\n             | Node::Ty(_)\n+            | Node::TypeBinding(_)\n             | Node::Infer(_)\n             | Node::TraitRef(_)\n             | Node::Pat(_)\n@@ -323,7 +324,8 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_parent_node(self, hir_id: HirId) -> HirId {\n-        self.find_parent_node(hir_id).unwrap()\n+        self.find_parent_node(hir_id)\n+            .unwrap_or_else(|| bug!(\"No parent for node {:?}\", self.node_to_string(hir_id)))\n     }\n \n     /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n@@ -973,6 +975,7 @@ impl<'hir> Map<'hir> {\n                     .with_hi(seg.args.map_or_else(|| ident_span.hi(), |args| args.span_ext.hi()))\n             }\n             Node::Ty(ty) => ty.span,\n+            Node::TypeBinding(tb) => tb.span,\n             Node::TraitRef(tr) => tr.path.span,\n             Node::Binding(pat) => pat.span,\n             Node::Pat(pat) => pat.span,\n@@ -1205,6 +1208,7 @@ fn hir_id_to_string(map: Map<'_>, id: HirId) -> String {\n         Some(Node::Stmt(_)) => node_str(\"stmt\"),\n         Some(Node::PathSegment(_)) => node_str(\"path segment\"),\n         Some(Node::Ty(_)) => node_str(\"type\"),\n+        Some(Node::TypeBinding(_)) => node_str(\"type binding\"),\n         Some(Node::TraitRef(_)) => node_str(\"trait ref\"),\n         Some(Node::Binding(_)) => node_str(\"local\"),\n         Some(Node::Pat(_)) => node_str(\"pat\"),"}, {"sha": "7d0b751d35abef5bfb96a45bd07a5eaa37ddfbb9", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=a07290047e6b27638f491ee7ebb90e20fece2a79", "patch": "@@ -23,8 +23,7 @@ pub enum Region {\n pub enum LifetimeScopeForPath {\n     /// Contains all lifetime names that are in scope and could possibly be used in generics\n     /// arguments of path.\n-    NonElided(Vec<LocalDefId>),\n-\n+    NonElided,\n     /// Information that allows us to suggest args of the form `<'_>` in case\n     /// no generic arguments were provided for a path.\n     Elided,"}, {"sha": "50e067e225f61f4236a84eeeea8a975a98aaa43b", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=a07290047e6b27638f491ee7ebb90e20fece2a79", "patch": "@@ -517,30 +517,16 @@ fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::\n \n #[tracing::instrument(level = \"debug\")]\n fn get_lifetime_scopes_for_path(mut scope: &Scope<'_>) -> LifetimeScopeForPath {\n-    let mut available_lifetimes = vec![];\n     loop {\n         match scope {\n-            Scope::Binder { lifetimes, s, .. } => {\n-                available_lifetimes.extend(lifetimes.keys());\n-                scope = s;\n-            }\n-            Scope::Body { s, .. } => {\n-                scope = s;\n-            }\n-            Scope::Elision { elide, s } => {\n-                if let Elide::Exact(_) = elide {\n-                    return LifetimeScopeForPath::Elided;\n-                } else {\n-                    scope = s;\n-                }\n-            }\n-            Scope::ObjectLifetimeDefault { s, .. } => {\n-                scope = s;\n-            }\n-            Scope::Root => {\n-                return LifetimeScopeForPath::NonElided(available_lifetimes);\n-            }\n-            Scope::Supertrait { s, .. } | Scope::TraitRefBoundary { s, .. } => {\n+            Scope::Elision { elide: Elide::Exact(_), .. } => return LifetimeScopeForPath::Elided,\n+            Scope::Root => return LifetimeScopeForPath::NonElided,\n+            Scope::Binder { s, .. }\n+            | Scope::Body { s, .. }\n+            | Scope::ObjectLifetimeDefault { s, .. }\n+            | Scope::Supertrait { s, .. }\n+            | Scope::TraitRefBoundary { s, .. }\n+            | Scope::Elision { s, .. } => {\n                 scope = s;\n             }\n         }\n@@ -2170,6 +2156,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n             Node::ForeignItem(_) | Node::Ty(_) | Node::TraitRef(_) => None,\n+\n+            Node::TypeBinding(_) if let Node::TraitRef(_) = self.tcx.hir().get(self.tcx.hir().get_parent_node(parent)) => None,\n+\n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types.\n             _ => {"}, {"sha": "58b63804b4a4ed18cb53db0b81cf70d4a8d6de5c", "filename": "compiler/rustc_typeck/src/check/generator_interior/drop_ranges/cfg_build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior%2Fdrop_ranges%2Fcfg_build.rs?ref=a07290047e6b27638f491ee7ebb90e20fece2a79", "patch": "@@ -249,6 +249,7 @@ impl<'a, 'tcx> DropRangeVisitor<'a, 'tcx> {\n                 | hir::Node::Stmt(..)\n                 | hir::Node::PathSegment(..)\n                 | hir::Node::Ty(..)\n+                | hir::Node::TypeBinding(..)\n                 | hir::Node::TraitRef(..)\n                 | hir::Node::Binding(..)\n                 | hir::Node::Pat(..)"}, {"sha": "2433401b7f0f5f5502ffc4eff0370a285832a7ee", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 4, "deletions": 15, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=a07290047e6b27638f491ee7ebb90e20fece2a79", "patch": "@@ -450,21 +450,10 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     .discr_type()\n                     .to_ty(tcx),\n \n-                Node::TraitRef(trait_ref @ &TraitRef {\n-                  path, ..\n-                }) if let Some((binding, seg)) =\n-                  path\n-                      .segments\n-                      .iter()\n-                      .find_map(|seg| {\n-                          seg.args?.bindings\n-                              .iter()\n-                              .find_map(|binding| if binding.opt_const()?.hir_id == hir_id {\n-                                Some((binding, seg))\n-                              } else {\n-                                None\n-                              })\n-                      }) =>\n+                Node::TypeBinding(binding @ &TypeBinding { hir_id: binding_id, ..  })\n+                    if let Node::TraitRef(trait_ref) = tcx.hir().get(\n+                        tcx.hir().get_parent_node(binding_id)\n+                    ) =>\n                 {\n                   let Some(trait_def_id) = trait_ref.trait_def_id() else {\n                     return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");"}, {"sha": "c433c5ebbd36859856d5972235e53a112e22ab64", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 50, "deletions": 39, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a07290047e6b27638f491ee7ebb90e20fece2a79/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=a07290047e6b27638f491ee7ebb90e20fece2a79", "patch": "@@ -291,7 +291,52 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n     }\n \n     // Creates lifetime name suggestions from the lifetime parameter names\n-    fn get_lifetime_args_suggestions_from_param_names(&self, num_params_to_take: usize) -> String {\n+    fn get_lifetime_args_suggestions_from_param_names(\n+        &self,\n+        path_hir_id: Option<hir::HirId>,\n+        num_params_to_take: usize,\n+    ) -> String {\n+        debug!(?path_hir_id);\n+\n+        if let Some(path_hir_id) = path_hir_id {\n+            // We first try to get lifetime name suggestions from scope or elision information.\n+            // If none is available we use the parameter definitions\n+            if let Some(LifetimeScopeForPath::Elided) = self.tcx.lifetime_scope(path_hir_id) {\n+                // Use suggestions of the form `<'_, '_>` in case lifetime can be elided\n+                return [\"'_\"].repeat(num_params_to_take).join(\",\");\n+            }\n+\n+            let mut ret = Vec::new();\n+            for (id, node) in self.tcx.hir().parent_iter(path_hir_id) {\n+                debug!(?id);\n+                let params = if let Some(generics) = node.generics() {\n+                    generics.params\n+                } else if let hir::Node::Ty(ty) = node\n+                    && let hir::TyKind::BareFn(bare_fn) = ty.kind\n+                {\n+                    bare_fn.generic_params\n+                } else {\n+                    &[]\n+                };\n+                ret.extend(params.iter().filter_map(|p| {\n+                    let hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit }\n+                        = p.kind\n+                    else { return None };\n+                    let hir::ParamName::Plain(name) = p.name else { return None };\n+                    Some(name.to_string())\n+                }));\n+                if ret.len() >= num_params_to_take {\n+                    return ret[..num_params_to_take].join(\", \");\n+                }\n+                // We cannot refer to lifetimes defined in an outer function.\n+                if let hir::Node::Item(_) = node {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // We could not gather enough lifetime parameters in the scope.\n+        // We use the parameter names from the target type's definition instead.\n         self.gen_params\n             .params\n             .iter()\n@@ -501,44 +546,10 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n         let num_params_to_take = num_missing_args;\n         let msg = format!(\"add missing {} argument{}\", self.kind(), pluralize!(num_missing_args));\n \n-        // we first try to get lifetime name suggestions from scope or elision information. If none is\n-        // available we use the parameter definitions\n-        let suggested_args = if let Some(hir_id) = self.path_segment.hir_id {\n-            if let Some(lifetimes_in_scope) = self.tcx.lifetime_scope(hir_id) {\n-                match lifetimes_in_scope {\n-                    LifetimeScopeForPath::NonElided(param_names) => {\n-                        debug!(\"NonElided(param_names: {:?})\", param_names);\n-\n-                        if param_names.len() >= num_params_to_take {\n-                            // use lifetime parameters in scope for suggestions\n-                            param_names\n-                                .iter()\n-                                .take(num_params_to_take)\n-                                .map(|def_id| {\n-                                    self.tcx.item_name(def_id.to_def_id()).to_ident_string()\n-                                })\n-                                .collect::<Vec<_>>()\n-                                .join(\", \")\n-                        } else {\n-                            // Not enough lifetime arguments in scope -> create suggestions from\n-                            // lifetime parameter names in definition. An error for the incorrect\n-                            // lifetime scope will be output later.\n-                            self.get_lifetime_args_suggestions_from_param_names(num_params_to_take)\n-                        }\n-                    }\n-                    LifetimeScopeForPath::Elided => {\n-                        debug!(\"Elided\");\n-                        // use suggestions of the form `<'_, '_>` in case lifetime can be elided\n-                        [\"'_\"].repeat(num_params_to_take).join(\",\")\n-                    }\n-                }\n-            } else {\n-                self.get_lifetime_args_suggestions_from_param_names(num_params_to_take)\n-            }\n-        } else {\n-            self.get_lifetime_args_suggestions_from_param_names(num_params_to_take)\n-        };\n-\n+        let suggested_args = self.get_lifetime_args_suggestions_from_param_names(\n+            self.path_segment.hir_id,\n+            num_params_to_take,\n+        );\n         debug!(\"suggested_args: {:?}\", &suggested_args);\n \n         match self.angle_brackets {"}]}