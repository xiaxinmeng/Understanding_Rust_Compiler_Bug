{"sha": "aba84894d1879a7429d5bc20d0bfdca3471685de", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiYTg0ODk0ZDE4NzlhNzQyOWQ1YmMyMGQwYmZkY2EzNDcxNjg1ZGU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-10-21T20:00:45Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-21T20:00:45Z"}, "message": "Rollup merge of #62330 - SimonSapin:no-drop-in-union-fields, r=RalfJung\n\nChange untagged_unions to not allow union fields with drop\n\nThis is a rebase of #56440, massaged to solve merge conflicts and make the test suite pass.\n\nChange untagged_unions to not allow union fields with drop\n\nUnion fields may now never have a type with attached destructor. This for example allows unions to use arbitrary field types only by wrapping them in `ManuallyDrop` (or similar).\n\nThe stable rule remains, that union fields must be `Copy`. We use the new rule for the `untagged_union` feature.\n\nTracking issue: https://github.com/rust-lang/rust/issues/55149", "tree": {"sha": "5c11f19bd3b62b335a5a189f49b0ef2a6c3bc2f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c11f19bd3b62b335a5a189f49b0ef2a6c3bc2f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aba84894d1879a7429d5bc20d0bfdca3471685de", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdrg5uCRBK7hj4Ov3rIwAAdHIIABaaHnjnj7UXzoi5McPHOCnY\nbUymyJqqKzm79askuC9FQeziY26r5rx+uLE+JWdxRsAlWTetz23LqZz0esEUnFgl\ntJcJfKs1cIW0vfiuQeUIYSp97Q/z50Cd3V7xro5ztwawBrat2s5dvnhtvPzQGVR8\nqwqewFTW0LcSO0nfRSZ7LJoEakA6H6uk94QK7BKgDOZe5Q6tSs/xk2IrzHZaHee4\nbQT4mU9r4HxEMTO8NEWhCZh905ywetKsLTQ5BG2ErMqAt9EM8WiCJjh1yoc/01Cj\nP1gsCUZ8HyCtolH3seUy+9gMexc84uSGGjrqOE86vKjYhnyjbnTvkrdTnxYJC8Q=\n=Trnq\n-----END PGP SIGNATURE-----\n", "payload": "tree 5c11f19bd3b62b335a5a189f49b0ef2a6c3bc2f2\nparent 10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07\nparent 875bdd5dbe663a6dafd785b86c8964a90653eeb7\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1571688045 +0200\ncommitter GitHub <noreply@github.com> 1571688045 +0200\n\nRollup merge of #62330 - SimonSapin:no-drop-in-union-fields, r=RalfJung\n\nChange untagged_unions to not allow union fields with drop\n\nThis is a rebase of #56440, massaged to solve merge conflicts and make the test suite pass.\n\nChange untagged_unions to not allow union fields with drop\n\nUnion fields may now never have a type with attached destructor. This for example allows unions to use arbitrary field types only by wrapping them in `ManuallyDrop` (or similar).\n\nThe stable rule remains, that union fields must be `Copy`. We use the new rule for the `untagged_union` feature.\n\nTracking issue: https://github.com/rust-lang/rust/issues/55149\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aba84894d1879a7429d5bc20d0bfdca3471685de", "html_url": "https://github.com/rust-lang/rust/commit/aba84894d1879a7429d5bc20d0bfdca3471685de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aba84894d1879a7429d5bc20d0bfdca3471685de/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07", "html_url": "https://github.com/rust-lang/rust/commit/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07"}, {"sha": "875bdd5dbe663a6dafd785b86c8964a90653eeb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/875bdd5dbe663a6dafd785b86c8964a90653eeb7", "html_url": "https://github.com/rust-lang/rust/commit/875bdd5dbe663a6dafd785b86c8964a90653eeb7"}], "stats": {"total": 719, "additions": 454, "deletions": 265}, "files": [{"sha": "813d7c4bafef8cfdaf779be20dacf71cfc46de35", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -596,30 +596,6 @@ warning: function cannot return without recursing\n   |\n ```\n \n-## unions-with-drop-fields\n-\n-This lint detects use of unions that contain fields with possibly non-trivial drop code. Some\n-example code that triggers this lint:\n-\n-```rust\n-#![feature(untagged_unions)]\n-\n-union U {\n-    s: String,\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-warning: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n- --> src/main.rs:4:5\n-  |\n-4 |     s: String,\n-  |     ^^^^^^^^^\n-  |\n-```\n-\n ## unknown-lints\n \n This lint detects unrecognized lint attribute. Some"}, {"sha": "93274ef0c927cdc1050bdc368710f3d672006fa2", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -36,5 +36,5 @@ parking_lot = \"0.9\"\n byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n-smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+smallvec = { version = \"0.6.8\", features = [\"union\", \"may_dangle\"] }\n measureme = \"0.3\""}, {"sha": "5555dace45bfa63e750d01875875fc367ad86f2d", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -818,6 +818,8 @@ impl<'tcx> ty::TyS<'tcx> {\n     ///\n     /// (Note that this implies that if `ty` has a destructor attached,\n     /// then `needs_drop` will definitely return `true` for `ty`.)\n+    ///\n+    /// Note that this method is used to check eligible types in unions.\n     #[inline]\n     pub fn needs_drop(&'tcx self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> bool {\n         tcx.needs_drop_raw(param_env.and(self)).0"}, {"sha": "5d9a97cc21eefe2302b82deec42e768e892e00ae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -980,35 +980,6 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n     }\n }\n \n-declare_lint! {\n-    UNIONS_WITH_DROP_FIELDS,\n-    Warn,\n-    \"use of unions that contain fields with possibly non-trivial drop code\"\n-}\n-\n-declare_lint_pass!(\n-    /// Lint for unions that contain fields with possibly non-trivial destructors.\n-    UnionsWithDropFields => [UNIONS_WITH_DROP_FIELDS]\n-);\n-\n-impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n-    fn check_item(&mut self, ctx: &LateContext<'_, '_>, item: &hir::Item) {\n-        if let hir::ItemKind::Union(ref vdata, _) = item.kind {\n-            for field in vdata.fields() {\n-                let field_ty = ctx.tcx.type_of(\n-                    ctx.tcx.hir().local_def_id(field.hir_id));\n-                if field_ty.needs_drop(ctx.tcx, ctx.param_env) {\n-                    ctx.span_lint(UNIONS_WITH_DROP_FIELDS,\n-                                  field.span,\n-                                  \"union contains a field with possibly non-trivial drop code, \\\n-                                   drop code of union fields is ignored when dropping the union\");\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n declare_lint! {\n     pub UNREACHABLE_PUB,\n     Allow,\n@@ -1288,7 +1259,6 @@ declare_lint_pass!(\n         NO_MANGLE_GENERIC_ITEMS,\n         MUTABLE_TRANSMUTES,\n         UNSTABLE_FEATURES,\n-        UNIONS_WITH_DROP_FIELDS,\n         UNREACHABLE_PUB,\n         TYPE_ALIAS_BOUNDS,\n         TRIVIAL_BOUNDS"}, {"sha": "f83755181f82e9c37232ceff2556dcbff0e02890", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -164,9 +164,6 @@ macro_rules! late_lint_mod_passes {\n             // Depends on referenced function signatures in expressions\n             MutableTransmutes: MutableTransmutes,\n \n-            // Depends on types of fields, checks if they implement Drop\n-            UnionsWithDropFields: UnionsWithDropFields,\n-\n             TypeAliasBounds: TypeAliasBounds,\n \n             TrivialConstraints: TrivialConstraints,"}, {"sha": "73a025182a7e338ae9854f37b31aa0190095e62d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1387,9 +1387,37 @@ fn check_union(tcx: TyCtxt<'_>, id: hir::HirId, span: Span) {\n     def.destructor(tcx); // force the destructor to be evaluated\n     check_representable(tcx, span, def_id);\n     check_transparent(tcx, span, def_id);\n+    check_union_fields(tcx, span, def_id);\n     check_packed(tcx, span, def_id);\n }\n \n+/// When the `#![feature(untagged_unions)]` gate is active,\n+/// check that the fields of the `union` does not contain fields that need dropping.\n+fn check_union_fields(tcx: TyCtxt<'_>, span: Span, item_def_id: DefId) -> bool {\n+    let item_type = tcx.type_of(item_def_id);\n+    if let ty::Adt(def, substs) = item_type.kind {\n+        assert!(def.is_union());\n+        let fields = &def.non_enum_variant().fields;\n+        for field in fields {\n+            let field_ty = field.ty(tcx, substs);\n+            // We are currently checking the type this field came from, so it must be local.\n+            let field_span = tcx.hir().span_if_local(field.did).unwrap();\n+            let param_env = tcx.param_env(field.did);\n+            if field_ty.needs_drop(tcx, param_env) {\n+                struct_span_err!(tcx.sess, field_span, E0740,\n+                                    \"unions may not contain fields that need dropping\")\n+                            .span_note(field_span,\n+                                        \"`std::mem::ManuallyDrop` can be used to wrap the type\")\n+                            .emit();\n+                return false;\n+            }\n+        }\n+    } else {\n+        span_bug!(span, \"unions must be ty::Adt, but got {:?}\", item_type.kind);\n+    }\n+    return true;\n+}\n+\n /// Checks that an opaque type does not contain cycles and does not use `Self` or `T::Foo`\n /// projections that would result in \"inheriting lifetimes\".\n fn check_opaque<'tcx>("}, {"sha": "3ecbf620cbc7b9068d956b2a355b924f47f9c10c", "filename": "src/librustc_typeck/error_codes.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc_typeck%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibrustc_typeck%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Ferror_codes.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -4863,6 +4863,10 @@ assert_eq!(1, discriminant(&Enum::Struct{a: 7, b: 11}));\n ```\n \"##,\n \n+E0740: r##\"\n+A `union` cannot have fields with destructors.\n+\"##,\n+\n E0733: r##\"\n Recursion in an `async fn` requires boxing. For example, this will not compile:\n "}, {"sha": "93d3e4ea3df228a33fefc5534065897a8abcb5fa", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -275,6 +275,7 @@\n #![feature(link_args)]\n #![feature(linkage)]\n #![feature(log_syntax)]\n+#![feature(manually_drop_take)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n #![feature(needs_panic_runtime)]"}, {"sha": "2dde81bb0ecd48bc4681e1fc99a292bb9cfc0eaa", "filename": "src/libstd/panicking.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibstd%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Flibstd%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpanicking.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -12,8 +12,7 @@ use core::panic::{BoxMeUp, PanicInfo, Location};\n use crate::any::Any;\n use crate::fmt;\n use crate::intrinsics;\n-use crate::mem;\n-use crate::ptr;\n+use crate::mem::{self, ManuallyDrop};\n use crate::raw;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::sys::stdio::panic_output;\n@@ -227,10 +226,9 @@ pub use realstd::rt::update_panic_count;\n \n /// Invoke a closure, capturing the cause of an unwinding panic if one occurs.\n pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>> {\n-    #[allow(unions_with_drop_fields)]\n     union Data<F, R> {\n-        f: F,\n-        r: R,\n+        f: ManuallyDrop<F>,\n+        r: ManuallyDrop<R>,\n     }\n \n     // We do some sketchy operations with ownership here for the sake of\n@@ -261,7 +259,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     let mut any_data = 0;\n     let mut any_vtable = 0;\n     let mut data = Data {\n-        f,\n+        f: ManuallyDrop::new(f)\n     };\n \n     let r = __rust_maybe_catch_panic(do_call::<F, R>,\n@@ -271,7 +269,7 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n \n     return if r == 0 {\n         debug_assert!(update_panic_count(0) == 0);\n-        Ok(data.r)\n+        Ok(ManuallyDrop::into_inner(data.r))\n     } else {\n         update_panic_count(-1);\n         debug_assert!(update_panic_count(0) == 0);\n@@ -284,8 +282,9 @@ pub unsafe fn r#try<R, F: FnOnce() -> R>(f: F) -> Result<R, Box<dyn Any + Send>>\n     fn do_call<F: FnOnce() -> R, R>(data: *mut u8) {\n         unsafe {\n             let data = data as *mut Data<F, R>;\n-            let f = ptr::read(&mut (*data).f);\n-            ptr::write(&mut (*data).r, f());\n+            let data = &mut (*data);\n+            let f = ManuallyDrop::take(&mut data.f);\n+            data.r = ManuallyDrop::new(f());\n         }\n     }\n }"}, {"sha": "97c5acf1f72ca42129efce0205612dc331f7719d", "filename": "src/test/ui/associated-type-bounds/union-bounds.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -3,13 +3,13 @@\n #![feature(associated_type_bounds)]\n #![feature(untagged_unions)]\n \n-#![allow(unions_with_drop_fields, unused_assignments)]\n+#![allow(unused_assignments)]\n \n-trait Tr1 { type As1; }\n-trait Tr2 { type As2; }\n-trait Tr3 { type As3; }\n-trait Tr4<'a> { type As4; }\n-trait Tr5 { type As5; }\n+trait Tr1: Copy { type As1: Copy; }\n+trait Tr2: Copy { type As2: Copy; }\n+trait Tr3: Copy { type As3: Copy; }\n+trait Tr4<'a>: Copy { type As4: Copy; }\n+trait Tr5: Copy { type As5: Copy; }\n \n impl Tr1 for &str { type As1 = bool; }\n impl Tr2 for bool { type As2 = u8; }\n@@ -71,7 +71,8 @@ where\n     let _: &'a T = &x.f0;\n }\n \n-union UnSelf<T> where Self: Tr1<As1: Tr2> {\n+#[derive(Copy, Clone)]\n+union UnSelf<T> where Self: Tr1<As1: Tr2>, T: Copy {\n     f0: T,\n     f1: <Self as Tr1>::As1,\n     f2: <<Self as Tr1>::As1 as Tr2>::As2,"}, {"sha": "5a7568fe2cd50fa025c5ad8018da27c56f448d4b", "filename": "src/test/ui/drop/dynamic-drop.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdrop%2Fdynamic-drop.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -8,6 +8,7 @@\n #![feature(slice_patterns)]\n \n use std::cell::{Cell, RefCell};\n+use std::mem::ManuallyDrop;\n use std::ops::Generator;\n use std::panic;\n use std::pin::Pin;\n@@ -152,17 +153,16 @@ fn assignment1(a: &Allocator, c0: bool) {\n     _v = _w;\n }\n \n-#[allow(unions_with_drop_fields)]\n union Boxy<T> {\n-    a: T,\n-    b: T,\n+    a: ManuallyDrop<T>,\n+    b: ManuallyDrop<T>,\n }\n \n fn union1(a: &Allocator) {\n     unsafe {\n-        let mut u = Boxy { a: a.alloc() };\n-        u.b = a.alloc();\n-        drop(u.a);\n+        let mut u = Boxy { a: ManuallyDrop::new(a.alloc()) };\n+        *u.b = a.alloc(); // drops first alloc\n+        drop(ManuallyDrop::into_inner(u.a));\n     }\n }\n "}, {"sha": "0faa9090f4ebcfd898a632a1faf6d6dc6448d5be", "filename": "src/test/ui/feature-gates/feature-gate-associated_type_bounds.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-associated_type_bounds.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,7 +1,7 @@\n #![feature(untagged_unions)]\n \n-trait Tr1 { type As1; }\n-trait Tr2 { type As2; }\n+trait Tr1 { type As1: Copy; }\n+trait Tr2 { type As2: Copy; }\n \n struct S1;\n #[derive(Copy, Clone)]\n@@ -32,7 +32,7 @@ enum _En1<T: Tr1<As1: Tr2>> {\n \n union _Un1<T: Tr1<As1: Tr2>> {\n //~^ ERROR associated type bounds are unstable\n-    outest: T,\n+    outest: std::mem::ManuallyDrop<T>,\n     outer: T::As1,\n     inner: <T::As1 as Tr2>::As2,\n }"}, {"sha": "9ee0e6f681dcc4ae2f1b9b335ab15a90825d8aee", "filename": "src/test/ui/feature-gates/feature-gate-untagged_unions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -7,11 +7,11 @@ union U2<T: Copy> { // OK\n }\n \n union U3 { //~ ERROR unions with non-`Copy` fields are unstable\n-    a: String,\n+    a: String, //~ ERROR unions may not contain fields that need dropping\n }\n \n union U4<T> { //~ ERROR unions with non-`Copy` fields are unstable\n-    a: T,\n+    a: T, //~ ERROR unions may not contain fields that need dropping\n }\n \n union U5 { //~ ERROR unions with `Drop` implementations are unstable"}, {"sha": "1885518a4585cc0e8b916bd34e31f39d18821624", "filename": "src/test/ui/feature-gates/feature-gate-untagged_unions.stderr", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-untagged_unions.stderr?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -31,6 +31,31 @@ LL | | }\n    = note: for more information, see https://github.com/rust-lang/rust/issues/32836\n    = help: add `#![feature(untagged_unions)]` to the crate attributes to enable\n \n-error: aborting due to 3 previous errors\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/feature-gate-untagged_unions.rs:10:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/feature-gate-untagged_unions.rs:10:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/feature-gate-untagged_unions.rs:14:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/feature-gate-untagged_unions.rs:14:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+\n+error: aborting due to 5 previous errors\n \n-For more information about this error, try `rustc --explain E0658`.\n+Some errors have detailed explanations: E0658, E0740.\n+For more information about an error, try `rustc --explain E0658`."}, {"sha": "ea8a3c177e9d7f77dd202b8dced545200e861400", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-union.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,13 +1,12 @@\n #![feature(rustc_attrs)]\n #![feature(untagged_unions)]\n-#![allow(unions_with_drop_fields)]\n \n #[rustc_outlives]\n-union Foo<'b, U> { //~ ERROR rustc_outlives\n+union Foo<'b, U: Copy> { //~ ERROR rustc_outlives\n     bar: Bar<'b, U>\n }\n \n-union Bar<'a, T> where T: 'a {\n+union Bar<'a, T: Copy> where T: 'a {\n     x: &'a (),\n     y: T,\n }"}, {"sha": "8aa246e8bfeb35f312a6fd413bc7a9f36295a470", "filename": "src/test/ui/rfc-2093-infer-outlives/explicit-union.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fexplicit-union.stderr?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,7 +1,7 @@\n error: rustc_outlives\n-  --> $DIR/explicit-union.rs:6:1\n+  --> $DIR/explicit-union.rs:5:1\n    |\n-LL | / union Foo<'b, U> {\n+LL | / union Foo<'b, U: Copy> {\n LL | |     bar: Bar<'b, U>\n LL | | }\n    | |_^"}, {"sha": "0da3cc2ba1b0434c363c2c8503066ef878e03840", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-union.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,14 +1,13 @@\n #![feature(rustc_attrs)]\n #![feature(untagged_unions)]\n-#![allow(unions_with_drop_fields)]\n \n #[rustc_outlives]\n-union Foo<'a, T> { //~ ERROR rustc_outlives\n+union Foo<'a, T: Copy> { //~ ERROR rustc_outlives\n     field1: Bar<'a, T>\n }\n \n // Type U needs to outlive lifetime 'b\n-union Bar<'b, U> {\n+union Bar<'b, U: Copy> {\n     field2: &'b U\n }\n "}, {"sha": "a42285a56d0890cb39d809e5494b26bd8bb9336a", "filename": "src/test/ui/rfc-2093-infer-outlives/nested-union.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2093-infer-outlives%2Fnested-union.stderr?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,7 +1,7 @@\n error: rustc_outlives\n-  --> $DIR/nested-union.rs:6:1\n+  --> $DIR/nested-union.rs:5:1\n    |\n-LL | / union Foo<'a, T> {\n+LL | / union Foo<'a, T: Copy> {\n LL | |     field1: Bar<'a, T>\n LL | | }\n    | |_^"}, {"sha": "3b1eb9e1dfa16a86543aad7f17e3126941a65839", "filename": "src/test/ui/self/self-in-typedefs.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Fself%2Fself-in-typedefs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Fself%2Fself-in-typedefs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Fself-in-typedefs.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -3,7 +3,8 @@\n #![feature(untagged_unions)]\n \n #![allow(dead_code)]\n-#![allow(unions_with_drop_fields)]\n+\n+use std::mem::ManuallyDrop;\n \n enum A<'a, T: 'a>\n where\n@@ -24,6 +25,14 @@ where\n union C<'a, T: 'a>\n where\n     Self: Send, T: PartialEq<Self>\n+{\n+    foo: &'a Self,\n+    bar: ManuallyDrop<T>,\n+}\n+\n+union D<'a, T: 'a>\n+where\n+    Self: Send, T: PartialEq<Self> + Copy\n {\n     foo: &'a Self,\n     bar: T,"}, {"sha": "91e9a0d0b659c7e7cbc1a496f2adfed56d97fd8e", "filename": "src/test/ui/union/issue-41073.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Fissue-41073.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Fissue-41073.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Fissue-41073.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -0,0 +1,24 @@\n+#![feature(untagged_unions)]\n+\n+union Test {\n+    a: A, //~ ERROR unions may not contain fields that need dropping\n+    b: B\n+}\n+\n+#[derive(Debug)]\n+struct A(i32);\n+impl Drop for A {\n+    fn drop(&mut self) { println!(\"A\"); }\n+}\n+\n+#[derive(Debug)]\n+struct B(f32);\n+impl Drop for B {\n+    fn drop(&mut self) { println!(\"B\"); }\n+}\n+\n+fn main() {\n+    let mut test = Test { a: A(3) };\n+    println!(\"{:?}\", unsafe { test.b });\n+    unsafe { test.b = B(0.5); }\n+}"}, {"sha": "2e9598b227124f9e07731f2a48ca956935bd7d4a", "filename": "src/test/ui/union/issue-41073.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Fissue-41073.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Fissue-41073.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Fissue-41073.stderr?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -0,0 +1,15 @@\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/issue-41073.rs:4:5\n+   |\n+LL |     a: A,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/issue-41073.rs:4:5\n+   |\n+LL |     a: A,\n+   |     ^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0740`."}, {"sha": "edf08e6ca678f13a4340aac6b5afd54052fc8bff", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.rs", "status": "modified", "additions": 50, "deletions": 11, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,51 +1,90 @@\n #![feature(untagged_unions)]\n #![allow(unused)]\n \n-#[allow(unions_with_drop_fields)]\n+use std::ops::{Deref, DerefMut};\n+\n+#[derive(Default)]\n+struct MockBox<T> {\n+    value: [T; 1],\n+}\n+\n+impl<T> MockBox<T> {\n+    fn new(value: T) -> Self { MockBox { value: [value] } }\n+}\n+\n+impl<T> Deref for MockBox<T> {\n+    type Target = T;\n+    fn deref(&self) -> &T { &self.value[0] }\n+}\n+\n+impl<T> DerefMut for MockBox<T> {\n+    fn deref_mut(&mut self) -> &mut T { &mut self.value[0] }\n+}\n+\n+#[derive(Default)]\n+struct MockVec<T> {\n+    value: [T; 0],\n+}\n+\n+impl<T> MockVec<T> {\n+    fn new() -> Self { MockVec { value: [] } }\n+}\n+\n+impl<T> Deref for MockVec<T> {\n+    type Target = [T];\n+    fn deref(&self) -> &[T] { &self.value }\n+}\n+\n+impl<T> DerefMut for MockVec<T> {\n+    fn deref_mut(&mut self) -> &mut [T] { &mut self.value }\n+}\n+\n+\n union U {\n-    x: ((Vec<u8>, Vec<u8>), Vec<u8>),\n-    y: Box<Vec<u8>>,\n+    x: ((MockVec<u8>, MockVec<u8>), MockVec<u8>),\n+    y: MockBox<MockVec<u8>>,\n }\n \n fn use_borrow<T>(_: &T) {}\n \n unsafe fn parent_sibling_borrow() {\n-    let mut u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let mut u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = &mut u.x.0;\n     let b = &u.y; //~ ERROR cannot borrow `u` (via `u.y`)\n     use_borrow(a);\n }\n \n unsafe fn parent_sibling_move() {\n-    let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = u.x.0;\n     let b = u.y; //~ ERROR use of moved value: `u`\n }\n \n unsafe fn grandparent_sibling_borrow() {\n-    let mut u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let mut u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = &mut (u.x.0).0;\n     let b = &u.y; //~ ERROR cannot borrow `u` (via `u.y`)\n     use_borrow(a);\n }\n \n unsafe fn grandparent_sibling_move() {\n-    let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+    let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n     let a = (u.x.0).0;\n     let b = u.y; //~ ERROR use of moved value: `u`\n }\n \n unsafe fn deref_sibling_borrow() {\n-    let mut u = U { y: Box::default() };\n+    let mut u = U { y: MockBox::default() };\n     let a = &mut *u.y;\n     let b = &u.x; //~ ERROR cannot borrow `u` (via `u.x`)\n     use_borrow(a);\n }\n \n unsafe fn deref_sibling_move() {\n-    let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n-    let a = *u.y;\n-    let b = u.x; //~ ERROR use of moved value: `u`\n+    let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n+    // No way to test deref-move without Box in union\n+    // let a = *u.y;\n+    // let b = u.x; ERROR use of moved value: `u`\n }\n \n "}, {"sha": "8ba155bafb0b95526c0e13fa4ca9f2bd072db98a", "filename": "src/test/ui/union/union-borrow-move-parent-sibling.stderr", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-borrow-move-parent-sibling.stderr?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,5 +1,5 @@\n error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:15:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:53:13\n    |\n LL |     let a = &mut u.x.0;\n    |             ---------- mutable borrow occurs here (via `u.x.0`)\n@@ -11,17 +11,17 @@ LL |     use_borrow(a);\n    = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0`\n \n error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:22:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:60:13\n    |\n-LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+LL |     let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n    |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n LL |     let a = u.x.0;\n    |             ----- value moved here\n LL |     let b = u.y;\n    |             ^^^ value used here after move\n \n error[E0502]: cannot borrow `u` (via `u.y`) as immutable because it is also borrowed as mutable (via `u.x.0.0`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:28:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:66:13\n    |\n LL |     let a = &mut (u.x.0).0;\n    |             -------------- mutable borrow occurs here (via `u.x.0.0`)\n@@ -33,38 +33,28 @@ LL |     use_borrow(a);\n    = note: `u.y` is a field of the union `U`, so it overlaps the field `u.x.0.0`\n \n error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:35:13\n+  --> $DIR/union-borrow-move-parent-sibling.rs:73:13\n    |\n-LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n+LL |     let u = U { x: ((MockVec::new(), MockVec::new()), MockVec::new()) };\n    |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n LL |     let a = (u.x.0).0;\n    |             --------- value moved here\n LL |     let b = u.y;\n    |             ^^^ value used here after move\n \n-error[E0502]: cannot borrow `u` (via `u.x`) as immutable because it is also borrowed as mutable (via `*u.y`)\n-  --> $DIR/union-borrow-move-parent-sibling.rs:41:13\n+error[E0502]: cannot borrow `u` (via `u.x`) as immutable because it is also borrowed as mutable (via `u.y`)\n+  --> $DIR/union-borrow-move-parent-sibling.rs:79:13\n    |\n LL |     let a = &mut *u.y;\n-   |             --------- mutable borrow occurs here (via `*u.y`)\n+   |                   --- mutable borrow occurs here (via `u.y`)\n LL |     let b = &u.x;\n-   |             ^^^^ immutable borrow of `u.x` -- which overlaps with `*u.y` -- occurs here\n+   |             ^^^^ immutable borrow of `u.x` -- which overlaps with `u.y` -- occurs here\n LL |     use_borrow(a);\n    |                - mutable borrow later used here\n    |\n-   = note: `u.x` is a field of the union `U`, so it overlaps the field `*u.y`\n+   = note: `u.x` is a field of the union `U`, so it overlaps the field `u.y`\n \n-error[E0382]: use of moved value: `u`\n-  --> $DIR/union-borrow-move-parent-sibling.rs:48:13\n-   |\n-LL |     let u = U { x: ((Vec::new(), Vec::new()), Vec::new()) };\n-   |         - move occurs because `u` has type `U`, which does not implement the `Copy` trait\n-LL |     let a = *u.y;\n-   |             ---- value moved here\n-LL |     let b = u.x;\n-   |             ^^^ value used here after move\n-\n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n \n Some errors have detailed explanations: E0382, E0502.\n For more information about an error, try `rustc --explain E0382`."}, {"sha": "8f816cc1b737c6c4822e80379c969ae6185337ba", "filename": "src/test/ui/union/union-custom-drop.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -0,0 +1,19 @@\n+// test for a union with a field that's a union with a manual impl Drop\n+// Ensures we do not treat all unions as not having any drop glue.\n+\n+#![feature(untagged_unions)]\n+\n+union Foo {\n+    bar: Bar, //~ ERROR unions may not contain fields that need dropping\n+}\n+\n+union Bar {\n+    a: i32,\n+    b: u32,\n+}\n+\n+impl Drop for Bar {\n+    fn drop(&mut self) {}\n+}\n+\n+fn main() {}"}, {"sha": "ee2333f905fb4106ed234eb144621456a2c3621d", "filename": "src/test/ui/union/union-custom-drop.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-custom-drop.stderr?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -0,0 +1,15 @@\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-custom-drop.rs:7:5\n+   |\n+LL |     bar: Bar,\n+   |     ^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-custom-drop.rs:7:5\n+   |\n+LL |     bar: Bar,\n+   |     ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0740`."}, {"sha": "60e280f53f52c8dc0caabf6f4aad068a4c312c73", "filename": "src/test/ui/union/union-derive-clone.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,5 +1,7 @@\n #![feature(untagged_unions)]\n \n+use std::mem::ManuallyDrop;\n+\n #[derive(Clone)] //~ ERROR the trait bound `U1: std::marker::Copy` is not satisfied\n union U1 {\n     a: u8,\n@@ -18,14 +20,19 @@ union U3 {\n }\n \n #[derive(Clone, Copy)]\n-union U4<T> {\n+union U4<T: Copy> {\n     a: T, // OK\n }\n \n+#[derive(Clone, Copy)]\n+union U5<T> {\n+    a: ManuallyDrop<T>, // OK\n+}\n+\n #[derive(Clone)]\n struct CloneNoCopy;\n \n fn main() {\n-    let u = U4 { a: CloneNoCopy };\n-    let w = u.clone(); //~ ERROR no method named `clone` found for type `U4<CloneNoCopy>`\n+    let u = U5 { a: ManuallyDrop::new(CloneNoCopy) };\n+    let w = u.clone(); //~ ERROR no method named `clone` found for type `U5<CloneNoCopy>`\n }"}, {"sha": "6893f9176f2db7778bd846d090c0707a2f9dcacc", "filename": "src/test/ui/union/union-derive-clone.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.stderr?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,22 +1,22 @@\n error[E0277]: the trait bound `U1: std::marker::Copy` is not satisfied\n-  --> $DIR/union-derive-clone.rs:3:10\n+  --> $DIR/union-derive-clone.rs:5:10\n    |\n LL | #[derive(Clone)]\n    |          ^^^^^ the trait `std::marker::Copy` is not implemented for `U1`\n    |\n    = note: required by `std::clone::AssertParamIsCopy`\n \n-error[E0599]: no method named `clone` found for type `U4<CloneNoCopy>` in the current scope\n-  --> $DIR/union-derive-clone.rs:30:15\n+error[E0599]: no method named `clone` found for type `U5<CloneNoCopy>` in the current scope\n+  --> $DIR/union-derive-clone.rs:37:15\n    |\n-LL | union U4<T> {\n+LL | union U5<T> {\n    | ----------- method `clone` not found for this\n ...\n LL |     let w = u.clone();\n-   |               ^^^^^ method not found in `U4<CloneNoCopy>`\n+   |               ^^^^^ method not found in `U5<CloneNoCopy>`\n    |\n    = note: the method `clone` exists but the following trait bounds were not satisfied:\n-           `U4<CloneNoCopy> : std::clone::Clone`\n+           `U5<CloneNoCopy> : std::clone::Clone`\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `std::clone::Clone`"}, {"sha": "b2f7ae679fd6849ec8ee3dae2843bfec8d4ef4ea", "filename": "src/test/ui/union/union-derive-rpass.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-derive-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-derive-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-rpass.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n #![allow(unused_variables)]\n-#![allow(unions_with_drop_fields)]\n \n // Some traits can be derived for unions.\n \n@@ -24,11 +23,11 @@ impl PartialEq for U { fn eq(&self, rhs: &Self) -> bool { true } }\n     Copy,\n     Eq\n )]\n-union W<T> {\n+union W<T: Copy> {\n     a: T,\n }\n \n-impl<T> PartialEq for W<T> { fn eq(&self, rhs: &Self) -> bool { true } }\n+impl<T: Copy> PartialEq for W<T> { fn eq(&self, rhs: &Self) -> bool { true } }\n \n fn main() {\n     let u = U { b: 0 };"}, {"sha": "f1511b0a60180c63328642c3325542b916a89b55", "filename": "src/test/ui/union/union-drop-assign.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-drop-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-drop-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-drop-assign.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,15 +1,16 @@\n // run-pass\n #![allow(unused_assignments)]\n-#![allow(unions_with_drop_fields)]\n \n // Drop works for union itself.\n \n #![feature(untagged_unions)]\n \n+use std::mem::ManuallyDrop;\n+\n struct S;\n \n union U {\n-    a: S\n+    a: ManuallyDrop<S>\n }\n \n impl Drop for S {\n@@ -28,11 +29,11 @@ static mut CHECK: u8 = 0;\n \n fn main() {\n     unsafe {\n-        let mut u = U { a: S };\n+        let mut u = U { a: ManuallyDrop::new(S) };\n         assert_eq!(CHECK, 0);\n-        u = U { a: S };\n+        u = U { a: ManuallyDrop::new(S) };\n         assert_eq!(CHECK, 1); // union itself is assigned, union is dropped, field is not dropped\n-        u.a = S;\n+        *u.a = S;\n         assert_eq!(CHECK, 11); // union field is assigned, field is dropped\n     }\n }"}, {"sha": "daa03ce6b6fd85d47473ca9942124e28cd949cbe", "filename": "src/test/ui/union/union-drop.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-drop.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n #![allow(dead_code)]\n #![allow(unused_variables)]\n-#![allow(unions_with_drop_fields)]\n \n // Drop works for union itself.\n \n@@ -21,12 +20,6 @@ union Y {\n     a: S,\n }\n \n-impl Drop for S {\n-    fn drop(&mut self) {\n-        unsafe { CHECK += 10; }\n-    }\n-}\n-\n impl Drop for U {\n     fn drop(&mut self) {\n         unsafe { CHECK += 1; }\n@@ -51,10 +44,10 @@ fn main() {\n         {\n             let w = W { a: S };\n         }\n-        assert_eq!(CHECK, 2); // 2, not 11, dtor of S is not called\n+        assert_eq!(CHECK, 2); // 2, dtor of W is called\n         {\n             let y = Y { a: S };\n         }\n-        assert_eq!(CHECK, 2); // 2, not 12, dtor of S is not called\n+        assert_eq!(CHECK, 2); // 2, dtor of Y is called\n     }\n }"}, {"sha": "eb169c516d2a81f53d438a04d66c7c3b7115294e", "filename": "src/test/ui/union/union-generic-rpass.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-generic-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-generic-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-generic-rpass.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,37 +1,33 @@\n // run-pass\n #![allow(dead_code)]\n-#![allow(unions_with_drop_fields)]\n \n #![feature(untagged_unions)]\n \n+use std::mem::ManuallyDrop;\n+\n union MaybeItem<T: Iterator> {\n-    elem: T::Item,\n+    elem: ManuallyDrop<T::Item>,\n     none: (),\n }\n \n-union U<A, B> {\n+union U<A, B> where A: Copy, B: Copy {\n     a: A,\n     b: B,\n }\n \n-unsafe fn union_transmute<A, B>(a: A) -> B {\n+unsafe fn union_transmute<A, B>(a: A) -> B where A: Copy, B: Copy {\n     U { a: a }.b\n }\n \n fn main() {\n     unsafe {\n-        let u = U::<String, Vec<u8>> { a: String::from(\"abcd\") };\n-\n-        assert_eq!(u.b.len(), 4);\n-        assert_eq!(u.b[0], b'a');\n-\n         let b = union_transmute::<(u8, u8), u16>((1, 1));\n         assert_eq!(b, (1 << 8) + 1);\n \n         let v: Vec<u8> = vec![1, 2, 3];\n         let mut i = v.iter();\n         i.next();\n-        let mi = MaybeItem::<std::slice::Iter<_>> { elem: i.next().unwrap() };\n-        assert_eq!(*mi.elem, 2);\n+        let mi = MaybeItem::<std::slice::Iter<_>> { elem: ManuallyDrop::new(i.next().unwrap()) };\n+        assert_eq!(**mi.elem, 2);\n     }\n }"}, {"sha": "a43a5050865691e6bd7db60e2222feff00ecfc16", "filename": "src/test/ui/union/union-manuallydrop-rpass.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-manuallydrop-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-manuallydrop-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-manuallydrop-rpass.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -0,0 +1,42 @@\n+#![feature(untagged_unions)]\n+#![allow(dead_code)]\n+// run-pass\n+\n+use std::mem::needs_drop;\n+use std::mem::ManuallyDrop;\n+\n+struct NeedDrop;\n+\n+impl Drop for NeedDrop {\n+    fn drop(&mut self) {}\n+}\n+\n+union UnionOk1<T> {\n+    empty: (),\n+    value: ManuallyDrop<T>,\n+}\n+\n+union UnionOk2 {\n+    value: ManuallyDrop<NeedDrop>,\n+}\n+\n+#[allow(dead_code)]\n+union UnionOk3<T: Copy> {\n+    empty: (),\n+    value: T,\n+}\n+\n+trait Foo { }\n+\n+trait ImpliesCopy : Copy { }\n+\n+#[allow(dead_code)]\n+union UnionOk4<T: ImpliesCopy> {\n+    value: T,\n+}\n+\n+fn main() {\n+    // NeedDrop should not make needs_drop true\n+    assert!(!needs_drop::<UnionOk1<NeedDrop>>());\n+    assert!(!needs_drop::<UnionOk3<&dyn Foo>>());\n+}"}, {"sha": "59282bec59b84de9cbf6757e0c78ef1197e21406", "filename": "src/test/ui/union/union-nodrop.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-nodrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-nodrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-nodrop.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,12 +1,11 @@\n // run-pass\n \n-#![feature(core_intrinsics)]\n #![feature(untagged_unions)]\n \n-#![allow(unions_with_drop_fields)]\n #![allow(dead_code)]\n \n-use std::intrinsics::needs_drop;\n+use std::mem::needs_drop;\n+use std::mem::ManuallyDrop;\n \n struct NeedDrop;\n \n@@ -16,10 +15,14 @@ impl Drop for NeedDrop {\n \n // Constant expressios allow `NoDrop` to go out of scope,\n // unlike a value of the interior type implementing `Drop`.\n-static X: () = (NoDrop { inner: NeedDrop }, ()).1;\n+static X: () = (NoDrop { inner: ManuallyDrop::new(NeedDrop) }, ()).1;\n+\n+const Y: () = (NoDrop { inner: ManuallyDrop::new(NeedDrop) }, ()).1;\n+\n+const fn _f() { (NoDrop { inner: ManuallyDrop::new(NeedDrop) }, ()).1 }\n \n // A union that scrubs the drop glue from its inner type\n-union NoDrop<T> {inner: T}\n+union NoDrop<T> { inner: ManuallyDrop<T> }\n \n // Copy currently can't be implemented on drop-containing unions,\n // this may change later\n@@ -40,7 +43,7 @@ struct Baz {\n     y: Box<u8>,\n }\n \n-union ActuallyDrop<T> {inner: T}\n+union ActuallyDrop<T> { inner: ManuallyDrop<T> }\n \n impl<T> Drop for ActuallyDrop<T> {\n     fn drop(&mut self) {}"}, {"sha": "8234beb74a8269137568b0d8b63c6575fd61b9a9", "filename": "src/test/ui/union/union-overwrite.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-overwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-overwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-overwrite.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,21 +1,27 @@\n // run-pass\n-#![allow(unions_with_drop_fields)]\n-\n #![feature(untagged_unions)]\n \n #[repr(C)]\n+#[derive(Copy, Clone)]\n struct Pair<T, U>(T, U);\n #[repr(C)]\n+#[derive(Copy, Clone)]\n struct Triple<T>(T, T, T);\n \n #[repr(C)]\n-union U<A, B> {\n+union U<A, B>\n+where\n+    A: Copy, B: Copy\n+{\n     a: Pair<A, A>,\n     b: B,\n }\n \n #[repr(C)]\n-union W<A, B> {\n+union W<A, B>\n+where\n+    A: Copy, B: Copy\n+{\n     a: A,\n     b: B,\n }"}, {"sha": "8535cbd019ce87c6871f2dfbc8511df2e186c25a", "filename": "src/test/ui/union/union-unsafe.rs", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,29 +1,33 @@\n #![feature(untagged_unions)]\n+use std::mem::ManuallyDrop;\n \n union U1 {\n     a: u8\n }\n \n union U2 {\n-    a: String\n+    a: ManuallyDrop<String>\n }\n \n union U3<T> {\n-    a: T\n+    a: ManuallyDrop<T>\n }\n \n union U4<T: Copy> {\n     a: T\n }\n \n fn generic_noncopy<T: Default>() {\n-    let mut u3 = U3 { a: T::default() };\n-    u3.a = T::default(); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };\n+    u3.a = ManuallyDrop::new(T::default()); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    *u3.a = T::default(); //~ ERROR access to union field is unsafe\n }\n \n fn generic_copy<T: Copy + Default>() {\n-    let mut u3 = U3 { a: T::default() };\n-    u3.a = T::default(); // OK\n+    let mut u3 = U3 { a: ManuallyDrop::new(T::default()) };\n+    u3.a = ManuallyDrop::new(T::default()); // OK\n+    *u3.a = T::default(); //~ ERROR access to union field is unsafe\n+\n     let mut u4 = U4 { a: T::default() };\n     u4.a = T::default(); // OK\n }\n@@ -32,14 +36,20 @@ fn main() {\n     let mut u1 = U1 { a: 10 }; // OK\n     let a = u1.a; //~ ERROR access to union field is unsafe\n     u1.a = 11; // OK\n+\n     let U1 { a } = u1; //~ ERROR access to union field is unsafe\n     if let U1 { a: 12 } = u1 {} //~ ERROR access to union field is unsafe\n     // let U1 { .. } = u1; // OK\n \n-    let mut u2 = U2 { a: String::from(\"old\") }; // OK\n-    u2.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field is unsafe\n-    let mut u3 = U3 { a: 0 }; // OK\n-    u3.a = 1; // OK\n-    let mut u3 = U3 { a: String::from(\"old\") }; // OK\n-    u3.a = String::from(\"new\"); //~ ERROR assignment to non-`Copy` union field is unsafe\n+    let mut u2 = U2 { a: ManuallyDrop::new(String::from(\"old\")) }; // OK\n+    u2.a = ManuallyDrop::new(String::from(\"new\")); //~ ERROR assignment to non-`Copy` union\n+    *u2.a = String::from(\"new\"); //~ ERROR access to union field is unsafe\n+\n+    let mut u3 = U3 { a: ManuallyDrop::new(0) }; // OK\n+    u3.a = ManuallyDrop::new(1); // OK\n+    *u3.a = 1; //~ ERROR access to union field is unsafe\n+\n+    let mut u3 = U3 { a: ManuallyDrop::new(String::from(\"old\")) }; // OK\n+    u3.a = ManuallyDrop::new(String::from(\"new\")); //~ ERROR assignment to non-`Copy` union\n+    *u3.a = String::from(\"new\"); //~ ERROR access to union field is unsafe\n }"}, {"sha": "e020dab63f8f442d503b119caf1b59bcd2d53793", "filename": "src/test/ui/union/union-unsafe.stderr", "status": "modified", "additions": 53, "deletions": 13, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-unsafe.stderr?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,51 +1,91 @@\n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:21:5\n+  --> $DIR/union-unsafe.rs:22:5\n    |\n-LL |     u3.a = T::default();\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u3.a = ManuallyDrop::new(T::default());\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:33:13\n+  --> $DIR/union-unsafe.rs:23:6\n+   |\n+LL |     *u3.a = T::default();\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:29:6\n+   |\n+LL |     *u3.a = T::default();\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:37:13\n    |\n LL |     let a = u1.a;\n    |             ^^^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:35:14\n+  --> $DIR/union-unsafe.rs:40:14\n    |\n LL |     let U1 { a } = u1;\n    |              ^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: access to union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:36:20\n+  --> $DIR/union-unsafe.rs:41:20\n    |\n LL |     if let U1 { a: 12 } = u1 {}\n    |                    ^^ access to union field\n    |\n    = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n \n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:40:5\n+  --> $DIR/union-unsafe.rs:45:5\n    |\n-LL |     u2.a = String::from(\"new\");\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u2.a = ManuallyDrop::new(String::from(\"new\"));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:46:6\n+   |\n+LL |     *u2.a = String::from(\"new\");\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:50:6\n+   |\n+LL |     *u3.a = 1;\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n error[E0133]: assignment to non-`Copy` union field is unsafe and requires unsafe function or block\n-  --> $DIR/union-unsafe.rs:44:5\n+  --> $DIR/union-unsafe.rs:53:5\n    |\n-LL |     u3.a = String::from(\"new\");\n-   |     ^^^^ assignment to non-`Copy` union field\n+LL |     u3.a = ManuallyDrop::new(String::from(\"new\"));\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ assignment to non-`Copy` union field\n    |\n    = note: the previous content of the field will be dropped, which causes undefined behavior if the field was not properly initialized\n \n-error: aborting due to 6 previous errors\n+error[E0133]: access to union field is unsafe and requires unsafe function or block\n+  --> $DIR/union-unsafe.rs:54:6\n+   |\n+LL |     *u3.a = String::from(\"new\");\n+   |      ^^^^ access to union field\n+   |\n+   = note: the field may not be properly initialized: using uninitialized data will cause undefined behavior\n+\n+error: aborting due to 11 previous errors\n \n For more information about this error, try `rustc --explain E0133`."}, {"sha": "4dbeb7c1e7e973d3a0b7b3afc99bcf8d01a4af9c", "filename": "src/test/ui/union/union-with-drop-fields-lint-rpass.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint-rpass.rs?ref=10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07", "patch": "@@ -1,32 +0,0 @@\n-// run-pass\n-\n-#![feature(untagged_unions)]\n-#![allow(dead_code)]\n-#![allow(unions_with_drop_fields)]\n-\n-union U {\n-    a: u8, // OK\n-}\n-\n-union W {\n-    a: String, // OK\n-    b: String, // OK\n-}\n-\n-struct S(String);\n-\n-// `S` doesn't implement `Drop` trait, but still has non-trivial destructor\n-union Y {\n-    a: S, // OK\n-}\n-\n-// We don't know if `T` is trivially-destructable or not until trans\n-union J<T> {\n-    a: T, // OK\n-}\n-\n-union H<T: Copy> {\n-    a: T, // OK\n-}\n-\n-fn main() {}"}, {"sha": "2f90f240d2e1947e05807f22bf49dbfa0dfdb4bb", "filename": "src/test/ui/union/union-with-drop-fields-lint.stderr", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields-lint.stderr?ref=10f12fe3e73f3b6f7e6d6f8bbd87b1a8b4e74a07", "patch": "@@ -1,26 +0,0 @@\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:10:5\n-   |\n-LL |     a: String,\n-   |     ^^^^^^^^^\n-   |\n-note: lint level defined here\n-  --> $DIR/union-with-drop-fields-lint.rs:3:9\n-   |\n-LL | #![deny(unions_with_drop_fields)]\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^\n-\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:18:5\n-   |\n-LL |     a: S,\n-   |     ^^^^\n-\n-error: union contains a field with possibly non-trivial drop code, drop code of union fields is ignored when dropping the union\n-  --> $DIR/union-with-drop-fields-lint.rs:23:5\n-   |\n-LL |     a: T,\n-   |     ^^^^\n-\n-error: aborting due to 3 previous errors\n-"}, {"sha": "e3c63a6d5b5a2e7ad447a3ff7bb7a8d3e794e4fa", "filename": "src/test/ui/union/union-with-drop-fields.rs", "status": "renamed", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.rs?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -1,26 +1,25 @@\n #![feature(untagged_unions)]\n #![allow(dead_code)]\n-#![deny(unions_with_drop_fields)]\n \n union U {\n     a: u8, // OK\n }\n \n union W {\n-    a: String, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: String, //~ ERROR unions may not contain fields that need dropping\n     b: String, // OK, only one field is reported\n }\n \n struct S(String);\n \n // `S` doesn't implement `Drop` trait, but still has non-trivial destructor\n union Y {\n-    a: S, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: S, //~ ERROR unions may not contain fields that need dropping\n }\n \n // We don't know if `T` is trivially-destructable or not until trans\n union J<T> {\n-    a: T, //~ ERROR union contains a field with possibly non-trivial drop code\n+    a: T, //~ ERROR unions may not contain fields that need dropping\n }\n \n union H<T: Copy> {", "previous_filename": "src/test/ui/union/union-with-drop-fields-lint.rs"}, {"sha": "0e77279be616a7a1f71b2759a70e1b29a776dcfa", "filename": "src/test/ui/union/union-with-drop-fields.stderr", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/aba84894d1879a7429d5bc20d0bfdca3471685de/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-with-drop-fields.stderr?ref=aba84894d1879a7429d5bc20d0bfdca3471685de", "patch": "@@ -0,0 +1,39 @@\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:9:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:9:5\n+   |\n+LL |     a: String,\n+   |     ^^^^^^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:17:5\n+   |\n+LL |     a: S,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:17:5\n+   |\n+LL |     a: S,\n+   |     ^^^^\n+\n+error[E0740]: unions may not contain fields that need dropping\n+  --> $DIR/union-with-drop-fields.rs:22:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+   |\n+note: `std::mem::ManuallyDrop` can be used to wrap the type\n+  --> $DIR/union-with-drop-fields.rs:22:5\n+   |\n+LL |     a: T,\n+   |     ^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0740`."}]}