{"sha": "dbcd9f00d1d66e9f245c3b934fe9530982430824", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiY2Q5ZjAwZDFkNjZlOWYyNDVjM2I5MzRmZTk1MzA5ODI0MzA4MjQ=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-06T18:29:26Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2015-08-17T21:41:38Z"}, "message": "Create separate module for intrinsic typechecking.", "tree": {"sha": "37f5a3f6736fb91024f594992dddcf977a653f66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37f5a3f6736fb91024f594992dddcf977a653f66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dbcd9f00d1d66e9f245c3b934fe9530982430824", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dbcd9f00d1d66e9f245c3b934fe9530982430824", "html_url": "https://github.com/rust-lang/rust/commit/dbcd9f00d1d66e9f245c3b934fe9530982430824", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dbcd9f00d1d66e9f245c3b934fe9530982430824/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "717da9513f787f6f46726bc62e5d3b173435522e", "url": "https://api.github.com/repos/rust-lang/rust/commits/717da9513f787f6f46726bc62e5d3b173435522e", "html_url": "https://github.com/rust-lang/rust/commit/717da9513f787f6f46726bc62e5d3b173435522e"}], "stats": {"total": 1019, "additions": 525, "deletions": 494}, "files": [{"sha": "86c106a234df2e9166b680f5a0d939aee5011578", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "added", "additions": 520, "deletions": 0, "changes": 520, "blob_url": "https://github.com/rust-lang/rust/blob/dbcd9f00d1d66e9f245c3b934fe9530982430824/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcd9f00d1d66e9f245c3b934fe9530982430824/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=dbcd9f00d1d66e9f245c3b934fe9530982430824", "patch": "@@ -0,0 +1,520 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Type-checking for the rust-intrinsic and platform-intrinsic\n+//! intrinsics that the compiler exposes.\n+\n+use astconv::AstConv;\n+use intrinsics;\n+use middle::infer;\n+use middle::subst;\n+use middle::ty::FnSig;\n+use middle::ty::{self, Ty};\n+use middle::ty_fold::TypeFolder;\n+use {CrateCtxt, require_same_types};\n+\n+use std::collections::{HashMap};\n+use std::iter;\n+use syntax::abi;\n+use syntax::attr::AttrMetaMethods;\n+use syntax::ast;\n+use syntax::ast_util::local_def;\n+use syntax::codemap::Span;\n+use syntax::parse::token;\n+\n+\n+/// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n+/// and in libcore/intrinsics.rs\n+pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n+    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n+        let name = token::intern(&format!(\"P{}\", n));\n+        ccx.tcx.mk_param(subst::FnSpace, n, name)\n+    }\n+\n+    let tcx = ccx.tcx;\n+    let name = it.ident.name.as_str();\n+    let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n+        let split : Vec<&str> = name.split('_').collect();\n+        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n+\n+        //We only care about the operation here\n+        let (n_tps, inputs, output) = match split[1] {\n+            \"cxchg\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n+                                param(ccx, 0),\n+                                param(ccx, 0)),\n+                        param(ccx, 0)),\n+            \"load\" => (1, vec!(tcx.mk_imm_ptr(param(ccx, 0))),\n+                       param(ccx, 0)),\n+            \"store\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n+                        tcx.mk_nil()),\n+\n+            \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n+            \"min\"  | \"umax\" | \"umin\" => {\n+                (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n+                 param(ccx, 0))\n+            }\n+            \"fence\" | \"singlethreadfence\" => {\n+                (0, Vec::new(), tcx.mk_nil())\n+            }\n+            op => {\n+                span_err!(tcx.sess, it.span, E0092,\n+                    \"unrecognized atomic operation function: `{}`\", op);\n+                return;\n+            }\n+        };\n+        (n_tps, inputs, ty::FnConverging(output))\n+    } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n+        (0, Vec::new(), ty::FnDiverging)\n+    } else {\n+        let (n_tps, inputs, output) = match &name[..] {\n+            \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n+            \"size_of\" |\n+            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n+            \"size_of_val\" |  \"min_align_of_val\" => {\n+                (1, vec![\n+                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                                                                  ty::BrAnon(0))),\n+                                    param(ccx, 0))\n+                 ], ccx.tcx.types.usize)\n+            }\n+            \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n+            \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n+            \"forget\" => (1, vec!( param(ccx, 0) ), tcx.mk_nil()),\n+            \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n+            \"move_val_init\" => {\n+                (1,\n+                 vec!(\n+                    tcx.mk_mut_ptr(param(ccx, 0)),\n+                    param(ccx, 0)\n+                  ),\n+               tcx.mk_nil())\n+            }\n+            \"drop_in_place\" => {\n+                (1, vec![tcx.mk_mut_ptr(param(ccx, 0))], tcx.mk_nil())\n+            }\n+            \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n+\n+            \"type_name\" => (1, Vec::new(), tcx.mk_static_str()),\n+            \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n+            \"offset\" | \"arith_offset\" => {\n+              (1,\n+               vec!(\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutImmutable\n+                  }),\n+                  ccx.tcx.types.isize\n+               ),\n+               tcx.mk_ptr(ty::TypeAndMut {\n+                   ty: param(ccx, 0),\n+                   mutbl: ast::MutImmutable\n+               }))\n+            }\n+            \"copy\" | \"copy_nonoverlapping\" => {\n+              (1,\n+               vec!(\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutImmutable\n+                  }),\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutMutable\n+                  }),\n+                  tcx.types.usize,\n+               ),\n+               tcx.mk_nil())\n+            }\n+            \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n+              (1,\n+               vec!(\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutMutable\n+                  }),\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutImmutable\n+                  }),\n+                  tcx.types.usize,\n+               ),\n+               tcx.mk_nil())\n+            }\n+            \"write_bytes\" | \"volatile_set_memory\" => {\n+              (1,\n+               vec!(\n+                  tcx.mk_ptr(ty::TypeAndMut {\n+                      ty: param(ccx, 0),\n+                      mutbl: ast::MutMutable\n+                  }),\n+                  tcx.types.u8,\n+                  tcx.types.usize,\n+               ),\n+               tcx.mk_nil())\n+            }\n+            \"sqrtf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"sqrtf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"powif32\" => {\n+               (0,\n+                vec!( tcx.types.f32, tcx.types.i32 ),\n+                tcx.types.f32)\n+            }\n+            \"powif64\" => {\n+               (0,\n+                vec!( tcx.types.f64, tcx.types.i32 ),\n+                tcx.types.f64)\n+            }\n+            \"sinf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"sinf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"cosf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"cosf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"powf32\" => {\n+               (0,\n+                vec!( tcx.types.f32, tcx.types.f32 ),\n+                tcx.types.f32)\n+            }\n+            \"powf64\" => {\n+               (0,\n+                vec!( tcx.types.f64, tcx.types.f64 ),\n+                tcx.types.f64)\n+            }\n+            \"expf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"expf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"exp2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"exp2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"logf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"logf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"log10f32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"log10f64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"log2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"log2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"fmaf32\" => {\n+                (0,\n+                 vec!( tcx.types.f32, tcx.types.f32, tcx.types.f32 ),\n+                 tcx.types.f32)\n+            }\n+            \"fmaf64\" => {\n+                (0,\n+                 vec!( tcx.types.f64, tcx.types.f64, tcx.types.f64 ),\n+                 tcx.types.f64)\n+            }\n+            \"fabsf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"fabsf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"copysignf32\"  => (0, vec!( tcx.types.f32, tcx.types.f32 ), tcx.types.f32),\n+            \"copysignf64\"  => (0, vec!( tcx.types.f64, tcx.types.f64 ), tcx.types.f64),\n+            \"floorf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"floorf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"ceilf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"ceilf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"truncf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"truncf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"rintf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"rintf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"nearbyintf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"nearbyintf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"roundf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n+            \"roundf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n+            \"ctpop8\"       => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"ctpop16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"ctpop32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"ctpop64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"ctlz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"ctlz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"ctlz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"ctlz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"cttz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n+            \"cttz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"cttz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"cttz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+            \"bswap16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n+            \"bswap32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n+            \"bswap64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n+\n+            \"volatile_load\" =>\n+                (1, vec!( tcx.mk_imm_ptr(param(ccx, 0)) ), param(ccx, 0)),\n+            \"volatile_store\" =>\n+                (1, vec!( tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0) ), tcx.mk_nil()),\n+\n+            \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.i8, tcx.types.i8),\n+                tcx.mk_tup(vec!(tcx.types.i8, tcx.types.bool))),\n+\n+            \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.i16, tcx.types.i16),\n+                tcx.mk_tup(vec!(tcx.types.i16, tcx.types.bool))),\n+\n+            \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.i32, tcx.types.i32),\n+                tcx.mk_tup(vec!(tcx.types.i32, tcx.types.bool))),\n+\n+            \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.i64, tcx.types.i64),\n+                tcx.mk_tup(vec!(tcx.types.i64, tcx.types.bool))),\n+\n+            \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.u8, tcx.types.u8),\n+                tcx.mk_tup(vec!(tcx.types.u8, tcx.types.bool))),\n+\n+            \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.u16, tcx.types.u16),\n+                tcx.mk_tup(vec!(tcx.types.u16, tcx.types.bool))),\n+\n+            \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n+                (0, vec!(tcx.types.u32, tcx.types.u32),\n+                tcx.mk_tup(vec!(tcx.types.u32, tcx.types.bool))),\n+\n+            \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n+                (0, vec!(tcx.types.u64, tcx.types.u64),\n+                tcx.mk_tup(vec!(tcx.types.u64, tcx.types.bool))),\n+\n+            \"unchecked_udiv\" | \"unchecked_sdiv\" | \"unchecked_urem\" | \"unchecked_srem\" =>\n+                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+\n+            \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n+                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n+\n+            \"return_address\" => (0, vec![], tcx.mk_imm_ptr(tcx.types.u8)),\n+\n+            \"assume\" => (0, vec![tcx.types.bool], tcx.mk_nil()),\n+\n+            \"discriminant_value\" => (1, vec![\n+                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                                                                  ty::BrAnon(0))),\n+                                   param(ccx, 0))], tcx.types.u64),\n+\n+            \"try\" => {\n+                let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n+                let fn_ty = ty::BareFnTy {\n+                    unsafety: ast::Unsafety::Normal,\n+                    abi: abi::Rust,\n+                    sig: ty::Binder(FnSig {\n+                        inputs: vec![mut_u8],\n+                        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n+                        variadic: false,\n+                    }),\n+                };\n+                let fn_ty = tcx.mk_bare_fn(fn_ty);\n+                (0, vec![tcx.mk_fn(None, fn_ty), mut_u8], mut_u8)\n+            }\n+\n+            ref other => {\n+                span_err!(tcx.sess, it.span, E0093,\n+                          \"unrecognized intrinsic function: `{}`\", *other);\n+                return;\n+            }\n+        };\n+        (n_tps, inputs, ty::FnConverging(output))\n+    };\n+    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: ast::Unsafety::Unsafe,\n+        abi: abi::RustIntrinsic,\n+        sig: ty::Binder(FnSig {\n+            inputs: inputs,\n+            output: output,\n+            variadic: false,\n+        }),\n+    }));\n+    let i_ty = ccx.tcx.lookup_item_type(local_def(it.id));\n+    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n+    if i_n_tps != n_tps {\n+        span_err!(tcx.sess, it.span, E0094,\n+            \"intrinsic has wrong number of type \\\n+             parameters: found {}, expected {}\",\n+             i_n_tps, n_tps);\n+    } else {\n+        require_same_types(tcx,\n+                           None,\n+                           false,\n+                           it.span,\n+                           i_ty.ty,\n+                           fty,\n+                           || {\n+                format!(\"intrinsic has wrong type: expected `{}`\",\n+                         fty)\n+            });\n+    }\n+}\n+\n+/// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n+pub fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n+                                     it: &ast::ForeignItem) {\n+    let param = |n| {\n+        let name = token::intern(&format!(\"P{}\", n));\n+        ccx.tcx.mk_param(subst::FnSpace, n, name)\n+    };\n+\n+    let tcx = ccx.tcx;\n+    let i_ty = tcx.lookup_item_type(local_def(it.id));\n+    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n+    let name = it.ident.name.as_str();\n+    let mut infer_ctxt = None;\n+\n+    let (n_tps, inputs, output) = match &*name {\n+        \"simd_eq\" | \"simd_ne\" | \"simd_lt\" | \"simd_le\" | \"simd_gt\" | \"simd_ge\" => {\n+            (2, vec![param(0), param(0)], param(1))\n+        }\n+        \"simd_add\" | \"simd_sub\" | \"simd_mul\" |\n+        \"simd_div\" | \"simd_shl\" | \"simd_shr\" |\n+        \"simd_and\" | \"simd_or\" | \"simd_xor\" => {\n+            (1, vec![param(0), param(0)], param(0))\n+        }\n+        \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n+        \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n+        \"simd_cast\" => (2, vec![param(0)], param(1)),\n+        name if name.starts_with(\"simd_shuffle\") => {\n+            match name[\"simd_shuffle\".len()..].parse() {\n+                Ok(n) => {\n+                    let mut params = vec![param(0), param(0)];\n+                    params.extend(iter::repeat(tcx.types.u32).take(n));\n+\n+                    let ictxt = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n+                    let ret = ictxt.next_ty_var();\n+                    infer_ctxt = Some(ictxt);\n+                    (2, params, ret)\n+                }\n+                Err(_) => {\n+                    span_err!(tcx.sess, it.span, E0439,\n+                              \"invalid `simd_shuffle`, needs length: `{}`\", name);\n+                    return\n+                }\n+            }\n+        }\n+        _ => {\n+            match intrinsics::Intrinsic::find(tcx, &name) {\n+                Some(intr) => {\n+                    // this function is a platform specific intrinsic\n+                    if i_n_tps != 0 {\n+                        tcx.sess.span_err(it.span,\n+                                         &format!(\"intrinsic has wrong number of type parameters: \\\n+                                                    found {}, expected 0\",\n+                                                   i_n_tps));\n+                        return\n+                    }\n+\n+                    let mut structural_to_nomimal = HashMap::new();\n+\n+                    let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n+                    let input_pairs = intr.inputs.iter().zip(&sig.inputs);\n+                    for (i, (expected_arg, arg)) in input_pairs.enumerate() {\n+                        match_intrinsic_type_to_type(tcx, &format!(\"argument {}\", i + 1), it.span,\n+                                                     &mut structural_to_nomimal, expected_arg, arg);\n+                    }\n+                    match_intrinsic_type_to_type(tcx, \"return value\", it.span,\n+                                                 &mut structural_to_nomimal,\n+                                                 &intr.output, sig.output.unwrap());\n+                    return\n+                }\n+                None => {\n+                    tcx.sess.span_err(it.span,\n+                                      &format!(\"unrecognized intrinsic function: `{}`\", name));\n+                    return;\n+                }\n+            }\n+        }\n+    };\n+\n+    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n+        unsafety: ast::Unsafety::Unsafe,\n+        abi: abi::PlatformIntrinsic,\n+        sig: ty::Binder(FnSig {\n+            inputs: inputs,\n+            output: ty::FnConverging(output),\n+            variadic: false,\n+        }),\n+    }));\n+    if i_n_tps != n_tps {\n+        span_err!(tcx.sess, it.span, E0094,\n+            \"intrinsic has wrong number of type \\\n+             parameters: found {}, expected {}\",\n+             i_n_tps, n_tps);\n+    } else {\n+        require_same_types(tcx,\n+                           infer_ctxt.as_ref(),\n+                           false,\n+                           it.span,\n+                           i_ty.ty,\n+                           fty,\n+                           || {\n+                format!(\"intrinsic has wrong type: expected `{}`\",\n+                         fty)\n+            });\n+    }\n+}\n+\n+// walk the expected type and the actual type in lock step, checking they're\n+// the same, in a kinda-structural way, i.e. `Vector`s have to be simd structs with\n+// exactly the right element type\n+fn match_intrinsic_type_to_type<'tcx, 'a>(\n+        tcx: &ty::ctxt<'tcx>,\n+        position: &str,\n+        span: Span,\n+        structural_to_nominal: &mut HashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n+        expected: &'a intrinsics::Type, t: ty::Ty<'tcx>)\n+{\n+    use intrinsics::Type::*;\n+    match *expected {\n+        Integer(bits) => match (bits, &t.sty) {\n+            (8, &ty::TyInt(ast::TyI8)) | (8, &ty::TyUint(ast::TyU8)) |\n+            (16, &ty::TyInt(ast::TyI16)) | (16, &ty::TyUint(ast::TyU16)) |\n+            (32, &ty::TyInt(ast::TyI32)) | (32, &ty::TyUint(ast::TyU32)) |\n+            (64, &ty::TyInt(ast::TyI64)) | (64, &ty::TyUint(ast::TyU64)) => {},\n+            _ => tcx.sess.span_err(span,\n+                                   &format!(\"intrinsic {} has wrong type: found `{}`, \\\n+                                             expected `i{n}` or `u{n}`\",\n+                                            position,\n+                                            t, n = bits)),\n+        },\n+        Float(bits) => match (bits, &t.sty) {\n+            (32, &ty::TyFloat(ast::TyF32)) |\n+            (64, &ty::TyFloat(ast::TyF64)) => {},\n+            _ => tcx.sess.span_err(span,\n+                                   &format!(\"intrinsic {} has wrong type: found `{}`, \\\n+                                             expected `f{n}`\",\n+                                            position,\n+                                            t, n = bits)),\n+        },\n+        Pointer(_) => unimplemented!(),\n+        Vector(ref inner_expected, len) => {\n+            if !t.is_simd(tcx) {\n+                tcx.sess.span_err(span,\n+                                  &format!(\"intrinsic {} has wrong type: found non-simd type {}, \\\n+                                           expected simd type\",\n+                                           position, t));\n+                return;\n+            }\n+            let t_len = t.simd_size(tcx);\n+            if len as usize != t_len {\n+                tcx.sess.span_err(span,\n+                                  &format!(\"intrinsic {} has wrong type: found \\\n+                                            vector with length {}, expected length {}\",\n+                                           position,\n+                                           t_len, len));\n+                return;\n+            }\n+            let t_ty = t.simd_type(tcx);\n+            {\n+                let previous = structural_to_nominal.entry(expected).or_insert(t);\n+                if *previous != t {\n+                    tcx.sess.span_err(span,\n+                                      &format!(\"intrinsic {} has wrong type: found `{}`, \\\n+                                                but already seen this vector type as `{}`\",\n+                                               position, t, previous));\n+                    return;\n+                }\n+            }\n+            match_intrinsic_type_to_type(tcx,\n+                                         position,\n+                                         span,\n+                                         structural_to_nominal,\n+                                         inner_expected,\n+                                         t_ty)\n+        }\n+    }\n+}"}, {"sha": "500e4287d61b8dcee273318d7b97f7ba50aef1f2", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 494, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/dbcd9f00d1d66e9f245c3b934fe9530982430824/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dbcd9f00d1d66e9f245c3b934fe9530982430824/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=dbcd9f00d1d66e9f245c3b934fe9530982430824", "patch": "@@ -84,7 +84,6 @@ use self::TupleArgumentsFlag::*;\n use astconv::{self, ast_region_to_region, ast_ty_to_ty, AstConv, PathParamMode};\n use check::_match::pat_ctxt;\n use fmt_macros::{Parser, Piece, Position};\n-use intrinsics;\n use middle::astconv_util::{check_path_args, NO_TPS, NO_REGIONS};\n use middle::def;\n use middle::infer;\n@@ -102,16 +101,15 @@ use middle::ty_fold::{TypeFolder, TypeFoldable};\n use require_c_abi_if_variadic;\n use rscope::{ElisionFailureInfo, RegionScope};\n use session::Session;\n-use {CrateCtxt, lookup_full_def, require_same_types};\n+use {CrateCtxt, lookup_full_def};\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, ErrorReported, indenter, loop_query};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use util::lev_distance::lev_distance;\n \n use std::cell::{Cell, Ref, RefCell};\n-use std::collections::{HashSet, HashMap};\n-use std::iter;\n+use std::collections::{HashSet};\n use std::mem::replace;\n use std::slice;\n use syntax::{self, abi, attr};\n@@ -141,6 +139,7 @@ mod cast;\n mod closure;\n mod callee;\n mod compare_method;\n+mod intrinsic;\n mod op;\n \n /// closures defined within the function.  For example:\n@@ -718,11 +717,11 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n       ast::ItemForeignMod(ref m) => {\n         if m.abi == abi::RustIntrinsic {\n             for item in &m.items {\n-                check_intrinsic_type(ccx, &**item);\n+                intrinsic::check_intrinsic_type(ccx, &**item);\n             }\n         } else if m.abi == abi::PlatformIntrinsic {\n             for item in &m.items {\n-                check_platform_intrinsic_type(ccx, &**item);\n+                intrinsic::check_platform_intrinsic_type(ccx, &**item);\n             }\n         } else {\n             for item in &m.items {\n@@ -5086,491 +5085,3 @@ pub fn check_bounds_are_used<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         }\n     }\n }\n-\n-/// Remember to add all intrinsics here, in librustc_trans/trans/intrinsic.rs,\n-/// and in libcore/intrinsics.rs\n-pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n-    fn param<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, n: u32) -> Ty<'tcx> {\n-        let name = token::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(subst::FnSpace, n, name)\n-    }\n-\n-    let tcx = ccx.tcx;\n-    let name = it.ident.name.as_str();\n-    let (n_tps, inputs, output) = if name.starts_with(\"atomic_\") {\n-        let split : Vec<&str> = name.split('_').collect();\n-        assert!(split.len() >= 2, \"Atomic intrinsic not correct format\");\n-\n-        //We only care about the operation here\n-        let (n_tps, inputs, output) = match split[1] {\n-            \"cxchg\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)),\n-                                param(ccx, 0),\n-                                param(ccx, 0)),\n-                        param(ccx, 0)),\n-            \"load\" => (1, vec!(tcx.mk_imm_ptr(param(ccx, 0))),\n-                       param(ccx, 0)),\n-            \"store\" => (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n-                        tcx.mk_nil()),\n-\n-            \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\" | \"xor\" | \"max\" |\n-            \"min\"  | \"umax\" | \"umin\" => {\n-                (1, vec!(tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0)),\n-                 param(ccx, 0))\n-            }\n-            \"fence\" | \"singlethreadfence\" => {\n-                (0, Vec::new(), tcx.mk_nil())\n-            }\n-            op => {\n-                span_err!(tcx.sess, it.span, E0092,\n-                    \"unrecognized atomic operation function: `{}`\", op);\n-                return;\n-            }\n-        };\n-        (n_tps, inputs, ty::FnConverging(output))\n-    } else if &name[..] == \"abort\" || &name[..] == \"unreachable\" {\n-        (0, Vec::new(), ty::FnDiverging)\n-    } else {\n-        let (n_tps, inputs, output) = match &name[..] {\n-            \"breakpoint\" => (0, Vec::new(), tcx.mk_nil()),\n-            \"size_of\" |\n-            \"pref_align_of\" | \"min_align_of\" => (1, Vec::new(), ccx.tcx.types.usize),\n-            \"size_of_val\" |  \"min_align_of_val\" => {\n-                (1, vec![\n-                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n-                                                                  ty::BrAnon(0))),\n-                                    param(ccx, 0))\n-                 ], ccx.tcx.types.usize)\n-            }\n-            \"init\" | \"init_dropped\" => (1, Vec::new(), param(ccx, 0)),\n-            \"uninit\" => (1, Vec::new(), param(ccx, 0)),\n-            \"forget\" => (1, vec!( param(ccx, 0) ), tcx.mk_nil()),\n-            \"transmute\" => (2, vec!( param(ccx, 0) ), param(ccx, 1)),\n-            \"move_val_init\" => {\n-                (1,\n-                 vec!(\n-                    tcx.mk_mut_ptr(param(ccx, 0)),\n-                    param(ccx, 0)\n-                  ),\n-               tcx.mk_nil())\n-            }\n-            \"drop_in_place\" => {\n-                (1, vec![tcx.mk_mut_ptr(param(ccx, 0))], tcx.mk_nil())\n-            }\n-            \"needs_drop\" => (1, Vec::new(), ccx.tcx.types.bool),\n-\n-            \"type_name\" => (1, Vec::new(), tcx.mk_static_str()),\n-            \"type_id\" => (1, Vec::new(), ccx.tcx.types.u64),\n-            \"offset\" | \"arith_offset\" => {\n-              (1,\n-               vec!(\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutImmutable\n-                  }),\n-                  ccx.tcx.types.isize\n-               ),\n-               tcx.mk_ptr(ty::TypeAndMut {\n-                   ty: param(ccx, 0),\n-                   mutbl: ast::MutImmutable\n-               }))\n-            }\n-            \"copy\" | \"copy_nonoverlapping\" => {\n-              (1,\n-               vec!(\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutImmutable\n-                  }),\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutMutable\n-                  }),\n-                  tcx.types.usize,\n-               ),\n-               tcx.mk_nil())\n-            }\n-            \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => {\n-              (1,\n-               vec!(\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutMutable\n-                  }),\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutImmutable\n-                  }),\n-                  tcx.types.usize,\n-               ),\n-               tcx.mk_nil())\n-            }\n-            \"write_bytes\" | \"volatile_set_memory\" => {\n-              (1,\n-               vec!(\n-                  tcx.mk_ptr(ty::TypeAndMut {\n-                      ty: param(ccx, 0),\n-                      mutbl: ast::MutMutable\n-                  }),\n-                  tcx.types.u8,\n-                  tcx.types.usize,\n-               ),\n-               tcx.mk_nil())\n-            }\n-            \"sqrtf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"sqrtf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"powif32\" => {\n-               (0,\n-                vec!( tcx.types.f32, tcx.types.i32 ),\n-                tcx.types.f32)\n-            }\n-            \"powif64\" => {\n-               (0,\n-                vec!( tcx.types.f64, tcx.types.i32 ),\n-                tcx.types.f64)\n-            }\n-            \"sinf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"sinf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"cosf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"cosf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"powf32\" => {\n-               (0,\n-                vec!( tcx.types.f32, tcx.types.f32 ),\n-                tcx.types.f32)\n-            }\n-            \"powf64\" => {\n-               (0,\n-                vec!( tcx.types.f64, tcx.types.f64 ),\n-                tcx.types.f64)\n-            }\n-            \"expf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"expf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"exp2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"exp2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"logf32\"   => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"logf64\"   => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"log10f32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"log10f64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"log2f32\"  => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"log2f64\"  => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"fmaf32\" => {\n-                (0,\n-                 vec!( tcx.types.f32, tcx.types.f32, tcx.types.f32 ),\n-                 tcx.types.f32)\n-            }\n-            \"fmaf64\" => {\n-                (0,\n-                 vec!( tcx.types.f64, tcx.types.f64, tcx.types.f64 ),\n-                 tcx.types.f64)\n-            }\n-            \"fabsf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"fabsf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"copysignf32\"  => (0, vec!( tcx.types.f32, tcx.types.f32 ), tcx.types.f32),\n-            \"copysignf64\"  => (0, vec!( tcx.types.f64, tcx.types.f64 ), tcx.types.f64),\n-            \"floorf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"floorf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"ceilf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"ceilf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"truncf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"truncf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"rintf32\"      => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"rintf64\"      => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"nearbyintf32\" => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"nearbyintf64\" => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"roundf32\"     => (0, vec!( tcx.types.f32 ), tcx.types.f32),\n-            \"roundf64\"     => (0, vec!( tcx.types.f64 ), tcx.types.f64),\n-            \"ctpop8\"       => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n-            \"ctpop16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n-            \"ctpop32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n-            \"ctpop64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n-            \"ctlz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n-            \"ctlz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n-            \"ctlz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n-            \"ctlz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n-            \"cttz8\"        => (0, vec!( tcx.types.u8  ), tcx.types.u8),\n-            \"cttz16\"       => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n-            \"cttz32\"       => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n-            \"cttz64\"       => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n-            \"bswap16\"      => (0, vec!( tcx.types.u16 ), tcx.types.u16),\n-            \"bswap32\"      => (0, vec!( tcx.types.u32 ), tcx.types.u32),\n-            \"bswap64\"      => (0, vec!( tcx.types.u64 ), tcx.types.u64),\n-\n-            \"volatile_load\" =>\n-                (1, vec!( tcx.mk_imm_ptr(param(ccx, 0)) ), param(ccx, 0)),\n-            \"volatile_store\" =>\n-                (1, vec!( tcx.mk_mut_ptr(param(ccx, 0)), param(ccx, 0) ), tcx.mk_nil()),\n-\n-            \"i8_add_with_overflow\" | \"i8_sub_with_overflow\" | \"i8_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.i8, tcx.types.i8),\n-                tcx.mk_tup(vec!(tcx.types.i8, tcx.types.bool))),\n-\n-            \"i16_add_with_overflow\" | \"i16_sub_with_overflow\" | \"i16_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.i16, tcx.types.i16),\n-                tcx.mk_tup(vec!(tcx.types.i16, tcx.types.bool))),\n-\n-            \"i32_add_with_overflow\" | \"i32_sub_with_overflow\" | \"i32_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.i32, tcx.types.i32),\n-                tcx.mk_tup(vec!(tcx.types.i32, tcx.types.bool))),\n-\n-            \"i64_add_with_overflow\" | \"i64_sub_with_overflow\" | \"i64_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.i64, tcx.types.i64),\n-                tcx.mk_tup(vec!(tcx.types.i64, tcx.types.bool))),\n-\n-            \"u8_add_with_overflow\" | \"u8_sub_with_overflow\" | \"u8_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.u8, tcx.types.u8),\n-                tcx.mk_tup(vec!(tcx.types.u8, tcx.types.bool))),\n-\n-            \"u16_add_with_overflow\" | \"u16_sub_with_overflow\" | \"u16_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.u16, tcx.types.u16),\n-                tcx.mk_tup(vec!(tcx.types.u16, tcx.types.bool))),\n-\n-            \"u32_add_with_overflow\" | \"u32_sub_with_overflow\" | \"u32_mul_with_overflow\"=>\n-                (0, vec!(tcx.types.u32, tcx.types.u32),\n-                tcx.mk_tup(vec!(tcx.types.u32, tcx.types.bool))),\n-\n-            \"u64_add_with_overflow\" | \"u64_sub_with_overflow\"  | \"u64_mul_with_overflow\" =>\n-                (0, vec!(tcx.types.u64, tcx.types.u64),\n-                tcx.mk_tup(vec!(tcx.types.u64, tcx.types.bool))),\n-\n-            \"unchecked_udiv\" | \"unchecked_sdiv\" | \"unchecked_urem\" | \"unchecked_srem\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n-\n-            \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" =>\n-                (1, vec![param(ccx, 0), param(ccx, 0)], param(ccx, 0)),\n-\n-            \"return_address\" => (0, vec![], tcx.mk_imm_ptr(tcx.types.u8)),\n-\n-            \"assume\" => (0, vec![tcx.types.bool], tcx.mk_nil()),\n-\n-            \"discriminant_value\" => (1, vec![\n-                    tcx.mk_imm_ref(tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n-                                                                  ty::BrAnon(0))),\n-                                   param(ccx, 0))], tcx.types.u64),\n-\n-            \"try\" => {\n-                let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n-                let fn_ty = ty::BareFnTy {\n-                    unsafety: ast::Unsafety::Normal,\n-                    abi: abi::Rust,\n-                    sig: ty::Binder(FnSig {\n-                        inputs: vec![mut_u8],\n-                        output: ty::FnOutput::FnConverging(tcx.mk_nil()),\n-                        variadic: false,\n-                    }),\n-                };\n-                let fn_ty = tcx.mk_bare_fn(fn_ty);\n-                (0, vec![tcx.mk_fn(None, fn_ty), mut_u8], mut_u8)\n-            }\n-\n-            ref other => {\n-                span_err!(tcx.sess, it.span, E0093,\n-                          \"unrecognized intrinsic function: `{}`\", *other);\n-                return;\n-            }\n-        };\n-        (n_tps, inputs, ty::FnConverging(output))\n-    };\n-    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: ast::Unsafety::Unsafe,\n-        abi: abi::RustIntrinsic,\n-        sig: ty::Binder(FnSig {\n-            inputs: inputs,\n-            output: output,\n-            variadic: false,\n-        }),\n-    }));\n-    let i_ty = ccx.tcx.lookup_item_type(local_def(it.id));\n-    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n-    if i_n_tps != n_tps {\n-        span_err!(tcx.sess, it.span, E0094,\n-            \"intrinsic has wrong number of type \\\n-             parameters: found {}, expected {}\",\n-             i_n_tps, n_tps);\n-    } else {\n-        require_same_types(tcx,\n-                           None,\n-                           false,\n-                           it.span,\n-                           i_ty.ty,\n-                           fty,\n-                           || {\n-                format!(\"intrinsic has wrong type: expected `{}`\",\n-                         fty)\n-            });\n-    }\n-}\n-\n-fn check_platform_intrinsic_type(ccx: &CrateCtxt,\n-                                 it: &ast::ForeignItem) {\n-    let param = |n| {\n-        let name = token::intern(&format!(\"P{}\", n));\n-        ccx.tcx.mk_param(subst::FnSpace, n, name)\n-    };\n-\n-    let tcx = ccx.tcx;\n-    let i_ty = tcx.lookup_item_type(local_def(it.id));\n-    let i_n_tps = i_ty.generics.types.len(subst::FnSpace);\n-    let name = it.ident.name.as_str();\n-    let mut infer_ctxt = None;\n-\n-    let (n_tps, inputs, output) = match &*name {\n-        \"simd_eq\" | \"simd_ne\" | \"simd_lt\" | \"simd_le\" | \"simd_gt\" | \"simd_ge\" => {\n-            (2, vec![param(0), param(0)], param(1))\n-        }\n-        \"simd_add\" | \"simd_sub\" | \"simd_mul\" |\n-        \"simd_div\" | \"simd_shl\" | \"simd_shr\" |\n-        \"simd_and\" | \"simd_or\" | \"simd_xor\" => {\n-            (1, vec![param(0), param(0)], param(0))\n-        }\n-        \"simd_insert\" => (2, vec![param(0), tcx.types.u32, param(1)], param(0)),\n-        \"simd_extract\" => (2, vec![param(0), tcx.types.u32], param(1)),\n-        \"simd_cast\" => (2, vec![param(0)], param(1)),\n-        name if name.starts_with(\"simd_shuffle\") => {\n-            match name[\"simd_shuffle\".len()..].parse() {\n-                Ok(n) => {\n-                    let mut params = vec![param(0), param(0)];\n-                    params.extend(iter::repeat(tcx.types.u32).take(n));\n-\n-                    let ictxt = infer::new_infer_ctxt(tcx, &tcx.tables, None, false);\n-                    let ret = ictxt.next_ty_var();\n-                    infer_ctxt = Some(ictxt);\n-                    (2, params, ret)\n-                }\n-                Err(_) => {\n-                    span_err!(tcx.sess, it.span, E0439,\n-                              \"invalid `simd_shuffle`, needs length: `{}`\", name);\n-                    return\n-                }\n-            }\n-        }\n-        _ => {\n-            match intrinsics::Intrinsic::find(tcx, &name) {\n-                Some(intr) => {\n-                    // this function is a platform specific intrinsic\n-                    if i_n_tps != 0 {\n-                        tcx.sess.span_err(it.span,\n-                                         &format!(\"intrinsic has wrong number of type parameters: \\\n-                                                    found {}, expected 0\",\n-                                                   i_n_tps));\n-                        return\n-                    }\n-\n-                    let mut structural_to_nomimal = HashMap::new();\n-\n-                    let sig = tcx.no_late_bound_regions(i_ty.ty.fn_sig()).unwrap();\n-                    let input_pairs = intr.inputs.iter().zip(&sig.inputs);\n-                    for (i, (expected_arg, arg)) in input_pairs.enumerate() {\n-                        match_intrinsic_type_to_type(tcx, &format!(\"argument {}\", i + 1), it.span,\n-                                                     &mut structural_to_nomimal, expected_arg, arg);\n-                    }\n-                    match_intrinsic_type_to_type(tcx, \"return value\", it.span,\n-                                                 &mut structural_to_nomimal,\n-                                                 &intr.output, sig.output.unwrap());\n-                    return\n-                }\n-                None => {\n-                    tcx.sess.span_err(it.span,\n-                                      &format!(\"unrecognized intrinsic function: `{}`\", name));\n-                    return;\n-                }\n-            }\n-        }\n-    };\n-\n-    let fty = tcx.mk_fn(None, tcx.mk_bare_fn(ty::BareFnTy {\n-        unsafety: ast::Unsafety::Unsafe,\n-        abi: abi::PlatformIntrinsic,\n-        sig: ty::Binder(FnSig {\n-            inputs: inputs,\n-            output: ty::FnConverging(output),\n-            variadic: false,\n-        }),\n-    }));\n-    if i_n_tps != n_tps {\n-        span_err!(tcx.sess, it.span, E0094,\n-            \"intrinsic has wrong number of type \\\n-             parameters: found {}, expected {}\",\n-             i_n_tps, n_tps);\n-    } else {\n-        require_same_types(tcx,\n-                           infer_ctxt.as_ref(),\n-                           false,\n-                           it.span,\n-                           i_ty.ty,\n-                           fty,\n-                           || {\n-                format!(\"intrinsic has wrong type: expected `{}`\",\n-                         fty)\n-            });\n-    }\n-}\n-\n-// walk the expected type and the actual type in lock step, checking they're\n-// the same, in a kinda-structural way, i.e. `Vector`s have to be simd structs with\n-// exactly the right element type\n-fn match_intrinsic_type_to_type<'tcx, 'a>(\n-        tcx: &ty::ctxt<'tcx>,\n-        position: &str,\n-        span: Span,\n-        structural_to_nominal: &mut HashMap<&'a intrinsics::Type, ty::Ty<'tcx>>,\n-        expected: &'a intrinsics::Type, t: ty::Ty<'tcx>)\n-{\n-    use intrinsics::Type::*;\n-    match *expected {\n-        Integer(bits) => match (bits, &t.sty) {\n-            (8, &ty::TyInt(ast::TyI8)) | (8, &ty::TyUint(ast::TyU8)) |\n-            (16, &ty::TyInt(ast::TyI16)) | (16, &ty::TyUint(ast::TyU16)) |\n-            (32, &ty::TyInt(ast::TyI32)) | (32, &ty::TyUint(ast::TyU32)) |\n-            (64, &ty::TyInt(ast::TyI64)) | (64, &ty::TyUint(ast::TyU64)) => {},\n-            _ => tcx.sess.span_err(span,\n-                                   &format!(\"intrinsic {} has wrong type: found `{}`, \\\n-                                             expected `i{n}` or `u{n}`\",\n-                                            position,\n-                                            t, n = bits)),\n-        },\n-        Float(bits) => match (bits, &t.sty) {\n-            (32, &ty::TyFloat(ast::TyF32)) |\n-            (64, &ty::TyFloat(ast::TyF64)) => {},\n-            _ => tcx.sess.span_err(span,\n-                                   &format!(\"intrinsic {} has wrong type: found `{}`, \\\n-                                             expected `f{n}`\",\n-                                            position,\n-                                            t, n = bits)),\n-        },\n-        Pointer(_) => unimplemented!(),\n-        Vector(ref inner_expected, len) => {\n-            if !t.is_simd(tcx) {\n-                tcx.sess.span_err(span,\n-                                  &format!(\"intrinsic {} has wrong type: found non-simd type {}, \\\n-                                           expected simd type\",\n-                                           position, t));\n-                return;\n-            }\n-            let t_len = t.simd_size(tcx);\n-            if len as usize != t_len {\n-                tcx.sess.span_err(span,\n-                                  &format!(\"intrinsic {} has wrong type: found \\\n-                                            vector with length {}, expected length {}\",\n-                                           position,\n-                                           t_len, len));\n-                return;\n-            }\n-            let t_ty = t.simd_type(tcx);\n-            {\n-                let previous = structural_to_nominal.entry(expected).or_insert(t);\n-                if *previous != t {\n-                    tcx.sess.span_err(span,\n-                                      &format!(\"intrinsic {} has wrong type: found `{}`, \\\n-                                                but already seen this vector type as `{}`\",\n-                                               position, t, previous));\n-                    return;\n-                }\n-            }\n-            match_intrinsic_type_to_type(tcx,\n-                                         position,\n-                                         span,\n-                                         structural_to_nominal,\n-                                         inner_expected,\n-                                         t_ty)\n-        }\n-    }\n-}"}]}