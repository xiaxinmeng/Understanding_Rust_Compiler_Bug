{"sha": "a851e1e543c944b38472751d251593f3c593cc3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4NTFlMWU1NDNjOTQ0YjM4NDcyNzUxZDI1MTU5M2YzYzU5M2NjM2E=", "commit": {"author": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-06-21T14:01:35Z"}, "committer": {"name": "gaurikholkar", "email": "f2013002@goa.bits-pilani.ac.in", "date": "2017-06-29T13:37:18Z"}, "message": "Adding changes to track anonymous region in self", "tree": {"sha": "505eff8a6c176353a3b3e152e8cd78ef1cdd90ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/505eff8a6c176353a3b3e152e8cd78ef1cdd90ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a851e1e543c944b38472751d251593f3c593cc3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a851e1e543c944b38472751d251593f3c593cc3a", "html_url": "https://github.com/rust-lang/rust/commit/a851e1e543c944b38472751d251593f3c593cc3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a851e1e543c944b38472751d251593f3c593cc3a/comments", "author": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "committer": {"login": "gaurikholkar", "id": 117768111, "node_id": "U_kgDOBwT_rw", "avatar_url": "https://avatars.githubusercontent.com/u/117768111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gaurikholkar", "html_url": "https://github.com/gaurikholkar", "followers_url": "https://api.github.com/users/gaurikholkar/followers", "following_url": "https://api.github.com/users/gaurikholkar/following{/other_user}", "gists_url": "https://api.github.com/users/gaurikholkar/gists{/gist_id}", "starred_url": "https://api.github.com/users/gaurikholkar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gaurikholkar/subscriptions", "organizations_url": "https://api.github.com/users/gaurikholkar/orgs", "repos_url": "https://api.github.com/users/gaurikholkar/repos", "events_url": "https://api.github.com/users/gaurikholkar/events{/privacy}", "received_events_url": "https://api.github.com/users/gaurikholkar/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d99ffd11b28357ed989a9641ed94ea384659d51", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d99ffd11b28357ed989a9641ed94ea384659d51", "html_url": "https://github.com/rust-lang/rust/commit/2d99ffd11b28357ed989a9641ed94ea384659d51"}], "stats": {"total": 116, "additions": 93, "deletions": 23}, "files": [{"sha": "a63ae186f61d856ccd7beb93ef02ba47bd9ceb17", "filename": "src/librustc/infer/error_reporting/named_anon_conflict.rs", "status": "modified", "additions": 40, "deletions": 20, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a851e1e543c944b38472751d251593f3c593cc3a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a851e1e543c944b38472751d251593f3c593cc3a/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnamed_anon_conflict.rs?ref=a851e1e543c944b38472751d251593f3c593cc3a", "patch": "@@ -27,19 +27,21 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     // Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n     // Here, we would return the hir::Arg for y, we return the type &'a\n     // i32, which is the type of y but with the anonymous region replaced\n-    // with 'a and also the corresponding bound region.\n-    fn find_arg_with_anonymous_region(&self,\n-                                      anon_region: Region<'tcx>,\n-                                      named_region: Region<'tcx>)\n-                                      -> Option<(&hir::Arg, ty::Ty<'tcx>, ty::BoundRegion)> {\n+    // with 'a, the corresponding bound region and is_first which is true if\n+    // the hir::Arg is the first argument in the function declaration.\n+    fn find_arg_with_anonymous_region\n+        (&self,\n+         anon_region: Region<'tcx>,\n+         named_region: Region<'tcx>)\n+         -> Option<(&hir::Arg, ty::Ty<'tcx>, ty::BoundRegion, bool)> {\n \n         match *anon_region {\n             ty::ReFree(ref free_region) => {\n \n                 let id = free_region.scope;\n                 let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n                 let body_id = self.tcx.hir.maybe_body_owned_by(node_id).unwrap();\n-\n+                let mut is_first = false;\n                 let body = self.tcx.hir.body(body_id);\n                 body.arguments\n                     .iter()\n@@ -56,7 +58,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                                           r\n                                                       });\n                                     if found_anon_region {\n-                                        return Some((arg, new_arg_ty, free_region.bound_region));\n+                                        if body.arguments.iter().nth(0) == Some(&arg) {\n+                                            is_first = true;\n+                                        }\n+                                        return Some((arg,\n+                                                     new_arg_ty,\n+                                                     free_region.bound_region,\n+                                                     is_first));\n                                     } else {\n                                         None\n                                     }\n@@ -86,19 +94,19 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.\n-        let (named, (arg, new_ty, br), scope_def_id) =\n-            if self.is_named_region(sub) && self.is_suitable_anonymous_region(sup).is_some() {\n-                (sub,\n-                 self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n-                 self.is_suitable_anonymous_region(sup).unwrap())\n-            } else if self.is_named_region(sup) &&\n-                      self.is_suitable_anonymous_region(sub).is_some() {\n-                (sup,\n-                 self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n-                 self.is_suitable_anonymous_region(sub).unwrap())\n-            } else {\n-                return false; // inapplicable\n-            };\n+        let (named, (arg, new_ty, br, is_first), scope_def_id) = if\n+            self.is_named_region(sub) && self.is_suitable_anonymous_region(sup).is_some() {\n+            (sub,\n+             self.find_arg_with_anonymous_region(sup, sub).unwrap(),\n+             self.is_suitable_anonymous_region(sup).unwrap())\n+        } else if\n+            self.is_named_region(sup) && self.is_suitable_anonymous_region(sub).is_some() {\n+            (sup,\n+             self.find_arg_with_anonymous_region(sub, sup).unwrap(),\n+             self.is_suitable_anonymous_region(sub).unwrap())\n+        } else {\n+            return false; // inapplicable\n+        };\n \n         // Here, we check for the case where the anonymous region\n         // is in the return type.\n@@ -116,6 +124,18 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             _ => {}\n         }\n \n+        // Here we check for the case where anonymous region\n+        // corresponds to self and if yes, we display E0312.\n+        // FIXME(#42700) - Need to format self properly to\n+        // enable E0611 for it.\n+        if is_first &&\n+           self.tcx\n+               .opt_associated_item(scope_def_id)\n+               .map(|i| i.method_has_self_argument)\n+               .unwrap_or(false) {\n+            return false;\n+        }\n+\n         if let Some(simple_name) = arg.pat.simple_name() {\n             struct_span_err!(self.tcx.sess,\n                              span,"}, {"sha": "502871022ff6f3b06ae79886ddb5df717f9dd436", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-if-else-using-impl-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a851e1e543c944b38472751d251593f3c593cc3a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a851e1e543c944b38472751d251593f3c593cc3a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-if-else-using-impl-3.stderr?ref=a851e1e543c944b38472751d251593f3c593cc3a", "patch": "@@ -3,7 +3,7 @@ error[E0611]: explicit lifetime required in the type of `x`\n    |\n 16 |   fn foo<'a>(&'a self, x: &i32) -> &i32 {\n    |                        - consider changing the type of `x` to `&'a i32`\n-17 |    \n+17 | \n 18 |     if true { &self.field } else { x }\n    |                                    ^ lifetime `'a` required\n "}, {"sha": "471b3401827d8106050281770a56350fa5b091d4", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-return-type-is-anon.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a851e1e543c944b38472751d251593f3c593cc3a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a851e1e543c944b38472751d251593f3c593cc3a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-return-type-is-anon.stderr?ref=a851e1e543c944b38472751d251593f3c593cc3a", "patch": "@@ -8,7 +8,7 @@ note: ...the reference is valid for the anonymous lifetime #1 defined on the met\n   --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:16:3\n    |\n 16 | /   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n-17 | |    \n+17 | |\n 18 | |     x\n 19 | |\n 20 | |   }\n@@ -17,7 +17,7 @@ note: ...but the borrowed content is only valid for the lifetime 'a as defined o\n   --> $DIR/ex1-return-one-existing-name-return-type-is-anon.rs:16:3\n    |\n 16 | /   fn foo<'a>(&self, x: &'a i32) -> &i32 {\n-17 | |    \n+17 | |\n 18 | |     x\n 19 | |\n 20 | |   }"}, {"sha": "a8ce60c47b6f528ed26e096339080a584af5f600", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-self-is-anon.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a851e1e543c944b38472751d251593f3c593cc3a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a851e1e543c944b38472751d251593f3c593cc3a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.rs?ref=a851e1e543c944b38472751d251593f3c593cc3a", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo {\n+    field: i32,\n+}\n+\n+impl Foo {\n+    fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n+\n+        if true { x } else { self }\n+\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "46fc43eaf5756fa0524dca41aab65e33f554f38b", "filename": "src/test/ui/lifetime-errors/ex1-return-one-existing-name-self-is-anon.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a851e1e543c944b38472751d251593f3c593cc3a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a851e1e543c944b38472751d251593f3c593cc3a/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetime-errors%2Fex1-return-one-existing-name-self-is-anon.stderr?ref=a851e1e543c944b38472751d251593f3c593cc3a", "patch": "@@ -0,0 +1,27 @@\n+error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n+  --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:18:30\n+   |\n+18 |         if true { x } else { self }\n+   |                              ^^^^\n+   |\n+note: ...the reference is valid for the lifetime 'a as defined on the method body at 16:5...\n+  --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:16:5\n+   |\n+16 | /     fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n+17 | |\n+18 | |         if true { x } else { self }\n+19 | |\n+20 | |     }\n+   | |_____^\n+note: ...but the borrowed content is only valid for the anonymous lifetime #1 defined on the method body at 16:5\n+  --> $DIR/ex1-return-one-existing-name-self-is-anon.rs:16:5\n+   |\n+16 | /     fn foo<'a>(&self, x: &'a Foo) -> &'a Foo {\n+17 | |\n+18 | |         if true { x } else { self }\n+19 | |\n+20 | |     }\n+   | |_____^\n+\n+error: aborting due to previous error(s)\n+"}]}