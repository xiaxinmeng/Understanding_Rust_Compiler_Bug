{"sha": "6e0b0d4d7094d8d63a3c11325ae8c53c9928aab7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMGIwZDRkNzA5NGQ4ZDYzYTNjMTEzMjVhZThjNTNjOTkyOGFhYjc=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-13T15:40:51Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2019-09-13T23:44:45Z"}, "message": "Move cache into Context, avoid TLS\n\nThis doesn't move everything over as cache() is pretty annoying to\nremove fully, but it gets the ball rolling.", "tree": {"sha": "8f700af303c12d99a544a1f49e2f1fff5586e25c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f700af303c12d99a544a1f49e2f1fff5586e25c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e0b0d4d7094d8d63a3c11325ae8c53c9928aab7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e0b0d4d7094d8d63a3c11325ae8c53c9928aab7", "html_url": "https://github.com/rust-lang/rust/commit/6e0b0d4d7094d8d63a3c11325ae8c53c9928aab7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e0b0d4d7094d8d63a3c11325ae8c53c9928aab7/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f", "html_url": "https://github.com/rust-lang/rust/commit/f5ed0fd1c0175679c7f72ee0e6f8f5532f94a69f"}], "stats": {"total": 55, "additions": 26, "deletions": 29}, "files": [{"sha": "dc9e7131c89de6d576cca3f35f6699ac63b710ae", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 26, "deletions": 29, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/6e0b0d4d7094d8d63a3c11325ae8c53c9928aab7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e0b0d4d7094d8d63a3c11325ae8c53c9928aab7/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6e0b0d4d7094d8d63a3c11325ae8c53c9928aab7", "patch": "@@ -167,6 +167,7 @@ struct Context {\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     id_map: Rc<RefCell<IdMap>>,\n     pub shared: Arc<SharedContext>,\n+    pub cache: Arc<Cache>,\n }\n \n crate struct SharedContext {\n@@ -477,31 +478,31 @@ pub fn run(mut krate: clean::Crate,\n     let dst = output;\n     scx.ensure_dir(&dst)?;\n     krate = sources::render(&dst, &mut scx, krate)?;\n+    let (new_crate, index, cache) = Cache::from_krate(\n+        renderinfo,\n+        &extern_html_root_urls,\n+        &dst,\n+        krate,\n+    );\n+    krate = new_crate;\n+    let cache = Arc::new(cache);\n     let mut cx = Context {\n         current: Vec::new(),\n         dst,\n         render_redirect_pages: false,\n         id_map: Rc::new(RefCell::new(id_map)),\n         shared: Arc::new(scx),\n+        cache: cache.clone(),\n     };\n \n-    let (new_crate, index, cache) = Cache::from_krate(\n-        renderinfo,\n-        &extern_html_root_urls,\n-        &cx.dst,\n-        krate,\n-    );\n-    krate = new_crate;\n-\n     // Freeze the cache now that the index has been built. Put an Arc into TLS\n     // for future parallelization opportunities\n-    let cache = Arc::new(cache);\n     CACHE_KEY.with(|v| *v.borrow_mut() = cache.clone());\n     CURRENT_DEPTH.with(|s| s.set(0));\n \n     // Write shared runs within a flock; disable thread dispatching of IO temporarily.\n     Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(true);\n-    write_shared(&cx, &krate, &*cache, index, &md_opts, diag)?;\n+    write_shared(&cx, &krate, index, &md_opts, diag)?;\n     Arc::get_mut(&mut cx.shared).unwrap().fs.set_sync_only(false);\n \n     // And finally render the whole crate's documentation\n@@ -519,7 +520,6 @@ pub fn run(mut krate: clean::Crate,\n fn write_shared(\n     cx: &Context,\n     krate: &clean::Crate,\n-    cache: &Cache,\n     search_index: String,\n     options: &RenderOptions,\n     diag: &errors::Handler,\n@@ -750,7 +750,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n     {\n         let (mut all_aliases, _, _) = try_err!(collect(&dst, &krate.name, \"ALIASES\", false), &dst);\n         let mut output = String::with_capacity(100);\n-        for (alias, items) in &cache.aliases {\n+        for (alias, items) in &cx.cache.aliases {\n             if items.is_empty() {\n                 continue\n             }\n@@ -920,17 +920,17 @@ themePicker.onblur = handleThemeButtonsBlur;\n \n     // Update the list of all implementors for traits\n     let dst = cx.dst.join(\"implementors\");\n-    for (&did, imps) in &cache.implementors {\n+    for (&did, imps) in &cx.cache.implementors {\n         // Private modules can leak through to this phase of rustdoc, which\n         // could contain implementations for otherwise private types. In some\n         // rare cases we could find an implementation for an item which wasn't\n         // indexed, so we just skip this step in that case.\n         //\n         // FIXME: this is a vague explanation for why this can't be a `get`, in\n         //        theory it should be...\n-        let &(ref remote_path, remote_item_type) = match cache.paths.get(&did) {\n+        let &(ref remote_path, remote_item_type) = match cx.cache.paths.get(&did) {\n             Some(p) => p,\n-            None => match cache.external_paths.get(&did) {\n+            None => match cx.cache.external_paths.get(&did) {\n                 Some(p) => p,\n                 None => continue,\n             }\n@@ -958,7 +958,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n         // Only create a js file if we have impls to add to it. If the trait is\n         // documented locally though we always create the file to avoid dead\n         // links.\n-        if !have_impls && !cache.paths.contains_key(&did) {\n+        if !have_impls && !cx.cache.paths.contains_key(&did) {\n             continue;\n         }\n \n@@ -1309,7 +1309,7 @@ impl Context {\n             extra_scripts: &[],\n             static_extra_scripts: &[],\n         };\n-        let sidebar = if let Some(ref version) = cache().crate_version {\n+        let sidebar = if let Some(ref version) = self.cache.crate_version {\n             format!(\"<p class='location'>Crate {}</p>\\\n                      <div class='block version'>\\\n                          <p>Version {}</p>\\\n@@ -1399,7 +1399,7 @@ impl Context {\n                            &self.shared.themes)\n         } else {\n             let mut url = self.root_path();\n-            if let Some(&(ref names, ty)) = cache().paths.get(&it.def_id) {\n+            if let Some(&(ref names, ty)) = self.cache.paths.get(&it.def_id) {\n                 for name in &names[..names.len() - 1] {\n                     url.push_str(name);\n                     url.push_str(\"/\");\n@@ -1549,7 +1549,6 @@ impl Context {\n     fn src_href(&self, item: &clean::Item) -> Option<String> {\n         let mut root = self.root_path();\n \n-        let cache = cache();\n         let mut path = String::new();\n \n         // We can safely ignore macros from other libraries\n@@ -1565,7 +1564,7 @@ impl Context {\n                 return None;\n             }\n         } else {\n-            let (krate, src_root) = match *cache.extern_locations.get(&item.def_id.krate)? {\n+            let (krate, src_root) = match *self.cache.extern_locations.get(&item.def_id.krate)? {\n                 (ref name, ref src, Local) => (name, src),\n                 (ref name, ref src, Remote(ref s)) => {\n                     root = s.to_string();\n@@ -2475,11 +2474,9 @@ fn item_trait(\n     // If there are methods directly on this trait object, render them here.\n     render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All);\n \n-    let cache = cache();\n-\n     let mut synthetic_types = Vec::new();\n \n-    if let Some(implementors) = cache.implementors.get(&it.def_id) {\n+    if let Some(implementors) = cx.cache.implementors.get(&it.def_id) {\n         // The DefId is for the first Type found with that name. The bool is\n         // if any Types with the same name but different DefId have been found.\n         let mut implementor_dups: FxHashMap<&str, (DefId, bool)> = FxHashMap::default();\n@@ -2502,7 +2499,7 @@ fn item_trait(\n \n         let (local, foreign) = implementors.iter()\n             .partition::<Vec<_>, _>(|i| i.inner_impl().for_.def_id()\n-                                         .map_or(true, |d| cache.paths.contains_key(&d)));\n+                                         .map_or(true, |d| cx.cache.paths.contains_key(&d)));\n \n \n         let (mut synthetic, mut concrete): (Vec<&&Impl>, Vec<&&Impl>) = local.iter()\n@@ -2567,7 +2564,7 @@ fn item_trait(\n            path = if it.def_id.is_local() {\n                cx.current.join(\"/\")\n            } else {\n-               let (ref path, _) = cache.external_paths[&it.def_id];\n+               let (ref path, _) = cx.cache.external_paths[&it.def_id];\n                path[..path.len() - 1].join(\"/\")\n            },\n            ty = it.type_(),\n@@ -3144,7 +3141,7 @@ fn render_assoc_items(w: &mut Buffer,\n                       containing_item: &clean::Item,\n                       it: DefId,\n                       what: AssocItemRender<'_>) {\n-    let c = cache();\n+    let c = &cx.cache;\n     let v = match c.impls.get(&it) {\n         Some(v) => v,\n         None => return,\n@@ -3250,7 +3247,7 @@ fn render_deref_methods(w: &mut Buffer, cx: &Context, impl_: &Impl,\n         render_assoc_items(w, cx, container_item, did, what)\n     } else {\n         if let Some(prim) = target.primitive_type() {\n-            if let Some(&did) = cache().primitive_locations.get(&prim) {\n+            if let Some(&did) = cx.cache.primitive_locations.get(&prim) {\n                 render_assoc_items(w, cx, container_item, did, what);\n             }\n         }\n@@ -3500,7 +3497,7 @@ fn render_impl(w: &mut Buffer, cx: &Context, i: &Impl, link: AssocItemLink<'_>,\n         }\n     }\n \n-    let traits = &cache().traits;\n+    let traits = &cx.cache.traits;\n     let trait_ = i.trait_did().map(|did| &traits[&did]);\n \n     write!(w, \"<div class='impl-items'>\");\n@@ -3642,7 +3639,7 @@ fn print_sidebar(cx: &Context, it: &clean::Item, buffer: &mut Buffer) {\n     }\n \n     if it.is_crate() {\n-        if let Some(ref version) = cache().crate_version {\n+        if let Some(ref version) = cx.cache.crate_version {\n             write!(buffer,\n                     \"<div class='block version'>\\\n                     <p>Version {}</p>\\"}]}