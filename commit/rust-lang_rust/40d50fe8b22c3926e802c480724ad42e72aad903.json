{"sha": "40d50fe8b22c3926e802c480724ad42e72aad903", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwZDUwZmU4YjIyYzM5MjZlODAyYzQ4MDcyNGFkNDJlNzJhYWQ5MDM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-07T11:58:07Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-03-07T11:58:07Z"}, "message": "Don't lint `nan_cmp` and `zero_ptr` in constants", "tree": {"sha": "4ea752a7fa4da840f57f457e83cc5d9572b99421", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ea752a7fa4da840f57f457e83cc5d9572b99421"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40d50fe8b22c3926e802c480724ad42e72aad903", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40d50fe8b22c3926e802c480724ad42e72aad903", "html_url": "https://github.com/rust-lang/rust/commit/40d50fe8b22c3926e802c480724ad42e72aad903", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40d50fe8b22c3926e802c480724ad42e72aad903/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5fd3c7f94add151ccf1155658c3074a2985bbf6", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5fd3c7f94add151ccf1155658c3074a2985bbf6", "html_url": "https://github.com/rust-lang/rust/commit/e5fd3c7f94add151ccf1155658c3074a2985bbf6"}], "stats": {"total": 190, "additions": 110, "deletions": 80}, "files": [{"sha": "881d210a28d11f44417a3f959f423a92e335e70e", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40d50fe8b22c3926e802c480724ad42e72aad903/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d50fe8b22c3926e802c480724ad42e72aad903/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=40d50fe8b22c3926e802c480724ad42e72aad903", "patch": "@@ -445,14 +445,14 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         misc::REDUNDANT_PATTERN,\n         misc::SHORT_CIRCUIT_STATEMENT,\n         misc::TOPLEVEL_REF_ARG,\n+        misc::ZERO_PTR,\n         misc_early::BUILTIN_TYPE_SHADOW,\n         misc_early::DOUBLE_NEG,\n         misc_early::DUPLICATE_UNDERSCORE_ARGUMENT,\n         misc_early::MIXED_CASE_HEX_LITERALS,\n         misc_early::REDUNDANT_CLOSURE_CALL,\n         misc_early::UNNEEDED_FIELD_PATTERN,\n         misc_early::ZERO_PREFIXED_LITERAL,\n-        misc_early::ZERO_PTR,\n         mut_reference::UNNECESSARY_MUT_PASSED,\n         mutex_atomic::MUTEX_ATOMIC,\n         needless_bool::BOOL_COMPARISON,"}, {"sha": "885d10d2fd98d3e8f2d66206e2a4b7a362667163", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 85, "deletions": 40, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/40d50fe8b22c3926e802c480724ad42e72aad903/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d50fe8b22c3926e802c480724ad42e72aad903/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=40d50fe8b22c3926e802c480724ad42e72aad903", "patch": "@@ -8,8 +8,9 @@ use rustc_const_eval::ConstContext;\n use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n use utils::{get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path, snippet,\n-            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment, iter_input_pats};\n+            span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment, iter_input_pats, in_constant};\n use utils::sugg::Sugg;\n+use syntax::ast::LitKind;\n \n /// **What it does:** Checks for function arguments and let bindings denoted as `ref`.\n ///\n@@ -172,6 +173,24 @@ declare_lint! {\n     \"using a short circuit boolean condition as a statement\"\n }\n \n+/// **What it does:** Catch casts from `0` to some pointer type\n+///\n+/// **Why is this bad?** This generally means `null` and is better expressed as\n+/// {`std`, `core`}`::ptr::`{`null`, `null_mut`}.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+///\n+/// ```rust\n+/// 0 as *const u32\n+/// ```\n+declare_lint! {\n+    pub ZERO_PTR,\n+    Warn,\n+    \"using 0 as *{const, mut} T\"\n+}\n+\n #[derive(Copy, Clone)]\n pub struct Pass;\n \n@@ -184,7 +203,8 @@ impl LintPass for Pass {\n                     MODULO_ONE,\n                     REDUNDANT_PATTERN,\n                     USED_UNDERSCORE_BINDING,\n-                    SHORT_CIRCUIT_STATEMENT)\n+                    SHORT_CIRCUIT_STATEMENT,\n+                    ZERO_PTR)\n     }\n }\n \n@@ -263,41 +283,48 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n-            let op = cmp.node;\n-            if op.is_comparison() {\n-                if let ExprPath(QPath::Resolved(_, ref path)) = left.node {\n-                    check_nan(cx, path, expr.span);\n-                }\n-                if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n-                    check_nan(cx, path, expr.span);\n-                }\n-                check_to_owned(cx, left, right, true, cmp.span);\n-                check_to_owned(cx, right, left, false, cmp.span)\n-            }\n-            if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n-                if is_allowed(cx, left) || is_allowed(cx, right) {\n-                    return;\n+        match expr.node {\n+            ExprCast(ref e, ref ty) => {\n+                check_cast(cx, expr.span, e, ty);\n+                return;\n+            },\n+            ExprBinary(ref cmp, ref left, ref right) => {\n+                let op = cmp.node;\n+                if op.is_comparison() {\n+                    if let ExprPath(QPath::Resolved(_, ref path)) = left.node {\n+                        check_nan(cx, path, expr);\n+                    }\n+                    if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n+                        check_nan(cx, path, expr);\n+                    }\n+                    check_to_owned(cx, left, right, true, cmp.span);\n+                    check_to_owned(cx, right, left, false, cmp.span)\n                 }\n-                if let Some(name) = get_item_name(cx, expr) {\n-                    let name = &*name.as_str();\n-                    if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n-                       name.ends_with(\"_eq\") {\n+                if (op == BiEq || op == BiNe) && (is_float(cx, left) || is_float(cx, right)) {\n+                    if is_allowed(cx, left) || is_allowed(cx, right) {\n                         return;\n                     }\n+                    if let Some(name) = get_item_name(cx, expr) {\n+                        let name = &*name.as_str();\n+                        if name == \"eq\" || name == \"ne\" || name == \"is_nan\" || name.starts_with(\"eq_\") ||\n+                        name.ends_with(\"_eq\") {\n+                            return;\n+                        }\n+                    }\n+                    span_lint_and_then(cx, FLOAT_CMP, expr.span, \"strict comparison of f32 or f64\", |db| {\n+                        let lhs = Sugg::hir(cx, left, \"..\");\n+                        let rhs = Sugg::hir(cx, right, \"..\");\n+\n+                        db.span_suggestion(expr.span,\n+                                        \"consider comparing them within some error\",\n+                                        format!(\"({}).abs() < error\", lhs - rhs));\n+                        db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n+                    });\n+                } else if op == BiRem && is_integer_literal(right, 1) {\n+                    span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n                 }\n-                span_lint_and_then(cx, FLOAT_CMP, expr.span, \"strict comparison of f32 or f64\", |db| {\n-                    let lhs = Sugg::hir(cx, left, \"..\");\n-                    let rhs = Sugg::hir(cx, right, \"..\");\n-\n-                    db.span_suggestion(expr.span,\n-                                       \"consider comparing them within some error\",\n-                                       format!(\"({}).abs() < error\", lhs - rhs));\n-                    db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n-                });\n-            } else if op == BiRem && is_integer_literal(right, 1) {\n-                span_lint(cx, MODULO_ONE, expr.span, \"any number modulo 1 will be 0\");\n-            }\n+            },\n+            _ => {}\n         }\n         if in_attributes_expansion(cx, expr) {\n             // Don't lint things expanded by #[derive(...)], etc\n@@ -349,13 +376,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n }\n \n-fn check_nan(cx: &LateContext, path: &Path, span: Span) {\n-    path.segments.last().map(|seg| if &*seg.name.as_str() == \"NAN\" {\n-        span_lint(cx,\n-                  CMP_NAN,\n-                  span,\n-                  \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n-    });\n+fn check_nan(cx: &LateContext, path: &Path, expr: &Expr) {\n+    if !in_constant(cx, expr.id) {\n+        path.segments.last().map(|seg| if &*seg.name.as_str() == \"NAN\" {\n+            span_lint(cx,\n+                    CMP_NAN,\n+                    expr.span,\n+                    \"doomed comparison with NAN, use `std::{f32,f64}::is_nan()` instead\");\n+        });\n+    }\n }\n \n fn is_allowed(cx: &LateContext, expr: &Expr) -> bool {\n@@ -489,3 +518,19 @@ fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n         _ => false,\n     }\n }\n+\n+fn check_cast(cx: &LateContext, span: Span, e: &Expr, ty: &Ty) {\n+    if_let_chain! {[\n+        let TyPtr(MutTy { mutbl, .. }) = ty.node,\n+        let ExprLit(ref lit) = e.node,\n+        let LitKind::Int(value, ..) = lit.node,\n+        value == 0,\n+        !in_constant(cx, e.id)\n+    ], {\n+        let msg = match mutbl {\n+            Mutability::MutMutable => \"`0 as *mut _` detected. Consider using `ptr::null_mut()`\",\n+            Mutability::MutImmutable => \"`0 as *const _` detected. Consider using `ptr::null()`\",\n+        };\n+        span_lint(cx, ZERO_PTR, span, msg);\n+    }}\n+}"}, {"sha": "57c0c637f4111a41b727986fdf58d812c96b1598", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/40d50fe8b22c3926e802c480724ad42e72aad903/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d50fe8b22c3926e802c480724ad42e72aad903/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=40d50fe8b22c3926e802c480724ad42e72aad903", "patch": "@@ -162,24 +162,6 @@ declare_lint! {\n     \"shadowing a builtin type\"\n }\n \n-/// **What it does:** Catch casts from `0` to some pointer type\n-///\n-/// **Why is this bad?** This generally means `null` and is better expressed as\n-/// {`std`, `core`}`::ptr::`{`null`, `null_mut`}.\n-///\n-/// **Known problems:** None.\n-///\n-/// **Example:**\n-///\n-/// ```rust\n-/// 0 as *const u32\n-/// ```\n-declare_lint! {\n-    pub ZERO_PTR,\n-    Warn,\n-    \"using 0 as *{const, mut} T\"\n-}\n-\n #[derive(Copy, Clone)]\n pub struct MiscEarly;\n \n@@ -192,8 +174,7 @@ impl LintPass for MiscEarly {\n                     MIXED_CASE_HEX_LITERALS,\n                     UNSEPARATED_LITERAL_SUFFIX,\n                     ZERO_PREFIXED_LITERAL,\n-                    BUILTIN_TYPE_SHADOW,\n-                    ZERO_PTR)\n+                    BUILTIN_TYPE_SHADOW)\n     }\n }\n \n@@ -381,9 +362,6 @@ impl EarlyLintPass for MiscEarly {\n                     }\n                 }}\n             },\n-            ExprKind::Cast(ref e, ref ty) => {\n-                check_cast(cx, expr.span, e, ty);\n-            },\n             _ => (),\n         }\n     }\n@@ -412,18 +390,3 @@ impl EarlyLintPass for MiscEarly {\n         }\n     }\n }\n-\n-fn check_cast(cx: &EarlyContext, span: Span, e: &Expr, ty: &Ty) {\n-    if_let_chain! {[\n-        let TyKind::Ptr(MutTy { mutbl, .. }) = ty.node,\n-        let ExprKind::Lit(ref lit) = e.node,\n-        let LitKind::Int(value, ..) = lit.node,\n-        value == 0\n-    ], {\n-        let msg = match mutbl {\n-            Mutability::Mutable => \"`0 as *mut _` detected. Consider using `ptr::null_mut()`\",\n-            Mutability::Immutable => \"`0 as *const _` detected. Consider using `ptr::null()`\",\n-        };\n-        span_lint(cx, ZERO_PTR, span, msg);\n-    }}\n-}"}, {"sha": "58b416b832564e56c1644a6e48c614bb03f39477", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40d50fe8b22c3926e802c480724ad42e72aad903/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d50fe8b22c3926e802c480724ad42e72aad903/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=40d50fe8b22c3926e802c480724ad42e72aad903", "patch": "@@ -10,6 +10,7 @@ use rustc::traits;\n use rustc::ty::subst::Subst;\n use rustc::ty;\n use rustc::ty::layout::TargetDataLayout;\n+use rustc::mir::transform::MirSource;\n use rustc_errors;\n use std::borrow::Cow;\n use std::env;\n@@ -98,6 +99,17 @@ pub mod higher;\n pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.expn_id != lhs.expn_id\n }\n+\n+pub fn in_constant(cx: &LateContext, id: NodeId) -> bool {\n+    let parent_id = cx.tcx.hir.get_parent(id);\n+    match MirSource::from_node(cx.tcx, parent_id) {\n+        MirSource::Fn(_) => false,\n+        MirSource::Const(_) |\n+        MirSource::Static(..) |\n+        MirSource::Promoted(..) => true,\n+    }\n+}\n+\n /// Returns true if this `expn_info` was expanded by any macro.\n pub fn in_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n     cx.sess().codemap().with_expn_info(span.expn_id, |info| {"}, {"sha": "9f63a6b2d73223f2fc78e1e4a92c88ec445b5ce1", "filename": "tests/run-pass/mut_mut_macro.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/40d50fe8b22c3926e802c480724ad42e72aad903/tests%2Frun-pass%2Fmut_mut_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40d50fe8b22c3926e802c480724ad42e72aad903/tests%2Frun-pass%2Fmut_mut_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmut_mut_macro.rs?ref=40d50fe8b22c3926e802c480724ad42e72aad903", "patch": "@@ -1,12 +1,20 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n+#![deny(mut_mut, zero_ptr, cmp_nan)]\n+#![allow(dead_code)]\n \n #[macro_use]\n extern crate lazy_static;\n \n use std::collections::HashMap;\n \n-#[deny(mut_mut)]\n+// ensure that we don't suggest `is_nan` and `is_null` inside constants\n+// FIXME: once const fn is stable, suggest these functions again in constants\n+const BAA: *const i32 = 0 as *const i32;\n+static mut BAR: *const i32 = BAA;\n+static mut FOO: *const i32 = 0 as *const i32;\n+static mut BUH: bool = 42.0 < std::f32::NAN;\n+\n #[allow(unused_variables, unused_mut)]\n fn main() {\n     lazy_static! {\n@@ -19,4 +27,6 @@ fn main() {\n         static ref MUT_COUNT : usize = MUT_MAP.len();\n     }\n     assert!(*MUT_COUNT == 1);\n+    // FIXME: don't lint in array length, requires `check_body`\n+    //let _ = [\"\"; (42.0 < std::f32::NAN) as usize];\n }"}]}