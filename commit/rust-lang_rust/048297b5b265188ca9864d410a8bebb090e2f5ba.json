{"sha": "048297b5b265188ca9864d410a8bebb090e2f5ba", "node_id": "C_kwDOAAsO6NoAKDA0ODI5N2I1YjI2NTE4OGNhOTg2NGQ0MTBhOGJlYmIwOTBlMmY1YmE", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-21T14:43:41Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-21T14:43:41Z"}, "message": "`ptr_arg` cleanup", "tree": {"sha": "16b53a3876eff90b153750b387b9e4bb1bf93b8e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16b53a3876eff90b153750b387b9e4bb1bf93b8e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/048297b5b265188ca9864d410a8bebb090e2f5ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/048297b5b265188ca9864d410a8bebb090e2f5ba", "html_url": "https://github.com/rust-lang/rust/commit/048297b5b265188ca9864d410a8bebb090e2f5ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/048297b5b265188ca9864d410a8bebb090e2f5ba/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ed86bf82210042a894620e1537e86a7fe2ce5b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ed86bf82210042a894620e1537e86a7fe2ce5b6", "html_url": "https://github.com/rust-lang/rust/commit/7ed86bf82210042a894620e1537e86a7fe2ce5b6"}], "stats": {"total": 174, "additions": 89, "deletions": 85}, "files": [{"sha": "c2ade4f0db764c1db07a630ae6e49c906df4df3a", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 83, "deletions": 79, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/048297b5b265188ca9864d410a8bebb090e2f5ba/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048297b5b265188ca9864d410a8bebb090e2f5ba/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=048297b5b265188ca9864d410a8bebb090e2f5ba", "patch": "@@ -385,87 +385,91 @@ fn check_fn_args<'cx, 'tcx: 'cx>(\n     hir_tys: &'tcx [hir::Ty<'_>],\n     params: &'tcx [Param<'_>],\n ) -> impl Iterator<Item = PtrArg<'tcx>> + 'cx {\n-    tys.iter().enumerate().filter_map(|(i, ty)| {\n-        if_chain! {\n-            if let ty::Ref(_, ty, mutability) = *ty.kind();\n-            if let ty::Adt(adt, substs) = *ty.kind();\n-\n-            let hir_ty = &hir_tys[i];\n-            if let TyKind::Rptr(lt, ref ty) = hir_ty.kind;\n-            if let TyKind::Path(QPath::Resolved(None, path)) = ty.ty.kind;\n-\n-            if let [.., name] = path.segments;\n-            if cx.tcx.item_name(adt.did) == name.ident.name;\n-\n-            if !is_lint_allowed(cx, PTR_ARG, hir_ty.hir_id);\n-            if params.get(i).map_or(true, |p| !is_lint_allowed(cx, PTR_ARG, p.hir_id));\n-\n-            then {\n-                let (method_renames, deref_ty, deref_impl_id) = match cx.tcx.get_diagnostic_name(adt.did) {\n-                    Some(sym::Vec) => (\n-                        [(\"clone\", \".to_owned()\")].as_slice(),\n-                        DerefTy::Slice(\n-                            name.args\n-                                .and_then(|args| args.args.first())\n-                                .and_then(|arg| if let GenericArg::Type(ty) = arg {\n-                                    Some(ty.span)\n-                                } else {\n-                                    None\n-                                }),\n-                            substs.type_at(0),\n+    tys.iter()\n+        .zip(hir_tys.iter())\n+        .enumerate()\n+        .filter_map(|(i, (ty, hir_ty))| {\n+            if_chain! {\n+                if let ty::Ref(_, ty, mutability) = *ty.kind();\n+                if let ty::Adt(adt, substs) = *ty.kind();\n+\n+                if let TyKind::Rptr(lt, ref ty) = hir_ty.kind;\n+                if let TyKind::Path(QPath::Resolved(None, path)) = ty.ty.kind;\n+\n+                // Check that the name as typed matches the actual name of the type.\n+                // e.g. `fn foo(_: &Foo)` shouldn't trigger the lint when `Foo` is an alias for `Vec`\n+                if let [.., name] = path.segments;\n+                if cx.tcx.item_name(adt.did) == name.ident.name;\n+\n+                if !is_lint_allowed(cx, PTR_ARG, hir_ty.hir_id);\n+                if params.get(i).map_or(true, |p| !is_lint_allowed(cx, PTR_ARG, p.hir_id));\n+\n+                then {\n+                    let (method_renames, deref_ty, deref_impl_id) = match cx.tcx.get_diagnostic_name(adt.did) {\n+                        Some(sym::Vec) => (\n+                            [(\"clone\", \".to_owned()\")].as_slice(),\n+                            DerefTy::Slice(\n+                                name.args\n+                                    .and_then(|args| args.args.first())\n+                                    .and_then(|arg| if let GenericArg::Type(ty) = arg {\n+                                        Some(ty.span)\n+                                    } else {\n+                                        None\n+                                    }),\n+                                substs.type_at(0),\n+                            ),\n+                            cx.tcx.lang_items().slice_impl()\n                         ),\n-                        cx.tcx.lang_items().slice_impl()\n-                    ),\n-                    Some(sym::String) => (\n-                        [(\"clone\", \".to_owned()\"), (\"as_str\", \"\")].as_slice(),\n-                        DerefTy::Str,\n-                        cx.tcx.lang_items().str_impl()\n-                    ),\n-                    Some(sym::PathBuf) => (\n-                        [(\"clone\", \".to_path_buf()\"), (\"as_path\", \"\")].as_slice(),\n-                        DerefTy::Path,\n-                        None,\n-                    ),\n-                    Some(sym::Cow) => {\n-                        let ty_name = name.args\n-                            .and_then(|args| {\n-                                args.args.iter().find_map(|a| match a {\n-                                    GenericArg::Type(x) => Some(x),\n-                                    _ => None,\n+                        Some(sym::String) => (\n+                            [(\"clone\", \".to_owned()\"), (\"as_str\", \"\")].as_slice(),\n+                            DerefTy::Str,\n+                            cx.tcx.lang_items().str_impl()\n+                        ),\n+                        Some(sym::PathBuf) => (\n+                            [(\"clone\", \".to_path_buf()\"), (\"as_path\", \"\")].as_slice(),\n+                            DerefTy::Path,\n+                            None,\n+                        ),\n+                        Some(sym::Cow) => {\n+                            let ty_name = name.args\n+                                .and_then(|args| {\n+                                    args.args.iter().find_map(|a| match a {\n+                                        GenericArg::Type(x) => Some(x),\n+                                        _ => None,\n+                                    })\n                                 })\n-                            })\n-                            .and_then(|arg| snippet_opt(cx, arg.span))\n-                            .unwrap_or_else(|| substs.type_at(1).to_string());\n-                        span_lint_and_sugg(\n-                            cx,\n-                            PTR_ARG,\n-                            hir_ty.span,\n-                            \"using a reference to `Cow` is not recommended\",\n-                            \"change this to\",\n-                            format!(\"&{}{}\", mutability.prefix_str(), ty_name),\n-                            Applicability::Unspecified,\n-                        );\n-                        return None;\n-                    },\n-                    _ => return None,\n-                };\n-                return Some(PtrArg {\n-                    idx: i,\n-                    span: hir_ty.span,\n-                    ty_did: adt.did,\n-                    ty_name: name.ident.name,\n-                    method_renames,\n-                    ref_prefix: RefPrefix {\n-                        lt: lt.name,\n-                        mutability,\n-                    },\n-                    deref_ty,\n-                    deref_assoc_items: deref_impl_id.map(|id| (id, cx.tcx.associated_items(id))),\n-                });\n+                                .and_then(|arg| snippet_opt(cx, arg.span))\n+                                .unwrap_or_else(|| substs.type_at(1).to_string());\n+                            span_lint_and_sugg(\n+                                cx,\n+                                PTR_ARG,\n+                                hir_ty.span,\n+                                \"using a reference to `Cow` is not recommended\",\n+                                \"change this to\",\n+                                format!(\"&{}{}\", mutability.prefix_str(), ty_name),\n+                                Applicability::Unspecified,\n+                            );\n+                            return None;\n+                        },\n+                        _ => return None,\n+                    };\n+                    return Some(PtrArg {\n+                        idx: i,\n+                        span: hir_ty.span,\n+                        ty_did: adt.did,\n+                        ty_name: name.ident.name,\n+                        method_renames,\n+                        ref_prefix: RefPrefix {\n+                            lt: lt.name,\n+                            mutability,\n+                        },\n+                        deref_ty,\n+                        deref_assoc_items: deref_impl_id.map(|id| (id, cx.tcx.associated_items(id))),\n+                    });\n+                }\n             }\n-        }\n-        None\n-    })\n+            None\n+        })\n }\n \n fn check_mut_from_ref(cx: &LateContext<'_>, decl: &FnDecl<'_>) {\n@@ -504,7 +508,7 @@ fn check_mut_from_ref(cx: &LateContext<'_>, decl: &FnDecl<'_>) {\n fn check_ptr_arg_usage<'tcx>(cx: &LateContext<'tcx>, body: &'tcx Body<'_>, args: &[PtrArg<'tcx>]) -> Vec<PtrArgResult> {\n     struct V<'cx, 'tcx> {\n         cx: &'cx LateContext<'tcx>,\n-        /// Map from a local id to which argument it cam from (index into `Self::args` and\n+        /// Map from a local id to which argument it came from (index into `Self::args` and\n         /// `Self::results`)\n         bindings: HirIdMap<usize>,\n         /// The arguments being checked."}, {"sha": "ed72423780821792ae61ea24d6fb322547465e16", "filename": "tests/ui/ptr_arg.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/048297b5b265188ca9864d410a8bebb090e2f5ba/tests%2Fui%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048297b5b265188ca9864d410a8bebb090e2f5ba/tests%2Fui%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fptr_arg.rs?ref=048297b5b265188ca9864d410a8bebb090e2f5ba", "patch": "@@ -169,13 +169,13 @@ fn fn_requires_vec(v: &Vec<u32>) -> bool {\n     vec_contains(v)\n }\n \n-// fn impl_fn_requires_vec(v: &Vec<u32>, f: impl Fn(&Vec<u32>)) {\n-//     f(v);\n-// }\n+fn impl_fn_requires_vec(v: &Vec<u32>, f: impl Fn(&Vec<u32>)) {\n+    f(v);\n+}\n \n-// fn dyn_fn_requires_vec(v: &Vec<u32>, f: &dyn Fn(&Vec<u32>)) {\n-//     f(v);\n-// }\n+fn dyn_fn_requires_vec(v: &Vec<u32>, f: &dyn Fn(&Vec<u32>)) {\n+    f(v);\n+}\n \n // No error for types behind an alias (#7699)\n type A = Vec<u8>;"}]}