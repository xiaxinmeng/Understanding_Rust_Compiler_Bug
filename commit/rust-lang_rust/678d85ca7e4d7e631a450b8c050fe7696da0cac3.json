{"sha": "678d85ca7e4d7e631a450b8c050fe7696da0cac3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3OGQ4NWNhN2U0ZDdlNjMxYTQ1MGI4YzA1MGZlNzY5NmRhMGNhYzM=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-04-29T18:28:43Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:03:46Z"}, "message": "Implement struct ctor application", "tree": {"sha": "f013655d9c581959ebd5a2db83d6fea91005fdb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f013655d9c581959ebd5a2db83d6fea91005fdb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/678d85ca7e4d7e631a450b8c050fe7696da0cac3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/678d85ca7e4d7e631a450b8c050fe7696da0cac3", "html_url": "https://github.com/rust-lang/rust/commit/678d85ca7e4d7e631a450b8c050fe7696da0cac3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/678d85ca7e4d7e631a450b8c050fe7696da0cac3/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "062c7953a12bf849db641d14d8d26af47ddca79e", "url": "https://api.github.com/repos/rust-lang/rust/commits/062c7953a12bf849db641d14d8d26af47ddca79e", "html_url": "https://github.com/rust-lang/rust/commit/062c7953a12bf849db641d14d8d26af47ddca79e"}], "stats": {"total": 190, "additions": 121, "deletions": 69}, "files": [{"sha": "4cdb5913deb5affac5c188ddaa1876a7a2b535ee", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/678d85ca7e4d7e631a450b8c050fe7696da0cac3/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/678d85ca7e4d7e631a450b8c050fe7696da0cac3/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=678d85ca7e4d7e631a450b8c050fe7696da0cac3", "patch": "@@ -166,7 +166,7 @@ impl Path {\n     }\n \n     /// Converts a known mod path to `Path`.\n-    pub(crate) fn from_known_path(\n+    pub fn from_known_path(\n         path: ModPath,\n         generic_args: Vec<Option<Interned<GenericArgs>>>,\n     ) -> Path {"}, {"sha": "a62f0fa4f63781f61faf6ed46a3360592da1c26b", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/678d85ca7e4d7e631a450b8c050fe7696da0cac3/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/678d85ca7e4d7e631a450b8c050fe7696da0cac3/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=678d85ca7e4d7e631a450b8c050fe7696da0cac3", "patch": "@@ -382,7 +382,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n \n         let pattern_arena = usefulness::PatternArena::clone_from(&body.pats);\n         let cx = usefulness::MatchCheckCtx {\n-            krate: self.owner.module(db.upcast()).krate(),\n+            module: self.owner.module(db.upcast()),\n             match_expr,\n             body,\n             infer: &infer,"}, {"sha": "4dcbd7f9fedf13d3d52c3e3933faa8626bf1638c", "filename": "crates/hir_ty/src/diagnostics/pattern.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/678d85ca7e4d7e631a450b8c050fe7696da0cac3/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/678d85ca7e4d7e631a450b8c050fe7696da0cac3/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs?ref=678d85ca7e4d7e631a450b8c050fe7696da0cac3", "patch": "@@ -11,24 +11,67 @@ mod tests {\n     use super::*;\n \n     #[test]\n-    fn unit_exhaustive() {\n+    fn unit() {\n         check_diagnostics(\n             r#\"\n fn main() {\n-    match ()   { ()   => {} }\n-    match ()   { _    => {} }\n+    match () { () => {} }\n+    match () {  _ => {} }\n+    match () {          }\n+        //^^ Missing match arm\n }\n \"#,\n         );\n     }\n \n     #[test]\n-    fn unit_non_exhaustive() {\n+    fn tuple_of_units() {\n         check_diagnostics(\n             r#\"\n fn main() {\n-    match ()   {            }\n-        //^^ Missing match arm\n+    match ((), ()) { ((), ()) => {} }\n+    match ((), ()) {  ((), _) => {} }\n+    match ((), ()) {   (_, _) => {} }\n+    match ((), ()) {        _ => {} }\n+    match ((), ()) {                }\n+        //^^^^^^^^ Missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn tuple_with_ellipsis() {\n+        // TODO: test non-exhaustive match with ellipsis in the middle\n+        // of a pattern, check reported witness\n+        check_diagnostics(\n+            r#\"\n+struct A; struct B;\n+fn main(v: (A, (), B)) {\n+    match v { (A, ..)    => {} }\n+    match v { (.., B)    => {} }\n+    match v { (A, .., B) => {} }\n+    match v { (..)       => {} }\n+    match v {                  }\n+        //^ Missing match arm\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn strukt() {\n+        check_diagnostics(\n+            r#\"\n+struct A; struct B;\n+struct S { a: A, b: B}\n+fn main(v: S) {\n+    match v { S { a, b }       => {} }\n+    match v { S { a: _, b: _ } => {} }\n+    match v { S { .. }         => {} }\n+    match v { _                => {} }\n+    match v {                        }\n+        //^ Missing match arm\n }\n \"#,\n         );"}, {"sha": "7bd02a502091a135d5c856cef51ae4e6d81f873e", "filename": "crates/hir_ty/src/diagnostics/pattern/deconstruct_pat.rs", "status": "modified", "additions": 68, "deletions": 55, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/678d85ca7e4d7e631a450b8c050fe7696da0cac3/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/678d85ca7e4d7e631a450b8c050fe7696da0cac3/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs?ref=678d85ca7e4d7e631a450b8c050fe7696da0cac3", "patch": "@@ -1,5 +1,9 @@\n use hir_def::{\n-    expr::{Pat, PatId},\n+    expr::{Pat, PatId, RecordFieldPat},\n+    find_path::find_path,\n+    item_scope::ItemInNs,\n+    path::Path,\n+    type_ref::Mutability,\n     AttrDefId, EnumVariantId, HasModule, VariantId,\n };\n \n@@ -126,19 +130,25 @@ impl Constructor {\n \n     /// Determines the constructor that the given pattern can be specialized to.\n     pub(super) fn from_pat(cx: &MatchCheckCtx<'_>, pat: PatId) -> Self {\n+        let ty = cx.type_of(pat);\n         match &cx.pattern_arena.borrow()[pat] {\n             Pat::Bind { .. } | Pat::Wild => Wildcard,\n             Pat::Tuple { .. } | Pat::Ref { .. } | Pat::Box { .. } => Single,\n+            Pat::Record { .. } | Pat::Path(_) | Pat::TupleStruct { .. } => {\n+                let variant_id =\n+                    cx.infer.variant_resolution_for_pat(pat).unwrap_or_else(|| todo!());\n+                match variant_id {\n+                    VariantId::EnumVariantId(id) => Variant(id),\n+                    VariantId::StructId(_) | VariantId::UnionId(_) => Single,\n+                }\n+            }\n \n+            Pat::Or(..) => panic!(\"bug: Or-pattern should have been expanded earlier on.\"),\n             pat => todo!(\"Constructor::from_pat {:?}\", pat),\n             // Pat::Missing => {}\n-            // Pat::Or(_) => {}\n-            // Pat::Record { path, args, ellipsis } => {}\n             // Pat::Range { start, end } => {}\n             // Pat::Slice { prefix, slice, suffix } => {}\n-            // Pat::Path(_) => {}\n             // Pat::Lit(_) => {}\n-            // Pat::TupleStruct { path, args, ellipsis } => {}\n             // Pat::ConstBlock(_) => {}\n         }\n     }\n@@ -435,7 +445,8 @@ impl Fields {\n                     } else {\n                         let variant_id = constructor.variant_id_for_adt(*adt, cx);\n                         let variant = variant_id.variant_data(cx.db.upcast());\n-                        let adt_is_local = variant_id.module(cx.db.upcast()).krate() == cx.krate;\n+                        let adt_is_local =\n+                            variant_id.module(cx.db.upcast()).krate() == cx.module.krate();\n                         // Whether we must not match the fields of this variant exhaustively.\n                         let is_non_exhaustive =\n                             is_field_list_non_exhaustive(variant_id, cx) && !adt_is_local;\n@@ -490,43 +501,44 @@ impl Fields {\n             Single | Variant(_) => match pcx.ty.kind(&Interner) {\n                 TyKind::Adt(..) | TyKind::Tuple(..) => {\n                     // We want the real indices here.\n-                    // TODO indices\n+                    // TODO indices and ellipsis interaction, tests\n                     let subpatterns = subpatterns_and_indices.iter().map(|&(_, pat)| pat).collect();\n \n                     if let Some((adt, substs)) = pcx.ty.as_adt() {\n-                        if let hir_def::AdtId::EnumId(_) = adt {\n-                            todo!()\n-                        } else {\n-                            todo!()\n+                        let item = ItemInNs::Types(adt.into());\n+                        let path = find_path(pcx.cx.db.upcast(), item, pcx.cx.module)\n+                            .map(|mpath| Path::from_known_path(mpath, Vec::new()).into());\n+                        match adt {\n+                            hir_def::AdtId::EnumId(_) => todo!(),\n+                            hir_def::AdtId::StructId(id) => {\n+                                let variant_data = &pcx.cx.db.struct_data(id).variant_data;\n+                                let args = subpatterns_and_indices\n+                                    .iter()\n+                                    .zip(variant_data.fields().iter())\n+                                    .map(|(&(_, pat), (_, field_data))| RecordFieldPat {\n+                                        name: field_data.name.clone(),\n+                                        pat,\n+                                    })\n+                                    .collect();\n+                                Pat::Record { path, args, ellipsis: false }\n+                            }\n+                            hir_def::AdtId::UnionId(_) => todo!(),\n                         }\n                     } else {\n-                        // TODO ellipsis\n                         Pat::Tuple { args: subpatterns, ellipsis: None }\n                     }\n                 }\n-\n-                _ => todo!(),\n-                // TyKind::AssociatedType(_, _) => {}\n-                // TyKind::Scalar(_) => {}\n-                // TyKind::Array(_, _) => {}\n-                // TyKind::Slice(_) => {}\n-                // TyKind::Raw(_, _) => {}\n-                // TyKind::Ref(_, _, _) => {}\n-                // TyKind::OpaqueType(_, _) => {}\n-                // TyKind::FnDef(_, _) => {}\n-                // TyKind::Str => {}\n-                // TyKind::Never => {}\n-                // TyKind::Closure(_, _) => {}\n-                // TyKind::Generator(_, _) => {}\n-                // TyKind::GeneratorWitness(_, _) => {}\n-                // TyKind::Foreign(_) => {}\n-                // TyKind::Error => {}\n-                // TyKind::Placeholder(_) => {}\n-                // TyKind::Dyn(_) => {}\n-                // TyKind::Alias(_) => {}\n-                // TyKind::Function(_) => {}\n-                // TyKind::BoundVar(_) => {}\n-                // TyKind::InferenceVar(_, _) => {}\n+                // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n+                // be careful to reconstruct the correct constant pattern here. However a string\n+                // literal pattern will never be reported as a non-exhaustiveness witness, so we\n+                // can ignore this issue.\n+                TyKind::Ref(..) => {\n+                    Pat::Ref { pat: subpatterns.next().unwrap(), mutability: Mutability::Shared }\n+                }\n+                TyKind::Slice(..) | TyKind::Array(..) => {\n+                    panic!(\"bug: bad slice pattern {:?} {:?}\", ctor, pcx.ty)\n+                }\n+                _ => Pat::Wild,\n             },\n             Constructor::Slice(slice) => {\n                 todo!()\n@@ -537,9 +549,9 @@ impl Fields {\n             NonExhaustive => Pat::Wild,\n             Wildcard => Pat::Wild,\n             Opaque => panic!(\"bug: we should not try to apply an opaque constructor\"),\n-            Missing => panic!(\n-                \"bug: trying to apply the `Missing` constructor; this should have been done in `apply_constructors`\"\n-            ),\n+            Missing => {\n+                panic!(\"bug: trying to apply the `Missing` constructor; this should have been done in `apply_constructors`\")\n+            }\n         }\n     }\n \n@@ -628,30 +640,31 @@ impl Fields {\n         cx: &MatchCheckCtx<'_>,\n     ) -> Self {\n         match &cx.pattern_arena.borrow()[pat] {\n-            Pat::Ref { pat: subpattern, .. } => {\n+            Pat::Ref { pat: subpattern, .. } | Pat::Box { inner: subpattern } => {\n                 assert_eq!(self.len(), 1);\n                 Fields::from_single_pattern(*subpattern)\n             }\n-            Pat::Tuple { args: subpatterns, ellipsis } => {\n+            Pat::Tuple { args, ellipsis } | Pat::TupleStruct { args, ellipsis, .. } => {\n                 // FIXME(iDawer) handle ellipsis.\n                 // XXX(iDawer): in rustc, this is handled by HIR->TypedHIR lowering\n                 // rustc_mir_build::thir::pattern::PatCtxt::lower_tuple_subpats(..)\n-                self.replace_with_fieldpats(subpatterns.iter().copied())\n+                self.replace_with_fieldpats(args.iter().copied())\n             }\n-\n-            Pat::Wild => self.clone(),\n-            pat => todo!(\"Fields::replace_with_pattern_arguments({:?})\", pat),\n-            // Pat::Missing => {}\n-            // Pat::Or(_) => {}\n-            // Pat::Record { path, args, ellipsis } => {}\n-            // Pat::Range { start, end } => {}\n-            // Pat::Slice { prefix, slice, suffix } => {}\n-            // Pat::Path(_) => {}\n-            // Pat::Lit(_) => {}\n-            // Pat::Bind { mode, name, subpat } => {}\n-            // Pat::TupleStruct { path, args, ellipsis } => {}\n-            // Pat::Box { inner } => {}\n-            // Pat::ConstBlock(_) => {}\n+            Pat::Record { args, ellipsis, .. } => {\n+                // FIXME(iDawer) handle ellipsis.\n+                self.replace_with_fieldpats(args.iter().map(|field_pat| field_pat.pat))\n+            }\n+            Pat::Slice { .. } => {\n+                todo!()\n+            }\n+            Pat::Missing\n+            | Pat::Wild\n+            | Pat::Or(_)\n+            | Pat::Range { .. }\n+            | Pat::Path(_)\n+            | Pat::Lit(_)\n+            | Pat::Bind { .. }\n+            | Pat::ConstBlock(_) => self.clone(),\n         }\n     }\n }"}, {"sha": "4b55aee97dbe149eb1a4aa053baef7971e695b46", "filename": "crates/hir_ty/src/diagnostics/pattern/usefulness.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/678d85ca7e4d7e631a450b8c050fe7696da0cac3/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/678d85ca7e4d7e631a450b8c050fe7696da0cac3/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs?ref=678d85ca7e4d7e631a450b8c050fe7696da0cac3", "patch": "@@ -3,11 +3,7 @@\n \n use std::{cell::RefCell, iter::FromIterator, ops::Index, sync::Arc};\n \n-use base_db::CrateId;\n-use hir_def::{\n-    body::Body,\n-    expr::{ExprId, Pat, PatId},\n-};\n+use hir_def::{ModuleId, body::Body, expr::{ExprId, Pat, PatId}};\n use la_arena::Arena;\n use once_cell::unsync::OnceCell;\n use rustc_hash::FxHashMap;\n@@ -24,7 +20,7 @@ use self::{\n };\n \n pub(crate) struct MatchCheckCtx<'a> {\n-    pub(crate) krate: CrateId,\n+    pub(crate) module: ModuleId,\n     pub(crate) match_expr: ExprId,\n     pub(crate) body: Arc<Body>,\n     pub(crate) infer: &'a InferenceResult,"}]}