{"sha": "b7e2157dbab228e491919094f012af3ff8ce530c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI3ZTIxNTdkYmFiMjI4ZTQ5MTkxOTA5NGYwMTJhZjNmZjhjZTUzMGM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-27T02:05:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-27T02:05:11Z"}, "message": "Auto merge of #35542 - scottcarr:visitor_refactor, r=nikomatsakis\n\n[MIR] track Location in MirVisitor, combine Location\n\nAll the users of MirVisitor::visit_statement implement their own statement index tracking.  This PR move the tracking into MirVisitor itself.\n\nAlso, there were 2 separate implementations of Location that were identical.  This PR eliminates one of them.", "tree": {"sha": "5106e185858cfdec22cebc3bc22d35548b3e904b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5106e185858cfdec22cebc3bc22d35548b3e904b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7e2157dbab228e491919094f012af3ff8ce530c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7e2157dbab228e491919094f012af3ff8ce530c", "html_url": "https://github.com/rust-lang/rust/commit/b7e2157dbab228e491919094f012af3ff8ce530c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7e2157dbab228e491919094f012af3ff8ce530c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1987131063f08afc54d57cdba56c2acddcff191d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1987131063f08afc54d57cdba56c2acddcff191d", "html_url": "https://github.com/rust-lang/rust/commit/1987131063f08afc54d57cdba56c2acddcff191d"}, {"sha": "c043a27e4232993d4366962f854d4d3812c66fff", "url": "https://api.github.com/repos/rust-lang/rust/commits/c043a27e4232993d4366962f854d4d3812c66fff", "html_url": "https://github.com/rust-lang/rust/commit/c043a27e4232993d4366962f854d4d3812c66fff"}], "stats": {"total": 532, "additions": 278, "deletions": 254}, "files": [{"sha": "5279d0526089639fe9f5e6202dbc0332db65f3f3", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -1239,3 +1239,14 @@ impl<'a, 'b>  GraphSuccessors<'b> for Mir<'a> {\n     type Item = BasicBlock;\n     type Iter = IntoIter<BasicBlock>;\n }\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash, Ord, PartialOrd)]\n+pub struct Location {\n+    /// the location is within this block\n+    pub block: BasicBlock,\n+\n+    /// the location is the start of the this statement; or, if `statement_index`\n+    /// == num-statements, then the start of the terminator.\n+    pub statement_index: usize,\n+}\n+"}, {"sha": "0a0872b5edafe3d452079e78cf14f142411cdf28", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 122, "deletions": 89, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -103,60 +103,70 @@ macro_rules! make_mir_visitor {\n \n             fn visit_statement(&mut self,\n                                block: BasicBlock,\n-                               statement: & $($mutability)* Statement<'tcx>) {\n-                self.super_statement(block, statement);\n+                               statement: & $($mutability)* Statement<'tcx>,\n+                               location: Location) {\n+                self.super_statement(block, statement, location);\n             }\n \n             fn visit_assign(&mut self,\n                             block: BasicBlock,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>) {\n-                self.super_assign(block, lvalue, rvalue);\n+                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            location: Location) {\n+                self.super_assign(block, lvalue, rvalue, location);\n             }\n \n             fn visit_terminator(&mut self,\n                                 block: BasicBlock,\n-                                terminator: & $($mutability)* Terminator<'tcx>) {\n-                self.super_terminator(block, terminator);\n+                                terminator: & $($mutability)* Terminator<'tcx>,\n+                                location: Location) {\n+                self.super_terminator(block, terminator, location);\n             }\n \n             fn visit_terminator_kind(&mut self,\n                                      block: BasicBlock,\n-                                     kind: & $($mutability)* TerminatorKind<'tcx>) {\n-                self.super_terminator_kind(block, kind);\n+                                     kind: & $($mutability)* TerminatorKind<'tcx>,\n+                                     location: Location) {\n+                self.super_terminator_kind(block, kind, location);\n             }\n \n             fn visit_assert_message(&mut self,\n-                                    msg: & $($mutability)* AssertMessage<'tcx>) {\n-                self.super_assert_message(msg);\n+                                    msg: & $($mutability)* AssertMessage<'tcx>,\n+                                    location: Location) {\n+                self.super_assert_message(msg, location);\n             }\n \n             fn visit_rvalue(&mut self,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>) {\n-                self.super_rvalue(rvalue);\n+                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            location: Location) {\n+                self.super_rvalue(rvalue, location);\n             }\n \n             fn visit_operand(&mut self,\n-                             operand: & $($mutability)* Operand<'tcx>) {\n-                self.super_operand(operand);\n+                             operand: & $($mutability)* Operand<'tcx>,\n+                             location: Location) {\n+                self.super_operand(operand, location);\n             }\n \n             fn visit_lvalue(&mut self,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            context: LvalueContext) {\n-                self.super_lvalue(lvalue, context);\n+                            context: LvalueContext,\n+                            location: Location) {\n+                self.super_lvalue(lvalue, context, location);\n             }\n \n             fn visit_projection(&mut self,\n                                 lvalue: & $($mutability)* LvalueProjection<'tcx>,\n-                                context: LvalueContext) {\n-                self.super_projection(lvalue, context);\n+                                context: LvalueContext,\n+                                location: Location) {\n+                self.super_projection(lvalue, context, location);\n             }\n \n             fn visit_projection_elem(&mut self,\n                                      lvalue: & $($mutability)* LvalueElem<'tcx>,\n-                                     context: LvalueContext) {\n-                self.super_projection_elem(lvalue, context);\n+                                     context: LvalueContext,\n+                                     location: Location) {\n+                self.super_projection_elem(lvalue, context, location);\n             }\n \n             fn visit_branch(&mut self,\n@@ -166,17 +176,20 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_constant(&mut self,\n-                              constant: & $($mutability)* Constant<'tcx>) {\n-                self.super_constant(constant);\n+                              constant: & $($mutability)* Constant<'tcx>,\n+                              location: Location) {\n+                self.super_constant(constant, location);\n             }\n \n             fn visit_literal(&mut self,\n-                             literal: & $($mutability)* Literal<'tcx>) {\n-                self.super_literal(literal);\n+                             literal: & $($mutability)* Literal<'tcx>,\n+                             location: Location) {\n+                self.super_literal(literal, location);\n             }\n \n             fn visit_def_id(&mut self,\n-                            def_id: & $($mutability)* DefId) {\n+                            def_id: & $($mutability)* DefId,\n+                            _: Location) {\n                 self.super_def_id(def_id);\n             }\n \n@@ -206,18 +219,21 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_const_val(&mut self,\n-                               const_val: & $($mutability)* ConstVal) {\n+                               const_val: & $($mutability)* ConstVal,\n+                               _: Location) {\n                 self.super_const_val(const_val);\n             }\n \n             fn visit_const_usize(&mut self,\n-                                 const_usize: & $($mutability)* ConstUsize) {\n+                                 const_usize: & $($mutability)* ConstUsize,\n+                                 _: Location) {\n                 self.super_const_usize(const_usize);\n             }\n \n             fn visit_typed_const_val(&mut self,\n-                                     val: & $($mutability)* TypedConstVal<'tcx>) {\n-                self.super_typed_const_val(val);\n+                                     val: & $($mutability)* TypedConstVal<'tcx>,\n+                                     location: Location) {\n+                self.super_typed_const_val(val, location);\n             }\n \n             fn visit_var_decl(&mut self,\n@@ -280,12 +296,16 @@ macro_rules! make_mir_visitor {\n                     is_cleanup: _\n                 } = *data;\n \n+                let mut index = 0;\n                 for statement in statements {\n-                    self.visit_statement(block, statement);\n+                    let location = Location { block: block, statement_index: index };\n+                    self.visit_statement(block, statement, location);\n+                    index += 1;\n                 }\n \n                 if let Some(ref $($mutability)* terminator) = *terminator {\n-                    self.visit_terminator(block, terminator);\n+                    let location = Location { block: block, statement_index: index };\n+                    self.visit_terminator(block, terminator, location);\n                 }\n             }\n \n@@ -304,7 +324,8 @@ macro_rules! make_mir_visitor {\n \n             fn super_statement(&mut self,\n                                block: BasicBlock,\n-                               statement: & $($mutability)* Statement<'tcx>) {\n+                               statement: & $($mutability)* Statement<'tcx>,\n+                               location: Location) {\n                 let Statement {\n                     ref $($mutability)* source_info,\n                     ref $($mutability)* kind,\n@@ -314,51 +335,54 @@ macro_rules! make_mir_visitor {\n                 match *kind {\n                     StatementKind::Assign(ref $($mutability)* lvalue,\n                                           ref $($mutability)* rvalue) => {\n-                        self.visit_assign(block, lvalue, rvalue);\n+                        self.visit_assign(block, lvalue, rvalue, location);\n                     }\n                     StatementKind::SetDiscriminant{ ref $($mutability)* lvalue, .. } => {\n-                        self.visit_lvalue(lvalue, LvalueContext::Store);\n+                        self.visit_lvalue(lvalue, LvalueContext::Store, location);\n                     }\n                     StatementKind::StorageLive(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::StorageLive);\n+                        self.visit_lvalue(lvalue, LvalueContext::StorageLive, location);\n                     }\n                     StatementKind::StorageDead(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::StorageDead);\n+                        self.visit_lvalue(lvalue, LvalueContext::StorageDead, location);\n                     }\n                 }\n             }\n \n             fn super_assign(&mut self,\n                             _block: BasicBlock,\n                             lvalue: &$($mutability)* Lvalue<'tcx>,\n-                            rvalue: &$($mutability)* Rvalue<'tcx>) {\n-                self.visit_lvalue(lvalue, LvalueContext::Store);\n-                self.visit_rvalue(rvalue);\n+                            rvalue: &$($mutability)* Rvalue<'tcx>,\n+                            location: Location) {\n+                self.visit_lvalue(lvalue, LvalueContext::Store, location);\n+                self.visit_rvalue(rvalue, location);\n             }\n \n             fn super_terminator(&mut self,\n                                 block: BasicBlock,\n-                                terminator: &$($mutability)* Terminator<'tcx>) {\n+                                terminator: &$($mutability)* Terminator<'tcx>,\n+                                location: Location) {\n                 let Terminator {\n                     ref $($mutability)* source_info,\n                     ref $($mutability)* kind,\n                 } = *terminator;\n \n                 self.visit_source_info(source_info);\n-                self.visit_terminator_kind(block, kind);\n+                self.visit_terminator_kind(block, kind, location);\n             }\n \n             fn super_terminator_kind(&mut self,\n                                      block: BasicBlock,\n-                                     kind: & $($mutability)* TerminatorKind<'tcx>) {\n+                                     kind: & $($mutability)* TerminatorKind<'tcx>,\n+                                     source_location: Location) {\n                 match *kind {\n                     TerminatorKind::Goto { target } => {\n                         self.visit_branch(block, target);\n                     }\n \n                     TerminatorKind::If { ref $($mutability)* cond,\n                                          ref $($mutability)* targets } => {\n-                        self.visit_operand(cond);\n+                        self.visit_operand(cond, source_location);\n                         for &target in targets.as_slice() {\n                             self.visit_branch(block, target);\n                         }\n@@ -367,7 +391,7 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Switch { ref $($mutability)* discr,\n                                              adt_def: _,\n                                              ref targets } => {\n-                        self.visit_lvalue(discr, LvalueContext::Inspect);\n+                        self.visit_lvalue(discr, LvalueContext::Inspect, source_location);\n                         for &target in targets {\n                             self.visit_branch(block, target);\n                         }\n@@ -377,10 +401,10 @@ macro_rules! make_mir_visitor {\n                                                 ref $($mutability)* switch_ty,\n                                                 ref $($mutability)* values,\n                                                 ref targets } => {\n-                        self.visit_lvalue(discr, LvalueContext::Inspect);\n+                        self.visit_lvalue(discr, LvalueContext::Inspect, source_location);\n                         self.visit_ty(switch_ty);\n                         for value in values {\n-                            self.visit_const_val(value);\n+                            self.visit_const_val(value, source_location);\n                         }\n                         for &target in targets {\n                             self.visit_branch(block, target);\n@@ -395,7 +419,7 @@ macro_rules! make_mir_visitor {\n                     TerminatorKind::Drop { ref $($mutability)* location,\n                                            target,\n                                            unwind } => {\n-                        self.visit_lvalue(location, LvalueContext::Drop);\n+                        self.visit_lvalue(location, LvalueContext::Drop, source_location);\n                         self.visit_branch(block, target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n@@ -404,8 +428,8 @@ macro_rules! make_mir_visitor {\n                                                      ref $($mutability)* value,\n                                                      target,\n                                                      unwind } => {\n-                        self.visit_lvalue(location, LvalueContext::Drop);\n-                        self.visit_operand(value);\n+                        self.visit_lvalue(location, LvalueContext::Drop, source_location);\n+                        self.visit_operand(value, source_location);\n                         self.visit_branch(block, target);\n                         unwind.map(|t| self.visit_branch(block, t));\n                     }\n@@ -414,12 +438,12 @@ macro_rules! make_mir_visitor {\n                                            ref $($mutability)* args,\n                                            ref $($mutability)* destination,\n                                            cleanup } => {\n-                        self.visit_operand(func);\n+                        self.visit_operand(func, source_location);\n                         for arg in args {\n-                            self.visit_operand(arg);\n+                            self.visit_operand(arg, source_location);\n                         }\n                         if let Some((ref $($mutability)* destination, target)) = *destination {\n-                            self.visit_lvalue(destination, LvalueContext::Call);\n+                            self.visit_lvalue(destination, LvalueContext::Call, source_location);\n                             self.visit_branch(block, target);\n                         }\n                         cleanup.map(|t| self.visit_branch(block, t));\n@@ -430,56 +454,58 @@ macro_rules! make_mir_visitor {\n                                              ref $($mutability)* msg,\n                                              target,\n                                              cleanup } => {\n-                        self.visit_operand(cond);\n-                        self.visit_assert_message(msg);\n+                        self.visit_operand(cond, source_location);\n+                        self.visit_assert_message(msg, source_location);\n                         self.visit_branch(block, target);\n                         cleanup.map(|t| self.visit_branch(block, t));\n                     }\n                 }\n             }\n \n             fn super_assert_message(&mut self,\n-                                    msg: & $($mutability)* AssertMessage<'tcx>) {\n+                                    msg: & $($mutability)* AssertMessage<'tcx>,\n+                                    location: Location) {\n                 match *msg {\n                     AssertMessage::BoundsCheck {\n                         ref $($mutability)* len,\n                         ref $($mutability)* index\n                     } => {\n-                        self.visit_operand(len);\n-                        self.visit_operand(index);\n+                        self.visit_operand(len, location);\n+                        self.visit_operand(index, location);\n                     }\n                     AssertMessage::Math(_) => {}\n                 }\n             }\n \n             fn super_rvalue(&mut self,\n-                            rvalue: & $($mutability)* Rvalue<'tcx>) {\n+                            rvalue: & $($mutability)* Rvalue<'tcx>,\n+                            location: Location) {\n                 match *rvalue {\n                     Rvalue::Use(ref $($mutability)* operand) => {\n-                        self.visit_operand(operand);\n+                        self.visit_operand(operand, location);\n                     }\n \n                     Rvalue::Repeat(ref $($mutability)* value,\n                                    ref $($mutability)* typed_const_val) => {\n-                        self.visit_operand(value);\n-                        self.visit_typed_const_val(typed_const_val);\n+                        self.visit_operand(value, location);\n+                        self.visit_typed_const_val(typed_const_val, location);\n                     }\n \n                     Rvalue::Ref(r, bk, ref $($mutability)* path) => {\n                         self.visit_lvalue(path, LvalueContext::Borrow {\n                             region: r,\n                             kind: bk\n-                        });\n+                        }, location);\n                     }\n \n                     Rvalue::Len(ref $($mutability)* path) => {\n-                        self.visit_lvalue(path, LvalueContext::Inspect);\n+                        self.visit_lvalue(path, LvalueContext::Inspect, location);\n                     }\n \n                     Rvalue::Cast(_cast_kind,\n                                  ref $($mutability)* operand,\n                                  ref $($mutability)* ty) => {\n-                        self.visit_operand(operand);\n+                        self.visit_operand(operand, location);\n                         self.visit_ty(ty);\n                     }\n \n@@ -489,12 +515,12 @@ macro_rules! make_mir_visitor {\n                     Rvalue::CheckedBinaryOp(_bin_op,\n                                      ref $($mutability)* lhs,\n                                      ref $($mutability)* rhs) => {\n-                        self.visit_operand(lhs);\n-                        self.visit_operand(rhs);\n+                        self.visit_operand(lhs, location);\n+                        self.visit_operand(rhs, location);\n                     }\n \n                     Rvalue::UnaryOp(_un_op, ref $($mutability)* op) => {\n-                        self.visit_operand(op);\n+                        self.visit_operand(op, location);\n                     }\n \n                     Rvalue::Box(ref $($mutability)* ty) => {\n@@ -515,73 +541,77 @@ macro_rules! make_mir_visitor {\n                             }\n                             AggregateKind::Closure(ref $($mutability)* def_id,\n                                                    ref $($mutability)* closure_substs) => {\n-                                self.visit_def_id(def_id);\n+                                self.visit_def_id(def_id, location);\n                                 self.visit_closure_substs(closure_substs);\n                             }\n                         }\n \n                         for operand in operands {\n-                            self.visit_operand(operand);\n+                            self.visit_operand(operand, location);\n                         }\n                     }\n \n                     Rvalue::InlineAsm { ref $($mutability)* outputs,\n                                         ref $($mutability)* inputs,\n                                         asm: _ } => {\n                         for output in & $($mutability)* outputs[..] {\n-                            self.visit_lvalue(output, LvalueContext::Store);\n+                            self.visit_lvalue(output, LvalueContext::Store, location);\n                         }\n                         for input in & $($mutability)* inputs[..] {\n-                            self.visit_operand(input);\n+                            self.visit_operand(input, location);\n                         }\n                     }\n                 }\n             }\n \n             fn super_operand(&mut self,\n-                             operand: & $($mutability)* Operand<'tcx>) {\n+                             operand: & $($mutability)* Operand<'tcx>,\n+                             location: Location) {\n                 match *operand {\n                     Operand::Consume(ref $($mutability)* lvalue) => {\n-                        self.visit_lvalue(lvalue, LvalueContext::Consume);\n+                        self.visit_lvalue(lvalue, LvalueContext::Consume, location);\n                     }\n                     Operand::Constant(ref $($mutability)* constant) => {\n-                        self.visit_constant(constant);\n+                        self.visit_constant(constant, location);\n                     }\n                 }\n             }\n \n             fn super_lvalue(&mut self,\n                             lvalue: & $($mutability)* Lvalue<'tcx>,\n-                            context: LvalueContext) {\n+                            context: LvalueContext,\n+                            location: Location) {\n                 match *lvalue {\n                     Lvalue::Var(_) |\n                     Lvalue::Temp(_) |\n                     Lvalue::Arg(_) |\n                     Lvalue::ReturnPointer => {\n                     }\n                     Lvalue::Static(ref $($mutability)* def_id) => {\n-                        self.visit_def_id(def_id);\n+                        self.visit_def_id(def_id, location);\n                     }\n                     Lvalue::Projection(ref $($mutability)* proj) => {\n-                        self.visit_projection(proj, context);\n+                        self.visit_projection(proj, context, location);\n                     }\n                 }\n             }\n \n             fn super_projection(&mut self,\n                                 proj: & $($mutability)* LvalueProjection<'tcx>,\n-                                context: LvalueContext) {\n+                                context: LvalueContext,\n+                                location: Location) {\n                 let Projection {\n                     ref $($mutability)* base,\n                     ref $($mutability)* elem,\n                 } = *proj;\n-                self.visit_lvalue(base, LvalueContext::Projection);\n-                self.visit_projection_elem(elem, context);\n+                self.visit_lvalue(base, LvalueContext::Projection, location);\n+                self.visit_projection_elem(elem, context, location);\n             }\n \n             fn super_projection_elem(&mut self,\n                                      proj: & $($mutability)* LvalueElem<'tcx>,\n-                                     _context: LvalueContext) {\n+                                     _context: LvalueContext,\n+                                     location: Location) {\n                 match *proj {\n                     ProjectionElem::Deref => {\n                     }\n@@ -591,7 +621,7 @@ macro_rules! make_mir_visitor {\n                         self.visit_ty(ty);\n                     }\n                     ProjectionElem::Index(ref $($mutability)* operand) => {\n-                        self.visit_operand(operand);\n+                        self.visit_operand(operand, location);\n                     }\n                     ProjectionElem::ConstantIndex { offset: _,\n                                                     min_length: _,\n@@ -645,7 +675,8 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_constant(&mut self,\n-                              constant: & $($mutability)* Constant<'tcx>) {\n+                              constant: & $($mutability)* Constant<'tcx>,\n+                              location: Location) {\n                 let Constant {\n                     ref $($mutability)* span,\n                     ref $($mutability)* ty,\n@@ -654,11 +685,12 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_span(span);\n                 self.visit_ty(ty);\n-                self.visit_literal(literal);\n+                self.visit_literal(literal, location);\n             }\n \n             fn super_typed_const_val(&mut self,\n-                                     constant: & $($mutability)* TypedConstVal<'tcx>) {\n+                                     constant: & $($mutability)* TypedConstVal<'tcx>,\n+                                     location: Location) {\n                 let TypedConstVal {\n                     ref $($mutability)* span,\n                     ref $($mutability)* ty,\n@@ -667,19 +699,20 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_span(span);\n                 self.visit_ty(ty);\n-                self.visit_const_usize(value);\n+                self.visit_const_usize(value, location);\n             }\n \n             fn super_literal(&mut self,\n-                             literal: & $($mutability)* Literal<'tcx>) {\n+                             literal: & $($mutability)* Literal<'tcx>,\n+                             location: Location) {\n                 match *literal {\n                     Literal::Item { ref $($mutability)* def_id,\n                                     ref $($mutability)* substs } => {\n-                        self.visit_def_id(def_id);\n+                        self.visit_def_id(def_id, location);\n                         self.visit_substs(substs);\n                     }\n                     Literal::Value { ref $($mutability)* value } => {\n-                        self.visit_const_val(value);\n+                        self.visit_const_val(value, location);\n                     }\n                     Literal::Promoted { index: _ } => {}\n                 }"}, {"sha": "c46daf9c22537226dbadb5d422157eb399b4aab6", "filename": "src/librustc_borrowck/borrowck/mir/dataflow/impls.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fdataflow%2Fimpls.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -9,10 +9,9 @@\n // except according to those terms.\n \n use rustc::ty::TyCtxt;\n-use rustc::mir::repr::{self, Mir};\n+use rustc::mir::repr::{self, Mir, Location};\n use rustc_data_structures::indexed_vec::Idx;\n \n-use super::super::gather_moves::{Location};\n use super::super::gather_moves::{MoveOutIndex, MovePathIndex};\n use super::super::MoveDataParamEnv;\n use super::super::DropFlagState;\n@@ -252,7 +251,7 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, ctxt,\n-            Location { block: bb, index: idx },\n+            Location { block: bb, statement_index: idx },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n@@ -265,7 +264,7 @@ impl<'a, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'tcx> {\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, ctxt,\n-            Location { block: bb, index: statements_len },\n+            Location { block: bb, statement_index: statements_len },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n@@ -314,7 +313,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, ctxt,\n-            Location { block: bb, index: idx },\n+            Location { block: bb, statement_index: idx },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n@@ -327,7 +326,7 @@ impl<'a, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'tcx> {\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, ctxt,\n-            Location { block: bb, index: statements_len },\n+            Location { block: bb, statement_index: statements_len },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n@@ -375,7 +374,7 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, ctxt,\n-            Location { block: bb, index: idx },\n+            Location { block: bb, statement_index: idx },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n@@ -388,7 +387,7 @@ impl<'a, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'tcx> {\n     {\n         drop_flag_effects_for_location(\n             self.tcx, self.mir, ctxt,\n-            Location { block: bb, index: statements_len },\n+            Location { block: bb, statement_index: statements_len },\n             |path, s| Self::update_bits(sets, path, s)\n         )\n     }\n@@ -431,7 +430,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n         let path_map = &move_data.path_map;\n         let rev_lookup = &move_data.rev_lookup;\n \n-        let loc = Location { block: bb, index: idx };\n+        let loc = Location { block: bb, statement_index: idx };\n         debug!(\"stmt {:?} at loc {:?} moves out of move_indexes {:?}\",\n                stmt, loc, &loc_map[loc]);\n         for move_index in &loc_map[loc] {\n@@ -473,7 +472,7 @@ impl<'a, 'tcx> BitDenotation for MovingOutStatements<'a, 'tcx> {\n         let (mir, move_data) = (self.mir, &ctxt.move_data);\n         let term = mir[bb].terminator();\n         let loc_map = &move_data.loc_map;\n-        let loc = Location { block: bb, index: statements_len };\n+        let loc = Location { block: bb, statement_index: statements_len };\n         debug!(\"terminator {:?} at loc {:?} moves out of move_indexes {:?}\",\n                term, loc, &loc_map[loc]);\n         let bits_per_block = self.bits_per_block(ctxt);"}, {"sha": "57ec27aca9b04339f2e7771ed9292d0a0dfd4b41", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use indexed_set::IdxSetBuf;\n-use super::gather_moves::{MoveData, MovePathIndex, MovePathContent, Location};\n+use super::gather_moves::{MoveData, MovePathIndex, MovePathContent};\n use super::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use super::dataflow::{DataflowResults};\n use super::{drop_flag_effects_for_location, on_all_children_bits};\n@@ -146,9 +146,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             dead: self.flow_uninits.sets().on_entry_set_for(loc.block.index())\n                 .to_owned(),\n         };\n-        for stmt in 0..loc.index {\n+        for stmt in 0..loc.statement_index {\n             data.apply_location(self.tcx, self.mir, self.env,\n-                                Location { block: loc.block, index: stmt });\n+                                Location { block: loc.block, statement_index: stmt });\n         }\n         data\n     }\n@@ -226,7 +226,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n \n             let init_data = self.initialization_data_at(Location {\n                 block: bb,\n-                index: data.statements.len()\n+                statement_index: data.statements.len()\n             });\n \n             let path = self.move_data().rev_lookup.find(location);\n@@ -249,7 +249,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn elaborate_drops(&mut self)\n     {\n         for (bb, data) in self.mir.basic_blocks().iter_enumerated() {\n-            let loc = Location { block: bb, index: data.statements.len() };\n+            let loc = Location { block: bb, statement_index: data.statements.len() };\n             let terminator = data.terminator();\n \n             let resume_block = self.patch.resume_block();\n@@ -359,9 +359,9 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                 unwind: Some(unwind)\n             }, bb);\n             on_all_children_bits(self.tcx, self.mir, self.move_data(), path, |child| {\n-                self.set_drop_flag(Location { block: target, index: 0 },\n+                self.set_drop_flag(Location { block: target, statement_index: 0 },\n                                    child, DropFlagState::Present);\n-                self.set_drop_flag(Location { block: unwind, index: 0 },\n+                self.set_drop_flag(Location { block: unwind, statement_index: 0 },\n                                    child, DropFlagState::Present);\n             });\n         }\n@@ -741,7 +741,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let drop_block = self.drop_block(c);\n         if update_drop_flag {\n             self.set_drop_flag(\n-                Location { block: drop_block, index: 0 },\n+                Location { block: drop_block, statement_index: 0 },\n                 c.path,\n                 DropFlagState::Absent\n             );\n@@ -924,7 +924,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flags_on_init(&mut self) {\n-        let loc = Location { block: START_BLOCK, index: 0 };\n+        let loc = Location { block: START_BLOCK, statement_index: 0 };\n         let span = self.patch.source_info_for_location(self.mir, loc).span;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n@@ -939,7 +939,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             } = data.terminator().kind {\n                 assert!(!self.patch.is_patched(bb));\n \n-                let loc = Location { block: tgt, index: 0 };\n+                let loc = Location { block: tgt, statement_index: 0 };\n                 let path = self.move_data().rev_lookup.find(lv);\n                 on_all_children_bits(\n                     self.tcx, self.mir, self.move_data(), path,\n@@ -950,7 +950,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flags_for_args(&mut self) {\n-        let loc = Location { block: START_BLOCK, index: 0 };\n+        let loc = Location { block: START_BLOCK, statement_index: 0 };\n         super::drop_flag_effects_for_function_entry(\n             self.tcx, self.mir, self.env, |path, ds| {\n                 self.set_drop_flag(loc, path, ds);\n@@ -990,7 +990,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n                         }\n                     }\n                 }\n-                let loc = Location { block: bb, index: i };\n+                let loc = Location { block: bb, statement_index: i };\n                 super::drop_flag_effects_for_location(\n                     self.tcx, self.mir, self.env, loc, |path, ds| {\n                         if ds == DropFlagState::Absent || allow_initializations {\n@@ -1008,7 +1008,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n             } = data.terminator().kind {\n                 assert!(!self.patch.is_patched(bb));\n \n-                let loc = Location { block: bb, index: data.statements.len() };\n+                let loc = Location { block: bb, statement_index: data.statements.len() };\n                 let path = self.move_data().rev_lookup.find(lv);\n                 on_all_children_bits(\n                     self.tcx, self.mir, self.move_data(), path,"}, {"sha": "01bf8ed0e4b57679a379adf8854a6ad1cd5c1b1c", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -160,8 +160,8 @@ impl Index<Location> for LocMap {\n     type Output = [MoveOutIndex];\n     fn index(&self, index: Location) -> &Self::Output {\n         assert!(index.block.index() < self.map.len());\n-        assert!(index.index < self.map[index.block.index()].len());\n-        &self.map[index.block.index()][index.index]\n+        assert!(index.statement_index < self.map[index.block.index()].len());\n+        &self.map[index.block.index()][index.statement_index]\n     }\n }\n \n@@ -200,21 +200,6 @@ impl fmt::Debug for MoveOut {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n-pub struct Location {\n-    /// block where action is located\n-    pub block: BasicBlock,\n-    /// index within above block; statement when < statments.len) or\n-    /// the terminator (when = statements.len).\n-    pub index: usize,\n-}\n-\n-impl fmt::Debug for Location {\n-    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        write!(fmt, \"{:?}[{}]\", self.block, self.index)\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct MovePathData<'tcx> {\n     move_paths: Vec<MovePath<'tcx>>,\n@@ -569,7 +554,7 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n         };\n \n         for (i, stmt) in bb_data.statements.iter().enumerate() {\n-            let source = Location { block: bb, index: i };\n+            let source = Location { block: bb, statement_index: i };\n             match stmt.kind {\n                 StatementKind::Assign(ref lval, ref rval) => {\n                     bb_ctxt.builder.create_move_path(lval);\n@@ -631,14 +616,14 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n \n             TerminatorKind::Return => {\n                 let source = Location { block: bb,\n-                                        index: bb_data.statements.len() };\n+                                        statement_index: bb_data.statements.len() };\n                 debug!(\"gather_moves Return on_move_out_lval return {:?}\", source);\n                 bb_ctxt.on_move_out_lval(SK::Return, &Lvalue::ReturnPointer, source);\n             }\n \n             TerminatorKind::If { ref cond, targets: _ } => {\n                 let source = Location { block: bb,\n-                                        index: bb_data.statements.len() };\n+                                        statement_index: bb_data.statements.len() };\n                 bb_ctxt.on_operand(SK::If, cond, source);\n             }\n \n@@ -669,20 +654,20 @@ fn gather_moves<'a, 'tcx>(mir: &Mir<'tcx>, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> MoveD\n \n             TerminatorKind::Drop { ref location, target: _, unwind: _ } => {\n                 let source = Location { block: bb,\n-                                        index: bb_data.statements.len() };\n+                                        statement_index: bb_data.statements.len() };\n                 bb_ctxt.on_move_out_lval(SK::Drop, location, source);\n             }\n             TerminatorKind::DropAndReplace { ref location, ref value, .. } => {\n                 let assigned_path = bb_ctxt.builder.move_path_for(location);\n                 bb_ctxt.path_map.fill_to(assigned_path.index());\n \n                 let source = Location { block: bb,\n-                                        index: bb_data.statements.len() };\n+                                        statement_index: bb_data.statements.len() };\n                 bb_ctxt.on_operand(SK::Use, value, source);\n             }\n             TerminatorKind::Call { ref func, ref args, ref destination, cleanup: _ } => {\n                 let source = Location { block: bb,\n-                                        index: bb_data.statements.len() };\n+                                        statement_index: bb_data.statements.len() };\n                 bb_ctxt.on_operand(SK::CallFn, func, source);\n                 for arg in args {\n                     debug!(\"gather_moves Call on_operand {:?} {:?}\", arg, source);\n@@ -757,7 +742,7 @@ impl<'b, 'tcx: 'b> BlockContext<'b, 'tcx> {\n                         stmt_kind: StmtKind,\n                         lval: &Lvalue<'tcx>,\n                         source: Location) {\n-        let i = source.index;\n+        let i = source.statement_index;\n         let index = MoveOutIndex::new(self.moves.len());\n \n         let path = self.builder.move_path_for(lval);"}, {"sha": "31380c6f71c99877a0ec7fdb2a852c3cdebd1a10", "filename": "src/librustc_borrowck/borrowck/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fmod.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -19,7 +19,7 @@ use rustc::hir;\n use rustc::hir::intravisit::{FnKind};\n \n use rustc::mir::repr;\n-use rustc::mir::repr::{BasicBlock, BasicBlockData, Mir, Statement, Terminator};\n+use rustc::mir::repr::{BasicBlock, BasicBlockData, Mir, Statement, Terminator, Location};\n use rustc::session::Session;\n use rustc::ty::{self, TyCtxt};\n \n@@ -35,7 +35,7 @@ use self::dataflow::{DataflowOperator};\n use self::dataflow::{Dataflow, DataflowAnalysis, DataflowResults};\n use self::dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n use self::dataflow::{DefinitelyInitializedLvals};\n-use self::gather_moves::{MoveData, MovePathIndex, Location};\n+use self::gather_moves::{MoveData, MovePathIndex};\n use self::gather_moves::{MovePathContent, MovePathData};\n \n fn has_rustc_mir_with(attrs: &[ast::Attribute], name: &str) -> Option<P<MetaItem>> {\n@@ -367,7 +367,7 @@ fn drop_flag_effects_for_location<'a, 'tcx, F>(\n     }\n \n     let block = &mir[loc.block];\n-    match block.statements.get(loc.index) {\n+    match block.statements.get(loc.statement_index) {\n         Some(stmt) => match stmt.kind {\n             repr::StatementKind::SetDiscriminant{ .. } => {\n                 span_bug!(stmt.source_info.span, \"SetDiscrimant should not exist during borrowck\");"}, {"sha": "52cd1a9f949bf6219b7e1cd7e101a9a7c6ea0d8e", "filename": "src/librustc_borrowck/borrowck/mir/patch.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fpatch.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::gather_moves::Location;\n use rustc::ty::Ty;\n use rustc::mir::repr::*;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n@@ -89,7 +88,7 @@ impl<'tcx> MirPatch<'tcx> {\n         };\n         Location {\n             block: bb,\n-            index: offset\n+            statement_index: offset\n         }\n     }\n \n@@ -149,12 +148,12 @@ impl<'tcx> MirPatch<'tcx> {\n             }\n             debug!(\"MirPatch: adding statement {:?} at loc {:?}+{}\",\n                    stmt, loc, delta);\n-            loc.index += delta;\n+            loc.statement_index += delta;\n             let source_info = Self::source_info_for_index(\n                 &mir[loc.block], loc\n             );\n             mir[loc.block].statements.insert(\n-                loc.index, Statement {\n+                loc.statement_index, Statement {\n                     source_info: source_info,\n                     kind: stmt\n                 });\n@@ -163,7 +162,7 @@ impl<'tcx> MirPatch<'tcx> {\n     }\n \n     pub fn source_info_for_index(data: &BasicBlockData, loc: Location) -> SourceInfo {\n-        match data.statements.get(loc.index) {\n+        match data.statements.get(loc.statement_index) {\n             Some(stmt) => stmt.source_info,\n             None => data.terminator().source_info\n         }"}, {"sha": "ccbc4de82fb6367a23cb43d045b954ae89c1a868", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -42,6 +42,7 @@ use rustc_const_math::ConstInt;\n \n use rustc::mir;\n use rustc::mir::visit::MutVisitor;\n+use rustc::mir::repr::Location;\n \n use std::cell::Cell;\n use std::io;\n@@ -846,7 +847,7 @@ pub fn maybe_get_item_mir<'a, 'tcx>(cdata: Cmd,\n     impl<'v, 'cdata, 'codemap> mir::visit::MutVisitor<'v>\n         for MirDefIdAndSpanTranslator<'cdata, 'codemap>\n     {\n-        fn visit_def_id(&mut self, def_id: &mut DefId) {\n+        fn visit_def_id(&mut self, def_id: &mut DefId, _: Location) {\n             *def_id = translate_def_id(self.crate_metadata, *def_id);\n         }\n "}, {"sha": "026a79b32b8f735680af4685e7646bded4ff28c7", "filename": "src/librustc_mir/build/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fcfg.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -13,7 +13,7 @@\n \n //! Routines for manipulating the control-flow graph.\n \n-use build::{CFG, Location};\n+use build::CFG;\n use rustc::mir::repr::*;\n \n impl<'tcx> CFG<'tcx> {"}, {"sha": "59d6cf118596990bbe8db97410b6e6febdd3ae2c", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -101,16 +101,6 @@ pub struct ScopeAuxiliary {\n     pub postdoms: Vec<Location>,\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug, Hash)]\n-pub struct Location {\n-    /// the location is within this block\n-    pub block: BasicBlock,\n-\n-    /// the location is the start of the this statement; or, if `statement_index`\n-    /// == num-statements, then the start of the terminator.\n-    pub statement_index: usize,\n-}\n-\n pub type ScopeAuxiliaryVec = IndexVec<ScopeId, ScopeAuxiliary>;\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "d46a7b2bb9506fe22c446e414ad5fd92431446b3", "filename": "src/librustc_mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use build::{Location, ScopeAuxiliaryVec, ScopeId};\n+use build::{ScopeAuxiliaryVec, ScopeId};\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n use rustc::mir::repr::*;"}, {"sha": "32fddd293cacd770c4cef456f372e2d45e2e31e2", "filename": "src/librustc_mir/transform/no_landing_pads.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fno_landing_pads.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -19,7 +19,10 @@ use rustc::mir::transform::{Pass, MirPass, MirSource};\n pub struct NoLandingPads;\n \n impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n-    fn visit_terminator(&mut self, bb: BasicBlock, terminator: &mut Terminator<'tcx>) {\n+    fn visit_terminator(&mut self,\n+                        bb: BasicBlock,\n+                        terminator: &mut Terminator<'tcx>,\n+                        location: Location) {\n         match terminator.kind {\n             TerminatorKind::Goto { .. } |\n             TerminatorKind::Resume |\n@@ -37,7 +40,7 @@ impl<'tcx> MutVisitor<'tcx> for NoLandingPads {\n                 unwind.take();\n             },\n         }\n-        self.super_terminator(bb, terminator);\n+        self.super_terminator(bb, terminator, location);\n     }\n }\n "}, {"sha": "f864f1678f23690747f3ab055006063d95732363", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -28,11 +28,10 @@ use rustc::mir::traversal::ReversePostorder;\n use rustc::ty::TyCtxt;\n use syntax_pos::Span;\n \n-use build::Location;\n-\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n \n use std::mem;\n+use std::usize;\n \n /// State of a temporary during collection and promotion.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -77,13 +76,12 @@ pub enum Candidate {\n \n struct TempCollector {\n     temps: IndexVec<Temp, TempState>,\n-    location: Location,\n     span: Span\n }\n \n impl<'tcx> Visitor<'tcx> for TempCollector {\n-    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext) {\n-        self.super_lvalue(lvalue, context);\n+    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext, location: Location) {\n+        self.super_lvalue(lvalue, context, location);\n         if let Lvalue::Temp(index) = *lvalue {\n             // Ignore drops, if the temp gets promoted,\n             // then it's constant and thus drop is noop.\n@@ -101,7 +99,7 @@ impl<'tcx> Visitor<'tcx> for TempCollector {\n                     LvalueContext::Store |\n                     LvalueContext::Call => {\n                         *temp = TempState::Defined {\n-                            location: self.location,\n+                            location: location,\n                             uses: 0\n                         };\n                         return;\n@@ -126,27 +124,11 @@ impl<'tcx> Visitor<'tcx> for TempCollector {\n     fn visit_source_info(&mut self, source_info: &SourceInfo) {\n         self.span = source_info.span;\n     }\n-\n-    fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n-        assert_eq!(self.location.block, bb);\n-        self.super_statement(bb, statement);\n-        self.location.statement_index += 1;\n-    }\n-\n-    fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n-        self.location.statement_index = 0;\n-        self.location.block = bb;\n-        self.super_basic_block_data(bb, data);\n-    }\n }\n \n pub fn collect_temps(mir: &Mir, rpo: &mut ReversePostorder) -> IndexVec<Temp, TempState> {\n     let mut collector = TempCollector {\n         temps: IndexVec::from_elem(TempState::Undefined, &mir.temp_decls),\n-        location: Location {\n-            block: START_BLOCK,\n-            statement_index: 0\n-        },\n         span: mir.span\n     };\n     for (bb, data) in rpo {\n@@ -266,9 +248,15 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n \n         // Then, recurse for components in the Rvalue or Call.\n         if stmt_idx < no_stmts {\n-            self.visit_rvalue(rvalue.as_mut().unwrap());\n+            self.visit_rvalue(rvalue.as_mut().unwrap(), Location {\n+                block: bb,\n+                statement_index: stmt_idx\n+            });\n         } else {\n-            self.visit_terminator_kind(bb, call.as_mut().unwrap());\n+            self.visit_terminator_kind(bb, call.as_mut().unwrap(), Location {\n+                block: bb,\n+                statement_index: no_stmts\n+            });\n         }\n \n         let new_temp = self.promoted.temp_decls.push(TempDecl {\n@@ -327,19 +315,25 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 }\n             }\n         };\n-        self.visit_rvalue(&mut rvalue);\n+        self.visit_rvalue(&mut rvalue, Location{\n+            block: BasicBlock::new(0),\n+            statement_index: usize::MAX\n+        });\n         self.assign(Lvalue::ReturnPointer, rvalue, span);\n         self.source.promoted.push(self.promoted);\n     }\n }\n \n /// Replaces all temporaries with their promoted counterparts.\n impl<'a, 'tcx> MutVisitor<'tcx> for Promoter<'a, 'tcx> {\n-    fn visit_lvalue(&mut self, lvalue: &mut Lvalue<'tcx>, context: LvalueContext) {\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &mut Lvalue<'tcx>,\n+                    context: LvalueContext,\n+                    location: Location) {\n         if let Lvalue::Temp(ref mut temp) = *lvalue {\n             *temp = self.promote_temp(*temp);\n         }\n-        self.super_lvalue(lvalue, context);\n+        self.super_lvalue(lvalue, context, location);\n     }\n }\n "}, {"sha": "840befe603eee2fe6dbd15c4095ef5b402df93e5", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 36, "deletions": 38, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -36,8 +36,7 @@ use syntax_pos::Span;\n \n use std::collections::hash_map::Entry;\n use std::fmt;\n-\n-use build::Location;\n+use std::usize;\n \n use super::promote_consts::{self, Candidate, TempState};\n \n@@ -147,7 +146,6 @@ struct Qualifier<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     return_qualif: Option<Qualif>,\n     qualif: Qualif,\n     const_fn_arg_vars: BitVector,\n-    location: Location,\n     temp_promotion_state: IndexVec<Temp, TempState>,\n     promotion_candidates: Vec<Candidate>\n }\n@@ -178,10 +176,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             return_qualif: None,\n             qualif: Qualif::empty(),\n             const_fn_arg_vars: BitVector::new(mir.var_decls.len()),\n-            location: Location {\n-                block: START_BLOCK,\n-                statement_index: 0\n-            },\n             temp_promotion_state: temps,\n             promotion_candidates: vec![]\n         }\n@@ -293,7 +287,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     /// Assign the current qualification to the given destination.\n-    fn assign(&mut self, dest: &Lvalue<'tcx>) {\n+    fn assign(&mut self, dest: &Lvalue<'tcx>, location: Location) {\n         let qualif = self.qualif;\n         let span = self.span;\n         let store = |slot: &mut Option<Qualif>| {\n@@ -331,7 +325,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             // This must be an explicit assignment.\n             _ => {\n                 // Catch more errors in the destination.\n-                self.visit_lvalue(dest, LvalueContext::Store);\n+                self.visit_lvalue(dest, LvalueContext::Store, location);\n                 self.statement_like();\n             }\n         }\n@@ -399,7 +393,10 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n                     self.qualif = Qualif::NOT_CONST;\n                     for index in 0..mir.var_decls.len() {\n                         if !self.const_fn_arg_vars.contains(index) {\n-                            self.assign(&Lvalue::Var(Var::new(index)));\n+                            self.assign(&Lvalue::Var(Var::new(index)), Location {\n+                                block: bb,\n+                                statement_index: usize::MAX,\n+                            });\n                         }\n                     }\n \n@@ -445,7 +442,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n /// For functions (constant or not), it also records\n /// candidates for promotion in promotion_candidates.\n impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n-    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext) {\n+    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, context: LvalueContext, location: Location) {\n         match *lvalue {\n             Lvalue::Arg(_) => {\n                 self.add(Qualif::FN_ARGUMENT);\n@@ -477,7 +474,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n             Lvalue::Projection(ref proj) => {\n                 self.nest(|this| {\n-                    this.super_lvalue(lvalue, context);\n+                    this.super_lvalue(lvalue, context, location);\n                     match proj.elem {\n                         ProjectionElem::Deref => {\n                             if !this.try_consume() {\n@@ -527,11 +524,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn visit_operand(&mut self, operand: &Operand<'tcx>) {\n+    fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n         match *operand {\n             Operand::Consume(_) => {\n                 self.nest(|this| {\n-                    this.super_operand(operand);\n+                    this.super_operand(operand, location);\n                     this.try_consume();\n                 });\n             }\n@@ -570,9 +567,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n         // Recurse through operands and lvalues.\n-        self.super_rvalue(rvalue);\n+        self.super_rvalue(rvalue, location);\n \n         match *rvalue {\n             Rvalue::Use(_) |\n@@ -648,7 +645,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                 }\n \n                 // We might have a candidate for promotion.\n-                let candidate = Candidate::Ref(self.location);\n+                let candidate = Candidate::Ref(location);\n                 if self.mode == Mode::Fn || self.mode == Mode::ConstFn {\n                     if !self.qualif.intersects(Qualif::NEVER_PROMOTE) {\n                         // We can only promote direct borrows of temps.\n@@ -733,9 +730,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         }\n     }\n \n-    fn visit_terminator_kind(&mut self, bb: BasicBlock, kind: &TerminatorKind<'tcx>) {\n+    fn visit_terminator_kind(&mut self,\n+                             bb: BasicBlock,\n+                             kind: &TerminatorKind<'tcx>,\n+                             location: Location) {\n         if let TerminatorKind::Call { ref func, ref args, ref destination, .. } = *kind {\n-            self.visit_operand(func);\n+            self.visit_operand(func, location);\n \n             let fn_ty = func.ty(self.mir, self.tcx);\n             let (is_shuffle, is_const_fn) = match fn_ty.sty {\n@@ -749,7 +749,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n \n             for (i, arg) in args.iter().enumerate() {\n                 self.nest(|this| {\n-                    this.visit_operand(arg);\n+                    this.visit_operand(arg, location);\n                     if is_shuffle && i == 2 && this.mode == Mode::Fn {\n                         let candidate = Candidate::ShuffleIndices(bb);\n                         if !this.qualif.intersects(Qualif::NEVER_PROMOTE) {\n@@ -827,16 +827,20 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                         self.deny_drop();\n                     }\n                 }\n-                self.assign(dest);\n+                self.assign(dest, location);\n             }\n         } else {\n             // Qualify any operands inside other terminators.\n-            self.super_terminator_kind(bb, kind);\n+            self.super_terminator_kind(bb, kind, location);\n         }\n     }\n \n-    fn visit_assign(&mut self, _: BasicBlock, dest: &Lvalue<'tcx>, rvalue: &Rvalue<'tcx>) {\n-        self.visit_rvalue(rvalue);\n+    fn visit_assign(&mut self,\n+                    _: BasicBlock,\n+                    dest: &Lvalue<'tcx>,\n+                    rvalue: &Rvalue<'tcx>,\n+                    location: Location) {\n+        self.visit_rvalue(rvalue, location);\n \n         // Check the allowed const fn argument forms.\n         if let (Mode::ConstFn, &Lvalue::Var(index)) = (self.mode, dest) {\n@@ -857,38 +861,32 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n         }\n \n-        self.assign(dest);\n+        self.assign(dest, location);\n     }\n \n     fn visit_source_info(&mut self, source_info: &SourceInfo) {\n         self.span = source_info.span;\n     }\n \n-    fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>) {\n-        assert_eq!(self.location.block, bb);\n+    fn visit_statement(&mut self, bb: BasicBlock, statement: &Statement<'tcx>, location: Location) {\n         self.nest(|this| {\n             this.visit_source_info(&statement.source_info);\n             match statement.kind {\n                 StatementKind::Assign(ref lvalue, ref rvalue) => {\n-                    this.visit_assign(bb, lvalue, rvalue);\n+                    this.visit_assign(bb, lvalue, rvalue, location);\n                 }\n                 StatementKind::SetDiscriminant { .. } |\n                 StatementKind::StorageLive(_) |\n                 StatementKind::StorageDead(_) => {}\n             }\n         });\n-        self.location.statement_index += 1;\n-    }\n-\n-    fn visit_terminator(&mut self, bb: BasicBlock, terminator: &Terminator<'tcx>) {\n-        assert_eq!(self.location.block, bb);\n-        self.nest(|this| this.super_terminator(bb, terminator));\n     }\n \n-    fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n-        self.location.statement_index = 0;\n-        self.location.block = bb;\n-        self.super_basic_block_data(bb, data);\n+    fn visit_terminator(&mut self,\n+                        bb: BasicBlock,\n+                        terminator: &Terminator<'tcx>,\n+                        location: Location) {\n+        self.nest(|this| this.super_terminator(bb, terminator, location));\n     }\n }\n "}, {"sha": "21d4ae595e8ac2462023fdca6fe34b0a81cd9419", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -68,17 +68,20 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_lvalue(&mut self, lvalue: &Lvalue<'tcx>, _context: visit::LvalueContext) {\n-        self.sanitize_lvalue(lvalue);\n+    fn visit_lvalue(&mut self,\n+                    lvalue: &Lvalue<'tcx>,\n+                    _context: visit::LvalueContext,\n+                    location: Location) {\n+        self.sanitize_lvalue(lvalue, location);\n     }\n \n-    fn visit_constant(&mut self, constant: &Constant<'tcx>) {\n-        self.super_constant(constant);\n+    fn visit_constant(&mut self, constant: &Constant<'tcx>, location: Location) {\n+        self.super_constant(constant, location);\n         self.sanitize_type(constant, constant.ty);\n     }\n \n-    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>) {\n-        self.super_rvalue(rvalue);\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        self.super_rvalue(rvalue, location);\n         if let Some(ty) = rvalue.ty(self.mir, self.tcx()) {\n             self.sanitize_type(rvalue, ty);\n         }\n@@ -124,7 +127,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn sanitize_lvalue(&mut self, lvalue: &Lvalue<'tcx>) -> LvalueTy<'tcx> {\n+    fn sanitize_lvalue(&mut self, lvalue: &Lvalue<'tcx>, location: Location) -> LvalueTy<'tcx> {\n         debug!(\"sanitize_lvalue: {:?}\", lvalue);\n         match *lvalue {\n             Lvalue::Var(index) => LvalueTy::Ty { ty: self.mir.var_decls[index].ty },\n@@ -136,22 +139,23 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 LvalueTy::Ty { ty: self.mir.return_ty }\n             }\n             Lvalue::Projection(ref proj) => {\n-                let base_ty = self.sanitize_lvalue(&proj.base);\n+                let base_ty = self.sanitize_lvalue(&proj.base, location);\n                 if let LvalueTy::Ty { ty } = base_ty {\n                     if ty.references_error() {\n                         assert!(self.errors_reported);\n                         return LvalueTy::Ty { ty: self.tcx().types.err };\n                     }\n                 }\n-                self.sanitize_projection(base_ty, &proj.elem, lvalue)\n+                self.sanitize_projection(base_ty, &proj.elem, lvalue, location)\n             }\n         }\n     }\n \n     fn sanitize_projection(&mut self,\n                            base: LvalueTy<'tcx>,\n                            pi: &LvalueElem<'tcx>,\n-                           lvalue: &Lvalue<'tcx>)\n+                           lvalue: &Lvalue<'tcx>,\n+                           location: Location)\n                            -> LvalueTy<'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, lvalue);\n         let tcx = self.tcx();\n@@ -168,7 +172,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 }\n             }\n             ProjectionElem::Index(ref i) => {\n-                self.visit_operand(i);\n+                self.visit_operand(i, location);\n                 let index_ty = i.ty(self.mir, tcx);\n                 if index_ty != tcx.types.usize {\n                     LvalueTy::Ty {"}, {"sha": "c11e696302d345eb8b9ef4b081b3ce485ff5ada7", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -201,6 +201,7 @@ use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::repr as mir;\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n+use rustc::mir::repr::Location;\n \n use rustc_const_eval as const_eval;\n \n@@ -446,7 +447,7 @@ struct MirNeighborCollector<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n-    fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>) {\n+    fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: Location) {\n         debug!(\"visiting rvalue {:?}\", *rvalue);\n \n         match *rvalue {\n@@ -517,12 +518,13 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             _ => { /* not interesting */ }\n         }\n \n-        self.super_rvalue(rvalue);\n+        self.super_rvalue(rvalue, location);\n     }\n \n     fn visit_lvalue(&mut self,\n                     lvalue: &mir::Lvalue<'tcx>,\n-                    context: mir_visit::LvalueContext) {\n+                    context: mir_visit::LvalueContext,\n+                    location: Location) {\n         debug!(\"visiting lvalue {:?}\", *lvalue);\n \n         if let mir_visit::LvalueContext::Drop = context {\n@@ -537,10 +539,10 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             self.output.push(TransItem::DropGlue(DropGlueKind::Ty(ty)));\n         }\n \n-        self.super_lvalue(lvalue, context);\n+        self.super_lvalue(lvalue, context, location);\n     }\n \n-    fn visit_operand(&mut self, operand: &mir::Operand<'tcx>) {\n+    fn visit_operand(&mut self, operand: &mir::Operand<'tcx>, location: Location) {\n         debug!(\"visiting operand {:?}\", *operand);\n \n         let callee = match *operand {\n@@ -620,7 +622,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             }\n         }\n \n-        self.super_operand(operand);\n+        self.super_operand(operand, location);\n \n         fn can_result_in_trans_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                               def_id: DefId)\n@@ -654,7 +656,8 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n     // we would not register drop-glues.\n     fn visit_terminator_kind(&mut self,\n                              block: mir::BasicBlock,\n-                             kind: &mir::TerminatorKind<'tcx>) {\n+                             kind: &mir::TerminatorKind<'tcx>,\n+                             location: Location) {\n         let tcx = self.scx.tcx();\n         match *kind {\n             mir::TerminatorKind::Call {\n@@ -682,7 +685,7 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n             _ => { /* Nothing to do. */ }\n         }\n \n-        self.super_terminator_kind(block, kind);\n+        self.super_terminator_kind(block, kind, location);\n \n         fn is_drop_in_place_intrinsic<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                                 def_id: DefId,"}, {"sha": "cfd1ec09968616d7f118382e19809ef09c9d4852", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc::mir::repr as mir;\n use rustc::mir::repr::TerminatorKind;\n+use rustc::mir::repr::Location;\n use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use common::{self, Block, BlockAndBuilder};\n@@ -104,7 +105,8 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n     fn visit_assign(&mut self,\n                     block: mir::BasicBlock,\n                     lvalue: &mir::Lvalue<'tcx>,\n-                    rvalue: &mir::Rvalue<'tcx>) {\n+                    rvalue: &mir::Rvalue<'tcx>,\n+                    location: Location) {\n         debug!(\"visit_assign(block={:?}, lvalue={:?}, rvalue={:?})\", block, lvalue, rvalue);\n \n         if let Some(index) = self.mir.local_index(lvalue) {\n@@ -113,15 +115,16 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n                 self.mark_as_lvalue(index);\n             }\n         } else {\n-            self.visit_lvalue(lvalue, LvalueContext::Store);\n+            self.visit_lvalue(lvalue, LvalueContext::Store, location);\n         }\n \n-        self.visit_rvalue(rvalue);\n+        self.visit_rvalue(rvalue, location);\n     }\n \n     fn visit_terminator_kind(&mut self,\n                              block: mir::BasicBlock,\n-                             kind: &mir::TerminatorKind<'tcx>) {\n+                             kind: &mir::TerminatorKind<'tcx>,\n+                             location: Location) {\n         match *kind {\n             mir::TerminatorKind::Call {\n                 func: mir::Operand::Constant(mir::Constant {\n@@ -133,18 +136,19 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n                 if let mir::Operand::Consume(ref lvalue) = args[0] {\n-                    self.visit_lvalue(lvalue, LvalueContext::Drop);\n+                    self.visit_lvalue(lvalue, LvalueContext::Drop, location);\n                 }\n             }\n             _ => {}\n         }\n \n-        self.super_terminator_kind(block, kind);\n+        self.super_terminator_kind(block, kind, location);\n     }\n \n     fn visit_lvalue(&mut self,\n                     lvalue: &mir::Lvalue<'tcx>,\n-                    context: LvalueContext) {\n+                    context: LvalueContext,\n+                    location: Location) {\n         debug!(\"visit_lvalue(lvalue={:?}, context={:?})\", lvalue, context);\n \n         // Allow uses of projections of immediate pair fields.\n@@ -196,11 +200,11 @@ impl<'mir, 'bcx, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'bcx, 'tcx> {\n         // A deref projection only reads the pointer, never needs the lvalue.\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n             if let mir::ProjectionElem::Deref = proj.elem {\n-                return self.visit_lvalue(&proj.base, LvalueContext::Consume);\n+                return self.visit_lvalue(&proj.base, LvalueContext::Consume, location);\n             }\n         }\n \n-        self.super_lvalue(lvalue, context);\n+        self.super_lvalue(lvalue, context, location);\n     }\n }\n "}, {"sha": "f7b046b30cad7397c1652726fe6824e9b508d8bd", "filename": "src/test/run-pass-fulldeps/auxiliary/dummy_mir_pass.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7e2157dbab228e491919094f012af3ff8ce530c/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fauxiliary%2Fdummy_mir_pass.rs?ref=b7e2157dbab228e491919094f012af3ff8ce530c", "patch": "@@ -19,7 +19,7 @@ extern crate rustc_const_math;\n extern crate syntax;\n \n use rustc::mir::transform::{self, MirPass, MirSource};\n-use rustc::mir::repr::{Mir, Literal};\n+use rustc::mir::repr::{Mir, Literal, Location};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use rustc::middle::const_val::ConstVal;\n@@ -40,7 +40,7 @@ impl<'tcx> MirPass<'tcx> for Pass {\n struct Visitor;\n \n impl<'tcx> MutVisitor<'tcx> for Visitor {\n-    fn visit_literal(&mut self, literal: &mut Literal<'tcx>) {\n+    fn visit_literal(&mut self, literal: &mut Literal<'tcx>, _: Location) {\n         if let Literal::Value { ref mut value } = *literal {\n             if let ConstVal::Integral(ConstInt::I32(ref mut i @ 11)) = *value {\n                 *i = 42;"}]}