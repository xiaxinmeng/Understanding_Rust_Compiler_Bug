{"sha": "bc04a4eac47dcdc9feb3061dcc683e9d420227ab", "node_id": "C_kwDOAAsO6NoAKGJjMDRhNGVhYzQ3ZGNkYzlmZWIzMDYxZGNjNjgzZTlkNDIwMjI3YWI", "commit": {"author": {"name": "Tavian Barnes", "email": "tavianator@tavianator.com", "date": "2022-01-11T19:09:52Z"}, "committer": {"name": "Tavian Barnes", "email": "tavianator@tavianator.com", "date": "2022-01-21T12:59:14Z"}, "message": "fs: Use readdir() instead of readdir_r() on Linux\n\nreaddir() is preferred over readdir_r() on Linux and many other\nplatforms because it more gracefully supports long file names.  Both\nglibc and musl (and presumably all other Linux libc implementations)\nguarantee that readdir() is thread-safe as long as a single DIR* is not\naccessed concurrently, which is enough to make a readdir()-based\nimplementation of ReadDir safe.  This implementation is already used for\nsome other OSes including Fuchsia, Redox, and Solaris.\n\nSee #40021 for more details.  Fixes #86649.  Fixes #34668.", "tree": {"sha": "1f3a8c664eabf2c22cfebad02552bc92a3e72363", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f3a8c664eabf2c22cfebad02552bc92a3e72363"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc04a4eac47dcdc9feb3061dcc683e9d420227ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc04a4eac47dcdc9feb3061dcc683e9d420227ab", "html_url": "https://github.com/rust-lang/rust/commit/bc04a4eac47dcdc9feb3061dcc683e9d420227ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc04a4eac47dcdc9feb3061dcc683e9d420227ab/comments", "author": {"login": "tavianator", "id": 1692591, "node_id": "MDQ6VXNlcjE2OTI1OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1692591?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tavianator", "html_url": "https://github.com/tavianator", "followers_url": "https://api.github.com/users/tavianator/followers", "following_url": "https://api.github.com/users/tavianator/following{/other_user}", "gists_url": "https://api.github.com/users/tavianator/gists{/gist_id}", "starred_url": "https://api.github.com/users/tavianator/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tavianator/subscriptions", "organizations_url": "https://api.github.com/users/tavianator/orgs", "repos_url": "https://api.github.com/users/tavianator/repos", "events_url": "https://api.github.com/users/tavianator/events{/privacy}", "received_events_url": "https://api.github.com/users/tavianator/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tavianator", "id": 1692591, "node_id": "MDQ6VXNlcjE2OTI1OTE=", "avatar_url": "https://avatars.githubusercontent.com/u/1692591?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tavianator", "html_url": "https://github.com/tavianator", "followers_url": "https://api.github.com/users/tavianator/followers", "following_url": "https://api.github.com/users/tavianator/following{/other_user}", "gists_url": "https://api.github.com/users/tavianator/gists{/gist_id}", "starred_url": "https://api.github.com/users/tavianator/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tavianator/subscriptions", "organizations_url": "https://api.github.com/users/tavianator/orgs", "repos_url": "https://api.github.com/users/tavianator/repos", "events_url": "https://api.github.com/users/tavianator/events{/privacy}", "received_events_url": "https://api.github.com/users/tavianator/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3e92fec948f3875d1fa66d37c8e2599e6140215", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3e92fec948f3875d1fa66d37c8e2599e6140215", "html_url": "https://github.com/rust-lang/rust/commit/c3e92fec948f3875d1fa66d37c8e2599e6140215"}], "stats": {"total": 43, "additions": 30, "deletions": 13}, "files": [{"sha": "d1bd1f6d0ebd25b8a8fa6c66da942e867d3ac3c4", "filename": "library/std/src/sys/unix/fs.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bc04a4eac47dcdc9feb3061dcc683e9d420227ab/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc04a4eac47dcdc9feb3061dcc683e9d420227ab/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ffs.rs?ref=bc04a4eac47dcdc9feb3061dcc683e9d420227ab", "patch": "@@ -34,6 +34,17 @@ use libc::c_char;\n use libc::dirfd;\n #[cfg(any(target_os = \"linux\", target_os = \"emscripten\"))]\n use libc::fstatat64;\n+#[cfg(any(\n+    target_os = \"solaris\",\n+    target_os = \"fuchsia\",\n+    target_os = \"redox\",\n+    target_os = \"illumos\"\n+))]\n+use libc::readdir as readdir64;\n+#[cfg(target_os = \"linux\")]\n+use libc::readdir64;\n+#[cfg(any(target_os = \"emscripten\", target_os = \"l4re\"))]\n+use libc::readdir64_r;\n #[cfg(not(any(\n     target_os = \"linux\",\n     target_os = \"emscripten\",\n@@ -60,9 +71,7 @@ use libc::{\n     lstat as lstat64, off_t as off64_t, open as open64, stat as stat64,\n };\n #[cfg(any(target_os = \"linux\", target_os = \"emscripten\", target_os = \"l4re\"))]\n-use libc::{\n-    dirent64, fstat64, ftruncate64, lseek64, lstat64, off64_t, open64, readdir64_r, stat64,\n-};\n+use libc::{dirent64, fstat64, ftruncate64, lseek64, lstat64, off64_t, open64, stat64};\n \n pub use crate::sys_common::fs::try_exists;\n \n@@ -202,6 +211,7 @@ struct InnerReadDir {\n pub struct ReadDir {\n     inner: Arc<InnerReadDir>,\n     #[cfg(not(any(\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"fuchsia\",\n@@ -218,11 +228,11 @@ unsafe impl Sync for Dir {}\n pub struct DirEntry {\n     entry: dirent64,\n     dir: Arc<InnerReadDir>,\n-    // We need to store an owned copy of the entry name\n-    // on Solaris and Fuchsia because a) it uses a zero-length\n-    // array to store the name, b) its lifetime between readdir\n-    // calls is not guaranteed.\n+    // We need to store an owned copy of the entry name on platforms that use\n+    // readdir() (not readdir_r()), because a) struct dirent may use a flexible\n+    // array to store the name, b) it lives only until the next readdir() call.\n     #[cfg(any(\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"fuchsia\",\n@@ -449,6 +459,7 @@ impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n \n     #[cfg(any(\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"fuchsia\",\n         target_os = \"redox\",\n@@ -457,12 +468,13 @@ impl Iterator for ReadDir {\n     fn next(&mut self) -> Option<io::Result<DirEntry>> {\n         unsafe {\n             loop {\n-                // Although readdir_r(3) would be a correct function to use here because\n-                // of the thread safety, on Illumos and Fuchsia the readdir(3C) function\n-                // is safe to use in threaded applications and it is generally preferred\n-                // over the readdir_r(3C) function.\n+                // As of POSIX.1-2017, readdir() is not required to be thread safe; only\n+                // readdir_r() is. However, readdir_r() cannot correctly handle platforms\n+                // with unlimited or variable NAME_MAX.  Many modern platforms guarantee\n+                // thread safety for readdir() as long an individual DIR* is not accessed\n+                // concurrently, which is sufficient for Rust.\n                 super::os::set_errno(0);\n-                let entry_ptr = libc::readdir(self.inner.dirp.0);\n+                let entry_ptr = readdir64(self.inner.dirp.0);\n                 if entry_ptr.is_null() {\n                     // null can mean either the end is reached or an error occurred.\n                     // So we had to clear errno beforehand to check for an error now.\n@@ -486,6 +498,7 @@ impl Iterator for ReadDir {\n     }\n \n     #[cfg(not(any(\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"fuchsia\",\n         target_os = \"redox\",\n@@ -652,6 +665,7 @@ impl DirEntry {\n     }\n \n     #[cfg(not(any(\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"fuchsia\",\n@@ -661,6 +675,7 @@ impl DirEntry {\n         unsafe { CStr::from_ptr(self.entry.d_name.as_ptr()) }\n     }\n     #[cfg(any(\n+        target_os = \"linux\",\n         target_os = \"solaris\",\n         target_os = \"illumos\",\n         target_os = \"fuchsia\",\n@@ -1071,6 +1086,7 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n             Ok(ReadDir {\n                 inner: Arc::new(inner),\n                 #[cfg(not(any(\n+                    target_os = \"linux\",\n                     target_os = \"solaris\",\n                     target_os = \"illumos\",\n                     target_os = \"fuchsia\",\n@@ -1606,6 +1622,7 @@ mod remove_dir_impl {\n             ReadDir {\n                 inner: Arc::new(InnerReadDir { dirp, root: dummy_root }),\n                 #[cfg(not(any(\n+                    target_os = \"linux\",\n                     target_os = \"solaris\",\n                     target_os = \"illumos\",\n                     target_os = \"fuchsia\","}, {"sha": "7466c77356c7c40a35a5b1d23359e7ba9f7e799d", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bc04a4eac47dcdc9feb3061dcc683e9d420227ab/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc04a4eac47dcdc9feb3061dcc683e9d420227ab/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=bc04a4eac47dcdc9feb3061dcc683e9d420227ab", "patch": "@@ -75,7 +75,7 @@ pub fn errno() -> i32 {\n }\n \n /// Sets the platform-specific value of errno\n-#[cfg(all(not(target_os = \"linux\"), not(target_os = \"dragonfly\"), not(target_os = \"vxworks\")))] // needed for readdir and syscall!\n+#[cfg(all(not(target_os = \"dragonfly\"), not(target_os = \"vxworks\")))] // needed for readdir and syscall!\n #[allow(dead_code)] // but not all target cfgs actually end up using it\n pub fn set_errno(e: i32) {\n     unsafe { *errno_location() = e as c_int }"}]}