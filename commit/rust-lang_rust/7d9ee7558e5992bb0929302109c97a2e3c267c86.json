{"sha": "7d9ee7558e5992bb0929302109c97a2e3c267c86", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkOWVlNzU1OGU1OTkyYmIwOTI5MzAyMTA5Yzk3YTJlM2MyNjdjODY=", "commit": {"author": {"name": "WhizSid", "email": "whizsid@aol.com", "date": "2020-10-18T17:02:46Z"}, "committer": {"name": "Caleb Cartwright", "email": "calebcartwright@users.noreply.github.com", "date": "2020-11-29T19:26:58Z"}, "message": "Comment between typebounds (#4474)\n\n* Test cases and get spans\n\n* Fixed type bounds\n\n* Fixed issue of test cases\n\n* Fixed first test case issue\n\n* Removed unwanted whitespaces\n\n* Removed tmp files", "tree": {"sha": "27f0149b20c8cd4c5489641291b2c11cf7ed77e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/27f0149b20c8cd4c5489641291b2c11cf7ed77e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d9ee7558e5992bb0929302109c97a2e3c267c86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d9ee7558e5992bb0929302109c97a2e3c267c86", "html_url": "https://github.com/rust-lang/rust/commit/7d9ee7558e5992bb0929302109c97a2e3c267c86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d9ee7558e5992bb0929302109c97a2e3c267c86/comments", "author": {"login": "whizsid", "id": 44908250, "node_id": "MDQ6VXNlcjQ0OTA4MjUw", "avatar_url": "https://avatars.githubusercontent.com/u/44908250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/whizsid", "html_url": "https://github.com/whizsid", "followers_url": "https://api.github.com/users/whizsid/followers", "following_url": "https://api.github.com/users/whizsid/following{/other_user}", "gists_url": "https://api.github.com/users/whizsid/gists{/gist_id}", "starred_url": "https://api.github.com/users/whizsid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/whizsid/subscriptions", "organizations_url": "https://api.github.com/users/whizsid/orgs", "repos_url": "https://api.github.com/users/whizsid/repos", "events_url": "https://api.github.com/users/whizsid/events{/privacy}", "received_events_url": "https://api.github.com/users/whizsid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "823c4f820a46159661d681b6f982c6457c5eb0f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/823c4f820a46159661d681b6f982c6457c5eb0f6", "html_url": "https://github.com/rust-lang/rust/commit/823c4f820a46159661d681b6f982c6457c5eb0f6"}], "stats": {"total": 211, "additions": 167, "deletions": 44}, "files": [{"sha": "7eeee2ac979a867f3d17755b180a84261ea61daf", "filename": "src/types.rs", "status": "modified", "additions": 118, "deletions": 44, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/7d9ee7558e5992bb0929302109c97a2e3c267c86/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d9ee7558e5992bb0929302109c97a2e3c267c86/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=7d9ee7558e5992bb0929302109c97a2e3c267c86", "patch": "@@ -874,57 +874,131 @@ fn join_bounds(\n     items: &[ast::GenericBound],\n     need_indent: bool,\n ) -> Option<String> {\n-    debug_assert!(!items.is_empty());\n-\n-    // Try to join types in a single line\n-    let joiner = match context.config.type_punctuation_density() {\n-        TypeDensity::Compressed => \"+\",\n-        TypeDensity::Wide => \" + \",\n-    };\n-    let type_strs = items\n-        .iter()\n-        .map(|item| item.rewrite(context, shape))\n-        .collect::<Option<Vec<_>>>()?;\n-    let result = type_strs.join(joiner);\n-    if items.len() <= 1 || (!result.contains('\\n') && result.len() <= shape.width) {\n-        return Some(result);\n-    }\n+    join_bounds_inner(context, shape, items, need_indent, false)\n+}\n \n-    // We need to use multiple lines.\n-    let (type_strs, offset) = if need_indent {\n-        // Rewrite with additional indentation.\n-        let nested_shape = shape\n-            .block_indent(context.config.tab_spaces())\n-            .with_max_width(context.config);\n-        let type_strs = items\n-            .iter()\n-            .map(|item| item.rewrite(context, nested_shape))\n-            .collect::<Option<Vec<_>>>()?;\n-        (type_strs, nested_shape.indent)\n-    } else {\n-        (type_strs, shape.indent)\n-    };\n+fn join_bounds_inner(\n+    context: &RewriteContext<'_>,\n+    shape: Shape,\n+    items: &[ast::GenericBound],\n+    need_indent: bool,\n+    force_newline: bool,\n+) -> Option<String> {\n+    debug_assert!(!items.is_empty());\n \n+    let generic_bounds_in_order = is_generic_bounds_in_order(items);\n     let is_bound_extendable = |s: &str, b: &ast::GenericBound| match b {\n         ast::GenericBound::Outlives(..) => true,\n         ast::GenericBound::Trait(..) => last_line_extendable(s),\n     };\n-    let mut result = String::with_capacity(128);\n-    result.push_str(&type_strs[0]);\n-    let mut can_be_put_on_the_same_line = is_bound_extendable(&result, &items[0]);\n-    let generic_bounds_in_order = is_generic_bounds_in_order(items);\n-    for (bound, bound_str) in items[1..].iter().zip(type_strs[1..].iter()) {\n-        if generic_bounds_in_order && can_be_put_on_the_same_line {\n-            result.push_str(joiner);\n-        } else {\n-            result.push_str(&offset.to_string_with_newline(context.config));\n-            result.push_str(\"+ \");\n-        }\n-        result.push_str(bound_str);\n-        can_be_put_on_the_same_line = is_bound_extendable(bound_str, bound);\n-    }\n \n-    Some(result)\n+    let result = items.iter().enumerate().try_fold(\n+        (String::new(), None, false),\n+        |(strs, prev_trailing_span, prev_extendable), (i, item)| {\n+            let trailing_span = if i < items.len() - 1 {\n+                let hi = context\n+                    .snippet_provider\n+                    .span_before(mk_sp(items[i + 1].span().lo(), item.span().hi()), \"+\");\n+\n+                Some(mk_sp(item.span().hi(), hi))\n+            } else {\n+                None\n+            };\n+            let (leading_span, has_leading_comment) = if i > 0 {\n+                let lo = context\n+                    .snippet_provider\n+                    .span_after(mk_sp(items[i - 1].span().hi(), item.span().lo()), \"+\");\n+\n+                let span = mk_sp(lo, item.span().lo());\n+\n+                let has_comments = contains_comment(context.snippet(span));\n+\n+                (Some(mk_sp(lo, item.span().lo())), has_comments)\n+            } else {\n+                (None, false)\n+            };\n+            let prev_has_trailing_comment = match prev_trailing_span {\n+                Some(ts) => contains_comment(context.snippet(ts)),\n+                _ => false,\n+            };\n+\n+            let shape = if i > 0 && need_indent && force_newline {\n+                shape\n+                    .block_indent(context.config.tab_spaces())\n+                    .with_max_width(context.config)\n+            } else {\n+                shape\n+            };\n+            let whitespace = if force_newline && (!prev_extendable || !generic_bounds_in_order) {\n+                shape\n+                    .indent\n+                    .to_string_with_newline(context.config)\n+                    .to_string()\n+            } else {\n+                String::from(\" \")\n+            };\n+\n+            let joiner = match context.config.type_punctuation_density() {\n+                TypeDensity::Compressed => String::from(\"+\"),\n+                TypeDensity::Wide => whitespace + \"+ \",\n+            };\n+            let joiner = if has_leading_comment {\n+                joiner.trim_end()\n+            } else {\n+                &joiner\n+            };\n+            let joiner = if prev_has_trailing_comment {\n+                joiner.trim_start()\n+            } else {\n+                joiner\n+            };\n+\n+            let (trailing_str, extendable) = if i == 0 {\n+                let bound_str = item.rewrite(context, shape)?;\n+                let bound_str_clone = bound_str.clone();\n+                (bound_str, is_bound_extendable(&bound_str_clone, item))\n+            } else {\n+                let bound_str = &item.rewrite(context, shape)?;\n+                match leading_span {\n+                    Some(ls) if has_leading_comment => (\n+                        combine_strs_with_missing_comments(\n+                            context, joiner, bound_str, ls, shape, true,\n+                        )?,\n+                        is_bound_extendable(bound_str, item),\n+                    ),\n+                    _ => (\n+                        String::from(joiner) + bound_str,\n+                        is_bound_extendable(bound_str, item),\n+                    ),\n+                }\n+            };\n+            match prev_trailing_span {\n+                Some(ts) if prev_has_trailing_comment => combine_strs_with_missing_comments(\n+                    context,\n+                    &strs,\n+                    &trailing_str,\n+                    ts,\n+                    shape,\n+                    true,\n+                )\n+                .map(|v| (v, trailing_span, extendable)),\n+                _ => Some((\n+                    String::from(strs) + &trailing_str,\n+                    trailing_span,\n+                    extendable,\n+                )),\n+            }\n+        },\n+    )?;\n+\n+    if !force_newline\n+        && items.len() > 1\n+        && (result.0.contains('\\n') || result.0.len() > shape.width)\n+    {\n+        join_bounds_inner(context, shape, items, need_indent, true)\n+    } else {\n+        Some(result.0)\n+    }\n }\n \n pub(crate) fn can_be_overflowed_type("}, {"sha": "d8a27f7a4a408e391697ea8c30ce636b9690cfac", "filename": "tests/source/issue-4243.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7d9ee7558e5992bb0929302109c97a2e3c267c86/tests%2Fsource%2Fissue-4243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d9ee7558e5992bb0929302109c97a2e3c267c86/tests%2Fsource%2Fissue-4243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-4243.rs?ref=7d9ee7558e5992bb0929302109c97a2e3c267c86", "patch": "@@ -0,0 +1,21 @@\n+fn main() {\n+    type A: AA /*AA*/ + /*AB*/ AB \n++ AC = AA \n+/*AA*/ + \n+ /*AB*/ AB+AC;\n+\n+    type B: BA /*BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA*/+/*BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB*/ BB\n+   + BC = BA /*BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA*/ + /*BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB*/ BB+ BC;\n+\n+    type C: CA // CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA \n+// CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n+  +\n+        // CBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n+        // CBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n+   CB + CC = CA // CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n+    // CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n+    +\n+    // CBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n+        // CBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n+        CB+ CC;\n+}"}, {"sha": "67fa1d2a312fb51d5cd402e95ea7be1d6a7afa75", "filename": "tests/target/issue-4243.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/7d9ee7558e5992bb0929302109c97a2e3c267c86/tests%2Ftarget%2Fissue-4243.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d9ee7558e5992bb0929302109c97a2e3c267c86/tests%2Ftarget%2Fissue-4243.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-4243.rs?ref=7d9ee7558e5992bb0929302109c97a2e3c267c86", "patch": "@@ -0,0 +1,28 @@\n+fn main() {\n+    type A: AA /*AA*/ + /*AB*/ AB + AC = AA\n+        /*AA*/\n+        +\n+        /*AB*/\n+        AB\n+        + AC;\n+\n+    type B: BA /*BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA*/\n+        + /*BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB*/ BB\n+        + BC = BA /*BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA*/\n+        + /*BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB*/ BB\n+        + BC;\n+\n+    type C: CA // CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n+        // CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n+        +\n+        // CBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n+        // CBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n+        CB\n+        + CC = CA // CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n+        // CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n+        +\n+        // CBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n+        // CBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB\n+        CB\n+        + CC;\n+}"}]}