{"sha": "8276dac08183e374d27b2c3165d10b9dfcde09b3", "node_id": "C_kwDOAAsO6NoAKDgyNzZkYWMwODE4M2UzNzRkMjdiMmMzMTY1ZDEwYjlkZmNkZTA5YjM", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-19T14:30:32Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-22T17:16:15Z"}, "message": "Mark inherent impls as using the type during liveness collection.", "tree": {"sha": "12c55cb03d23eaea5b6a37223a9eed45833f9e35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12c55cb03d23eaea5b6a37223a9eed45833f9e35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8276dac08183e374d27b2c3165d10b9dfcde09b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8276dac08183e374d27b2c3165d10b9dfcde09b3", "html_url": "https://github.com/rust-lang/rust/commit/8276dac08183e374d27b2c3165d10b9dfcde09b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8276dac08183e374d27b2c3165d10b9dfcde09b3/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10f4ce324baf7cfb7ce2b2096662b82b79204944", "url": "https://api.github.com/repos/rust-lang/rust/commits/10f4ce324baf7cfb7ce2b2096662b82b79204944", "html_url": "https://github.com/rust-lang/rust/commit/10f4ce324baf7cfb7ce2b2096662b82b79204944"}], "stats": {"total": 46, "additions": 21, "deletions": 25}, "files": [{"sha": "648090f2b4d57d1ce0303cea23a85e83888e01de", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 21, "deletions": 25, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/8276dac08183e374d27b2c3165d10b9dfcde09b3/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8276dac08183e374d27b2c3165d10b9dfcde09b3/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=8276dac08183e374d27b2c3165d10b9dfcde09b3", "patch": "@@ -285,20 +285,33 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n                     let def = self.tcx.adt_def(item.def_id);\n                     self.repr_has_repr_c = def.repr().c();\n \n-                    intravisit::walk_item(self, &item);\n-                }\n-                hir::ItemKind::Enum(..) => {\n-                    intravisit::walk_item(self, &item);\n+                    intravisit::walk_item(self, &item)\n                 }\n                 hir::ItemKind::ForeignMod { .. } => {}\n-                _ => {\n-                    intravisit::walk_item(self, &item);\n-                }\n+                _ => intravisit::walk_item(self, &item),\n             },\n             Node::TraitItem(trait_item) => {\n                 intravisit::walk_trait_item(self, trait_item);\n             }\n             Node::ImplItem(impl_item) => {\n+                let item = self.tcx.local_parent(impl_item.def_id);\n+                if self.tcx.impl_trait_ref(item).is_none() {\n+                    //// If it's a type whose items are live, then it's live, too.\n+                    //// This is done to handle the case where, for example, the static\n+                    //// method of a private type is used, but the type itself is never\n+                    //// called directly.\n+                    let self_ty = self.tcx.type_of(item);\n+                    match *self_ty.kind() {\n+                        ty::Adt(def, _) => self.check_def_id(def.did()),\n+                        ty::Foreign(did) => self.check_def_id(did),\n+                        ty::Dynamic(data, ..) => {\n+                            if let Some(def_id) = data.principal_def_id() {\n+                                self.check_def_id(def_id)\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n                 intravisit::walk_impl_item(self, impl_item);\n             }\n             Node::ForeignItem(foreign_item) => {\n@@ -671,24 +684,7 @@ impl<'tcx> DeadVisitor<'tcx> {\n \n     // id := HIR id of an item's definition.\n     fn symbol_is_live(&mut self, def_id: LocalDefId) -> bool {\n-        if self.live_symbols.contains(&def_id) {\n-            return true;\n-        }\n-        // If it's a type whose items are live, then it's live, too.\n-        // This is done to handle the case where, for example, the static\n-        // method of a private type is used, but the type itself is never\n-        // called directly.\n-        let inherent_impls = self.tcx.inherent_impls(def_id);\n-        for &impl_did in inherent_impls.iter() {\n-            for item_did in self.tcx.associated_item_def_ids(impl_did) {\n-                if let Some(def_id) = item_did.as_local()\n-                    && self.live_symbols.contains(&def_id)\n-                {\n-                    return true;\n-                }\n-            }\n-        }\n-        false\n+        self.live_symbols.contains(&def_id)\n     }\n \n     fn warn_multiple_dead_codes("}]}