{"sha": "acb43ce573563efa74027fb485032347a93c1a3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjYjQzY2U1NzM1NjNlZmE3NDAyN2ZiNDg1MDMyMzQ3YTkzYzFhM2M=", "commit": {"author": {"name": "Corey Farwell", "email": "coreyf@rwell.org", "date": "2017-04-11T22:36:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-04-11T22:36:12Z"}, "message": "Rollup merge of #40559 - nagisa:manually-drop, r=alexcrichton\n\nImplement Manually Drop\n\nAs the RFC has been from approx a week in FCP without any major comments, I\u2019m taking the opportunity to submit the PR early.", "tree": {"sha": "22c50c46e586f0e2e68d4214f783bbf5808b8b58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/22c50c46e586f0e2e68d4214f783bbf5808b8b58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/acb43ce573563efa74027fb485032347a93c1a3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/acb43ce573563efa74027fb485032347a93c1a3c", "html_url": "https://github.com/rust-lang/rust/commit/acb43ce573563efa74027fb485032347a93c1a3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/acb43ce573563efa74027fb485032347a93c1a3c/comments", "author": {"login": "frewsxcv", "id": 416575, "node_id": "MDQ6VXNlcjQxNjU3NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/416575?v=4", "gravatar_id": "", "url": "https://api.github.com/users/frewsxcv", "html_url": "https://github.com/frewsxcv", "followers_url": "https://api.github.com/users/frewsxcv/followers", "following_url": "https://api.github.com/users/frewsxcv/following{/other_user}", "gists_url": "https://api.github.com/users/frewsxcv/gists{/gist_id}", "starred_url": "https://api.github.com/users/frewsxcv/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/frewsxcv/subscriptions", "organizations_url": "https://api.github.com/users/frewsxcv/orgs", "repos_url": "https://api.github.com/users/frewsxcv/repos", "events_url": "https://api.github.com/users/frewsxcv/events{/privacy}", "received_events_url": "https://api.github.com/users/frewsxcv/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f6f4eb7c386b01dec8c0337a600365407ba6a56", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f6f4eb7c386b01dec8c0337a600365407ba6a56", "html_url": "https://github.com/rust-lang/rust/commit/4f6f4eb7c386b01dec8c0337a600365407ba6a56"}, {"sha": "c337b99f4cb0968481a03195d25358b484d7db22", "url": "https://api.github.com/repos/rust-lang/rust/commits/c337b99f4cb0968481a03195d25358b484d7db22", "html_url": "https://github.com/rust-lang/rust/commit/c337b99f4cb0968481a03195d25358b484d7db22"}], "stats": {"total": 211, "additions": 147, "deletions": 64}, "files": [{"sha": "54e602a81db7389e93e2eb682e8c2371ce423223", "filename": "src/doc/unstable-book/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2FSUMMARY.md?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -114,6 +114,7 @@\n - [loop_break_value](loop-break-value.md)\n - [macro_reexport](macro-reexport.md)\n - [main](main.md)\n+- [manually_drop](manually-drop.md)\n - [map_entry_recover_keys](map-entry-recover-keys.md)\n - [mpsc_select](mpsc-select.md)\n - [n16](n16.md)"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/doc/unstable-book/src/manually-drop.md", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Fdoc%2Funstable-book%2Fsrc%2Fmanually-drop.md", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Fdoc%2Funstable-book%2Fsrc%2Fmanually-drop.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fmanually-drop.md?ref=acb43ce573563efa74027fb485032347a93c1a3c"}, {"sha": "99afd08e81183eb451df419c93a633b43456bb9c", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -44,6 +44,7 @@\n #![feature(heap_api)]\n #![feature(inclusive_range)]\n #![feature(lang_items)]\n+#![feature(manually_drop)]\n #![feature(nonzero)]\n #![feature(pattern)]\n #![feature(placement_in)]"}, {"sha": "3069adb12e92cd127c5bd29d03d266da23d49df4", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -1558,7 +1558,7 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n             //    performance than with the 2nd method.\n             //\n             // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n-            let mut tmp = NoDrop { value: ptr::read(&v[0]) };\n+            let mut tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n \n             // Intermediate state of the insertion process is always tracked by `hole`, which\n             // serves two purposes:\n@@ -1571,13 +1571,13 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n             let mut hole = InsertionHole {\n-                src: &mut tmp.value,\n+                src: &mut *tmp,\n                 dest: &mut v[1],\n             };\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n-                if !is_less(&v[i], &tmp.value) {\n+                if !is_less(&v[i], &*tmp) {\n                     break;\n                 }\n                 ptr::copy_nonoverlapping(&v[i], &mut v[i - 1], 1);\n@@ -1587,12 +1587,6 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n         }\n     }\n \n-    // Holds a value, but never drops it.\n-    #[allow(unions_with_drop_fields)]\n-    union NoDrop<T> {\n-        value: T\n-    }\n-\n     // When dropped, copies from `src` into `dest`.\n     struct InsertionHole<T> {\n         src: *mut T,"}, {"sha": "b0287631585125a9febd3fb903e5d51e2358ae8e", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -691,9 +691,6 @@ extern \"rust-intrinsic\" {\n     /// initialize memory previous set to the result of `uninit`.\n     pub fn uninit<T>() -> T;\n \n-    /// Moves a value out of scope without running drop glue.\n-    pub fn forget<T>(_: T) -> ();\n-\n     /// Reinterprets the bits of a value of one type as another type.\n     ///\n     /// Both types must have the same size. Neither the original, nor the result,"}, {"sha": "7be927b28ed7eb7ecfef5fcc8da2ab1d0cdc9410", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 119, "deletions": 1, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -171,7 +171,7 @@ pub use intrinsics::transmute;\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn forget<T>(t: T) {\n-    unsafe { intrinsics::forget(t) }\n+    ManuallyDrop::new(t);\n }\n \n /// Returns the size of a type in bytes.\n@@ -736,3 +736,121 @@ pub fn discriminant<T>(v: &T) -> Discriminant<T> {\n     }\n }\n \n+\n+/// A wrapper to inhibit compiler from automatically calling `T`\u2019s destructor.\n+///\n+/// This wrapper is 0-cost.\n+///\n+/// # Examples\n+///\n+/// This wrapper helps with explicitly documenting the drop order dependencies between fields of\n+/// the type:\n+///\n+/// ```rust\n+/// # #![feature(manually_drop)]\n+/// use std::mem::ManuallyDrop;\n+/// struct Peach;\n+/// struct Banana;\n+/// struct Melon;\n+/// struct FruitBox {\n+///     // Immediately clear there\u2019s something non-trivial going on with these fields.\n+///     peach: ManuallyDrop<Peach>,\n+///     melon: Melon, // Field that\u2019s independent of the other two.\n+///     banana: ManuallyDrop<Banana>,\n+/// }\n+///\n+/// impl Drop for FruitBox {\n+///     fn drop(&mut self) {\n+///         unsafe {\n+///             // Explicit ordering in which field destructors are run specified in the intuitive\n+///             // location \u2013 the destructor of the structure containing the fields.\n+///             // Moreover, one can now reorder fields within the struct however much they want.\n+///             ManuallyDrop::drop(&mut self.peach);\n+///             ManuallyDrop::drop(&mut self.banana);\n+///         }\n+///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n+///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n+///     }\n+/// }\n+/// ```\n+#[unstable(feature = \"manually_drop\", issue = \"40673\")]\n+#[allow(unions_with_drop_fields)]\n+pub union ManuallyDrop<T>{ value: T }\n+\n+impl<T> ManuallyDrop<T> {\n+    /// Wrap a value to be manually dropped.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// # #![feature(manually_drop)]\n+    /// use std::mem::ManuallyDrop;\n+    /// ManuallyDrop::new(Box::new(()));\n+    /// ```\n+    #[unstable(feature = \"manually_drop\", issue = \"40673\")]\n+    #[inline]\n+    pub fn new(value: T) -> ManuallyDrop<T> {\n+        ManuallyDrop { value: value }\n+    }\n+\n+    /// Extract the value from the ManuallyDrop container.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// # #![feature(manually_drop)]\n+    /// use std::mem::ManuallyDrop;\n+    /// let x = ManuallyDrop::new(Box::new(()));\n+    /// let _: Box<()> = ManuallyDrop::into_inner(x);\n+    /// ```\n+    #[unstable(feature = \"manually_drop\", issue = \"40673\")]\n+    #[inline]\n+    pub fn into_inner(slot: ManuallyDrop<T>) -> T {\n+        unsafe {\n+            slot.value\n+        }\n+    }\n+\n+    /// Manually drops the contained value.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function runs the destructor of the contained value and thus the wrapped value\n+    /// now represents uninitialized data. It is up to the user of this method to ensure the\n+    /// uninitialized data is not actually used.\n+    #[unstable(feature = \"manually_drop\", issue = \"40673\")]\n+    #[inline]\n+    pub unsafe fn drop(slot: &mut ManuallyDrop<T>) {\n+        ptr::drop_in_place(&mut slot.value)\n+    }\n+}\n+\n+#[unstable(feature = \"manually_drop\", issue = \"40673\")]\n+impl<T> ::ops::Deref for ManuallyDrop<T> {\n+    type Target = T;\n+    #[inline]\n+    fn deref(&self) -> &Self::Target {\n+        unsafe {\n+            &self.value\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"manually_drop\", issue = \"40673\")]\n+impl<T> ::ops::DerefMut for ManuallyDrop<T> {\n+    #[inline]\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        unsafe {\n+            &mut self.value\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"manually_drop\", issue = \"40673\")]\n+impl<T: ::fmt::Debug> ::fmt::Debug for ManuallyDrop<T> {\n+    fn fmt(&self, fmt: &mut ::fmt::Formatter) -> ::fmt::Result {\n+        unsafe {\n+            fmt.debug_tuple(\"ManuallyDrop\").field(&self.value).finish()\n+        }\n+    }\n+}"}, {"sha": "6f9f2915dfe102c1fe6022d660816e69279152ed", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -20,12 +20,6 @@ use cmp;\n use mem;\n use ptr;\n \n-/// Holds a value, but never drops it.\n-#[allow(unions_with_drop_fields)]\n-union NoDrop<T> {\n-    value: T\n-}\n-\n /// When dropped, copies from `src` into `dest`.\n struct CopyOnDrop<T> {\n     src: *mut T,\n@@ -49,15 +43,15 @@ fn shift_head<T, F>(v: &mut [T], is_less: &mut F)\n             // Read the first element into a stack-allocated variable. If a following comparison\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n-            let mut tmp = NoDrop { value: ptr::read(v.get_unchecked(0)) };\n+            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n             let mut hole = CopyOnDrop {\n-                src: &mut tmp.value,\n+                src: &mut *tmp,\n                 dest: v.get_unchecked_mut(1),\n             };\n             ptr::copy_nonoverlapping(v.get_unchecked(1), v.get_unchecked_mut(0), 1);\n \n             for i in 2..len {\n-                if !is_less(v.get_unchecked(i), &tmp.value) {\n+                if !is_less(v.get_unchecked(i), &*tmp) {\n                     break;\n                 }\n \n@@ -81,15 +75,15 @@ fn shift_tail<T, F>(v: &mut [T], is_less: &mut F)\n             // Read the last element into a stack-allocated variable. If a following comparison\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n-            let mut tmp = NoDrop { value: ptr::read(v.get_unchecked(len - 1)) };\n+            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n             let mut hole = CopyOnDrop {\n-                src: &mut tmp.value,\n+                src: &mut *tmp,\n                 dest: v.get_unchecked_mut(len - 2),\n             };\n             ptr::copy_nonoverlapping(v.get_unchecked(len - 2), v.get_unchecked_mut(len - 1), 1);\n \n             for i in (0..len-2).rev() {\n-                if !is_less(&tmp.value, v.get_unchecked(i)) {\n+                if !is_less(&*tmp, v.get_unchecked(i)) {\n                     break;\n                 }\n \n@@ -403,12 +397,12 @@ fn partition<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> (usize, bool)\n \n         // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n         // operation panics, the pivot will be automatically written back into the slice.\n-        let mut tmp = NoDrop { value: unsafe { ptr::read(pivot) } };\n+        let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n         let _pivot_guard = CopyOnDrop {\n-            src: unsafe { &mut tmp.value },\n+            src: &mut *tmp,\n             dest: pivot,\n         };\n-        let pivot = unsafe { &tmp.value };\n+        let pivot = &*tmp;\n \n         // Find the first pair of out-of-order elements.\n         let mut l = 0;\n@@ -452,12 +446,12 @@ fn partition_equal<T, F>(v: &mut [T], pivot: usize, is_less: &mut F) -> usize\n \n     // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n     // operation panics, the pivot will be automatically written back into the slice.\n-    let mut tmp = NoDrop { value: unsafe { ptr::read(pivot) } };\n+    let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n     let _pivot_guard = CopyOnDrop {\n-        src: unsafe { &mut tmp.value },\n+        src: &mut *tmp,\n         dest: pivot,\n     };\n-    let pivot = unsafe { &tmp.value };\n+    let pivot = &*tmp;\n \n     // Now partition the slice.\n     let mut l = 0;"}, {"sha": "adb22197226023fcb80731626f1ecc97255275f7", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -20,10 +20,11 @@ use std::fmt;\n use std::mem;\n use std::collections::range::RangeArgument;\n use std::collections::Bound::{Excluded, Included, Unbounded};\n+use std::mem::ManuallyDrop;\n \n pub unsafe trait Array {\n     type Element;\n-    type PartialStorage: Default + Unsize<[ManuallyDrop<Self::Element>]>;\n+    type PartialStorage: Unsize<[ManuallyDrop<Self::Element>]>;\n     const LEN: usize;\n }\n \n@@ -66,7 +67,7 @@ impl<A: Array> ArrayVec<A> {\n     pub fn new() -> Self {\n         ArrayVec {\n             count: 0,\n-            values: Default::default(),\n+            values: unsafe { ::std::mem::uninitialized() },\n         }\n     }\n \n@@ -81,7 +82,7 @@ impl<A: Array> ArrayVec<A> {\n     /// Panics when the stack vector is full.\n     pub fn push(&mut self, el: A::Element) {\n         let arr = &mut self.values as &mut [ManuallyDrop<_>];\n-        arr[self.count] = ManuallyDrop { value: el };\n+        arr[self.count] = ManuallyDrop::new(el);\n         self.count += 1;\n     }\n \n@@ -90,8 +91,8 @@ impl<A: Array> ArrayVec<A> {\n             let arr = &mut self.values as &mut [ManuallyDrop<_>];\n             self.count -= 1;\n             unsafe {\n-                let value = ptr::read(&arr[self.count]);\n-                Some(value.value)\n+                let value = ptr::read(&*arr[self.count]);\n+                Some(value)\n             }\n         } else {\n             None\n@@ -210,7 +211,7 @@ impl<A: Array> Iterator for Iter<A> {\n     fn next(&mut self) -> Option<A::Element> {\n         let arr = &self.store as &[ManuallyDrop<_>];\n         unsafe {\n-            self.indices.next().map(|i| ptr::read(&arr[i]).value)\n+            self.indices.next().map(|i| ptr::read(&*arr[i]))\n         }\n     }\n \n@@ -233,7 +234,7 @@ impl<'a, A: Array> Iterator for Drain<'a, A> {\n \n     #[inline]\n     fn next(&mut self) -> Option<A::Element> {\n-        self.iter.next().map(|elt| unsafe { ptr::read(elt as *const ManuallyDrop<_>).value })\n+        self.iter.next().map(|elt| unsafe { ptr::read(&**elt) })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -295,25 +296,3 @@ impl<'a, A: Array> IntoIterator for &'a mut ArrayVec<A> {\n         self.iter_mut()\n     }\n }\n-\n-// FIXME: This should use repr(transparent) from rust-lang/rfcs#1758.\n-#[allow(unions_with_drop_fields)]\n-pub union ManuallyDrop<T> {\n-    value: T,\n-    #[allow(dead_code)]\n-    empty: (),\n-}\n-\n-impl<T> ManuallyDrop<T> {\n-    fn new() -> ManuallyDrop<T> {\n-        ManuallyDrop {\n-            empty: ()\n-        }\n-    }\n-}\n-\n-impl<T> Default for ManuallyDrop<T> {\n-    fn default() -> Self {\n-        ManuallyDrop::new()\n-    }\n-}"}, {"sha": "72c533a74618b8185eae1cb22807539ef56cdb4f", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -39,6 +39,7 @@\n #![feature(conservative_impl_trait)]\n #![feature(discriminant_value)]\n #![feature(specialization)]\n+#![feature(manually_drop)]\n \n #![cfg_attr(unix, feature(libc))]\n #![cfg_attr(test, feature(test))]"}, {"sha": "7077eade61182af2387119e8dd0801d8e3b48062", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -186,7 +186,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             C_nil(ccx)\n         }\n         // Effectively no-ops\n-        \"uninit\" | \"forget\" => {\n+        \"uninit\" => {\n             C_nil(ccx)\n         }\n         \"needs_drop\" => {"}, {"sha": "cd58fcd4806da62d104e61679c7a9527ae71bad6", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -124,7 +124,6 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             \"rustc_peek\" => (1, vec![param(0)], param(0)),\n             \"init\" => (1, Vec::new(), param(0)),\n             \"uninit\" => (1, Vec::new(), param(0)),\n-            \"forget\" => (1, vec![ param(0) ], tcx.mk_nil()),\n             \"transmute\" => (2, vec![ param(0) ], param(1)),\n             \"move_val_init\" => {\n                 (1,"}, {"sha": "48c9fda31e8c80707674537252d6a2fe4306d0a9", "filename": "src/test/compile-fail/forget-init-unsafe.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/acb43ce573563efa74027fb485032347a93c1a3c/src%2Ftest%2Fcompile-fail%2Fforget-init-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/acb43ce573563efa74027fb485032347a93c1a3c/src%2Ftest%2Fcompile-fail%2Fforget-init-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fforget-init-unsafe.rs?ref=acb43ce573563efa74027fb485032347a93c1a3c", "patch": "@@ -10,10 +10,9 @@\n \n #![feature(core_intrinsics)]\n \n-use std::intrinsics::{init, forget};\n+use std::intrinsics::{init};\n \n // Test that the `forget` and `init` intrinsics are really unsafe\n pub fn main() {\n     let stuff = init::<isize>(); //~ ERROR call to unsafe function requires unsafe\n-    forget(stuff);             //~ ERROR call to unsafe function requires unsafe\n }"}]}