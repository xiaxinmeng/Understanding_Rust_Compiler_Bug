{"sha": "7579663199a6f44545b5b5bb448d3b7d5ecfb88c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1Nzk2NjMxOTlhNmY0NDU0NWI1YjViYjQ0OGQzYjdkNWVjZmI4OGM=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-28T14:52:42Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-12-31T14:56:28Z"}, "message": "Extract temporal_order function", "tree": {"sha": "4f78c5396d33a72608bf36dc28102c7c726369ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4f78c5396d33a72608bf36dc28102c7c726369ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7579663199a6f44545b5b5bb448d3b7d5ecfb88c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7579663199a6f44545b5b5bb448d3b7d5ecfb88c", "html_url": "https://github.com/rust-lang/rust/commit/7579663199a6f44545b5b5bb448d3b7d5ecfb88c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7579663199a6f44545b5b5bb448d3b7d5ecfb88c/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9022e09a3e23e3dd81ad7fe4b8a3c177aa6cc344", "url": "https://api.github.com/repos/rust-lang/rust/commits/9022e09a3e23e3dd81ad7fe4b8a3c177aa6cc344", "html_url": "https://github.com/rust-lang/rust/commit/9022e09a3e23e3dd81ad7fe4b8a3c177aa6cc344"}], "stats": {"total": 90, "additions": 64, "deletions": 26}, "files": [{"sha": "64f7ab04503685e49ea8591ab15ba8a94546ef95", "filename": "src/optimize/stack2reg.rs", "status": "modified", "additions": 64, "deletions": 26, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7579663199a6f44545b5b5bb448d3b7d5ecfb88c/src%2Foptimize%2Fstack2reg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7579663199a6f44545b5b5bb448d3b7d5ecfb88c/src%2Foptimize%2Fstack2reg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fstack2reg.rs?ref=7579663199a6f44545b5b5bb448d3b7d5ecfb88c", "patch": "@@ -74,6 +74,8 @@ pub(super) fn optimize_function(\n         }\n     }\n \n+    // FIXME Repeat following instructions until fixpoint.\n+\n     println!(\"{}:\\nstack slot usage: {:?}\", name, stack_slot_usage_map);\n \n     remove_unused_stack_addr_and_stack_load(&mut ctx.func, &mut stack_slot_usage_map);\n@@ -100,38 +102,23 @@ pub(super) fn optimize_function(\n                     SpatialOverlap::Partial | SpatialOverlap::Full => true,\n                 }\n             }).filter(|&store| {\n-                // Check if the store may have happened before the load.\n-\n-                let store_ebb = ctx.func.layout.inst_ebb(store).unwrap();\n-                if load_ebb == store_ebb {\n-                    ctx.func.layout.cmp(store, load) == std::cmp::Ordering::Less\n-                } else {\n-                    // FIXME O(stack_load count * ebb count)\n-                    // FIXME reuse memory allocations\n-                    let mut visited = EntitySet::new();\n-                    let mut todo = EntitySet::new();\n-                    todo.insert(load_ebb);\n-                    while let Some(ebb) = todo.pop() {\n-                        if visited.contains(ebb) {\n-                            continue;\n-                        }\n-                        visited.insert(ebb);\n-                        if ebb == store_ebb {\n-                            return true;\n-                        }\n-                        for bb in ctx.cfg.pred_iter(ebb) {\n-                            todo.insert(bb.ebb);\n-                        }\n-                    }\n-                    false\n+                match temporal_order(&*ctx, load, store) {\n+                    TemporalOrder::NeverBefore => false, // Can never be the source of the loaded value.\n+                    TemporalOrder::MaybeBefore | TemporalOrder::DefinitivelyBefore => true,\n                 }\n             }).collect::<Vec<Inst>>();\n             for &store in &potential_stores {\n-                println!(\"Potential store -> load forwarding {} -> {} ({:?})\", ctx.func.dfg.display_inst(store, None), ctx.func.dfg.display_inst(load, None), spatial_overlap(ctx.func, load, store));\n+                println!(\n+                    \"Potential store -> load forwarding {} -> {} ({:?}, {:?})\",\n+                    ctx.func.dfg.display_inst(store, None),\n+                    ctx.func.dfg.display_inst(load, None),\n+                    spatial_overlap(&ctx.func, store, load),\n+                    temporal_order(&*ctx, store, load),\n+                );\n             }\n             match *potential_stores {\n                 [] => println!(\"[{}] [BUG?] Reading uninitialized memory\", name),\n-                [store] if spatial_overlap(&ctx.func, load, store) == SpatialOverlap::Full => {\n+                [store] if spatial_overlap(&ctx.func, load, store) == SpatialOverlap::Full && temporal_order(&ctx, load, store) == TemporalOrder::DefinitivelyBefore => {\n                     let store_ebb = ctx.func.layout.inst_ebb(store).unwrap();\n                     let stored_value = ctx.func.dfg.inst_args(store)[0];\n                     let stored_type = ctx.func.dfg.value_type(stored_value);\n@@ -149,6 +136,7 @@ pub(super) fn optimize_function(\n \n         if users.stack_load.is_empty() {\n             // Never loaded; can safely remove all stores and the stack slot.\n+            // FIXME also remove stores when there is always a next store before a load.\n             for user in users.stack_store.drain() {\n                 println!(\"[{}] Remove dead stack store {} of {}\", name, user, stack_slot.0);\n                 ctx.func.dfg.replace(user).nop();\n@@ -292,6 +280,8 @@ fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n         }\n     }\n \n+    debug_assert_ne!(src, dest);\n+\n     let (src_ss, src_offset, src_size) = inst_info(func, src);\n     let (dest_ss, dest_offset, dest_size) = inst_info(func, dest);\n \n@@ -311,3 +301,51 @@ fn spatial_overlap(func: &Function, src: Inst, dest: Inst) -> SpatialOverlap {\n \n     SpatialOverlap::Partial\n }\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+enum TemporalOrder {\n+    /// `src` will never be executed before `dest`.\n+    NeverBefore,\n+\n+    /// `src` may be executed before `dest`.\n+    MaybeBefore,\n+\n+    /// `src` will always be executed before `dest`.\n+    /// There may still be other instructions in between.\n+    DefinitivelyBefore,\n+}\n+\n+fn temporal_order(ctx: &Context, src: Inst, dest: Inst) -> TemporalOrder {\n+    debug_assert_ne!(src, dest);\n+\n+    let src_ebb = ctx.func.layout.inst_ebb(src).unwrap();\n+    let dest_ebb = ctx.func.layout.inst_ebb(dest).unwrap();\n+    if src_ebb == dest_ebb {\n+        use std::cmp::Ordering::*;\n+        match ctx.func.layout.cmp(src, dest) {\n+            Less => TemporalOrder::DefinitivelyBefore,\n+            Equal => unreachable!(),\n+            Greater => TemporalOrder::MaybeBefore, // FIXME use dominator to check for loops\n+        }\n+    } else {\n+        // FIXME O(stack_load count * ebb count)\n+        // FIXME reuse memory allocations\n+        // FIXME return DefinitivelyBefore is src dominates dest\n+        let mut visited = EntitySet::new();\n+        let mut todo = EntitySet::new();\n+        todo.insert(dest_ebb);\n+        while let Some(ebb) = todo.pop() {\n+            if visited.contains(ebb) {\n+                continue;\n+            }\n+            visited.insert(ebb);\n+            if ebb == src_ebb {\n+                return TemporalOrder::MaybeBefore;\n+            }\n+            for bb in ctx.cfg.pred_iter(ebb) {\n+                todo.insert(bb.ebb);\n+            }\n+        }\n+        TemporalOrder::NeverBefore\n+    }\n+}"}]}