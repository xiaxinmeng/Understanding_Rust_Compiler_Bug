{"sha": "e2d649405ab0bcbc494471285108243ad7ceeca9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUyZDY0OTQwNWFiMGJjYmM0OTQ0NzEyODUxMDgyNDNhZDdjZWVjYTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-05T01:43:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-01-05T01:43:07Z"}, "message": "Auto merge of #30707 - tsion:mir-text, r=nikomatsakis\n\nr? @nikomatsakis\n\nTextual MIR can be dumped for a particular `fn` with `#![rustc_mir(pretty = \"filename.mir\")]`. Below is an example of the text output.\n\n```rust\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\nfn example() -> Point {\n    let mut e = Point { x: 1, y: 2 };\n\n    let num = 5;\n    let plus_num = |x: i32| x + num;\n\n    e.y = plus_num(e.x);\n    e\n}\n```\n\n```rust\nfn() -> Point {\n    let mut var0: Point; // e\n    let var1: i32; // num\n    let var2: [closure@test.rs:84:20: 84:36 num:&i32]; // plus_num\n    let mut tmp0: ();\n    let mut tmp1: &i32;\n    let mut tmp2: ();\n    let mut tmp3: i32;\n    let mut tmp4: &[closure@test.rs:84:20: 84:36 num:&i32];\n    let mut tmp5: i32;\n    let mut tmp6: Point;\n\n    bb0: {\n        var0 = Point { x: 1, y: 2 };\n        var1 = 5;\n        tmp1 = &var1;\n        var2 = [closure@test.rs:84:20: 84:36] { num: tmp1 };\n        tmp4 = &var2;\n        tmp5 = var0.0;\n        tmp3 = tmp4(tmp5) -> [return: bb3, unwind: bb4];\n    }\n\n    bb1: {\n        return;\n    }\n\n    bb2: {\n        diverge;\n    }\n\n    bb3: {\n        drop var0.1;\n        var0.1 = tmp3;\n        drop tmp2;\n        drop var2;\n        drop var0;\n        tmp6 = var0;\n        return = tmp6;\n        drop tmp6;\n        goto -> bb1;\n    }\n\n    bb4: {\n        drop var2;\n        goto -> bb5;\n    }\n\n    bb5: {\n        drop var0;\n        goto -> bb2;\n    }\n}\n```\n\n```rust\nfn(arg0: &[closure@test.rs:84:20: 84:36 num:&i32], arg1: i32) -> i32 {\n    let var0: i32; // x\n    let mut tmp0: ();\n    let mut tmp1: i32;\n    let mut tmp2: i32;\n\n    bb0: {\n        var0 = arg1;\n        tmp1 = var0;\n        tmp2 = (*(*arg0).0);\n        return = Add(tmp1, tmp2);\n        goto -> bb1;\n    }\n\n    bb1: {\n        return;\n    }\n\n    bb2: {\n        diverge;\n    }\n}\n```", "tree": {"sha": "1a18963d7ca468f2309c963c7ccfe9e4109ac4c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a18963d7ca468f2309c963c7ccfe9e4109ac4c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e2d649405ab0bcbc494471285108243ad7ceeca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e2d649405ab0bcbc494471285108243ad7ceeca9", "html_url": "https://github.com/rust-lang/rust/commit/e2d649405ab0bcbc494471285108243ad7ceeca9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e2d649405ab0bcbc494471285108243ad7ceeca9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5e229057c93222afd4943a49d382c4c5d6e8c26", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5e229057c93222afd4943a49d382c4c5d6e8c26", "html_url": "https://github.com/rust-lang/rust/commit/d5e229057c93222afd4943a49d382c4c5d6e8c26"}, {"sha": "080994a189c7b3680e822d3f6ddf448c152e6374", "url": "https://api.github.com/repos/rust-lang/rust/commits/080994a189c7b3680e822d3f6ddf448c152e6374", "html_url": "https://github.com/rust-lang/rust/commit/080994a189c7b3680e822d3f6ddf448c152e6374"}], "stats": {"total": 231, "additions": 191, "deletions": 40}, "files": [{"sha": "75a588d424ebbb7b56ff7cb099f9ad06ac7581a7", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 88, "deletions": 23, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/e2d649405ab0bcbc494471285108243ad7ceeca9/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d649405ab0bcbc494471285108243ad7ceeca9/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=e2d649405ab0bcbc494471285108243ad7ceeca9", "patch": "@@ -18,7 +18,7 @@ use rustc_front::hir::InlineAsm;\n use syntax::ast::Name;\n use syntax::codemap::Span;\n use std::borrow::{Cow, IntoCow};\n-use std::fmt::{Debug, Formatter, Error, Write};\n+use std::fmt::{self, Debug, Formatter, Write};\n use std::{iter, u32};\n \n /// Lowered representation of a single function.\n@@ -183,8 +183,8 @@ impl BasicBlock {\n }\n \n impl Debug for BasicBlock {\n-    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n-        write!(fmt, \"BB({})\", self.0)\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n+        write!(fmt, \"bb{}\", self.0)\n     }\n }\n \n@@ -317,7 +317,7 @@ impl<'tcx> BasicBlockData<'tcx> {\n }\n \n impl<'tcx> Debug for Terminator<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         try!(self.fmt_head(fmt));\n         let successors = self.successors();\n         let labels = self.fmt_successor_labels();\n@@ -347,7 +347,7 @@ impl<'tcx> Terminator<'tcx> {\n     /// Write the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n     /// successor basic block, if any. The only information not inlcuded is the list of possible\n     /// successors, which may be rendered differently between the text and the graphviz format.\n-    pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> Result<(), Error> {\n+    pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n         use self::Terminator::*;\n         match *self {\n             Goto { .. } => write!(fmt, \"goto\"),\n@@ -421,7 +421,7 @@ pub enum DropKind {\n }\n \n impl<'tcx> Debug for Statement<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n             Assign(ref lv, ref rv) => write!(fmt, \"{:?} = {:?}\", lv, rv),\n@@ -541,7 +541,7 @@ impl<'tcx> Lvalue<'tcx> {\n }\n \n impl<'tcx> Debug for Lvalue<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::Lvalue::*;\n \n         match *self {\n@@ -551,24 +551,24 @@ impl<'tcx> Debug for Lvalue<'tcx> {\n                 write!(fmt,\"arg{:?}\", id),\n             Temp(id) =>\n                 write!(fmt,\"tmp{:?}\", id),\n-            Static(id) =>\n-                write!(fmt,\"Static({:?})\", id),\n+            Static(def_id) =>\n+                write!(fmt, \"{}\", ty::tls::with(|tcx| tcx.item_path_str(def_id))),\n             ReturnPointer =>\n-                write!(fmt,\"ReturnPointer\"),\n+                write!(fmt, \"return\"),\n             Projection(ref data) =>\n                 match data.elem {\n                     ProjectionElem::Downcast(ref adt_def, index) =>\n-                        write!(fmt,\"({:?} as {})\", data.base, adt_def.variants[index].name),\n+                        write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].name),\n                     ProjectionElem::Deref =>\n-                        write!(fmt,\"(*{:?})\", data.base),\n+                        write!(fmt, \"(*{:?})\", data.base),\n                     ProjectionElem::Field(field) =>\n-                        write!(fmt,\"{:?}.{:?}\", data.base, field.index()),\n+                        write!(fmt, \"{:?}.{:?}\", data.base, field.index()),\n                     ProjectionElem::Index(ref index) =>\n-                        write!(fmt,\"{:?}[{:?}]\", data.base, index),\n+                        write!(fmt, \"{:?}[{:?}]\", data.base, index),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n-                        write!(fmt,\"{:?}[{:?} of {:?}]\", data.base, offset, min_length),\n+                        write!(fmt, \"{:?}[{:?} of {:?}]\", data.base, offset, min_length),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n-                        write!(fmt,\"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n+                        write!(fmt, \"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n                 },\n         }\n     }\n@@ -588,7 +588,7 @@ pub enum Operand<'tcx> {\n }\n \n impl<'tcx> Debug for Operand<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::Operand::*;\n         match *self {\n             Constant(ref a) => write!(fmt, \"{:?}\", a),\n@@ -715,22 +715,87 @@ pub enum UnOp {\n }\n \n impl<'tcx> Debug for Rvalue<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::Rvalue::*;\n \n         match *self {\n             Use(ref lvalue) => write!(fmt, \"{:?}\", lvalue),\n             Repeat(ref a, ref b) => write!(fmt, \"[{:?}; {:?}]\", a, b),\n-            Ref(ref a, bk, ref b) => write!(fmt, \"&{:?} {:?} {:?}\", a, bk, b),\n             Len(ref a) => write!(fmt, \"Len({:?})\", a),\n             Cast(ref kind, ref lv, ref ty) => write!(fmt, \"{:?} as {:?} ({:?})\", lv, ty, kind),\n             BinaryOp(ref op, ref a, ref b) => write!(fmt, \"{:?}({:?}, {:?})\", op, a, b),\n             UnaryOp(ref op, ref a) => write!(fmt, \"{:?}({:?})\", op, a),\n             Box(ref t) => write!(fmt, \"Box({:?})\", t),\n-            Aggregate(ref kind, ref lvs) => write!(fmt, \"Aggregate<{:?}>{:?}\", kind, lvs),\n             InlineAsm(ref asm) => write!(fmt, \"InlineAsm({:?})\", asm),\n             Slice { ref input, from_start, from_end } =>\n                 write!(fmt, \"{:?}[{:?}..-{:?}]\", input, from_start, from_end),\n+\n+            Ref(_, borrow_kind, ref lv) => {\n+                let kind_str = match borrow_kind {\n+                    BorrowKind::Shared => \"\",\n+                    BorrowKind::Mut | BorrowKind::Unique => \"mut \",\n+                };\n+                write!(fmt, \"&{}{:?}\", kind_str, lv)\n+            }\n+\n+            Aggregate(ref kind, ref lvs) => {\n+                use self::AggregateKind::*;\n+\n+                fn fmt_tuple(fmt: &mut Formatter, name: &str, lvs: &[Operand]) -> fmt::Result {\n+                    let mut tuple_fmt = fmt.debug_tuple(name);\n+                    for lv in lvs {\n+                        tuple_fmt.field(lv);\n+                    }\n+                    tuple_fmt.finish()\n+                }\n+\n+                match *kind {\n+                    Vec => write!(fmt, \"{:?}\", lvs),\n+\n+                    Tuple => {\n+                        if lvs.len() == 1 {\n+                            write!(fmt, \"({:?},)\", lvs[0])\n+                        } else {\n+                            fmt_tuple(fmt, \"\", lvs)\n+                        }\n+                    }\n+\n+                    Adt(adt_def, variant, _) => {\n+                        let variant_def = &adt_def.variants[variant];\n+                        let name = ty::tls::with(|tcx| tcx.item_path_str(variant_def.did));\n+\n+                        match variant_def.kind() {\n+                            ty::VariantKind::Unit => write!(fmt, \"{}\", name),\n+                            ty::VariantKind::Tuple => fmt_tuple(fmt, &name, lvs),\n+                            ty::VariantKind::Struct => {\n+                                let mut struct_fmt = fmt.debug_struct(&name);\n+                                for (field, lv) in variant_def.fields.iter().zip(lvs) {\n+                                    struct_fmt.field(&field.name.as_str(), lv);\n+                                }\n+                                struct_fmt.finish()\n+                            }\n+                        }\n+                    }\n+\n+                    Closure(def_id, _) => ty::tls::with(|tcx| {\n+                        if let Some(node_id) = tcx.map.as_local_node_id(def_id) {\n+                            let name = format!(\"[closure@{:?}]\", tcx.map.span(node_id));\n+                            let mut struct_fmt = fmt.debug_struct(&name);\n+\n+                            tcx.with_freevars(node_id, |freevars| {\n+                                for (freevar, lv) in freevars.iter().zip(lvs) {\n+                                    let var_name = tcx.local_var_name_str(freevar.def.var_id());\n+                                    struct_fmt.field(&var_name, lv);\n+                                }\n+                            });\n+\n+                            struct_fmt.finish()\n+                        } else {\n+                            write!(fmt, \"[closure]\")\n+                        }\n+                    }),\n+                }\n+            }\n         }\n     }\n }\n@@ -771,13 +836,13 @@ pub enum Literal<'tcx> {\n }\n \n impl<'tcx> Debug for Constant<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         write!(fmt, \"{:?}\", self.literal)\n     }\n }\n \n impl<'tcx> Debug for Literal<'tcx> {\n-    fn fmt(&self, fmt: &mut Formatter) -> Result<(), Error> {\n+    fn fmt(&self, fmt: &mut Formatter) -> fmt::Result {\n         use self::Literal::*;\n         match *self {\n             Item { def_id, .. } =>\n@@ -788,7 +853,7 @@ impl<'tcx> Debug for Literal<'tcx> {\n }\n \n /// Write a `ConstVal` in a way closer to the original source code than the `Debug` output.\n-pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> Result<(), Error> {\n+pub fn fmt_const_val<W: Write>(fmt: &mut W, const_val: &ConstVal) -> fmt::Result {\n     use middle::const_eval::ConstVal::*;\n     match *const_val {\n         Float(f) => write!(fmt, \"{:?}\", f),"}, {"sha": "9cc40bbc3838a2e35c549c8d2fe54ba280d19a03", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e2d649405ab0bcbc494471285108243ad7ceeca9/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d649405ab0bcbc494471285108243ad7ceeca9/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=e2d649405ab0bcbc494471285108243ad7ceeca9", "patch": "@@ -29,8 +29,8 @@ extern crate rustc_back;\n extern crate syntax;\n \n pub mod build;\n-pub mod mir_map;\n+pub mod graphviz;\n mod hair;\n-mod graphviz;\n+pub mod mir_map;\n+pub mod pretty;\n pub mod transform;\n-"}, {"sha": "a3ca4c05456021827de3b4d726c55233c8df93d7", "filename": "src/librustc_mir/mir_map.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e2d649405ab0bcbc494471285108243ad7ceeca9/src%2Flibrustc_mir%2Fmir_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d649405ab0bcbc494471285108243ad7ceeca9/src%2Flibrustc_mir%2Fmir_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmir_map.rs?ref=e2d649405ab0bcbc494471285108243ad7ceeca9", "patch": "@@ -22,6 +22,7 @@ extern crate rustc_front;\n \n use build;\n use graphviz;\n+use pretty;\n use transform::*;\n use rustc::mir::repr::Mir;\n use hair::cx::Cx;\n@@ -152,29 +153,29 @@ impl<'a, 'm, 'tcx> Visitor<'tcx> for InnerDump<'a,'m,'tcx> {\n                                          .flat_map(|a| a.meta_item_list())\n                                          .flat_map(|l| l.iter());\n                 for item in meta_item_list {\n-                    if item.check_name(\"graphviz\") {\n+                    if item.check_name(\"graphviz\") || item.check_name(\"pretty\") {\n                         match item.value_str() {\n                             Some(s) => {\n-                                match\n-                                    File::create(format!(\"{}{}\", prefix, s))\n-                                    .and_then(|ref mut output| {\n+                                let filename = format!(\"{}{}\", prefix, s);\n+                                let result = File::create(&filename).and_then(|ref mut output| {\n+                                    if item.check_name(\"graphviz\") {\n                                         graphviz::write_mir_graphviz(&mir, output)\n-                                    })\n-                                {\n-                                    Ok(()) => { }\n-                                    Err(e) => {\n-                                        self.tcx.sess.span_fatal(\n-                                            item.span,\n-                                            &format!(\"Error writing graphviz \\\n-                                                      results to `{}`: {}\",\n-                                                     s, e));\n+                                    } else {\n+                                        pretty::write_mir_pretty(&mir, output)\n                                     }\n+                                });\n+\n+                                if let Err(e) = result {\n+                                    self.tcx.sess.span_fatal(\n+                                        item.span,\n+                                        &format!(\"Error writing MIR {} results to `{}`: {}\",\n+                                                 item.name(), filename, e));\n                                 }\n                             }\n                             None => {\n                                 self.tcx.sess.span_err(\n                                     item.span,\n-                                    \"graphviz attribute requires a path\");\n+                                    &format!(\"{} attribute requires a path\", item.name()));\n                             }\n                         }\n                     }"}, {"sha": "163559f279281ac2caa67b07b366552ecc1b5c85", "filename": "src/librustc_mir/pretty.rs", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/e2d649405ab0bcbc494471285108243ad7ceeca9/src%2Flibrustc_mir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e2d649405ab0bcbc494471285108243ad7ceeca9/src%2Flibrustc_mir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fpretty.rs?ref=e2d649405ab0bcbc494471285108243ad7ceeca9", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::mir::repr::*;\n+use rustc::middle::ty;\n+use std::io::{self, Write};\n+\n+const INDENT: &'static str = \"    \";\n+\n+/// Write out a human-readable textual representation for the given MIR.\n+pub fn write_mir_pretty<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> {\n+    try!(write_mir_intro(mir, w));\n+\n+    // Nodes\n+    for block in mir.all_basic_blocks() {\n+        try!(write_basic_block(block, mir, w));\n+    }\n+\n+    writeln!(w, \"}}\")\n+}\n+\n+/// Write out a human-readable textual representation for the given basic block.\n+fn write_basic_block<W: Write>(block: BasicBlock, mir: &Mir, w: &mut W) -> io::Result<()> {\n+    let data = mir.basic_block_data(block);\n+\n+    // Basic block label at the top.\n+    try!(writeln!(w, \"\\n{}{:?}: {{\", INDENT, block));\n+\n+    // List of statements in the middle.\n+    for statement in &data.statements {\n+        try!(writeln!(w, \"{0}{0}{1:?};\", INDENT, statement));\n+    }\n+\n+    // Terminator at the bottom.\n+    try!(writeln!(w, \"{0}{0}{1:?};\", INDENT, data.terminator));\n+\n+    writeln!(w, \"{}}}\", INDENT)\n+}\n+\n+/// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n+/// local variables (both user-defined bindings and compiler temporaries).\n+fn write_mir_intro<W: Write>(mir: &Mir, w: &mut W) -> io::Result<()> {\n+    try!(write!(w, \"fn(\"));\n+\n+    // fn argument types.\n+    for (i, arg) in mir.arg_decls.iter().enumerate() {\n+        if i > 0 {\n+            try!(write!(w, \", \"));\n+        }\n+        try!(write!(w, \"{:?}: {}\", Lvalue::Arg(i as u32), arg.ty));\n+    }\n+\n+    try!(write!(w, \") -> \"));\n+\n+    // fn return type.\n+    match mir.return_ty {\n+        ty::FnOutput::FnConverging(ty) => try!(write!(w, \"{}\", ty)),\n+        ty::FnOutput::FnDiverging => try!(write!(w, \"!\")),\n+    }\n+\n+    try!(writeln!(w, \" {{\"));\n+\n+    // User variable types (including the user's name in a comment).\n+    for (i, var) in mir.var_decls.iter().enumerate() {\n+        try!(write!(w, \"{}let \", INDENT));\n+        if var.mutability == Mutability::Mut {\n+            try!(write!(w, \"mut \"));\n+        }\n+        try!(writeln!(w, \"{:?}: {}; // {}\", Lvalue::Var(i as u32), var.ty, var.name));\n+    }\n+\n+    // Compiler-introduced temporary types.\n+    for (i, temp) in mir.temp_decls.iter().enumerate() {\n+        try!(writeln!(w, \"{}let mut {:?}: {};\", INDENT, Lvalue::Temp(i as u32), temp.ty));\n+    }\n+\n+    Ok(())\n+}"}]}