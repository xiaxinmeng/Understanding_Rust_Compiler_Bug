{"sha": "af69066aa6afa7bff771a6ee9548b2b84a02a88a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmNjkwNjZhYTZhZmE3YmZmNzcxYTZlZTk1NDhiMmI4NGEwMmE4OGE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-02T17:36:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-12-02T17:36:29Z"}, "message": "Auto merge of #69864 - LinkTed:master, r=Amanieu\n\nunix: Extend UnixStream and UnixDatagram to send and receive file descriptors\n\nAdd the functions `recv_vectored_fds` and `send_vectored_fds` to `UnixDatagram` and `UnixStream`. With this functions `UnixDatagram` and `UnixStream` can send and receive file descriptors, by using `recvmsg` and `sendmsg` system call.", "tree": {"sha": "e27f9b8edb3821be445081b430bf38d06704eaaf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e27f9b8edb3821be445081b430bf38d06704eaaf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af69066aa6afa7bff771a6ee9548b2b84a02a88a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af69066aa6afa7bff771a6ee9548b2b84a02a88a", "html_url": "https://github.com/rust-lang/rust/commit/af69066aa6afa7bff771a6ee9548b2b84a02a88a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af69066aa6afa7bff771a6ee9548b2b84a02a88a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a094ff9590b83c8f94d898f92c2964a5803ded06", "url": "https://api.github.com/repos/rust-lang/rust/commits/a094ff9590b83c8f94d898f92c2964a5803ded06", "html_url": "https://github.com/rust-lang/rust/commit/a094ff9590b83c8f94d898f92c2964a5803ded06"}, {"sha": "8983752c12c65e598dff704502ad1b0334d1daaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/8983752c12c65e598dff704502ad1b0334d1daaa", "html_url": "https://github.com/rust-lang/rust/commit/8983752c12c65e598dff704502ad1b0334d1daaa"}], "stats": {"total": 4869, "additions": 3098, "deletions": 1771}, "files": [{"sha": "83eb847697dd4f4e33c87ccc74854b86e335682e", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=af69066aa6afa7bff771a6ee9548b2b84a02a88a", "patch": "@@ -301,6 +301,7 @@\n #![feature(rustc_private)]\n #![feature(shrink_to)]\n #![feature(slice_concat_ext)]\n+#![feature(slice_fill)]\n #![feature(slice_internals)]\n #![feature(slice_ptr_get)]\n #![feature(slice_ptr_len)]"}, {"sha": "3d2366554b5b245e8ea5e7f7f433cd82e867e6d2", "filename": "library/std/src/sys/unix/ext/net.rs", "status": "removed", "additions": 0, "deletions": 1768, "changes": 1768, "blob_url": "https://github.com/rust-lang/rust/blob/a094ff9590b83c8f94d898f92c2964a5803ded06/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a094ff9590b83c8f94d898f92c2964a5803ded06/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet.rs?ref=a094ff9590b83c8f94d898f92c2964a5803ded06", "patch": "@@ -1,1768 +0,0 @@\n-//! Unix-specific networking functionality.\n-\n-#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-\n-#[cfg(all(test, not(target_os = \"emscripten\")))]\n-mod tests;\n-\n-// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n-#[cfg(not(unix))]\n-#[allow(non_camel_case_types)]\n-mod libc {\n-    pub use libc::c_int;\n-    pub type socklen_t = u32;\n-    pub struct sockaddr;\n-    #[derive(Clone)]\n-    pub struct sockaddr_un;\n-}\n-\n-use crate::ascii;\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n-use crate::mem;\n-use crate::net::{self, Shutdown};\n-use crate::os::unix::ffi::OsStrExt;\n-use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n-use crate::path::Path;\n-use crate::sys::net::Socket;\n-use crate::sys::{self, cvt};\n-use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n-use crate::time::Duration;\n-\n-#[cfg(any(\n-    target_os = \"android\",\n-    target_os = \"linux\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\"\n-))]\n-use crate::os::unix::ucred;\n-\n-#[unstable(feature = \"peer_credentials_unix_socket\", issue = \"42839\", reason = \"unstable\")]\n-#[cfg(any(\n-    target_os = \"android\",\n-    target_os = \"linux\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"ios\",\n-    target_os = \"macos\",\n-    target_os = \"openbsd\"\n-))]\n-pub use ucred::UCred;\n-\n-#[cfg(any(\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"haiku\"\n-))]\n-use libc::MSG_NOSIGNAL;\n-#[cfg(not(any(\n-    target_os = \"linux\",\n-    target_os = \"android\",\n-    target_os = \"dragonfly\",\n-    target_os = \"freebsd\",\n-    target_os = \"openbsd\",\n-    target_os = \"netbsd\",\n-    target_os = \"haiku\"\n-)))]\n-const MSG_NOSIGNAL: libc::c_int = 0x0;\n-\n-fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n-    // Work with an actual instance of the type since using a null pointer is UB\n-    let base = addr as *const _ as usize;\n-    let path = &addr.sun_path as *const _ as usize;\n-    path - base\n-}\n-\n-unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n-    let mut addr: libc::sockaddr_un = mem::zeroed();\n-    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n-\n-    let bytes = path.as_os_str().as_bytes();\n-\n-    if bytes.contains(&0) {\n-        return Err(io::Error::new(\n-            io::ErrorKind::InvalidInput,\n-            \"paths may not contain interior null bytes\",\n-        ));\n-    }\n-\n-    if bytes.len() >= addr.sun_path.len() {\n-        return Err(io::Error::new(\n-            io::ErrorKind::InvalidInput,\n-            \"path must be shorter than SUN_LEN\",\n-        ));\n-    }\n-    for (dst, src) in addr.sun_path.iter_mut().zip(bytes.iter()) {\n-        *dst = *src as libc::c_char;\n-    }\n-    // null byte for pathname addresses is already there because we zeroed the\n-    // struct\n-\n-    let mut len = sun_path_offset(&addr) + bytes.len();\n-    match bytes.get(0) {\n-        Some(&0) | None => {}\n-        Some(_) => len += 1,\n-    }\n-    Ok((addr, len as libc::socklen_t))\n-}\n-\n-enum AddressKind<'a> {\n-    Unnamed,\n-    Pathname(&'a Path),\n-    Abstract(&'a [u8]),\n-}\n-\n-/// An address associated with a Unix socket.\n-///\n-/// # Examples\n-///\n-/// ```\n-/// use std::os::unix::net::UnixListener;\n-///\n-/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n-///     Ok(sock) => sock,\n-///     Err(e) => {\n-///         println!(\"Couldn't bind: {:?}\", e);\n-///         return\n-///     }\n-/// };\n-/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-/// ```\n-#[derive(Clone)]\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct SocketAddr {\n-    addr: libc::sockaddr_un,\n-    len: libc::socklen_t,\n-}\n-\n-impl SocketAddr {\n-    fn new<F>(f: F) -> io::Result<SocketAddr>\n-    where\n-        F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int,\n-    {\n-        unsafe {\n-            let mut addr: libc::sockaddr_un = mem::zeroed();\n-            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n-            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n-            SocketAddr::from_parts(addr, len)\n-        }\n-    }\n-\n-    fn from_parts(addr: libc::sockaddr_un, mut len: libc::socklen_t) -> io::Result<SocketAddr> {\n-        if len == 0 {\n-            // When there is a datagram from unnamed unix socket\n-            // linux returns zero bytes of address\n-            len = sun_path_offset(&addr) as libc::socklen_t; // i.e., zero-length address\n-        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n-            return Err(io::Error::new(\n-                io::ErrorKind::InvalidInput,\n-                \"file descriptor did not correspond to a Unix socket\",\n-            ));\n-        }\n-\n-        Ok(SocketAddr { addr, len })\n-    }\n-\n-    /// Returns `true` if the address is unnamed.\n-    ///\n-    /// # Examples\n-    ///\n-    /// A named address:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixListener::bind(\"/tmp/sock\")?;\n-    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(addr.is_unnamed(), false);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// An unnamed address:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::unbound()?;\n-    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(addr.is_unnamed(), true);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn is_unnamed(&self) -> bool {\n-        if let AddressKind::Unnamed = self.address() { true } else { false }\n-    }\n-\n-    /// Returns the contents of this address if it is a `pathname` address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// With a pathname:\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    /// use std::path::Path;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixListener::bind(\"/tmp/sock\")?;\n-    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// Without a pathname:\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::unbound()?;\n-    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     assert_eq!(addr.as_pathname(), None);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn as_pathname(&self) -> Option<&Path> {\n-        if let AddressKind::Pathname(path) = self.address() { Some(path) } else { None }\n-    }\n-\n-    fn address(&self) -> AddressKind<'_> {\n-        let len = self.len as usize - sun_path_offset(&self.addr);\n-        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n-\n-        // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n-        if len == 0\n-            || (cfg!(not(any(target_os = \"linux\", target_os = \"android\")))\n-                && self.addr.sun_path[0] == 0)\n-        {\n-            AddressKind::Unnamed\n-        } else if self.addr.sun_path[0] == 0 {\n-            AddressKind::Abstract(&path[1..len])\n-        } else {\n-            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n-        }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for SocketAddr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.address() {\n-            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n-            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n-            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n-        }\n-    }\n-}\n-\n-struct AsciiEscaped<'a>(&'a [u8]);\n-\n-impl<'a> fmt::Display for AsciiEscaped<'a> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(fmt, \"\\\"\")?;\n-        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n-            write!(fmt, \"{}\", byte as char)?;\n-        }\n-        write!(fmt, \"\\\"\")\n-    }\n-}\n-\n-/// A Unix stream socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixStream;\n-/// use std::io::prelude::*;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let mut stream = UnixStream::connect(\"/path/to/my/socket\")?;\n-///     stream.write_all(b\"hello world\")?;\n-///     let mut response = String::new();\n-///     stream.read_to_string(&mut response)?;\n-///     println!(\"{}\", response);\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixStream(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixStream {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixStream\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixStream {\n-    /// Connects to the socket named by `path`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n-        fn inner(path: &Path) -> io::Result<UnixStream> {\n-            unsafe {\n-                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n-                Ok(UnixStream(inner))\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixStream`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// let (sock1, sock2) = match UnixStream::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n-        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-        Ok((UnixStream(i1), UnixStream(i2)))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixStream` is a reference to the same stream that this\n-    /// object references. Both handles will read and write the same stream of\n-    /// data, and options set on one stream will be propagated to the other\n-    /// stream.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixStream> {\n-        self.0.duplicate().map(UnixStream)\n-    }\n-\n-    /// Returns the socket address of the local half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Returns the socket address of the remote half of this connection.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Gets the peer credentials for this Unix domain socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(peer_credentials_unix_socket)]\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let peer_cred = socket.peer_cred().expect(\"Couldn't get peer credentials\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"peer_credentials_unix_socket\", issue = \"42839\", reason = \"unstable\")]\n-    #[cfg(any(\n-        target_os = \"android\",\n-        target_os = \"linux\",\n-        target_os = \"dragonfly\",\n-        target_os = \"freebsd\",\n-        target_os = \"ios\",\n-        target_os = \"macos\",\n-        target_os = \"openbsd\"\n-    ))]\n-    pub fn peer_cred(&self) -> io::Result<UCred> {\n-        ucred::peer_cred(self)\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`read`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`read`]: io::Read::read\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    ///     let err = result.unwrap_err();\n-    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`write`] calls will block\n-    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n-    /// passed to this method.\n-    ///\n-    /// [`read`]: io::Read::read\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"Couldn't set write timeout\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::net::UdpSocket;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n-    ///     let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    ///     let err = result.unwrap_err();\n-    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n-    ///     assert_eq!(socket.read_timeout()?, Some(Duration::new(1, 0)));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"Couldn't set write timeout\");\n-    ///     assert_eq!(socket.write_timeout()?, Some(Duration::new(1, 0)));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     if let Ok(Some(err)) = socket.take_error() {\n-    ///         println!(\"Got error: {:?}\", err);\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Shuts down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixStream;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-\n-    /// Receives data on the socket from the remote address to which it is\n-    /// connected, without removing that data from the queue. On success,\n-    /// returns the number of bytes peeked.\n-    ///\n-    /// Successive calls return the same data. This is accomplished by passing\n-    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_peek)]\n-    ///\n-    /// use std::os::unix::net::UnixStream;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n-    ///     let mut buf = [0; 10];\n-    ///     let len = socket.peek(&mut buf).expect(\"peek failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n-    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.peek(buf)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Read for UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        io::Read::read(&mut &*self, buf)\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        io::Read::read_vectored(&mut &*self, bufs)\n-    }\n-\n-    #[inline]\n-    fn is_read_vectored(&self) -> bool {\n-        io::Read::is_read_vectored(&&*self)\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Read for &'a UnixStream {\n-    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n-        self.0.read_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    fn is_read_vectored(&self) -> bool {\n-        self.0.is_read_vectored()\n-    }\n-\n-    #[inline]\n-    unsafe fn initializer(&self) -> Initializer {\n-        Initializer::nop()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl io::Write for UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        io::Write::write(&mut &*self, buf)\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        io::Write::write_vectored(&mut &*self, bufs)\n-    }\n-\n-    #[inline]\n-    fn is_write_vectored(&self) -> bool {\n-        io::Write::is_write_vectored(&&*self)\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        io::Write::flush(&mut &*self)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> io::Write for &'a UnixStream {\n-    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n-        self.0.write_vectored(bufs)\n-    }\n-\n-    #[inline]\n-    fn is_write_vectored(&self) -> bool {\n-        self.0.is_write_vectored()\n-    }\n-\n-    fn flush(&mut self) -> io::Result<()> {\n-        Ok(())\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n-        UnixStream(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpStream {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::TcpListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl AsRawFd for net::UdpSocket {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.as_inner().socket().as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpStream {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpStream::from_inner(sys_common::net::TcpStream::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::TcpListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::TcpListener::from_inner(sys_common::net::TcpListener::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n-impl FromRawFd for net::UdpSocket {\n-    unsafe fn from_raw_fd(fd: RawFd) -> net::UdpSocket {\n-        let socket = sys::net::Socket::from_inner(fd);\n-        net::UdpSocket::from_inner(sys_common::net::UdpSocket::from_inner(socket))\n-    }\n-}\n-\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpStream {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::TcpListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-#[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n-impl IntoRawFd for net::UdpSocket {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.into_inner().into_socket().into_inner()\n-    }\n-}\n-\n-/// A structure representing a Unix domain socket server.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-///\n-///     // accept connections and process them, spawning a new thread for each one\n-///     for stream in listener.incoming() {\n-///         match stream {\n-///             Ok(stream) => {\n-///                 /* connection succeeded */\n-///                 thread::spawn(|| handle_client(stream));\n-///             }\n-///             Err(err) => {\n-///                 /* connection failed */\n-///                 break;\n-///             }\n-///         }\n-///     }\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixListener(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixListener {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixListener\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixListener {\n-    /// Creates a new `UnixListener` bound to the specified socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't connect: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n-        fn inner(path: &Path) -> io::Result<UnixListener> {\n-            unsafe {\n-                let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n-                cvt(libc::listen(*inner.as_inner(), 128))?;\n-\n-                Ok(UnixListener(inner))\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Accepts a new incoming connection to this listener.\n-    ///\n-    /// This function will block the calling thread until a new Unix connection\n-    /// is established. When established, the corresponding [`UnixStream`] and\n-    /// the remote peer's address will be returned.\n-    ///\n-    /// [`UnixStream`]: crate::os::unix::net::UnixStream\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-    ///\n-    ///     match listener.accept() {\n-    ///         Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n-    ///         Err(e) => println!(\"accept function failed: {:?}\", e),\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n-        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n-        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n-        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n-        let addr = SocketAddr::from_parts(storage, len)?;\n-        Ok((UnixStream(sock), addr))\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixListener` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one listener will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-    ///     let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixListener> {\n-        self.0.duplicate().map(UnixListener)\n-    }\n-\n-    /// Returns the local socket address of this listener.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-    ///     let addr = listener.local_addr().expect(\"Couldn't get local address\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// This will result in the `accept` operation becoming nonblocking,\n-    /// i.e., immediately returning from their calls. If the IO operation is\n-    /// successful, `Ok` is returned and no further action is required. If the\n-    /// IO operation could not be completed and needs to be retried, an error\n-    /// with kind [`io::ErrorKind::WouldBlock`] is returned.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-    ///     listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixListener;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/tmp/sock\")?;\n-    ///\n-    ///     if let Ok(Some(err)) = listener.take_error() {\n-    ///         println!(\"Got error: {:?}\", err);\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// # Platform specific\n-    /// On Redox this always returns `None`.\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Returns an iterator over incoming connections.\n-    ///\n-    /// The iterator will never return [`None`] and will also not yield the\n-    /// peer's [`SocketAddr`] structure.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::thread;\n-    /// use std::os::unix::net::{UnixStream, UnixListener};\n-    ///\n-    /// fn handle_client(stream: UnixStream) {\n-    ///     // ...\n-    /// }\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-    ///\n-    ///     for stream in listener.incoming() {\n-    ///         match stream {\n-    ///             Ok(stream) => {\n-    ///                 thread::spawn(|| handle_client(stream));\n-    ///             }\n-    ///             Err(err) => {\n-    ///                 break;\n-    ///             }\n-    ///         }\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn incoming(&self) -> Incoming<'_> {\n-        Incoming { listener: self }\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixListener {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixListener {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n-        UnixListener(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixListener {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> IntoIterator for &'a UnixListener {\n-    type Item = io::Result<UnixStream>;\n-    type IntoIter = Incoming<'a>;\n-\n-    fn into_iter(self) -> Incoming<'a> {\n-        self.incoming()\n-    }\n-}\n-\n-/// An iterator over incoming connections to a [`UnixListener`].\n-///\n-/// It will never return [`None`].\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::thread;\n-/// use std::os::unix::net::{UnixStream, UnixListener};\n-///\n-/// fn handle_client(stream: UnixStream) {\n-///     // ...\n-/// }\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n-///\n-///     for stream in listener.incoming() {\n-///         match stream {\n-///             Ok(stream) => {\n-///                 thread::spawn(|| handle_client(stream));\n-///             }\n-///             Err(err) => {\n-///                 break;\n-///             }\n-///         }\n-///     }\n-///     Ok(())\n-/// }\n-/// ```\n-#[derive(Debug)]\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct Incoming<'a> {\n-    listener: &'a UnixListener,\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl<'a> Iterator for Incoming<'a> {\n-    type Item = io::Result<UnixStream>;\n-\n-    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n-        Some(self.listener.accept().map(|s| s.0))\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        (usize::MAX, None)\n-    }\n-}\n-\n-/// A Unix datagram socket.\n-///\n-/// # Examples\n-///\n-/// ```no_run\n-/// use std::os::unix::net::UnixDatagram;\n-///\n-/// fn main() -> std::io::Result<()> {\n-///     let socket = UnixDatagram::bind(\"/path/to/my/socket\")?;\n-///     socket.send_to(b\"hello world\", \"/path/to/other/socket\")?;\n-///     let mut buf = [0; 100];\n-///     let (count, address) = socket.recv_from(&mut buf)?;\n-///     println!(\"socket {:?} sent {:?}\", address, &buf[..count]);\n-///     Ok(())\n-/// }\n-/// ```\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-pub struct UnixDatagram(Socket);\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl fmt::Debug for UnixDatagram {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut builder = fmt.debug_struct(\"UnixDatagram\");\n-        builder.field(\"fd\", self.0.as_inner());\n-        if let Ok(addr) = self.local_addr() {\n-            builder.field(\"local\", &addr);\n-        }\n-        if let Ok(addr) = self.peer_addr() {\n-            builder.field(\"peer\", &addr);\n-        }\n-        builder.finish()\n-    }\n-}\n-\n-impl UnixDatagram {\n-    /// Creates a Unix datagram socket bound to the given path.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't bind: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n-        fn inner(path: &Path) -> io::Result<UnixDatagram> {\n-            unsafe {\n-                let socket = UnixDatagram::unbound()?;\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len as _))?;\n-\n-                Ok(socket)\n-            }\n-        }\n-        inner(path.as_ref())\n-    }\n-\n-    /// Creates a Unix Datagram socket which is not bound to any address.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let sock = match UnixDatagram::unbound() {\n-    ///     Ok(sock) => sock,\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't unbound: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn unbound() -> io::Result<UnixDatagram> {\n-        let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n-        Ok(UnixDatagram(inner))\n-    }\n-\n-    /// Creates an unnamed pair of connected sockets.\n-    ///\n-    /// Returns two `UnixDatagrams`s which are connected to each other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// let (sock1, sock2) = match UnixDatagram::pair() {\n-    ///     Ok((sock1, sock2)) => (sock1, sock2),\n-    ///     Err(e) => {\n-    ///         println!(\"Couldn't unbound: {:?}\", e);\n-    ///         return\n-    ///     }\n-    /// };\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n-        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n-        Ok((UnixDatagram(i1), UnixDatagram(i2)))\n-    }\n-\n-    /// Connects the socket to the specified address.\n-    ///\n-    /// The [`send`] method may be used to send data to the specified address.\n-    /// [`recv`] and [`recv_from`] will only receive data from that address.\n-    ///\n-    /// [`send`]: UnixDatagram::send\n-    /// [`recv`]: UnixDatagram::recv\n-    /// [`recv_from`]: UnixDatagram::recv_from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     match sock.connect(\"/path/to/the/socket\") {\n-    ///         Ok(sock) => sock,\n-    ///         Err(e) => {\n-    ///             println!(\"Couldn't connect: {:?}\", e);\n-    ///             return Err(e)\n-    ///         }\n-    ///     };\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n-        fn inner(d: &UnixDatagram, path: &Path) -> io::Result<()> {\n-            unsafe {\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                cvt(libc::connect(*d.0.as_inner(), &addr as *const _ as *const _, len))?;\n-\n-                Ok(())\n-            }\n-        }\n-        inner(self, path.as_ref())\n-    }\n-\n-    /// Creates a new independently owned handle to the underlying socket.\n-    ///\n-    /// The returned `UnixDatagram` is a reference to the same socket that this\n-    /// object references. Both handles can be used to accept incoming\n-    /// connections and options set on one side will affect the other.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n-    ///     let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n-        self.0.duplicate().map(UnixDatagram)\n-    }\n-\n-    /// Returns the address of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n-    ///     let addr = sock.local_addr().expect(\"Couldn't get local address\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    /// Returns the address of this socket's peer.\n-    ///\n-    /// The [`connect`] method will connect the socket to a peer.\n-    ///\n-    /// [`connect`]: UnixDatagram::connect\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.connect(\"/path/to/the/socket\")?;\n-    ///\n-    ///     let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n-        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n-    }\n-\n-    fn recv_from_flags(\n-        &self,\n-        buf: &mut [u8],\n-        flags: libc::c_int,\n-    ) -> io::Result<(usize, SocketAddr)> {\n-        let mut count = 0;\n-        let addr = SocketAddr::new(|addr, len| unsafe {\n-            count = libc::recvfrom(\n-                *self.0.as_inner(),\n-                buf.as_mut_ptr() as *mut _,\n-                buf.len(),\n-                flags,\n-                addr,\n-                len,\n-            );\n-            if count > 0 {\n-                1\n-            } else if count == 0 {\n-                0\n-            } else {\n-                -1\n-            }\n-        })?;\n-\n-        Ok((count as usize, addr))\n-    }\n-\n-    /// Receives data from the socket.\n-    ///\n-    /// On success, returns the number of bytes read and the address from\n-    /// whence the data came.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     let mut buf = vec![0; 10];\n-    ///     let (size, sender) = sock.recv_from(buf.as_mut_slice())?;\n-    ///     println!(\"received {} bytes from {:?}\", size, sender);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        self.recv_from_flags(buf, 0)\n-    }\n-\n-    /// Receives data from the socket.\n-    ///\n-    /// On success, returns the number of bytes read.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n-    ///     let mut buf = vec![0; 10];\n-    ///     sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.read(buf)\n-    }\n-\n-    /// Sends data on the socket to the specified address.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n-        fn inner(d: &UnixDatagram, buf: &[u8], path: &Path) -> io::Result<usize> {\n-            unsafe {\n-                let (addr, len) = sockaddr_un(path)?;\n-\n-                let count = cvt(libc::sendto(\n-                    *d.0.as_inner(),\n-                    buf.as_ptr() as *const _,\n-                    buf.len(),\n-                    MSG_NOSIGNAL,\n-                    &addr as *const _ as *const _,\n-                    len,\n-                ))?;\n-                Ok(count as usize)\n-            }\n-        }\n-        inner(self, buf, path.as_ref())\n-    }\n-\n-    /// Sends data on the socket to the socket's peer.\n-    ///\n-    /// The peer address may be set by the `connect` method, and this method\n-    /// will return an error if the socket has not already been connected.\n-    ///\n-    /// On success, returns the number of bytes written.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n-    ///     sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n-        self.0.write(buf)\n-    }\n-\n-    /// Sets the read timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will\n-    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`]\n-    /// is passed to this method.\n-    ///\n-    /// [`recv`]: UnixDatagram::recv\n-    /// [`recv_from`]: UnixDatagram::recv_from\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.set_read_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"set_read_timeout function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::unbound()?;\n-    ///     let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n-    ///     let err = result.unwrap_err();\n-    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Sets the write timeout for the socket.\n-    ///\n-    /// If the provided value is [`None`], then [`send`] and [`send_to`] calls will\n-    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method.\n-    ///\n-    /// [`send`]: UnixDatagram::send\n-    /// [`send_to`]: UnixDatagram::send_to\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"set_write_timeout function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    ///\n-    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n-    /// method:\n-    ///\n-    /// ```no_run\n-    /// use std::io;\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::unbound()?;\n-    ///     let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n-    ///     let err = result.unwrap_err();\n-    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n-        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Returns the read timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.set_read_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"set_read_timeout function failed\");\n-    ///     assert_eq!(sock.read_timeout()?, Some(Duration::new(1, 0)));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_RCVTIMEO)\n-    }\n-\n-    /// Returns the write timeout of this socket.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::time::Duration;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.set_write_timeout(Some(Duration::new(1, 0)))\n-    ///         .expect(\"set_write_timeout function failed\");\n-    ///     assert_eq!(sock.write_timeout()?, Some(Duration::new(1, 0)));\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n-        self.0.timeout(libc::SO_SNDTIMEO)\n-    }\n-\n-    /// Moves the socket into or out of nonblocking mode.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n-        self.0.set_nonblocking(nonblocking)\n-    }\n-\n-    /// Returns the value of the `SO_ERROR` option.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     if let Ok(Some(err)) = sock.take_error() {\n-    ///         println!(\"Got error: {:?}\", err);\n-    ///     }\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n-        self.0.take_error()\n-    }\n-\n-    /// Shut down the read, write, or both halves of this connection.\n-    ///\n-    /// This function will cause all pending and future I/O calls on the\n-    /// specified portions to immediately return with an appropriate value\n-    /// (see the documentation of [`Shutdown`]).\n-    ///\n-    /// ```no_run\n-    /// use std::os::unix::net::UnixDatagram;\n-    /// use std::net::Shutdown;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let sock = UnixDatagram::unbound()?;\n-    ///     sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n-        self.0.shutdown(how)\n-    }\n-\n-    /// Receives data on the socket from the remote address to which it is\n-    /// connected, without removing that data from the queue. On success,\n-    /// returns the number of bytes peeked.\n-    ///\n-    /// Successive calls return the same data. This is accomplished by passing\n-    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_peek)]\n-    ///\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n-    ///     let mut buf = [0; 10];\n-    ///     let len = socket.peek(&mut buf).expect(\"peek failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n-    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n-        self.0.peek(buf)\n-    }\n-\n-    /// Receives a single datagram message on the socket, without removing it from the\n-    /// queue. On success, returns the number of bytes read and the origin.\n-    ///\n-    /// The function must be called with valid byte array `buf` of sufficient size to\n-    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n-    /// excess bytes may be discarded.\n-    ///\n-    /// Successive calls return the same data. This is accomplished by passing\n-    /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n-    ///\n-    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n-    /// synchronize IO events on one or more sockets.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```no_run\n-    /// #![feature(unix_socket_peek)]\n-    ///\n-    /// use std::os::unix::net::UnixDatagram;\n-    ///\n-    /// fn main() -> std::io::Result<()> {\n-    ///     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n-    ///     let mut buf = [0; 10];\n-    ///     let (len, addr) = socket.peek_from(&mut buf).expect(\"peek failed\");\n-    ///     Ok(())\n-    /// }\n-    /// ```\n-    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n-    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n-        self.recv_from_flags(buf, libc::MSG_PEEK)\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl AsRawFd for UnixDatagram {\n-    fn as_raw_fd(&self) -> RawFd {\n-        *self.0.as_inner()\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl FromRawFd for UnixDatagram {\n-    unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram {\n-        UnixDatagram(Socket::from_inner(fd))\n-    }\n-}\n-\n-#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n-impl IntoRawFd for UnixDatagram {\n-    fn into_raw_fd(self) -> RawFd {\n-        self.0.into_inner()\n-    }\n-}"}, {"sha": "1f9036242eb59bee8f670e0b9347660ad59a432a", "filename": "library/std/src/sys/unix/ext/net/addr.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Faddr.rs?ref=af69066aa6afa7bff771a6ee9548b2b84a02a88a", "patch": "@@ -0,0 +1,226 @@\n+use crate::ffi::OsStr;\n+use crate::os::unix::ffi::OsStrExt;\n+use crate::path::Path;\n+use crate::sys::cvt;\n+use crate::{ascii, fmt, io, mem};\n+\n+// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n+#[cfg(not(unix))]\n+#[allow(non_camel_case_types)]\n+mod libc {\n+    pub use libc::c_int;\n+    pub type socklen_t = u32;\n+    pub struct sockaddr;\n+    #[derive(Clone)]\n+    pub struct sockaddr_un;\n+}\n+\n+fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n+    // Work with an actual instance of the type since using a null pointer is UB\n+    let base = addr as *const _ as usize;\n+    let path = &addr.sun_path as *const _ as usize;\n+    path - base\n+}\n+\n+pub(super) unsafe fn sockaddr_un(path: &Path) -> io::Result<(libc::sockaddr_un, libc::socklen_t)> {\n+    let mut addr: libc::sockaddr_un = mem::zeroed();\n+    addr.sun_family = libc::AF_UNIX as libc::sa_family_t;\n+\n+    let bytes = path.as_os_str().as_bytes();\n+\n+    if bytes.contains(&0) {\n+        return Err(io::Error::new(\n+            io::ErrorKind::InvalidInput,\n+            \"paths may not contain interior null bytes\",\n+        ));\n+    }\n+\n+    if bytes.len() >= addr.sun_path.len() {\n+        return Err(io::Error::new(\n+            io::ErrorKind::InvalidInput,\n+            \"path must be shorter than SUN_LEN\",\n+        ));\n+    }\n+    for (dst, src) in addr.sun_path.iter_mut().zip(bytes.iter()) {\n+        *dst = *src as libc::c_char;\n+    }\n+    // null byte for pathname addresses is already there because we zeroed the\n+    // struct\n+\n+    let mut len = sun_path_offset(&addr) + bytes.len();\n+    match bytes.get(0) {\n+        Some(&0) | None => {}\n+        Some(_) => len += 1,\n+    }\n+    Ok((addr, len as libc::socklen_t))\n+}\n+\n+enum AddressKind<'a> {\n+    Unnamed,\n+    Pathname(&'a Path),\n+    Abstract(&'a [u8]),\n+}\n+\n+struct AsciiEscaped<'a>(&'a [u8]);\n+\n+impl<'a> fmt::Display for AsciiEscaped<'a> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(fmt, \"\\\"\")?;\n+        for byte in self.0.iter().cloned().flat_map(ascii::escape_default) {\n+            write!(fmt, \"{}\", byte as char)?;\n+        }\n+        write!(fmt, \"\\\"\")\n+    }\n+}\n+\n+/// An address associated with a Unix socket.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::os::unix::net::UnixListener;\n+///\n+/// let socket = match UnixListener::bind(\"/tmp/sock\") {\n+///     Ok(sock) => sock,\n+///     Err(e) => {\n+///         println!(\"Couldn't bind: {:?}\", e);\n+///         return\n+///     }\n+/// };\n+/// let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+/// ```\n+#[derive(Clone)]\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct SocketAddr {\n+    addr: libc::sockaddr_un,\n+    len: libc::socklen_t,\n+}\n+\n+impl SocketAddr {\n+    pub(super) fn new<F>(f: F) -> io::Result<SocketAddr>\n+    where\n+        F: FnOnce(*mut libc::sockaddr, *mut libc::socklen_t) -> libc::c_int,\n+    {\n+        unsafe {\n+            let mut addr: libc::sockaddr_un = mem::zeroed();\n+            let mut len = mem::size_of::<libc::sockaddr_un>() as libc::socklen_t;\n+            cvt(f(&mut addr as *mut _ as *mut _, &mut len))?;\n+            SocketAddr::from_parts(addr, len)\n+        }\n+    }\n+\n+    pub(super) fn from_parts(\n+        addr: libc::sockaddr_un,\n+        mut len: libc::socklen_t,\n+    ) -> io::Result<SocketAddr> {\n+        if len == 0 {\n+            // When there is a datagram from unnamed unix socket\n+            // linux returns zero bytes of address\n+            len = sun_path_offset(&addr) as libc::socklen_t; // i.e., zero-length address\n+        } else if addr.sun_family != libc::AF_UNIX as libc::sa_family_t {\n+            return Err(io::Error::new(\n+                io::ErrorKind::InvalidInput,\n+                \"file descriptor did not correspond to a Unix socket\",\n+            ));\n+        }\n+\n+        Ok(SocketAddr { addr, len })\n+    }\n+\n+    /// Returns `true` if the address is unnamed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// A named address:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixListener::bind(\"/tmp/sock\")?;\n+    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(addr.is_unnamed(), false);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// An unnamed address:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::unbound()?;\n+    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(addr.is_unnamed(), true);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn is_unnamed(&self) -> bool {\n+        if let AddressKind::Unnamed = self.address() { true } else { false }\n+    }\n+\n+    /// Returns the contents of this address if it is a `pathname` address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// With a pathname:\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    /// use std::path::Path;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixListener::bind(\"/tmp/sock\")?;\n+    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(addr.as_pathname(), Some(Path::new(\"/tmp/sock\")));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// Without a pathname:\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::unbound()?;\n+    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     assert_eq!(addr.as_pathname(), None);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn as_pathname(&self) -> Option<&Path> {\n+        if let AddressKind::Pathname(path) = self.address() { Some(path) } else { None }\n+    }\n+\n+    fn address(&self) -> AddressKind<'_> {\n+        let len = self.len as usize - sun_path_offset(&self.addr);\n+        let path = unsafe { mem::transmute::<&[libc::c_char], &[u8]>(&self.addr.sun_path) };\n+\n+        // macOS seems to return a len of 16 and a zeroed sun_path for unnamed addresses\n+        if len == 0\n+            || (cfg!(not(any(target_os = \"linux\", target_os = \"android\")))\n+                && self.addr.sun_path[0] == 0)\n+        {\n+            AddressKind::Unnamed\n+        } else if self.addr.sun_path[0] == 0 {\n+            AddressKind::Abstract(&path[1..len])\n+        } else {\n+            AddressKind::Pathname(OsStr::from_bytes(&path[..len - 1]).as_ref())\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for SocketAddr {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self.address() {\n+            AddressKind::Unnamed => write!(fmt, \"(unnamed)\"),\n+            AddressKind::Abstract(name) => write!(fmt, \"{} (abstract)\", AsciiEscaped(name)),\n+            AddressKind::Pathname(path) => write!(fmt, \"{:?} (pathname)\", path),\n+        }\n+    }\n+}"}, {"sha": "2c91ba70dd0b5c16aa43f2a779b66086356ed223", "filename": "library/std/src/sys/unix/ext/net/ancillary.rs", "status": "added", "additions": 660, "deletions": 0, "changes": 660, "blob_url": "https://github.com/rust-lang/rust/blob/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fancillary.rs?ref=af69066aa6afa7bff771a6ee9548b2b84a02a88a", "patch": "@@ -0,0 +1,660 @@\n+use super::{sockaddr_un, SocketAddr};\n+use crate::convert::TryFrom;\n+use crate::io::{self, IoSliceMut};\n+use crate::marker::PhantomData;\n+use crate::mem::{size_of, zeroed};\n+use crate::os::unix::io::RawFd;\n+use crate::path::Path;\n+#[cfg(target_os = \"android\")]\n+use crate::ptr::eq;\n+use crate::ptr::read_unaligned;\n+use crate::slice::from_raw_parts;\n+use crate::sys::net::Socket;\n+\n+// FIXME(#43348): Make libc adapt #[doc(cfg(...))] so we don't need these fake definitions here?\n+#[cfg(all(doc, not(target_os = \"linux\"), not(target_os = \"android\")))]\n+#[allow(non_camel_case_types)]\n+mod libc {\n+    pub use libc::c_int;\n+    pub struct ucred;\n+    pub struct cmsghdr;\n+    pub type pid_t = i32;\n+    pub type gid_t = u32;\n+    pub type uid_t = u32;\n+}\n+\n+pub(super) fn recv_vectored_with_ancillary_from(\n+    socket: &Socket,\n+    bufs: &mut [IoSliceMut<'_>],\n+    ancillary: &mut SocketAncillary<'_>,\n+) -> io::Result<(usize, bool, io::Result<SocketAddr>)> {\n+    unsafe {\n+        let mut msg_name: libc::sockaddr_un = zeroed();\n+\n+        let mut msg: libc::msghdr = zeroed();\n+        msg.msg_name = &mut msg_name as *mut _ as *mut _;\n+        msg.msg_namelen = size_of::<libc::sockaddr_un>() as libc::socklen_t;\n+        msg.msg_iov = bufs.as_mut_ptr().cast();\n+        msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                msg.msg_iovlen = bufs.len() as libc::size_t;\n+                msg.msg_controllen = ancillary.buffer.len() as libc::size_t;\n+            } else if #[cfg(any(\n+                          target_os = \"dragonfly\",\n+                          target_os = \"emscripten\",\n+                          target_os = \"freebsd\",\n+                          all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"netbsd\",\n+                          target_os = \"openbsd\",\n+                      ))] {\n+                msg.msg_iovlen = bufs.len() as libc::c_int;\n+                msg.msg_controllen = ancillary.buffer.len() as libc::socklen_t;\n+            }\n+        }\n+\n+        let count = socket.recv_msg(&mut msg)?;\n+\n+        ancillary.length = msg.msg_controllen as usize;\n+        ancillary.truncated = msg.msg_flags & libc::MSG_CTRUNC == libc::MSG_CTRUNC;\n+\n+        let truncated = msg.msg_flags & libc::MSG_TRUNC == libc::MSG_TRUNC;\n+        let addr = SocketAddr::from_parts(msg_name, msg.msg_namelen);\n+\n+        Ok((count, truncated, addr))\n+    }\n+}\n+\n+pub(super) fn send_vectored_with_ancillary_to(\n+    socket: &Socket,\n+    path: Option<&Path>,\n+    bufs: &mut [IoSliceMut<'_>],\n+    ancillary: &mut SocketAncillary<'_>,\n+) -> io::Result<usize> {\n+    unsafe {\n+        let (mut msg_name, msg_namelen) =\n+            if let Some(path) = path { sockaddr_un(path)? } else { (zeroed(), 0) };\n+\n+        let mut msg: libc::msghdr = zeroed();\n+        msg.msg_name = &mut msg_name as *mut _ as *mut _;\n+        msg.msg_namelen = msg_namelen;\n+        msg.msg_iov = bufs.as_mut_ptr().cast();\n+        msg.msg_control = ancillary.buffer.as_mut_ptr().cast();\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                msg.msg_iovlen = bufs.len() as libc::size_t;\n+                msg.msg_controllen = ancillary.length as libc::size_t;\n+            } else if #[cfg(any(\n+                          target_os = \"dragonfly\",\n+                          target_os = \"emscripten\",\n+                          target_os = \"freebsd\",\n+                          all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"netbsd\",\n+                          target_os = \"openbsd\",\n+                      ))] {\n+                msg.msg_iovlen = bufs.len() as libc::c_int;\n+                msg.msg_controllen = ancillary.length as libc::socklen_t;\n+            }\n+        }\n+\n+        ancillary.truncated = false;\n+\n+        socket.send_msg(&mut msg)\n+    }\n+}\n+\n+fn add_to_ancillary_data<T>(\n+    buffer: &mut [u8],\n+    length: &mut usize,\n+    source: &[T],\n+    cmsg_level: libc::c_int,\n+    cmsg_type: libc::c_int,\n+) -> bool {\n+    let source_len = if let Some(source_len) = source.len().checked_mul(size_of::<T>()) {\n+        if let Ok(source_len) = u32::try_from(source_len) {\n+            source_len\n+        } else {\n+            return false;\n+        }\n+    } else {\n+        return false;\n+    };\n+\n+    unsafe {\n+        let additional_space = libc::CMSG_SPACE(source_len) as usize;\n+\n+        let new_length = if let Some(new_length) = additional_space.checked_add(*length) {\n+            new_length\n+        } else {\n+            return false;\n+        };\n+\n+        if new_length > buffer.len() {\n+            return false;\n+        }\n+\n+        buffer[*length..new_length].fill(0);\n+\n+        *length = new_length;\n+\n+        let mut msg: libc::msghdr = zeroed();\n+        msg.msg_control = buffer.as_mut_ptr().cast();\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                msg.msg_controllen = *length as libc::size_t;\n+            } else if #[cfg(any(\n+                          target_os = \"dragonfly\",\n+                          target_os = \"emscripten\",\n+                          target_os = \"freebsd\",\n+                          all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"netbsd\",\n+                          target_os = \"openbsd\",\n+                      ))] {\n+                msg.msg_controllen = *length as libc::socklen_t;\n+            }\n+        }\n+\n+        let mut cmsg = libc::CMSG_FIRSTHDR(&msg);\n+        let mut previous_cmsg = cmsg;\n+        while !cmsg.is_null() {\n+            previous_cmsg = cmsg;\n+            cmsg = libc::CMSG_NXTHDR(&msg, cmsg);\n+            cfg_if::cfg_if! {\n+                // Android return the same pointer if it is the last cmsg.\n+                // Therefore, check it if the previous pointer is the same as the current one.\n+                if #[cfg(target_os = \"android\")] {\n+                    if cmsg == previous_cmsg {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        if previous_cmsg.is_null() {\n+            return false;\n+        }\n+\n+        (*previous_cmsg).cmsg_level = cmsg_level;\n+        (*previous_cmsg).cmsg_type = cmsg_type;\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as libc::size_t;\n+            } else if #[cfg(any(\n+                          target_os = \"dragonfly\",\n+                          target_os = \"emscripten\",\n+                          target_os = \"freebsd\",\n+                          all(target_os = \"linux\", target_env = \"musl\",),\n+                          target_os = \"netbsd\",\n+                          target_os = \"openbsd\",\n+                      ))] {\n+                (*previous_cmsg).cmsg_len = libc::CMSG_LEN(source_len) as libc::socklen_t;\n+            }\n+        }\n+\n+        let data = libc::CMSG_DATA(previous_cmsg).cast();\n+\n+        libc::memcpy(data, source.as_ptr().cast(), source_len as usize);\n+    }\n+    true\n+}\n+\n+struct AncillaryDataIter<'a, T> {\n+    data: &'a [u8],\n+    phantom: PhantomData<T>,\n+}\n+\n+impl<'a, T> AncillaryDataIter<'a, T> {\n+    /// Create `AncillaryDataIter` struct to iterate through the data unit in the control message.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `data` must contain a valid control message.\n+    unsafe fn new(data: &'a [u8]) -> AncillaryDataIter<'a, T> {\n+        AncillaryDataIter { data, phantom: PhantomData }\n+    }\n+}\n+\n+impl<'a, T> Iterator for AncillaryDataIter<'a, T> {\n+    type Item = T;\n+\n+    fn next(&mut self) -> Option<T> {\n+        if size_of::<T>() <= self.data.len() {\n+            unsafe {\n+                let unit = read_unaligned(self.data.as_ptr().cast());\n+                self.data = &self.data[size_of::<T>()..];\n+                Some(unit)\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Unix credential.\n+#[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+#[derive(Clone)]\n+pub struct SocketCred(libc::ucred);\n+\n+#[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+impl SocketCred {\n+    /// Create a Unix credential struct.\n+    ///\n+    /// PID, UID and GID is set to 0.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn new() -> SocketCred {\n+        SocketCred(libc::ucred { pid: 0, uid: 0, gid: 0 })\n+    }\n+\n+    /// Set the PID.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn set_pid(&mut self, pid: libc::pid_t) {\n+        self.0.pid = pid;\n+    }\n+\n+    /// Get the current PID.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn get_pid(&self) -> libc::pid_t {\n+        self.0.pid\n+    }\n+\n+    /// Set the UID.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn set_uid(&mut self, uid: libc::uid_t) {\n+        self.0.uid = uid;\n+    }\n+\n+    /// Get the current UID.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn get_uid(&self) -> libc::uid_t {\n+        self.0.uid\n+    }\n+\n+    /// Set the GID.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn set_gid(&mut self, gid: libc::gid_t) {\n+        self.0.gid = gid;\n+    }\n+\n+    /// Get the current GID.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn get_gid(&self) -> libc::gid_t {\n+        self.0.gid\n+    }\n+}\n+\n+/// This control message contains file descriptors.\n+///\n+/// The level is equal to `SOL_SOCKET` and the type is equal to `SCM_RIGHTS`.\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+pub struct ScmRights<'a>(AncillaryDataIter<'a, RawFd>);\n+\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+impl<'a> Iterator for ScmRights<'a> {\n+    type Item = RawFd;\n+\n+    fn next(&mut self) -> Option<RawFd> {\n+        self.0.next()\n+    }\n+}\n+\n+/// This control message contains unix credentials.\n+///\n+/// The level is equal to `SOL_SOCKET` and the type is equal to `SCM_CREDENTIALS` or `SCM_CREDS`.\n+#[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+pub struct ScmCredentials<'a>(AncillaryDataIter<'a, libc::ucred>);\n+\n+#[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+impl<'a> Iterator for ScmCredentials<'a> {\n+    type Item = SocketCred;\n+\n+    fn next(&mut self) -> Option<SocketCred> {\n+        Some(SocketCred(self.0.next()?))\n+    }\n+}\n+\n+/// The error type which is returned from parsing the type a control message.\n+#[non_exhaustive]\n+#[derive(Debug)]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+pub enum AncillaryError {\n+    Unknown { cmsg_level: i32, cmsg_type: i32 },\n+}\n+\n+/// This enum represent one control message of variable type.\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+pub enum AncillaryData<'a> {\n+    ScmRights(ScmRights<'a>),\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    ScmCredentials(ScmCredentials<'a>),\n+}\n+\n+impl<'a> AncillaryData<'a> {\n+    /// Create a `AncillaryData::ScmRights` variant.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `data` must contain a valid control message and the control message must be type of\n+    /// `SOL_SOCKET` and level of `SCM_RIGHTS`.\n+    unsafe fn as_rights(data: &'a [u8]) -> Self {\n+        let ancillary_data_iter = AncillaryDataIter::new(data);\n+        let scm_rights = ScmRights(ancillary_data_iter);\n+        AncillaryData::ScmRights(scm_rights)\n+    }\n+\n+    /// Create a `AncillaryData::ScmCredentials` variant.\n+    ///\n+    /// # Safety\n+    ///\n+    /// `data` must contain a valid control message and the control message must be type of\n+    /// `SOL_SOCKET` and level of `SCM_CREDENTIALS` or `SCM_CREDENTIALS`.\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    unsafe fn as_credentials(data: &'a [u8]) -> Self {\n+        let ancillary_data_iter = AncillaryDataIter::new(data);\n+        let scm_credentials = ScmCredentials(ancillary_data_iter);\n+        AncillaryData::ScmCredentials(scm_credentials)\n+    }\n+\n+    fn try_from_cmsghdr(cmsg: &'a libc::cmsghdr) -> Result<Self, AncillaryError> {\n+        unsafe {\n+            cfg_if::cfg_if! {\n+                if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                    let cmsg_len_zero = libc::CMSG_LEN(0) as libc::size_t;\n+                } else if #[cfg(any(\n+                              target_os = \"dragonfly\",\n+                              target_os = \"emscripten\",\n+                              target_os = \"freebsd\",\n+                              all(target_os = \"linux\", target_env = \"musl\",),\n+                              target_os = \"netbsd\",\n+                              target_os = \"openbsd\",\n+                          ))] {\n+                    let cmsg_len_zero = libc::CMSG_LEN(0) as libc::socklen_t;\n+                }\n+            }\n+            let data_len = (*cmsg).cmsg_len - cmsg_len_zero;\n+            let data = libc::CMSG_DATA(cmsg).cast();\n+            let data = from_raw_parts(data, data_len as usize);\n+\n+            match (*cmsg).cmsg_level {\n+                libc::SOL_SOCKET => match (*cmsg).cmsg_type {\n+                    libc::SCM_RIGHTS => Ok(AncillaryData::as_rights(data)),\n+                    #[cfg(any(target_os = \"android\", target_os = \"linux\",))]\n+                    libc::SCM_CREDENTIALS => Ok(AncillaryData::as_credentials(data)),\n+                    cmsg_type => {\n+                        Err(AncillaryError::Unknown { cmsg_level: libc::SOL_SOCKET, cmsg_type })\n+                    }\n+                },\n+                cmsg_level => {\n+                    Err(AncillaryError::Unknown { cmsg_level, cmsg_type: (*cmsg).cmsg_type })\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+/// This struct is used to iterate through the control messages.\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+pub struct Messages<'a> {\n+    buffer: &'a [u8],\n+    current: Option<&'a libc::cmsghdr>,\n+}\n+\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+impl<'a> Iterator for Messages<'a> {\n+    type Item = Result<AncillaryData<'a>, AncillaryError>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        unsafe {\n+            let mut msg: libc::msghdr = zeroed();\n+            msg.msg_control = self.buffer.as_ptr() as *mut _;\n+            cfg_if::cfg_if! {\n+                if #[cfg(any(target_os = \"android\", all(target_os = \"linux\", target_env = \"gnu\")))] {\n+                    msg.msg_controllen = self.buffer.len() as libc::size_t;\n+                } else if #[cfg(any(\n+                              target_os = \"dragonfly\",\n+                              target_os = \"emscripten\",\n+                              target_os = \"freebsd\",\n+                              all(target_os = \"linux\", target_env = \"musl\",),\n+                              target_os = \"netbsd\",\n+                              target_os = \"openbsd\",\n+                          ))] {\n+                    msg.msg_controllen = self.buffer.len() as libc::socklen_t;\n+                }\n+            }\n+\n+            let cmsg = if let Some(current) = self.current {\n+                libc::CMSG_NXTHDR(&msg, current)\n+            } else {\n+                libc::CMSG_FIRSTHDR(&msg)\n+            };\n+\n+            let cmsg = cmsg.as_ref()?;\n+            cfg_if::cfg_if! {\n+                // Android return the same pointer if it is the last cmsg.\n+                // Therefore, check it if the previous pointer is the same as the current one.\n+                if #[cfg(target_os = \"android\")] {\n+                    if let Some(current) = self.current {\n+                        if eq(current, cmsg) {\n+                            return None;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            self.current = Some(cmsg);\n+            let ancillary_result = AncillaryData::try_from_cmsghdr(cmsg);\n+            Some(ancillary_result)\n+        }\n+    }\n+}\n+\n+/// A Unix socket Ancillary data struct.\n+///\n+/// # Example\n+/// ```no_run\n+/// #![feature(unix_socket_ancillary_data)]\n+/// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n+/// use std::io::IoSliceMut;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+///\n+///     let mut fds = [0; 8];\n+///     let mut ancillary_buffer = [0; 128];\n+///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+///\n+///     let mut buf = [1; 8];\n+///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+///\n+///     for ancillary_result in ancillary.messages() {\n+///         if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n+///             for fd in scm_rights {\n+///                 println!(\"receive file descriptor: {}\", fd);\n+///             }\n+///         }\n+///     }\n+///     Ok(())\n+/// }\n+/// ```\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+#[derive(Debug)]\n+pub struct SocketAncillary<'a> {\n+    buffer: &'a mut [u8],\n+    length: usize,\n+    truncated: bool,\n+}\n+\n+impl<'a> SocketAncillary<'a> {\n+    /// Create an ancillary data with the given buffer.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// # #![allow(unused_mut)]\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::SocketAncillary;\n+    /// let mut ancillary_buffer = [0; 128];\n+    /// let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn new(buffer: &'a mut [u8]) -> Self {\n+        SocketAncillary { buffer, length: 0, truncated: false }\n+    }\n+\n+    /// Returns the capacity of the buffer.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn capacity(&self) -> usize {\n+        self.buffer.len()\n+    }\n+\n+    /// Returns the number of used bytes.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn len(&self) -> usize {\n+        self.length\n+    }\n+\n+    /// Returns the iterator of the control messages.\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn messages(&self) -> Messages<'_> {\n+        Messages { buffer: &self.buffer[..self.length], current: None }\n+    }\n+\n+    /// Is `true` if during a recv operation the ancillary was truncated.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+    ///\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///\n+    ///     let mut buf = [1; 8];\n+    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///\n+    ///     println!(\"Is truncated: {}\", ancillary.truncated());\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn truncated(&self) -> bool {\n+        self.truncated\n+    }\n+\n+    /// Add file descriptors to the ancillary data.\n+    ///\n+    /// The function returns `true` if there was enough space in the buffer.\n+    /// If there was not enough space then no file descriptors was appended.\n+    /// Technically, that means this operation adds a control message with the level `SOL_SOCKET`\n+    /// and type `SCM_RIGHTS`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n+    /// use std::os::unix::io::AsRawFd;\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+    ///\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&[sock.as_raw_fd()][..]);\n+    ///\n+    ///     let mut buf = [1; 8];\n+    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+    ///     sock.send_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn add_fds(&mut self, fds: &[RawFd]) -> bool {\n+        self.truncated = false;\n+        add_to_ancillary_data(\n+            &mut self.buffer,\n+            &mut self.length,\n+            fds,\n+            libc::SOL_SOCKET,\n+            libc::SCM_RIGHTS,\n+        )\n+    }\n+\n+    /// Add credentials to the ancillary data.\n+    ///\n+    /// The function returns `true` if there was enough space in the buffer.\n+    /// If there was not enough space then no credentials was appended.\n+    /// Technically, that means this operation adds a control message with the level `SOL_SOCKET`\n+    /// and type `SCM_CREDENTIALS` or `SCM_CREDS`.\n+    ///\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn add_creds(&mut self, creds: &[SocketCred]) -> bool {\n+        self.truncated = false;\n+        add_to_ancillary_data(\n+            &mut self.buffer,\n+            &mut self.length,\n+            creds,\n+            libc::SOL_SOCKET,\n+            libc::SCM_CREDENTIALS,\n+        )\n+    }\n+\n+    /// Clears the ancillary data, removing all values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixStream::connect(\"/tmp/sock\")?;\n+    ///\n+    ///     let mut fds1 = [0; 8];\n+    ///     let mut fds2 = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///\n+    ///     let mut buf = [1; 8];\n+    ///     let mut bufs = &mut [IoSliceMut::new(&mut buf[..])][..];\n+    ///\n+    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     for ancillary_result in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///\n+    ///     ancillary.clear();\n+    ///\n+    ///     sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     for ancillary_result in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn clear(&mut self) {\n+        self.length = 0;\n+        self.truncated = false;\n+    }\n+}"}, {"sha": "0f532c47c8f922510daf0f5a34a3ce3ed428b385", "filename": "library/std/src/sys/unix/ext/net/datagram.rs", "status": "added", "additions": 897, "deletions": 0, "changes": 897, "blob_url": "https://github.com/rust-lang/rust/blob/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fdatagram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fdatagram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fdatagram.rs?ref=af69066aa6afa7bff771a6ee9548b2b84a02a88a", "patch": "@@ -0,0 +1,897 @@\n+#[cfg(any(\n+    doc,\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"emscripten\",\n+    target_os = \"freebsd\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+))]\n+use super::{recv_vectored_with_ancillary_from, send_vectored_with_ancillary_to, SocketAncillary};\n+use super::{sockaddr_un, SocketAddr};\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"emscripten\",\n+    target_os = \"freebsd\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+))]\n+use crate::io::IoSliceMut;\n+use crate::net::Shutdown;\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::path::Path;\n+use crate::sys::cvt;\n+use crate::sys::net::Socket;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::time::Duration;\n+use crate::{fmt, io};\n+\n+#[cfg(any(\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"haiku\"\n+))]\n+use libc::MSG_NOSIGNAL;\n+#[cfg(not(any(\n+    target_os = \"linux\",\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"openbsd\",\n+    target_os = \"netbsd\",\n+    target_os = \"haiku\"\n+)))]\n+const MSG_NOSIGNAL: libc::c_int = 0x0;\n+\n+/// A Unix datagram socket.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::os::unix::net::UnixDatagram;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let socket = UnixDatagram::bind(\"/path/to/my/socket\")?;\n+///     socket.send_to(b\"hello world\", \"/path/to/other/socket\")?;\n+///     let mut buf = [0; 100];\n+///     let (count, address) = socket.recv_from(&mut buf)?;\n+///     println!(\"socket {:?} sent {:?}\", address, &buf[..count]);\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixDatagram(Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixDatagram {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixDatagram\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixDatagram {\n+    /// Creates a Unix datagram socket bound to the given path.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't bind: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixDatagram> {\n+        unsafe {\n+            let socket = UnixDatagram::unbound()?;\n+            let (addr, len) = sockaddr_un(path.as_ref())?;\n+\n+            cvt(libc::bind(*socket.0.as_inner(), &addr as *const _ as *const _, len as _))?;\n+\n+            Ok(socket)\n+        }\n+    }\n+\n+    /// Creates a Unix Datagram socket which is not bound to any address.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let sock = match UnixDatagram::unbound() {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn unbound() -> io::Result<UnixDatagram> {\n+        let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n+        Ok(UnixDatagram(inner))\n+    }\n+\n+    /// Creates an unnamed pair of connected sockets.\n+    ///\n+    /// Returns two `UnixDatagrams`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// let (sock1, sock2) = match UnixDatagram::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't unbound: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn pair() -> io::Result<(UnixDatagram, UnixDatagram)> {\n+        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_DGRAM)?;\n+        Ok((UnixDatagram(i1), UnixDatagram(i2)))\n+    }\n+\n+    /// Connects the socket to the specified address.\n+    ///\n+    /// The [`send`] method may be used to send data to the specified address.\n+    /// [`recv`] and [`recv_from`] will only receive data from that address.\n+    ///\n+    /// [`send`]: UnixDatagram::send\n+    /// [`recv`]: UnixDatagram::recv\n+    /// [`recv_from`]: UnixDatagram::recv_from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     match sock.connect(\"/path/to/the/socket\") {\n+    ///         Ok(sock) => sock,\n+    ///         Err(e) => {\n+    ///             println!(\"Couldn't connect: {:?}\", e);\n+    ///             return Err(e)\n+    ///         }\n+    ///     };\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn connect<P: AsRef<Path>>(&self, path: P) -> io::Result<()> {\n+        unsafe {\n+            let (addr, len) = sockaddr_un(path.as_ref())?;\n+\n+            cvt(libc::connect(*self.0.as_inner(), &addr as *const _ as *const _, len))?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixDatagram` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one side will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n+    ///     let sock_copy = sock.try_clone().expect(\"try_clone failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixDatagram> {\n+        self.0.duplicate().map(UnixDatagram)\n+    }\n+\n+    /// Returns the address of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n+    ///     let addr = sock.local_addr().expect(\"Couldn't get local address\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Returns the address of this socket's peer.\n+    ///\n+    /// The [`connect`] method will connect the socket to a peer.\n+    ///\n+    /// [`connect`]: UnixDatagram::connect\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.connect(\"/path/to/the/socket\")?;\n+    ///\n+    ///     let addr = sock.peer_addr().expect(\"Couldn't get peer address\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    fn recv_from_flags(\n+        &self,\n+        buf: &mut [u8],\n+        flags: libc::c_int,\n+    ) -> io::Result<(usize, SocketAddr)> {\n+        let mut count = 0;\n+        let addr = SocketAddr::new(|addr, len| unsafe {\n+            count = libc::recvfrom(\n+                *self.0.as_inner(),\n+                buf.as_mut_ptr() as *mut _,\n+                buf.len(),\n+                flags,\n+                addr,\n+                len,\n+            );\n+            if count > 0 {\n+                1\n+            } else if count == 0 {\n+                0\n+            } else {\n+                -1\n+            }\n+        })?;\n+\n+        Ok((count as usize, addr))\n+    }\n+\n+    /// Receives data from the socket.\n+    ///\n+    /// On success, returns the number of bytes read and the address from\n+    /// whence the data came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf = vec![0; 10];\n+    ///     let (size, sender) = sock.recv_from(buf.as_mut_slice())?;\n+    ///     println!(\"received {} bytes from {:?}\", size, sender);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn recv_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_flags(buf, 0)\n+    }\n+\n+    /// Receives data from the socket.\n+    ///\n+    /// On success, returns the number of bytes read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::bind(\"/path/to/the/socket\")?;\n+    ///     let mut buf = vec![0; 10];\n+    ///     sock.recv(buf.as_mut_slice()).expect(\"recv function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn recv(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    /// Receives data and ancillary data from socket.\n+    ///\n+    /// On success, returns the number of bytes read, if the data was truncated and the address from whence the msg came.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let mut fds = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     let (size, _truncated, sender) = sock.recv_vectored_with_ancillary_from(bufs, &mut ancillary)?;\n+    ///     println!(\"received {}\", size);\n+    ///     for ancillary_result in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn recv_vectored_with_ancillary_from(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<(usize, bool, SocketAddr)> {\n+        let (count, truncated, addr) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n+        let addr = addr?;\n+\n+        Ok((count, truncated, addr))\n+    }\n+\n+    /// Receives data and ancillary data from socket.\n+    ///\n+    /// On success, returns the number of bytes read and if the data was truncated.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let mut fds = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     let (size, _truncated) = sock.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     println!(\"received {}\", size);\n+    ///     for ancillary_result in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn recv_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<(usize, bool)> {\n+        let (count, truncated, addr) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n+        addr?;\n+\n+        Ok((count, truncated))\n+    }\n+\n+    /// Sends data on the socket to the specified address.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.send_to(b\"omelette au fromage\", \"/some/sock\").expect(\"send_to function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn send_to<P: AsRef<Path>>(&self, buf: &[u8], path: P) -> io::Result<usize> {\n+        unsafe {\n+            let (addr, len) = sockaddr_un(path.as_ref())?;\n+\n+            let count = cvt(libc::sendto(\n+                *self.0.as_inner(),\n+                buf.as_ptr() as *const _,\n+                buf.len(),\n+                MSG_NOSIGNAL,\n+                &addr as *const _ as *const _,\n+                len,\n+            ))?;\n+            Ok(count as usize)\n+        }\n+    }\n+\n+    /// Sends data on the socket to the socket's peer.\n+    ///\n+    /// The peer address may be set by the `connect` method, and this method\n+    /// will return an error if the socket has not already been connected.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.connect(\"/some/sock\").expect(\"Couldn't connect\");\n+    ///     sock.send(b\"omelette au fromage\").expect(\"send_to function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn send(&self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    /// Sends data and ancillary data on the socket to the specified address.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let fds = [0, 1, 2];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&fds[..]);\n+    ///     sock.send_vectored_with_ancillary_to(bufs, &mut ancillary, \"/some/sock\").expect(\"send_vectored_with_ancillary_to function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn send_vectored_with_ancillary_to<P: AsRef<Path>>(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+        path: P,\n+    ) -> io::Result<usize> {\n+        send_vectored_with_ancillary_to(&self.0, Some(path.as_ref()), bufs, ancillary)\n+    }\n+\n+    /// Sends data and ancillary data on the socket.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixDatagram, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let fds = [0, 1, 2];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&fds[..]);\n+    ///     sock.send_vectored_with_ancillary(bufs, &mut ancillary).expect(\"send_vectored_with_ancillary function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn send_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<usize> {\n+        send_vectored_with_ancillary_to(&self.0, None, bufs, ancillary)\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`recv`] and [`recv_from`] calls will\n+    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`]\n+    /// is passed to this method.\n+    ///\n+    /// [`recv`]: UnixDatagram::recv\n+    /// [`recv_from`]: UnixDatagram::recv_from\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_read_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"set_read_timeout function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::unbound()?;\n+    ///     let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    ///     let err = result.unwrap_err();\n+    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`send`] and [`send_to`] calls will\n+    /// block indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method.\n+    ///\n+    /// [`send`]: UnixDatagram::send\n+    /// [`send_to`]: UnixDatagram::send_to\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"set_write_timeout function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::unbound()?;\n+    ///     let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    ///     let err = result.unwrap_err();\n+    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_read_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"set_read_timeout function failed\");\n+    ///     assert_eq!(sock.read_timeout()?, Some(Duration::new(1, 0)));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"set_write_timeout function failed\");\n+    ///     assert_eq!(sock.write_timeout()?, Some(Duration::new(1, 0)));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_nonblocking(true).expect(\"set_nonblocking function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Moves the socket to pass unix credentials as control message in [`SocketAncillary`].\n+    ///\n+    /// Set the socket option `SO_PASSCRED`.\n+    ///\n+    /// # Examples\n+    ///\n+    #[cfg_attr(any(target_os = \"android\", target_os = \"linux\"), doc = \"```no_run\")]\n+    #[cfg_attr(not(any(target_os = \"android\", target_os = \"linux\")), doc = \"```ignore\")]\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.set_passcred(true).expect(\"set_passcred function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {\n+        self.0.set_passcred(passcred)\n+    }\n+\n+    /// Get the current value of the socket for passing unix credentials in [`SocketAncillary`].\n+    /// This value can be change by [`set_passcred`].\n+    ///\n+    /// Get the socket option `SO_PASSCRED`.\n+    ///\n+    /// [`set_passcred`]: UnixDatagram::set_passcred\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn passcred(&self) -> io::Result<bool> {\n+        self.0.passcred()\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     if let Ok(Some(err)) = sock.take_error() {\n+    ///         println!(\"Got error: {:?}\", err);\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Shut down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixDatagram;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let sock = UnixDatagram::unbound()?;\n+    ///     sock.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+\n+    /// Receives data on the socket from the remote address to which it is\n+    /// connected, without removing that data from the queue. On success,\n+    /// returns the number of bytes peeked.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_peek)]\n+    ///\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n+    ///     let mut buf = [0; 10];\n+    ///     let len = socket.peek(&mut buf).expect(\"peek failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.peek(buf)\n+    }\n+\n+    /// Receives a single datagram message on the socket, without removing it from the\n+    /// queue. On success, returns the number of bytes read and the origin.\n+    ///\n+    /// The function must be called with valid byte array `buf` of sufficient size to\n+    /// hold the message bytes. If a message is too long to fit in the supplied buffer,\n+    /// excess bytes may be discarded.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recvfrom` system call.\n+    ///\n+    /// Do not use this function to implement busy waiting, instead use `libc::poll` to\n+    /// synchronize IO events on one or more sockets.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_peek)]\n+    ///\n+    /// use std::os::unix::net::UnixDatagram;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixDatagram::bind(\"/tmp/sock\")?;\n+    ///     let mut buf = [0; 10];\n+    ///     let (len, addr) = socket.peek_from(&mut buf).expect(\"peek failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n+    pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n+        self.recv_from_flags(buf, libc::MSG_PEEK)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixDatagram {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixDatagram {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixDatagram {\n+        UnixDatagram(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixDatagram {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}"}, {"sha": "9803c6e27462c2dda9c222afed428dfa1038ed34", "filename": "library/std/src/sys/unix/ext/net/listener.rs", "status": "added", "additions": 319, "deletions": 0, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Flistener.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Flistener.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Flistener.rs?ref=af69066aa6afa7bff771a6ee9548b2b84a02a88a", "patch": "@@ -0,0 +1,319 @@\n+use super::{sockaddr_un, SocketAddr, UnixStream};\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::path::Path;\n+use crate::sys::cvt;\n+use crate::sys::net::Socket;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::{fmt, io, mem};\n+\n+/// A structure representing a Unix domain socket server.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+///\n+///     // accept connections and process them, spawning a new thread for each one\n+///     for stream in listener.incoming() {\n+///         match stream {\n+///             Ok(stream) => {\n+///                 /* connection succeeded */\n+///                 thread::spawn(|| handle_client(stream));\n+///             }\n+///             Err(err) => {\n+///                 /* connection failed */\n+///                 break;\n+///             }\n+///         }\n+///     }\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixListener(Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixListener {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixListener\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixListener {\n+    /// Creates a new `UnixListener` bound to the specified socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// let listener = match UnixListener::bind(\"/path/to/the/socket\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn bind<P: AsRef<Path>>(path: P) -> io::Result<UnixListener> {\n+        unsafe {\n+            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+            let (addr, len) = sockaddr_un(path.as_ref())?;\n+\n+            cvt(libc::bind(*inner.as_inner(), &addr as *const _ as *const _, len as _))?;\n+            cvt(libc::listen(*inner.as_inner(), 128))?;\n+\n+            Ok(UnixListener(inner))\n+        }\n+    }\n+\n+    /// Accepts a new incoming connection to this listener.\n+    ///\n+    /// This function will block the calling thread until a new Unix connection\n+    /// is established. When established, the corresponding [`UnixStream`] and\n+    /// the remote peer's address will be returned.\n+    ///\n+    /// [`UnixStream`]: crate::os::unix::net::UnixStream\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///\n+    ///     match listener.accept() {\n+    ///         Ok((socket, addr)) => println!(\"Got a client: {:?}\", addr),\n+    ///         Err(e) => println!(\"accept function failed: {:?}\", e),\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn accept(&self) -> io::Result<(UnixStream, SocketAddr)> {\n+        let mut storage: libc::sockaddr_un = unsafe { mem::zeroed() };\n+        let mut len = mem::size_of_val(&storage) as libc::socklen_t;\n+        let sock = self.0.accept(&mut storage as *mut _ as *mut _, &mut len)?;\n+        let addr = SocketAddr::from_parts(storage, len)?;\n+        Ok((UnixStream(sock), addr))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixListener` is a reference to the same socket that this\n+    /// object references. Both handles can be used to accept incoming\n+    /// connections and options set on one listener will affect the other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///     let listener_copy = listener.try_clone().expect(\"try_clone failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixListener> {\n+        self.0.duplicate().map(UnixListener)\n+    }\n+\n+    /// Returns the local socket address of this listener.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///     let addr = listener.local_addr().expect(\"Couldn't get local address\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// This will result in the `accept` operation becoming nonblocking,\n+    /// i.e., immediately returning from their calls. If the IO operation is\n+    /// successful, `Ok` is returned and no further action is required. If the\n+    /// IO operation could not be completed and needs to be retried, an error\n+    /// with kind [`io::ErrorKind::WouldBlock`] is returned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///     listener.set_nonblocking(true).expect(\"Couldn't set non blocking\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixListener;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/tmp/sock\")?;\n+    ///\n+    ///     if let Ok(Some(err)) = listener.take_error() {\n+    ///         println!(\"Got error: {:?}\", err);\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns `None`.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Returns an iterator over incoming connections.\n+    ///\n+    /// The iterator will never return [`None`] and will also not yield the\n+    /// peer's [`SocketAddr`] structure.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::thread;\n+    /// use std::os::unix::net::{UnixStream, UnixListener};\n+    ///\n+    /// fn handle_client(stream: UnixStream) {\n+    ///     // ...\n+    /// }\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+    ///\n+    ///     for stream in listener.incoming() {\n+    ///         match stream {\n+    ///             Ok(stream) => {\n+    ///                 thread::spawn(|| handle_client(stream));\n+    ///             }\n+    ///             Err(err) => {\n+    ///                 break;\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn incoming(&self) -> Incoming<'_> {\n+        Incoming { listener: self }\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixListener {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixListener {\n+        UnixListener(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixListener {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> IntoIterator for &'a UnixListener {\n+    type Item = io::Result<UnixStream>;\n+    type IntoIter = Incoming<'a>;\n+\n+    fn into_iter(self) -> Incoming<'a> {\n+        self.incoming()\n+    }\n+}\n+\n+/// An iterator over incoming connections to a [`UnixListener`].\n+///\n+/// It will never return [`None`].\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::thread;\n+/// use std::os::unix::net::{UnixStream, UnixListener};\n+///\n+/// fn handle_client(stream: UnixStream) {\n+///     // ...\n+/// }\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let listener = UnixListener::bind(\"/path/to/the/socket\")?;\n+///\n+///     for stream in listener.incoming() {\n+///         match stream {\n+///             Ok(stream) => {\n+///                 thread::spawn(|| handle_client(stream));\n+///             }\n+///             Err(err) => {\n+///                 break;\n+///             }\n+///         }\n+///     }\n+///     Ok(())\n+/// }\n+/// ```\n+#[derive(Debug)]\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct Incoming<'a> {\n+    listener: &'a UnixListener,\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> Iterator for Incoming<'a> {\n+    type Item = io::Result<UnixStream>;\n+\n+    fn next(&mut self) -> Option<io::Result<UnixStream>> {\n+        Some(self.listener.accept().map(|s| s.0))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (usize::MAX, None)\n+    }\n+}"}, {"sha": "3088ffb5e5c01b572a802271bc6ab94b465a9dc4", "filename": "library/std/src/sys/unix/ext/net/mod.rs", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fmod.rs?ref=af69066aa6afa7bff771a6ee9548b2b84a02a88a", "patch": "@@ -0,0 +1,54 @@\n+//! Unix-specific networking functionality\n+\n+#![stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+\n+mod addr;\n+#[doc(cfg(any(\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"emscripten\",\n+    target_os = \"freebsd\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+)))]\n+#[cfg(any(\n+    doc,\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"emscripten\",\n+    target_os = \"freebsd\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+))]\n+mod ancillary;\n+mod datagram;\n+mod listener;\n+mod raw_fd;\n+mod stream;\n+#[cfg(all(test, not(target_os = \"emscripten\")))]\n+mod tests;\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub use self::addr::*;\n+#[cfg(any(\n+    doc,\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"emscripten\",\n+    target_os = \"freebsd\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+))]\n+#[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+pub use self::ancillary::*;\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub use self::datagram::*;\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub use self::listener::*;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use self::raw_fd::*;\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub use self::stream::*;"}, {"sha": "c42fee4c73bcde72def7340c9909dac50b1d9032", "filename": "library/std/src/sys/unix/ext/net/raw_fd.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fraw_fd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fraw_fd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fraw_fd.rs?ref=af69066aa6afa7bff771a6ee9548b2b84a02a88a", "patch": "@@ -0,0 +1,40 @@\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+use crate::sys_common::{self, AsInner, FromInner, IntoInner};\n+use crate::{net, sys};\n+\n+macro_rules! impl_as_raw_fd {\n+    ($($t:ident)*) => {$(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl AsRawFd for net::$t {\n+            fn as_raw_fd(&self) -> RawFd {\n+                *self.as_inner().socket().as_inner()\n+            }\n+        }\n+    )*};\n+}\n+impl_as_raw_fd! { TcpStream TcpListener UdpSocket }\n+\n+macro_rules! impl_from_raw_fd {\n+    ($($t:ident)*) => {$(\n+        #[stable(feature = \"from_raw_os\", since = \"1.1.0\")]\n+        impl FromRawFd for net::$t {\n+            unsafe fn from_raw_fd(fd: RawFd) -> net::$t {\n+                let socket = sys::net::Socket::from_inner(fd);\n+                net::$t::from_inner(sys_common::net::$t::from_inner(socket))\n+            }\n+        }\n+    )*};\n+}\n+impl_from_raw_fd! { TcpStream TcpListener UdpSocket }\n+\n+macro_rules! impl_into_raw_fd {\n+    ($($t:ident)*) => {$(\n+        #[stable(feature = \"into_raw_os\", since = \"1.4.0\")]\n+        impl IntoRawFd for net::$t {\n+            fn into_raw_fd(self) -> RawFd {\n+                self.into_inner().into_socket().into_inner()\n+            }\n+        }\n+    )*};\n+}\n+impl_into_raw_fd! { TcpStream TcpListener UdpSocket }"}, {"sha": "9fe6b85837e33156818968f06c75a5776a640f58", "filename": "library/std/src/sys/unix/ext/net/stream.rs", "status": "added", "additions": 673, "deletions": 0, "changes": 673, "blob_url": "https://github.com/rust-lang/rust/blob/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Fstream.rs?ref=af69066aa6afa7bff771a6ee9548b2b84a02a88a", "patch": "@@ -0,0 +1,673 @@\n+#[cfg(any(\n+    doc,\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"emscripten\",\n+    target_os = \"freebsd\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+))]\n+use super::{recv_vectored_with_ancillary_from, send_vectored_with_ancillary_to, SocketAncillary};\n+use super::{sockaddr_un, SocketAddr};\n+use crate::fmt;\n+use crate::io::{self, Initializer, IoSlice, IoSliceMut};\n+use crate::net::Shutdown;\n+use crate::os::unix::io::{AsRawFd, FromRawFd, IntoRawFd, RawFd};\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"linux\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"ios\",\n+    target_os = \"macos\",\n+    target_os = \"openbsd\"\n+))]\n+use crate::os::unix::ucred;\n+use crate::path::Path;\n+use crate::sys::cvt;\n+use crate::sys::net::Socket;\n+use crate::sys_common::{AsInner, FromInner, IntoInner};\n+use crate::time::Duration;\n+\n+#[unstable(feature = \"peer_credentials_unix_socket\", issue = \"42839\", reason = \"unstable\")]\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"linux\",\n+    target_os = \"dragonfly\",\n+    target_os = \"freebsd\",\n+    target_os = \"ios\",\n+    target_os = \"macos\",\n+    target_os = \"openbsd\"\n+))]\n+pub use ucred::UCred;\n+\n+/// A Unix stream socket.\n+///\n+/// # Examples\n+///\n+/// ```no_run\n+/// use std::os::unix::net::UnixStream;\n+/// use std::io::prelude::*;\n+///\n+/// fn main() -> std::io::Result<()> {\n+///     let mut stream = UnixStream::connect(\"/path/to/my/socket\")?;\n+///     stream.write_all(b\"hello world\")?;\n+///     let mut response = String::new();\n+///     stream.read_to_string(&mut response)?;\n+///     println!(\"{}\", response);\n+///     Ok(())\n+/// }\n+/// ```\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+pub struct UnixStream(pub(super) Socket);\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl fmt::Debug for UnixStream {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut builder = fmt.debug_struct(\"UnixStream\");\n+        builder.field(\"fd\", self.0.as_inner());\n+        if let Ok(addr) = self.local_addr() {\n+            builder.field(\"local\", &addr);\n+        }\n+        if let Ok(addr) = self.peer_addr() {\n+            builder.field(\"peer\", &addr);\n+        }\n+        builder.finish()\n+    }\n+}\n+\n+impl UnixStream {\n+    /// Connects to the socket named by `path`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let socket = match UnixStream::connect(\"/tmp/sock\") {\n+    ///     Ok(sock) => sock,\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't connect: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn connect<P: AsRef<Path>>(path: P) -> io::Result<UnixStream> {\n+        unsafe {\n+            let inner = Socket::new_raw(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+            let (addr, len) = sockaddr_un(path.as_ref())?;\n+\n+            cvt(libc::connect(*inner.as_inner(), &addr as *const _ as *const _, len))?;\n+            Ok(UnixStream(inner))\n+        }\n+    }\n+\n+    /// Creates an unnamed pair of connected sockets.\n+    ///\n+    /// Returns two `UnixStream`s which are connected to each other.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// let (sock1, sock2) = match UnixStream::pair() {\n+    ///     Ok((sock1, sock2)) => (sock1, sock2),\n+    ///     Err(e) => {\n+    ///         println!(\"Couldn't create a pair of sockets: {:?}\", e);\n+    ///         return\n+    ///     }\n+    /// };\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn pair() -> io::Result<(UnixStream, UnixStream)> {\n+        let (i1, i2) = Socket::new_pair(libc::AF_UNIX, libc::SOCK_STREAM)?;\n+        Ok((UnixStream(i1), UnixStream(i2)))\n+    }\n+\n+    /// Creates a new independently owned handle to the underlying socket.\n+    ///\n+    /// The returned `UnixStream` is a reference to the same stream that this\n+    /// object references. Both handles will read and write the same stream of\n+    /// data, and options set on one stream will be propagated to the other\n+    /// stream.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let sock_copy = socket.try_clone().expect(\"Couldn't clone socket\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn try_clone(&self) -> io::Result<UnixStream> {\n+        self.0.duplicate().map(UnixStream)\n+    }\n+\n+    /// Returns the socket address of the local half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let addr = socket.local_addr().expect(\"Couldn't get local address\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn local_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getsockname(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Returns the socket address of the remote half of this connection.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let addr = socket.peer_addr().expect(\"Couldn't get peer address\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn peer_addr(&self) -> io::Result<SocketAddr> {\n+        SocketAddr::new(|addr, len| unsafe { libc::getpeername(*self.0.as_inner(), addr, len) })\n+    }\n+\n+    /// Gets the peer credentials for this Unix domain socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(peer_credentials_unix_socket)]\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let peer_cred = socket.peer_cred().expect(\"Couldn't get peer credentials\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"peer_credentials_unix_socket\", issue = \"42839\", reason = \"unstable\")]\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"linux\",\n+        target_os = \"dragonfly\",\n+        target_os = \"freebsd\",\n+        target_os = \"ios\",\n+        target_os = \"macos\",\n+        target_os = \"openbsd\"\n+    ))]\n+    pub fn peer_cred(&self) -> io::Result<UCred> {\n+        ucred::peer_cred(self)\n+    }\n+\n+    /// Sets the read timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`read`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method.\n+    ///\n+    /// [`read`]: io::Read::read\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let result = socket.set_read_timeout(Some(Duration::new(0, 0)));\n+    ///     let err = result.unwrap_err();\n+    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_read_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Sets the write timeout for the socket.\n+    ///\n+    /// If the provided value is [`None`], then [`write`] calls will block\n+    /// indefinitely. An [`Err`] is returned if the zero [`Duration`] is\n+    /// passed to this method.\n+    ///\n+    /// [`read`]: io::Read::read\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"Couldn't set write timeout\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// An [`Err`] is returned if the zero [`Duration`] is passed to this\n+    /// method:\n+    ///\n+    /// ```no_run\n+    /// use std::io;\n+    /// use std::net::UdpSocket;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UdpSocket::bind(\"127.0.0.1:34254\")?;\n+    ///     let result = socket.set_write_timeout(Some(Duration::new(0, 0)));\n+    ///     let err = result.unwrap_err();\n+    ///     assert_eq!(err.kind(), io::ErrorKind::InvalidInput);\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_write_timeout(&self, timeout: Option<Duration>) -> io::Result<()> {\n+        self.0.set_timeout(timeout, libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Returns the read timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_read_timeout(Some(Duration::new(1, 0))).expect(\"Couldn't set read timeout\");\n+    ///     assert_eq!(socket.read_timeout()?, Some(Duration::new(1, 0)));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn read_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_RCVTIMEO)\n+    }\n+\n+    /// Returns the write timeout of this socket.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::time::Duration;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_write_timeout(Some(Duration::new(1, 0)))\n+    ///         .expect(\"Couldn't set write timeout\");\n+    ///     assert_eq!(socket.write_timeout()?, Some(Duration::new(1, 0)));\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn write_timeout(&self) -> io::Result<Option<Duration>> {\n+        self.0.timeout(libc::SO_SNDTIMEO)\n+    }\n+\n+    /// Moves the socket into or out of nonblocking mode.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_nonblocking(true).expect(\"Couldn't set nonblocking\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n+        self.0.set_nonblocking(nonblocking)\n+    }\n+\n+    /// Moves the socket to pass unix credentials as control message in [`SocketAncillary`].\n+    ///\n+    /// Set the socket option `SO_PASSCRED`.\n+    ///\n+    /// # Examples\n+    ///\n+    #[cfg_attr(any(target_os = \"android\", target_os = \"linux\"), doc = \"```no_run\")]\n+    #[cfg_attr(not(any(target_os = \"android\", target_os = \"linux\")), doc = \"```ignore\")]\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.set_passcred(true).expect(\"Couldn't set passcred\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {\n+        self.0.set_passcred(passcred)\n+    }\n+\n+    /// Get the current value of the socket for passing unix credentials in [`SocketAncillary`].\n+    /// This value can be change by [`set_passcred`].\n+    ///\n+    /// Get the socket option `SO_PASSCRED`.\n+    ///\n+    /// [`set_passcred`]: UnixStream::set_passcred\n+    #[cfg(any(doc, target_os = \"android\", target_os = \"linux\",))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn passcred(&self) -> io::Result<bool> {\n+        self.0.passcred()\n+    }\n+\n+    /// Returns the value of the `SO_ERROR` option.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     if let Ok(Some(err)) = socket.take_error() {\n+    ///         println!(\"Got error: {:?}\", err);\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    ///\n+    /// # Platform specific\n+    /// On Redox this always returns `None`.\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn take_error(&self) -> io::Result<Option<io::Error>> {\n+        self.0.take_error()\n+    }\n+\n+    /// Shuts down the read, write, or both halves of this connection.\n+    ///\n+    /// This function will cause all pending and future I/O calls on the\n+    /// specified portions to immediately return with an appropriate value\n+    /// (see the documentation of [`Shutdown`]).\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// use std::os::unix::net::UnixStream;\n+    /// use std::net::Shutdown;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     socket.shutdown(Shutdown::Both).expect(\"shutdown function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+    pub fn shutdown(&self, how: Shutdown) -> io::Result<()> {\n+        self.0.shutdown(how)\n+    }\n+\n+    /// Receives data on the socket from the remote address to which it is\n+    /// connected, without removing that data from the queue. On success,\n+    /// returns the number of bytes peeked.\n+    ///\n+    /// Successive calls return the same data. This is accomplished by passing\n+    /// `MSG_PEEK` as a flag to the underlying `recv` system call.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_peek)]\n+    ///\n+    /// use std::os::unix::net::UnixStream;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let mut buf = [0; 10];\n+    ///     let len = socket.peek(&mut buf).expect(\"peek failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"unix_socket_peek\", issue = \"76923\")]\n+    pub fn peek(&self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.peek(buf)\n+    }\n+\n+    /// Receives data and ancillary data from socket.\n+    ///\n+    /// On success, returns the number of bytes read.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary, AncillaryData};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let mut fds = [0; 8];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     let size = socket.recv_vectored_with_ancillary(bufs, &mut ancillary)?;\n+    ///     println!(\"received {}\", size);\n+    ///     for ancillary_result in ancillary.messages() {\n+    ///         if let AncillaryData::ScmRights(scm_rights) = ancillary_result.unwrap() {\n+    ///             for fd in scm_rights {\n+    ///                 println!(\"receive file descriptor: {}\", fd);\n+    ///             }\n+    ///         }\n+    ///     }\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn recv_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<usize> {\n+        let (count, _, _) = recv_vectored_with_ancillary_from(&self.0, bufs, ancillary)?;\n+\n+        Ok(count)\n+    }\n+\n+    /// Sends data and ancillary data on the socket.\n+    ///\n+    /// On success, returns the number of bytes written.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```no_run\n+    /// #![feature(unix_socket_ancillary_data)]\n+    /// use std::os::unix::net::{UnixStream, SocketAncillary};\n+    /// use std::io::IoSliceMut;\n+    ///\n+    /// fn main() -> std::io::Result<()> {\n+    ///     let socket = UnixStream::connect(\"/tmp/sock\")?;\n+    ///     let mut buf1 = [1; 8];\n+    ///     let mut buf2 = [2; 16];\n+    ///     let mut buf3 = [3; 8];\n+    ///     let mut bufs = &mut [\n+    ///         IoSliceMut::new(&mut buf1),\n+    ///         IoSliceMut::new(&mut buf2),\n+    ///         IoSliceMut::new(&mut buf3),\n+    ///     ][..];\n+    ///     let fds = [0, 1, 2];\n+    ///     let mut ancillary_buffer = [0; 128];\n+    ///     let mut ancillary = SocketAncillary::new(&mut ancillary_buffer[..]);\n+    ///     ancillary.add_fds(&fds[..]);\n+    ///     socket.send_vectored_with_ancillary(bufs, &mut ancillary).expect(\"send_vectored_with_ancillary function failed\");\n+    ///     Ok(())\n+    /// }\n+    /// ```\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+    ))]\n+    #[unstable(feature = \"unix_socket_ancillary_data\", issue = \"76915\")]\n+    pub fn send_vectored_with_ancillary(\n+        &self,\n+        bufs: &mut [IoSliceMut<'_>],\n+        ancillary: &mut SocketAncillary<'_>,\n+    ) -> io::Result<usize> {\n+        send_vectored_with_ancillary_to(&self.0, None, bufs, ancillary)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl io::Read for UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        io::Read::read(&mut &*self, buf)\n+    }\n+\n+    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        io::Read::read_vectored(&mut &*self, bufs)\n+    }\n+\n+    #[inline]\n+    fn is_read_vectored(&self) -> bool {\n+        io::Read::is_read_vectored(&&*self)\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Read for &'a UnixStream {\n+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {\n+        self.0.read(buf)\n+    }\n+\n+    fn read_vectored(&mut self, bufs: &mut [IoSliceMut<'_>]) -> io::Result<usize> {\n+        self.0.read_vectored(bufs)\n+    }\n+\n+    #[inline]\n+    fn is_read_vectored(&self) -> bool {\n+        self.0.is_read_vectored()\n+    }\n+\n+    #[inline]\n+    unsafe fn initializer(&self) -> Initializer {\n+        Initializer::nop()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl io::Write for UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        io::Write::write(&mut &*self, buf)\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        io::Write::write_vectored(&mut &*self, bufs)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        io::Write::is_write_vectored(&&*self)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        io::Write::flush(&mut &*self)\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl<'a> io::Write for &'a UnixStream {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.0.write(buf)\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        self.0.write_vectored(bufs)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        self.0.is_write_vectored()\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl AsRawFd for UnixStream {\n+    fn as_raw_fd(&self) -> RawFd {\n+        *self.0.as_inner()\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl FromRawFd for UnixStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> UnixStream {\n+        UnixStream(Socket::from_inner(fd))\n+    }\n+}\n+\n+#[stable(feature = \"unix_socket\", since = \"1.10.0\")]\n+impl IntoRawFd for UnixStream {\n+    fn into_raw_fd(self) -> RawFd {\n+        self.0.into_inner()\n+    }\n+}"}, {"sha": "97a016904b4a4be83e6b0338a19adec039ac859e", "filename": "library/std/src/sys/unix/ext/net/tests.rs", "status": "modified", "additions": 189, "deletions": 3, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fext%2Fnet%2Ftests.rs?ref=af69066aa6afa7bff771a6ee9548b2b84a02a88a", "patch": "@@ -1,11 +1,30 @@\n+use super::*;\n use crate::io::prelude::*;\n-use crate::io::{self, ErrorKind};\n+use crate::io::{self, ErrorKind, IoSlice, IoSliceMut};\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"emscripten\",\n+    target_os = \"freebsd\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+))]\n+use crate::iter::FromIterator;\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"emscripten\",\n+    target_os = \"freebsd\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+))]\n+use crate::os::unix::io::AsRawFd;\n use crate::sys_common::io::test::tmpdir;\n use crate::thread;\n use crate::time::Duration;\n \n-use super::*;\n-\n macro_rules! or_panic {\n     ($e:expr) => {\n         match $e {\n@@ -452,3 +471,170 @@ fn test_unix_datagram_peek_from() {\n     assert_eq!(size, 11);\n     assert_eq!(msg, &buf[..]);\n }\n+\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"emscripten\",\n+    target_os = \"freebsd\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+))]\n+#[test]\n+fn test_send_vectored_fds_unix_stream() {\n+    let (s1, s2) = or_panic!(UnixStream::pair());\n+\n+    let mut buf1 = [1; 8];\n+    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n+\n+    let mut ancillary1_buffer = [0; 128];\n+    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n+    assert!(ancillary1.add_fds(&[s1.as_raw_fd()][..]));\n+\n+    let usize = or_panic!(s1.send_vectored_with_ancillary(&mut bufs_send, &mut ancillary1));\n+    assert_eq!(usize, 8);\n+\n+    let mut buf2 = [0; 8];\n+    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n+\n+    let mut ancillary2_buffer = [0; 128];\n+    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n+\n+    let usize = or_panic!(s2.recv_vectored_with_ancillary(&mut bufs_recv, &mut ancillary2));\n+    assert_eq!(usize, 8);\n+    assert_eq!(buf1, buf2);\n+\n+    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n+    assert_eq!(ancillary_data_vec.len(), 1);\n+    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap().unwrap() {\n+        let fd_vec = Vec::from_iter(scm_rights);\n+        assert_eq!(fd_vec.len(), 1);\n+        unsafe {\n+            libc::close(fd_vec[0]);\n+        }\n+    } else {\n+        unreachable!(\"must be ScmRights\");\n+    }\n+}\n+\n+#[cfg(any(target_os = \"android\", target_os = \"emscripten\", target_os = \"linux\",))]\n+#[test]\n+fn test_send_vectored_with_ancillary_to_unix_datagram() {\n+    fn getpid() -> libc::pid_t {\n+        unsafe { libc::getpid() }\n+    }\n+\n+    fn getuid() -> libc::uid_t {\n+        unsafe { libc::getuid() }\n+    }\n+\n+    fn getgid() -> libc::gid_t {\n+        unsafe { libc::getgid() }\n+    }\n+\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+    let path2 = dir.path().join(\"sock2\");\n+\n+    let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n+\n+    or_panic!(bsock2.set_passcred(true));\n+\n+    let mut buf1 = [1; 8];\n+    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n+\n+    let mut ancillary1_buffer = [0; 128];\n+    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n+    let mut cred1 = SocketCred::new();\n+    cred1.set_pid(getpid());\n+    cred1.set_uid(getuid());\n+    cred1.set_gid(getgid());\n+    assert!(ancillary1.add_creds(&[cred1.clone()][..]));\n+\n+    let usize =\n+        or_panic!(bsock1.send_vectored_with_ancillary_to(&mut bufs_send, &mut ancillary1, &path2));\n+    assert_eq!(usize, 8);\n+\n+    let mut buf2 = [0; 8];\n+    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n+\n+    let mut ancillary2_buffer = [0; 128];\n+    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n+\n+    let (usize, truncated, _addr) =\n+        or_panic!(bsock2.recv_vectored_with_ancillary_from(&mut bufs_recv, &mut ancillary2));\n+    assert_eq!(ancillary2.truncated(), false);\n+    assert_eq!(usize, 8);\n+    assert_eq!(truncated, false);\n+    assert_eq!(buf1, buf2);\n+\n+    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n+    assert_eq!(ancillary_data_vec.len(), 1);\n+    if let AncillaryData::ScmCredentials(scm_credentials) =\n+        ancillary_data_vec.pop().unwrap().unwrap()\n+    {\n+        let cred_vec = Vec::from_iter(scm_credentials);\n+        assert_eq!(cred_vec.len(), 1);\n+        assert_eq!(cred1.get_pid(), cred_vec[0].get_pid());\n+        assert_eq!(cred1.get_uid(), cred_vec[0].get_uid());\n+        assert_eq!(cred1.get_gid(), cred_vec[0].get_gid());\n+    } else {\n+        unreachable!(\"must be ScmCredentials\");\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"android\",\n+    target_os = \"dragonfly\",\n+    target_os = \"emscripten\",\n+    target_os = \"freebsd\",\n+    target_os = \"linux\",\n+    target_os = \"netbsd\",\n+    target_os = \"openbsd\",\n+))]\n+#[test]\n+fn test_send_vectored_with_ancillary_unix_datagram() {\n+    let dir = tmpdir();\n+    let path1 = dir.path().join(\"sock1\");\n+    let path2 = dir.path().join(\"sock2\");\n+\n+    let bsock1 = or_panic!(UnixDatagram::bind(&path1));\n+    let bsock2 = or_panic!(UnixDatagram::bind(&path2));\n+\n+    let mut buf1 = [1; 8];\n+    let mut bufs_send = &mut [IoSliceMut::new(&mut buf1[..])][..];\n+\n+    let mut ancillary1_buffer = [0; 128];\n+    let mut ancillary1 = SocketAncillary::new(&mut ancillary1_buffer[..]);\n+    assert!(ancillary1.add_fds(&[bsock1.as_raw_fd()][..]));\n+\n+    or_panic!(bsock1.connect(&path2));\n+    let usize = or_panic!(bsock1.send_vectored_with_ancillary(&mut bufs_send, &mut ancillary1));\n+    assert_eq!(usize, 8);\n+\n+    let mut buf2 = [0; 8];\n+    let mut bufs_recv = &mut [IoSliceMut::new(&mut buf2[..])][..];\n+\n+    let mut ancillary2_buffer = [0; 128];\n+    let mut ancillary2 = SocketAncillary::new(&mut ancillary2_buffer[..]);\n+\n+    let (usize, truncated) =\n+        or_panic!(bsock2.recv_vectored_with_ancillary(&mut bufs_recv, &mut ancillary2));\n+    assert_eq!(usize, 8);\n+    assert_eq!(truncated, false);\n+    assert_eq!(buf1, buf2);\n+\n+    let mut ancillary_data_vec = Vec::from_iter(ancillary2.messages());\n+    assert_eq!(ancillary_data_vec.len(), 1);\n+    if let AncillaryData::ScmRights(scm_rights) = ancillary_data_vec.pop().unwrap().unwrap() {\n+        let fd_vec = Vec::from_iter(scm_rights);\n+        assert_eq!(fd_vec.len(), 1);\n+        unsafe {\n+            libc::close(fd_vec[0]);\n+        }\n+    } else {\n+        unreachable!(\"must be ScmRights\");\n+    }\n+}"}, {"sha": "7198a2f08d668d04019e062abb8341cbbb978ebf", "filename": "library/std/src/sys/unix/net.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af69066aa6afa7bff771a6ee9548b2b84a02a88a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fnet.rs?ref=af69066aa6afa7bff771a6ee9548b2b84a02a88a", "patch": "@@ -275,6 +275,20 @@ impl Socket {\n         self.recv_from_with_flags(buf, 0)\n     }\n \n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+    ))]\n+    pub fn recv_msg(&self, msg: &mut libc::msghdr) -> io::Result<usize> {\n+        let n = cvt(unsafe { libc::recvmsg(self.0.raw(), msg, libc::MSG_CMSG_CLOEXEC) })?;\n+        Ok(n as usize)\n+    }\n+\n     pub fn peek_from(&self, buf: &mut [u8]) -> io::Result<(usize, SocketAddr)> {\n         self.recv_from_with_flags(buf, MSG_PEEK)\n     }\n@@ -292,6 +306,20 @@ impl Socket {\n         self.0.is_write_vectored()\n     }\n \n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"dragonfly\",\n+        target_os = \"emscripten\",\n+        target_os = \"freebsd\",\n+        target_os = \"linux\",\n+        target_os = \"netbsd\",\n+        target_os = \"openbsd\",\n+    ))]\n+    pub fn send_msg(&self, msg: &mut libc::msghdr) -> io::Result<usize> {\n+        let n = cvt(unsafe { libc::sendmsg(self.0.raw(), msg, 0) })?;\n+        Ok(n as usize)\n+    }\n+\n     pub fn set_timeout(&self, dur: Option<Duration>, kind: libc::c_int) -> io::Result<()> {\n         let timeout = match dur {\n             Some(dur) => {\n@@ -351,6 +379,17 @@ impl Socket {\n         Ok(raw != 0)\n     }\n \n+    #[cfg(any(target_os = \"android\", target_os = \"linux\",))]\n+    pub fn set_passcred(&self, passcred: bool) -> io::Result<()> {\n+        setsockopt(self, libc::SOL_SOCKET, libc::SO_PASSCRED, passcred as libc::c_int)\n+    }\n+\n+    #[cfg(any(target_os = \"android\", target_os = \"linux\",))]\n+    pub fn passcred(&self) -> io::Result<bool> {\n+        let passcred: libc::c_int = getsockopt(self, libc::SOL_SOCKET, libc::SO_PASSCRED)?;\n+        Ok(passcred != 0)\n+    }\n+\n     #[cfg(not(any(target_os = \"solaris\", target_os = \"illumos\")))]\n     pub fn set_nonblocking(&self, nonblocking: bool) -> io::Result<()> {\n         let mut nonblocking = nonblocking as libc::c_int;"}]}