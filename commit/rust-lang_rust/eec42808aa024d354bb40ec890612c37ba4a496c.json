{"sha": "eec42808aa024d354bb40ec890612c37ba4a496c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlYzQyODA4YWEwMjRkMzU0YmI0MGVjODkwNjEyYzM3YmE0YTQ5NmM=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-04-19T04:31:43Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-04-28T21:56:11Z"}, "message": "Update bitmask API", "tree": {"sha": "85836dfa0c89687cde4351a1acd5562c6dc60577", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85836dfa0c89687cde4351a1acd5562c6dc60577"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eec42808aa024d354bb40ec890612c37ba4a496c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eec42808aa024d354bb40ec890612c37ba4a496c", "html_url": "https://github.com/rust-lang/rust/commit/eec42808aa024d354bb40ec890612c37ba4a496c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eec42808aa024d354bb40ec890612c37ba4a496c/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "url": "https://api.github.com/repos/rust-lang/rust/commits/da42aa5403659a6f1f6f4bc4b65d177f13fb6536", "html_url": "https://github.com/rust-lang/rust/commit/da42aa5403659a6f1f6f4bc4b65d177f13fb6536"}], "stats": {"total": 356, "additions": 196, "deletions": 160}, "files": [{"sha": "1812a9c624dc3c4b7c8d08ef691b99a4691c8106", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=eec42808aa024d354bb40ec890612c37ba4a496c", "patch": "@@ -76,6 +76,9 @@ extern \"platform-intrinsic\" {\n     pub(crate) fn simd_reduce_and<T, U>(x: T) -> U;\n     pub(crate) fn simd_reduce_or<T, U>(x: T) -> U;\n     pub(crate) fn simd_reduce_xor<T, U>(x: T) -> U;\n+\n+    // truncate integer vector to bitmask\n+    pub(crate) fn simd_bitmask<T, U>(x: T) -> U;\n }\n \n #[cfg(feature = \"std\")]"}, {"sha": "2d84b1306ea5a50f3b43f0644d4a00d8b3eed17f", "filename": "crates/core_simd/src/lanes_at_most_32.rs", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flanes_at_most_32.rs?ref=eec42808aa024d354bb40ec890612c37ba4a496c", "patch": "@@ -1,14 +1,38 @@\n /// Implemented for vectors that are supported by the implementation.\n-pub trait LanesAtMost32 {}\n+pub trait LanesAtMost32: sealed::Sealed {\n+    #[doc(hidden)]\n+    type BitMask: Into<u64>;\n+}\n+\n+mod sealed {\n+    pub trait Sealed {}\n+}\n \n macro_rules! impl_for {\n     { $name:ident } => {\n-        impl LanesAtMost32 for $name<1> {}\n-        impl LanesAtMost32 for $name<2> {}\n-        impl LanesAtMost32 for $name<4> {}\n-        impl LanesAtMost32 for $name<8> {}\n-        impl LanesAtMost32 for $name<16> {}\n-        impl LanesAtMost32 for $name<32> {}\n+        impl<const LANES: usize> sealed::Sealed for $name<LANES>\n+        where\n+            $name<LANES>: LanesAtMost32,\n+        {}\n+\n+        impl LanesAtMost32 for $name<1> {\n+            type BitMask = u8;\n+        }\n+        impl LanesAtMost32 for $name<2> {\n+            type BitMask = u8;\n+        }\n+        impl LanesAtMost32 for $name<4> {\n+            type BitMask = u8;\n+        }\n+        impl LanesAtMost32 for $name<8> {\n+            type BitMask = u8;\n+        }\n+        impl LanesAtMost32 for $name<16> {\n+            type BitMask = u16;\n+        }\n+        impl LanesAtMost32 for $name<32> {\n+            type BitMask = u32;\n+        }\n     }\n }\n "}, {"sha": "bf7c70c5a3ad5747794f5fd9bab72a656bbf3654", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 48, "deletions": 98, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=eec42808aa024d354bb40ec890612c37ba4a496c", "patch": "@@ -1,13 +1,9 @@\n-use crate::LanesAtMost32;\n-\n /// A mask where each lane is represented by a single bit.\n #[derive(Copy, Clone, Debug, PartialOrd, PartialEq, Ord, Eq, Hash)]\n #[repr(transparent)]\n-pub struct BitMask<const LANES: usize>(u64)\n+pub struct BitMask<const LANES: usize>(u64);\n \n impl<const LANES: usize> BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n {\n     #[inline]\n     pub fn splat(value: bool) -> Self {\n@@ -25,13 +21,50 @@ where\n \n     #[inline]\n     pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n-        self.0 ^= ((value ^ self.test(lane)) as u64) << lane\n+        self.0 ^= ((value ^ self.test_unchecked(lane)) as u64) << lane\n+    }\n+\n+    #[inline]\n+    pub fn to_int<V, T>(self) -> V\n+    where\n+        V: Default + AsMut<[T; LANES]>,\n+        T: From<i8>,\n+    {\n+        // TODO this should be an intrinsic sign-extension\n+        let mut v = V::default();\n+        for i in 0..LANES {\n+            let lane = unsafe { self.test_unchecked(i) };\n+            v.as_mut()[i] = (-(lane as i8)).into();\n+        }\n+        v\n+    }\n+\n+    #[inline]\n+    pub unsafe fn from_int_unchecked<V>(value: V) -> Self\n+    where\n+        V: crate::LanesAtMost32,\n+    {\n+        let mask: V::BitMask = crate::intrinsics::simd_bitmask(value);\n+        Self(mask.into())\n+    }\n+\n+    #[inline]\n+    pub fn to_bitmask(self) -> u64 {\n+        self.0\n+    }\n+\n+    #[inline]\n+    pub fn any(self) -> bool {\n+        self != Self::splat(false)\n+    }\n+\n+    #[inline]\n+    pub fn all(self) -> bool {\n+        self == Self::splat(true)\n     }\n }\n \n impl<const LANES: usize> core::ops::BitAnd for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n {\n     type Output = Self;\n     #[inline]\n@@ -41,8 +74,6 @@ where\n }\n \n impl<const LANES: usize> core::ops::BitAnd<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n {\n     type Output = Self;\n     #[inline]\n@@ -52,8 +83,6 @@ where\n }\n \n impl<const LANES: usize> core::ops::BitAnd<BitMask<LANES>> for bool\n-where\n-    BitMask<LANES>: LanesAtMost32,\n {\n     type Output = BitMask<LANES>;\n     #[inline]\n@@ -63,8 +92,6 @@ where\n }\n \n impl<const LANES: usize> core::ops::BitOr for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n {\n     type Output = Self;\n     #[inline]\n@@ -73,31 +100,7 @@ where\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitOr<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    type Output = Self;\n-    #[inline]\n-    fn bitor(self, rhs: bool) -> Self {\n-        self | Self::splat(rhs)\n-    }\n-}\n-\n-impl<const LANES: usize> core::ops::BitOr<BitMask<LANES>> for bool\n-where\n-    BitMask<LANES>: LanesAtMost32,\n-{\n-    type Output = BitMask<LANES>;\n-    #[inline]\n-    fn bitor(self, rhs: BitMask<LANES>) -> BitMask<LANES> {\n-        BitMask::<LANES>::splat(self) | rhs\n-    }\n-}\n-\n impl<const LANES: usize> core::ops::BitXor for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n {\n     type Output = Self;\n     #[inline]\n@@ -106,95 +109,42 @@ where\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitXor<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    type Output = Self;\n-    #[inline]\n-    fn bitxor(self, rhs: bool) -> Self::Output {\n-        self ^ Self::splat(rhs)\n-    }\n-}\n-\n-impl<const LANES: usize> core::ops::BitXor<BitMask<LANES>> for bool\n-where\n-    BitMask<LANES>: LanesAtMost32,\n-{\n-    type Output = BitMask<LANES>;\n-    #[inline]\n-    fn bitxor(self, rhs: BitMask<LANES>) -> Self::Output {\n-        BitMask::<LANES>::splat(self) ^ rhs\n-    }\n-}\n-\n impl<const LANES: usize> core::ops::Not for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n {\n     type Output = BitMask<LANES>;\n     #[inline]\n     fn not(self) -> Self::Output {\n-        Self(!self.0)\n+        Self(!self.0) & Self::splat(true)\n     }\n }\n \n impl<const LANES: usize> core::ops::BitAndAssign for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n {\n     #[inline]\n     fn bitand_assign(&mut self, rhs: Self) {\n         self.0 &= rhs.0;\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitAndAssign<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    #[inline]\n-    fn bitand_assign(&mut self, rhs: bool) {\n-        *self &= Self::splat(rhs);\n-    }\n-}\n-\n impl<const LANES: usize> core::ops::BitOrAssign for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n {\n     #[inline]\n     fn bitor_assign(&mut self, rhs: Self) {\n         self.0 |= rhs.0;\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitOrAssign<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    #[inline]\n-    fn bitor_assign(&mut self, rhs: bool) {\n-        *self |= Self::splat(rhs);\n-    }\n-}\n-\n impl<const LANES: usize> core::ops::BitXorAssign for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n {\n     #[inline]\n     fn bitxor_assign(&mut self, rhs: Self) {\n         self.0 ^= rhs.0;\n     }\n }\n \n-impl<const LANES: usize> core::ops::BitXorAssign<bool> for BitMask<LANES>\n-where\n-    Self: LanesAtMost32,\n-{\n-    #[inline]\n-    fn bitxor_assign(&mut self, rhs: bool) {\n-        *self ^= Self::splat(rhs);\n-    }\n-}\n+pub type Mask8<const LANES: usize> = BitMask<LANES>;\n+pub type Mask16<const LANES: usize> = BitMask<LANES>;\n+pub type Mask32<const LANES: usize> = BitMask<LANES>;\n+pub type Mask64<const LANES: usize> = BitMask<LANES>;\n+pub type Mask128<const LANES: usize> = BitMask<LANES>;\n+pub type MaskSize<const LANES: usize> = BitMask<LANES>;"}, {"sha": "2d1ddd6dc305000def297334284f08c73df7cfda", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 8, "deletions": 51, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=eec42808aa024d354bb40ec890612c37ba4a496c", "patch": "@@ -46,14 +46,12 @@ macro_rules! define_mask {\n             }\n \n             #[inline]\n-            pub fn test(&self, lane: usize) -> bool {\n-                assert!(lane < LANES, \"lane index out of range\");\n+            pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n                 self.0[lane] == -1\n             }\n \n             #[inline]\n-            pub fn set(&mut self, lane: usize, value: bool) {\n-                assert!(lane < LANES, \"lane index out of range\");\n+            pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n                 self.0[lane] = if value {\n                     -1\n                 } else {\n@@ -70,6 +68,12 @@ macro_rules! define_mask {\n             pub unsafe fn from_int_unchecked(value: crate::$type<LANES>) -> Self {\n                 Self(value)\n             }\n+\n+            #[inline]\n+            pub fn to_bitmask(self) -> u64 {\n+                let mask: <crate::$type<LANES> as crate::LanesAtMost32>::BitMask = unsafe { crate::intrinsics::simd_bitmask(self.0) };\n+                mask.into()\n+            }\n         }\n \n         impl<const LANES: usize> core::convert::From<$name<LANES>> for crate::$type<LANES>\n@@ -81,53 +85,6 @@ macro_rules! define_mask {\n             }\n         }\n \n-        impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                f.debug_list()\n-                    .entries((0..LANES).map(|lane| self.test(lane)))\n-                    .finish()\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::fmt::Binary for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Binary::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::fmt::Octal for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Octal::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::fmt::LowerHex for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::LowerHex::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl<const LANES: usize> core::fmt::UpperHex for $name<LANES>\n-        where\n-            crate::$type<LANES>: crate::LanesAtMost32,\n-        {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::UpperHex::fmt(&self.0, f)\n-            }\n-        }\n-\n         impl<const LANES: usize> core::ops::BitAnd for $name<LANES>\n         where\n             crate::$type<LANES>: crate::LanesAtMost32,"}, {"sha": "e5352ef4d1a28791e03ea00a4a2fd5e1f89801be", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 89, "deletions": 4, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=eec42808aa024d354bb40ec890612c37ba4a496c", "patch": "@@ -8,6 +8,12 @@ mod mask_impl;\n \n use crate::{LanesAtMost32, SimdI16, SimdI32, SimdI64, SimdI8, SimdIsize};\n \n+/// Converts masks to bitmasks, with one bit set for each lane.\n+pub trait ToBitMask {\n+    /// Converts this mask to a bitmask.\n+    fn to_bitmask(self) -> u64;\n+}\n+\n macro_rules! define_opaque_mask {\n     {\n         $(#[$attr:meta])*\n@@ -61,13 +67,53 @@ macro_rules! define_opaque_mask {\n                 Self(<$inner_ty>::from_int_unchecked(value))\n             }\n \n+            /// Converts a vector of integers to a mask, where 0 represents `false` and -1\n+            /// represents `true`.\n+            ///\n+            /// # Panics\n+            /// Panics if any lane is not 0 or -1.\n+            #[inline]\n+            pub fn from_int(value: $bits_ty<LANES>) -> Self {\n+                assert!(\n+                    (value.lanes_eq($bits_ty::splat(0)) | value.lanes_eq($bits_ty::splat(-1))).all(),\n+                    \"all values must be either 0 or -1\",\n+                );\n+                unsafe { Self::from_int_unchecked(value) }\n+            }\n+\n+            /// Converts the mask to a vector of integers, where 0 represents `false` and -1\n+            /// represents `true`.\n+            #[inline]\n+            pub fn to_int(self) -> $bits_ty<LANES> {\n+                self.0.to_int()\n+            }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Safety\n+            /// `lane` must be less than `LANES`.\n+            #[inline]\n+            pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n+                self.0.test_unchecked(lane)\n+            }\n+\n             /// Tests the value of the specified lane.\n             ///\n             /// # Panics\n             /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n             #[inline]\n             pub fn test(&self, lane: usize) -> bool {\n-                self.0.test(lane)\n+                assert!(lane < LANES, \"lane index out of range\");\n+                unsafe { self.test_unchecked(lane) }\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Safety\n+            /// `lane` must be less than `LANES`.\n+            #[inline]\n+            pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n+                self.0.set_unchecked(lane, value);\n             }\n \n             /// Sets the value of the specified lane.\n@@ -76,7 +122,44 @@ macro_rules! define_opaque_mask {\n             /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n             #[inline]\n             pub fn set(&mut self, lane: usize, value: bool) {\n-                self.0.set(lane, value);\n+                assert!(lane < LANES, \"lane index out of range\");\n+                unsafe { self.set_unchecked(lane, value); }\n+            }\n+        }\n+\n+        impl ToBitMask for $name<1> {\n+            fn to_bitmask(self) -> u64 {\n+                self.0.to_bitmask()\n+            }\n+        }\n+\n+        impl ToBitMask for $name<2> {\n+            fn to_bitmask(self) -> u64 {\n+                self.0.to_bitmask()\n+            }\n+        }\n+\n+        impl ToBitMask for $name<4> {\n+            fn to_bitmask(self) -> u64 {\n+                self.0.to_bitmask()\n+            }\n+        }\n+\n+        impl ToBitMask for $name<8> {\n+            fn to_bitmask(self) -> u64 {\n+                self.0.to_bitmask()\n+            }\n+        }\n+\n+        impl ToBitMask for $name<16> {\n+            fn to_bitmask(self) -> u64 {\n+                self.0.to_bitmask()\n+            }\n+        }\n+\n+        impl ToBitMask for $name<32> {\n+            fn to_bitmask(self) -> u64 {\n+                self.0.to_bitmask()\n             }\n         }\n \n@@ -147,10 +230,12 @@ macro_rules! define_opaque_mask {\n \n         impl<const LANES: usize> core::fmt::Debug for $name<LANES>\n         where\n-            $bits_ty<LANES>: LanesAtMost32,\n+            $bits_ty<LANES>: crate::LanesAtMost32,\n         {\n             fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Debug::fmt(&self.0, f)\n+                f.debug_list()\n+                    .entries((0..LANES).map(|lane| self.test(lane)))\n+                    .finish()\n             }\n         }\n "}, {"sha": "be83f4c2ec7764c2c990419706ac2f0dba1aae75", "filename": "crates/core_simd/tests/masks.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eec42808aa024d354bb40ec890612c37ba4a496c/crates%2Fcore_simd%2Ftests%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fmasks.rs?ref=eec42808aa024d354bb40ec890612c37ba4a496c", "patch": "@@ -56,6 +56,23 @@ macro_rules! test_mask_api {\n                 v.set(2, true);\n                 assert!(!v.all());\n             }\n+\n+            #[test]\n+            fn roundtrip_int_conversion() {\n+                let values = [true, false, false, true, false, false, true, false];\n+                let mask = core_simd::$name::<8>::from_array(values);\n+                let int = mask.to_int();\n+                assert_eq!(int.to_array(), [-1, 0, 0, -1, 0, 0, -1, 0]);\n+                assert_eq!(core_simd::$name::<8>::from_int(int), mask);\n+            }\n+\n+            #[test]\n+            fn to_bitmask() {\n+                use core_simd::ToBitMask;\n+                let values = [true, false, false, true, false, false, true, false];\n+                let mask = core_simd::$name::<8>::from_array(values);\n+                assert_eq!(mask.to_bitmask(), 0b01001001);\n+            }\n         }\n     }\n }"}]}