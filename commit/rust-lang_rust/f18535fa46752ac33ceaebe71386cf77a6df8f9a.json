{"sha": "f18535fa46752ac33ceaebe71386cf77a6df8f9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxODUzNWZhNDY3NTJhYzMzY2VhZWJlNzEzODZjZjc3YTZkZjhmOWE=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-07-06T01:18:38Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-10-02T03:28:08Z"}, "message": "Refactor `rustc_peek`\n\nWe now use `DataflowResultsCursor` to get the dataflow state before\ncalls to `rustc_peek`. The original version used a custom implementation\nthat only looked at assignment statements. This also extends\n`rustc_peek` to take arguments by-value as well as by-reference, and\nallows *all* dataflow analyses, not just those dependent on `MoveData`,\nto be inspected.", "tree": {"sha": "2ce9b0e5768a58c187a7ec4243456e64afbb8fc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2ce9b0e5768a58c187a7ec4243456e64afbb8fc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f18535fa46752ac33ceaebe71386cf77a6df8f9a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f18535fa46752ac33ceaebe71386cf77a6df8f9a", "html_url": "https://github.com/rust-lang/rust/commit/f18535fa46752ac33ceaebe71386cf77a6df8f9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f18535fa46752ac33ceaebe71386cf77a6df8f9a/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "702b45e409495a41afcccbe87a251a692b0cefab", "url": "https://api.github.com/repos/rust-lang/rust/commits/702b45e409495a41afcccbe87a251a692b0cefab", "html_url": "https://github.com/rust-lang/rust/commit/702b45e409495a41afcccbe87a251a692b0cefab"}], "stats": {"total": 284, "additions": 153, "deletions": 131}, "files": [{"sha": "d0ffcbbae885574aac2a88dfc4cd0aaec38ed46e", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 153, "deletions": 131, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/f18535fa46752ac33ceaebe71386cf77a6df8f9a/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f18535fa46752ac33ceaebe71386cf77a6df8f9a/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=f18535fa46752ac33ceaebe71386cf77a6df8f9a", "patch": "@@ -3,16 +3,17 @@ use syntax::ast;\n use syntax::symbol::sym;\n use syntax_pos::Span;\n \n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty::{self, TyCtxt, Ty};\n use rustc::hir::def_id::DefId;\n-use rustc::mir::{self, Body, Location};\n+use rustc::mir::{self, Body, Location, Local};\n use rustc_index::bit_set::BitSet;\n use crate::transform::{MirPass, MirSource};\n \n use crate::dataflow::{do_dataflow, DebugFormatted};\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::BitDenotation;\n use crate::dataflow::DataflowResults;\n+use crate::dataflow::DataflowResultsCursor;\n use crate::dataflow::{\n     DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeUninitializedPlaces\n };\n@@ -88,151 +89,172 @@ pub fn sanity_check_via_rustc_peek<'tcx, O>(\n     def_id: DefId,\n     _attributes: &[ast::Attribute],\n     results: &DataflowResults<'tcx, O>,\n-) where\n-    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n-{\n+) where O: RustcPeekAt<'tcx> {\n     debug!(\"sanity_check_via_rustc_peek def_id: {:?}\", def_id);\n-    // FIXME: this is not DRY. Figure out way to abstract this and\n-    // `dataflow::build_sets`. (But note it is doing non-standard\n-    // stuff, so such generalization may not be realistic.)\n \n-    for bb in body.basic_blocks().indices() {\n-        each_block(tcx, body, results, bb);\n-    }\n-}\n+    let mut cursor = DataflowResultsCursor::new(results, body);\n \n-fn each_block<'tcx, O>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &Body<'tcx>,\n-    results: &DataflowResults<'tcx, O>,\n-    bb: mir::BasicBlock,\n-) where\n-    O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n-{\n-    let move_data = results.0.operator.move_data();\n-    let mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = body[bb];\n-\n-    let (args, span) = match is_rustc_peek(tcx, terminator) {\n-        Some(args_and_span) => args_and_span,\n-        None => return,\n-    };\n-    assert!(args.len() == 1);\n-    let peek_arg_place = match args[0] {\n-        mir::Operand::Copy(ref place @ mir::Place {\n-            base: mir::PlaceBase::Local(_),\n-            projection: box [],\n-        }) |\n-        mir::Operand::Move(ref place @ mir::Place {\n-            base: mir::PlaceBase::Local(_),\n-            projection: box [],\n-        }) => Some(place),\n-        _ => None,\n-    };\n-\n-    let peek_arg_place = match peek_arg_place {\n-        Some(arg) => arg,\n-        None => {\n-            tcx.sess.diagnostic().span_err(\n-                span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n-            return;\n-        }\n-    };\n-\n-    let mut on_entry = results.0.sets.entry_set_for(bb.index()).to_owned();\n-    let mut trans = results.0.sets.trans_for(bb.index()).clone();\n-\n-    // Emulate effect of all statements in the block up to (but not\n-    // including) the borrow within `peek_arg_place`. Do *not* include\n-    // call to `peek_arg_place` itself (since we are peeking the state\n-    // of the argument at time immediate preceding Call to\n-    // `rustc_peek`).\n-\n-    for (j, stmt) in statements.iter().enumerate() {\n-        debug!(\"rustc_peek: ({:?},{}) {:?}\", bb, j, stmt);\n-        let (place, rvalue) = match stmt.kind {\n-            mir::StatementKind::Assign(box(ref place, ref rvalue)) => {\n-                (place, rvalue)\n+    let peek_calls = body\n+            .basic_blocks()\n+            .iter_enumerated()\n+            .filter_map(|(bb, block_data)| {\n+                PeekCall::from_terminator(tcx, block_data.terminator())\n+                    .map(|call| (bb, block_data, call))\n+            });\n+\n+    for (bb, block_data, call) in peek_calls {\n+        // Look for a sequence like the following to indicate that we should be peeking at `_1`:\n+        //    _2 = &_1;\n+        //    rustc_peek(_2);\n+        //\n+        //    /* or */\n+        //\n+        //    _2 = _1;\n+        //    rustc_peek(_2);\n+        let (statement_index, peek_rval) = block_data\n+            .statements\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(i, stmt)| value_assigned_to_local(stmt, call.arg).map(|rval| (i, rval)))\n+            .next()\n+            .expect(\"call to rustc_peek should be preceded by \\\n+                    assignment to temporary holding its argument\");\n+\n+        match (call.kind, peek_rval) {\n+            | (PeekCallKind::ByRef, mir::Rvalue::Ref(_, _, place))\n+            | (PeekCallKind::ByVal, mir::Rvalue::Use(mir::Operand::Move(place)))\n+            | (PeekCallKind::ByVal, mir::Rvalue::Use(mir::Operand::Copy(place)))\n+            => {\n+                let loc = Location { block: bb, statement_index };\n+                cursor.seek(loc);\n+                let state = cursor.get();\n+                results.operator().peek_at(tcx, place, state, call);\n             }\n-            mir::StatementKind::FakeRead(..) |\n-            mir::StatementKind::StorageLive(_) |\n-            mir::StatementKind::StorageDead(_) |\n-            mir::StatementKind::InlineAsm { .. } |\n-            mir::StatementKind::Retag { .. } |\n-            mir::StatementKind::AscribeUserType(..) |\n-            mir::StatementKind::Nop => continue,\n-            mir::StatementKind::SetDiscriminant{ .. } =>\n-                span_bug!(stmt.source_info.span,\n-                          \"sanity_check should run before Deaggregator inserts SetDiscriminant\"),\n-        };\n-\n-        if place == peek_arg_place {\n-            if let mir::Rvalue::Ref(_, mir::BorrowKind::Shared, ref peeking_at_place) = *rvalue {\n-                // Okay, our search is over.\n-                match move_data.rev_lookup.find(peeking_at_place.as_ref()) {\n-                    LookupResult::Exact(peek_mpi) => {\n-                        let bit_state = on_entry.contains(peek_mpi);\n-                        debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n-                               place, peeking_at_place, bit_state);\n-                        if !bit_state {\n-                            tcx.sess.span_err(span, \"rustc_peek: bit not set\");\n-                        }\n-                    }\n-                    LookupResult::Parent(..) => {\n-                        tcx.sess.span_err(span, \"rustc_peek: argument untracked\");\n-                    }\n-                }\n-                return;\n-            } else {\n-                // Our search should have been over, but the input\n-                // does not match expectations of `rustc_peek` for\n-                // this sanity_check.\n+\n+            _ => {\n                 let msg = \"rustc_peek: argument expression \\\n-                           must be immediate borrow of form `&expr`\";\n-                tcx.sess.span_err(span, msg);\n+                           must be either `place` or `&place`\";\n+                tcx.sess.span_err(call.span, msg);\n             }\n         }\n+    }\n+}\n \n-        let lhs_mpi = move_data.rev_lookup.find(place.as_ref());\n-\n-        debug!(\"rustc_peek: computing effect on place: {:?} ({:?}) in stmt: {:?}\",\n-               place, lhs_mpi, stmt);\n-        // reset GEN and KILL sets before emulating their effect.\n-        trans.clear();\n-        results.0.operator.before_statement_effect(\n-            &mut trans,\n-            Location { block: bb, statement_index: j });\n-        results.0.operator.statement_effect(\n-            &mut trans,\n-            Location { block: bb, statement_index: j });\n-        trans.apply(&mut on_entry);\n+/// If `stmt` is an assignment where the LHS is the given local (with no projections), returns the\n+/// RHS of the assignment.\n+fn value_assigned_to_local<'a, 'tcx>(\n+    stmt: &'a mir::Statement<'tcx>,\n+    local: Local,\n+) -> Option<&'a mir::Rvalue<'tcx>> {\n+    if let mir::StatementKind::Assign(box (place, rvalue)) = &stmt.kind {\n+        if let mir::Place { base: mir::PlaceBase::Local(l), projection: box [] } = place {\n+            if local == *l {\n+                return Some(&*rvalue);\n+            }\n+        }\n     }\n \n-    results.0.operator.before_terminator_effect(\n-        &mut trans,\n-        Location { block: bb, statement_index: statements.len() });\n+    None\n+}\n \n-    tcx.sess.span_err(span, &format!(\"rustc_peek: MIR did not match \\\n-                                      anticipated pattern; note that \\\n-                                      rustc_peek expects input of \\\n-                                      form `&expr`\"));\n+#[derive(Clone, Copy, Debug)]\n+enum PeekCallKind {\n+    ByVal,\n+    ByRef,\n }\n \n-fn is_rustc_peek<'a, 'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    terminator: &'a Option<mir::Terminator<'tcx>>,\n-) -> Option<(&'a [mir::Operand<'tcx>], Span)> {\n-    if let Some(mir::Terminator { ref kind, source_info, .. }) = *terminator {\n-        if let mir::TerminatorKind::Call { func: ref oper, ref args, .. } = *kind {\n-            if let mir::Operand::Constant(ref func) = *oper {\n-                if let ty::FnDef(def_id, _) = func.literal.ty.kind {\n-                    let abi = tcx.fn_sig(def_id).abi();\n-                    let name = tcx.item_name(def_id);\n-                    if abi == Abi::RustIntrinsic && name == sym::rustc_peek {\n-                        return Some((args, source_info.span));\n+impl PeekCallKind {\n+    fn from_arg_ty(arg: Ty<'_>) -> Self {\n+        match arg.kind {\n+            ty::Ref(_, _, _) => PeekCallKind::ByRef,\n+            _ => PeekCallKind::ByVal,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct PeekCall {\n+    arg: Local,\n+    kind: PeekCallKind,\n+    span: Span,\n+}\n+\n+impl PeekCall {\n+    fn from_terminator<'tcx>(\n+        tcx: TyCtxt<'tcx>,\n+        terminator: &mir::Terminator<'tcx>,\n+    ) -> Option<Self> {\n+        use mir::{Operand, Place, PlaceBase};\n+\n+        let span = terminator.source_info.span;\n+        if let mir::TerminatorKind::Call { func: Operand::Constant(func), args, .. } =\n+            &terminator.kind\n+        {\n+            if let ty::FnDef(def_id, substs) = func.literal.ty.kind {\n+                let sig = tcx.fn_sig(def_id);\n+                let name = tcx.item_name(def_id);\n+                if sig.abi() != Abi::RustIntrinsic || name != sym::rustc_peek {\n+                    return None;\n+                }\n+\n+                assert_eq!(args.len(), 1);\n+                let kind = PeekCallKind::from_arg_ty(substs.type_at(0));\n+                let arg = match args[0] {\n+                    | Operand::Copy(Place { base: PlaceBase::Local(local), projection: box [] })\n+                    | Operand::Move(Place { base: PlaceBase::Local(local), projection: box [] })\n+                    => local,\n+\n+                    _ => {\n+                        tcx.sess.diagnostic().span_err(\n+                            span, \"dataflow::sanity_check cannot feed a non-temp to rustc_peek.\");\n+                        return None;\n                     }\n+                };\n+\n+                return Some(PeekCall {\n+                    arg,\n+                    kind,\n+                    span,\n+                });\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+pub trait RustcPeekAt<'tcx>: BitDenotation<'tcx> {\n+    fn peek_at(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        place: &mir::Place<'tcx>,\n+        flow_state: &BitSet<Self::Idx>,\n+        call: PeekCall,\n+    );\n+}\n+\n+impl<'tcx, O> RustcPeekAt<'tcx> for O\n+    where O: BitDenotation<'tcx, Idx = MovePathIndex> + HasMoveData<'tcx>,\n+{\n+    fn peek_at(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        place: &mir::Place<'tcx>,\n+        flow_state: &BitSet<Self::Idx>,\n+        call: PeekCall,\n+    ) {\n+        match self.move_data().rev_lookup.find(place.as_ref()) {\n+            LookupResult::Exact(peek_mpi) => {\n+                let bit_state = flow_state.contains(peek_mpi);\n+                debug!(\"rustc_peek({:?} = &{:?}) bit_state: {}\",\n+                       call.arg, place, bit_state);\n+                if !bit_state {\n+                    tcx.sess.span_err(call.span, \"rustc_peek: bit not set\");\n                 }\n             }\n+            LookupResult::Parent(..) => {\n+                tcx.sess.span_err(call.span, \"rustc_peek: argument untracked\");\n+            }\n         }\n     }\n-    return None;\n }"}]}