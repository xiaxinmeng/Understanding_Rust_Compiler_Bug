{"sha": "7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281", "node_id": "C_kwDOAAsO6NoAKDdmODljN2MzMmRjZWUwZTAxYmIxZWRhMDBmYmRiNzdhOWFiNWUyODE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-23T05:40:50Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-03-24T16:00:27Z"}, "message": "Make EvalCtxt's infcx private", "tree": {"sha": "9ad9a6d93f5965dc3e1bc96b4f4603c939b815d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ad9a6d93f5965dc3e1bc96b4f4603c939b815d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281", "html_url": "https://github.com/rust-lang/rust/commit/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f421586eed77de266a3f99ffa8a5687b7d2d893c", "url": "https://api.github.com/repos/rust-lang/rust/commits/f421586eed77de266a3f99ffa8a5687b7d2d893c", "html_url": "https://github.com/rust-lang/rust/commit/f421586eed77de266a3f99ffa8a5687b7d2d893c"}], "stats": {"total": 209, "additions": 134, "deletions": 75}, "files": [{"sha": "d393ab1ba4a8553e7e3e76a29e0a0227bdcd4bf2", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "modified", "additions": 11, "deletions": 46, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281", "patch": "@@ -8,17 +8,15 @@\n /// section of the [rustc-dev-guide][c].\n ///\n /// [c]: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n-use self::canonicalize::{CanonicalizeMode, Canonicalizer};\n+pub use self::canonicalize::{CanonicalizeMode, Canonicalizer};\n+\n use super::{CanonicalGoal, Certainty, EvalCtxt, Goal};\n-use super::{CanonicalResponse, ExternalConstraints, QueryResult, Response};\n-use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n+use super::{CanonicalResponse, QueryResult, Response};\n use rustc_infer::infer::canonical::CanonicalVarValues;\n use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::solve::ExternalConstraintsData;\n-use rustc_infer::traits::ObligationCause;\n use rustc_middle::ty::{self, GenericArgKind};\n-use rustc_span::DUMMY_SP;\n use std::iter;\n use std::ops::Deref;\n \n@@ -32,12 +30,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n     ) -> (Vec<ty::GenericArg<'tcx>>, CanonicalGoal<'tcx>) {\n         let mut orig_values = Default::default();\n-        let canonical_goal = Canonicalizer::canonicalize(\n-            self.infcx,\n-            CanonicalizeMode::Input,\n-            &mut orig_values,\n-            goal,\n-        );\n+        let canonical_goal = self.canonicalize(CanonicalizeMode::Input, &mut orig_values, goal);\n         (orig_values, canonical_goal)\n     }\n \n@@ -58,35 +51,14 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let external_constraints = self.compute_external_query_constraints()?;\n \n         let response = Response { var_values: self.var_values, external_constraints, certainty };\n-        let canonical = Canonicalizer::canonicalize(\n-            self.infcx,\n+        let canonical = self.canonicalize(\n             CanonicalizeMode::Response { max_input_universe: self.max_input_universe },\n             &mut Default::default(),\n             response,\n         );\n         Ok(canonical)\n     }\n \n-    #[instrument(level = \"debug\", skip(self), ret)]\n-    fn compute_external_query_constraints(&self) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n-        // Cannot use `take_registered_region_obligations` as we may compute the response\n-        // inside of a `probe` whenever we have multiple choices inside of the solver.\n-        let region_obligations = self.infcx.inner.borrow().region_obligations().to_owned();\n-        let region_constraints = self.infcx.with_region_constraints(|region_constraints| {\n-            make_query_region_constraints(\n-                self.tcx(),\n-                region_obligations\n-                    .iter()\n-                    .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category())),\n-                region_constraints,\n-            )\n-        });\n-        let opaque_types = self.infcx.clone_opaque_types_for_query_response();\n-        Ok(self\n-            .tcx()\n-            .mk_external_constraints(ExternalConstraintsData { region_constraints, opaque_types }))\n-    }\n-\n     /// After calling a canonical query, we apply the constraints returned\n     /// by the query using this function.\n     ///\n@@ -126,10 +98,10 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         // FIXME: Longterm canonical queries should deal with all placeholders\n         // created inside of the query directly instead of returning them to the\n         // caller.\n-        let prev_universe = self.infcx.universe();\n+        let prev_universe = self.universe();\n         let universes_created_in_query = response.max_universe.index() + 1;\n         for _ in 0..universes_created_in_query {\n-            self.infcx.create_next_universe();\n+            self.create_next_universe();\n         }\n \n         let var_values = response.value.var_values;\n@@ -172,7 +144,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                     // A variable from inside a binder of the query. While ideally these shouldn't\n                     // exist at all (see the FIXME at the start of this method), we have to deal with\n                     // them for now.\n-                    self.infcx.instantiate_canonical_var(DUMMY_SP, info, |idx| {\n+                    self.instantiate_canonical_var(info, |idx| {\n                         ty::UniverseIndex::from(prev_universe.index() + idx.index())\n                     })\n                 } else if info.is_existential() {\n@@ -186,7 +158,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                     if let Some(v) = opt_values[index] {\n                         v\n                     } else {\n-                        self.infcx.instantiate_canonical_var(DUMMY_SP, info, |_| prev_universe)\n+                        self.instantiate_canonical_var(info, |_| prev_universe)\n                     }\n                 } else {\n                     // For placeholders which were already part of the input, we simply map this\n@@ -219,15 +191,8 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     fn register_region_constraints(&mut self, region_constraints: &QueryRegionConstraints<'tcx>) {\n         for &(ty::OutlivesPredicate(lhs, rhs), _) in &region_constraints.outlives {\n             match lhs.unpack() {\n-                GenericArgKind::Lifetime(lhs) => self.infcx.region_outlives_predicate(\n-                    &ObligationCause::dummy(),\n-                    ty::Binder::dummy(ty::OutlivesPredicate(lhs, rhs)),\n-                ),\n-                GenericArgKind::Type(lhs) => self.infcx.register_region_obligation_with_cause(\n-                    lhs,\n-                    rhs,\n-                    &ObligationCause::dummy(),\n-                ),\n+                GenericArgKind::Lifetime(lhs) => self.register_region_outlives(lhs, rhs),\n+                GenericArgKind::Type(lhs) => self.register_ty_outlives(lhs, rhs),\n                 GenericArgKind::Const(_) => bug!(\"const outlives: {lhs:?}: {rhs:?}\"),\n             }\n         }"}, {"sha": "92aff517fbb8bb701b20f96b52d2a0fb42051666", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 108, "deletions": 4, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281", "patch": "@@ -1,28 +1,49 @@\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::at::ToTrace;\n-use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n+use rustc_infer::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarValues};\n use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{\n     DefineOpaqueTypes, InferCtxt, InferOk, LateBoundRegionConversionTime, TyCtxtInferExt,\n };\n use rustc_infer::traits::query::NoSolution;\n-use rustc_infer::traits::solve::{CanonicalGoal, Certainty, MaybeCause, QueryResult};\n use rustc_infer::traits::ObligationCause;\n use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use rustc_middle::traits::solve::{\n+    CanonicalGoal, Certainty, ExternalConstraints, ExternalConstraintsData, MaybeCause, QueryResult,\n+};\n use rustc_middle::ty::{\n     self, Ty, TyCtxt, TypeFoldable, TypeSuperVisitable, TypeVisitable, TypeVisitableExt,\n     TypeVisitor,\n };\n use rustc_span::DUMMY_SP;\n use std::ops::ControlFlow;\n \n+use crate::traits::specialization_graph;\n+\n+use super::canonical::{CanonicalizeMode, Canonicalizer};\n use super::search_graph::{self, OverflowHandler};\n use super::SolverMode;\n use super::{search_graph::SearchGraph, Goal};\n \n pub struct EvalCtxt<'a, 'tcx> {\n-    // FIXME: should be private.\n-    pub(super) infcx: &'a InferCtxt<'tcx>,\n+    /// The inference context that backs (mostly) inference and placeholder terms\n+    /// instantiated while solving goals.\n+    ///\n+    /// NOTE: The `InferCtxt` that backs the `EvalCtxt` is intentionally private,\n+    /// because the `InferCtxt` is much more general than `EvalCtxt`. Methods such\n+    /// as  `take_registered_region_obligations` can mess up query responses,\n+    /// using `At::normalize` is totally wrong, calling `evaluate_root_goal` can\n+    /// cause coinductive unsoundness, etc.\n+    ///\n+    /// Methods that are generally of use for trait solving are *intentionally*\n+    /// re-declared through the `EvalCtxt` below, often with cleaner signatures\n+    /// since we don't care about things like `ObligationCause`s and `Span`s here.\n+    /// If some `InferCtxt` method is missing, please first think defensively about\n+    /// the method's compatibility with this solver, or if an existing one does\n+    /// the job already.\n+    infcx: &'a InferCtxt<'tcx>,\n+\n     pub(super) var_values: CanonicalVarValues<'tcx>,\n     /// The highest universe index nameable by the caller.\n     ///\n@@ -548,4 +569,87 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     pub(super) fn universe(&self) -> ty::UniverseIndex {\n         self.infcx.universe()\n     }\n+\n+    pub(super) fn create_next_universe(&self) -> ty::UniverseIndex {\n+        self.infcx.create_next_universe()\n+    }\n+\n+    pub(super) fn instantiate_canonical_var(\n+        &self,\n+        cv_info: CanonicalVarInfo<'tcx>,\n+        universe_map: impl Fn(ty::UniverseIndex) -> ty::UniverseIndex,\n+    ) -> ty::GenericArg<'tcx> {\n+        self.infcx.instantiate_canonical_var(DUMMY_SP, cv_info, universe_map)\n+    }\n+\n+    pub(super) fn translate_substs(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        source_impl: DefId,\n+        source_substs: ty::SubstsRef<'tcx>,\n+        target_node: specialization_graph::Node,\n+    ) -> ty::SubstsRef<'tcx> {\n+        crate::traits::translate_substs(\n+            self.infcx,\n+            param_env,\n+            source_impl,\n+            source_substs,\n+            target_node,\n+        )\n+    }\n+\n+    pub(super) fn register_ty_outlives(&self, ty: Ty<'tcx>, lt: ty::Region<'tcx>) {\n+        self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n+    }\n+\n+    pub(super) fn register_region_outlives(&self, a: ty::Region<'tcx>, b: ty::Region<'tcx>) {\n+        // `b : a` ==> `a <= b`\n+        // (inlined from `InferCtxt::region_outlives_predicate`)\n+        self.infcx.sub_regions(\n+            rustc_infer::infer::SubregionOrigin::RelateRegionParamBound(DUMMY_SP),\n+            b,\n+            a,\n+        );\n+    }\n+\n+    /// Computes the list of goals required for `arg` to be well-formed\n+    pub(super) fn well_formed_goals(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        arg: ty::GenericArg<'tcx>,\n+    ) -> Option<impl Iterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>> {\n+        crate::traits::wf::unnormalized_obligations(self.infcx, param_env, arg)\n+            .map(|obligations| obligations.into_iter().map(|obligation| obligation.into()))\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn compute_external_query_constraints(\n+        &self,\n+    ) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+        // Cannot use `take_registered_region_obligations` as we may compute the response\n+        // inside of a `probe` whenever we have multiple choices inside of the solver.\n+        let region_obligations = self.infcx.inner.borrow().region_obligations().to_owned();\n+        let region_constraints = self.infcx.with_region_constraints(|region_constraints| {\n+            make_query_region_constraints(\n+                self.tcx(),\n+                region_obligations\n+                    .iter()\n+                    .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category())),\n+                region_constraints,\n+            )\n+        });\n+        let opaque_types = self.infcx.clone_opaque_types_for_query_response();\n+        Ok(self\n+            .tcx()\n+            .mk_external_constraints(ExternalConstraintsData { region_constraints, opaque_types }))\n+    }\n+\n+    pub(super) fn canonicalize<T: TypeFoldable<TyCtxt<'tcx>>>(\n+        &self,\n+        canonicalize_mode: CanonicalizeMode,\n+        variables: &mut Vec<ty::GenericArg<'tcx>>,\n+        value: T,\n+    ) -> Canonical<'tcx, T> {\n+        Canonicalizer::canonicalize(self.infcx, canonicalize_mode, variables, value)\n+    }\n }"}, {"sha": "7c01d5d2bef92519d372c1b2eae9304c99660f0a", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 8, "deletions": 16, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281", "patch": "@@ -15,16 +15,14 @@ use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n-    CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n-    Goal, QueryResult, Response,\n+    CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraintsData, Goal, QueryResult,\n+    Response,\n };\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n     CoercePredicate, RegionOutlivesPredicate, SubtypePredicate, TypeOutlivesPredicate,\n };\n \n-use crate::traits::ObligationCause;\n-\n mod assembly;\n mod canonical;\n mod eval_ctxt;\n@@ -68,7 +66,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n         let ty::OutlivesPredicate(ty, lt) = goal.predicate;\n-        self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n+        self.register_ty_outlives(ty, lt);\n         self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n@@ -77,10 +75,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        self.infcx.region_outlives_predicate(\n-            &ObligationCause::dummy(),\n-            ty::Binder::dummy(goal.predicate),\n-        );\n+        let ty::OutlivesPredicate(a, b) = goal.predicate;\n+        self.register_region_outlives(a, b);\n         self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n     }\n \n@@ -146,13 +142,9 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         &mut self,\n         goal: Goal<'tcx, ty::GenericArg<'tcx>>,\n     ) -> QueryResult<'tcx> {\n-        match crate::traits::wf::unnormalized_obligations(\n-            self.infcx,\n-            goal.param_env,\n-            goal.predicate,\n-        ) {\n-            Some(obligations) => {\n-                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+        match self.well_formed_goals(goal.param_env, goal.predicate) {\n+            Some(goals) => {\n+                self.add_goals(goals);\n                 self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n             }\n             None => self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS),"}, {"sha": "4c61a2cb2cc7809d8432289daf1e63af00a6727a", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=7f89c7c32dcee0e01bb1eda00fbdb77a9ab5e281", "patch": "@@ -1,4 +1,4 @@\n-use crate::traits::{specialization_graph, translate_substs};\n+use crate::traits::specialization_graph;\n \n use super::assembly;\n use super::trait_goals::structural_traits;\n@@ -7,7 +7,6 @@ use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefId;\n use rustc_hir::LangItem;\n-use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::specialization_graph::LeafDef;\n use rustc_infer::traits::Reveal;\n@@ -168,7 +167,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n             // return ambiguity this would otherwise be incomplete, resulting in\n             // unsoundness during coherence (#105782).\n             let Some(assoc_def) = fetch_eligible_assoc_item_def(\n-                ecx.infcx,\n+                ecx,\n                 goal.param_env,\n                 goal_trait_ref,\n                 goal.predicate.def_id(),\n@@ -199,8 +198,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal_trait_ref.def_id,\n                 impl_substs,\n             );\n-            let substs = translate_substs(\n-                ecx.infcx,\n+            let substs = ecx.translate_substs(\n                 goal.param_env,\n                 impl_def_id,\n                 impl_substs_with_gat,\n@@ -500,15 +498,15 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n ///\n /// FIXME: We should merge these 3 implementations as it's likely that they otherwise\n /// diverge.\n-#[instrument(level = \"debug\", skip(infcx, param_env), ret)]\n+#[instrument(level = \"debug\", skip(ecx, param_env), ret)]\n fn fetch_eligible_assoc_item_def<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n+    ecx: &EvalCtxt<'_, 'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     goal_trait_ref: ty::TraitRef<'tcx>,\n     trait_assoc_def_id: DefId,\n     impl_def_id: DefId,\n ) -> Result<Option<LeafDef>, NoSolution> {\n-    let node_item = specialization_graph::assoc_def(infcx.tcx, impl_def_id, trait_assoc_def_id)\n+    let node_item = specialization_graph::assoc_def(ecx.tcx(), impl_def_id, trait_assoc_def_id)\n         .map_err(|ErrorGuaranteed { .. }| NoSolution)?;\n \n     let eligible = if node_item.is_final() {\n@@ -520,7 +518,7 @@ fn fetch_eligible_assoc_item_def<'tcx>(\n         // transmute checking and polymorphic MIR optimizations could\n         // get a result which isn't correct for all monomorphizations.\n         if param_env.reveal() == Reveal::All {\n-            let poly_trait_ref = infcx.resolve_vars_if_possible(goal_trait_ref);\n+            let poly_trait_ref = ecx.resolve_vars_if_possible(goal_trait_ref);\n             !poly_trait_ref.still_further_specializable()\n         } else {\n             debug!(?node_item.item.def_id, \"not eligible due to default\");"}]}