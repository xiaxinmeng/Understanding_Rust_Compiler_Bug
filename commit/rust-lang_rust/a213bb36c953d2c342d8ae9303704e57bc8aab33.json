{"sha": "a213bb36c953d2c342d8ae9303704e57bc8aab33", "node_id": "C_kwDOAAsO6NoAKGEyMTNiYjM2Yzk1M2QyYzM0MmQ4YWU5MzAzNzA0ZTU3YmM4YWFiMzM", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-12-04T03:19:10Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2022-12-19T16:46:17Z"}, "message": "implement the skeleton of the updated trait solver", "tree": {"sha": "01fa1c6b8fa4b3e5099424ef9aba0c282fb43d94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/01fa1c6b8fa4b3e5099424ef9aba0c282fb43d94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a213bb36c953d2c342d8ae9303704e57bc8aab33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a213bb36c953d2c342d8ae9303704e57bc8aab33", "html_url": "https://github.com/rust-lang/rust/commit/a213bb36c953d2c342d8ae9303704e57bc8aab33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a213bb36c953d2c342d8ae9303704e57bc8aab33/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4653c93e4442d88bf3278067183c8fdc0be74a1f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4653c93e4442d88bf3278067183c8fdc0be74a1f", "html_url": "https://github.com/rust-lang/rust/commit/4653c93e4442d88bf3278067183c8fdc0be74a1f"}], "stats": {"total": 1656, "additions": 1569, "deletions": 87}, "files": [{"sha": "a722613e3310efacb04b8636609c2dff4772e5c7", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -151,7 +151,11 @@ impl<'tcx> InferCtxt<'tcx> {\n         })\n     }\n \n-    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+    /// FIXME: This method should only be used for canonical queries and therefore be private.\n+    ///\n+    /// As the new solver does canonicalization slightly differently, this is also used there\n+    /// for now. This should hopefully change fairly soon.\n+    pub fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n         self.inner\n             .borrow_mut()\n             .opaque_type_storage"}, {"sha": "0b32f67a81e16bb3fcea96e999fdb1bf273b1f00", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -300,6 +300,16 @@ impl<'tcx, V> Canonical<'tcx, V> {\n         let Canonical { max_universe, variables, value } = self;\n         Canonical { max_universe, variables, value: map_op(value) }\n     }\n+\n+    /// Allows you to map the `value` of a canonical while keeping the same set of\n+    /// bound variables.\n+    ///\n+    /// **WARNING:** This function is very easy to mis-use, hence the name! See\n+    /// the comment of [Canonical::unchecked_map] for more details.\n+    pub fn unchecked_rebind<W>(self, value: W) -> Canonical<'tcx, W> {\n+        let Canonical { max_universe, variables, value: _ } = self;\n+        Canonical { max_universe, variables, value }\n+    }\n }\n \n pub type QueryOutlivesConstraint<'tcx> = ("}, {"sha": "6a149be3137ee69ecc0145939aa4e6701aded6ec", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -96,7 +96,7 @@ pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>;\n \n-#[derive(Copy, Clone, Debug, HashStable)]\n+#[derive(Copy, Clone, Debug, HashStable, PartialEq, Eq)]\n pub struct NoSolution;\n \n pub type Fallible<T> = Result<T, NoSolution>;"}, {"sha": "a4dd22801e69dc0d119ff34caf6b8a5a30df7107", "filename": "compiler/rustc_middle/src/traits/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fspecialization_graph.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -180,6 +180,7 @@ impl Iterator for Ancestors<'_> {\n }\n \n /// Information about the most specialized definition of an associated item.\n+#[derive(Debug)]\n pub struct LeafDef {\n     /// The associated item described by this `LeafDef`.\n     pub item: ty::AssocItem,"}, {"sha": "f01d74539a12e1b9be8731abf0b56d9d7eb45cf5", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -535,6 +535,17 @@ impl<'tcx> Predicate<'tcx> {\n         self\n     }\n \n+    #[instrument(level = \"debug\", skip(tcx), ret)]\n+    pub fn is_coinductive(self, tcx: TyCtxt<'tcx>) -> bool {\n+        match self.kind().skip_binder() {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(data)) => {\n+                tcx.trait_is_coinductive(data.def_id())\n+            }\n+            ty::PredicateKind::WellFormed(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n     /// Whether this projection can be soundly normalized.\n     ///\n     /// Wf predicates must not be normalized, as normalization\n@@ -1018,6 +1029,24 @@ pub struct ProjectionPredicate<'tcx> {\n     pub term: Term<'tcx>,\n }\n \n+impl<'tcx> ProjectionPredicate<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n+        self.projection_ty.self_ty()\n+    }\n+\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> ProjectionPredicate<'tcx> {\n+        Self { projection_ty: self.projection_ty.with_self_ty(tcx, self_ty), ..self }\n+    }\n+\n+    pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n+        self.projection_ty.trait_def_id(tcx)\n+    }\n+\n+    pub fn def_id(self) -> DefId {\n+        self.projection_ty.def_id\n+    }\n+}\n+\n pub type PolyProjectionPredicate<'tcx> = Binder<'tcx, ProjectionPredicate<'tcx>>;\n \n impl<'tcx> PolyProjectionPredicate<'tcx> {\n@@ -1054,18 +1083,6 @@ impl<'tcx> PolyProjectionPredicate<'tcx> {\n     }\n }\n \n-impl<'tcx> ProjectionPredicate<'tcx> {\n-    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n-        Self {\n-            projection_ty: tcx.mk_alias_ty(\n-                self.projection_ty.def_id,\n-                [self_ty.into()].into_iter().chain(self.projection_ty.substs.iter().skip(1)),\n-            ),\n-            ..self\n-        }\n-    }\n-}\n-\n pub trait ToPolyTraitRef<'tcx> {\n     fn to_poly_trait_ref(&self) -> PolyTraitRef<'tcx>;\n }"}, {"sha": "890a4da63878558eff3608e268061d35e9e2e1f4", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -1169,7 +1169,7 @@ pub struct AliasTy<'tcx> {\n }\n \n impl<'tcx> AliasTy<'tcx> {\n-    pub fn trait_def_id(&self, tcx: TyCtxt<'tcx>) -> DefId {\n+    pub fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId {\n         match tcx.def_kind(self.def_id) {\n             DefKind::AssocTy | DefKind::AssocConst => tcx.parent(self.def_id),\n             DefKind::ImplTraitPlaceholder => {\n@@ -1183,7 +1183,7 @@ impl<'tcx> AliasTy<'tcx> {\n     /// For example, if this is a projection of `<T as StreamingIterator>::Item<'a>`,\n     /// then this function would return a `T: Iterator` trait reference and `['a]` as the own substs\n     pub fn trait_ref_and_own_substs(\n-        &self,\n+        self,\n         tcx: TyCtxt<'tcx>,\n     ) -> (ty::TraitRef<'tcx>, &'tcx [ty::GenericArg<'tcx>]) {\n         debug_assert!(matches!(tcx.def_kind(self.def_id), DefKind::AssocTy | DefKind::AssocConst));\n@@ -1202,14 +1202,18 @@ impl<'tcx> AliasTy<'tcx> {\n     /// WARNING: This will drop the substs for generic associated types\n     /// consider calling [Self::trait_ref_and_own_substs] to get those\n     /// as well.\n-    pub fn trait_ref(&self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n+    pub fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx> {\n         let def_id = self.trait_def_id(tcx);\n         tcx.mk_trait_ref(def_id, self.substs.truncate_to(tcx, tcx.generics_of(def_id)))\n     }\n \n-    pub fn self_ty(&self) -> Ty<'tcx> {\n+    pub fn self_ty(self) -> Ty<'tcx> {\n         self.substs.type_at(0)\n     }\n+\n+    pub fn with_self_ty(self, tcx: TyCtxt<'tcx>, self_ty: Ty<'tcx>) -> Self {\n+        tcx.mk_alias_ty(self.def_id, [self_ty.into()].into_iter().chain(self.substs.iter().skip(1)))\n+    }\n }\n \n #[derive(Copy, Clone, Debug, TypeFoldable, TypeVisitable, Lift)]"}, {"sha": "237b36701c2b63af80583de3e64e843f2e1edf18", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -573,6 +573,10 @@ impl<T> EarlyBinder<T> {\n     pub fn rebind<U>(&self, value: U) -> EarlyBinder<U> {\n         EarlyBinder(value)\n     }\n+\n+    pub fn skip_binder(self) -> T {\n+        self.0\n+    }\n }\n \n impl<T> EarlyBinder<Option<T>> {"}, {"sha": "a30d1df4ede52bd3ffcdbf298b0f0d9f0d2e3d44", "filename": "compiler/rustc_trait_selection/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Flib.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -19,6 +19,7 @@\n #![feature(let_chains)]\n #![feature(if_let_guard)]\n #![feature(never_type)]\n+#![feature(result_option_inspect)]\n #![feature(type_alias_impl_trait)]\n #![recursion_limit = \"512\"] // For rustdoc\n \n@@ -37,4 +38,5 @@ extern crate smallvec;\n pub mod autoderef;\n pub mod errors;\n pub mod infer;\n+pub mod solve;\n pub mod traits;"}, {"sha": "993b79890669c206a8da81d42f7c0b31091a3aab", "filename": "compiler/rustc_trait_selection/src/solve/cache.rs", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcache.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -0,0 +1,257 @@\n+//! This module both handles the global cache which stores \"finished\" goals,\n+//! and the provisional cache which contains partially computed goals.\n+//!\n+//! The provisional cache is necessary when dealing with coinductive cycles.\n+//!\n+//! For more information about the provisional cache and coinduction in general,\n+//! check out the relevant section of the rustc-dev-guide.\n+//!\n+//! FIXME(@lcnr): Write that section, feel free to ping me if you need help here\n+//! before then or if I still haven't done that before January 2023.\n+use super::overflow::OverflowData;\n+use super::CanonicalGoal;\n+use super::{EvalCtxt, QueryResult};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_middle::ty::TyCtxt;\n+use std::{cmp::Ordering, collections::hash_map::Entry};\n+\n+#[derive(Debug, Clone)]\n+struct ProvisionalEntry<'tcx> {\n+    // In case we have a coinductive cycle, this is the\n+    // the currently least restrictive result of this goal.\n+    response: QueryResult<'tcx>,\n+    // The lowest element on the stack on which this result\n+    // relies on. Starts out as just being the depth at which\n+    // we've proven this obligation, but gets lowered to the\n+    // depth of another goal if we rely on it in a cycle.\n+    depth: usize,\n+}\n+\n+struct StackElem<'tcx> {\n+    goal: CanonicalGoal<'tcx>,\n+    has_been_used: bool,\n+}\n+\n+/// The cache used for goals which are currently in progress or which depend\n+/// on in progress results.\n+///\n+/// Once we're done with a goal we can store it in the global trait solver\n+/// cache of the `TyCtxt`. For goals which we're currently proving, or which\n+/// have only been proven via a coinductive cycle using a goal still on our stack\n+/// we have to use this separate data structure.\n+///\n+/// The current data structure is not perfect, so there may still be room for\n+/// improvement here. We have the following requirements:\n+///\n+/// ## Is there is a provisional entry for the given goal:\n+///\n+/// ```ignore (for syntax highlighting)\n+/// self.entries.get(goal)\n+/// ```\n+///\n+/// ## Get all goals on the stack involved in a cycle:\n+///\n+/// ```ignore (for syntax highlighting)\n+/// let entry = self.entries.get(goal).unwrap();\n+/// let involved_goals = self.stack.iter().skip(entry.depth);\n+/// ```\n+///\n+/// ## Capping the depth of all entries\n+///\n+/// Needed whenever we encounter a cycle. The current implementation always\n+/// iterates over all entries instead of only the ones with a larger depth.\n+/// Changing this may result in notable performance improvements.\n+///\n+/// ```ignore (for syntax highlighting)\n+/// let cycle_depth = self.entries.get(goal).unwrap().depth;\n+/// for e in &mut self.entries {\n+///     e.depth = e.depth.min(cycle_depth);\n+/// }\n+/// ```\n+///\n+/// ## Checking whether we have to rerun the current goal\n+///\n+/// A goal has to be rerun if its provisional result was used in a cycle\n+/// and that result is different from its final result. We update\n+/// [StackElem::has_been_used] for the deepest stack element involved in a cycle.\n+///\n+/// ## Moving all finished goals into the global cache\n+///\n+/// If `stack_elem.has_been_used` is true, iterate over all entries, moving the ones\n+/// with equal depth. If not, simply move this single entry.\n+pub(super) struct ProvisionalCache<'tcx> {\n+    stack: Vec<StackElem<'tcx>>,\n+    entries: FxHashMap<CanonicalGoal<'tcx>, ProvisionalEntry<'tcx>>,\n+}\n+\n+impl<'tcx> ProvisionalCache<'tcx> {\n+    pub(super) fn empty() -> ProvisionalCache<'tcx> {\n+        ProvisionalCache { stack: Vec::new(), entries: Default::default() }\n+    }\n+\n+    pub(super) fn current_depth(&self) -> usize {\n+        self.stack.len()\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    /// Tries putting the new goal on the stack, returning an error if it is already cached.\n+    ///\n+    /// This correctly updates the provisional cache if there is a cycle.\n+    pub(super) fn try_push_stack(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx>,\n+    ) -> Result<(), QueryResult<'tcx>> {\n+        // FIXME: start by checking the global cache\n+\n+        // Look at the provisional cache to check for cycles.\n+        let cache = &mut self.provisional_cache;\n+        match cache.entries.entry(goal) {\n+            // No entry, simply push this goal on the stack after dealing with overflow.\n+            Entry::Vacant(v) => {\n+                if self.overflow_data.has_overflow(cache.stack.len()) {\n+                    return Err(self.deal_with_overflow());\n+                }\n+\n+                v.insert(ProvisionalEntry {\n+                    response: fixme_response_yes_no_constraints(),\n+                    depth: cache.stack.len(),\n+                });\n+                cache.stack.push(StackElem { goal, has_been_used: false });\n+                Ok(())\n+            }\n+            // We have a nested goal which relies on a goal `root` deeper in the stack.\n+            //\n+            // We first store that we may have to rerun `evaluate_goal` for `root` in case the\n+            // provisional response is not equal to the final response. We also update the depth\n+            // of all goals which recursively depend on our current goal to depend on `root`\n+            // instead.\n+            //\n+            // Finally we can return either the provisional response for that goal if we have a\n+            // coinductive cycle or an ambiguous result if the cycle is inductive.\n+            Entry::Occupied(entry) => {\n+                // FIXME: `ProvisionalEntry` should be `Copy`.\n+                let entry = entry.get().clone();\n+                cache.stack[entry.depth].has_been_used = true;\n+                for provisional_entry in cache.entries.values_mut() {\n+                    provisional_entry.depth = provisional_entry.depth.min(entry.depth);\n+                }\n+\n+                // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n+                // We can also depend on goals which aren't part of the stack but coinductively\n+                // depend on the stack themselves. We already checked whether all the goals\n+                // between these goals and their root on the stack. This means that as long as\n+                // each goal in a cycle is checked for coinductivity by itself simply checking\n+                // the stack is enough.\n+                if cache.stack[entry.depth..]\n+                    .iter()\n+                    .all(|g| g.goal.value.predicate.is_coinductive(self.tcx))\n+                {\n+                    Err(entry.response)\n+                } else {\n+                    Err(fixme_response_maybe_no_constraints())\n+                }\n+            }\n+        }\n+    }\n+\n+    /// We cannot simply store the result of [EvalCtxt::compute_goal] as we have to deal with\n+    /// coinductive cycles.\n+    ///\n+    /// When we encounter a coinductive cycle, we have to prove the final result of that cycle\n+    /// while we are still computing that result. Because of this we continously recompute the\n+    /// cycle until the result of the previous iteration is equal to the final result, at which\n+    /// point we are done.\n+    ///\n+    /// This function returns `true` if we were able to finalize the goal and `false` if it has\n+    /// updated the provisional cache and we have to recompute the current goal.\n+    ///\n+    /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n+    pub(super) fn try_finalize_goal(\n+        &mut self,\n+        actual_goal: CanonicalGoal<'tcx>,\n+        response: QueryResult<'tcx>,\n+    ) -> bool {\n+        let cache = &mut self.provisional_cache;\n+        let StackElem { goal, has_been_used } = cache.stack.pop().unwrap();\n+        assert_eq!(goal, actual_goal);\n+\n+        let provisional_entry = cache.entries.get_mut(&goal).unwrap();\n+        // Check whether the current stack entry is the root of a cycle.\n+        //\n+        // If so, we either move all participants of that cycle to the global cache\n+        // or, in case the provisional response used in the cycle is not equal to the\n+        // final response, have to recompute the goal after updating the provisional\n+        // response to the final response of this iteration.\n+        if has_been_used {\n+            if provisional_entry.response == response {\n+                // We simply drop all entries according to an immutable condition, so\n+                // query instability is not a concern here.\n+                #[allow(rustc::potential_query_instability)]\n+                cache.entries.retain(|goal, entry| match entry.depth.cmp(&cache.stack.len()) {\n+                    Ordering::Less => true,\n+                    Ordering::Equal => {\n+                        Self::try_move_finished_goal_to_global_cache(\n+                            self.tcx,\n+                            &mut self.overflow_data,\n+                            &cache.stack,\n+                            // FIXME: these should be `Copy` :(\n+                            goal.clone(),\n+                            entry.response.clone(),\n+                        );\n+                        false\n+                    }\n+                    Ordering::Greater => bug!(\"entry with greater depth than the current leaf\"),\n+                });\n+\n+                true\n+            } else {\n+                provisional_entry.response = response;\n+                cache.stack.push(StackElem { goal, has_been_used: false });\n+                false\n+            }\n+        } else {\n+            Self::try_move_finished_goal_to_global_cache(\n+                self.tcx,\n+                &mut self.overflow_data,\n+                &cache.stack,\n+                goal,\n+                response,\n+            );\n+            cache.entries.remove(&goal);\n+            true\n+        }\n+    }\n+\n+    fn try_move_finished_goal_to_global_cache(\n+        tcx: TyCtxt<'tcx>,\n+        overflow_data: &mut OverflowData,\n+        stack: &[StackElem<'tcx>],\n+        goal: CanonicalGoal<'tcx>,\n+        response: QueryResult<'tcx>,\n+    ) {\n+        // We move goals to the global cache if we either did not hit an overflow or if it's\n+        // the root goal as that will now always hit the same overflow limit.\n+        //\n+        // NOTE: We cannot move any non-root goals to the global cache even if their final result\n+        // isn't impacted by the overflow as that goal still has unstable query dependencies\n+        // because it didn't go its full depth.\n+        //\n+        // FIXME(@lcnr): We could still cache subtrees which are not impacted by overflow though.\n+        // Tracking that info correctly isn't trivial, so I haven't implemented it for now.\n+        let should_cache_globally = !overflow_data.did_overflow() || stack.is_empty();\n+        if should_cache_globally {\n+            // FIXME: move the provisional entry to the global cache.\n+            let _ = (tcx, goal, response);\n+        }\n+    }\n+}\n+\n+fn fixme_response_yes_no_constraints<'tcx>() -> QueryResult<'tcx> {\n+    unimplemented!()\n+}\n+\n+fn fixme_response_maybe_no_constraints<'tcx>() -> QueryResult<'tcx> {\n+    unimplemented!()\n+}"}, {"sha": "80115d78d88d17aad9cbb4d77894a435c6be14d3", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -0,0 +1,92 @@\n+use std::mem;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_infer::{\n+    infer::InferCtxt,\n+    traits::{query::NoSolution, FulfillmentError, PredicateObligation, TraitEngine},\n+};\n+use rustc_middle::ty;\n+\n+use super::{Certainty, EvalCtxt};\n+\n+/// A trait engine using the new trait solver.\n+///\n+/// This is mostly identical to how `evaluate_all` works inside of the\n+/// solver, except that the requirements are slightly different.\n+///\n+/// Unlike `evaluate_all` it is possible to add new obligations later on\n+/// and we also have to track diagnostics information by using `Obligation`\n+/// instead of `Goal`.\n+///\n+/// It is also likely that we want to use slightly different datastructures\n+/// here as this will have to deal with far more root goals than `evaluate_all`.\n+pub struct FulfillmentCtxt<'tcx> {\n+    obligations: Vec<PredicateObligation<'tcx>>,\n+}\n+\n+impl<'tcx> FulfillmentCtxt<'tcx> {\n+    pub fn new() -> FulfillmentCtxt<'tcx> {\n+        FulfillmentCtxt { obligations: Vec::new() }\n+    }\n+}\n+\n+impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n+    fn register_predicate_obligation(\n+        &mut self,\n+        _infcx: &InferCtxt<'tcx>,\n+        obligation: PredicateObligation<'tcx>,\n+    ) {\n+        self.obligations.push(obligation);\n+    }\n+\n+    fn select_all_or_error(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n+        let errors = self.select_where_possible(infcx);\n+        if !errors.is_empty() {\n+            return errors;\n+        }\n+\n+        if self.obligations.is_empty() {\n+            Vec::new()\n+        } else {\n+            unimplemented!(\"ambiguous obligations\")\n+        }\n+    }\n+\n+    fn select_where_possible(&mut self, infcx: &InferCtxt<'tcx>) -> Vec<FulfillmentError<'tcx>> {\n+        let errors = Vec::new();\n+        for i in 0.. {\n+            if !infcx.tcx.recursion_limit().value_within_limit(i) {\n+                unimplemented!(\"overflow\")\n+            }\n+\n+            let mut has_changed = false;\n+            for o in mem::take(&mut self.obligations) {\n+                let mut cx = EvalCtxt::new(infcx.tcx);\n+                let (changed, certainty) = match cx.evaluate_goal(infcx, o.clone().into()) {\n+                    Ok(result) => result,\n+                    Err(NoSolution) => unimplemented!(\"error\"),\n+                };\n+\n+                has_changed |= changed;\n+                match certainty {\n+                    Certainty::Yes => {}\n+                    Certainty::Maybe(_) => self.obligations.push(o),\n+                }\n+            }\n+\n+            if !has_changed {\n+                break;\n+            }\n+        }\n+\n+        errors\n+    }\n+\n+    fn pending_obligations(&self) -> Vec<PredicateObligation<'tcx>> {\n+        self.obligations.clone()\n+    }\n+\n+    fn relationships(&mut self) -> &mut FxHashMap<ty::TyVid, ty::FoundRelationships> {\n+        unimplemented!(\"Should be moved out of `TraitEngine`\")\n+    }\n+}"}, {"sha": "436f4eea6625bcdf45b7b3e66bec6cba9d4bee80", "filename": "compiler/rustc_trait_selection/src/solve/infcx_ext.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Finfcx_ext.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -0,0 +1,55 @@\n+use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc_infer::infer::InferCtxt;\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::ty::Ty;\n+use rustc_span::DUMMY_SP;\n+\n+use crate::solve::ExternalConstraints;\n+\n+use super::{Certainty, QueryResult, Response};\n+\n+/// Methods used inside of the canonical queries of the solver.\n+pub(super) trait InferCtxtExt<'tcx> {\n+    fn next_ty_infer(&self) -> Ty<'tcx>;\n+\n+    fn make_canonical_response(\n+        &self,\n+        var_values: CanonicalVarValues<'tcx>,\n+        certainty: Certainty,\n+    ) -> QueryResult<'tcx>;\n+}\n+\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n+    fn next_ty_infer(&self) -> Ty<'tcx> {\n+        self.next_ty_var(TypeVariableOrigin {\n+            kind: TypeVariableOriginKind::MiscVariable,\n+            span: DUMMY_SP,\n+        })\n+    }\n+\n+    fn make_canonical_response(\n+        &self,\n+        var_values: CanonicalVarValues<'tcx>,\n+        certainty: Certainty,\n+    ) -> QueryResult<'tcx> {\n+        let external_constraints = take_external_constraints(self)?;\n+\n+        Ok(self.canonicalize_response(Response { var_values, external_constraints, certainty }))\n+    }\n+}\n+\n+#[instrument(level = \"debug\", skip(infcx), ret)]\n+fn take_external_constraints<'tcx>(\n+    infcx: &InferCtxt<'tcx>,\n+) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+    let region_obligations = infcx.take_registered_region_obligations();\n+    let opaque_types = infcx.take_opaque_types_for_query_response();\n+    Ok(ExternalConstraints {\n+        // FIXME: Now that's definitely wrong :)\n+        //\n+        // Should also do the leak check here I think\n+        regions: drop(region_obligations),\n+        opaque_types,\n+    })\n+}"}, {"sha": "5d6529f85423b64f09867f2d88e2183f3045d8fa", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -0,0 +1,308 @@\n+//! The new trait solver, currently still WIP.\n+//!\n+//! As a user of the trait system, you can use `TyCtxt::evaluate_goal` to\n+//! interact with this solver.\n+//!\n+//! For a high-level overview of how this solver works, check out the relevant\n+//! section of the rustc-dev-guide.\n+//!\n+//! FIXME(@lcnr): Write that section. If you read this before then ask me\n+//! about it on zulip.\n+\n+// FIXME: Instead of using `infcx.canonicalize_query` we have to add a new routine which\n+// preserves universes and creates a unique var (in the highest universe) for each\n+// appearance of a region.\n+\n+// FIXME: `CanonicalVarValues` should be interned and `Copy`.\n+\n+// FIXME: uses of `infcx.at` need to enable deferred projection equality once that's implemented.\n+\n+use std::mem;\n+\n+use rustc_infer::infer::canonical::OriginalQueryValues;\n+use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::Obligation;\n+use rustc_middle::infer::canonical::{Canonical, CanonicalVarValues};\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_middle::ty::{RegionOutlivesPredicate, ToPredicate, TypeOutlivesPredicate};\n+use rustc_span::DUMMY_SP;\n+\n+use self::infcx_ext::InferCtxtExt;\n+\n+mod cache;\n+mod fulfill;\n+mod infcx_ext;\n+mod overflow;\n+mod project_goals;\n+mod trait_goals;\n+\n+pub use fulfill::FulfillmentCtxt;\n+\n+/// A goal is a statement, i.e. `predicate`, we want to prove\n+/// given some assumptions, i.e. `param_env`.\n+///\n+/// Most of the time the `param_env` contains the `where`-bounds of the function\n+/// we're currently typechecking while the `predicate` is some trait bound.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Goal<'tcx, P> {\n+    param_env: ty::ParamEnv<'tcx>,\n+    predicate: P,\n+}\n+\n+impl<'tcx, P> Goal<'tcx, P> {\n+    pub fn new(\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+        predicate: impl ToPredicate<'tcx, P>,\n+    ) -> Goal<'tcx, P> {\n+        Goal { param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+\n+    /// Updates the goal to one with a different `predicate` but the same `param_env`.\n+    fn with<Q>(self, tcx: TyCtxt<'tcx>, predicate: impl ToPredicate<'tcx, Q>) -> Goal<'tcx, Q> {\n+        Goal { param_env: self.param_env, predicate: predicate.to_predicate(tcx) }\n+    }\n+}\n+\n+impl<'tcx, P> From<Obligation<'tcx, P>> for Goal<'tcx, P> {\n+    fn from(obligation: Obligation<'tcx, P>) -> Goal<'tcx, P> {\n+        Goal { param_env: obligation.param_env, predicate: obligation.predicate }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable)]\n+pub struct Response<'tcx> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    /// Additional constraints returned by this query.\n+    pub external_constraints: ExternalConstraints<'tcx>,\n+    pub certainty: Certainty,\n+}\n+\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum Certainty {\n+    Yes,\n+    Maybe(MaybeCause),\n+}\n+\n+impl Certainty {\n+    /// When proving multiple goals using **AND**, e.g. nested obligations for an impl,\n+    /// use this function to unify the certainty of these goals\n+    pub fn unify_and(self, other: Certainty) -> Certainty {\n+        match (self, other) {\n+            (Certainty::Yes, Certainty::Yes) => Certainty::Yes,\n+            (Certainty::Yes, Certainty::Maybe(_)) => other,\n+            (Certainty::Maybe(_), Certainty::Yes) => self,\n+            (Certainty::Maybe(MaybeCause::Overflow), Certainty::Maybe(MaybeCause::Overflow)) => {\n+                Certainty::Maybe(MaybeCause::Overflow)\n+            }\n+            // If at least one of the goals is ambiguous, hide the overflow as the ambiguous goal\n+            // may still result in failure.\n+            (Certainty::Maybe(MaybeCause::Ambiguity), Certainty::Maybe(_))\n+            | (Certainty::Maybe(_), Certainty::Maybe(MaybeCause::Ambiguity)) => {\n+                Certainty::Maybe(MaybeCause::Ambiguity)\n+            }\n+        }\n+    }\n+}\n+\n+/// Why we failed to evaluate a goal.\n+#[derive(Debug, PartialEq, Eq, Clone, Copy, Hash, TypeFoldable, TypeVisitable)]\n+pub enum MaybeCause {\n+    /// We failed due to ambiguity. This ambiguity can either\n+    /// be a true ambiguity, i.e. there are multiple different answers,\n+    /// or we hit a case where we just don't bother, e.g. `?x: Trait` goals.\n+    Ambiguity,\n+    /// We gave up due to an overflow, most often by hitting the recursion limit.\n+    Overflow,\n+}\n+\n+/// Additional constraints returned on success.\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, TypeFoldable, TypeVisitable)]\n+pub struct ExternalConstraints<'tcx> {\n+    // FIXME: implement this.\n+    regions: (),\n+    opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n+}\n+\n+type CanonicalGoal<'tcx, T = ty::Predicate<'tcx>> = Canonical<'tcx, Goal<'tcx, T>>;\n+type CanonicalResponse<'tcx> = Canonical<'tcx, Response<'tcx>>;\n+/// The result of evaluating a canonical query.\n+///\n+/// FIXME: We use a different type than the existing canonical queries. This is because\n+/// we need to add a `Certainty` for `overflow` and may want to restructure this code without\n+/// having to worry about changes to currently used code. Once we've made progress on this\n+/// solver, merge the two responses again.\n+pub type QueryResult<'tcx> = Result<CanonicalResponse<'tcx>, NoSolution>;\n+\n+pub trait TyCtxtExt<'tcx> {\n+    fn evaluate_goal(self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx>;\n+}\n+\n+impl<'tcx> TyCtxtExt<'tcx> for TyCtxt<'tcx> {\n+    fn evaluate_goal(self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n+        let mut cx = EvalCtxt::new(self);\n+        cx.evaluate_canonical_goal(goal)\n+    }\n+}\n+\n+struct EvalCtxt<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+\n+    provisional_cache: cache::ProvisionalCache<'tcx>,\n+    overflow_data: overflow::OverflowData,\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> EvalCtxt<'tcx> {\n+        EvalCtxt {\n+            tcx,\n+            provisional_cache: cache::ProvisionalCache::empty(),\n+            overflow_data: overflow::OverflowData::new(tcx),\n+        }\n+    }\n+\n+    /// Recursively evaluates `goal`, returning whether any inference vars have\n+    /// been constrained and the certainty of the result.\n+    fn evaluate_goal(\n+        &mut self,\n+        infcx: &InferCtxt<'tcx>,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> Result<(bool, Certainty), NoSolution> {\n+        let mut orig_values = OriginalQueryValues::default();\n+        let canonical_goal = infcx.canonicalize_query(goal, &mut orig_values);\n+        let canonical_response = self.evaluate_canonical_goal(canonical_goal)?;\n+        Ok((\n+            true, // FIXME: check whether `var_values` are an identity substitution.\n+            fixme_instantiate_canonical_query_response(infcx, &orig_values, canonical_response),\n+        ))\n+    }\n+\n+    fn evaluate_canonical_goal(&mut self, goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n+        match self.try_push_stack(goal) {\n+            Ok(()) => {}\n+            // Our goal is already on the stack, eager return.\n+            Err(response) => return response,\n+        }\n+\n+        // We may have to repeatedly recompute the goal in case of coinductive cycles,\n+        // check out the `cache` module for more information.\n+        //\n+        // FIXME: Similar to `evaluate_all`, this has to check for overflow.\n+        loop {\n+            let result = self.compute_goal(goal);\n+\n+            // FIXME: `Response` should be `Copy`\n+            if self.try_finalize_goal(goal, result.clone()) {\n+                return result;\n+            }\n+        }\n+    }\n+\n+    fn compute_goal(&mut self, canonical_goal: CanonicalGoal<'tcx>) -> QueryResult<'tcx> {\n+        // WARNING: We're looking at a canonical value without instantiating it here.\n+        //\n+        // We have to be incredibly careful to not change the order of bound variables or\n+        // remove any. As we go from `Goal<'tcx, Predicate>` to `Goal` with the variants\n+        // of `PredicateKind` this is the case and it is and faster than instantiating and\n+        // recanonicalizing.\n+        let Goal { param_env, predicate } = canonical_goal.value;\n+        if let Some(kind) = predicate.kind().no_bound_vars() {\n+            match kind {\n+                ty::PredicateKind::Clause(ty::Clause::Trait(predicate)) => self.compute_trait_goal(\n+                    canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                ),\n+                ty::PredicateKind::Clause(ty::Clause::Projection(predicate)) => self\n+                    .compute_projection_goal(\n+                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                    ),\n+                ty::PredicateKind::Clause(ty::Clause::TypeOutlives(predicate)) => self\n+                    .compute_type_outlives_goal(\n+                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                    ),\n+                ty::PredicateKind::Clause(ty::Clause::RegionOutlives(predicate)) => self\n+                    .compute_region_outlives_goal(\n+                        canonical_goal.unchecked_rebind(Goal { param_env, predicate }),\n+                    ),\n+                // FIXME: implement these predicates :)\n+                ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::ObjectSafe(_)\n+                | ty::PredicateKind::ClosureKind(_, _, _)\n+                | ty::PredicateKind::Subtype(_)\n+                | ty::PredicateKind::Coerce(_)\n+                | ty::PredicateKind::ConstEvaluatable(_)\n+                | ty::PredicateKind::ConstEquate(_, _)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(_)\n+                | ty::PredicateKind::Ambiguous => unimplemented!(),\n+            }\n+        } else {\n+            let (infcx, goal, var_values) =\n+                self.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n+            let kind = infcx.replace_bound_vars_with_placeholders(goal.predicate.kind());\n+            let goal = goal.with(self.tcx, ty::Binder::dummy(kind));\n+            let (_, certainty) = self.evaluate_goal(&infcx, goal)?;\n+            infcx.make_canonical_response(var_values, certainty)\n+        }\n+    }\n+\n+    fn compute_type_outlives_goal(\n+        &mut self,\n+        _goal: CanonicalGoal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        todo!()\n+    }\n+\n+    fn compute_region_outlives_goal(\n+        &mut self,\n+        _goal: CanonicalGoal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        todo!()\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    fn evaluate_all(\n+        &mut self,\n+        infcx: &InferCtxt<'tcx>,\n+        mut goals: Vec<Goal<'tcx, ty::Predicate<'tcx>>>,\n+    ) -> Result<Certainty, NoSolution> {\n+        let mut new_goals = Vec::new();\n+        self.repeat_while_none(|this| {\n+            let mut has_changed = Err(Certainty::Yes);\n+            for goal in goals.drain(..) {\n+                let (changed, certainty) = match this.evaluate_goal(infcx, goal) {\n+                    Ok(result) => result,\n+                    Err(NoSolution) => return Some(Err(NoSolution)),\n+                };\n+\n+                if changed {\n+                    has_changed = Ok(());\n+                }\n+\n+                match certainty {\n+                    Certainty::Yes => {}\n+                    Certainty::Maybe(_) => {\n+                        new_goals.push(goal);\n+                        has_changed = has_changed.map_err(|c| c.unify_and(certainty));\n+                    }\n+                }\n+            }\n+\n+            match has_changed {\n+                Ok(()) => {\n+                    mem::swap(&mut new_goals, &mut goals);\n+                    None\n+                }\n+                Err(certainty) => Some(Ok(certainty)),\n+            }\n+        })\n+    }\n+}\n+\n+fn fixme_instantiate_canonical_query_response<'tcx>(\n+    _: &InferCtxt<'tcx>,\n+    _: &OriginalQueryValues<'tcx>,\n+    _: CanonicalResponse<'tcx>,\n+) -> Certainty {\n+    unimplemented!()\n+}"}, {"sha": "8d73a83aec96e119639b011ab134ff94176f964c", "filename": "compiler/rustc_trait_selection/src/solve/overflow.rs", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Foverflow.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -0,0 +1,80 @@\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_session::Limit;\n+\n+use super::{Certainty, EvalCtxt, MaybeCause, QueryResult};\n+\n+/// When detecting a solver overflow, we return ambiguity. Overflow can be\n+/// *hidden* by either a fatal error in an **AND** or a trivial success in an **OR**.\n+///\n+/// This is in issue in case of exponential blowup, e.g. if each goal on the stack\n+/// has multiple nested (overflowing) candidates. To deal with this, we reduce the limit\n+/// used by the solver when hitting the default limit for the first time.\n+///\n+/// FIXME: Get tests where always using the `default_limit` results in a hang and refer\n+/// to them here. We can also improve the overflow strategy if necessary.\n+pub(super) struct OverflowData {\n+    default_limit: Limit,\n+    current_limit: Limit,\n+    /// When proving an **AND** we have to repeatedly iterate over the yet unproven goals.\n+    ///\n+    /// Because of this each iteration also increases the depth in addition to the stack\n+    /// depth.\n+    additional_depth: usize,\n+}\n+\n+impl OverflowData {\n+    pub(super) fn new(tcx: TyCtxt<'_>) -> OverflowData {\n+        let default_limit = tcx.recursion_limit();\n+        OverflowData { default_limit, current_limit: default_limit, additional_depth: 0 }\n+    }\n+\n+    #[inline]\n+    pub(super) fn did_overflow(&self) -> bool {\n+        self.default_limit.0 != self.current_limit.0\n+    }\n+\n+    #[inline]\n+    pub(super) fn has_overflow(&self, depth: usize) -> bool {\n+        self.current_limit.value_within_limit(depth + self.additional_depth)\n+    }\n+\n+    /// Updating the current limit when hitting overflow.\n+    fn deal_with_overflow(&mut self) {\n+        // When first hitting overflow we reduce the overflow limit\n+        // for all future goals to prevent hangs if there's an exponental\n+        // blowup.\n+        self.current_limit.0 = self.default_limit.0 / 8;\n+    }\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    pub(super) fn deal_with_overflow(&mut self) -> QueryResult<'tcx> {\n+        self.overflow_data.deal_with_overflow();\n+        fixme_response_overflow_no_constraints()\n+    }\n+\n+    /// A `while`-loop which tracks overflow.\n+    pub(super) fn repeat_while_none(\n+        &mut self,\n+        mut loop_body: impl FnMut(&mut Self) -> Option<Result<Certainty, NoSolution>>,\n+    ) -> Result<Certainty, NoSolution> {\n+        let start_depth = self.overflow_data.additional_depth;\n+        let depth = self.provisional_cache.current_depth();\n+        while !self.overflow_data.has_overflow(depth) {\n+            if let Some(result) = loop_body(self) {\n+                self.overflow_data.additional_depth = start_depth;\n+                return result;\n+            }\n+\n+            self.overflow_data.additional_depth += 1;\n+        }\n+        self.overflow_data.additional_depth = start_depth;\n+        self.overflow_data.deal_with_overflow();\n+        Ok(Certainty::Maybe(MaybeCause::Overflow))\n+    }\n+}\n+\n+fn fixme_response_overflow_no_constraints<'tcx>() -> QueryResult<'tcx> {\n+    unimplemented!()\n+}"}, {"sha": "47a8f59ceb77f2fb0ebb2b76218c2e78f580c78a", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "added", "additions": 324, "deletions": 0, "changes": 324, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -0,0 +1,324 @@\n+use crate::traits::{specialization_graph, translate_substs};\n+\n+use super::infcx_ext::InferCtxtExt;\n+use super::{\n+    fixme_instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty,\n+    EvalCtxt, Goal, QueryResult,\n+};\n+use rustc_errors::ErrorGuaranteed;\n+use rustc_hir::def::DefKind;\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::canonical::{CanonicalVarValues, OriginalQueryValues};\n+use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::specialization_graph::LeafDef;\n+use rustc_infer::traits::{ObligationCause, Reveal};\n+use rustc_middle::ty;\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::ty::ProjectionPredicate;\n+use rustc_middle::ty::TypeVisitable;\n+use rustc_span::DUMMY_SP;\n+use std::iter;\n+\n+// FIXME: Deduplicate the candidate code between projection and trait goal.\n+\n+/// Similar to [super::trait_goals::Candidate] but for `Projection` goals.\n+#[derive(Debug, Clone)]\n+struct Candidate<'tcx> {\n+    source: CandidateSource,\n+    result: CanonicalResponse<'tcx>,\n+}\n+\n+#[allow(dead_code)] // FIXME: implement and use all variants.\n+#[derive(Debug, Clone, Copy)]\n+enum CandidateSource {\n+    Impl(DefId),\n+    ParamEnv(usize),\n+    Builtin,\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    pub(super) fn compute_projection_goal(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx, ProjectionPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let candidates = self.assemble_and_evaluate_project_candidates(goal);\n+        self.merge_project_candidates(candidates)\n+    }\n+\n+    fn assemble_and_evaluate_project_candidates(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx, ProjectionPredicate<'tcx>>,\n+    ) -> Vec<Candidate<'tcx>> {\n+        let (ref infcx, goal, var_values) =\n+            self.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n+        let mut acx = AssemblyCtxt { cx: self, infcx, var_values, candidates: Vec::new() };\n+\n+        acx.assemble_candidates_after_normalizing_self_ty(goal);\n+        acx.assemble_impl_candidates(goal);\n+        acx.candidates\n+    }\n+\n+    fn merge_project_candidates(\n+        &mut self,\n+        mut candidates: Vec<Candidate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        match candidates.len() {\n+            0 => return Err(NoSolution),\n+            1 => return Ok(candidates.pop().unwrap().result),\n+            _ => {}\n+        }\n+\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            'outer: while i < candidates.len() {\n+                for j in (0..candidates.len()).filter(|&j| i != j) {\n+                    if self.project_candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                    ) {\n+                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                        candidates.swap_remove(i);\n+                        continue 'outer;\n+                    }\n+                }\n+\n+                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                // If there are *STILL* multiple candidates, give up\n+                // and report ambiguity.\n+                i += 1;\n+                if i > 1 {\n+                    debug!(\"multiple matches, ambig\");\n+                    // FIXME: return overflow if all candidates overflow, otherwise return ambiguity.\n+                    unimplemented!();\n+                }\n+            }\n+        }\n+\n+        Ok(candidates.pop().unwrap().result)\n+    }\n+\n+    fn project_candidate_should_be_dropped_in_favor_of(\n+        &self,\n+        candidate: &Candidate<'tcx>,\n+        other: &Candidate<'tcx>,\n+    ) -> bool {\n+        // FIXME: implement this\n+        match (candidate.source, other.source) {\n+            (CandidateSource::Impl(_), _)\n+            | (CandidateSource::ParamEnv(_), _)\n+            | (CandidateSource::Builtin, _) => unimplemented!(),\n+        }\n+    }\n+}\n+\n+/// Similar to [super::trait_goals::AssemblyCtxt] but for `Projection` goals.\n+struct AssemblyCtxt<'a, 'tcx> {\n+    cx: &'a mut EvalCtxt<'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n+    var_values: CanonicalVarValues<'tcx>,\n+    candidates: Vec<Candidate<'tcx>>,\n+}\n+\n+impl<'tcx> AssemblyCtxt<'_, 'tcx> {\n+    fn try_insert_candidate(&mut self, source: CandidateSource, certainty: Certainty) {\n+        match self.infcx.make_canonical_response(self.var_values.clone(), certainty) {\n+            Ok(result) => self.candidates.push(Candidate { source, result }),\n+            Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n+        }\n+    }\n+\n+    fn assemble_candidates_after_normalizing_self_ty(\n+        &mut self,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n+    ) {\n+        let tcx = self.cx.tcx;\n+        let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.projection_ty.self_ty().kind() else {\n+            return\n+        };\n+        self.infcx.probe(|_| {\n+            let normalized_ty = self.infcx.next_ty_infer();\n+            let normalizes_to_goal = goal.with(\n+                tcx,\n+                ty::Binder::dummy(ty::ProjectionPredicate {\n+                    projection_ty,\n+                    term: normalized_ty.into(),\n+                }),\n+            );\n+            let normalization_certainty =\n+                match self.cx.evaluate_goal(&self.infcx, normalizes_to_goal) {\n+                    Ok((_, certainty)) => certainty,\n+                    Err(NoSolution) => return,\n+                };\n+\n+            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n+            // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n+            let goal = goal.with(tcx, goal.predicate.with_self_ty(tcx, normalized_ty));\n+            let mut orig_values = OriginalQueryValues::default();\n+            let goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let normalized_candidates = self.cx.assemble_and_evaluate_project_candidates(goal);\n+            // Map each candidate from being canonical wrt the current inference context to being\n+            // canonical wrt the caller.\n+            for Candidate { source, result } in normalized_candidates {\n+                self.infcx.probe(|_| {\n+                    let candidate_certainty = fixme_instantiate_canonical_query_response(\n+                        self.infcx,\n+                        &orig_values,\n+                        result,\n+                    );\n+                    self.try_insert_candidate(\n+                        source,\n+                        normalization_certainty.unify_and(candidate_certainty),\n+                    )\n+                })\n+            }\n+        })\n+    }\n+\n+    fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, ProjectionPredicate<'tcx>>) {\n+        self.cx.tcx.for_each_relevant_impl(\n+            goal.predicate.trait_def_id(self.cx.tcx),\n+            goal.predicate.self_ty(),\n+            |impl_def_id| self.consider_impl_candidate(goal, impl_def_id),\n+        );\n+    }\n+\n+    fn consider_impl_candidate(\n+        &mut self,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n+        impl_def_id: DefId,\n+    ) {\n+        let tcx = self.cx.tcx;\n+        let goal_trait_ref = goal.predicate.projection_ty.trait_ref(tcx);\n+        let impl_trait_ref = tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        if iter::zip(goal_trait_ref.substs, impl_trait_ref.skip_binder().substs)\n+            .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n+        {\n+            return;\n+        }\n+\n+        self.infcx.probe(|_| {\n+            let impl_substs = self.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+            let impl_trait_ref = impl_trait_ref.subst(tcx, impl_substs);\n+\n+            let Ok(InferOk { obligations, .. }) = self\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .define_opaque_types(false)\n+                .eq(goal_trait_ref, impl_trait_ref)\n+                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n+            else {\n+                return\n+            };\n+\n+            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n+            let Ok(trait_ref_certainty) = self.cx.evaluate_all(self.infcx, nested_goals) else { return };\n+\n+            let Some(assoc_def) = self.fetch_eligible_assoc_item_def(\n+                goal.param_env,\n+                goal_trait_ref,\n+                goal.predicate.def_id(),\n+                impl_def_id\n+            ) else {\n+                return\n+            };\n+\n+            if !assoc_def.item.defaultness(tcx).has_value() {\n+                tcx.sess.delay_span_bug(\n+                    tcx.def_span(assoc_def.item.def_id),\n+                    \"missing value for assoc item in impl\",\n+                );\n+            }\n+\n+            // Getting the right substitutions here is complex, e.g. given:\n+            // - a goal `<Vec<u32> as Trait<i32>>::Assoc<u64>`\n+            // - the applicable impl `impl<T> Trait<i32> for Vec<T>`\n+            // - and the impl which defines `Assoc` being `impl<T, U> Trait<U> for Vec<T>`\n+            //\n+            // We first rebase the goal substs onto the impl, going from `[Vec<u32>, i32, u64]`\n+            // to `[u32, u64]`.\n+            //\n+            // And then map these substs to the substs of the defining impl of `Assoc`, going\n+            // from `[u32, u64]` to `[u32, i32, u64]`.\n+            let impl_substs_with_gat = goal.predicate.projection_ty.substs.rebase_onto(\n+                tcx,\n+                goal_trait_ref.def_id,\n+                impl_trait_ref.substs,\n+            );\n+            let substs = translate_substs(\n+                self.infcx,\n+                goal.param_env,\n+                impl_def_id,\n+                impl_substs_with_gat,\n+                assoc_def.defining_node,\n+            );\n+\n+            // Finally we construct the actual value of the associated type.\n+            let is_const = matches!(tcx.def_kind(assoc_def.item.def_id), DefKind::AssocConst);\n+            let ty = tcx.bound_type_of(assoc_def.item.def_id);\n+            let term: ty::EarlyBinder<ty::Term<'tcx>> = if is_const {\n+                let identity_substs = ty::InternalSubsts::identity_for_item(tcx, assoc_def.item.def_id);\n+                let did = ty::WithOptConstParam::unknown(assoc_def.item.def_id);\n+                let kind =\n+                    ty::ConstKind::Unevaluated(ty::UnevaluatedConst::new(did, identity_substs));\n+                ty.map_bound(|ty| tcx.mk_const(kind, ty).into())\n+            } else {\n+                ty.map_bound(|ty| ty.into())\n+            };\n+\n+            let Ok(InferOk { obligations, .. }) = self\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .define_opaque_types(false)\n+                .eq(goal.predicate.term,  term.subst(tcx, substs))\n+                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n+            else {\n+                return\n+            };\n+\n+            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n+            let Ok(rhs_certainty) = self.cx.evaluate_all(self.infcx, nested_goals) else { return };\n+\n+            let certainty = trait_ref_certainty.unify_and(rhs_certainty);\n+            self.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+        })\n+    }\n+\n+    /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code.\n+    ///\n+    /// FIXME: We should merge these 3 implementations as it's likely that they otherwise\n+    /// diverge.\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    fn fetch_eligible_assoc_item_def(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        goal_trait_ref: ty::TraitRef<'tcx>,\n+        trait_assoc_def_id: DefId,\n+        impl_def_id: DefId,\n+    ) -> Option<LeafDef> {\n+        let node_item =\n+            specialization_graph::assoc_def(self.cx.tcx, impl_def_id, trait_assoc_def_id)\n+                .map_err(|ErrorGuaranteed { .. }| ())\n+                .ok()?;\n+\n+        let eligible = if node_item.is_final() {\n+            // Non-specializable items are always projectable.\n+            true\n+        } else {\n+            // Only reveal a specializable default if we're past type-checking\n+            // and the obligation is monomorphic, otherwise passes such as\n+            // transmute checking and polymorphic MIR optimizations could\n+            // get a result which isn't correct for all monomorphizations.\n+            if param_env.reveal() == Reveal::All {\n+                let poly_trait_ref = self.infcx.resolve_vars_if_possible(goal_trait_ref);\n+                !poly_trait_ref.still_further_specializable()\n+            } else {\n+                debug!(?node_item.item.def_id, \"not eligible due to default\");\n+                false\n+            }\n+        };\n+\n+        if eligible { Some(node_item) } else { None }\n+    }\n+}"}, {"sha": "4ea9081bf46a65ecc3cba57cebcbb686c35c3299", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -0,0 +1,282 @@\n+//! Dealing with trait goals, i.e. `T: Trait<'a, U>`.\n+\n+use std::iter;\n+\n+use super::infcx_ext::InferCtxtExt;\n+use super::{\n+    fixme_instantiate_canonical_query_response, CanonicalGoal, CanonicalResponse, Certainty,\n+    EvalCtxt, Goal, QueryResult,\n+};\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::canonical::{CanonicalVarValues, OriginalQueryValues};\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::infer::{InferCtxt, InferOk};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::ty;\n+use rustc_middle::ty::fast_reject::{DeepRejectCtxt, TreatParams};\n+use rustc_middle::ty::TraitPredicate;\n+use rustc_span::DUMMY_SP;\n+\n+/// A candidate is a possible way to prove a goal.\n+///\n+/// It consists of both the `source`, which describes how that goal\n+/// would be proven, and the `result` when using the given `source`.\n+///\n+/// For the list of possible candidates, please look at the documentation\n+/// of [CandidateSource].\n+#[derive(Debug, Clone)]\n+pub(super) struct Candidate<'tcx> {\n+    source: CandidateSource,\n+    result: CanonicalResponse<'tcx>,\n+}\n+\n+#[allow(dead_code)] // FIXME: implement and use all variants.\n+#[derive(Debug, Clone, Copy)]\n+pub(super) enum CandidateSource {\n+    /// Some user-defined impl with the given `DefId`.\n+    Impl(DefId),\n+    /// The n-th caller bound in the `param_env` of our goal.\n+    ///\n+    /// This is pretty much always a bound from the `where`-clauses of the\n+    /// currently checked item.\n+    ParamEnv(usize),\n+    /// A bound on the `self_ty` in case it is a projection or an opaque type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore (for syntax highlighting)\n+    /// trait Trait {\n+    ///     type Assoc: OtherTrait;\n+    /// }\n+    /// ```\n+    ///\n+    /// We know that `<Whatever as Trait>::Assoc: OtherTrait` holds by looking at\n+    /// the bounds on `Trait::Assoc`.\n+    AliasBound(usize),\n+    /// A builtin implementation for some specific traits, used in cases\n+    /// where we cannot rely an ordinary library implementations.\n+    ///\n+    /// The most notable examples are `Sized`, `Copy` and `Clone`. This is also\n+    /// used for the `DiscriminantKind` and `Pointee` trait, both of which have\n+    /// an associated type.\n+    Builtin,\n+    /// An automatic impl for an auto trait, e.g. `Send`. These impls recursively look\n+    /// at the constituent types of the `self_ty` to check whether the auto trait\n+    /// is implemented for those.\n+    AutoImpl,\n+}\n+\n+struct AssemblyCtxt<'a, 'tcx> {\n+    cx: &'a mut EvalCtxt<'tcx>,\n+    infcx: &'a InferCtxt<'tcx>,\n+    var_values: CanonicalVarValues<'tcx>,\n+    candidates: Vec<Candidate<'tcx>>,\n+}\n+\n+impl<'tcx> EvalCtxt<'tcx> {\n+    pub(super) fn compute_trait_goal(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx, TraitPredicate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        let candidates = self.assemble_and_evaluate_trait_candidates(goal);\n+        self.merge_trait_candidates_discard_reservation_impls(candidates)\n+    }\n+\n+    pub(super) fn assemble_and_evaluate_trait_candidates(\n+        &mut self,\n+        goal: CanonicalGoal<'tcx, TraitPredicate<'tcx>>,\n+    ) -> Vec<Candidate<'tcx>> {\n+        let (ref infcx, goal, var_values) =\n+            self.tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &goal);\n+        let mut acx = AssemblyCtxt { cx: self, infcx, var_values, candidates: Vec::new() };\n+\n+        acx.assemble_candidates_after_normalizing_self_ty(goal);\n+        acx.assemble_impl_candidates(goal);\n+\n+        // FIXME: Remaining candidates\n+        acx.candidates\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn merge_trait_candidates_discard_reservation_impls(\n+        &mut self,\n+        mut candidates: Vec<Candidate<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        match candidates.len() {\n+            0 => return Err(NoSolution),\n+            1 => return Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result),\n+            _ => {}\n+        }\n+\n+        if candidates.len() > 1 {\n+            let mut i = 0;\n+            'outer: while i < candidates.len() {\n+                for j in (0..candidates.len()).filter(|&j| i != j) {\n+                    if self.trait_candidate_should_be_dropped_in_favor_of(\n+                        &candidates[i],\n+                        &candidates[j],\n+                    ) {\n+                        debug!(candidate = ?candidates[i], \"Dropping candidate #{}/{}\", i, candidates.len());\n+                        candidates.swap_remove(i);\n+                        continue 'outer;\n+                    }\n+                }\n+\n+                debug!(candidate = ?candidates[i], \"Retaining candidate #{}/{}\", i, candidates.len());\n+                // If there are *STILL* multiple candidates, give up\n+                // and report ambiguity.\n+                i += 1;\n+                if i > 1 {\n+                    debug!(\"multiple matches, ambig\");\n+                    // FIXME: return overflow if all candidates overflow, otherwise return ambiguity.\n+                    unimplemented!();\n+                }\n+            }\n+        }\n+\n+        Ok(self.discard_reservation_impl(candidates.pop().unwrap()).result)\n+    }\n+\n+    fn trait_candidate_should_be_dropped_in_favor_of(\n+        &self,\n+        candidate: &Candidate<'tcx>,\n+        other: &Candidate<'tcx>,\n+    ) -> bool {\n+        // FIXME: implement this\n+        match (candidate.source, other.source) {\n+            (CandidateSource::Impl(_), _)\n+            | (CandidateSource::ParamEnv(_), _)\n+            | (CandidateSource::AliasBound(_), _)\n+            | (CandidateSource::Builtin, _)\n+            | (CandidateSource::AutoImpl, _) => unimplemented!(),\n+        }\n+    }\n+\n+    fn discard_reservation_impl(&self, candidate: Candidate<'tcx>) -> Candidate<'tcx> {\n+        if let CandidateSource::Impl(def_id) = candidate.source {\n+            if let ty::ImplPolarity::Reservation = self.tcx.impl_polarity(def_id) {\n+                debug!(\"Selected reservation impl\");\n+                // FIXME: reduce candidate to ambiguous\n+                // FIXME: replace `var_values` with identity, yeet external constraints.\n+                unimplemented!()\n+            }\n+        }\n+\n+        candidate\n+    }\n+}\n+\n+impl<'tcx> AssemblyCtxt<'_, 'tcx> {\n+    /// Adds a new candidate using the current state of the inference context.\n+    ///\n+    /// This does require each assembly method to correctly use `probe` to not taint\n+    /// the results of other candidates.\n+    fn try_insert_candidate(&mut self, source: CandidateSource, certainty: Certainty) {\n+        match self.infcx.make_canonical_response(self.var_values.clone(), certainty) {\n+            Ok(result) => self.candidates.push(Candidate { source, result }),\n+            Err(NoSolution) => debug!(?source, ?certainty, \"failed leakcheck\"),\n+        }\n+    }\n+\n+    /// If the self type of a trait goal is a projection, computing the relevant candidates is difficult.\n+    ///\n+    /// To deal with this, we first try to normalize the self type and add the candidates for the normalized\n+    /// self type to the list of candidates in case that succeeds. Note that we can't just eagerly return in\n+    /// this case as projections as self types add `\n+    fn assemble_candidates_after_normalizing_self_ty(\n+        &mut self,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n+    ) {\n+        let tcx = self.cx.tcx;\n+        // FIXME: We also have to normalize opaque types, not sure where to best fit that in.\n+        let &ty::Alias(ty::Projection, projection_ty) = goal.predicate.self_ty().kind() else {\n+            return\n+        };\n+        self.infcx.probe(|_| {\n+            let normalized_ty = self.infcx.next_ty_infer();\n+            let normalizes_to_goal = goal.with(\n+                tcx,\n+                ty::Binder::dummy(ty::ProjectionPredicate {\n+                    projection_ty,\n+                    term: normalized_ty.into(),\n+                }),\n+            );\n+            let normalization_certainty =\n+                match self.cx.evaluate_goal(&self.infcx, normalizes_to_goal) {\n+                    Ok((_, certainty)) => certainty,\n+                    Err(NoSolution) => return,\n+                };\n+\n+            // NOTE: Alternatively we could call `evaluate_goal` here and only have a `Normalized` candidate.\n+            // This doesn't work as long as we use `CandidateSource` in both winnowing and to resolve associated items.\n+            let goal = goal.with(tcx, goal.predicate.with_self_type(tcx, normalized_ty));\n+            let mut orig_values = OriginalQueryValues::default();\n+            let goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let normalized_candidates = self.cx.assemble_and_evaluate_trait_candidates(goal);\n+\n+            // Map each candidate from being canonical wrt the current inference context to being\n+            // canonical wrt the caller.\n+            for Candidate { source, result } in normalized_candidates {\n+                self.infcx.probe(|_| {\n+                    let candidate_certainty = fixme_instantiate_canonical_query_response(\n+                        self.infcx,\n+                        &orig_values,\n+                        result,\n+                    );\n+\n+                    // FIXME: This is a bit scary if the `normalizes_to_goal` overflows.\n+                    //\n+                    // If we have an ambiguous candidate it hides that normalization\n+                    // caused an overflow which may cause issues.\n+                    self.try_insert_candidate(\n+                        source,\n+                        normalization_certainty.unify_and(candidate_certainty),\n+                    )\n+                })\n+            }\n+        })\n+    }\n+\n+    fn assemble_impl_candidates(&mut self, goal: Goal<'tcx, TraitPredicate<'tcx>>) {\n+        self.cx.tcx.for_each_relevant_impl(\n+            goal.predicate.def_id(),\n+            goal.predicate.self_ty(),\n+            |impl_def_id| self.consider_impl_candidate(goal, impl_def_id),\n+        );\n+    }\n+\n+    fn consider_impl_candidate(\n+        &mut self,\n+        goal: Goal<'tcx, TraitPredicate<'tcx>>,\n+        impl_def_id: DefId,\n+    ) {\n+        let impl_trait_ref = self.cx.tcx.bound_impl_trait_ref(impl_def_id).unwrap();\n+        let drcx = DeepRejectCtxt { treat_obligation_params: TreatParams::AsPlaceholder };\n+        if iter::zip(goal.predicate.trait_ref.substs, impl_trait_ref.skip_binder().substs)\n+            .any(|(goal, imp)| !drcx.generic_args_may_unify(goal, imp))\n+        {\n+            return;\n+        }\n+\n+        self.infcx.probe(|_| {\n+            let impl_substs = self.infcx.fresh_substs_for_item(DUMMY_SP, impl_def_id);\n+            let impl_trait_ref = impl_trait_ref.subst(self.cx.tcx, impl_substs);\n+\n+            let Ok(InferOk { obligations, .. }) = self\n+                .infcx\n+                .at(&ObligationCause::dummy(), goal.param_env)\n+                .define_opaque_types(false)\n+                .eq(goal.predicate.trait_ref, impl_trait_ref)\n+                .map_err(|e| debug!(\"failed to equate trait refs: {e:?}\"))\n+            else {\n+                return\n+            };\n+\n+            let nested_goals = obligations.into_iter().map(|o| o.into()).collect();\n+\n+            let Ok(certainty) = self.cx.evaluate_all(self.infcx, nested_goals) else { return };\n+            self.try_insert_candidate(CandidateSource::Impl(impl_def_id), certainty);\n+        })\n+    }\n+}"}, {"sha": "5276da2e49c750743c4b9d26a2909eb843926de8", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 3, "deletions": 56, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -25,7 +25,6 @@ use rustc_data_structures::sso::SsoHashSet;\n use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def::DefKind;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::lang_items::LangItem;\n use rustc_infer::infer::at::At;\n use rustc_infer::infer::resolve::OpportunisticRegionResolver;\n@@ -1553,7 +1552,7 @@ fn assemble_candidates_from_impls<'cx, 'tcx>(\n                 // NOTE: This should be kept in sync with the similar code in\n                 // `rustc_ty_utils::instance::resolve_associated_item()`.\n                 let node_item =\n-                    assoc_def(selcx, impl_data.impl_def_id, obligation.predicate.def_id)\n+                    specialization_graph::assoc_def(selcx.tcx(), impl_data.impl_def_id, obligation.predicate.def_id)\n                         .map_err(|ErrorGuaranteed { .. }| ())?;\n \n                 if node_item.is_final() {\n@@ -2113,7 +2112,7 @@ fn confirm_impl_candidate<'cx, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_def_id).unwrap();\n \n     let param_env = obligation.param_env;\n-    let Ok(assoc_ty) = assoc_def(selcx, impl_def_id, assoc_item_id) else {\n+    let Ok(assoc_ty) = specialization_graph::assoc_def(tcx, impl_def_id, assoc_item_id) else {\n         return Progress { term: tcx.ty_error().into(), obligations: nested };\n     };\n \n@@ -2210,7 +2209,7 @@ fn confirm_impl_trait_in_trait_candidate<'tcx>(\n     let mut obligations = data.nested;\n \n     let trait_fn_def_id = tcx.impl_trait_in_trait_parent(obligation.predicate.def_id);\n-    let Ok(leaf_def) = assoc_def(selcx, data.impl_def_id, trait_fn_def_id) else {\n+    let Ok(leaf_def) = specialization_graph::assoc_def(tcx, data.impl_def_id, trait_fn_def_id) else {\n         return Progress { term: tcx.ty_error().into(), obligations };\n     };\n     if !leaf_def.item.defaultness(tcx).has_value() {\n@@ -2347,58 +2346,6 @@ fn assoc_ty_own_obligations<'cx, 'tcx>(\n     }\n }\n \n-/// Locate the definition of an associated type in the specialization hierarchy,\n-/// starting from the given impl.\n-///\n-/// Based on the \"projection mode\", this lookup may in fact only examine the\n-/// topmost impl. See the comments for `Reveal` for more details.\n-fn assoc_def(\n-    selcx: &SelectionContext<'_, '_>,\n-    impl_def_id: DefId,\n-    assoc_def_id: DefId,\n-) -> Result<specialization_graph::LeafDef, ErrorGuaranteed> {\n-    let tcx = selcx.tcx();\n-    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n-    let trait_def = tcx.trait_def(trait_def_id);\n-\n-    // This function may be called while we are still building the\n-    // specialization graph that is queried below (via TraitDef::ancestors()),\n-    // so, in order to avoid unnecessary infinite recursion, we manually look\n-    // for the associated item at the given impl.\n-    // If there is no such item in that impl, this function will fail with a\n-    // cycle error if the specialization graph is currently being built.\n-    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_def_id) {\n-        let item = tcx.associated_item(impl_item_id);\n-        let impl_node = specialization_graph::Node::Impl(impl_def_id);\n-        return Ok(specialization_graph::LeafDef {\n-            item: *item,\n-            defining_node: impl_node,\n-            finalizing_node: if item.defaultness(tcx).is_default() {\n-                None\n-            } else {\n-                Some(impl_node)\n-            },\n-        });\n-    }\n-\n-    let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n-    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_def_id) {\n-        Ok(assoc_item)\n-    } else {\n-        // This is saying that neither the trait nor\n-        // the impl contain a definition for this\n-        // associated type.  Normally this situation\n-        // could only arise through a compiler bug --\n-        // if the user wrote a bad item name, it\n-        // should have failed in astconv.\n-        bug!(\n-            \"No associated type `{}` for {}\",\n-            tcx.item_name(assoc_def_id),\n-            tcx.def_path_str(impl_def_id)\n-        )\n-    }\n-}\n-\n pub(crate) trait ProjectionCacheKeyExt<'cx, 'tcx>: Sized {\n     fn from_poly_projection_predicate(\n         selcx: &mut SelectionContext<'cx, 'tcx>,"}, {"sha": "81e8f9e914c2373ceae19be1daf898dc54e1a2d8", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -1171,19 +1171,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     where\n         I: Iterator<Item = ty::Predicate<'tcx>>,\n     {\n-        cycle.all(|predicate| self.coinductive_predicate(predicate))\n-    }\n-\n-    fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n-        let result = match predicate.kind().skip_binder() {\n-            ty::PredicateKind::Clause(ty::Clause::Trait(ref data)) => {\n-                self.tcx().trait_is_coinductive(data.def_id())\n-            }\n-            ty::PredicateKind::WellFormed(_) => true,\n-            _ => false,\n-        };\n-        debug!(?predicate, ?result, \"coinductive_predicate\");\n-        result\n+        cycle.all(|predicate| predicate.is_coinductive(self.tcx()))\n     }\n \n     /// Further evaluates `candidate` to decide whether all type parameters match and whether nested"}, {"sha": "02b0667774028a37224a926b1d74bb9a92f52b6f", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -1,6 +1,7 @@\n use super::OverlapError;\n \n use crate::traits;\n+use rustc_errors::ErrorGuaranteed;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty::fast_reject::{self, SimplifiedType, TreatParams};\n use rustc_middle::ty::{self, TyCtxt, TypeVisitable};\n@@ -379,3 +380,51 @@ impl<'tcx> GraphExt<'tcx> for Graph {\n         self.children.entry(parent).or_default().insert_blindly(tcx, child);\n     }\n }\n+\n+/// Locate the definition of an associated type in the specialization hierarchy,\n+/// starting from the given impl.\n+pub(crate) fn assoc_def(\n+    tcx: TyCtxt<'_>,\n+    impl_def_id: DefId,\n+    assoc_def_id: DefId,\n+) -> Result<LeafDef, ErrorGuaranteed> {\n+    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n+    let trait_def = tcx.trait_def(trait_def_id);\n+\n+    // This function may be called while we are still building the\n+    // specialization graph that is queried below (via TraitDef::ancestors()),\n+    // so, in order to avoid unnecessary infinite recursion, we manually look\n+    // for the associated item at the given impl.\n+    // If there is no such item in that impl, this function will fail with a\n+    // cycle error if the specialization graph is currently being built.\n+    if let Some(&impl_item_id) = tcx.impl_item_implementor_ids(impl_def_id).get(&assoc_def_id) {\n+        let &item = tcx.associated_item(impl_item_id);\n+        let impl_node = Node::Impl(impl_def_id);\n+        return Ok(LeafDef {\n+            item,\n+            defining_node: impl_node,\n+            finalizing_node: if item.defaultness(tcx).is_default() {\n+                None\n+            } else {\n+                Some(impl_node)\n+            },\n+        });\n+    }\n+\n+    let ancestors = trait_def.ancestors(tcx, impl_def_id)?;\n+    if let Some(assoc_item) = ancestors.leaf_def(tcx, assoc_def_id) {\n+        Ok(assoc_item)\n+    } else {\n+        // This is saying that neither the trait nor\n+        // the impl contain a definition for this\n+        // associated type.  Normally this situation\n+        // could only arise through a compiler bug --\n+        // if the user wrote a bad item name, it\n+        // should have failed in astconv.\n+        bug!(\n+            \"No associated type `{}` for {}\",\n+            tcx.item_name(assoc_def_id),\n+            tcx.def_path_str(impl_def_id)\n+        )\n+    }\n+}"}, {"sha": "a3bb76d7e3b732992c4aeaad87dfaabf665976c5", "filename": "src/test/ui/traits/solver-cycles/inductive-canonical-cycle.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.rs?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -0,0 +1,28 @@\n+// known-bug\n+\n+// This should compile but fails with the current solver.\n+//\n+// This checks that the new solver uses `Ambiguous` when hitting the\n+// inductive cycle here when proving `exists<^0, ^1> (): Trait<^0, ^1>`\n+// which requires proving `Trait<?1, ?0>` but that has the same\n+// canonical representation.\n+trait Trait<T, U> {}\n+\n+impl<T, U> Trait<T, U> for ()\n+where\n+    (): Trait<U, T>,\n+    T: OtherTrait,\n+{}\n+\n+trait OtherTrait {}\n+impl OtherTrait for u32 {}\n+\n+fn require_trait<T, U>()\n+where\n+    (): Trait<T, U>\n+{}\n+\n+fn main() {\n+    require_trait::<_, _>();\n+    //~^ ERROR overflow evaluating\n+}"}, {"sha": "e4b84e07822d28c784896071f43f19244aff4da6", "filename": "src/test/ui/traits/solver-cycles/inductive-canonical-cycle.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fsolver-cycles%2Finductive-canonical-cycle.stderr?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -0,0 +1,26 @@\n+error[E0275]: overflow evaluating the requirement `_: Sized`\n+  --> $DIR/inductive-canonical-cycle.rs:26:5\n+   |\n+LL |     require_trait::<_, _>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`inductive_canonical_cycle`)\n+note: required for `()` to implement `Trait<_, _>`\n+  --> $DIR/inductive-canonical-cycle.rs:11:12\n+   |\n+LL | impl<T, U> Trait<T, U> for ()\n+   |            ^^^^^^^^^^^     ^^\n+   = note: 128 redundant requirements hidden\n+   = note: required for `()` to implement `Trait<_, _>`\n+note: required by a bound in `require_trait`\n+  --> $DIR/inductive-canonical-cycle.rs:22:9\n+   |\n+LL | fn require_trait<T, U>()\n+   |    ------------- required by a bound in this\n+LL | where\n+LL |     (): Trait<T, U>\n+   |         ^^^^^^^^^^^ required by this bound in `require_trait`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0275`."}, {"sha": "c7158a51861e5f396d270c48475cf2ee3eee7dad", "filename": "triagebot.toml", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a213bb36c953d2c342d8ae9303704e57bc8aab33/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a213bb36c953d2c342d8ae9303704e57bc8aab33/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=a213bb36c953d2c342d8ae9303704e57bc8aab33", "patch": "@@ -342,6 +342,10 @@ cc = [\"@BoxyUwU\"]\n message = \"Some changes occured in `rustc_ty_utils::consts.rs`\"\n cc = [\"@BoxyUwU\"]\n \n+[mentions.\"compiler/rustc_trait_selection/src/solve]\n+message = \"Some changes occurred to the core trait solver\"\n+cc = [\"@lcnr\"]\n+\n [mentions.\"compiler/rustc_trait_selection/src/traits/engine.rs\"]\n message = \"\"\"\n Some changes occurred in engine.rs, potentially modifying the public API \\"}]}