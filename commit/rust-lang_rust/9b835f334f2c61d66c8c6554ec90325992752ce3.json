{"sha": "9b835f334f2c61d66c8c6554ec90325992752ce3", "node_id": "C_kwDOAAsO6NoAKDliODM1ZjMzNGYyYzYxZDY2YzhjNjU1NGVjOTAzMjU5OTI3NTJjZTM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-17T19:00:42Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-17T19:00:42Z"}, "message": "Auto merge of #14594 - Veykril:Simplify, r=Veykril\n\ninternal: Move Expander and LowerCtx into separate modules", "tree": {"sha": "62d38c8456c9984cabc09f1b238876600042e398", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/62d38c8456c9984cabc09f1b238876600042e398"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b835f334f2c61d66c8c6554ec90325992752ce3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b835f334f2c61d66c8c6554ec90325992752ce3", "html_url": "https://github.com/rust-lang/rust/commit/9b835f334f2c61d66c8c6554ec90325992752ce3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b835f334f2c61d66c8c6554ec90325992752ce3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b92b7c0d949a1260ddbb5f6e7a32b44f51a68921", "url": "https://api.github.com/repos/rust-lang/rust/commits/b92b7c0d949a1260ddbb5f6e7a32b44f51a68921", "html_url": "https://github.com/rust-lang/rust/commit/b92b7c0d949a1260ddbb5f6e7a32b44f51a68921"}, {"sha": "bca8029a6ed7bed26bdea284738f64f10c063ba8", "url": "https://api.github.com/repos/rust-lang/rust/commits/bca8029a6ed7bed26bdea284738f64f10c063ba8", "html_url": "https://github.com/rust-lang/rust/commit/bca8029a6ed7bed26bdea284738f64f10c063ba8"}], "stats": {"total": 889, "additions": 487, "deletions": 402}, "files": [{"sha": "1ebbe160b071c83feba7152292602329a7c9a397", "filename": "crates/hir-def/src/attr.rs", "status": "modified", "additions": 55, "deletions": 31, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fattr.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -28,8 +28,8 @@ use crate::{\n     lang_item::LangItem,\n     nameres::{ModuleOrigin, ModuleSource},\n     src::{HasChildSource, HasSource},\n-    AdtId, AttrDefId, EnumId, GenericParamId, LocalEnumVariantId, LocalFieldId, Lookup, MacroId,\n-    VariantId,\n+    AdtId, AssocItemLoc, AttrDefId, EnumId, GenericParamId, ItemLoc, LocalEnumVariantId,\n+    LocalFieldId, Lookup, MacroId, VariantId,\n };\n \n /// Holds documentation\n@@ -421,23 +421,24 @@ impl AttrsWithOwner {\n             AttrDefId::EnumVariantId(it) => {\n                 return db.variants_attrs(it.parent)[it.local_id].clone();\n             }\n+            // FIXME: DRY this up\n             AttrDefId::AdtId(it) => match it {\n-                AdtId::StructId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-                AdtId::EnumId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-                AdtId::UnionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                AdtId::StructId(it) => attrs_from_item_tree_loc(db, it),\n+                AdtId::EnumId(it) => attrs_from_item_tree_loc(db, it),\n+                AdtId::UnionId(it) => attrs_from_item_tree_loc(db, it),\n             },\n-            AttrDefId::TraitId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::TraitAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::TraitId(it) => attrs_from_item_tree_loc(db, it),\n+            AttrDefId::TraitAliasId(it) => attrs_from_item_tree_loc(db, it),\n             AttrDefId::MacroId(it) => match it {\n-                MacroId::Macro2Id(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-                MacroId::MacroRulesId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-                MacroId::ProcMacroId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                MacroId::Macro2Id(it) => attrs_from_item_tree(db, it.lookup(db).id),\n+                MacroId::MacroRulesId(it) => attrs_from_item_tree(db, it.lookup(db).id),\n+                MacroId::ProcMacroId(it) => attrs_from_item_tree(db, it.lookup(db).id),\n             },\n-            AttrDefId::ImplId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::ConstId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::StaticId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::FunctionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n-            AttrDefId::TypeAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::ImplId(it) => attrs_from_item_tree_loc(db, it),\n+            AttrDefId::ConstId(it) => attrs_from_item_tree_assoc(db, it),\n+            AttrDefId::StaticId(it) => attrs_from_item_tree_assoc(db, it),\n+            AttrDefId::FunctionId(it) => attrs_from_item_tree_assoc(db, it),\n+            AttrDefId::TypeAliasId(it) => attrs_from_item_tree_assoc(db, it),\n             AttrDefId::GenericParamId(it) => match it {\n                 GenericParamId::ConstParamId(it) => {\n                     let src = it.parent().child_source(db);\n@@ -458,7 +459,7 @@ impl AttrsWithOwner {\n                     RawAttrs::from_attrs_owner(db.upcast(), src.with_value(&src.value[it.local_id]))\n                 }\n             },\n-            AttrDefId::ExternBlockId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::ExternBlockId(it) => attrs_from_item_tree_loc(db, it),\n         };\n \n         let attrs = raw_attrs.filter(db.upcast(), def.krate(db));\n@@ -506,28 +507,28 @@ impl AttrsWithOwner {\n                 InFile::new(file_id, owner)\n             }\n             AttrDefId::AdtId(adt) => match adt {\n-                AdtId::StructId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-                AdtId::UnionId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-                AdtId::EnumId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+                AdtId::StructId(id) => any_has_attrs(db, id),\n+                AdtId::UnionId(id) => any_has_attrs(db, id),\n+                AdtId::EnumId(id) => any_has_attrs(db, id),\n             },\n-            AttrDefId::FunctionId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::FunctionId(id) => any_has_attrs(db, id),\n             AttrDefId::EnumVariantId(id) => {\n                 let map = db.variants_attrs_source_map(id.parent);\n                 let file_id = id.parent.lookup(db).id.file_id();\n                 let root = db.parse_or_expand(file_id);\n                 InFile::new(file_id, ast::AnyHasAttrs::new(map[id.local_id].to_node(&root)))\n             }\n-            AttrDefId::StaticId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-            AttrDefId::ConstId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-            AttrDefId::TraitId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-            AttrDefId::TraitAliasId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-            AttrDefId::TypeAliasId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::StaticId(id) => any_has_attrs(db, id),\n+            AttrDefId::ConstId(id) => any_has_attrs(db, id),\n+            AttrDefId::TraitId(id) => any_has_attrs(db, id),\n+            AttrDefId::TraitAliasId(id) => any_has_attrs(db, id),\n+            AttrDefId::TypeAliasId(id) => any_has_attrs(db, id),\n             AttrDefId::MacroId(id) => match id {\n-                MacroId::Macro2Id(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-                MacroId::MacroRulesId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n-                MacroId::ProcMacroId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+                MacroId::Macro2Id(id) => any_has_attrs(db, id),\n+                MacroId::MacroRulesId(id) => any_has_attrs(db, id),\n+                MacroId::ProcMacroId(id) => any_has_attrs(db, id),\n             },\n-            AttrDefId::ImplId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::ImplId(id) => any_has_attrs(db, id),\n             AttrDefId::GenericParamId(id) => match id {\n                 GenericParamId::ConstParamId(id) => id\n                     .parent()\n@@ -542,7 +543,7 @@ impl AttrsWithOwner {\n                     .child_source(db)\n                     .map(|source| ast::AnyHasAttrs::new(source[id.local_id].clone())),\n             },\n-            AttrDefId::ExternBlockId(id) => id.lookup(db).source(db).map(ast::AnyHasAttrs::new),\n+            AttrDefId::ExternBlockId(id) => any_has_attrs(db, id),\n         };\n \n         AttrSourceMap::new(owner.as_ref().map(|node| node as &dyn HasAttrs))\n@@ -769,12 +770,35 @@ impl<'attr> AttrQuery<'attr> {\n     }\n }\n \n-fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase) -> RawAttrs {\n+fn any_has_attrs(\n+    db: &dyn DefDatabase,\n+    id: impl Lookup<Data = impl HasSource<Value = impl ast::HasAttrs>>,\n+) -> InFile<ast::AnyHasAttrs> {\n+    id.lookup(db).source(db).map(ast::AnyHasAttrs::new)\n+}\n+\n+fn attrs_from_item_tree<N: ItemTreeNode>(db: &dyn DefDatabase, id: ItemTreeId<N>) -> RawAttrs {\n     let tree = id.item_tree(db);\n     let mod_item = N::id_to_mod_item(id.value);\n     tree.raw_attrs(mod_item.into()).clone()\n }\n \n+fn attrs_from_item_tree_loc<N: ItemTreeNode>(\n+    db: &dyn DefDatabase,\n+    lookup: impl Lookup<Data = ItemLoc<N>>,\n+) -> RawAttrs {\n+    let id = lookup.lookup(db).id;\n+    attrs_from_item_tree(db, id)\n+}\n+\n+fn attrs_from_item_tree_assoc<N: ItemTreeNode>(\n+    db: &dyn DefDatabase,\n+    lookup: impl Lookup<Data = AssocItemLoc<N>>,\n+) -> RawAttrs {\n+    let id = lookup.lookup(db).id;\n+    attrs_from_item_tree(db, id)\n+}\n+\n pub(crate) fn variants_attrs_source_map(\n     db: &dyn DefDatabase,\n     def: EnumId,"}, {"sha": "0c0e8ac8204e36a849a744fcff696d3eae9c9a3b", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 45, "deletions": 302, "changes": 347, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -10,284 +10,25 @@ use std::{ops::Index, sync::Arc};\n \n use base_db::CrateId;\n use cfg::{CfgExpr, CfgOptions};\n-use drop_bomb::DropBomb;\n use either::Either;\n-use hir_expand::{\n-    ast_id_map::AstIdMap, attrs::RawAttrs, hygiene::Hygiene, name::Name, AstId, ExpandError,\n-    ExpandResult, HirFileId, InFile, MacroCallId,\n-};\n+use hir_expand::{name::Name, HirFileId, InFile};\n use la_arena::{Arena, ArenaMap};\n-use limit::Limit;\n-use once_cell::unsync::OnceCell;\n use profile::Count;\n use rustc_hash::FxHashMap;\n-use syntax::{ast, AstPtr, Parse, SyntaxNode, SyntaxNodePtr};\n+use syntax::{ast, AstPtr, SyntaxNodePtr};\n \n use crate::{\n-    attr::Attrs,\n     db::DefDatabase,\n+    expander::Expander,\n     hir::{\n         dummy_expr_id, Binding, BindingId, Expr, ExprId, Label, LabelId, Pat, PatId, RecordFieldPat,\n     },\n-    item_scope::BuiltinShadowMode,\n-    macro_id_to_def_id,\n     nameres::DefMap,\n     path::{ModPath, Path},\n     src::{HasChildSource, HasSource},\n-    AsMacroCall, BlockId, DefWithBodyId, HasModule, LocalModuleId, Lookup, MacroId, ModuleId,\n-    UnresolvedMacro,\n+    BlockId, DefWithBodyId, HasModule, Lookup,\n };\n \n-pub struct LowerCtx<'a> {\n-    pub db: &'a dyn DefDatabase,\n-    hygiene: Hygiene,\n-    ast_id_map: Option<(HirFileId, OnceCell<Arc<AstIdMap>>)>,\n-}\n-\n-impl<'a> LowerCtx<'a> {\n-    pub fn new(db: &'a dyn DefDatabase, hygiene: &Hygiene, file_id: HirFileId) -> Self {\n-        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: Some((file_id, OnceCell::new())) }\n-    }\n-\n-    pub fn with_file_id(db: &'a dyn DefDatabase, file_id: HirFileId) -> Self {\n-        LowerCtx {\n-            db,\n-            hygiene: Hygiene::new(db.upcast(), file_id),\n-            ast_id_map: Some((file_id, OnceCell::new())),\n-        }\n-    }\n-\n-    pub fn with_hygiene(db: &'a dyn DefDatabase, hygiene: &Hygiene) -> Self {\n-        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: None }\n-    }\n-\n-    pub(crate) fn hygiene(&self) -> &Hygiene {\n-        &self.hygiene\n-    }\n-\n-    pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n-        Path::from_src(ast, self)\n-    }\n-\n-    pub(crate) fn ast_id<N: syntax::AstNode>(&self, item: &N) -> Option<AstId<N>> {\n-        let &(file_id, ref ast_id_map) = self.ast_id_map.as_ref()?;\n-        let ast_id_map = ast_id_map.get_or_init(|| self.db.ast_id_map(file_id));\n-        Some(InFile::new(file_id, ast_id_map.ast_id(item)))\n-    }\n-}\n-\n-/// A subset of Expander that only deals with cfg attributes. We only need it to\n-/// avoid cyclic queries in crate def map during enum processing.\n-#[derive(Debug)]\n-pub(crate) struct CfgExpander {\n-    cfg_options: CfgOptions,\n-    hygiene: Hygiene,\n-    krate: CrateId,\n-}\n-\n-#[derive(Debug)]\n-pub struct Expander {\n-    cfg_expander: CfgExpander,\n-    def_map: Arc<DefMap>,\n-    current_file_id: HirFileId,\n-    module: LocalModuleId,\n-    /// `recursion_depth == usize::MAX` indicates that the recursion limit has been reached.\n-    recursion_depth: usize,\n-}\n-\n-impl CfgExpander {\n-    pub(crate) fn new(\n-        db: &dyn DefDatabase,\n-        current_file_id: HirFileId,\n-        krate: CrateId,\n-    ) -> CfgExpander {\n-        let hygiene = Hygiene::new(db.upcast(), current_file_id);\n-        let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n-        CfgExpander { cfg_options, hygiene, krate }\n-    }\n-\n-    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n-        Attrs::filter(db, self.krate, RawAttrs::new(db.upcast(), owner, &self.hygiene))\n-    }\n-\n-    pub(crate) fn is_cfg_enabled(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> bool {\n-        let attrs = self.parse_attrs(db, owner);\n-        attrs.is_cfg_enabled(&self.cfg_options)\n-    }\n-\n-    pub(crate) fn hygiene(&self) -> &Hygiene {\n-        &self.hygiene\n-    }\n-}\n-\n-impl Expander {\n-    pub fn new(db: &dyn DefDatabase, current_file_id: HirFileId, module: ModuleId) -> Expander {\n-        let cfg_expander = CfgExpander::new(db, current_file_id, module.krate);\n-        let def_map = module.def_map(db);\n-        Expander {\n-            cfg_expander,\n-            def_map,\n-            current_file_id,\n-            module: module.local_id,\n-            recursion_depth: 0,\n-        }\n-    }\n-\n-    pub fn enter_expand<T: ast::AstNode>(\n-        &mut self,\n-        db: &dyn DefDatabase,\n-        macro_call: ast::MacroCall,\n-    ) -> Result<ExpandResult<Option<(Mark, Parse<T>)>>, UnresolvedMacro> {\n-        // FIXME: within_limit should support this, instead of us having to extract the error\n-        let mut unresolved_macro_err = None;\n-\n-        let result = self.within_limit(db, |this| {\n-            let macro_call = InFile::new(this.current_file_id, &macro_call);\n-\n-            let resolver =\n-                |path| this.resolve_path_as_macro(db, &path).map(|it| macro_id_to_def_id(db, it));\n-\n-            match macro_call.as_call_id_with_errors(db, this.def_map.krate(), resolver) {\n-                Ok(call_id) => call_id,\n-                Err(resolve_err) => {\n-                    unresolved_macro_err = Some(resolve_err);\n-                    ExpandResult { value: None, err: None }\n-                }\n-            }\n-        });\n-\n-        if let Some(err) = unresolved_macro_err {\n-            Err(err)\n-        } else {\n-            Ok(result)\n-        }\n-    }\n-\n-    pub fn enter_expand_id<T: ast::AstNode>(\n-        &mut self,\n-        db: &dyn DefDatabase,\n-        call_id: MacroCallId,\n-    ) -> ExpandResult<Option<(Mark, Parse<T>)>> {\n-        self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))\n-    }\n-\n-    fn enter_expand_inner(\n-        db: &dyn DefDatabase,\n-        call_id: MacroCallId,\n-        error: Option<ExpandError>,\n-    ) -> ExpandResult<Option<InFile<Parse<SyntaxNode>>>> {\n-        let file_id = call_id.as_file();\n-        let ExpandResult { value, err } = db.parse_or_expand_with_err(file_id);\n-\n-        ExpandResult { value: Some(InFile::new(file_id, value)), err: error.or(err) }\n-    }\n-\n-    pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n-        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n-        self.current_file_id = mark.file_id;\n-        if self.recursion_depth == usize::MAX {\n-            // Recursion limit has been reached somewhere in the macro expansion tree. Reset the\n-            // depth only when we get out of the tree.\n-            if !self.current_file_id.is_macro() {\n-                self.recursion_depth = 0;\n-            }\n-        } else {\n-            self.recursion_depth -= 1;\n-        }\n-        mark.bomb.defuse();\n-    }\n-\n-    pub fn ctx<'a>(&self, db: &'a dyn DefDatabase) -> LowerCtx<'a> {\n-        LowerCtx::new(db, &self.cfg_expander.hygiene, self.current_file_id)\n-    }\n-\n-    pub(crate) fn to_source<T>(&self, value: T) -> InFile<T> {\n-        InFile { file_id: self.current_file_id, value }\n-    }\n-\n-    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n-        self.cfg_expander.parse_attrs(db, owner)\n-    }\n-\n-    pub(crate) fn cfg_options(&self) -> &CfgOptions {\n-        &self.cfg_expander.cfg_options\n-    }\n-\n-    pub fn current_file_id(&self) -> HirFileId {\n-        self.current_file_id\n-    }\n-\n-    fn parse_path(&mut self, db: &dyn DefDatabase, path: ast::Path) -> Option<Path> {\n-        let ctx = LowerCtx::with_hygiene(db, &self.cfg_expander.hygiene);\n-        Path::from_src(path, &ctx)\n-    }\n-\n-    fn resolve_path_as_macro(&self, db: &dyn DefDatabase, path: &ModPath) -> Option<MacroId> {\n-        self.def_map.resolve_path(db, self.module, path, BuiltinShadowMode::Other).0.take_macros()\n-    }\n-\n-    fn recursion_limit(&self, db: &dyn DefDatabase) -> Limit {\n-        let limit = db.crate_limits(self.cfg_expander.krate).recursion_limit as _;\n-\n-        #[cfg(not(test))]\n-        return Limit::new(limit);\n-\n-        // Without this, `body::tests::your_stack_belongs_to_me` stack-overflows in debug\n-        #[cfg(test)]\n-        return Limit::new(std::cmp::min(32, limit));\n-    }\n-\n-    fn within_limit<F, T: ast::AstNode>(\n-        &mut self,\n-        db: &dyn DefDatabase,\n-        op: F,\n-    ) -> ExpandResult<Option<(Mark, Parse<T>)>>\n-    where\n-        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,\n-    {\n-        if self.recursion_depth == usize::MAX {\n-            // Recursion limit has been reached somewhere in the macro expansion tree. We should\n-            // stop expanding other macro calls in this tree, or else this may result in\n-            // exponential number of macro expansions, leading to a hang.\n-            //\n-            // The overflow error should have been reported when it occurred (see the next branch),\n-            // so don't return overflow error here to avoid diagnostics duplication.\n-            cov_mark::hit!(overflow_but_not_me);\n-            return ExpandResult::only_err(ExpandError::RecursionOverflowPoisoned);\n-        } else if self.recursion_limit(db).check(self.recursion_depth + 1).is_err() {\n-            self.recursion_depth = usize::MAX;\n-            cov_mark::hit!(your_stack_belongs_to_me);\n-            return ExpandResult::only_err(ExpandError::Other(\n-                \"reached recursion limit during macro expansion\".into(),\n-            ));\n-        }\n-\n-        let ExpandResult { value, err } = op(self);\n-        let Some(call_id) = value else {\n-            return ExpandResult { value: None, err };\n-        };\n-\n-        Self::enter_expand_inner(db, call_id, err).map(|value| {\n-            value.and_then(|InFile { file_id, value }| {\n-                let parse = value.cast::<T>()?;\n-\n-                self.recursion_depth += 1;\n-                self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n-                let old_file_id = std::mem::replace(&mut self.current_file_id, file_id);\n-                let mark =\n-                    Mark { file_id: old_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n-                Some((mark, parse))\n-            })\n-        })\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct Mark {\n-    file_id: HirFileId,\n-    bomb: DropBomb,\n-}\n-\n /// The body of an item (function, const etc.).\n #[derive(Debug, Eq, PartialEq)]\n pub struct Body {\n@@ -376,47 +117,49 @@ impl Body {\n         let _p = profile::span(\"body_with_source_map_query\");\n         let mut params = None;\n \n-        let (file_id, module, body, is_async_fn) = match def {\n-            DefWithBodyId::FunctionId(f) => {\n-                let data = db.function_data(f);\n-                let f = f.lookup(db);\n-                let src = f.source(db);\n-                params = src.value.param_list().map(|param_list| {\n-                    let item_tree = f.id.item_tree(db);\n-                    let func = &item_tree[f.id.value];\n-                    let krate = f.container.module(db).krate;\n-                    let crate_graph = db.crate_graph();\n+        let (file_id, module, body, is_async_fn) = {\n+            match def {\n+                DefWithBodyId::FunctionId(f) => {\n+                    let data = db.function_data(f);\n+                    let f = f.lookup(db);\n+                    let src = f.source(db);\n+                    params = src.value.param_list().map(|param_list| {\n+                        let item_tree = f.id.item_tree(db);\n+                        let func = &item_tree[f.id.value];\n+                        let krate = f.container.module(db).krate;\n+                        let crate_graph = db.crate_graph();\n+                        (\n+                            param_list,\n+                            func.params.clone().map(move |param| {\n+                                item_tree\n+                                    .attrs(db, krate, param.into())\n+                                    .is_cfg_enabled(&crate_graph[krate].cfg_options)\n+                            }),\n+                        )\n+                    });\n                     (\n-                        param_list,\n-                        func.params.clone().map(move |param| {\n-                            item_tree\n-                                .attrs(db, krate, param.into())\n-                                .is_cfg_enabled(&crate_graph[krate].cfg_options)\n-                        }),\n+                        src.file_id,\n+                        f.module(db),\n+                        src.value.body().map(ast::Expr::from),\n+                        data.has_async_kw(),\n                     )\n-                });\n-                (\n-                    src.file_id,\n-                    f.module(db),\n-                    src.value.body().map(ast::Expr::from),\n-                    data.has_async_kw(),\n-                )\n-            }\n-            DefWithBodyId::ConstId(c) => {\n-                let c = c.lookup(db);\n-                let src = c.source(db);\n-                (src.file_id, c.module(db), src.value.body(), false)\n-            }\n-            DefWithBodyId::StaticId(s) => {\n-                let s = s.lookup(db);\n-                let src = s.source(db);\n-                (src.file_id, s.module(db), src.value.body(), false)\n-            }\n-            DefWithBodyId::VariantId(v) => {\n-                let e = v.parent.lookup(db);\n-                let src = v.parent.child_source(db);\n-                let variant = &src.value[v.local_id];\n-                (src.file_id, e.container, variant.expr(), false)\n+                }\n+                DefWithBodyId::ConstId(c) => {\n+                    let c = c.lookup(db);\n+                    let src = c.source(db);\n+                    (src.file_id, c.module(db), src.value.body(), false)\n+                }\n+                DefWithBodyId::StaticId(s) => {\n+                    let s = s.lookup(db);\n+                    let src = s.source(db);\n+                    (src.file_id, s.module(db), src.value.body(), false)\n+                }\n+                DefWithBodyId::VariantId(v) => {\n+                    let e = v.parent.lookup(db);\n+                    let src = v.parent.child_source(db);\n+                    let variant = &src.value[v.local_id];\n+                    (src.file_id, e.container, variant.expr(), false)\n+                }\n             }\n         };\n         let expander = Expander::new(db, file_id, module);"}, {"sha": "27dfe766d335ecc38dcdb18d5a89f16e1db6c30c", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -24,16 +24,19 @@ use syntax::{\n };\n \n use crate::{\n-    body::{Body, BodyDiagnostic, BodySourceMap, Expander, ExprPtr, LabelPtr, LowerCtx, PatPtr},\n+    body::{Body, BodyDiagnostic, BodySourceMap, ExprPtr, LabelPtr, PatPtr},\n     data::adt::StructKind,\n     db::DefDatabase,\n+    expander::Expander,\n     hir::{\n         dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, CaptureBy, ClosureKind, Expr,\n         ExprId, Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat,\n         RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n     lang_item::LangItem,\n+    lower::LowerCtx,\n+    nameres::DefMap,\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n@@ -50,6 +53,7 @@ pub(super) fn lower(\n     ExprCollector {\n         db,\n         krate,\n+        def_map: db.crate_def_map(krate),\n         source_map: BodySourceMap::default(),\n         ast_id_map: db.ast_id_map(expander.current_file_id),\n         body: Body {\n@@ -75,6 +79,7 @@ pub(super) fn lower(\n struct ExprCollector<'a> {\n     db: &'a dyn DefDatabase,\n     expander: Expander,\n+    def_map: Arc<DefMap>,\n     ast_id_map: Arc<AstIdMap>,\n     krate: CrateId,\n     body: Body,\n@@ -777,7 +782,13 @@ impl ExprCollector<'_> {\n         let outer_file = self.expander.current_file_id;\n \n         let macro_call_ptr = self.expander.to_source(AstPtr::new(&mcall));\n-        let res = self.expander.enter_expand(self.db, mcall);\n+        let module = self.expander.module.local_id;\n+        let res = self.expander.enter_expand(self.db, mcall, |path| {\n+            self.def_map\n+                .resolve_path(self.db, module, &path, crate::item_scope::BuiltinShadowMode::Other)\n+                .0\n+                .take_macros()\n+        });\n \n         let res = match res {\n             Ok(res) => res,\n@@ -944,10 +955,7 @@ impl ExprCollector<'_> {\n         let block_id = if block_has_items {\n             let file_local_id = self.ast_id_map.ast_id(&block);\n             let ast_id = AstId::new(self.expander.current_file_id, file_local_id);\n-            Some(self.db.intern_block(BlockLoc {\n-                ast_id,\n-                module: self.expander.def_map.module_id(self.expander.module),\n-            }))\n+            Some(self.db.intern_block(BlockLoc { ast_id, module: self.expander.module }))\n         } else {\n             None\n         };\n@@ -956,11 +964,11 @@ impl ExprCollector<'_> {\n             match block_id.map(|block_id| (self.db.block_def_map(block_id), block_id)) {\n                 Some((def_map, block_id)) => {\n                     self.body.block_scopes.push(block_id);\n-                    (def_map.root(), def_map)\n+                    (def_map.module_id(def_map.root()), def_map)\n                 }\n-                None => (self.expander.module, self.expander.def_map.clone()),\n+                None => (self.expander.module, self.def_map.clone()),\n             };\n-        let prev_def_map = mem::replace(&mut self.expander.def_map, def_map);\n+        let prev_def_map = mem::replace(&mut self.def_map, def_map);\n         let prev_local_module = mem::replace(&mut self.expander.module, module);\n \n         let mut statements = Vec::new();\n@@ -982,7 +990,7 @@ impl ExprCollector<'_> {\n         let expr_id = self\n             .alloc_expr(mk_block(block_id, statements.into_boxed_slice(), tail), syntax_node_ptr);\n \n-        self.expander.def_map = prev_def_map;\n+        self.def_map = prev_def_map;\n         self.expander.module = prev_local_module;\n         expr_id\n     }\n@@ -1028,9 +1036,9 @@ impl ExprCollector<'_> {\n                 let (binding, pattern) = if is_simple_ident_pat {\n                     // This could also be a single-segment path pattern. To\n                     // decide that, we need to try resolving the name.\n-                    let (resolved, _) = self.expander.def_map.resolve_path(\n+                    let (resolved, _) = self.def_map.resolve_path(\n                         self.db,\n-                        self.expander.module,\n+                        self.expander.module.local_id,\n                         &name.clone().into(),\n                         BuiltinShadowMode::Other,\n                     );"}, {"sha": "73d4eebb85afdda51ee97a9549e9bdfec2955436", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 26, "deletions": 7, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -11,8 +11,8 @@ use syntax::{ast, Parse};\n \n use crate::{\n     attr::Attrs,\n-    body::{Expander, Mark},\n     db::DefDatabase,\n+    expander::{Expander, Mark},\n     item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n     nameres::{\n         attr_resolution::ResolvedAttr,\n@@ -44,16 +44,16 @@ impl FunctionData {\n     pub(crate) fn fn_data_query(db: &dyn DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n         let loc = func.lookup(db);\n         let krate = loc.container.module(db).krate;\n-        let crate_graph = db.crate_graph();\n-        let cfg_options = &crate_graph[krate].cfg_options;\n         let item_tree = loc.id.item_tree(db);\n         let func = &item_tree[loc.id.value];\n         let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n-            db.trait_data(trait_id).visibility.clone()\n+            trait_vis(db, trait_id)\n         } else {\n             item_tree[func.visibility].clone()\n         };\n \n+        let crate_graph = db.crate_graph();\n+        let cfg_options = &crate_graph[krate].cfg_options;\n         let enabled_params = func\n             .params\n             .clone()\n@@ -188,7 +188,7 @@ impl TypeAliasData {\n         let item_tree = loc.id.item_tree(db);\n         let typ = &item_tree[loc.id.value];\n         let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n-            db.trait_data(trait_id).visibility.clone()\n+            trait_vis(db, trait_id)\n         } else {\n             item_tree[typ.visibility].clone()\n         };\n@@ -471,7 +471,7 @@ impl ConstData {\n         let item_tree = loc.id.item_tree(db);\n         let konst = &item_tree[loc.id.value];\n         let visibility = if let ItemContainerId::TraitId(trait_id) = loc.container {\n-            db.trait_data(trait_id).visibility.clone()\n+            trait_vis(db, trait_id)\n         } else {\n             item_tree[konst.visibility].clone()\n         };\n@@ -647,8 +647,20 @@ impl<'a> AssocItemCollector<'a> {\n                     let _cx = stdx::panic_context::enter(format!(\n                         \"collect_items MacroCall: {macro_call}\"\n                     ));\n+                    let module = self.expander.module.local_id;\n+\n                     if let Ok(res) =\n-                        self.expander.enter_expand::<ast::MacroItems>(self.db, macro_call)\n+                        self.expander.enter_expand::<ast::MacroItems>(self.db, macro_call, |path| {\n+                            self.def_map\n+                                .resolve_path(\n+                                    self.db,\n+                                    module,\n+                                    &path,\n+                                    crate::item_scope::BuiltinShadowMode::Other,\n+                                )\n+                                .0\n+                                .take_macros()\n+                        })\n                     {\n                         self.collect_macro_items(res, &|| hir_expand::MacroCallKind::FnLike {\n                             ast_id: InFile::new(file_id, call.ast_id),\n@@ -692,3 +704,10 @@ impl<'a> AssocItemCollector<'a> {\n         self.expander.exit(self.db, mark);\n     }\n }\n+\n+fn trait_vis(db: &dyn DefDatabase, trait_id: TraitId) -> RawVisibility {\n+    let ItemLoc { id: tree_id, .. } = trait_id.lookup(db);\n+    let item_tree = tree_id.item_tree(db);\n+    let tr_def = &item_tree[tree_id.value];\n+    item_tree[tr_def.visibility].clone()\n+}"}, {"sha": "31f91317994d1ca8bda0d139fea1e89b25cb66c3", "filename": "crates/hir-def/src/data/adt.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fdata%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fdata%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata%2Fadt.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -17,11 +17,12 @@ use rustc_abi::{Align, Integer, IntegerType, ReprFlags, ReprOptions};\n use syntax::ast::{self, HasName, HasVisibility};\n \n use crate::{\n-    body::{CfgExpander, LowerCtx},\n     builtin_type::{BuiltinInt, BuiltinUint},\n     db::DefDatabase,\n+    expander::CfgExpander,\n     item_tree::{AttrOwner, Field, FieldAstId, Fields, ItemTree, ModItem, RawVisibilityId},\n     lang_item::LangItem,\n+    lower::LowerCtx,\n     nameres::diagnostics::DefDiagnostic,\n     src::HasChildSource,\n     src::HasSource,"}, {"sha": "cc87b03eef7fb3de3c62d7b8426f395ceb004dd9", "filename": "crates/hir-def/src/db.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdb.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -217,6 +217,8 @@ pub trait DefDatabase: InternDatabase + ExpandDatabase + Upcast<dyn ExpandDataba\n \n     #[salsa::transparent]\n     fn crate_limits(&self, crate_id: CrateId) -> CrateLimits;\n+    #[salsa::transparent]\n+    fn recursion_limit(&self, crate_id: CrateId) -> u32;\n \n     fn crate_supports_no_std(&self, crate_id: CrateId) -> bool;\n }\n@@ -240,6 +242,10 @@ fn crate_limits(db: &dyn DefDatabase, crate_id: CrateId) -> CrateLimits {\n     }\n }\n \n+fn recursion_limit(db: &dyn DefDatabase, crate_id: CrateId) -> u32 {\n+    db.crate_limits(crate_id).recursion_limit\n+}\n+\n fn crate_supports_no_std(db: &dyn DefDatabase, crate_id: CrateId) -> bool {\n     let file = db.crate_graph()[crate_id].root_file_id;\n     let item_tree = db.file_item_tree(file.into());"}, {"sha": "34ed1e72f2001cd1c51afca4c864cbc3283779bf", "filename": "crates/hir-def/src/expander.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fexpander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fexpander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fexpander.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -0,0 +1,211 @@\n+//! Macro expansion utilities.\n+\n+use base_db::CrateId;\n+use cfg::CfgOptions;\n+use drop_bomb::DropBomb;\n+use hir_expand::{\n+    attrs::RawAttrs, hygiene::Hygiene, mod_path::ModPath, ExpandError, ExpandResult, HirFileId,\n+    InFile, MacroCallId, UnresolvedMacro,\n+};\n+use limit::Limit;\n+use syntax::{ast, Parse, SyntaxNode};\n+\n+use crate::{\n+    attr::Attrs, db::DefDatabase, lower::LowerCtx, macro_id_to_def_id, path::Path, AsMacroCall,\n+    MacroId, ModuleId,\n+};\n+\n+/// A subset of Expander that only deals with cfg attributes. We only need it to\n+/// avoid cyclic queries in crate def map during enum processing.\n+#[derive(Debug)]\n+pub(crate) struct CfgExpander {\n+    cfg_options: CfgOptions,\n+    hygiene: Hygiene,\n+    krate: CrateId,\n+}\n+\n+#[derive(Debug)]\n+pub struct Expander {\n+    cfg_expander: CfgExpander,\n+    pub(crate) current_file_id: HirFileId,\n+    pub(crate) module: ModuleId,\n+    /// `recursion_depth == usize::MAX` indicates that the recursion limit has been reached.\n+    recursion_depth: u32,\n+    recursion_limit: Limit,\n+}\n+\n+impl CfgExpander {\n+    pub(crate) fn new(\n+        db: &dyn DefDatabase,\n+        current_file_id: HirFileId,\n+        krate: CrateId,\n+    ) -> CfgExpander {\n+        let hygiene = Hygiene::new(db.upcast(), current_file_id);\n+        let cfg_options = db.crate_graph()[krate].cfg_options.clone();\n+        CfgExpander { cfg_options, hygiene, krate }\n+    }\n+\n+    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n+        Attrs::filter(db, self.krate, RawAttrs::new(db.upcast(), owner, &self.hygiene))\n+    }\n+\n+    pub(crate) fn is_cfg_enabled(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> bool {\n+        let attrs = self.parse_attrs(db, owner);\n+        attrs.is_cfg_enabled(&self.cfg_options)\n+    }\n+\n+    pub(crate) fn hygiene(&self) -> &Hygiene {\n+        &self.hygiene\n+    }\n+}\n+\n+impl Expander {\n+    pub fn new(db: &dyn DefDatabase, current_file_id: HirFileId, module: ModuleId) -> Expander {\n+        let cfg_expander = CfgExpander::new(db, current_file_id, module.krate);\n+        let recursion_limit = db.recursion_limit(module.krate);\n+        #[cfg(not(test))]\n+        let recursion_limit = Limit::new(recursion_limit as usize);\n+        // Without this, `body::tests::your_stack_belongs_to_me` stack-overflows in debug\n+        #[cfg(test)]\n+        let recursion_limit = Limit::new(std::cmp::min(32, recursion_limit as usize));\n+        Expander { cfg_expander, current_file_id, module, recursion_depth: 0, recursion_limit }\n+    }\n+\n+    pub fn enter_expand<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        macro_call: ast::MacroCall,\n+        resolver: impl Fn(ModPath) -> Option<MacroId>,\n+    ) -> Result<ExpandResult<Option<(Mark, Parse<T>)>>, UnresolvedMacro> {\n+        // FIXME: within_limit should support this, instead of us having to extract the error\n+        let mut unresolved_macro_err = None;\n+\n+        let result = self.within_limit(db, |this| {\n+            let macro_call = InFile::new(this.current_file_id, &macro_call);\n+            match macro_call.as_call_id_with_errors(db.upcast(), this.module.krate(), |path| {\n+                resolver(path).map(|it| macro_id_to_def_id(db, it))\n+            }) {\n+                Ok(call_id) => call_id,\n+                Err(resolve_err) => {\n+                    unresolved_macro_err = Some(resolve_err);\n+                    ExpandResult { value: None, err: None }\n+                }\n+            }\n+        });\n+\n+        if let Some(err) = unresolved_macro_err {\n+            Err(err)\n+        } else {\n+            Ok(result)\n+        }\n+    }\n+\n+    pub fn enter_expand_id<T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        call_id: MacroCallId,\n+    ) -> ExpandResult<Option<(Mark, Parse<T>)>> {\n+        self.within_limit(db, |_this| ExpandResult::ok(Some(call_id)))\n+    }\n+\n+    fn enter_expand_inner(\n+        db: &dyn DefDatabase,\n+        call_id: MacroCallId,\n+        error: Option<ExpandError>,\n+    ) -> ExpandResult<Option<InFile<Parse<SyntaxNode>>>> {\n+        let file_id = call_id.as_file();\n+        let ExpandResult { value, err } = db.parse_or_expand_with_err(file_id);\n+\n+        ExpandResult { value: Some(InFile::new(file_id, value)), err: error.or(err) }\n+    }\n+\n+    pub fn exit(&mut self, db: &dyn DefDatabase, mut mark: Mark) {\n+        self.cfg_expander.hygiene = Hygiene::new(db.upcast(), mark.file_id);\n+        self.current_file_id = mark.file_id;\n+        if self.recursion_depth == u32::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. Reset the\n+            // depth only when we get out of the tree.\n+            if !self.current_file_id.is_macro() {\n+                self.recursion_depth = 0;\n+            }\n+        } else {\n+            self.recursion_depth -= 1;\n+        }\n+        mark.bomb.defuse();\n+    }\n+\n+    pub fn ctx<'a>(&self, db: &'a dyn DefDatabase) -> LowerCtx<'a> {\n+        LowerCtx::new(db, &self.cfg_expander.hygiene, self.current_file_id)\n+    }\n+\n+    pub(crate) fn to_source<T>(&self, value: T) -> InFile<T> {\n+        InFile { file_id: self.current_file_id, value }\n+    }\n+\n+    pub(crate) fn parse_attrs(&self, db: &dyn DefDatabase, owner: &dyn ast::HasAttrs) -> Attrs {\n+        self.cfg_expander.parse_attrs(db, owner)\n+    }\n+\n+    pub(crate) fn cfg_options(&self) -> &CfgOptions {\n+        &self.cfg_expander.cfg_options\n+    }\n+\n+    pub fn current_file_id(&self) -> HirFileId {\n+        self.current_file_id\n+    }\n+\n+    pub(crate) fn parse_path(&mut self, db: &dyn DefDatabase, path: ast::Path) -> Option<Path> {\n+        let ctx = LowerCtx::with_hygiene(db, &self.cfg_expander.hygiene);\n+        Path::from_src(path, &ctx)\n+    }\n+\n+    fn within_limit<F, T: ast::AstNode>(\n+        &mut self,\n+        db: &dyn DefDatabase,\n+        op: F,\n+    ) -> ExpandResult<Option<(Mark, Parse<T>)>>\n+    where\n+        F: FnOnce(&mut Self) -> ExpandResult<Option<MacroCallId>>,\n+    {\n+        if self.recursion_depth == u32::MAX {\n+            // Recursion limit has been reached somewhere in the macro expansion tree. We should\n+            // stop expanding other macro calls in this tree, or else this may result in\n+            // exponential number of macro expansions, leading to a hang.\n+            //\n+            // The overflow error should have been reported when it occurred (see the next branch),\n+            // so don't return overflow error here to avoid diagnostics duplication.\n+            cov_mark::hit!(overflow_but_not_me);\n+            return ExpandResult::only_err(ExpandError::RecursionOverflowPoisoned);\n+        } else if self.recursion_limit.check(self.recursion_depth as usize + 1).is_err() {\n+            self.recursion_depth = u32::MAX;\n+            cov_mark::hit!(your_stack_belongs_to_me);\n+            return ExpandResult::only_err(ExpandError::Other(\n+                \"reached recursion limit during macro expansion\".into(),\n+            ));\n+        }\n+\n+        let ExpandResult { value, err } = op(self);\n+        let Some(call_id) = value else {\n+            return ExpandResult { value: None, err };\n+        };\n+\n+        Self::enter_expand_inner(db, call_id, err).map(|value| {\n+            value.and_then(|InFile { file_id, value }| {\n+                let parse = value.cast::<T>()?;\n+\n+                self.recursion_depth += 1;\n+                self.cfg_expander.hygiene = Hygiene::new(db.upcast(), file_id);\n+                let old_file_id = std::mem::replace(&mut self.current_file_id, file_id);\n+                let mark =\n+                    Mark { file_id: old_file_id, bomb: DropBomb::new(\"expansion mark dropped\") };\n+                Some((mark, parse))\n+            })\n+        })\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct Mark {\n+    file_id: HirFileId,\n+    bomb: DropBomb,\n+}"}, {"sha": "c7668577585a10bd8a371fb90b9d6c106e7a1db9", "filename": "crates/hir-def/src/generics.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fgenerics.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -3,6 +3,8 @@\n //! generic parameters. See also the `Generics` type and the `generics_of` query\n //! in rustc.\n \n+use std::sync::Arc;\n+\n use base_db::FileId;\n use either::Either;\n use hir_expand::{\n@@ -16,10 +18,12 @@ use stdx::impl_from;\n use syntax::ast::{self, HasGenericParams, HasName, HasTypeBounds};\n \n use crate::{\n-    body::{Expander, LowerCtx},\n     child_by_source::ChildBySource,\n     db::DefDatabase,\n     dyn_map::{keys, DynMap},\n+    expander::Expander,\n+    lower::LowerCtx,\n+    nameres::DefMap,\n     src::{HasChildSource, HasSource},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n     AdtId, ConstParamId, GenericDefId, HasModule, LifetimeParamId, LocalLifetimeParamId,\n@@ -151,7 +155,6 @@ impl GenericParams {\n         def: GenericDefId,\n     ) -> Interned<GenericParams> {\n         let _p = profile::span(\"generic_params_query\");\n-\n         macro_rules! id_to_generics {\n             ($id:ident) => {{\n                 let id = $id.lookup(db).id;\n@@ -174,7 +177,9 @@ impl GenericParams {\n \n                 // Don't create an `Expander` nor call `loc.source(db)` if not needed since this\n                 // causes a reparse after the `ItemTree` has been created.\n-                let mut expander = Lazy::new(|| Expander::new(db, loc.source(db).file_id, module));\n+                let mut expander = Lazy::new(|| {\n+                    (module.def_map(db), Expander::new(db, loc.source(db).file_id, module))\n+                });\n                 for param in &func_data.params {\n                     generic_params.fill_implicit_impl_trait_args(db, &mut expander, param);\n                 }\n@@ -327,7 +332,7 @@ impl GenericParams {\n     pub(crate) fn fill_implicit_impl_trait_args(\n         &mut self,\n         db: &dyn DefDatabase,\n-        expander: &mut Expander,\n+        exp: &mut Lazy<(Arc<DefMap>, Expander), impl FnOnce() -> (Arc<DefMap>, Expander)>,\n         type_ref: &TypeRef,\n     ) {\n         type_ref.walk(&mut |type_ref| {\n@@ -347,14 +352,27 @@ impl GenericParams {\n             }\n             if let TypeRef::Macro(mc) = type_ref {\n                 let macro_call = mc.to_node(db.upcast());\n-                match expander.enter_expand::<ast::Type>(db, macro_call) {\n-                    Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n-                        let ctx = expander.ctx(db);\n-                        let type_ref = TypeRef::from_ast(&ctx, expanded.tree());\n-                        self.fill_implicit_impl_trait_args(db, expander, &type_ref);\n-                        expander.exit(db, mark);\n-                    }\n-                    _ => {}\n+                let (def_map, expander) = &mut **exp;\n+\n+                let module = expander.module.local_id;\n+                let resolver = |path| {\n+                    def_map\n+                        .resolve_path(\n+                            db,\n+                            module,\n+                            &path,\n+                            crate::item_scope::BuiltinShadowMode::Other,\n+                        )\n+                        .0\n+                        .take_macros()\n+                };\n+                if let Ok(ExpandResult { value: Some((mark, expanded)), .. }) =\n+                    expander.enter_expand(db, macro_call, resolver)\n+                {\n+                    let ctx = expander.ctx(db);\n+                    let type_ref = TypeRef::from_ast(&ctx, expanded.tree());\n+                    self.fill_implicit_impl_trait_args(db, &mut *exp, &type_ref);\n+                    exp.1.exit(db, mark);\n                 }\n             }\n         });"}, {"sha": "06e6be66baadb67a8d6c3ce83006613417be4b3b", "filename": "crates/hir-def/src/hir/type_ref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -11,9 +11,9 @@ use intern::Interned;\n use syntax::ast::{self, HasName};\n \n use crate::{\n-    body::LowerCtx,\n     builtin_type::{BuiltinInt, BuiltinType, BuiltinUint},\n     hir::Literal,\n+    lower::LowerCtx,\n     path::Path,\n };\n "}, {"sha": "0480e6a51d3138b39bb5e1ba337717bb8125c32b", "filename": "crates/hir-def/src/import_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fimport_map.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -476,7 +476,7 @@ mod tests {\n     use base_db::{fixture::WithFixture, SourceDatabase, Upcast};\n     use expect_test::{expect, Expect};\n \n-    use crate::{test_db::TestDB, ItemContainerId, Lookup};\n+    use crate::{db::DefDatabase, test_db::TestDB, ItemContainerId, Lookup};\n \n     use super::*;\n "}, {"sha": "457a519872cd7853b425888077925fdd3df617fa", "filename": "crates/hir-def/src/item_tree/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Flower.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -20,7 +20,7 @@ pub(super) struct Ctx<'a> {\n     db: &'a dyn DefDatabase,\n     tree: ItemTree,\n     source_ast_id_map: Arc<AstIdMap>,\n-    body_ctx: crate::body::LowerCtx<'a>,\n+    body_ctx: crate::lower::LowerCtx<'a>,\n }\n \n impl<'a> Ctx<'a> {\n@@ -29,7 +29,7 @@ impl<'a> Ctx<'a> {\n             db,\n             tree: ItemTree::default(),\n             source_ast_id_map: db.ast_id_map(file),\n-            body_ctx: crate::body::LowerCtx::with_file_id(db, file),\n+            body_ctx: crate::lower::LowerCtx::with_file_id(db, file),\n         }\n     }\n "}, {"sha": "b7f0e229eef26c4e384eb37c8c130e29131099ee", "filename": "crates/hir-def/src/lib.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flib.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -22,6 +22,9 @@ pub mod builtin_type;\n pub mod per_ns;\n pub mod item_scope;\n \n+pub mod lower;\n+pub mod expander;\n+\n pub mod dyn_map;\n \n pub mod item_tree;\n@@ -65,6 +68,7 @@ use hir_expand::{\n     builtin_attr_macro::BuiltinAttrExpander,\n     builtin_derive_macro::BuiltinDeriveExpander,\n     builtin_fn_macro::{BuiltinFnLikeExpander, EagerExpander},\n+    db::ExpandDatabase,\n     eager::expand_eager_macro,\n     hygiene::Hygiene,\n     proc_macro::ProcMacroExpander,\n@@ -791,7 +795,7 @@ impl AttrDefId {\n pub trait AsMacroCall {\n     fn as_call_id(\n         &self,\n-        db: &dyn db::DefDatabase,\n+        db: &dyn ExpandDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Option<MacroCallId> {\n@@ -800,7 +804,7 @@ pub trait AsMacroCall {\n \n     fn as_call_id_with_errors(\n         &self,\n-        db: &dyn db::DefDatabase,\n+        db: &dyn ExpandDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro>;\n@@ -809,15 +813,14 @@ pub trait AsMacroCall {\n impl AsMacroCall for InFile<&ast::MacroCall> {\n     fn as_call_id_with_errors(\n         &self,\n-        db: &dyn db::DefDatabase,\n+        db: &dyn ExpandDatabase,\n         krate: CrateId,\n         resolver: impl Fn(path::ModPath) -> Option<MacroDefId>,\n     ) -> Result<ExpandResult<Option<MacroCallId>>, UnresolvedMacro> {\n         let expands_to = hir_expand::ExpandTo::from_call_site(self.value);\n         let ast_id = AstId::new(self.file_id, db.ast_id_map(self.file_id).ast_id(self.value));\n-        let h = Hygiene::new(db.upcast(), self.file_id);\n-        let path =\n-            self.value.path().and_then(|path| path::ModPath::from_src(db.upcast(), path, &h));\n+        let h = Hygiene::new(db, self.file_id);\n+        let path = self.value.path().and_then(|path| path::ModPath::from_src(db, path, &h));\n \n         let Some(path) = path else {\n             return Ok(ExpandResult::only_err(ExpandError::Other(\"malformed macro invocation\".into())));\n@@ -847,7 +850,7 @@ impl<T: ast::AstNode> AstIdWithPath<T> {\n }\n \n fn macro_call_as_call_id(\n-    db: &dyn db::DefDatabase,\n+    db: &dyn ExpandDatabase,\n     call: &AstIdWithPath<ast::MacroCall>,\n     expand_to: ExpandTo,\n     krate: CrateId,\n@@ -857,7 +860,7 @@ fn macro_call_as_call_id(\n }\n \n fn macro_call_as_call_id_(\n-    db: &dyn db::DefDatabase,\n+    db: &dyn ExpandDatabase,\n     call: &AstIdWithPath<ast::MacroCall>,\n     expand_to: ExpandTo,\n     krate: CrateId,\n@@ -867,13 +870,12 @@ fn macro_call_as_call_id_(\n         resolver(call.path.clone()).ok_or_else(|| UnresolvedMacro { path: call.path.clone() })?;\n \n     let res = if let MacroDefKind::BuiltInEager(..) = def.kind {\n-        let macro_call = InFile::new(call.ast_id.file_id, call.ast_id.to_node(db.upcast()));\n-\n-        expand_eager_macro(db.upcast(), krate, macro_call, def, &resolver)?\n+        let macro_call = InFile::new(call.ast_id.file_id, call.ast_id.to_node(db));\n+        expand_eager_macro(db, krate, macro_call, def, &resolver)?\n     } else {\n         ExpandResult {\n             value: Some(def.as_lazy_macro(\n-                db.upcast(),\n+                db,\n                 krate,\n                 MacroCallKind::FnLike { ast_id: call.ast_id, expand_to },\n             )),"}, {"sha": "1991d547f5d2e0f5848e860be48b30b75b0d2b91", "filename": "crates/hir-def/src/lower.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Flower.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -0,0 +1,46 @@\n+//! Context for lowering paths.\n+use std::sync::Arc;\n+\n+use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, AstId, HirFileId, InFile};\n+use once_cell::unsync::OnceCell;\n+use syntax::ast;\n+\n+use crate::{db::DefDatabase, path::Path};\n+\n+pub struct LowerCtx<'a> {\n+    pub db: &'a dyn DefDatabase,\n+    hygiene: Hygiene,\n+    ast_id_map: Option<(HirFileId, OnceCell<Arc<AstIdMap>>)>,\n+}\n+\n+impl<'a> LowerCtx<'a> {\n+    pub fn new(db: &'a dyn DefDatabase, hygiene: &Hygiene, file_id: HirFileId) -> Self {\n+        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: Some((file_id, OnceCell::new())) }\n+    }\n+\n+    pub fn with_file_id(db: &'a dyn DefDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx {\n+            db,\n+            hygiene: Hygiene::new(db.upcast(), file_id),\n+            ast_id_map: Some((file_id, OnceCell::new())),\n+        }\n+    }\n+\n+    pub fn with_hygiene(db: &'a dyn DefDatabase, hygiene: &Hygiene) -> Self {\n+        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: None }\n+    }\n+\n+    pub(crate) fn hygiene(&self) -> &Hygiene {\n+        &self.hygiene\n+    }\n+\n+    pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n+        Path::from_src(ast, self)\n+    }\n+\n+    pub(crate) fn ast_id<N: syntax::AstNode>(&self, item: &N) -> Option<AstId<N>> {\n+        let &(file_id, ref ast_id_map) = self.ast_id_map.as_ref()?;\n+        let ast_id_map = ast_id_map.get_or_init(|| self.db.ast_id_map(file_id));\n+        Some(InFile::new(file_id, ast_id_map.ast_id(item)))\n+    }\n+}"}, {"sha": "756a8f50490b661262769ed00945ddb9a8dfbbbd", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -1111,7 +1111,7 @@ impl DefCollector<'_> {\n             match &directive.kind {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n                     let call_id = macro_call_as_call_id(\n-                        self.db,\n+                        self.db.upcast(),\n                         ast_id,\n                         *expand_to,\n                         self.def_map.krate,\n@@ -1402,7 +1402,7 @@ impl DefCollector<'_> {\n                 MacroDirectiveKind::FnLike { ast_id, expand_to } => {\n                     // FIXME: we shouldn't need to re-resolve the macro here just to get the unresolved error!\n                     let macro_call_as_call_id = macro_call_as_call_id(\n-                        self.db,\n+                        self.db.upcast(),\n                         ast_id,\n                         *expand_to,\n                         self.def_map.krate,\n@@ -2117,7 +2117,7 @@ impl ModCollector<'_, '_> {\n \n         // Case 1: try to resolve in legacy scope and expand macro_rules\n         if let Ok(res) = macro_call_as_call_id(\n-            self.def_collector.db,\n+            self.def_collector.db.upcast(),\n             &ast_id,\n             mac.expand_to,\n             self.def_collector.def_map.krate,"}, {"sha": "34fa15f9e1fa502c44d2246db29565b98e438288", "filename": "crates/hir-def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -2,7 +2,7 @@ use std::sync::Arc;\n \n use base_db::SourceDatabaseExt;\n \n-use crate::{AdtId, ModuleDefId};\n+use crate::{db::DefDatabase, AdtId, ModuleDefId};\n \n use super::*;\n "}, {"sha": "b9b8082549718cbca6417be87961447fef8e7c7e", "filename": "crates/hir-def/src/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -7,8 +7,8 @@ use std::{\n };\n \n use crate::{\n-    body::LowerCtx,\n     lang_item::LangItemTarget,\n+    lower::LowerCtx,\n     type_ref::{ConstRefOrPath, LifetimeRef, TypeBound, TypeRef},\n };\n use hir_expand::name::Name;"}, {"sha": "721f9b76804a0ebf0df50fe786ec6e22a3240d14", "filename": "crates/hir-def/src/path/lower.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpath%2Flower.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -2,17 +2,15 @@\n \n use std::iter;\n \n-use crate::type_ref::ConstRefOrPath;\n+use crate::{lower::LowerCtx, type_ref::ConstRefOrPath};\n \n use either::Either;\n use hir_expand::name::{name, AsName};\n use intern::Interned;\n use syntax::ast::{self, AstNode, HasTypeBounds};\n \n-use super::AssociatedTypeBinding;\n use crate::{\n-    body::LowerCtx,\n-    path::{GenericArg, GenericArgs, ModPath, Path, PathKind},\n+    path::{AssociatedTypeBinding, GenericArg, GenericArgs, ModPath, Path, PathKind},\n     type_ref::{LifetimeRef, TypeBound, TypeRef},\n };\n "}, {"sha": "d445abae92327636a17da03ac2f10a7c9673b7ff", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -7,7 +7,6 @@ use std::fmt::{self, Debug};\n use base_db::CrateId;\n use chalk_ir::{BoundVar, TyKind};\n use hir_def::{\n-    body,\n     data::adt::VariantData,\n     db::DefDatabase,\n     find_path,\n@@ -1552,7 +1551,10 @@ impl HirDisplay for TypeRef {\n             }\n             TypeRef::Macro(macro_call) => {\n                 let macro_call = macro_call.to_node(f.db.upcast());\n-                let ctx = body::LowerCtx::with_hygiene(f.db.upcast(), &Hygiene::new_unhygienic());\n+                let ctx = hir_def::lower::LowerCtx::with_hygiene(\n+                    f.db.upcast(),\n+                    &Hygiene::new_unhygienic(),\n+                );\n                 match macro_call.path() {\n                     Some(path) => match Path::from_src(path, &ctx) {\n                         Some(path) => path.hir_fmt(f)?,"}, {"sha": "19bb7f169f1cb04688f345e9d7768f57e0619c14", "filename": "crates/hir-ty/src/interner.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-ty%2Fsrc%2Finterner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finterner.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -43,7 +43,7 @@ impl_internable!(\n );\n \n impl chalk_ir::interner::Interner for Interner {\n-    type InternedType = Interned<InternedWrapper<chalk_ir::TyData<Interner>>>;\n+    type InternedType = Interned<InternedWrapper<chalk_ir::TyData<Self>>>;\n     type InternedLifetime = Interned<InternedWrapper<chalk_ir::LifetimeData<Self>>>;\n     type InternedConst = Interned<InternedWrapper<chalk_ir::ConstData<Self>>>;\n     type InternedConcreteConst = ConstScalar;"}, {"sha": "7da747b94979d5bef9a0a2c21e2dc84aa58b1e14", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -18,9 +18,9 @@ use chalk_ir::{\n \n use either::Either;\n use hir_def::{\n-    body::Expander,\n     builtin_type::BuiltinType,\n     data::adt::StructKind,\n+    expander::Expander,\n     generics::{\n         TypeOrConstParamData, TypeParamProvenance, WherePredicate, WherePredicateTypeTarget,\n     },\n@@ -378,7 +378,9 @@ impl<'a> TyLoweringContext<'a> {\n                 };\n                 let ty = {\n                     let macro_call = macro_call.to_node(self.db.upcast());\n-                    match expander.enter_expand::<ast::Type>(self.db.upcast(), macro_call) {\n+                    match expander.enter_expand::<ast::Type>(self.db.upcast(), macro_call, |path| {\n+                        self.resolver.resolve_path_as_macro(self.db.upcast(), &path)\n+                    }) {\n                         Ok(ExpandResult { value: Some((mark, expanded)), .. }) => {\n                             let ctx = expander.ctx(self.db.upcast());\n                             // FIXME: Report syntax errors in expansion here"}, {"sha": "a9f78131501a0a282d8c5007481aff45449a1321", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -7,8 +7,8 @@ use std::{cell::RefCell, fmt, iter, mem, ops};\n use base_db::{FileId, FileRange};\n use either::Either;\n use hir_def::{\n-    body,\n     hir::Expr,\n+    lower::LowerCtx,\n     macro_id_to_def_id,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     type_ref::Mutability,\n@@ -1065,7 +1065,7 @@ impl<'db> SemanticsImpl<'db> {\n \n     fn resolve_type(&self, ty: &ast::Type) -> Option<Type> {\n         let analyze = self.analyze(ty.syntax())?;\n-        let ctx = body::LowerCtx::with_file_id(self.db.upcast(), analyze.file_id);\n+        let ctx = LowerCtx::with_file_id(self.db.upcast(), analyze.file_id);\n         let ty = hir_ty::TyLoweringContext::new(self.db, &analyze.resolver)\n             .lower_ty(&crate::TypeRef::from_ast(&ctx, ty.clone()));\n         Some(Type::new_with_resolver(self.db, &analyze.resolver, ty))\n@@ -1074,7 +1074,7 @@ impl<'db> SemanticsImpl<'db> {\n     fn resolve_trait(&self, path: &ast::Path) -> Option<Trait> {\n         let analyze = self.analyze(path.syntax())?;\n         let hygiene = hir_expand::hygiene::Hygiene::new(self.db.upcast(), analyze.file_id);\n-        let ctx = body::LowerCtx::with_hygiene(self.db.upcast(), &hygiene);\n+        let ctx = LowerCtx::with_hygiene(self.db.upcast(), &hygiene);\n         let hir_path = Path::from_src(path.clone(), &ctx)?;\n         match analyze.resolver.resolve_path_in_type_ns_fully(self.db.upcast(), &hir_path)? {\n             TypeNs::TraitId(id) => Some(Trait { id }),\n@@ -1672,7 +1672,7 @@ impl<'a> SemanticsScope<'a> {\n     /// Resolve a path as-if it was written at the given scope. This is\n     /// necessary a heuristic, as it doesn't take hygiene into account.\n     pub fn speculative_resolve(&self, path: &ast::Path) -> Option<PathResolution> {\n-        let ctx = body::LowerCtx::with_file_id(self.db.upcast(), self.file_id);\n+        let ctx = LowerCtx::with_file_id(self.db.upcast(), self.file_id);\n         let path = Path::from_src(path.clone(), &ctx)?;\n         resolve_hir_path(self.db, &self.resolver, &path)\n     }"}, {"sha": "a6a51e4907c46db24f3201e5fc630abac896702f", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -13,12 +13,12 @@ use std::{\n use either::Either;\n use hir_def::{\n     body::{\n-        self,\n         scope::{ExprScopes, ScopeId},\n         Body, BodySourceMap,\n     },\n     hir::{ExprId, Pat, PatId},\n     lang_item::LangItem,\n+    lower::LowerCtx,\n     macro_id_to_def_id,\n     path::{ModPath, Path, PathKind},\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n@@ -463,7 +463,7 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         macro_call: InFile<&ast::MacroCall>,\n     ) -> Option<Macro> {\n-        let ctx = body::LowerCtx::with_file_id(db.upcast(), macro_call.file_id);\n+        let ctx = LowerCtx::with_file_id(db.upcast(), macro_call.file_id);\n         let path = macro_call.value.path().and_then(|ast| Path::from_src(ast, &ctx))?;\n         self.resolver.resolve_path_as_macro(db.upcast(), path.mod_path()?).map(|it| it.into())\n     }\n@@ -575,7 +575,7 @@ impl SourceAnalyzer {\n \n         // This must be a normal source file rather than macro file.\n         let hygiene = Hygiene::new(db.upcast(), self.file_id);\n-        let ctx = body::LowerCtx::with_hygiene(db.upcast(), &hygiene);\n+        let ctx = LowerCtx::with_hygiene(db.upcast(), &hygiene);\n         let hir_path = Path::from_src(path.clone(), &ctx)?;\n \n         // Case where path is a qualifier of a use tree, e.g. foo::bar::{Baz, Qux} where we are"}, {"sha": "9fb58ebe8ab8e51f29f8ec68a596e2b9c4f726dd", "filename": "crates/ide-db/src/line_index.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fide-db%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fide-db%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fline_index.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -109,6 +109,9 @@ impl LineIndex {\n             line_wide_chars.insert(line, wide_chars);\n         }\n \n+        newlines.shrink_to_fit();\n+        line_wide_chars.shrink_to_fit();\n+\n         LineIndex { newlines, line_wide_chars }\n     }\n "}, {"sha": "dcdcd17dc61d5338d62f05d3e3c3a4617df18f80", "filename": "crates/ide-db/src/symbol_index.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fide-db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Fide-db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fsymbol_index.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -93,6 +93,7 @@ impl Query {\n pub trait SymbolsDatabase: HirDatabase + SourceDatabaseExt + Upcast<dyn HirDatabase> {\n     /// The symbol index for a given module. These modules should only be in source roots that\n     /// are inside local_roots.\n+    // FIXME: We should probably LRU  this\n     fn module_symbols(&self, module: Module) -> Arc<SymbolIndex>;\n \n     /// The symbol index for a given source root within library_roots."}, {"sha": "7fb4b513a7157a1651e8bd54fc8bce41c03f2856", "filename": "crates/limit/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Flimit%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b835f334f2c61d66c8c6554ec90325992752ce3/crates%2Flimit%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flimit%2Fsrc%2Flib.rs?ref=9b835f334f2c61d66c8c6554ec90325992752ce3", "patch": "@@ -6,6 +6,7 @@\n use std::sync::atomic::AtomicUsize;\n \n /// Represents a struct used to enforce a numerical limit.\n+#[derive(Debug)]\n pub struct Limit {\n     upper_bound: usize,\n     #[cfg(feature = \"tracking\")]"}]}