{"sha": "51fe2fe07fc81e177fe9b822bc4db91e51837e45", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxZmUyZmUwN2ZjODFlMTc3ZmU5YjgyMmJjNGRiOTFlNTE4MzdlNDU=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-20T18:50:38Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-01-21T00:45:47Z"}, "message": "rustc_trans: remove an unwrap by replacing a bool with Result.", "tree": {"sha": "900598eaa3535fd08b83600f3e7667fbe8e68eed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/900598eaa3535fd08b83600f3e7667fbe8e68eed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/51fe2fe07fc81e177fe9b822bc4db91e51837e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/51fe2fe07fc81e177fe9b822bc4db91e51837e45", "html_url": "https://github.com/rust-lang/rust/commit/51fe2fe07fc81e177fe9b822bc4db91e51837e45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/51fe2fe07fc81e177fe9b822bc4db91e51837e45/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a1e2844dfea7850be5c6c901b67ceff370b0eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a1e2844dfea7850be5c6c901b67ceff370b0eb", "html_url": "https://github.com/rust-lang/rust/commit/15a1e2844dfea7850be5c6c901b67ceff370b0eb"}], "stats": {"total": 56, "additions": 30, "deletions": 26}, "files": [{"sha": "caeb1a9e2c362753ec648347efe732bbd30db799", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/51fe2fe07fc81e177fe9b822bc4db91e51837e45/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51fe2fe07fc81e177fe9b822bc4db91e51837e45/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=51fe2fe07fc81e177fe9b822bc4db91e51837e45", "patch": "@@ -194,44 +194,48 @@ pub fn compute_abi_info<'a, 'tcx>(cx: &CodegenCx<'a, 'tcx>, fty: &mut FnType<'tc\n     let mut sse_regs = 8; // XMM0-7\n \n     let mut x86_64_ty = |arg: &mut ArgType<'tcx>, is_arg: bool| {\n-        let cls = classify_arg(cx, arg);\n+        let mut cls_or_mem = classify_arg(cx, arg);\n \n         let mut needed_int = 0;\n         let mut needed_sse = 0;\n-        let in_mem = match cls {\n-            Err(Memory) => true,\n-            Ok(ref cls) if is_arg => {\n-                for &c in cls {\n+        if is_arg {\n+            if let Ok(cls) = cls_or_mem {\n+                for &c in &cls {\n                     match c {\n                         Class::Int => needed_int += 1,\n                         Class::Sse => needed_sse += 1,\n                         _ => {}\n                     }\n                 }\n-                arg.layout.is_aggregate() &&\n-                    (int_regs < needed_int || sse_regs < needed_sse)\n+                if arg.layout.is_aggregate() {\n+                    if int_regs < needed_int || sse_regs < needed_sse {\n+                        cls_or_mem = Err(Memory);\n+                    }\n+                }\n             }\n-            Ok(_) => false\n-        };\n+        }\n \n-        if in_mem {\n-            if is_arg {\n-                arg.make_indirect_byval();\n-            } else {\n-                // `sret` parameter thus one less integer register available\n-                arg.make_indirect();\n-                int_regs -= 1;\n+        match cls_or_mem {\n+            Err(Memory) => {\n+                if is_arg {\n+                    arg.make_indirect_byval();\n+                } else {\n+                    // `sret` parameter thus one less integer register available\n+                    arg.make_indirect();\n+                    int_regs -= 1;\n+                }\n             }\n-        } else {\n-            // split into sized chunks passed individually\n-            int_regs -= needed_int;\n-            sse_regs -= needed_sse;\n-\n-            if arg.layout.is_aggregate() {\n-                let size = arg.layout.size;\n-                arg.cast_to(cast_target(cls.as_ref().unwrap(), size))\n-            } else {\n-                arg.extend_integer_width_to(32);\n+            Ok(ref cls) => {\n+                // split into sized chunks passed individually\n+                int_regs -= needed_int;\n+                sse_regs -= needed_sse;\n+\n+                if arg.layout.is_aggregate() {\n+                    let size = arg.layout.size;\n+                    arg.cast_to(cast_target(cls, size))\n+                } else {\n+                    arg.extend_integer_width_to(32);\n+                }\n             }\n         }\n     };"}]}