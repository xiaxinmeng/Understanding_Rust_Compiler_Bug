{"sha": "cae164753f557f668cb75610abda4f790981e5e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZTE2NDc1M2Y1NTdmNjY4Y2I3NTYxMGFiZGE0Zjc5MDk4MWU1ZTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-01T15:26:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-01T15:26:12Z"}, "message": "Auto merge of #55937 - davidtwco:issue-54943, r=pnkfelix\n\nNLL: User type annotations refactor, associated constant patterns and ref bindings.\n\nFixes #55511 and Fixes #55401. Contributes to #54943.\n\nThis PR performs a large refactoring on user type annotations, checks user type annotations for associated constants in patterns and that user type annotations for `ref` bindings are respected.\n\nr? @nikomatsakis", "tree": {"sha": "515bcca8a0e1239da5a7358488826f136d4d4d31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/515bcca8a0e1239da5a7358488826f136d4d4d31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cae164753f557f668cb75610abda4f790981e5e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cae164753f557f668cb75610abda4f790981e5e6", "html_url": "https://github.com/rust-lang/rust/commit/cae164753f557f668cb75610abda4f790981e5e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cae164753f557f668cb75610abda4f790981e5e6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36500deb1a276e47e9780876c136e8ceea46a860", "url": "https://api.github.com/repos/rust-lang/rust/commits/36500deb1a276e47e9780876c136e8ceea46a860", "html_url": "https://github.com/rust-lang/rust/commit/36500deb1a276e47e9780876c136e8ceea46a860"}, {"sha": "c20ba65a0b3142bbd88031fbf6eb7ef46bc1f7b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/c20ba65a0b3142bbd88031fbf6eb7ef46bc1f7b3", "html_url": "https://github.com/rust-lang/rust/commit/c20ba65a0b3142bbd88031fbf6eb7ef46bc1f7b3"}], "stats": {"total": 1304, "additions": 804, "deletions": 500}, "files": [{"sha": "002ac7cc7a9bba8dac6908b9daa4e7573d243068", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -494,22 +494,5 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::ClosureOutlivesSubj\n \n impl_stable_hash_for!(struct mir::interpret::GlobalId<'tcx> { instance, promoted });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::UserTypeAnnotation<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            mir::UserTypeAnnotation::Ty(ref ty) => {\n-                ty.hash_stable(hcx, hasher);\n-            }\n-            mir::UserTypeAnnotation::TypeOf(ref def_id, ref substs) => {\n-                def_id.hash_stable(hcx, hasher);\n-                substs.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n-\n impl_stable_hash_for!(struct mir::UserTypeProjection<'tcx> { base, projs });\n impl_stable_hash_for!(struct mir::UserTypeProjections<'tcx> { contents });"}, {"sha": "b2fe4b7561c5a74cf76724178dc07c3510350012", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -1251,3 +1251,29 @@ impl_stable_hash_for!(\n         goal,\n     }\n );\n+\n+impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::UserTypeAnnotation<'gcx> {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            ty::UserTypeAnnotation::Ty(ref ty) => {\n+                ty.hash_stable(hcx, hasher);\n+            }\n+            ty::UserTypeAnnotation::TypeOf(ref def_id, ref substs) => {\n+                def_id.hash_stable(hcx, hasher);\n+                substs.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for ty::UserTypeAnnotationIndex {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a>,\n+                                          hasher: &mut StableHasher<W>) {\n+        self.index().hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "2936405ebd0b79a325db5cf62daff9f988c4cc09", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 92, "deletions": 33, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -27,9 +27,12 @@ use syntax::ast::{self, Name};\n use syntax::symbol::InternedString;\n use syntax_pos::{Span, DUMMY_SP};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use ty::subst::{CanonicalUserSubsts, Subst, Substs};\n-use ty::{self, AdtDef, CanonicalTy, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt};\n+use ty::subst::{Subst, Substs};\n use ty::layout::VariantIdx;\n+use ty::{\n+    self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n+    UserTypeAnnotationIndex, UserTypeAnnotation,\n+};\n use util::ppaux;\n \n pub use mir::interpret::AssertMessage;\n@@ -121,6 +124,9 @@ pub struct Mir<'tcx> {\n     /// variables and temporaries.\n     pub local_decls: LocalDecls<'tcx>,\n \n+    /// User type annotations\n+    pub user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n+\n     /// Number of arguments this function takes.\n     ///\n     /// Starting at local 1, `arg_count` locals will be provided by the caller\n@@ -161,7 +167,8 @@ impl<'tcx> Mir<'tcx> {\n         source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n         promoted: IndexVec<Promoted, Mir<'tcx>>,\n         yield_ty: Option<Ty<'tcx>>,\n-        local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+        local_decls: LocalDecls<'tcx>,\n+        user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n         arg_count: usize,\n         upvar_decls: Vec<UpvarDecl>,\n         span: Span,\n@@ -185,6 +192,7 @@ impl<'tcx> Mir<'tcx> {\n             generator_drop: None,\n             generator_layout: None,\n             local_decls,\n+            user_type_annotations,\n             arg_count,\n             upvar_decls,\n             spread_arg: None,\n@@ -418,6 +426,7 @@ impl_stable_hash_for!(struct Mir<'tcx> {\n     generator_drop,\n     generator_layout,\n     local_decls,\n+    user_type_annotations,\n     arg_count,\n     upvar_decls,\n     spread_arg,\n@@ -2232,7 +2241,7 @@ pub enum AggregateKind<'tcx> {\n         &'tcx AdtDef,\n         VariantIdx,\n         &'tcx Substs<'tcx>,\n-        Option<UserTypeAnnotation<'tcx>>,\n+        Option<UserTypeAnnotationIndex>,\n         Option<usize>,\n     ),\n \n@@ -2446,38 +2455,11 @@ pub struct Constant<'tcx> {\n     /// indicate that `Vec<_>` was explicitly specified.\n     ///\n     /// Needed for NLL to impose user-given type constraints.\n-    pub user_ty: Option<UserTypeAnnotation<'tcx>>,\n+    pub user_ty: Option<UserTypeAnnotationIndex>,\n \n     pub literal: &'tcx ty::Const<'tcx>,\n }\n \n-/// A user-given type annotation attached to a constant.  These arise\n-/// from constants that are named via paths, like `Foo::<A>::new` and\n-/// so forth.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub enum UserTypeAnnotation<'tcx> {\n-    Ty(CanonicalTy<'tcx>),\n-\n-    /// The canonical type is the result of `type_of(def_id)` with the\n-    /// given substitutions applied.\n-    TypeOf(DefId, CanonicalUserSubsts<'tcx>),\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx> TypeFoldable<'tcx> for UserTypeAnnotation<'tcx> {\n-        (UserTypeAnnotation::Ty)(ty),\n-        (UserTypeAnnotation::TypeOf)(def, substs),\n-    }\n-}\n-\n-EnumLiftImpl! {\n-    impl<'a, 'tcx> Lift<'tcx> for UserTypeAnnotation<'a> {\n-        type Lifted = UserTypeAnnotation<'tcx>;\n-        (UserTypeAnnotation::Ty)(ty),\n-        (UserTypeAnnotation::TypeOf)(def, substs),\n-    }\n-}\n-\n /// A collection of projections into user types.\n ///\n /// They are projections because a binding can occur a part of a\n@@ -2537,6 +2519,48 @@ impl<'tcx> UserTypeProjections<'tcx> {\n     pub fn projections(&self) -> impl Iterator<Item=&UserTypeProjection<'tcx>> {\n         self.contents.iter().map(|&(ref user_type, _span)| user_type)\n     }\n+\n+    pub fn push_projection(\n+        mut self,\n+        user_ty: &UserTypeProjection<'tcx>,\n+        span: Span,\n+    ) -> Self {\n+        self.contents.push((user_ty.clone(), span));\n+        self\n+    }\n+\n+    fn map_projections(\n+        mut self,\n+        mut f: impl FnMut(UserTypeProjection<'tcx>) -> UserTypeProjection<'tcx>\n+    ) -> Self {\n+        self.contents = self.contents.drain(..).map(|(proj, span)| (f(proj), span)).collect();\n+        self\n+    }\n+\n+    pub fn index(self) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.index())\n+    }\n+\n+    pub fn subslice(self, from: u32, to: u32) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.subslice(from, to))\n+    }\n+\n+    pub fn deref(self) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.deref())\n+    }\n+\n+    pub fn leaf(self, field: Field) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.leaf(field))\n+    }\n+\n+    pub fn variant(\n+        self,\n+        adt_def: &'tcx AdtDef,\n+        variant_index: VariantIdx,\n+        field: Field,\n+    ) -> Self {\n+        self.map_projections(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n+    }\n }\n \n /// Encodes the effect of a user-supplied type annotation on the\n@@ -2556,12 +2580,45 @@ impl<'tcx> UserTypeProjections<'tcx> {\n ///   determined by finding the type of the `.0` field from `T`.\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UserTypeProjection<'tcx> {\n-    pub base: UserTypeAnnotation<'tcx>,\n+    pub base: UserTypeAnnotationIndex,\n     pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n }\n \n impl<'tcx> Copy for ProjectionKind<'tcx> { }\n \n+impl<'tcx> UserTypeProjection<'tcx> {\n+    pub(crate) fn index(mut self) -> Self {\n+        self.projs.push(ProjectionElem::Index(()));\n+        self\n+    }\n+\n+    pub(crate) fn subslice(mut self, from: u32, to: u32) -> Self {\n+        self.projs.push(ProjectionElem::Subslice { from, to });\n+        self\n+    }\n+\n+    pub(crate) fn deref(mut self) -> Self {\n+        self.projs.push(ProjectionElem::Deref);\n+        self\n+    }\n+\n+    pub(crate) fn leaf(mut self, field: Field) -> Self {\n+        self.projs.push(ProjectionElem::Field(field, ()));\n+        self\n+    }\n+\n+    pub(crate) fn variant(\n+        mut self,\n+        adt_def: &'tcx AdtDef,\n+        variant_index: VariantIdx,\n+        field: Field,\n+    ) -> Self {\n+        self.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n+        self.projs.push(ProjectionElem::Field(field, ()));\n+        self\n+    }\n+}\n+\n CloneTypeFoldableAndLiftImpls! { ProjectionKind<'tcx>, }\n \n impl<'tcx> TypeFoldable<'tcx> for UserTypeProjection<'tcx> {\n@@ -2970,6 +3027,7 @@ CloneTypeFoldableAndLiftImpls! {\n     SourceScope,\n     SourceScopeData,\n     SourceScopeLocalData,\n+    UserTypeAnnotationIndex,\n }\n \n BraceStructTypeFoldableImpl! {\n@@ -2983,6 +3041,7 @@ BraceStructTypeFoldableImpl! {\n         generator_drop,\n         generator_layout,\n         local_decls,\n+        user_type_annotations,\n         arg_count,\n         upvar_decls,\n         spread_arg,"}, {"sha": "67f85fbc8679ee133c2bd54722dea3c26807951c", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -1,4 +1,5 @@\n use hir::def_id::DefId;\n+use infer::canonical::Canonical;\n use ty::subst::Substs;\n use ty::{ClosureSubsts, GeneratorSubsts, Region, Ty};\n use mir::*;\n@@ -219,9 +220,10 @@ macro_rules! make_mir_visitor {\n \n             fn visit_user_type_annotation(\n                 &mut self,\n-                ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n+                index: UserTypeAnnotationIndex,\n+                ty: & $($mutability)* Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n             ) {\n-                self.super_user_type_annotation(ty);\n+                self.super_user_type_annotation(index, ty);\n             }\n \n             fn visit_region(&mut self,\n@@ -307,6 +309,14 @@ macro_rules! make_mir_visitor {\n                     self.visit_local_decl(local, & $($mutability)* mir.local_decls[local]);\n                 }\n \n+                for index in mir.user_type_annotations.indices() {\n+                    let (span, annotation) = & $($mutability)* mir.user_type_annotations[index];\n+                    self.visit_user_type_annotation(\n+                        index, annotation\n+                    );\n+                    self.visit_span(span);\n+                }\n+\n                 self.visit_span(&$($mutability)* mir.span);\n             }\n \n@@ -865,18 +875,14 @@ macro_rules! make_mir_visitor {\n \n             fn super_user_type_projection(\n                 &mut self,\n-                ty: & $($mutability)* UserTypeProjection<'tcx>,\n+                _ty: & $($mutability)* UserTypeProjection<'tcx>,\n             ) {\n-                let UserTypeProjection {\n-                    ref $($mutability)* base,\n-                    projs: _, // Note: Does not visit projection elems!\n-                } = *ty;\n-                self.visit_user_type_annotation(base);\n             }\n \n             fn super_user_type_annotation(\n                 &mut self,\n-                _ty: & $($mutability)* UserTypeAnnotation<'tcx>,\n+                _index: UserTypeAnnotationIndex,\n+                _ty: & $($mutability)* Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n             ) {\n             }\n "}, {"sha": "b2f30564de93a5d387a7fe19a666d892df02691b", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -22,7 +22,7 @@ impl<'tcx> AscribeUserType<'tcx> {\n         user_substs: UserSubsts<'tcx>,\n         projs: &'tcx ty::List<ProjectionKind<'tcx>>,\n     ) -> Self {\n-        AscribeUserType { mir_ty, variance, def_id, user_substs, projs }\n+        Self { mir_ty, variance, def_id, user_substs, projs }\n     }\n }\n "}, {"sha": "32348e2e5046dbc6027f033996919435b723b20f", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 104, "deletions": 42, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -14,7 +14,7 @@ use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{StableHashingContext, NodeIdHashingMode};\n-use infer::canonical::{CanonicalVarInfo, CanonicalVarInfos};\n+use infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use infer::outlives::free_region_map::FreeRegionMap;\n use middle::cstore::CrateStoreDyn;\n use middle::cstore::EncodedMetadata;\n@@ -23,7 +23,7 @@ use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;\n use mir::{self, Mir, interpret, ProjectionKind};\n use mir::interpret::Allocation;\n-use ty::subst::{CanonicalUserSubsts, Kind, Substs, Subst};\n+use ty::subst::{Kind, Substs, Subst};\n use ty::ReprOptions;\n use traits;\n use traits::{Clause, Clauses, GoalKind, Goal, Goals};\n@@ -38,8 +38,8 @@ use ty::GenericParamDefKind;\n use ty::layout::{LayoutDetails, TargetDataLayout, VariantIdx};\n use ty::query;\n use ty::steal::Steal;\n-use ty::BindingMode;\n-use ty::CanonicalTy;\n+use ty::subst::{UserSubsts, UnpackedKind};\n+use ty::{BoundVar, BindingMode};\n use ty::CanonicalPolyFnSig;\n use util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n@@ -49,7 +49,7 @@ use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n                                            StableVec};\n use arena::{TypedArena, SyncDroplessArena};\n-use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use rustc_data_structures::sync::{self, Lrc, Lock, WorkerLocal};\n use std::any::Any;\n use std::borrow::Borrow;\n@@ -342,26 +342,21 @@ pub struct TypeckTables<'tcx> {\n     /// other items.\n     node_substs: ItemLocalMap<&'tcx Substs<'tcx>>,\n \n-    /// Stores the canonicalized types provided by the user. See also\n-    /// `AscribeUserType` statement in MIR.\n-    user_provided_tys: ItemLocalMap<CanonicalTy<'tcx>>,\n+    /// This will either store the canonicalized types provided by the user\n+    /// or the substitutions that the user explicitly gave (if any) attached\n+    /// to `id`. These will not include any inferred values. The canonical form\n+    /// is used to capture things like `_` or other unspecified values.\n+    ///\n+    /// For example, if the user wrote `foo.collect::<Vec<_>>()`, then the\n+    /// canonical substitutions would include only `for<X> { Vec<X> }`.\n+    ///\n+    /// See also `AscribeUserType` statement in MIR.\n+    user_provided_types: ItemLocalMap<CanonicalUserTypeAnnotation<'tcx>>,\n \n     /// Stores the canonicalized types provided by the user. See also\n     /// `AscribeUserType` statement in MIR.\n     pub user_provided_sigs: DefIdMap<CanonicalPolyFnSig<'tcx>>,\n \n-    /// Stores the substitutions that the user explicitly gave (if any)\n-    /// attached to `id`. These will not include any inferred\n-    /// values. The canonical form is used to capture things like `_`\n-    /// or other unspecified values.\n-    ///\n-    /// Example:\n-    ///\n-    /// If the user wrote `foo.collect::<Vec<_>>()`, then the\n-    /// canonical substitutions would include only `for<X> { Vec<X>\n-    /// }`.\n-    user_substs: ItemLocalMap<CanonicalUserSubsts<'tcx>>,\n-\n     adjustments: ItemLocalMap<Vec<ty::adjustment::Adjustment<'tcx>>>,\n \n     /// Stores the actual binding mode for all instances of hir::BindingAnnotation.\n@@ -432,11 +427,10 @@ impl<'tcx> TypeckTables<'tcx> {\n             local_id_root,\n             type_dependent_defs: Default::default(),\n             field_indices: Default::default(),\n-            user_provided_tys: Default::default(),\n+            user_provided_types: Default::default(),\n             user_provided_sigs: Default::default(),\n             node_types: Default::default(),\n             node_substs: Default::default(),\n-            user_substs: Default::default(),\n             adjustments: Default::default(),\n             pat_binding_modes: Default::default(),\n             pat_adjustments: Default::default(),\n@@ -491,17 +485,21 @@ impl<'tcx> TypeckTables<'tcx> {\n         }\n     }\n \n-    pub fn user_provided_tys(&self) -> LocalTableInContext<'_, CanonicalTy<'tcx>> {\n+    pub fn user_provided_types(\n+        &self\n+    ) -> LocalTableInContext<'_, CanonicalUserTypeAnnotation<'tcx>> {\n         LocalTableInContext {\n             local_id_root: self.local_id_root,\n-            data: &self.user_provided_tys\n+            data: &self.user_provided_types\n         }\n     }\n \n-    pub fn user_provided_tys_mut(&mut self) -> LocalTableInContextMut<'_, CanonicalTy<'tcx>> {\n+    pub fn user_provided_types_mut(\n+        &mut self\n+    ) -> LocalTableInContextMut<'_, CanonicalUserTypeAnnotation<'tcx>> {\n         LocalTableInContextMut {\n             local_id_root: self.local_id_root,\n-            data: &mut self.user_provided_tys\n+            data: &mut self.user_provided_types\n         }\n     }\n \n@@ -551,18 +549,6 @@ impl<'tcx> TypeckTables<'tcx> {\n         self.node_substs.get(&id.local_id).cloned()\n     }\n \n-    pub fn user_substs_mut(&mut self) -> LocalTableInContextMut<'_, CanonicalUserSubsts<'tcx>> {\n-        LocalTableInContextMut {\n-            local_id_root: self.local_id_root,\n-            data: &mut self.user_substs\n-        }\n-    }\n-\n-    pub fn user_substs(&self, id: hir::HirId) -> Option<CanonicalUserSubsts<'tcx>> {\n-        validate_hir_id_for_typeck_tables(self.local_id_root, id, false);\n-        self.user_substs.get(&id.local_id).cloned()\n-    }\n-\n     // Returns the type of a pattern as a monotype. Like @expr_ty, this function\n     // doesn't provide type parameter substitutions.\n     pub fn pat_ty(&self, pat: &hir::Pat) -> Ty<'tcx> {\n@@ -739,11 +725,10 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n             local_id_root,\n             ref type_dependent_defs,\n             ref field_indices,\n-            ref user_provided_tys,\n+            ref user_provided_types,\n             ref user_provided_sigs,\n             ref node_types,\n             ref node_substs,\n-            ref user_substs,\n             ref adjustments,\n             ref pat_binding_modes,\n             ref pat_adjustments,\n@@ -763,11 +748,10 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n             type_dependent_defs.hash_stable(hcx, hasher);\n             field_indices.hash_stable(hcx, hasher);\n-            user_provided_tys.hash_stable(hcx, hasher);\n+            user_provided_types.hash_stable(hcx, hasher);\n             user_provided_sigs.hash_stable(hcx, hasher);\n             node_types.hash_stable(hcx, hasher);\n             node_substs.hash_stable(hcx, hasher);\n-            user_substs.hash_stable(hcx, hasher);\n             adjustments.hash_stable(hcx, hasher);\n             pat_binding_modes.hash_stable(hcx, hasher);\n             pat_adjustments.hash_stable(hcx, hasher);\n@@ -805,6 +789,84 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for TypeckTables<'gcx> {\n     }\n }\n \n+newtype_index! {\n+    pub struct UserTypeAnnotationIndex {\n+        DEBUG_FORMAT = \"UserTypeAnnotation({})\",\n+        const START_INDEX = 0,\n+    }\n+}\n+\n+/// Mapping of type annotation indices to canonical user type annotations.\n+pub type CanonicalUserTypeAnnotations<'tcx> =\n+    IndexVec<UserTypeAnnotationIndex, (Span, CanonicalUserTypeAnnotation<'tcx>)>;\n+\n+/// Canonicalized user type annotation.\n+pub type CanonicalUserTypeAnnotation<'gcx> = Canonical<'gcx, UserTypeAnnotation<'gcx>>;\n+\n+impl CanonicalUserTypeAnnotation<'gcx> {\n+    /// Returns `true` if this represents a substitution of the form `[?0, ?1, ?2]`,\n+    /// i.e. each thing is mapped to a canonical variable with the same index.\n+    pub fn is_identity(&self) -> bool {\n+        match self.value {\n+            UserTypeAnnotation::Ty(_) => false,\n+            UserTypeAnnotation::TypeOf(_, user_substs) => {\n+                if user_substs.user_self_ty.is_some() {\n+                    return false;\n+                }\n+\n+                user_substs.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n+                    match kind.unpack() {\n+                        UnpackedKind::Type(ty) => match ty.sty {\n+                            ty::Bound(debruijn, b) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(debruijn, ty::INNERMOST);\n+                                cvar == b.var\n+                            }\n+                            _ => false,\n+                        },\n+\n+                        UnpackedKind::Lifetime(r) => match r {\n+                            ty::ReLateBound(debruijn, br) => {\n+                                // We only allow a `ty::INNERMOST` index in substitutions.\n+                                assert_eq!(*debruijn, ty::INNERMOST);\n+                                cvar == br.assert_bound_var()\n+                            }\n+                            _ => false,\n+                        },\n+                    }\n+                })\n+            },\n+        }\n+    }\n+}\n+\n+/// A user-given type annotation attached to a constant.  These arise\n+/// from constants that are named via paths, like `Foo::<A>::new` and\n+/// so forth.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n+pub enum UserTypeAnnotation<'tcx> {\n+    Ty(Ty<'tcx>),\n+\n+    /// The canonical type is the result of `type_of(def_id)` with the\n+    /// given substitutions applied.\n+    TypeOf(DefId, UserSubsts<'tcx>),\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for UserTypeAnnotation<'tcx> {\n+        (UserTypeAnnotation::Ty)(ty),\n+        (UserTypeAnnotation::TypeOf)(def, substs),\n+    }\n+}\n+\n+EnumLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for UserTypeAnnotation<'a> {\n+        type Lifted = UserTypeAnnotation<'tcx>;\n+        (UserTypeAnnotation::Ty)(ty),\n+        (UserTypeAnnotation::TypeOf)(def, substs),\n+    }\n+}\n+\n impl<'tcx> CommonTypes<'tcx> {\n     fn new(interners: &CtxtInterners<'tcx>) -> CommonTypes<'tcx> {\n         let mk = |sty| CtxtInterners::intern_ty(interners, interners, sty);"}, {"sha": "d40dd830e9fb930f0182de08f52e668a454ded19", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -73,6 +73,10 @@ pub use self::binding::BindingMode::*;\n \n pub use self::context::{TyCtxt, FreeRegionInfo, GlobalArenas, AllArenas, tls, keep_local};\n pub use self::context::{Lift, TypeckTables, CtxtInterners};\n+pub use self::context::{\n+    UserTypeAnnotationIndex, UserTypeAnnotation, CanonicalUserTypeAnnotation,\n+    CanonicalUserTypeAnnotations,\n+};\n \n pub use self::instance::{Instance, InstanceDef};\n "}, {"sha": "842aea07614ddb0bc3d745e364cb50ba6ed55289", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -26,8 +26,8 @@ use session::config::OutputFilenames;\n use traits::{self, Vtable};\n use traits::query::{\n     CanonicalPredicateGoal, CanonicalProjectionGoal,\n-    CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal, CanonicalTypeOpEqGoal,\n-    CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n+    CanonicalTyGoal, CanonicalTypeOpAscribeUserTypeGoal,\n+    CanonicalTypeOpEqGoal, CanonicalTypeOpSubtypeGoal, CanonicalTypeOpProvePredicateGoal,\n     CanonicalTypeOpNormalizeGoal, NoSolution,\n };\n use traits::query::method_autoderef::MethodAutoderefStepsResult;"}, {"sha": "64e7af815b4bf93afc8da858cc5556effdec894e", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -2,12 +2,11 @@\n \n use hir::def_id::DefId;\n use infer::canonical::Canonical;\n-use ty::{self, BoundVar, Lift, List, Ty, TyCtxt};\n+use ty::{self, Lift, List, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc_data_structures::indexed_vec::Idx;\n use smallvec::SmallVec;\n \n use core::intrinsics;\n@@ -559,43 +558,6 @@ impl<'a, 'gcx, 'tcx> SubstFolder<'a, 'gcx, 'tcx> {\n \n pub type CanonicalUserSubsts<'tcx> = Canonical<'tcx, UserSubsts<'tcx>>;\n \n-impl CanonicalUserSubsts<'tcx> {\n-    /// True if this represents a substitution like\n-    ///\n-    /// ```text\n-    /// [?0, ?1, ?2]\n-    /// ```\n-    ///\n-    /// i.e., each thing is mapped to a canonical variable with the same index.\n-    pub fn is_identity(&self) -> bool {\n-        if self.value.user_self_ty.is_some() {\n-            return false;\n-        }\n-\n-        self.value.substs.iter().zip(BoundVar::new(0)..).all(|(kind, cvar)| {\n-            match kind.unpack() {\n-                UnpackedKind::Type(ty) => match ty.sty {\n-                    ty::Bound(debruijn, b) => {\n-                        // We only allow a `ty::INNERMOST` index in substitutions.\n-                        assert_eq!(debruijn, ty::INNERMOST);\n-                        cvar == b.var\n-                    }\n-                    _ => false,\n-                },\n-\n-                UnpackedKind::Lifetime(r) => match r {\n-                    ty::ReLateBound(debruijn, br) => {\n-                        // We only allow a `ty::INNERMOST` index in substitutions.\n-                        assert_eq!(*debruijn, ty::INNERMOST);\n-                        cvar == br.assert_bound_var()\n-                    }\n-                    _ => false,\n-                },\n-            }\n-        })\n-    }\n-}\n-\n /// Stores the user-given substs to reach some fully qualified path\n /// (e.g., `<T>::Item` or `<T as Trait>::Item`).\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]"}, {"sha": "aacc63c47de61fefd7d546eb0204e988e2508823", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -289,6 +289,11 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     self.out.extend(obligations);\n                 }\n \n+                ty::FnDef(did, substs) => {\n+                    let obligations = self.nominal_obligations(did, substs);\n+                    self.out.extend(obligations);\n+                }\n+\n                 ty::Ref(r, rty, _) => {\n                     // WfReference\n                     if !r.has_escaping_bound_vars() && !rty.has_escaping_bound_vars() {\n@@ -349,7 +354,7 @@ impl<'a, 'gcx, 'tcx> WfPredicates<'a, 'gcx, 'tcx> {\n                     }\n                 }\n \n-                ty::FnDef(..) | ty::FnPtr(_) => {\n+                ty::FnPtr(_) => {\n                     // let the loop iterate into the argument/return\n                     // types appearing in the fn signature\n                 }"}, {"sha": "a092c3b8ecde2c5671874d7ad4f67835a50f8eed", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -230,13 +230,14 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n                 // Before the CFG, dump out the values for each region variable.\n                 PassWhere::BeforeCFG => {\n                     regioncx.dump_mir(out)?;\n+                    writeln!(out, \"|\")?;\n \n                     if let Some(closure_region_requirements) = closure_region_requirements {\n-                        writeln!(out, \"|\")?;\n                         writeln!(out, \"| Free Region Constraints\")?;\n                         for_each_region_constraint(closure_region_requirements, &mut |msg| {\n                             writeln!(out, \"| {}\", msg)\n                         })?;\n+                        writeln!(out, \"|\")?;\n                     }\n                 }\n "}, {"sha": "55af7399aab8f311a97a2e970c690f975a3e7f9e", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -1,6 +1,10 @@\n+use rustc::infer::canonical::Canonical;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable};\n-use rustc::mir::{Location, Mir, UserTypeAnnotation};\n+use rustc::ty::{\n+    self, ClosureSubsts, GeneratorSubsts, Ty, TypeFoldable, UserTypeAnnotation,\n+    UserTypeAnnotationIndex,\n+};\n+use rustc::mir::{Location, Mir};\n use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n@@ -55,7 +59,11 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n         debug!(\"visit_ty: ty={:?}\", ty);\n     }\n \n-    fn visit_user_type_annotation(&mut self, _ty: &mut UserTypeAnnotation<'tcx>) {\n+    fn visit_user_type_annotation(\n+        &mut self,\n+        _index: UserTypeAnnotationIndex,\n+        _ty: &mut Canonical<'tcx, UserTypeAnnotation<'tcx>>,\n+    ) {\n         // User type annotations represent the types that the user\n         // wrote in the progarm. We don't want to erase the regions\n         // from these types: rather, we want to add them as"}, {"sha": "796a2f79f7554ceb119d7d2b6ad7e77da2c8d804", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 75, "deletions": 28, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -36,7 +36,10 @@ use rustc::traits::query::{Fallible, NoSolution};\n use rustc::traits::{ObligationCause, PredicateObligations};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::subst::{Subst, Substs, UnpackedKind};\n-use rustc::ty::{self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind};\n+use rustc::ty::{\n+    self, RegionVid, ToPolyTraitRef, Ty, TyCtxt, TyKind, UserTypeAnnotation,\n+    UserTypeAnnotationIndex,\n+};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc::ty::layout::VariantIdx;\n@@ -272,19 +275,20 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.sanitize_constant(constant, location);\n         self.sanitize_type(constant, constant.ty);\n \n-        if let Some(user_ty) = constant.user_ty {\n+        if let Some(annotation_index) = constant.user_ty {\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n                 constant.ty,\n                 ty::Variance::Invariant,\n-                &UserTypeProjection { base: user_ty, projs: vec![], },\n+                &UserTypeProjection { base: annotation_index, projs: vec![], },\n                 location.to_locations(),\n                 ConstraintCategory::Boring,\n             ) {\n+                let annotation = self.cx.instantiated_type_annotations[&annotation_index];\n                 span_mirbug!(\n                     self,\n                     constant,\n                     \"bad constant user type {:?} vs {:?}: {:?}\",\n-                    user_ty,\n+                    annotation,\n                     constant.ty,\n                     terr,\n                 );\n@@ -303,8 +307,20 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         self.sanitize_type(local_decl, local_decl.ty);\n \n         for (user_ty, span) in local_decl.user_ty.projections_and_spans() {\n+            let ty = if !local_decl.is_nonref_binding() {\n+                // If we have a binding of the form `let ref x: T = ..` then remove the outermost\n+                // reference so we can check the type annotation for the remaining type.\n+                if let ty::Ref(_, rty, _) = local_decl.ty.sty {\n+                    rty\n+                } else {\n+                    bug!(\"{:?} with ref binding has wrong type {}\", local, local_decl.ty);\n+                }\n+            } else {\n+                local_decl.ty\n+            };\n+\n             if let Err(terr) = self.cx.relate_type_and_user_type(\n-                local_decl.ty,\n+                ty,\n                 ty::Variance::Invariant,\n                 user_ty,\n                 Locations::All(*span),\n@@ -715,6 +731,15 @@ struct TypeChecker<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     reported_errors: FxHashSet<(Ty<'tcx>, Span)>,\n     borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n     universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n+    /// For each user-type annotation (identified by a UserTypeAnnotationIndex), we create\n+    /// an \"instantiated\" version at the beginning of type check, which replaces each\n+    /// canonical variable with a fresh inference variable. These instantiated versions are\n+    /// stored either in this field or in user_substs, depending on the kind of user-type\n+    /// annotation. They are then referenced by the code which has the job of enforcing these\n+    /// annotations. Part of the reason for this setup is that it allows us to enforce basic\n+    /// WF criteria on the types even if the code that referenced them is dead\n+    /// code (see #54943).\n+    instantiated_type_annotations: FxHashMap<UserTypeAnnotationIndex, UserTypeAnnotation<'tcx>>,\n }\n \n struct BorrowCheckContext<'a, 'tcx: 'a> {\n@@ -860,7 +885,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         borrowck_context: Option<&'a mut BorrowCheckContext<'a, 'tcx>>,\n         universal_region_relations: Option<&'a UniversalRegionRelations<'tcx>>,\n     ) -> Self {\n-        TypeChecker {\n+        let mut checker = Self {\n             infcx,\n             last_span: DUMMY_SP,\n             mir,\n@@ -871,7 +896,36 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             borrowck_context,\n             reported_errors: Default::default(),\n             universal_region_relations,\n+            instantiated_type_annotations: Default::default(),\n+        };\n+        checker.instantiate_user_type_annotations();\n+        checker\n+    }\n+\n+    /// Instantiate canonical types from user type annotations in the `Mir` into the\n+    /// `TypeChecker`. Used when relating user type annotations and when checking if\n+    /// annotations are well-formed.\n+    fn instantiate_user_type_annotations(&mut self) {\n+        debug!(\n+            \"instantiate_user_type_annotations: user_type_annotations={:?}\",\n+             self.mir.user_type_annotations\n+        );\n+        for annotation_index in self.mir.user_type_annotations.indices() {\n+            let (span, canonical_annotation) = &self.mir.user_type_annotations[annotation_index];\n+            let (mut annotation, _) = self.infcx.instantiate_canonical_with_fresh_inference_vars(\n+                *span, &canonical_annotation\n+            );\n+            match annotation {\n+                UserTypeAnnotation::Ty(ref mut ty) =>\n+                    *ty = self.normalize(ty, Locations::All(*span)),\n+                _ => {},\n+            }\n+            self.instantiated_type_annotations.insert(annotation_index, annotation);\n         }\n+        debug!(\n+            \"instantiate_user_type_annotations: instantiated_type_annotations={:?}\",\n+            self.instantiated_type_annotations,\n+        );\n     }\n \n     /// Given some operation `op` that manipulates types, proves\n@@ -1003,18 +1057,14 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             a, v, user_ty, locations,\n         );\n \n-        match user_ty.base {\n-            UserTypeAnnotation::Ty(canonical_ty) => {\n-                let (ty, _) = self.infcx\n-                    .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_ty);\n-\n+        let type_annotation = self.instantiated_type_annotations[&user_ty.base];\n+        match type_annotation {\n+            UserTypeAnnotation::Ty(ty) => {\n                 // The `TypeRelating` code assumes that \"unresolved inference\n                 // variables\" appear in the \"a\" side, so flip `Contravariant`\n                 // ambient variance to get the right relationship.\n                 let v1 = ty::Contravariant.xform(v);\n-\n                 let tcx = self.infcx.tcx;\n-                let ty = self.normalize(ty, locations);\n \n                 // We need to follow any provided projetions into the type.\n                 //\n@@ -1048,13 +1098,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     self.relate_types(ty, v1, a, locations, category)?;\n                 }\n             }\n-            UserTypeAnnotation::TypeOf(def_id, canonical_substs) => {\n-                let (\n-                    user_substs,\n-                    _,\n-                ) = self.infcx\n-                    .instantiate_canonical_with_fresh_inference_vars(DUMMY_SP, &canonical_substs);\n-\n+            UserTypeAnnotation::TypeOf(def_id, user_substs) => {\n                 let projs = self.infcx.tcx.intern_projs(&user_ty.projs);\n                 self.fully_perform_op(\n                     locations,\n@@ -1225,19 +1269,20 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 }\n \n-                if let Some(user_ty) = self.rvalue_user_ty(rv) {\n+                if let Some(annotation_index) = self.rvalue_user_ty(rv) {\n                     if let Err(terr) = self.relate_type_and_user_type(\n                         rv_ty,\n                         ty::Variance::Invariant,\n-                        &UserTypeProjection { base: user_ty, projs: vec![], },\n+                        &UserTypeProjection { base: annotation_index, projs: vec![], },\n                         location.to_locations(),\n                         ConstraintCategory::Boring,\n                     ) {\n+                        let annotation = self.instantiated_type_annotations[&annotation_index];\n                         span_mirbug!(\n                             self,\n                             stmt,\n                             \"bad user type on rvalue ({:?} = {:?}): {:?}\",\n-                            user_ty,\n+                            annotation,\n                             rv_ty,\n                             terr\n                         );\n@@ -1282,21 +1327,23 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     );\n                 };\n             }\n-            StatementKind::AscribeUserType(ref place, variance, box ref c_ty) => {\n+            StatementKind::AscribeUserType(ref place, variance, box ref projection) => {\n                 let place_ty = place.ty(mir, tcx).to_ty(tcx);\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n                     variance,\n-                    c_ty,\n+                    projection,\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n                 ) {\n+                    let annotation = self.instantiated_type_annotations[&projection.base];\n                     span_mirbug!(\n                         self,\n                         stmt,\n-                        \"bad type assert ({:?} <: {:?}): {:?}\",\n+                        \"bad type assert ({:?} <: {:?} with projections {:?}): {:?}\",\n                         place_ty,\n-                        c_ty,\n+                        annotation,\n+                        projection.projs,\n                         terr\n                     );\n                 }\n@@ -1955,7 +2002,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n     /// If this rvalue supports a user-given type annotation, then\n     /// extract and return it. This represents the final type of the\n     /// rvalue and will be unified with the inferred type.\n-    fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<UserTypeAnnotation<'tcx>> {\n+    fn rvalue_user_ty(&self, rvalue: &Rvalue<'tcx>) -> Option<UserTypeAnnotationIndex> {\n         match rvalue {\n             Rvalue::Use(_)\n             | Rvalue::Repeat(..)"}, {"sha": "f3d89a7a02515b3f17f00a95a44a71a67b3ba6d2", "filename": "src/librustc_mir/build/block.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fblock.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -141,9 +141,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                             None, remainder_span, lint_level, slice::from_ref(&pattern),\n                             ArmHasGuard(false), None);\n \n+                        debug!(\"ast_block_stmts: pattern={:?}\", pattern);\n                         this.visit_bindings(\n                             &pattern,\n-                            &PatternTypeProjections::none(),\n+                            UserTypeProjections::none(),\n                             &mut |this, _, _, _, node, span, _, _| {\n                                 this.storage_live_binding(block, node, span, OutsideGuard);\n                                 this.schedule_drop_for_binding(node, span, OutsideGuard);"}, {"sha": "a431bfc61b37ae8c2aa2f9855d2c935b02bb492d", "filename": "src/librustc_mir/build/expr/as_constant.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_constant.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -29,11 +29,16 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 lint_level: _,\n                 value,\n             } => this.as_constant(value),\n-            ExprKind::Literal { literal, user_ty } => Constant {\n-                span,\n-                ty,\n-                user_ty,\n-                literal,\n+            ExprKind::Literal { literal, user_ty } => {\n+                let user_ty = user_ty.map(|ty| {\n+                    this.canonical_user_type_annotations.push((span, ty))\n+                });\n+                Constant {\n+                    span,\n+                    ty,\n+                    user_ty,\n+                    literal,\n+                }\n             },\n             _ => span_bug!(span, \"expression is not a valid constant {:?}\", kind),\n         }"}, {"sha": "3ed00d5797907f638932cb4d51e097d6e94f724c", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -133,14 +133,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n                 let place = unpack!(block = this.as_place(block, source));\n                 if let Some(user_ty) = user_ty {\n+                    let annotation_index = this.canonical_user_type_annotations.push(\n+                        (source_info.span, user_ty)\n+                    );\n                     this.cfg.push(\n                         block,\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n                                 place.clone(),\n                                 Variance::Invariant,\n-                                box UserTypeProjection { base: user_ty, projs: vec![], },\n+                                box UserTypeProjection { base: annotation_index, projs: vec![], },\n                             ),\n                         },\n                     );\n@@ -153,14 +156,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     block = this.as_temp(block, source.temp_lifetime, source, mutability)\n                 );\n                 if let Some(user_ty) = user_ty {\n+                    let annotation_index = this.canonical_user_type_annotations.push(\n+                        (source_info.span, user_ty)\n+                    );\n                     this.cfg.push(\n                         block,\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n                                 Place::Local(temp.clone()),\n                                 Variance::Invariant,\n-                                box UserTypeProjection { base: user_ty, projs: vec![], },\n+                                box UserTypeProjection { base: annotation_index, projs: vec![], },\n                             ),\n                         },\n                     );"}, {"sha": "7dcac05e702a3ad0b297b7fae4b8cc10e1fcdfa4", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -331,6 +331,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         .collect()\n                 };\n \n+                let user_ty = user_ty.map(|ty| {\n+                    this.canonical_user_type_annotations.push((expr_span, ty))\n+                });\n                 let adt = box AggregateKind::Adt(\n                     adt_def,\n                     variant_index,"}, {"sha": "fe5bc6e19db659bb4af1308d74ca7199298a7bc5", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -8,7 +8,6 @@ use build::ForGuard::{self, OutsideGuard, RefWithinGuard, ValWithinGuard};\n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::{GuardFrame, GuardFrameLocal, LocalsForNode};\n use hair::*;\n-use hair::pattern::PatternTypeProjections;\n use rustc::mir::*;\n use rustc::ty::{self, Ty};\n use rustc::ty::layout::VariantIdx;\n@@ -302,14 +301,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 );\n \n                 let ty_source_info = self.source_info(user_ty_span);\n+                let user_ty = box pat_ascription_ty.user_ty(\n+                    &mut self.canonical_user_type_annotations, ty_source_info.span\n+                );\n                 self.cfg.push(\n                     block,\n                     Statement {\n                         source_info: ty_source_info,\n                         kind: StatementKind::AscribeUserType(\n                             place,\n                             ty::Variance::Invariant,\n-                            box pat_ascription_ty.user_ty(),\n+                            user_ty,\n                         ),\n                     },\n                 );\n@@ -406,9 +408,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         );\n         let mut scope = self.source_scope;\n         let num_patterns = patterns.len();\n+        debug!(\"declare_bindings: patterns={:?}\", patterns);\n         self.visit_bindings(\n             &patterns[0],\n-            &PatternTypeProjections::none(),\n+            UserTypeProjections::none(),\n             &mut |this, mutability, name, mode, var, span, ty, user_ty| {\n                 if visibility_scope.is_none() {\n                     visibility_scope =\n@@ -484,7 +487,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     pub(super) fn visit_bindings(\n         &mut self,\n         pattern: &Pattern<'tcx>,\n-        pattern_user_ty: &PatternTypeProjections<'tcx>,\n+        pattern_user_ty: UserTypeProjections<'tcx>,\n         f: &mut impl FnMut(\n             &mut Self,\n             Mutability,\n@@ -493,9 +496,10 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             NodeId,\n             Span,\n             Ty<'tcx>,\n-            &PatternTypeProjections<'tcx>,\n+            UserTypeProjections<'tcx>,\n         ),\n     ) {\n+        debug!(\"visit_bindings: pattern={:?} pattern_user_ty={:?}\", pattern, pattern_user_ty);\n         match *pattern.kind {\n             PatternKind::Binding {\n                 mutability,\n@@ -506,19 +510,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ref subpattern,\n                 ..\n             } => {\n-                let pattern_ref_binding; // sidestep temp lifetime limitations.\n-                let binding_user_ty = match mode {\n-                    BindingMode::ByValue => { pattern_user_ty }\n-                    BindingMode::ByRef(..) => {\n-                        // If this is a `ref` binding (e.g., `let ref\n-                        // x: T = ..`), then the type of `x` is not\n-                        // `T` but rather `&T`.\n-                        pattern_ref_binding = pattern_user_ty.ref_binding();\n-                        &pattern_ref_binding\n-                    }\n-                };\n-\n-                f(self, mutability, name, mode, var, pattern.span, ty, binding_user_ty);\n+                f(self, mutability, name, mode, var, pattern.span, ty, pattern_user_ty.clone());\n                 if let Some(subpattern) = subpattern.as_ref() {\n                     self.visit_bindings(subpattern, pattern_user_ty, f);\n                 }\n@@ -536,41 +528,47 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 let from = u32::try_from(prefix.len()).unwrap();\n                 let to = u32::try_from(suffix.len()).unwrap();\n                 for subpattern in prefix {\n-                    self.visit_bindings(subpattern, &pattern_user_ty.index(), f);\n+                    self.visit_bindings(subpattern, pattern_user_ty.clone().index(), f);\n                 }\n                 for subpattern in slice {\n-                    self.visit_bindings(subpattern, &pattern_user_ty.subslice(from, to), f);\n+                    self.visit_bindings(subpattern, pattern_user_ty.clone().subslice(from, to), f);\n                 }\n                 for subpattern in suffix {\n-                    self.visit_bindings(subpattern, &pattern_user_ty.index(), f);\n+                    self.visit_bindings(subpattern, pattern_user_ty.clone().index(), f);\n                 }\n             }\n             PatternKind::Constant { .. } | PatternKind::Range { .. } | PatternKind::Wild => {}\n             PatternKind::Deref { ref subpattern } => {\n-                self.visit_bindings(subpattern, &pattern_user_ty.deref(), f);\n+                self.visit_bindings(subpattern, pattern_user_ty.deref(), f);\n             }\n             PatternKind::AscribeUserType { ref subpattern, ref user_ty, user_ty_span } => {\n                 // This corresponds to something like\n                 //\n                 // ```\n                 // let A::<'a>(_): A<'static> = ...;\n                 // ```\n-                let subpattern_user_ty = pattern_user_ty.add_user_type(user_ty, user_ty_span);\n-                self.visit_bindings(subpattern, &subpattern_user_ty, f)\n+                let annotation = (user_ty_span, user_ty.base);\n+                let projection = UserTypeProjection {\n+                    base: self.canonical_user_type_annotations.push(annotation),\n+                    projs: user_ty.projs.clone(),\n+                };\n+                let subpattern_user_ty = pattern_user_ty.push_projection(&projection, user_ty_span);\n+                self.visit_bindings(subpattern, subpattern_user_ty, f)\n             }\n \n             PatternKind::Leaf { ref subpatterns } => {\n                 for subpattern in subpatterns {\n-                    let subpattern_user_ty = pattern_user_ty.leaf(subpattern.field);\n-                    self.visit_bindings(&subpattern.pattern, &subpattern_user_ty, f);\n+                    let subpattern_user_ty = pattern_user_ty.clone().leaf(subpattern.field);\n+                    debug!(\"visit_bindings: subpattern_user_ty={:?}\", subpattern_user_ty);\n+                    self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n \n             PatternKind::Variant { adt_def, substs: _, variant_index, ref subpatterns } => {\n                 for subpattern in subpatterns {\n-                    let subpattern_user_ty = pattern_user_ty.variant(\n+                    let subpattern_user_ty = pattern_user_ty.clone().variant(\n                         adt_def, variant_index, subpattern.field);\n-                    self.visit_bindings(&subpattern.pattern, &subpattern_user_ty, f);\n+                    self.visit_bindings(&subpattern.pattern, subpattern_user_ty, f);\n                 }\n             }\n         }\n@@ -1314,14 +1312,17 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 ascription.user_ty,\n             );\n \n+            let user_ty = box ascription.user_ty.clone().user_ty(\n+                &mut self.canonical_user_type_annotations, source_info.span\n+            );\n             self.cfg.push(\n                 block,\n                 Statement {\n                     source_info,\n                     kind: StatementKind::AscribeUserType(\n                         ascription.source.clone(),\n                         ty::Variance::Covariant,\n-                        box ascription.user_ty.clone().user_ty(),\n+                        user_ty,\n                     ),\n                 },\n             );\n@@ -1468,7 +1469,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         num_patterns: usize,\n         var_id: NodeId,\n         var_ty: Ty<'tcx>,\n-        user_var_ty: &PatternTypeProjections<'tcx>,\n+        user_ty: UserTypeProjections<'tcx>,\n         has_guard: ArmHasGuard,\n         opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n         pat_span: Span,\n@@ -1484,10 +1485,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             BindingMode::ByValue => ty::BindingMode::BindByValue(mutability.into()),\n             BindingMode::ByRef { .. } => ty::BindingMode::BindByReference(mutability.into()),\n         };\n+        debug!(\"declare_binding: user_ty={:?}\", user_ty);\n         let local = LocalDecl::<'tcx> {\n             mutability,\n             ty: var_ty,\n-            user_ty: user_var_ty.clone().user_ty(),\n+            user_ty,\n             name: Some(name),\n             source_info,\n             visibility_scope,"}, {"sha": "8acdecf6fa2489c9060c17ce0a59d4c8dc653710", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -379,6 +379,7 @@ struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     /// (A match binding can have two locals; the 2nd is for the arm's guard.)\n     var_indices: NodeMap<LocalsForNode>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n+    canonical_user_type_annotations: ty::CanonicalUserTypeAnnotations<'tcx>,\n     upvar_decls: Vec<UpvarDecl>,\n     unit_temp: Option<Place<'tcx>>,\n \n@@ -812,6 +813,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 LocalDecl::new_return_place(return_ty, return_span),\n                 1,\n             ),\n+            canonical_user_type_annotations: IndexVec::new(),\n             upvar_decls,\n             var_indices: Default::default(),\n             unit_temp: None,\n@@ -845,6 +847,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             IndexVec::new(),\n             yield_ty,\n             self.local_decls,\n+            self.canonical_user_type_annotations,\n             self.arg_count,\n             self.upvar_decls,\n             self.fn_span,"}, {"sha": "e73cc40c8c6e4ca19a84b14ed754281f6782d633", "filename": "src/librustc_mir/hair/cx/block.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fblock.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -78,12 +78,13 @@ fn mirror_stmts<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         let mut pattern = cx.pattern_from_hir(&local.pat);\n \n                         if let Some(ty) = &local.ty {\n-                            if let Some(&user_ty) = cx.tables.user_provided_tys().get(ty.hir_id) {\n+                            if let Some(&user_ty) = cx.tables.user_provided_types().get(ty.hir_id) {\n+                                debug!(\"mirror_stmts: user_ty={:?}\", user_ty);\n                                 pattern = Pattern {\n                                     ty: pattern.ty,\n                                     span: pattern.span,\n                                     kind: Box::new(PatternKind::AscribeUserType {\n-                                        user_ty: PatternTypeProjection::from_canonical_ty(user_ty),\n+                                        user_ty: PatternTypeProjection::from_user_type(user_ty),\n                                         user_ty_span: ty.span,\n                                         subpattern: pattern\n                                     })"}, {"sha": "293058a0f26f53d359316eb42eae69361a1b19d3", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 44, "deletions": 19, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n use rustc::hir::def_id::LocalDefId;\n-use rustc::mir::{BorrowKind};\n+use rustc::mir::BorrowKind;\n use syntax_pos::Span;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n@@ -283,9 +283,16 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 };\n                 if let Some((adt_def, index)) = adt_data {\n                     let substs = cx.tables().node_substs(fun.hir_id);\n-\n-                    let user_ty = cx.tables().user_substs(fun.hir_id)\n-                        .map(|user_substs| UserTypeAnnotation::TypeOf(adt_def.did, user_substs));\n+                    let user_provided_types = cx.tables().user_provided_types();\n+                    let user_ty = user_provided_types.get(fun.hir_id)\n+                        .map(|u_ty| *u_ty)\n+                        .map(|mut u_ty| {\n+                            if let UserTypeAnnotation::TypeOf(ref mut did, _) = &mut u_ty.value {\n+                                *did = adt_def.did;\n+                            }\n+                            u_ty\n+                        });\n+                    debug!(\"make_mirror_unadjusted: (call) user_ty={:?}\", user_ty);\n \n                     let field_refs = args.iter()\n                         .enumerate()\n@@ -464,11 +471,14 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                 ty::Adt(adt, substs) => {\n                     match adt.adt_kind() {\n                         AdtKind::Struct | AdtKind::Union => {\n+                            let user_provided_types = cx.tables().user_provided_types();\n+                            let user_ty = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n+                            debug!(\"make_mirror_unadjusted: (struct/union) user_ty={:?}\", user_ty);\n                             ExprKind::Adt {\n                                 adt_def: adt,\n                                 variant_index: VariantIdx::new(0),\n                                 substs,\n-                                user_ty: cx.user_substs_applied_to_adt(expr.hir_id, adt),\n+                                user_ty,\n                                 fields: field_refs(cx, fields),\n                                 base: base.as_ref().map(|base| {\n                                     FruInfo {\n@@ -487,11 +497,18 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                     assert!(base.is_none());\n \n                                     let index = adt.variant_index_with_id(variant_id);\n+                                    let user_provided_types = cx.tables().user_provided_types();\n+                                    let user_ty = user_provided_types.get(expr.hir_id)\n+                                        .map(|u_ty| *u_ty);\n+                                    debug!(\n+                                        \"make_mirror_unadjusted: (variant) user_ty={:?}\",\n+                                        user_ty\n+                                    );\n                                     ExprKind::Adt {\n                                         adt_def: adt,\n                                         variant_index: index,\n                                         substs,\n-                                        user_ty: cx.user_substs_applied_to_adt(expr.hir_id, adt),\n+                                        user_ty,\n                                         fields: field_refs(cx, fields),\n                                         base: None,\n                                     }\n@@ -635,8 +652,8 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         }\n         hir::ExprKind::Cast(ref source, ref cast_ty) => {\n             // Check for a user-given type annotation on this `cast`\n-            let user_ty = cx.tables.user_provided_tys().get(cast_ty.hir_id)\n-                .map(|&t| UserTypeAnnotation::Ty(t));\n+            let user_provided_types = cx.tables.user_provided_types();\n+            let user_ty = user_provided_types.get(cast_ty.hir_id);\n \n             debug!(\n                 \"cast({:?}) has ty w/ hir_id {:?} and user provided ty {:?}\",\n@@ -742,20 +759,20 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                     span: expr.span,\n                     kind: cast,\n                 };\n+                debug!(\"make_mirror_unadjusted: (cast) user_ty={:?}\", user_ty);\n \n                 ExprKind::ValueTypeAscription {\n                     source: cast_expr.to_ref(),\n-                    user_ty: Some(user_ty),\n+                    user_ty: Some(*user_ty),\n                 }\n             } else {\n                 cast\n             }\n         }\n         hir::ExprKind::Type(ref source, ref ty) => {\n-            let user_provided_tys = cx.tables.user_provided_tys();\n-            let user_ty = user_provided_tys\n-                .get(ty.hir_id)\n-                .map(|&c_ty| UserTypeAnnotation::Ty(c_ty));\n+            let user_provided_types = cx.tables.user_provided_types();\n+            let user_ty = user_provided_types.get(ty.hir_id).map(|u_ty| *u_ty);\n+            debug!(\"make_mirror_unadjusted: (type) user_ty={:?}\", user_ty);\n             if source.is_place_expr() {\n                 ExprKind::PlaceTypeAscription {\n                     source: source.to_ref(),\n@@ -792,8 +809,9 @@ fn user_substs_applied_to_def(\n     cx: &mut Cx<'a, 'gcx, 'tcx>,\n     hir_id: hir::HirId,\n     def: &Def,\n-) -> Option<UserTypeAnnotation<'tcx>> {\n-    match def {\n+) -> Option<ty::CanonicalUserTypeAnnotation<'tcx>> {\n+    debug!(\"user_substs_applied_to_def: def={:?}\", def);\n+    let user_provided_type = match def {\n         // A reference to something callable -- e.g., a fn, method, or\n         // a tuple-struct or tuple-variant. This has the type of a\n         // `Fn` but with the user-given substitutions.\n@@ -802,8 +820,7 @@ fn user_substs_applied_to_def(\n         Def::StructCtor(_, CtorKind::Fn) |\n         Def::VariantCtor(_, CtorKind::Fn) |\n         Def::Const(_) |\n-        Def::AssociatedConst(_) =>\n-            Some(UserTypeAnnotation::TypeOf(def.def_id(), cx.tables().user_substs(hir_id)?)),\n+        Def::AssociatedConst(_) => cx.tables().user_provided_types().get(hir_id).map(|u_ty| *u_ty),\n \n         // A unit struct/variant which is used as a value (e.g.,\n         // `None`). This has the type of the enum/struct that defines\n@@ -819,7 +836,9 @@ fn user_substs_applied_to_def(\n \n         _ =>\n             bug!(\"user_substs_applied_to_def: unexpected def {:?} at {:?}\", def, hir_id)\n-    }\n+    };\n+    debug!(\"user_substs_applied_to_def: user_provided_type={:?}\", user_provided_type);\n+    user_provided_type\n }\n \n fn method_callee<'a, 'gcx, 'tcx>(\n@@ -839,6 +858,7 @@ fn method_callee<'a, 'gcx, 'tcx>(\n                     span_bug!(expr.span, \"no type-dependent def for method callee\")\n                 });\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, def);\n+            debug!(\"method_callee: user_ty={:?}\", user_ty);\n             (def.def_id(), cx.tables().node_substs(expr.hir_id), user_ty)\n         }\n     };\n@@ -906,6 +926,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::VariantCtor(_, CtorKind::Fn) |\n         Def::SelfCtor(..) => {\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+            debug!(\"convert_path_expr: user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n                 literal: ty::Const::zero_sized(\n                     cx.tcx,\n@@ -918,6 +939,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n         Def::Const(def_id) |\n         Def::AssociatedConst(def_id) => {\n             let user_ty = user_substs_applied_to_def(cx, expr.hir_id, &def);\n+            debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n             ExprKind::Literal {\n                 literal: ty::Const::unevaluated(\n                     cx.tcx,\n@@ -931,6 +953,9 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n \n         Def::StructCtor(def_id, CtorKind::Const) |\n         Def::VariantCtor(def_id, CtorKind::Const) => {\n+            let user_provided_types = cx.tables.user_provided_types();\n+            let user_provided_type = user_provided_types.get(expr.hir_id).map(|u_ty| *u_ty);\n+            debug!(\"convert_path_expr: user_provided_type={:?}\", user_provided_type);\n             match cx.tables().node_id_to_type(expr.hir_id).sty {\n                 // A unit struct/variant which is used as a value.\n                 // We return a completely different ExprKind here to account for this special case.\n@@ -939,7 +964,7 @@ fn convert_path_expr<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                         adt_def,\n                         variant_index: adt_def.variant_index_with_id(def_id),\n                         substs,\n-                        user_ty: cx.user_substs_applied_to_adt(expr.hir_id, adt_def),\n+                        user_ty: user_provided_type,\n                         fields: vec![],\n                         base: None,\n                     }"}, {"sha": "b56e3d4e77395c49da800af726390bc10d1b553a", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -4,11 +4,12 @@\n //! unit-tested and separated from the Rust source and compiler data\n //! structures.\n \n-use rustc::mir::{BinOp, BorrowKind, UserTypeAnnotation, Field, UnOp};\n+use rustc::mir::{BinOp, BorrowKind, Field, UnOp};\n use rustc::hir::def_id::DefId;\n+use rustc::infer::canonical::Canonical;\n use rustc::middle::region;\n use rustc::ty::subst::Substs;\n-use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const};\n+use rustc::ty::{AdtDef, UpvarSubsts, Region, Ty, Const, UserTypeAnnotation};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir;\n use syntax::ast;\n@@ -20,7 +21,7 @@ mod constant;\n \n pub mod pattern;\n pub use self::pattern::{BindingMode, Pattern, PatternKind, PatternRange, FieldPattern};\n-pub(crate) use self::pattern::{PatternTypeProjection, PatternTypeProjections};\n+pub(crate) use self::pattern::PatternTypeProjection;\n \n mod util;\n \n@@ -265,20 +266,20 @@ pub enum ExprKind<'tcx> {\n \n         /// Optional user-given substs: for something like `let x =\n         /// Bar::<T> { ... }`.\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n \n         fields: Vec<FieldExprRef<'tcx>>,\n         base: Option<FruInfo<'tcx>>\n     },\n     PlaceTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n     },\n     ValueTypeAscription {\n         source: ExprRef<'tcx>,\n         /// Type that the user gave to this expression\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n     },\n     Closure {\n         closure_id: DefId,\n@@ -288,7 +289,7 @@ pub enum ExprKind<'tcx> {\n     },\n     Literal {\n         literal: &'tcx Const<'tcx>,\n-        user_ty: Option<UserTypeAnnotation<'tcx>>,\n+        user_ty: Option<Canonical<'tcx, UserTypeAnnotation<'tcx>>>,\n     },\n     InlineAsm {\n         asm: &'tcx hir::InlineAsm,"}, {"sha": "10d2d7bc1b18b7cb63bc724e5447c51d76a937b5", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 50, "deletions": 115, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -12,9 +12,10 @@ use hair::util::UserAnnotatedTyHelpers;\n use hair::constant::*;\n \n use rustc::mir::{fmt_const_val, Field, BorrowKind, Mutability};\n-use rustc::mir::{ProjectionElem, UserTypeAnnotation, UserTypeProjection, UserTypeProjections};\n+use rustc::mir::{ProjectionElem, UserTypeProjection};\n use rustc::mir::interpret::{Scalar, GlobalId, ConstValue, sign_extend};\n use rustc::ty::{self, Region, TyCtxt, AdtDef, Ty, Lift};\n+use rustc::ty::{CanonicalUserTypeAnnotation, CanonicalUserTypeAnnotations, UserTypeAnnotation};\n use rustc::ty::subst::{Substs, Kind};\n use rustc::ty::layout::VariantIdx;\n use rustc::hir::{self, PatKind, RangeEnd};\n@@ -58,113 +59,29 @@ pub struct Pattern<'tcx> {\n \n \n #[derive(Clone, Debug)]\n-pub(crate) struct PatternTypeProjections<'tcx> {\n-    contents: Vec<(PatternTypeProjection<'tcx>, Span)>,\n+pub struct PatternTypeProjection<'tcx> {\n+    pub base: CanonicalUserTypeAnnotation<'tcx>,\n+    pub projs: Vec<ProjectionElem<'tcx, (), ()>>,\n }\n \n-impl<'tcx> PatternTypeProjections<'tcx> {\n-    pub(crate) fn user_ty(self) -> UserTypeProjections<'tcx> {\n-        UserTypeProjections::from_projections(\n-            self.contents.into_iter().map(|(pat_ty_proj, span)| (pat_ty_proj.user_ty(), span)))\n-    }\n-\n-    pub(crate) fn none() -> Self {\n-        PatternTypeProjections { contents: vec![] }\n-    }\n-\n-    pub(crate) fn ref_binding(&self) -> Self {\n-        // FIXME(#55401): ignore for now\n-        PatternTypeProjections { contents: vec![] }\n-    }\n-\n-    fn map_projs(&self,\n-                 mut f: impl FnMut(&PatternTypeProjection<'tcx>) -> PatternTypeProjection<'tcx>)\n-                 -> Self\n-    {\n-        PatternTypeProjections {\n-            contents: self.contents\n-                .iter()\n-                .map(|(proj, span)| (f(proj), *span))\n-                .collect(), }\n-    }\n-\n-    pub(crate) fn index(&self) -> Self { self.map_projs(|pat_ty_proj| pat_ty_proj.index()) }\n-\n-    pub(crate) fn subslice(&self, from: u32, to: u32) -> Self {\n-        self.map_projs(|pat_ty_proj| pat_ty_proj.subslice(from, to))\n-    }\n-\n-    pub(crate) fn deref(&self) -> Self { self.map_projs(|pat_ty_proj| pat_ty_proj.deref()) }\n-\n-    pub(crate) fn leaf(&self, field: Field) -> Self {\n-        self.map_projs(|pat_ty_proj| pat_ty_proj.leaf(field))\n-    }\n-\n-    pub(crate) fn variant(&self,\n-                          adt_def: &'tcx AdtDef,\n-                          variant_index: VariantIdx,\n-                          field: Field) -> Self {\n-        self.map_projs(|pat_ty_proj| pat_ty_proj.variant(adt_def, variant_index, field))\n-    }\n-\n-    pub(crate) fn add_user_type(&self, user_ty: &PatternTypeProjection<'tcx>, sp: Span) -> Self {\n-        let mut new = self.clone();\n-        new.contents.push((user_ty.clone(), sp));\n-        new\n-    }\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct PatternTypeProjection<'tcx>(UserTypeProjection<'tcx>);\n-\n impl<'tcx> PatternTypeProjection<'tcx> {\n-    pub(crate) fn index(&self) -> Self {\n-        let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Index(()));\n-        new\n-    }\n-\n-    pub(crate) fn subslice(&self, from: u32, to: u32) -> Self {\n-        let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Subslice { from, to });\n-        new\n-    }\n-\n-    pub(crate) fn deref(&self) -> Self {\n-        let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Deref);\n-        new\n-    }\n-\n-    pub(crate) fn leaf(&self, field: Field) -> Self {\n-        let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Field(field, ()));\n-        new\n-    }\n-\n-    pub(crate) fn variant(&self,\n-                          adt_def: &'tcx AdtDef,\n-                          variant_index: VariantIdx,\n-                          field: Field) -> Self {\n-        let mut new = self.clone();\n-        new.0.projs.push(ProjectionElem::Downcast(adt_def, variant_index));\n-        new.0.projs.push(ProjectionElem::Field(field, ()));\n-        new\n-    }\n-\n-    pub(crate) fn from_canonical_ty(c_ty: ty::CanonicalTy<'tcx>) -> Self {\n-        Self::from_user_type(UserTypeAnnotation::Ty(c_ty))\n-    }\n-\n-    pub(crate) fn from_user_type(u_ty: UserTypeAnnotation<'tcx>) -> Self {\n-        Self::from_user_type_proj(UserTypeProjection { base: u_ty, projs: vec![], })\n+    pub(crate) fn from_user_type(user_annotation: CanonicalUserTypeAnnotation<'tcx>) -> Self {\n+        Self {\n+            base: user_annotation,\n+            projs: Vec::new(),\n+        }\n     }\n \n-    pub(crate) fn from_user_type_proj(u_ty: UserTypeProjection<'tcx>) -> Self {\n-        PatternTypeProjection(u_ty)\n+    pub(crate) fn user_ty(\n+        self,\n+        annotations: &mut CanonicalUserTypeAnnotations<'tcx>,\n+        span: Span,\n+    ) -> UserTypeProjection<'tcx> {\n+        UserTypeProjection {\n+            base: annotations.push((span, self.base)),\n+            projs: self.projs\n+        }\n     }\n-\n-    pub(crate) fn user_ty(self) -> UserTypeProjection<'tcx> { self.0 }\n }\n \n #[derive(Clone, Debug)]\n@@ -788,18 +705,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         };\n \n         if let Some(user_ty) = self.user_substs_applied_to_ty_of_hir_id(hir_id) {\n-            let subpattern = Pattern {\n-                span,\n-                ty,\n-                kind: Box::new(kind),\n-            };\n-\n-            debug!(\"pattern user_ty = {:?} for pattern at {:?}\", user_ty, span);\n-\n-            let pat_ty = PatternTypeProjection::from_user_type(user_ty);\n+            debug!(\"lower_variant_or_leaf: kind={:?} user_ty={:?} span={:?}\", kind, user_ty, span);\n             kind = PatternKind::AscribeUserType {\n-                subpattern,\n-                user_ty: pat_ty,\n+                subpattern: Pattern {\n+                    span,\n+                    ty,\n+                    kind: Box::new(kind),\n+                },\n+                user_ty: PatternTypeProjection::from_user_type(user_ty),\n                 user_ty_span: span,\n             };\n         }\n@@ -837,7 +750,28 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                         };\n                         match self.tcx.at(span).const_eval(self.param_env.and(cid)) {\n                             Ok(value) => {\n-                                return self.const_to_pat(instance, value, id, span)\n+                                let pattern = self.const_to_pat(instance, value, id, span);\n+                                if !is_associated_const {\n+                                    return pattern;\n+                                }\n+\n+                                let user_provided_types = self.tables().user_provided_types();\n+                                return if let Some(u_ty) = user_provided_types.get(id) {\n+                                    let user_ty = PatternTypeProjection::from_user_type(*u_ty);\n+                                    Pattern {\n+                                        span,\n+                                        kind: Box::new(\n+                                            PatternKind::AscribeUserType {\n+                                                subpattern: pattern,\n+                                                user_ty,\n+                                                user_ty_span: span,\n+                                            }\n+                                        ),\n+                                        ty: value.ty,\n+                                    }\n+                                } else {\n+                                    pattern\n+                                }\n                             },\n                             Err(_) => {\n                                 self.tcx.sess.span_err(\n@@ -927,7 +861,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n         id: hir::HirId,\n         span: Span,\n     ) -> Pattern<'tcx> {\n-        debug!(\"const_to_pat: cv={:#?}\", cv);\n+        debug!(\"const_to_pat: cv={:#?} id={:?}\", cv, id);\n         let adt_subpattern = |i, variant_opt| {\n             let field = Field::new(i);\n             let val = const_field(\n@@ -945,6 +879,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }).collect::<Vec<_>>()\n         };\n+        debug!(\"const_to_pat: cv.ty={:?} span={:?}\", cv.ty, span);\n         let kind = match cv.ty.sty {\n             ty::Float(_) => {\n                 let id = self.tcx.hir().hir_to_node_id(id);"}, {"sha": "f0f8263b64de53f286e090e225f8060473897057", "filename": "src/librustc_mir/hair/util.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fhair%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fhair%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Futil.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -1,37 +1,31 @@\n use rustc::hir;\n-use rustc::mir::UserTypeAnnotation;\n-use rustc::ty::{self, AdtDef, TyCtxt};\n+use rustc::ty::{self, CanonicalUserTypeAnnotation, TyCtxt, UserTypeAnnotation};\n \n crate trait UserAnnotatedTyHelpers<'gcx: 'tcx, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'_, 'gcx, 'tcx>;\n \n     fn tables(&self) -> &ty::TypeckTables<'tcx>;\n \n-    fn user_substs_applied_to_adt(\n-        &self,\n-        hir_id: hir::HirId,\n-        adt_def: &'tcx AdtDef,\n-    ) -> Option<UserTypeAnnotation<'tcx>> {\n-        let user_substs = self.tables().user_substs(hir_id)?;\n-        Some(UserTypeAnnotation::TypeOf(adt_def.did, user_substs))\n-    }\n-\n     /// Looks up the type associated with this hir-id and applies the\n     /// user-given substitutions; the hir-id must map to a suitable\n     /// type.\n     fn user_substs_applied_to_ty_of_hir_id(\n         &self,\n         hir_id: hir::HirId,\n-    ) -> Option<UserTypeAnnotation<'tcx>> {\n-        let user_substs = self.tables().user_substs(hir_id)?;\n+    ) -> Option<CanonicalUserTypeAnnotation<'tcx>> {\n+        let user_provided_types = self.tables().user_provided_types();\n+        let mut user_ty = *user_provided_types.get(hir_id)?;\n+        debug!(\"user_subts_applied_to_ty_of_hir_id: user_ty={:?}\", user_ty);\n         match &self.tables().node_id_to_type(hir_id).sty {\n-            ty::Adt(adt_def, _) => Some(UserTypeAnnotation::TypeOf(adt_def.did, user_substs)),\n-            ty::FnDef(def_id, _) => Some(UserTypeAnnotation::TypeOf(*def_id, user_substs)),\n-            sty => bug!(\n-                \"sty: {:?} should not have user-substs {:?} recorded \",\n-                sty,\n-                user_substs\n-            ),\n+            ty::Adt(adt_def, ..) => {\n+                if let UserTypeAnnotation::TypeOf(ref mut did, _) = &mut user_ty.value {\n+                    *did = adt_def.did;\n+                }\n+                Some(user_ty)\n+            }\n+            ty::FnDef(..) => Some(user_ty),\n+            sty =>\n+                bug!(\"sty: {:?} should not have user provided type {:?} recorded \", sty, user_ty),\n         }\n     }\n }"}, {"sha": "4c123d4a44b058857d3524b0d709a6992cc8fab3", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -207,6 +207,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         IndexVec::new(),\n         None,\n         local_decls_for_sig(&sig, span),\n+        IndexVec::new(),\n         sig.inputs().len(),\n         vec![],\n         span,\n@@ -376,6 +377,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n             IndexVec::new(),\n             None,\n             self.local_decls,\n+            IndexVec::new(),\n             self.sig.inputs().len(),\n             vec![],\n             self.span,\n@@ -825,6 +827,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         IndexVec::new(),\n         None,\n         local_decls,\n+        IndexVec::new(),\n         sig.inputs().len(),\n         vec![],\n         span,\n@@ -903,6 +906,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         IndexVec::new(),\n         None,\n         local_decls,\n+        IndexVec::new(),\n         sig.inputs().len(),\n         vec![],\n         span,"}, {"sha": "1602fc35a2c9585a54f44d13d052515a1310e72d", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -400,6 +400,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n                 IndexVec::new(),\n                 None,\n                 initial_locals,\n+                IndexVec::new(),\n                 0,\n                 vec![],\n                 mir.span,"}, {"sha": "6353eab6f6553770271e491549ce1c16cda7a1b7", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -142,6 +142,7 @@ fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n         }\n         writeln!(file, \"\")?;\n         extra_data(PassWhere::BeforeCFG, &mut file)?;\n+        write_user_type_annotations(mir, &mut file)?;\n         write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n         extra_data(PassWhere::AfterCFG, &mut file)?;\n     };\n@@ -618,6 +619,19 @@ fn write_temp_decls(mir: &Mir, w: &mut dyn Write) -> io::Result<()> {\n     Ok(())\n }\n \n+fn write_user_type_annotations(mir: &Mir, w: &mut dyn Write) -> io::Result<()> {\n+    if !mir.user_type_annotations.is_empty() {\n+        writeln!(w, \"| User Type Annotations\")?;\n+    }\n+    for (index, (span, annotation)) in mir.user_type_annotations.iter_enumerated() {\n+        writeln!(w, \"| {:?}: {:?} at {:?}\", index.index(), annotation, span)?;\n+    }\n+    if !mir.user_type_annotations.is_empty() {\n+        writeln!(w, \"|\")?;\n+    }\n+    Ok(())\n+}\n+\n pub fn dump_mir_def_ids(tcx: TyCtxt, single: Option<DefId>) -> Vec<DefId> {\n     if let Some(i) = single {\n         vec![i]"}, {"sha": "52fcb5b80f4ae9d4dec96886c8dd3b0cc02b31aa", "filename": "src/librustc_traits/type_op.rs", "status": "modified", "additions": 20, "deletions": 35, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_traits%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_traits%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Ftype_op.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -14,7 +14,7 @@ use rustc::traits::{\n     Normalized, Obligation, ObligationCause, TraitEngine, TraitEngineExt,\n };\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{Kind, Subst, UserSelfTy, UserSubsts};\n+use rustc::ty::subst::{Kind, Subst, UserSubsts, UserSelfTy};\n use rustc::ty::{\n     FnSig, Lift, ParamEnv, ParamEnvAnd, PolyFnSig, Predicate, Ty, TyCtxt, TypeFoldable, Variance,\n };\n@@ -44,28 +44,16 @@ fn type_op_ascribe_user_type<'tcx>(\n     tcx.infer_ctxt()\n         .enter_canonical_trait_query(&canonicalized, |infcx, fulfill_cx, key| {\n             let (\n-                param_env,\n-                AscribeUserType {\n-                    mir_ty,\n-                    variance,\n-                    def_id,\n-                    user_substs,\n-                    projs,\n-                },\n+                param_env, AscribeUserType { mir_ty, variance, def_id, user_substs, projs }\n             ) = key.into_parts();\n \n             debug!(\n-                \"type_op_ascribe_user_type(\\\n-                 mir_ty={:?}, variance={:?}, def_id={:?}, user_substs={:?}, projs={:?}\\\n-                 )\",\n-                mir_ty, variance, def_id, user_substs, projs,\n+                \"type_op_ascribe_user_type: mir_ty={:?} variance={:?} def_id={:?} \\\n+                 user_substs={:?} projs={:?}\",\n+                mir_ty, variance, def_id, user_substs, projs\n             );\n \n-            let mut cx = AscribeUserTypeCx {\n-                infcx,\n-                param_env,\n-                fulfill_cx,\n-            };\n+            let mut cx = AscribeUserTypeCx { infcx, param_env, fulfill_cx };\n             cx.relate_mir_and_user_ty(mir_ty, variance, def_id, user_substs, projs)?;\n \n             Ok(())\n@@ -130,10 +118,9 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         projs: &[ProjectionKind<'tcx>],\n     ) -> Result<(), NoSolution> {\n         let UserSubsts {\n-            substs,\n             user_self_ty,\n+            substs,\n         } = user_substs;\n-\n         let tcx = self.tcx();\n \n         let ty = tcx.type_of(def_id);\n@@ -171,20 +158,6 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n             self.relate(mir_ty, variance, ty)?;\n         }\n \n-        if let Some(UserSelfTy {\n-            impl_def_id,\n-            self_ty,\n-        }) = user_self_ty\n-        {\n-            let impl_self_ty = self.tcx().type_of(impl_def_id);\n-            let impl_self_ty = self.subst(impl_self_ty, &substs);\n-            let impl_self_ty = self.normalize(impl_self_ty);\n-\n-            self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n-\n-            self.prove_predicate(Predicate::WellFormed(impl_self_ty));\n-        }\n-\n         // Prove the predicates coming along with `def_id`.\n         //\n         // Also, normalize the `instantiated_predicates`\n@@ -198,6 +171,19 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n             self.prove_predicate(instantiated_predicate);\n         }\n \n+        if let Some(UserSelfTy {\n+            impl_def_id,\n+            self_ty,\n+        }) = user_self_ty {\n+            let impl_self_ty = self.tcx().type_of(impl_def_id);\n+            let impl_self_ty = self.subst(impl_self_ty, &substs);\n+            let impl_self_ty = self.normalize(impl_self_ty);\n+\n+            self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n+\n+            self.prove_predicate(Predicate::WellFormed(impl_self_ty));\n+        }\n+\n         // In addition to proving the predicates, we have to\n         // prove that `ty` is well-formed -- this is because\n         // the WF of `ty` is predicated on the substs being\n@@ -210,7 +196,6 @@ impl AscribeUserTypeCx<'me, 'gcx, 'tcx> {\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n         self.prove_predicate(Predicate::WellFormed(ty));\n-\n         Ok(())\n     }\n }"}, {"sha": "1758f762524563623bfed05dec3c4d15ff327d65", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -357,16 +357,16 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    pub fn resolve_ufcs(&self,\n-                        span: Span,\n-                        method_name: ast::Ident,\n-                        self_ty: Ty<'tcx>,\n-                        expr_id: ast::NodeId)\n-                        -> Result<Def, MethodError<'tcx>> {\n-        debug!(\"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\",\n-            method_name,\n-            self_ty,\n-            expr_id\n+    pub fn resolve_ufcs(\n+        &self,\n+        span: Span,\n+        method_name: ast::Ident,\n+        self_ty: Ty<'tcx>,\n+        expr_id: ast::NodeId\n+    ) -> Result<Def, MethodError<'tcx>> {\n+        debug!(\n+            \"resolve_ufcs: method_name={:?} self_ty={:?} expr_id={:?}\",\n+            method_name, self_ty, expr_id,\n         );\n \n         let tcx = self.tcx;\n@@ -375,6 +375,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         match self.probe_for_name(span, mode, method_name, IsSuggestion(false),\n                                   self_ty, expr_id, ProbeScope::TraitsInScope) {\n             Ok(pick) => {\n+                debug!(\"resolve_ufcs: pick={:?}\", pick);\n                 if let Some(import_id) = pick.import_id {\n                     let import_def_id = tcx.hir().local_def_id(import_id);\n                     debug!(\"resolve_ufcs: used_trait_import: {:?}\", import_def_id);\n@@ -383,6 +384,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 let def = pick.item.def();\n+                debug!(\"resolve_ufcs: def={:?}\", def);\n                 tcx.check_stability(def.def_id(), Some(expr_id), span);\n \n                 Ok(def)"}, {"sha": "d78d7273a36e6193894cdeaca5fb72b62daf8165", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 45, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -102,13 +102,14 @@ use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::mir::interpret::{ConstValue, GlobalId};\n use rustc::traits::{self, ObligationCause, ObligationCauseCode, TraitEngine};\n-use rustc::ty::{self, AdtKind, Ty, TyCtxt, GenericParamDefKind, RegionKind, Visibility,\n-                ToPolyTraitRef, ToPredicate};\n+use rustc::ty::{\n+    self, AdtKind, CanonicalUserTypeAnnotation, Ty, TyCtxt, GenericParamDefKind, Visibility,\n+    ToPolyTraitRef, ToPredicate, RegionKind, UserTypeAnnotation\n+};\n use rustc::ty::adjustment::{Adjust, Adjustment, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::query::Providers;\n-use rustc::ty::subst::{CanonicalUserSubsts, UnpackedKind, Subst, Substs,\n-                       UserSelfTy, UserSubsts};\n+use rustc::ty::subst::{UnpackedKind, Subst, Substs, UserSelfTy, UserSubsts};\n use rustc::ty::util::{Representability, IntTypeExt, Discr};\n use rustc::ty::layout::VariantIdx;\n use syntax_pos::{self, BytePos, Span, MultiSpan};\n@@ -974,10 +975,12 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n                     o_ty\n                 };\n \n-                let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(&revealed_ty);\n+                let c_ty = self.fcx.inh.infcx.canonicalize_user_type_annotation(\n+                    &UserTypeAnnotation::Ty(revealed_ty)\n+                );\n                 debug!(\"visit_local: ty.hir_id={:?} o_ty={:?} revealed_ty={:?} c_ty={:?}\",\n                        ty.hir_id, o_ty, revealed_ty, c_ty);\n-                self.fcx.tables.borrow_mut().user_provided_tys_mut().insert(ty.hir_id, c_ty);\n+                self.fcx.tables.borrow_mut().user_provided_types_mut().insert(ty.hir_id, c_ty);\n \n                 Some(LocalTy { decl_ty: o_ty, revealed_ty })\n             },\n@@ -2108,8 +2111,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.tables.borrow_mut().field_indices_mut().insert(hir_id, index);\n     }\n \n-    // The NodeId and the ItemLocalId must identify the same item. We just pass\n-    // both of them for consistency checking.\n     pub fn write_method_call(&self,\n                              hir_id: hir::HirId,\n                              method: MethodCallee<'tcx>) {\n@@ -2138,23 +2139,27 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if !method.substs.is_noop() {\n             let method_generics = self.tcx.generics_of(method.def_id);\n             if !method_generics.params.is_empty() {\n-                let user_substs = self.infcx.probe(|_| {\n-                    let just_method_substs = Substs::for_item(self.tcx, method.def_id, |param, _| {\n-                        let i = param.index as usize;\n-                        if i < method_generics.parent_count {\n-                            self.infcx.var_for_def(DUMMY_SP, param)\n-                        } else {\n-                            method.substs[i]\n-                        }\n-                    });\n-                    self.infcx.canonicalize_user_type_annotation(&UserSubsts {\n-                        substs: just_method_substs,\n+                let user_type_annotation = self.infcx.probe(|_| {\n+                    let user_substs = UserSubsts {\n+                        substs: Substs::for_item(self.tcx, method.def_id, |param, _| {\n+                            let i = param.index as usize;\n+                            if i < method_generics.parent_count {\n+                                self.infcx.var_for_def(DUMMY_SP, param)\n+                            } else {\n+                                method.substs[i]\n+                            }\n+                        }),\n                         user_self_ty: None, // not relevant here\n-                    })\n+                    };\n+\n+                    self.infcx.canonicalize_user_type_annotation(&UserTypeAnnotation::TypeOf(\n+                        method.def_id,\n+                        user_substs,\n+                    ))\n                 });\n \n-                debug!(\"write_method_call: user_substs = {:?}\", user_substs);\n-                self.write_user_substs(hir_id, user_substs);\n+                debug!(\"write_method_call: user_type_annotation={:?}\", user_type_annotation);\n+                self.write_user_type_annotation(hir_id, user_type_annotation);\n             }\n         }\n     }\n@@ -2177,41 +2182,47 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// This should be invoked **before any unifications have\n     /// occurred**, so that annotations like `Vec<_>` are preserved\n     /// properly.\n-    pub fn write_user_substs_from_substs(\n+    pub fn write_user_type_annotation_from_substs(\n         &self,\n         hir_id: hir::HirId,\n+        def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n         user_self_ty: Option<UserSelfTy<'tcx>>,\n     ) {\n         debug!(\n-            \"write_user_substs_from_substs({:?}, {:?}) in fcx {}\",\n-            hir_id,\n-            substs,\n-            self.tag(),\n+            \"write_user_type_annotation_from_substs: hir_id={:?} def_id={:?} substs={:?} \\\n+             user_self_ty={:?} in fcx {}\",\n+            hir_id, def_id, substs, user_self_ty, self.tag(),\n         );\n \n         if !substs.is_noop() {\n-            let user_substs = self.infcx.canonicalize_user_type_annotation(&UserSubsts {\n-                substs,\n-                user_self_ty,\n-            });\n-            debug!(\"instantiate_value_path: user_substs = {:?}\", user_substs);\n-            self.write_user_substs(hir_id, user_substs);\n+            let canonicalized = self.infcx.canonicalize_user_type_annotation(\n+                &UserTypeAnnotation::TypeOf(def_id, UserSubsts {\n+                    substs,\n+                    user_self_ty,\n+                })\n+            );\n+            debug!(\"write_user_type_annotation_from_substs: canonicalized={:?}\", canonicalized);\n+            self.write_user_type_annotation(hir_id, canonicalized);\n         }\n     }\n \n-    pub fn write_user_substs(&self, hir_id: hir::HirId, substs: CanonicalUserSubsts<'tcx>) {\n+    pub fn write_user_type_annotation(\n+        &self,\n+        hir_id: hir::HirId,\n+        canonical_user_type_annotation: CanonicalUserTypeAnnotation<'tcx>,\n+    ) {\n         debug!(\n-            \"write_user_substs({:?}, {:?}) in fcx {}\",\n-            hir_id,\n-            substs,\n-            self.tag(),\n+            \"write_user_type_annotation: hir_id={:?} canonical_user_type_annotation={:?} tag={}\",\n+            hir_id, canonical_user_type_annotation, self.tag(),\n         );\n \n-        if !substs.is_identity() {\n-            self.tables.borrow_mut().user_substs_mut().insert(hir_id, substs);\n+        if !canonical_user_type_annotation.is_identity() {\n+            self.tables.borrow_mut().user_provided_types_mut().insert(\n+                hir_id, canonical_user_type_annotation\n+            );\n         } else {\n-            debug!(\"write_user_substs: skipping identity substs\");\n+            debug!(\"write_user_type_annotation: skipping identity substs\");\n         }\n     }\n \n@@ -2377,6 +2388,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn to_ty_saving_user_provided_ty(&self, ast_ty: &hir::Ty) -> Ty<'tcx> {\n         let ty = self.to_ty(ast_ty);\n+        debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n         // If the type given by the user has free regions, save it for\n         // later, since NLL would like to enforce those. Also pass in\n@@ -2386,8 +2398,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // although I have my doubts). Other sorts of things are\n         // already sufficiently enforced with erased regions. =)\n         if ty.has_free_regions() || ty.has_projections() {\n-            let c_ty = self.infcx.canonicalize_response(&ty);\n-            self.tables.borrow_mut().user_provided_tys_mut().insert(ast_ty.hir_id, c_ty);\n+            let c_ty = self.infcx.canonicalize_response(&UserTypeAnnotation::Ty(ty));\n+            debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n+            self.tables.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n         }\n \n         ty\n@@ -3742,7 +3755,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         if let Some((variant, did, substs)) = variant {\n             debug!(\"check_struct_path: did={:?} substs={:?}\", did, substs);\n             let hir_id = self.tcx.hir().node_to_hir_id(node_id);\n-            self.write_user_substs_from_substs(hir_id, substs, None);\n+            self.write_user_type_annotation_from_substs(hir_id, did, substs, None);\n \n             // Check bounds on type arguments used in the path.\n             let bounds = self.instantiate_bounds(path_span, did, substs);\n@@ -4581,6 +4594,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                        span: Span)\n                                        -> (Def, Option<Ty<'tcx>>, &'b [hir::PathSegment])\n     {\n+        debug!(\"resolve_ty_and_def_ufcs: qpath={:?} node_id={:?} span={:?}\", qpath, node_id, span);\n         let (ty, qself, item_segment) = match *qpath {\n             QPath::Resolved(ref opt_qself, ref path) => {\n                 return (path.def,\n@@ -5101,6 +5115,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             Def::Method(def_id) |\n             Def::AssociatedConst(def_id) => {\n                 let container = tcx.associated_item(def_id).container;\n+                debug!(\"instantiate_value_path: def={:?} container={:?}\", def, container);\n                 match container {\n                     ty::TraitContainer(trait_did) => {\n                         callee::check_legal_trait_for_method_call(tcx, span, trait_did)\n@@ -5300,7 +5315,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // First, store the \"user substs\" for later.\n         let hir_id = tcx.hir().node_to_hir_id(node_id);\n-        self.write_user_substs_from_substs(hir_id, substs, user_self_ty);\n+        self.write_user_type_annotation_from_substs(hir_id, def_id, substs, user_self_ty);\n \n         // Add all the obligations that are required, substituting and\n         // normalized appropriately."}, {"sha": "38de936a027ff6e2dd4e28ddb2d70812ea138744", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -3,6 +3,7 @@\n // substitutions.\n \n use check::FnCtxt;\n+use errors::DiagnosticBuilder;\n use rustc::hir;\n use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n@@ -357,7 +358,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         debug_assert_eq!(fcx_tables.local_id_root, self.tables.local_id_root);\n         let common_local_id_root = fcx_tables.local_id_root.unwrap();\n \n-        for (&local_id, c_ty) in fcx_tables.user_provided_tys().iter() {\n+        let mut errors_buffer = Vec::new();\n+        for (&local_id, c_ty) in fcx_tables.user_provided_types().iter() {\n             let hir_id = hir::HirId {\n                 owner: common_local_id_root.index,\n                 local_id,\n@@ -374,8 +376,30 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             };\n \n             self.tables\n-                .user_provided_tys_mut()\n+                .user_provided_types_mut()\n                 .insert(hir_id, c_ty.clone());\n+\n+            if let ty::UserTypeAnnotation::TypeOf(_, user_substs) = c_ty.value {\n+                if self.rustc_dump_user_substs {\n+                    // This is a unit-testing mechanism.\n+                    let node_id = self.tcx().hir().hir_to_node_id(hir_id);\n+                    let span = self.tcx().hir().span(node_id);\n+                    // We need to buffer the errors in order to guarantee a consistent\n+                    // order when emitting them.\n+                    let err = self.tcx().sess.struct_span_err(\n+                        span,\n+                        &format!(\"user substs: {:?}\", user_substs)\n+                    );\n+                    err.buffer(&mut errors_buffer);\n+                }\n+            }\n+        }\n+\n+        if !errors_buffer.is_empty() {\n+            errors_buffer.sort_by_key(|diag| diag.span.primary_span());\n+            for diag in errors_buffer.drain(..) {\n+                DiagnosticBuilder::new_diagnostic(self.tcx().sess.diagnostic(), diag).emit();\n+            }\n         }\n     }\n \n@@ -573,22 +597,6 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n             assert!(!substs.needs_infer() && !substs.has_placeholders());\n             self.tables.node_substs_mut().insert(hir_id, substs);\n         }\n-\n-        // Copy over any user-substs\n-        if let Some(user_substs) = self.fcx.tables.borrow().user_substs(hir_id) {\n-            let user_substs = self.tcx().lift_to_global(&user_substs).unwrap();\n-            self.tables.user_substs_mut().insert(hir_id, user_substs);\n-\n-            // Unit-testing mechanism:\n-            if self.rustc_dump_user_substs {\n-                let node_id = self.tcx().hir().hir_to_node_id(hir_id);\n-                let span = self.tcx().hir().span(node_id);\n-                self.tcx().sess.span_err(\n-                    span,\n-                    &format!(\"user substs: {:?}\", user_substs),\n-                );\n-            }\n-        }\n     }\n \n     fn visit_adjustments(&mut self, span: Span, hir_id: hir::HirId) {"}, {"sha": "b6050f059c27bc6e5614bfa7a8ae544228b9aa1d", "filename": "src/test/incremental/hashes/let_expressions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Flet_expressions.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -70,7 +70,7 @@ pub fn change_mutability_of_reference_type() {\n \n #[cfg(not(cfail1))]\n #[rustc_clean(cfg=\"cfail2\",\n-    except=\"HirBody,TypeckTables,MirValidated\")]\n+    except=\"HirBody,TypeckTables,MirValidated,MirOptimized\")]\n #[rustc_clean(cfg=\"cfail3\")]\n pub fn change_mutability_of_reference_type() {\n     let _x: &mut u64;"}, {"sha": "88fd53d4ba59d3feb878618276ba80d84ac67272", "filename": "src/test/mir-opt/basic_assignment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fbasic_assignment.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -37,7 +37,7 @@ fn main() {\n //        StorageLive(_4);\n //        _4 = std::option::Option<std::boxed::Box<u32>>::None;\n //        FakeRead(ForLet, _4);\n-//        AscribeUserType(_4, o, UserTypeProjection { base: Ty(Canonical { max_universe: U0, variables: [], value: std::option::Option<std::boxed::Box<u32>> }), projs: [] });\n+//        AscribeUserType(_4, o, UserTypeProjection { base: UserTypeAnnotation(1), projs: [] });\n //        StorageLive(_5);\n //        StorageLive(_6);\n //        _6 = move _4;"}, {"sha": "4801369cfd1a8a3ffeb0fba3aaaa17f829669c56", "filename": "src/test/run-pass/associated-consts/associated-const-range-match-patterns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-range-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-range-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-consts%2Fassociated-const-range-match-patterns.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -1,5 +1,5 @@\n // run-pass\n-#![allow(dead_code)]\n+#![allow(dead_code, unreachable_patterns)]\n \n struct Foo;\n "}, {"sha": "7750e3403619288b0f44a332799ebc97c7e25c80", "filename": "src/test/ui/issue-54943-1.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-54943-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-54943-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943-1.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -0,0 +1,15 @@\n+#![feature(nll)]\n+\n+// This test is a minimal version of an ICE in the dropck-eyepatch tests\n+// found in the fix for #54943.\n+\n+// compile-pass\n+\n+fn foo<T>(_t: T) {\n+}\n+\n+fn main() {\n+    struct A<'a, B: 'a>(&'a B);\n+    let (a1, a2): (String, A<_>) = (String::from(\"auto\"), A(&\"this\"));\n+    foo((a1, a2));\n+}"}, {"sha": "f829c38c35d23638963114e4bc92fbe043512d9f", "filename": "src/test/ui/issue-54943-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-54943-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-54943-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943-2.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -0,0 +1,18 @@\n+#![feature(nll)]\n+\n+// This test is a minimal version of an ICE in the dropck-eyepatch tests\n+// found in the fix for #54943. In particular, this test is in unreachable\n+// code as the initial fix for this ICE only worked if the code was reachable.\n+\n+// compile-pass\n+\n+fn foo<T>(_t: T) {\n+}\n+\n+fn main() {\n+    return;\n+\n+    struct A<'a, B: 'a>(&'a B);\n+    let (a1, a2): (String, A<_>) = (String::from(\"auto\"), A(&\"this\"));\n+    foo((a1, a2));\n+}"}, {"sha": "185077bd684a87ecaac408212899eaeba80a8188", "filename": "src/test/ui/issue-54943-3.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-54943-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-54943-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943-3.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -0,0 +1,21 @@\n+// compile-pass\n+// FIXME(#54943) This test targets the scenario where proving the WF requirements requires\n+// knowing the value of the `_` type present in the user type annotation - unfortunately, figuring\n+// out the value of that `_` requires type-checking the surrounding code, but that code is dead,\n+// so our NLL region checker doesn't have access to it. This test should actually fail to compile.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+use std::fmt::Debug;\n+\n+fn foo<T: 'static + Debug>(_: T) { }\n+\n+fn bar<'a>() {\n+    return;\n+\n+    let _x = foo::<Vec<_>>(Vec::<&'a u32>::new());\n+    //~^ ERROR the type `&'a u32` does not fulfill the required lifetime [E0477]\n+}\n+\n+fn main() {}"}, {"sha": "c720f6279758068643488b9a43fcc873358840eb", "filename": "src/test/ui/issue-54943.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-54943.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-54943.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-54943.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -0,0 +1,17 @@\n+// compile-pass\n+// FIXME(#54943) This test targets the scenario where proving the WF requirements of a user\n+// type annotation requires checking dead code. This test should actually fail to compile.\n+\n+#![feature(nll)]\n+#![allow(warnings)]\n+\n+fn foo<T: 'static>() { }\n+\n+fn boo<'a>() {\n+    return;\n+\n+    let x = foo::<&'a u32>();\n+    //~^ ERROR the type `&'a u32` does not fulfill the required lifetime [E0477]\n+}\n+\n+fn main() {}"}, {"sha": "bf3e58e8cdb19b1c5cfea5247b1bba8e6cc4af73", "filename": "src/test/ui/issue-55511.nll.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-55511.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-55511.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-55511.nll.stderr?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -0,0 +1,15 @@\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/issue-55511.rs:13:28\n+   |\n+LL |     let b = Some(Cell::new(&a));\n+   |                            ^^ borrowed value does not live long enough\n+...\n+LL |         <() as Foo<'static>>::C => { }\n+   |         ----------------------- type annotation requires that `a` is borrowed for `'static`\n+...\n+LL | }\n+   | - `a` dropped here while still borrowed\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "4b9475ba627183092b85f9a2d406018893c8c6ed", "filename": "src/test/ui/issue-55511.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-55511.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-55511.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-55511.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -0,0 +1,19 @@\n+use std::cell::Cell;\n+\n+trait Foo<'a> {\n+    const C: Option<Cell<&'a u32>>;\n+}\n+\n+impl<'a, T> Foo<'a> for T {\n+    const C: Option<Cell<&'a u32>> = None;\n+}\n+\n+fn main() {\n+    let a = 22;\n+    let b = Some(Cell::new(&a));\n+    //~^ ERROR `a` does not live long enough [E0597]\n+    match b {\n+        <() as Foo<'static>>::C => { }\n+        _ => { }\n+    }\n+}"}, {"sha": "24668f045517ac828cb16ae9a63e452a87a2a70b", "filename": "src/test/ui/issue-55511.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-55511.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fissue-55511.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-55511.stderr?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -0,0 +1,14 @@\n+error[E0597]: `a` does not live long enough\n+  --> $DIR/issue-55511.rs:13:29\n+   |\n+LL |     let b = Some(Cell::new(&a));\n+   |                             ^ borrowed value does not live long enough\n+...\n+LL | }\n+   | - borrowed value only lives until here\n+   |\n+   = note: borrowed value must be valid for the static lifetime...\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0597`."}, {"sha": "2fa234491087d679d10cfe68653575753d3ea00d", "filename": "src/test/ui/nll/issue-55401.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fnll%2Fissue-55401.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fnll%2Fissue-55401.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55401.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -0,0 +1,8 @@\n+#![feature(nll)]\n+\n+fn static_to_a_to_static_through_ref_in_tuple<'a>(x: &'a u32) -> &'static u32 {\n+    let (ref y, _z): (&'a u32, u32) = (&22, 44);\n+    *y //~ ERROR\n+}\n+\n+fn main() {}"}, {"sha": "9e50db7b6045da374bd9591227b755edec3593cc", "filename": "src/test/ui/nll/issue-55401.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fnll%2Fissue-55401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fnll%2Fissue-55401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55401.stderr?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -0,0 +1,11 @@\n+error: unsatisfied lifetime constraints\n+  --> $DIR/issue-55401.rs:5:5\n+   |\n+LL | fn static_to_a_to_static_through_ref_in_tuple<'a>(x: &'a u32) -> &'static u32 {\n+   |                                               -- lifetime `'a` defined here\n+LL |     let (ref y, _z): (&'a u32, u32) = (&22, 44);\n+LL |     *y //~ ERROR\n+   |     ^^ returning this value requires that `'a` must outlive `'static`\n+\n+error: aborting due to previous error\n+"}, {"sha": "123c26195d006aadda51d2ec790a201e0f905caf", "filename": "src/test/ui/nll/user-annotations/dump-adt-brace-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-adt-brace-struct.stderr?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -1,4 +1,4 @@\n-error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [u32], user_self_ty: None }\n   --> $DIR/dump-adt-brace-struct.rs:18:5\n    |\n LL |     SomeStruct::<u32> { t: 22 }; //~ ERROR [u32]"}, {"sha": "a1a4e43e8a3e9484fc08fab35368d9b2ad313b87", "filename": "src/test/ui/nll/user-annotations/dump-fn-method.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fdump-fn-method.stderr?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -1,22 +1,22 @@\n-error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u32], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [u32], user_self_ty: None }\n   --> $DIR/dump-fn-method.rs:26:13\n    |\n LL |     let x = foo::<u32>; //~ ERROR [u32]\n    |             ^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }, CanonicalVarInfo { kind: Ty(General(U0)) }], value: UserSubsts { substs: [^0, u32, ^1], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [^0, u32, ^1], user_self_ty: None }\n   --> $DIR/dump-fn-method.rs:32:13\n    |\n LL |     let x = <_ as Bazoom<u32>>::method::<_>; //~ ERROR [^0, u32, ^1]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [], value: UserSubsts { substs: [u8, u16, u32], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [u8, u16, u32], user_self_ty: None }\n   --> $DIR/dump-fn-method.rs:36:13\n    |\n LL |     let x = <u8 as Bazoom<u16>>::method::<u32>; //~ ERROR [u8, u16, u32]\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: user substs: Canonical { max_universe: U0, variables: [CanonicalVarInfo { kind: Ty(General(U0)) }, CanonicalVarInfo { kind: Ty(General(U0)) }], value: UserSubsts { substs: [^0, ^1, u32], user_self_ty: None } }\n+error: user substs: UserSubsts { substs: [^0, ^1, u32], user_self_ty: None }\n   --> $DIR/dump-fn-method.rs:44:5\n    |\n LL |     y.method::<u32>(44, 66); //~ ERROR [^0, ^1, u32]"}, {"sha": "91a0d8590ff341e92ff00efaeda65f9dc511f717", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.rs?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -31,9 +31,7 @@ fn with_assoc<'a,'b>() {\n     // outlive 'a. In this case, that means TheType<'b>::TheAssocType,\n     // which is &'b (), must outlive 'a.\n \n-    // FIXME (#54943) NLL doesn't enforce WF condition in unreachable code if\n-    // `_x` is changed to `_`\n-    let _x: &'a WithAssoc<TheType<'b>> = loop { };\n+    let _: &'a WithAssoc<TheType<'b>> = loop { };\n     //~^ ERROR reference has a longer lifetime\n }\n "}, {"sha": "0d73d3d64322e0e69e0631d7cb7930819a4dac24", "filename": "src/test/ui/regions/regions-outlives-projection-container-wc.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/cae164753f557f668cb75610abda4f790981e5e6/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-outlives-projection-container-wc.stderr?ref=cae164753f557f668cb75610abda4f790981e5e6", "patch": "@@ -1,8 +1,8 @@\n error[E0491]: in type `&'a WithAssoc<TheType<'b>>`, reference has a longer lifetime than the data it references\n-  --> $DIR/regions-outlives-projection-container-wc.rs:36:13\n+  --> $DIR/regions-outlives-projection-container-wc.rs:34:12\n    |\n-LL |     let _x: &'a WithAssoc<TheType<'b>> = loop { };\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     let _: &'a WithAssoc<TheType<'b>> = loop { };\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: the pointer is valid for the lifetime 'a as defined on the function body at 28:15\n   --> $DIR/regions-outlives-projection-container-wc.rs:28:15"}]}