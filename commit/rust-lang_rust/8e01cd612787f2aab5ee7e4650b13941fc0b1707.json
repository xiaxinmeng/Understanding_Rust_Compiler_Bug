{"sha": "8e01cd612787f2aab5ee7e4650b13941fc0b1707", "node_id": "C_kwDOAAsO6NoAKDhlMDFjZDYxMjc4N2YyYWFiNWVlN2U0NjUwYjEzOTQxZmMwYjE3MDc", "commit": {"author": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-03-25T06:17:05Z"}, "committer": {"name": "Jakob Degen", "email": "jakob.e.degen@gmail.com", "date": "2022-04-11T19:22:29Z"}, "message": "Improve documentation for MIR statement kinds.", "tree": {"sha": "cd8eb7c27751fc1dacf088012e3826d3b313a953", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd8eb7c27751fc1dacf088012e3826d3b313a953"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e01cd612787f2aab5ee7e4650b13941fc0b1707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e01cd612787f2aab5ee7e4650b13941fc0b1707", "html_url": "https://github.com/rust-lang/rust/commit/8e01cd612787f2aab5ee7e4650b13941fc0b1707", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e01cd612787f2aab5ee7e4650b13941fc0b1707/comments", "author": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "JakobDegen", "id": 51179609, "node_id": "MDQ6VXNlcjUxMTc5NjA5", "avatar_url": "https://avatars.githubusercontent.com/u/51179609?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JakobDegen", "html_url": "https://github.com/JakobDegen", "followers_url": "https://api.github.com/users/JakobDegen/followers", "following_url": "https://api.github.com/users/JakobDegen/following{/other_user}", "gists_url": "https://api.github.com/users/JakobDegen/gists{/gist_id}", "starred_url": "https://api.github.com/users/JakobDegen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JakobDegen/subscriptions", "organizations_url": "https://api.github.com/users/JakobDegen/orgs", "repos_url": "https://api.github.com/users/JakobDegen/repos", "events_url": "https://api.github.com/users/JakobDegen/events{/privacy}", "received_events_url": "https://api.github.com/users/JakobDegen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ac5e986ed8e7d589787532857ef74576473adcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ac5e986ed8e7d589787532857ef74576473adcf", "html_url": "https://github.com/rust-lang/rust/commit/9ac5e986ed8e7d589787532857ef74576473adcf"}], "stats": {"total": 92, "additions": 76, "deletions": 16}, "files": [{"sha": "a01261c543ba671300f93fcdb6ac85865bd60add", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 76, "deletions": 16, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8e01cd612787f2aab5ee7e4650b13941fc0b1707/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e01cd612787f2aab5ee7e4650b13941fc0b1707/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=8e01cd612787f2aab5ee7e4650b13941fc0b1707", "patch": "@@ -1573,18 +1573,44 @@ impl Statement<'_> {\n /// causing an ICE if they are violated.\n #[derive(Clone, Debug, PartialEq, TyEncodable, TyDecodable, Hash, HashStable, TypeFoldable)]\n pub enum StatementKind<'tcx> {\n-    /// Write the RHS Rvalue to the LHS Place.\n+    /// Assign statements roughly correspond to an assignment in Rust proper (`x = ...`) except\n+    /// without the possibility of dropping the previous value (that must be done separately, if at\n+    /// all). The *exact* way this works is undecided. It probably does something like evaluating\n+    /// the LHS and RHS, and then doing the inverse of a place to value conversion to write the\n+    /// resulting value into memory. Various parts of this may do type specific things that are more\n+    /// complicated than simply copying over the bytes depending on the types.\n     ///\n-    /// The LHS place may not overlap with any memory accessed on the RHS.\n+    /// **Needs clarification**: The implication of the above idea would be that assignment implies\n+    /// that the resulting value is initialized. I believe we could commit to this separately from\n+    /// committing to whatever part of the memory model we would need to decide on to make the above\n+    /// paragragh precise. Do we want to?\n+    ///\n+    /// Assignments in which the types of the place and rvalue differ are not well-formed.\n+    ///\n+    /// **Needs clarification**: Do we ever want to worry about non-free (in the body) lifetimes for\n+    /// the typing requirement in post drop-elaboration MIR? I think probably not - I'm not sure we\n+    /// could meaningfully require this anyway. How about free lifetimes? Is ignoring this\n+    /// interesting for optimizations? Do we want to allow such optimizations?\n+    ///\n+    /// **Needs clarification**: We currently require that the LHS place not overlap with any place\n+    /// read as part of computation of the RHS. This requirement is under discussion in [#68364]. As\n+    /// a part of this discussion, it is also unclear in what order the components are evaluated.\n+    ///\n+    /// [#68364]: https://github.com/rust-lang/rust/issues/68364\n+    ///\n+    /// See [`Rvalue`] documentation for details on each of those.\n     Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n \n-    /// This represents all the reading that a pattern match may do\n-    /// (e.g., inspecting constants and discriminant values), and the\n-    /// kind of pattern it comes from. This is in order to adapt potential\n-    /// error messages to these specific patterns.\n+    /// This represents all the reading that a pattern match may do (e.g., inspecting constants and\n+    /// discriminant values), and the kind of pattern it comes from. This is in order to adapt\n+    /// potential error messages to these specific patterns.\n     ///\n     /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n     /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n+    ///\n+    /// When executed at runtime this is a nop.\n+    ///\n+    /// Disallowed after drop elaboration.\n     FakeRead(Box<(FakeReadCause, Place<'tcx>)>),\n \n     /// Write the discriminant for a variant to the enum Place.\n@@ -1599,17 +1625,36 @@ pub enum StatementKind<'tcx> {\n     /// This writes `uninit` bytes to the entire place.\n     Deinit(Box<Place<'tcx>>),\n \n-    /// Start a live range for the storage of the local.\n+    /// `StorageLive` and `StorageDead` statements mark the live range of a local.\n+    ///\n+    /// Using a local before a `StorageLive` or after a `StorageDead` is not well-formed. These\n+    /// statements are not required. If the entire MIR body contains no `StorageLive`/`StorageDead`\n+    /// statements for a particular local, the local is always considered live.\n+    ///\n+    /// More precisely, the MIR validator currently does a `MaybeLiveLocals` analysis to check\n+    /// validity of each use of a local. I believe this is equivalent to requiring for every use of\n+    /// a local, there exist at least one path from the root to that use that contains a\n+    /// `StorageLive` more recently than a `StorageDead`.\n+    ///\n+    /// **Needs clarification**: Is it permitted to `StorageLive` a local for which we previously\n+    /// executed `StorageDead`? How about two `StorageLive`s without an intervening `StorageDead`?\n+    /// Two `StorageDead`s without an intervening `StorageLive`? LLVM says yes, poison, yes. If the\n+    /// answer to any of these is \"no,\" is breaking that rule UB or is it an error to have a path in\n+    /// the CFG that might do this?\n     StorageLive(Local),\n \n-    /// End the current live range for the storage of the local.\n+    /// See `StorageLive` above.\n     StorageDead(Local),\n \n-    /// Retag references in the given place, ensuring they got fresh tags. This is\n-    /// part of the Stacked Borrows model. These statements are currently only interpreted\n-    /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n-    /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n-    /// for more details.\n+    /// Retag references in the given place, ensuring they got fresh tags.\n+    ///\n+    /// This is part of the Stacked Borrows model. These statements are currently only interpreted\n+    /// by miri and only generated when `-Z mir-emit-retag` is passed. See\n+    /// <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/> for\n+    /// more details.\n+    ///\n+    /// For code that is not specific to stacked borrows, you should consider statements to read\n+    /// and modify the place in an opaque way.\n     Retag(RetagKind, Box<Place<'tcx>>),\n \n     /// Encodes a user's type ascription. These need to be preserved\n@@ -1624,6 +1669,10 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n+    ///\n+    /// When executed at runtime this is a nop.\n+    ///\n+    /// Disallowed after drop elaboration.\n     AscribeUserType(Box<(Place<'tcx>, UserTypeProjection)>, ty::Variance),\n \n     /// Marks the start of a \"coverage region\", injected with '-Cinstrument-coverage'. A\n@@ -1633,9 +1682,20 @@ pub enum StatementKind<'tcx> {\n     /// executed.\n     Coverage(Box<Coverage>),\n \n-    /// Denotes a call to the intrinsic function copy_overlapping, where `src_dst` denotes the\n-    /// memory being read from and written to(one field to save memory), and size\n-    /// indicates how many bytes are being copied over.\n+    /// Denotes a call to the intrinsic function `copy_overlapping`.\n+    ///\n+    /// First, all three operands are evaluated. `src` and `dest` must each be a reference, pointer,\n+    /// or `Box` pointing to the same type `T`. `count` must evaluate to a `usize`. Then, `src` and\n+    /// `dest` are dereferenced, and `count * size_of::<T>()` bytes beginning with the first byte of\n+    /// the `src` place are copied to the continguous range of bytes beginning with the first byte\n+    /// of `dest`.\n+    ///\n+    /// **Needs clarification**: In what order are operands computed and dereferenced? It should\n+    /// probably match the order for assignment, but that is also undecided.\n+    ///\n+    /// **Needs clarification**: Is this typed or not, ie is there a place to value and back\n+    /// conversion involved? I vaguely remember Ralf saying somewhere that he thought it should not\n+    /// be.\n     CopyNonOverlapping(Box<CopyNonOverlapping<'tcx>>),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices."}]}