{"sha": "0383be8577adfa0c1b8e17887eae2fcc54eab81a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzODNiZTg1NzdhZGZhMGMxYjhlMTc4ODdlYWUyZmNjNTRlYWI4MWE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-06T00:37:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-06T00:37:58Z"}, "message": "Rollup merge of #62264 - RalfJung:inline-forcing, r=zackmdavis\n\nFix perf regression from Miri Machine trait changes\n\nMaybe this fixes the perf regression that https://github.com/rust-lang/rust/pull/62003 seemingly introduced?\n\nCc @nnethercote", "tree": {"sha": "49c96816e4609e36e222e15ee2b34d447992f3ce", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49c96816e4609e36e222e15ee2b34d447992f3ce"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0383be8577adfa0c1b8e17887eae2fcc54eab81a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdH+1mCRBK7hj4Ov3rIwAAdHIIAFfkTb7Qx++m9FJgPlRfC0nO\nd3XqI2JGkBYzJURB11nWDdLo/qobu6TQZk5sA99ruW2N84B1olFgOZlEzt0xkBOs\n/sA0LGiK0Gh8X3efnq+9pV1gYLLq6nDs+O+/ttzJndzik9tCqOrOOhZC1f+Lr7VF\nesbv313R1wu1D/0Q4PfjxI2kwiz5pmaf7s/TaApgiNdPc+6ZxZUE/eVgFb/W5XBI\nXOPOdOvtmyjusKdWp4Dn+TLCktt8FVRkKOfNi4eDw6ifKdCwWUkEzXeOmzywFZp1\nGzpdi2pcRHpqTBpoL08XtMdXiAQwv4vew8wYZQhwBWouo86mta30N/sXaU8bfB4=\n=VDL4\n-----END PGP SIGNATURE-----\n", "payload": "tree 49c96816e4609e36e222e15ee2b34d447992f3ce\nparent 947d7cf16db583bae255260696f022fb0e7ea4db\nparent 52e6f859f176e860ce8fbe479c991c8037e8a05a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562373478 +0200\ncommitter GitHub <noreply@github.com> 1562373478 +0200\n\nRollup merge of #62264 - RalfJung:inline-forcing, r=zackmdavis\n\nFix perf regression from Miri Machine trait changes\n\nMaybe this fixes the perf regression that https://github.com/rust-lang/rust/pull/62003 seemingly introduced?\n\nCc @nnethercote\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0383be8577adfa0c1b8e17887eae2fcc54eab81a", "html_url": "https://github.com/rust-lang/rust/commit/0383be8577adfa0c1b8e17887eae2fcc54eab81a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0383be8577adfa0c1b8e17887eae2fcc54eab81a/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "947d7cf16db583bae255260696f022fb0e7ea4db", "url": "https://api.github.com/repos/rust-lang/rust/commits/947d7cf16db583bae255260696f022fb0e7ea4db", "html_url": "https://github.com/rust-lang/rust/commit/947d7cf16db583bae255260696f022fb0e7ea4db"}, {"sha": "52e6f859f176e860ce8fbe479c991c8037e8a05a", "url": "https://api.github.com/repos/rust-lang/rust/commits/52e6f859f176e860ce8fbe479c991c8037e8a05a", "html_url": "https://github.com/rust-lang/rust/commit/52e6f859f176e860ce8fbe479c991c8037e8a05a"}], "stats": {"total": 132, "additions": 68, "deletions": 64}, "files": [{"sha": "f8de1cfaea0980361e6b770489c59a2a02e1a22d", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0383be8577adfa0c1b8e17887eae2fcc54eab81a/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0383be8577adfa0c1b8e17887eae2fcc54eab81a/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=0383be8577adfa0c1b8e17887eae2fcc54eab81a", "patch": "@@ -11,7 +11,7 @@ use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n@@ -23,7 +23,7 @@ use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n     InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpCx, StackPopCleanup,\n-    Allocation, AllocId, MemoryKind, Memory,\n+    Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n };\n \n@@ -409,27 +409,27 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn find_foreign_static(\n+        _tcx: TyCtxt<'tcx>,\n         _def_id: DefId,\n-        _tcx: TyCtxtAt<'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n         err!(ReadForeignStatic)\n     }\n \n     #[inline(always)]\n     fn tag_allocation<'b>(\n+        _memory_extra: &(),\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<!>>,\n-        _memory: &Memory<'mir, 'tcx, Self>,\n     ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n         // We do not use a tag so we can just cheaply forward the allocation\n         (alloc, ())\n     }\n \n     #[inline(always)]\n     fn tag_static_base_pointer(\n+        _memory_extra: &(),\n         _id: AllocId,\n-        _memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag {\n         ()\n     }"}, {"sha": "007ec8cb2db5c50ff070f73bc21511bd2bdf4d8a", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0383be8577adfa0c1b8e17887eae2fcc54eab81a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0383be8577adfa0c1b8e17887eae2fcc54eab81a/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=0383be8577adfa0c1b8e17887eae2fcc54eab81a", "patch": "@@ -222,6 +222,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self.memory\n     }\n \n+    #[inline(always)]\n+    pub fn force_ptr(\n+        &self,\n+        scalar: Scalar<M::PointerTag>,\n+    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+        self.memory.force_ptr(scalar)\n+    }\n+\n+    #[inline(always)]\n+    pub fn force_bits(\n+        &self,\n+        scalar: Scalar<M::PointerTag>,\n+        size: Size\n+    ) -> InterpResult<'tcx, u128> {\n+        self.memory.force_bits(scalar, size)\n+    }\n+\n     #[inline(always)]\n     pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n         self.memory.tag_static_base_pointer(ptr)\n@@ -253,6 +270,27 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.frame().body\n     }\n \n+    #[inline(always)]\n+    pub fn sign_extend(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n+        assert!(ty.abi.is_signed());\n+        sign_extend(value, ty.size)\n+    }\n+\n+    #[inline(always)]\n+    pub fn truncate(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n+        truncate(value, ty.size)\n+    }\n+\n+    #[inline]\n+    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_sized(self.tcx, self.param_env)\n+    }\n+\n+    #[inline]\n+    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n+    }\n+\n     pub(super) fn subst_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n         &self,\n         substs: T,\n@@ -288,14 +326,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ).ok_or_else(|| InterpError::TooGeneric.into())\n     }\n \n-    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, self.param_env)\n-    }\n-\n-    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n-    }\n-\n     pub fn load_mir(\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n@@ -766,32 +796,4 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"generate stacktrace: {:#?}, {:?}\", frames, explicit_span);\n         frames\n     }\n-\n-    #[inline(always)]\n-    pub fn sign_extend(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n-        assert!(ty.abi.is_signed());\n-        sign_extend(value, ty.size)\n-    }\n-\n-    #[inline(always)]\n-    pub fn truncate(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n-        truncate(value, ty.size)\n-    }\n-\n-    #[inline(always)]\n-    pub fn force_ptr(\n-        &self,\n-        scalar: Scalar<M::PointerTag>,\n-    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        self.memory.force_ptr(scalar)\n-    }\n-\n-    #[inline(always)]\n-    pub fn force_bits(\n-        &self,\n-        scalar: Scalar<M::PointerTag>,\n-        size: Size\n-    ) -> InterpResult<'tcx, u128> {\n-        self.memory.force_bits(scalar, size)\n-    }\n }"}, {"sha": "f37c474fa4fff23a20c02a7302775227a8a18697", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0383be8577adfa0c1b8e17887eae2fcc54eab81a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0383be8577adfa0c1b8e17887eae2fcc54eab81a/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=0383be8577adfa0c1b8e17887eae2fcc54eab81a", "patch": "@@ -7,11 +7,11 @@ use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::{self, query::TyCtxtAt};\n+use rustc::ty::{self, TyCtxt};\n \n use super::{\n-    Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n-    InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory\n+    Allocation, AllocId, InterpResult, InterpError, Scalar, AllocationExtra,\n+    InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -151,8 +151,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ///\n     /// This allocation will then be fed to `tag_allocation` to initialize the \"extra\" state.\n     fn find_foreign_static(\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        tcx: TyCtxtAt<'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n@@ -189,10 +189,10 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// For static allocations, the tag returned must be the same as the one returned by\n     /// `tag_static_base_pointer`.\n     fn tag_allocation<'b>(\n+        memory_extra: &Self::MemoryExtra,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKinds>>,\n-        memory: &Memory<'mir, 'tcx, Self>,\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag);\n \n     /// Return the \"base\" tag for the given static allocation: the one that is used for direct\n@@ -201,8 +201,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Be aware that requesting the `Allocation` for that `id` will lead to cycles\n     /// for cyclic statics!\n     fn tag_static_base_pointer(\n+        memory_extra: &Self::MemoryExtra,\n         id: AllocId,\n-        memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag;\n \n     /// Executes a retagging operation\n@@ -224,20 +224,22 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         extra: Self::FrameExtra,\n     ) -> InterpResult<'tcx>;\n \n+    #[inline(always)]\n     fn int_to_ptr(\n-        int: u64,\n         _mem: &Memory<'mir, 'tcx, Self>,\n+        int: u64,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n-        if int == 0 {\n-            err!(InvalidNullPointerUsage)\n+        Err((if int == 0 {\n+            InterpError::InvalidNullPointerUsage\n         } else {\n-            err!(ReadBytesAsPointer)\n-        }\n+            InterpError::ReadBytesAsPointer\n+        }).into())\n     }\n \n+    #[inline(always)]\n     fn ptr_to_int(\n-        _ptr: Pointer<Self::PointerTag>,\n         _mem: &Memory<'mir, 'tcx, Self>,\n+        _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n         err!(ReadPointerAsBytes)\n     }"}, {"sha": "33cd7330069e394ebd2801ed18b2c54f4ab594f2", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0383be8577adfa0c1b8e17887eae2fcc54eab81a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0383be8577adfa0c1b8e17887eae2fcc54eab81a/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=0383be8577adfa0c1b8e17887eae2fcc54eab81a", "patch": "@@ -143,7 +143,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n-        ptr.with_tag(M::tag_static_base_pointer(ptr.alloc_id, &self))\n+        ptr.with_tag(M::tag_static_base_pointer(&self.extra, ptr.alloc_id))\n     }\n \n     pub fn create_fn_alloc(\n@@ -189,7 +189,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> Pointer<M::PointerTag> {\n         let id = self.tcx.alloc_map.lock().reserve();\n-        let (alloc, tag) = M::tag_allocation(id, Cow::Owned(alloc), Some(kind), &self);\n+        let (alloc, tag) = M::tag_allocation(&self.extra, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n         Pointer::from(id).with_tag(tag)\n     }\n@@ -407,9 +407,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// contains a reference to memory that was created during its evaluation (i.e., not to\n     /// another static), those inner references only exist in \"resolved\" form.\n     fn get_static_alloc(\n-        id: AllocId,\n+        memory_extra: &M::MemoryExtra,\n         tcx: TyCtxtAt<'tcx>,\n-        memory: &Memory<'mir, 'tcx, M>,\n+        id: AllocId,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let alloc = match alloc {\n@@ -423,7 +423,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n                     trace!(\"static_alloc: foreign item {:?}\", def_id);\n-                    M::find_foreign_static(def_id, tcx)?\n+                    M::find_foreign_static(tcx.tcx, def_id)?\n                 } else {\n                     trace!(\"static_alloc: Need to compute {:?}\", def_id);\n                     let instance = Instance::mono(tcx.tcx, def_id);\n@@ -453,10 +453,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // We got tcx memory. Let the machine figure out whether and how to\n         // turn that into memory with the right pointer tag.\n         Ok(M::tag_allocation(\n+            memory_extra,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             alloc,\n             M::STATIC_KIND.map(MemoryKind::Machine),\n-            memory\n         ).0)\n     }\n \n@@ -469,7 +469,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n         let a = self.alloc_map.get_or(id, || {\n-            let alloc = Self::get_static_alloc(id, self.tcx, &self).map_err(Err)?;\n+            let alloc = Self::get_static_alloc(&self.extra, self.tcx, id).map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n                     // We got a ref, cheaply return that as an \"error\" so that the\n@@ -498,11 +498,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n     ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n         let tcx = self.tcx;\n-        let alloc = Self::get_static_alloc(id, tcx, &self);\n+        let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n             // Need to make a copy, even if `get_static_alloc` is able\n             // to give us a cheap reference.\n-            let alloc = alloc?;\n+            let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Immutable {\n                 return err!(ModifiedConstantMemory);\n             }\n@@ -948,7 +948,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         match scalar {\n             Scalar::Ptr(ptr) => Ok(ptr),\n-            _ => M::int_to_ptr(scalar.to_usize(self)?, self)\n+            _ => M::int_to_ptr(&self, scalar.to_usize(self)?)\n         }\n     }\n \n@@ -959,7 +959,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, u128> {\n         match scalar.to_bits_or_ptr(size, self) {\n             Ok(bits) => Ok(bits),\n-            Err(ptr) => Ok(M::ptr_to_int(ptr, self)? as u128)\n+            Err(ptr) => Ok(M::ptr_to_int(&self, ptr)? as u128)\n         }\n     }\n }"}]}