{"sha": "8a6118b74840727e17ec42b0aa6d7a215d57d2df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhhNjExOGI3NDg0MDcyN2UxN2VjNDJiMGFhNmQ3YTIxNWQ1N2QyZGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-13T14:57:34Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-15T00:07:55Z"}, "message": "move InlinedItem into librustc, where it belongs", "tree": {"sha": "cc3c3223c8e02f6c3248562695d6216bfb684f47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc3c3223c8e02f6c3248562695d6216bfb684f47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8a6118b74840727e17ec42b0aa6d7a215d57d2df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6118b74840727e17ec42b0aa6d7a215d57d2df", "html_url": "https://github.com/rust-lang/rust/commit/8a6118b74840727e17ec42b0aa6d7a215d57d2df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8a6118b74840727e17ec42b0aa6d7a215d57d2df/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c1e865c9df3c6928525025e410fc3d165fb97c85", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1e865c9df3c6928525025e410fc3d165fb97c85", "html_url": "https://github.com/rust-lang/rust/commit/c1e865c9df3c6928525025e410fc3d165fb97c85"}], "stats": {"total": 283, "additions": 157, "deletions": 126}, "files": [{"sha": "b38c15d0f6a1e47aaf5c9694addeb1415fe3bba5", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -12,6 +12,8 @@ pub use self::Node::*;\n pub use self::PathElem::*;\n use self::MapEntry::*;\n \n+use metadata::inline::InlinedItem;\n+use metadata::inline::InlinedItem as II;\n use syntax::abi;\n use syntax::ast::*;\n use syntax::ast_util;\n@@ -374,8 +376,8 @@ impl<'ast> Map<'ast> {\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let parent = self.get_parent(id);\n         match self.find_entry(parent) {\n-            Some(RootInlinedParent(&InlinedParent {ii: IITraitItem(did, _), ..})) => did,\n-            Some(RootInlinedParent(&InlinedParent {ii: IIImplItem(did, _), ..})) => did,\n+            Some(RootInlinedParent(&InlinedParent {ii: II::TraitItem(did, _), ..})) => did,\n+            Some(RootInlinedParent(&InlinedParent {ii: II::ImplItem(did, _), ..})) => did,\n             _ => ast_util::local_def(parent)\n         }\n     }\n@@ -967,16 +969,16 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           -> &'ast InlinedItem {\n     let mut fld = IdAndSpanUpdater { fold_ops: fold_ops };\n     let ii = match ii {\n-        IIItem(i) => IIItem(fld.fold_item(i).expect_one(\"expected one item\")),\n-        IITraitItem(d, ti) => {\n-            IITraitItem(fld.fold_ops.new_def_id(d),\n-                        fld.fold_trait_item(ti).expect_one(\"expected one trait item\"))\n+        II::Item(i) => II::Item(fld.fold_item(i).expect_one(\"expected one item\")),\n+        II::TraitItem(d, ti) => {\n+            II::TraitItem(fld.fold_ops.new_def_id(d),\n+                          fld.fold_trait_item(ti).expect_one(\"expected one trait item\"))\n         }\n-        IIImplItem(d, ii) => {\n-            IIImplItem(fld.fold_ops.new_def_id(d),\n-                       fld.fold_impl_item(ii).expect_one(\"expected one impl item\"))\n+        II::ImplItem(d, ii) => {\n+            II::ImplItem(fld.fold_ops.new_def_id(d),\n+                         fld.fold_impl_item(ii).expect_one(\"expected one impl item\"))\n         }\n-        IIForeign(i) => IIForeign(fld.fold_foreign_item(i))\n+        II::Foreign(i) => II::Foreign(fld.fold_foreign_item(i))\n     };\n \n     let ii_parent = map.forest.inlined_items.alloc(InlinedParent {\n@@ -990,20 +992,20 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n         parent_node: ii_parent_id,\n     };\n     collector.insert_entry(ii_parent_id, RootInlinedParent(ii_parent));\n-    visit::walk_inlined_item(&mut collector, &ii_parent.ii);\n+    ii_parent.ii.visit(&mut collector);\n \n     // Methods get added to the AST map when their impl is visited.  Since we\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now. Likewise with foreign items.\n     match ii_parent.ii {\n-        IIItem(_) => {}\n-        IITraitItem(_, ref ti) => {\n+        II::Item(_) => {}\n+        II::TraitItem(_, ref ti) => {\n             collector.insert(ti.id, NodeTraitItem(ti));\n         }\n-        IIImplItem(_, ref ii) => {\n+        II::ImplItem(_, ref ii) => {\n             collector.insert(ii.id, NodeImplItem(ii));\n         }\n-        IIForeign(ref i) => {\n+        II::Foreign(ref i) => {\n             collector.insert(i.id, NodeForeignItem(i));\n         }\n     }"}, {"sha": "d33b163c9725abb91cb993ea41ee7dc325f16779", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -14,6 +14,7 @@ use ast_map;\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n+use metadata::inline::InlinedItem;\n use middle::lang_items;\n use middle::ty;\n \n@@ -96,8 +97,8 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n }\n \n pub enum FoundAst<'ast> {\n-    Found(&'ast ast::InlinedItem),\n-    FoundParent(ast::DefId, &'ast ast::InlinedItem),\n+    Found(&'ast InlinedItem),\n+    FoundParent(ast::DefId, &'ast InlinedItem),\n     NotFound,\n }\n "}, {"sha": "11a5cc8c9d737f4ed17059ca5453b52e0fa2ef9b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -23,6 +23,7 @@ use metadata::csearch::MethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n use metadata::encoder::def_to_u64;\n+use metadata::inline::InlinedItem;\n use metadata::tydecode::{parse_ty_data, parse_region_data,\n                          parse_type_param_def_data, parse_bare_fn_ty_data,\n                          parse_trait_ref_data, parse_predicate_data};\n@@ -776,7 +777,7 @@ pub type DecodeInlinedItem<'a> =\n                         &ty::ctxt<'tcx>,\n                         Vec<ast_map::PathElem>,\n                         rbml::Doc)\n-                        -> Result<&'tcx ast::InlinedItem, Vec<ast_map::PathElem>> + 'a>;\n+                        -> Result<&'tcx InlinedItem, Vec<ast_map::PathElem>> + 'a>;\n \n pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeId,\n                                 mut decode_inlined_item: DecodeInlinedItem)"}, {"sha": "03f5f477bd8172a301b2fdf0a5697b8dda4a197c", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -13,15 +13,14 @@\n #![allow(unused_must_use)] // everything is just a MemWriter, can't fail\n #![allow(non_camel_case_types)]\n \n-pub use self::InlinedItemRef::*;\n-\n use ast_map::{self, LinkedPath, PathElem, PathElems};\n use back::svh::Svh;\n use session::config;\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n+use metadata::inline::InlinedItemRef;\n use middle::def;\n use middle::ty::{self, Ty};\n use middle::stability;\n@@ -46,14 +45,6 @@ use syntax::visit;\n use syntax;\n use rbml::writer::Encoder;\n \n-/// A borrowed version of `ast::InlinedItem`.\n-pub enum InlinedItemRef<'a> {\n-    IIItemRef(&'a ast::Item),\n-    IITraitItemRef(DefId, &'a ast::TraitItem),\n-    IIImplItemRef(DefId, &'a ast::ImplItem),\n-    IIForeignRef(&'a ast::ForeignItem)\n-}\n-\n pub type EncodeInlinedItem<'a> =\n     Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n \n@@ -830,7 +821,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n \n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n-        encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id), ii));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(local_def(parent_id), ii));\n     }\n \n     rbml_w.end_tag();\n@@ -868,7 +859,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             let needs_inline = any_types || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n             if needs_inline || sig.constness == ast::Constness::Const {\n-                encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n+                encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(local_def(parent_id),\n                                                                impl_item));\n             }\n             encode_constness(rbml_w, sig.constness);\n@@ -1050,7 +1041,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n-        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n@@ -1067,7 +1058,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, &item.attrs);\n         let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n         if needs_inline || constness == ast::Constness::Const {\n-            encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n+            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         }\n         if tps_len == 0 {\n             encode_symbol(ecx, rbml_w, item.id);\n@@ -1132,7 +1123,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for v in &enum_definition.variants {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n-        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_path(rbml_w, path);\n \n         // Encode inherent implementations for this enumeration.\n@@ -1180,7 +1171,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         needs to know*/\n         encode_struct_fields(rbml_w, variant, def_id);\n \n-        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n@@ -1455,7 +1446,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             match trait_item.node {\n                 ast::ConstTraitItem(_, _) => {\n                     encode_inlined_item(ecx, rbml_w,\n-                                        IITraitItemRef(def_id, trait_item));\n+                                        InlinedItemRef::TraitItem(def_id, trait_item));\n                 }\n                 ast::MethodTraitItem(ref sig, ref body) => {\n                     // If this is a static method, we've already\n@@ -1469,7 +1460,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                     if body.is_some() {\n                         encode_item_sort(rbml_w, 'p');\n-                        encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n+                        encode_inlined_item(ecx, rbml_w,\n+                                            InlinedItemRef::TraitItem(def_id, trait_item));\n                     } else {\n                         encode_item_sort(rbml_w, 'r');\n                     }\n@@ -1508,7 +1500,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n         encode_name(rbml_w, nitem.ident.name);\n         if abi == abi::RustIntrinsic {\n-            encode_inlined_item(ecx, rbml_w, IIForeignRef(nitem));\n+            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n         encode_attributes(rbml_w, &*nitem.attrs);\n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(nitem.id));"}, {"sha": "ba09e173fd80d5cf29bc73b8afff0fb4d8cdbdcf", "filename": "src/librustc/metadata/inline.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmetadata%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmetadata%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Finline.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use syntax::ast_util::{IdRange, IdRangeComputingVisitor,\n+                       IdVisitor, IdVisitingOperation};\n+use syntax::ptr::P;\n+use syntax::visit::Visitor;\n+use self::InlinedItem::*;\n+\n+/// The data we save and restore about an inlined item or method.  This is not\n+/// part of the AST that we parse from a file, but it becomes part of the tree\n+/// that we trans.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum InlinedItem {\n+    Item(P<ast::Item>),\n+    TraitItem(ast::DefId /* impl id */, P<ast::TraitItem>),\n+    ImplItem(ast::DefId /* impl id */, P<ast::ImplItem>),\n+    Foreign(P<ast::ForeignItem>),\n+}\n+\n+/// A borrowed version of `ast::InlinedItem`.\n+pub enum InlinedItemRef<'a> {\n+    Item(&'a ast::Item),\n+    TraitItem(ast::DefId, &'a ast::TraitItem),\n+    ImplItem(ast::DefId, &'a ast::ImplItem),\n+    Foreign(&'a ast::ForeignItem)\n+}\n+\n+impl InlinedItem {\n+    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n+        where V: Visitor<'ast>\n+    {\n+        match *self {\n+            Item(ref i) => visitor.visit_item(&**i),\n+            Foreign(ref i) => visitor.visit_foreign_item(&**i),\n+            TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n+            ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n+        }\n+    }\n+\n+    pub fn visit_ids<O: IdVisitingOperation>(&self, operation: &mut O) {\n+        let mut id_visitor = IdVisitor {\n+            operation: operation,\n+            pass_through_items: true,\n+            visited_outermost: false,\n+        };\n+        self.visit(&mut id_visitor);\n+    }\n+\n+    pub fn compute_id_range(&self) -> IdRange {\n+        let mut visitor = IdRangeComputingVisitor::new();\n+        self.visit_ids(&mut visitor);\n+        visitor.result()\n+    }\n+}\n+"}, {"sha": "44901eb05479138eb74aba347f76d0d09476abc9", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -19,3 +19,4 @@ pub mod csearch;\n pub mod loader;\n pub mod filesearch;\n pub mod macro_import;\n+pub mod inline;"}, {"sha": "a07b849b400aa3892b621db0456298a810f2ff0d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 31, "deletions": 30, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -17,16 +17,17 @@ use metadata::common as c;\n use metadata::cstore as cstore;\n use session::Session;\n use metadata::decoder;\n-use middle::def;\n use metadata::encoder as e;\n-use middle::region;\n+use metadata::inline::{InlinedItem, InlinedItemRef};\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId};\n use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n use middle::cast;\n use middle::check_const::ConstQualif;\n+use middle::def;\n use middle::privacy::{AllPublic, LastMod};\n+use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n@@ -75,20 +76,20 @@ trait tr_intern {\n \n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            rbml_w: &mut Encoder,\n-                           ii: e::InlinedItemRef) {\n+                           ii: InlinedItemRef) {\n     let id = match ii {\n-        e::IIItemRef(i) => i.id,\n-        e::IIForeignRef(i) => i.id,\n-        e::IITraitItemRef(_, ti) => ti.id,\n-        e::IIImplItemRef(_, ii) => ii.id,\n+        InlinedItemRef::Item(i) => i.id,\n+        InlinedItemRef::Foreign(i) => i.id,\n+        InlinedItemRef::TraitItem(_, ti) => ti.id,\n+        InlinedItemRef::ImplItem(_, ii) => ii.id,\n     };\n     debug!(\"> Encoding inlined item: {} ({:?})\",\n            ecx.tcx.map.path_to_string(id),\n            rbml_w.writer.seek(SeekFrom::Current(0)));\n \n     // Folding could be avoided with a smarter encoder.\n     let ii = simplify_ast(ii);\n-    let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n+    let id_range = ii.compute_id_range();\n \n     rbml_w.start_tag(c::tag_ast as usize);\n     id_range.encode(rbml_w);\n@@ -124,7 +125,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  path: Vec<ast_map::PathElem>,\n                                  par_doc: rbml::Doc)\n-                                 -> Result<&'tcx ast::InlinedItem, Vec<ast_map::PathElem>> {\n+                                 -> Result<&'tcx InlinedItem, Vec<ast_map::PathElem>> {\n     match par_doc.opt_child(c::tag_ast) {\n       None => Err(path),\n       Some(ast_doc) => {\n@@ -150,10 +151,10 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, raw_ii, dcx);\n \n         let ident = match *ii {\n-            ast::IIItem(ref i) => i.ident,\n-            ast::IIForeign(ref i) => i.ident,\n-            ast::IITraitItem(_, ref ti) => ti.ident,\n-            ast::IIImplItem(_, ref ii) => ii.ident\n+            InlinedItem::Item(ref i) => i.ident,\n+            InlinedItem::Foreign(ref i) => i.ident,\n+            InlinedItem::TraitItem(_, ref ti) => ti.ident,\n+            InlinedItem::ImplItem(_, ref ii) => ii.ident\n         };\n         debug!(\"Fn named: {}\", ident);\n         debug!(\"< Decoded inlined fn: {}::{}\",\n@@ -162,7 +163,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n         decode_side_tables(dcx, ast_doc);\n         match *ii {\n-          ast::IIItem(ref i) => {\n+          InlinedItem::Item(ref i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n                    syntax::print::pprust::item_to_string(&**i));\n           }\n@@ -349,7 +350,7 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(rbml_w: &mut Encoder, item: &ast::InlinedItem) {\n+fn encode_ast(rbml_w: &mut Encoder, item: &InlinedItem) {\n     rbml_w.start_tag(c::tag_tree as usize);\n     item.encode(rbml_w);\n     rbml_w.end_tag();\n@@ -399,34 +400,34 @@ impl Folder for NestedItemsDropper {\n // As it happens, trans relies on the fact that we do not export\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n-fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n+fn simplify_ast(ii: InlinedItemRef) -> InlinedItem {\n     let mut fld = NestedItemsDropper;\n \n     match ii {\n         // HACK we're not dropping items.\n-        e::IIItemRef(i) => {\n-            ast::IIItem(fold::noop_fold_item(P(i.clone()), &mut fld)\n+        InlinedItemRef::Item(i) => {\n+            InlinedItem::Item(fold::noop_fold_item(P(i.clone()), &mut fld)\n                             .expect_one(\"expected one item\"))\n         }\n-        e::IITraitItemRef(d, ti) => {\n-            ast::IITraitItem(d,\n+        InlinedItemRef::TraitItem(d, ti) => {\n+            InlinedItem::TraitItem(d,\n                 fold::noop_fold_trait_item(P(ti.clone()), &mut fld)\n                     .expect_one(\"noop_fold_trait_item must produce \\\n                                  exactly one trait item\"))\n         }\n-        e::IIImplItemRef(d, ii) => {\n-            ast::IIImplItem(d,\n+        InlinedItemRef::ImplItem(d, ii) => {\n+            InlinedItem::ImplItem(d,\n                 fold::noop_fold_impl_item(P(ii.clone()), &mut fld)\n                     .expect_one(\"noop_fold_impl_item must produce \\\n                                  exactly one impl item\"))\n         }\n-        e::IIForeignRef(i) => {\n-            ast::IIForeign(fold::noop_fold_foreign_item(P(i.clone()), &mut fld))\n+        InlinedItemRef::Foreign(i) => {\n+            InlinedItem::Foreign(fold::noop_fold_foreign_item(P(i.clone()), &mut fld))\n         }\n     }\n }\n \n-fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n+fn decode_ast(par_doc: rbml::Doc) -> InlinedItem {\n     let chi_doc = par_doc.get(c::tag_tree as usize);\n     let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n@@ -920,9 +921,9 @@ impl<'a, 'b, 'c, 'tcx> ast_util::IdVisitingOperation for\n \n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              rbml_w: &mut Encoder,\n-                             ii: &ast::InlinedItem) {\n+                             ii: &InlinedItem) {\n     rbml_w.start_tag(c::tag_table as usize);\n-    ast_util::visit_ids_for_inlined_item(ii, &mut SideTableEncodingIdVisitor {\n+    ii.visit_ids(&mut SideTableEncodingIdVisitor {\n         ecx: ecx,\n         rbml_w: rbml_w\n     });\n@@ -1644,15 +1645,15 @@ fn test_simplification() {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap();\n-    let item_in = e::IIItemRef(&*item);\n+    let item_in = InlinedItemRef::Item(&*item);\n     let item_out = simplify_ast(item_in);\n-    let item_exp = ast::IIItem(quote_item!(&cx,\n+    let item_exp = InlinedItem::Item(quote_item!(&cx,\n         fn new_int_alist<B>() -> alist<isize, B> {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap());\n     match (item_out, item_exp) {\n-      (ast::IIItem(item_out), ast::IIItem(item_exp)) => {\n+      (InlinedItem::Item(item_out), InlinedItem::Item(item_exp)) => {\n         assert!(pprust::item_to_string(&*item_out) ==\n                 pprust::item_to_string(&*item_exp));\n       }"}, {"sha": "a1327df224a977644aaaaa80f3cdef7a489dbced", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -17,6 +17,7 @@ use self::EvalHint::*;\n use ast_map;\n use ast_map::blocks::FnLikeNode;\n use metadata::csearch;\n+use metadata::inline::InlinedItem;\n use middle::{astencode, def, infer, subst, traits};\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n@@ -86,7 +87,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         }\n         let expr_id = match csearch::maybe_get_item_ast(tcx, enum_def,\n             Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n-            csearch::FoundAst::Found(&ast::IIItem(ref item)) => match item.node {\n+            csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n@@ -161,11 +162,11 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n         let mut used_ref_id = false;\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n-            csearch::FoundAst::Found(&ast::IIItem(ref item)) => match item.node {\n+            csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 ast::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n-            csearch::FoundAst::Found(&ast::IITraitItem(trait_id, ref ti)) => match ti.node {\n+            csearch::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n                 ast::ConstTraitItem(_, _) => {\n                     used_ref_id = true;\n                     match maybe_ref_id {\n@@ -184,7 +185,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                 }\n                 _ => None\n             },\n-            csearch::FoundAst::Found(&ast::IIImplItem(_, ref ii)) => match ii.node {\n+            csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n                 ast::ConstImplItem(_, ref expr) => Some(expr.id),\n                 _ => None\n             },\n@@ -217,8 +218,8 @@ fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: ast::DefId)\n \n     let fn_id = match csearch::maybe_get_item_ast(tcx, def_id,\n         box |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n-        csearch::FoundAst::Found(&ast::IIItem(ref item)) => Some(item.id),\n-        csearch::FoundAst::Found(&ast::IIImplItem(_, ref item)) => Some(item.id),\n+        csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n+        csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n         _ => None\n     };\n     tcx.extern_const_fns.borrow_mut().insert(def_id,"}, {"sha": "dafc1e900f3f903bde60dbc3a107c1848848a672", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -17,8 +17,9 @@\n //! `middle/typeck/infer/region_inference.rs`\n \n use ast_map;\n-use session::Session;\n+use metadata::inline::InlinedItem;\n use middle::ty::{self, Ty};\n+use session::Session;\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n \n use std::cell::RefCell;\n@@ -1231,7 +1232,7 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n \n pub fn resolve_inlined_item(sess: &Session,\n                             region_maps: &RegionMaps,\n-                            item: &ast::InlinedItem) {\n+                            item: &InlinedItem) {\n     let mut visitor = RegionResolutionVisitor {\n         sess: sess,\n         region_maps: region_maps,\n@@ -1241,5 +1242,5 @@ pub fn resolve_inlined_item(sess: &Session,\n             var_parent: InnermostDeclaringBlock::None\n         }\n     };\n-    visit::walk_inlined_item(&mut visitor, item);\n+    item.visit(&mut visitor);\n }"}, {"sha": "c6450d06eb66c92361f7ad021a621fbc05e8c4a4", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -10,6 +10,7 @@\n \n use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n use metadata::csearch;\n+use metadata::inline::InlinedItem;\n use middle::astencode;\n use middle::subst::Substs;\n use trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n@@ -48,7 +49,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.external().borrow_mut().insert(fn_id, None);\n             return None;\n         }\n-        csearch::FoundAst::Found(&ast::IIItem(ref item)) => {\n+        csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n \n@@ -91,12 +92,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n             item.id\n         }\n-        csearch::FoundAst::Found(&ast::IIForeign(ref item)) => {\n+        csearch::FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n             item.id\n         }\n-        csearch::FoundAst::FoundParent(parent_id, &ast::IIItem(ref item)) => {\n+        csearch::FoundAst::FoundParent(parent_id, &InlinedItem::Item(ref item)) => {\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n@@ -131,7 +132,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.sess().bug(\"maybe_get_item_ast returned a FoundParent \\\n                             with a non-item parent\");\n         }\n-        csearch::FoundAst::Found(&ast::IITraitItem(_, ref trait_item)) => {\n+        csearch::FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(trait_item.id));\n             ccx.external_srcs().borrow_mut().insert(trait_item.id, fn_id);\n \n@@ -150,7 +151,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             // don't.\n             trait_item.id\n         }\n-        csearch::FoundAst::Found(&ast::IIImplItem(impl_did, ref impl_item)) => {\n+        csearch::FoundAst::Found(&InlinedItem::ImplItem(impl_did, ref impl_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(impl_item.id));\n             ccx.external_srcs().borrow_mut().insert(impl_item.id, fn_id);\n "}, {"sha": "0bcd97cfe873feca537fb41e1ba27480ab8e449b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -23,7 +23,6 @@ pub use self::FloatTy::*;\n pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n pub use self::ImplItem_::*;\n-pub use self::InlinedItem::*;\n pub use self::IntTy::*;\n pub use self::Item_::*;\n pub use self::KleeneOp::*;\n@@ -1925,17 +1924,6 @@ impl ForeignItem_ {\n     }\n }\n \n-/// The data we save and restore about an inlined item or method.  This is not\n-/// part of the AST that we parse from a file, but it becomes part of the tree\n-/// that we trans.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum InlinedItem {\n-    IIItem(P<Item>),\n-    IITraitItem(DefId /* impl id */, P<TraitItem>),\n-    IIImplItem(DefId /* impl id */, P<ImplItem>),\n-    IIForeign(P<ForeignItem>),\n-}\n-\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion."}, {"sha": "7aff92ecb709080b6f97d0933a5b6ee290e55b38", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -503,19 +503,18 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n     }\n }\n \n-pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,\n-                                                          operation: &mut O) {\n-    let mut id_visitor = IdVisitor {\n-        operation: operation,\n-        pass_through_items: true,\n-        visited_outermost: false,\n-    };\n-\n-    visit::walk_inlined_item(&mut id_visitor, item);\n+pub struct IdRangeComputingVisitor {\n+    result: IdRange,\n }\n \n-struct IdRangeComputingVisitor {\n-    result: IdRange,\n+impl IdRangeComputingVisitor {\n+    pub fn new() -> IdRangeComputingVisitor {\n+        IdRangeComputingVisitor { result: IdRange::max() }\n+    }\n+\n+    pub fn result(&self) -> IdRange {\n+        self.result\n+    }\n }\n \n impl IdVisitingOperation for IdRangeComputingVisitor {\n@@ -524,14 +523,6 @@ impl IdVisitingOperation for IdRangeComputingVisitor {\n     }\n }\n \n-pub fn compute_id_range_for_inlined_item(item: &InlinedItem) -> IdRange {\n-    let mut visitor = IdRangeComputingVisitor {\n-        result: IdRange::max()\n-    };\n-    visit_ids_for_inlined_item(item, &mut visitor);\n-    visitor.result\n-}\n-\n /// Computes the id range for a single fn body, ignoring nested items.\n pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n                                     decl: &FnDecl,\n@@ -540,9 +531,7 @@ pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n                                     id: NodeId)\n                                     -> IdRange\n {\n-    let mut visitor = IdRangeComputingVisitor {\n-        result: IdRange::max()\n-    };\n+    let mut visitor = IdRangeComputingVisitor::new();\n     let mut id_visitor = IdVisitor {\n         operation: &mut visitor,\n         pass_through_items: false,"}, {"sha": "259564337a21bbaf8170df641c8c05fa2d40b32d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8a6118b74840727e17ec42b0aa6d7a215d57d2df/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=8a6118b74840727e17ec42b0aa6d7a215d57d2df", "patch": "@@ -142,17 +142,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n }\n \n-pub fn walk_inlined_item<'v,V>(visitor: &mut V, item: &'v InlinedItem)\n-                         where V: Visitor<'v> {\n-    match *item {\n-        IIItem(ref i) => visitor.visit_item(&**i),\n-        IIForeign(ref i) => visitor.visit_foreign_item(&**i),\n-        IITraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n-        IIImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n-    }\n-}\n-\n-\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     for attr in &krate.attrs {"}]}