{"sha": "17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3ZTMzNmM3ZDlmMmQyZmUwMmY4NDAzY2ZmMGViMTEyMjYzMGE4MWM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-22T07:50:15Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-09-22T07:50:15Z"}, "message": "Merge branch 'master' of https://github.com/tsion/miri", "tree": {"sha": "1d552a7424ee8e490eee6c81d783464b10fdbefe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d552a7424ee8e490eee6c81d783464b10fdbefe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX4408AAoJEFbW7qD8Z6xGtDsP/3F0NxGXn+5Tx/2xnFP9gkSG\nnWlfHt3Rl8NMdh3O3GsWfRIkChlY/yQXXrYRjPZRRftC1cLaDbY0EEO1zWMIJSFY\nJkyzTwLV3uwTguuzxL1yNPwexK3EFT7tboE5NwL9XzY4ONTDhQEO3Gg7YNnORQld\nzxvdQlqeR3Rp8nODIRT5CpQVlAtWDWVSTz7/01Teaka7UipKZdORIDRjaBGQ+f0w\nz0FVPKrdfW9YHEpr3lm60T7Wov8LkqrI0HrD/QegI7hLICsvkuYF1gDkJp8nFeoH\ndoCJX5zhg9siw4I2i1ywSfQsBhwgGpsc0/hmCHisH1ZhATSA6Vbt3VQUiFPR1bzF\n8Dr5wEZEROBJO/imt+PxvdjHL33me7XTqmx6XP2Yghn5CDA6i0NlfsVRDUJSXp4V\nZMtWNG0zXAI0HB95ACEJj2SiUvYpsLAdt2J/SW2g2BrZkegcA7ibY+7cx4Z5i+It\nUKuZ7MlLYko2NPjPTrhWUjMGupCdoJ7TWwuWWymMH+AvC4iFFeO5Q5sLprVT6r1W\nw2ptj3cGNU/B0i0LbxDZ4D+K6MLmpIV2kElNIOC50QtWCdSFszDf52awLZM68XAz\n6LvTpDnMpB1OeHV6S2tSv+usadISrBgJkiONzix9tbv61ihsAozPWvksf/cTmFHp\n+s47oaFooVof6KNRbQpa\n=C9O9\n-----END PGP SIGNATURE-----", "payload": "tree 1d552a7424ee8e490eee6c81d783464b10fdbefe\nparent 145cbf844cc876b05e29a0e08aa1d7a461d00ae9\nparent 5b012edc7ab8690610b0502be24f3eb8ed30486b\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474530615 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1474530615 +0200\n\nMerge branch 'master' of https://github.com/tsion/miri\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "html_url": "https://github.com/rust-lang/rust/commit/17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "145cbf844cc876b05e29a0e08aa1d7a461d00ae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/145cbf844cc876b05e29a0e08aa1d7a461d00ae9", "html_url": "https://github.com/rust-lang/rust/commit/145cbf844cc876b05e29a0e08aa1d7a461d00ae9"}, {"sha": "5b012edc7ab8690610b0502be24f3eb8ed30486b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b012edc7ab8690610b0502be24f3eb8ed30486b", "html_url": "https://github.com/rust-lang/rust/commit/5b012edc7ab8690610b0502be24f3eb8ed30486b"}], "stats": {"total": 152, "additions": 89, "deletions": 63}, "files": [{"sha": "06cbf2495dac78fa9402bb49b0f10d34a943e39d", "filename": "src/interpreter/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Finterpreter%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Finterpreter%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fcast.rs?ref=17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "patch": "@@ -28,15 +28,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             U64(u) |\n             IntegerPtr(u) => self.cast_const_int(u, ty, false),\n             FnPtr(ptr) |\n-            AbstractPtr(ptr) => self.cast_ptr(ptr, ty),\n+            Ptr(ptr) => self.cast_ptr(ptr, ty),\n         }\n     }\n \n     fn cast_ptr(&self, ptr: Pointer, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         use primval::PrimVal::*;\n         match ty.sty {\n             ty::TyRef(..) |\n-            ty::TyRawPtr(_) => Ok(AbstractPtr(ptr)),\n+            ty::TyRawPtr(_) => Ok(Ptr(ptr)),\n             ty::TyFnPtr(_) => Ok(FnPtr(ptr)),\n             _ => Err(EvalError::Unimplemented(format!(\"ptr to {:?} cast\", ty))),\n         }"}, {"sha": "a7e4407ce59a857afded8056ee529b1969e79397", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 33, "deletions": 28, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "patch": "@@ -246,7 +246,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 self.memory.write_bytes(ptr, s.as_bytes())?;\n                 self.memory.freeze(ptr.alloc_id)?;\n                 Value::ByValPair(\n-                    PrimVal::AbstractPtr(ptr),\n+                    PrimVal::Ptr(ptr),\n                     self.target_usize_primval(s.len() as u64)\n                 )\n             }\n@@ -255,7 +255,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ptr = self.memory.allocate(bs.len(), 1)?;\n                 self.memory.write_bytes(ptr, bs)?;\n                 self.memory.freeze(ptr.alloc_id)?;\n-                Value::ByVal(PrimVal::AbstractPtr(ptr))\n+                Value::ByVal(PrimVal::Ptr(ptr))\n             }\n \n             Struct(_)    => unimplemented!(),\n@@ -782,31 +782,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n     // remove it as soon as PrimVal can represent fat pointers.\n     fn eval_operand_to_ptr(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, Pointer> {\n         let value = self.eval_operand(op)?;\n-        match value {\n-            Value::ByRef(ptr) => Ok(ptr),\n-\n-            Value::ByVal(primval) => {\n-                let ty = self.operand_ty(op);\n-                let size = self.type_size(ty);\n-                let align = self.type_align(ty);\n-                let ptr = self.memory.allocate(size, align)?;\n-                self.memory.write_primval(ptr, primval)?;\n-                Ok(ptr)\n-            }\n-\n-            Value::ByValPair(primval1, primval2) => {\n-                let ty = self.operand_ty(op);\n-                let size = self.type_size(ty);\n-                let align = self.type_align(ty);\n-                let ptr = self.memory.allocate(size, align)?;\n-\n-                // FIXME(solson): Major dangerous assumptions here. Ideally obliterate this\n-                // function.\n-                self.memory.write_primval(ptr, primval1)?;\n-                self.memory.write_primval(ptr.offset((size / 2) as isize), primval2)?;\n-                Ok(ptr)\n-            }\n-        }\n+        let ty = self.operand_ty(op);\n+        self.value_to_ptr(value, ty)\n     }\n \n     fn eval_operand_to_primval(&mut self, op: &mir::Operand<'tcx>) -> EvalResult<'tcx, PrimVal> {\n@@ -992,6 +969,34 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n+    // FIXME(solson): This method unnecessarily allocates and should not be necessary. We can\n+    // remove it as soon as PrimVal can represent fat pointers.\n+    fn value_to_ptr(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, Pointer> {\n+        match value {\n+            Value::ByRef(ptr) => Ok(ptr),\n+\n+            Value::ByVal(primval) => {\n+                let size = self.type_size(ty);\n+                let align = self.type_align(ty);\n+                let ptr = self.memory.allocate(size, align)?;\n+                self.memory.write_primval(ptr, primval)?;\n+                Ok(ptr)\n+            }\n+\n+            Value::ByValPair(primval1, primval2) => {\n+                let size = self.type_size(ty);\n+                let align = self.type_align(ty);\n+                let ptr = self.memory.allocate(size, align)?;\n+\n+                // FIXME(solson): Major dangerous assumptions here. Ideally obliterate this\n+                // function.\n+                self.memory.write_primval(ptr, primval1)?;\n+                self.memory.write_primval(ptr.offset((size / 2) as isize), primval2)?;\n+                Ok(ptr)\n+            }\n+        }\n+    }\n+\n     fn value_to_primval(&mut self, value: Value, ty: Ty<'tcx>) -> EvalResult<'tcx, PrimVal> {\n         match value {\n             Value::ByRef(ptr) => self.read_primval(ptr, ty),\n@@ -1057,7 +1062,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             &ty::TyRawPtr(ty::TypeAndMut { ty, .. }) => {\n                 if self.type_is_sized(ty) {\n                     match self.memory.read_ptr(ptr) {\n-                        Ok(p) => PrimVal::AbstractPtr(p),\n+                        Ok(p) => PrimVal::Ptr(p),\n                         Err(EvalError::ReadBytesAsPointer) => {\n                             PrimVal::IntegerPtr(self.memory.read_usize(ptr)?)\n                         }"}, {"sha": "f87f5e43a96056bfaff80b9e80b7f9189a5fe877", "filename": "src/interpreter/step.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Finterpreter%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Finterpreter%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fstep.rs?ref=17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "patch": "@@ -82,6 +82,10 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             // Miri can safely ignore these. Only translation needs them.\n             StorageLive(_) | StorageDead(_) => {}\n+\n+            // Defined to do nothing. These are added by optimization passes, to avoid changing the\n+            // size of MIR constantly.\n+            Nop => {}\n         }\n \n         self.frame_mut().stmt += 1;\n@@ -186,12 +190,18 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for ConstantExtractor<'a, 'b, 'tcx> {\n         }\n     }\n \n-    fn visit_lvalue(&mut self, lvalue: &mir::Lvalue<'tcx>, context: LvalueContext, location: mir::Location) {\n+    fn visit_lvalue(\n+        &mut self,\n+        lvalue: &mir::Lvalue<'tcx>,\n+        context: LvalueContext<'tcx>,\n+        location: mir::Location\n+    ) {\n         self.super_lvalue(lvalue, context, location);\n         if let mir::Lvalue::Static(def_id) = *lvalue {\n             let substs = subst::Substs::empty(self.ecx.tcx);\n             let span = self.span;\n-            if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = self.ecx.tcx.map.get_if_local(def_id).expect(\"static not found\") {\n+            let node_item = self.ecx.tcx.map.get_if_local(def_id).expect(\"static not found\");\n+            if let hir::map::Node::NodeItem(&hir::Item { ref node, .. }) = node_item {\n                 if let hir::ItemStatic(_, m, _) = *node {\n                     self.global_item(def_id, substs, span, m == hir::MutImmutable);\n                     return;"}, {"sha": "10273881b67c6221853c87b03ae5a741ab4e77a1", "filename": "src/interpreter/terminator/mod.rs", "status": "modified", "additions": 35, "deletions": 24, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Finterpreter%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Finterpreter%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator%2Fmod.rs?ref=17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "patch": "@@ -13,7 +13,8 @@ use syntax::{ast, attr};\n \n use error::{EvalError, EvalResult};\n use memory::Pointer;\n-use super::{EvalContext, IntegerExt, StackPopCleanup};\n+use primval::PrimVal;\n+use super::{EvalContext, IntegerExt, StackPopCleanup, Value};\n \n mod intrinsics;\n \n@@ -154,7 +155,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         substs: &'tcx Substs<'tcx>,\n         fn_ty: &'tcx BareFnTy,\n         destination: Option<(Pointer, mir::BasicBlock)>,\n-        args: &[mir::Operand<'tcx>],\n+        arg_operands: &[mir::Operand<'tcx>],\n         span: Span,\n     ) -> EvalResult<'tcx, ()> {\n         use syntax::abi::Abi;\n@@ -163,7 +164,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = fn_ty.sig.0.output;\n                 let layout = self.type_layout(ty);\n                 let (ret, target) = destination.unwrap();\n-                self.call_intrinsic(def_id, substs, args, ret, layout)?;\n+                self.call_intrinsic(def_id, substs, arg_operands, ret, layout)?;\n                 self.goto_block(target);\n                 Ok(())\n             }\n@@ -172,23 +173,23 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 let ty = fn_ty.sig.0.output;\n                 let size = self.type_size(ty);\n                 let (ret, target) = destination.unwrap();\n-                self.call_c_abi(def_id, args, ret, size)?;\n+                self.call_c_abi(def_id, arg_operands, ret, size)?;\n                 self.goto_block(target);\n                 Ok(())\n             }\n \n             Abi::Rust | Abi::RustCall => {\n-                let mut arg_srcs = Vec::new();\n-                for arg in args {\n-                    let src = self.eval_operand_to_ptr(arg)?;\n-                    let src_ty = self.operand_ty(arg);\n-                    arg_srcs.push((src, src_ty));\n+                let mut args = Vec::new();\n+                for arg in arg_operands {\n+                    let arg_val = self.eval_operand(arg)?;\n+                    let arg_ty = self.operand_ty(arg);\n+                    args.push((arg_val, arg_ty));\n                 }\n \n                 // Only trait methods can have a Self parameter.\n                 let (resolved_def_id, resolved_substs) =\n                     if let Some(trait_id) = self.tcx.trait_of_item(def_id) {\n-                        self.trait_method(trait_id, def_id, substs, &mut arg_srcs)?\n+                        self.trait_method(trait_id, def_id, substs, &mut args)?\n                     } else {\n                         (def_id, substs)\n                     };\n@@ -200,9 +201,9 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 };\n                 self.push_stack_frame(resolved_def_id, span, mir, resolved_substs, return_ptr, return_to_block)?;\n \n-                for (i, (src, src_ty)) in arg_srcs.into_iter().enumerate() {\n+                for (i, (arg_val, arg_ty)) in args.into_iter().enumerate() {\n                     let dest = self.frame().locals[i];\n-                    self.move_(src, dest, src_ty)?;\n+                    self.write_value(arg_val, dest, arg_ty)?;\n                 }\n \n                 Ok(())\n@@ -344,7 +345,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         })\n     }\n \n-    fn unpack_fn_args(&self, args: &mut Vec<(Pointer, Ty<'tcx>)>) {\n+    fn unpack_fn_args(&self, args: &mut Vec<(Value, Ty<'tcx>)>) {\n         if let Some((last, last_ty)) = args.pop() {\n             let last_layout = self.type_layout(last_ty);\n             match (&last_ty.sty, last_layout) {\n@@ -353,9 +354,13 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     let offsets = iter::once(0)\n                         .chain(variant.offset_after_field.iter()\n                             .map(|s| s.bytes()));\n+                    let last_ptr = match last {\n+                        Value::ByRef(ptr) => ptr,\n+                        _ => bug!(\"rust-call ABI tuple argument wasn't Value::ByRef\"),\n+                    };\n                     for (offset, ty) in offsets.zip(fields) {\n-                        let src = last.offset(offset as isize);\n-                        args.push((src, ty));\n+                        let arg = Value::ByRef(last_ptr.offset(offset as isize));\n+                        args.push((arg, ty));\n                     }\n                 }\n                 ty => bug!(\"expected tuple as last argument in function with 'rust-call' ABI, got {:?}\", ty),\n@@ -369,7 +374,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         trait_id: DefId,\n         def_id: DefId,\n         substs: &'tcx Substs<'tcx>,\n-        args: &mut Vec<(Pointer, Ty<'tcx>)>,\n+        args: &mut Vec<(Value, Ty<'tcx>)>,\n     ) -> EvalResult<'tcx, (DefId, &'tcx Substs<'tcx>)> {\n         let trait_ref = ty::TraitRef::from_method(self.tcx, trait_id, substs);\n         let trait_ref = self.tcx.normalize_associated_type(&ty::Binder(trait_ref));\n@@ -398,6 +403,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     (ty::ClosureKind::FnMut, ty::ClosureKind::FnMut) |\n                     (ty::ClosureKind::FnOnce, ty::ClosureKind::FnOnce) |\n                     (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {} // No adapter needed.\n+\n                     (ty::ClosureKind::Fn, ty::ClosureKind::FnOnce) |\n                     (ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n                         // The closure fn is a `fn(&self, ...)` or `fn(&mut self, ...)`.\n@@ -409,13 +415,15 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                         //\n                         // These are both the same at trans time.\n \n-                        // interpreter magic: insert an intermediate pointer, so we can skip the intermediate function call\n-                        // FIXME: this is a memory leak, should probably add the pointer to the current stack\n-                        let ptr_size = self.memory.pointer_size();\n-                        let first = self.memory.allocate(ptr_size, ptr_size)?;\n-                        self.memory.copy(args[0].0, first, ptr_size, ptr_size)?;\n-                        self.memory.write_ptr(args[0].0, first)?;\n+                        // Interpreter magic: insert an intermediate pointer, so we can skip the\n+                        // intermediate function call.\n+                        // FIXME: this is a memory leak, should probably add the pointer to the\n+                        // current stack.\n+                        let first = self.value_to_ptr(args[0].0, args[0].1)?;\n+                        args[0].0 = Value::ByVal(PrimVal::Ptr(first));\n+                        args[0].1 = self.tcx.mk_mut_ptr(args[0].1);\n                     }\n+\n                     _ => bug!(\"cannot convert {:?} to {:?}\", closure_kind, trait_closure_kind),\n                 }\n                 Ok((vtable_closure.closure_def_id, vtable_closure.substs.func_substs))\n@@ -433,8 +441,11 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             traits::VtableObject(ref data) => {\n                 let idx = self.tcx.get_vtable_index_of_object_method(data, def_id);\n-                if let Some(&mut(first_arg, ref mut first_ty)) = args.get_mut(0) {\n-                    let (_, vtable) = self.get_fat_ptr(first_arg);\n+                if let Some(&mut(ref mut first_arg, ref mut first_ty)) = args.get_mut(0) {\n+                    // FIXME(solson): Remove this allocating hack.\n+                    let ptr = self.value_to_ptr(*first_arg, *first_ty)?;\n+                    *first_arg = Value::ByRef(ptr);\n+                    let (_, vtable) = self.get_fat_ptr(ptr);\n                     let vtable = self.memory.read_ptr(vtable)?;\n                     let idx = idx + 3;\n                     let offset = idx * self.memory.pointer_size();"}, {"sha": "0108f7e5d9c18d8594792a9ecb69744708c9c495", "filename": "src/memory.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "patch": "@@ -530,7 +530,7 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             PrimVal::F32(f) => self.write_f32(ptr, f),\n             PrimVal::F64(f) => self.write_f64(ptr, f),\n             PrimVal::FnPtr(p) |\n-            PrimVal::AbstractPtr(p) => self.write_ptr(ptr, p),\n+            PrimVal::Ptr(p) => self.write_ptr(ptr, p),\n         }\n     }\n "}, {"sha": "50ef05a245dfd96504911bf6403c0883aabbca2d", "filename": "src/primval.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Fprimval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17e336c7d9f2d2fe02f8403cff0eb1122630a81c/src%2Fprimval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fprimval.rs?ref=17e336c7d9f2d2fe02f8403cff0eb1122630a81c", "patch": "@@ -12,7 +12,7 @@ pub enum PrimVal {\n     I8(i8), I16(i16), I32(i32), I64(i64),\n     U8(u8), U16(u16), U32(u32), U64(u64),\n \n-    AbstractPtr(Pointer),\n+    Ptr(Pointer),\n     FnPtr(Pointer),\n     IntegerPtr(u64),\n     Char(char),\n@@ -211,10 +211,10 @@ pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> Eva\n \n         (IntegerPtr(l), IntegerPtr(r)) => int_binops!(IntegerPtr, l, r),\n \n-        (AbstractPtr(_), IntegerPtr(_)) |\n-        (IntegerPtr(_), AbstractPtr(_)) |\n-        (FnPtr(_), AbstractPtr(_)) |\n-        (AbstractPtr(_), FnPtr(_)) |\n+        (Ptr(_), IntegerPtr(_)) |\n+        (IntegerPtr(_), Ptr(_)) |\n+        (FnPtr(_), Ptr(_)) |\n+        (Ptr(_), FnPtr(_)) |\n         (FnPtr(_), IntegerPtr(_)) |\n         (IntegerPtr(_), FnPtr(_)) =>\n             unrelated_ptr_ops(bin_op)?,\n@@ -225,7 +225,7 @@ pub fn binary_op<'tcx>(bin_op: mir::BinOp, left: PrimVal, right: PrimVal) -> Eva\n             _ => return Err(EvalError::Unimplemented(format!(\"unimplemented fn ptr comparison: {:?}\", bin_op))),\n         },\n \n-        (AbstractPtr(l_ptr), AbstractPtr(r_ptr)) => {\n+        (Ptr(l_ptr), Ptr(r_ptr)) => {\n             if l_ptr.alloc_id != r_ptr.alloc_id {\n                 return Ok((unrelated_ptr_ops(bin_op)?, false));\n             }"}]}