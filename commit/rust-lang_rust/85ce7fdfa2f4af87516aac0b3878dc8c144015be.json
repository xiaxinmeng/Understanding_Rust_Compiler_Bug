{"sha": "85ce7fdfa2f4af87516aac0b3878dc8c144015be", "node_id": "C_kwDOAAsO6NoAKDg1Y2U3ZmRmYTJmNGFmODc1MTZhYWMwYjM4NzhkYzhjMTQ0MDE1YmU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-10T00:15:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-10T00:15:39Z"}, "message": "Auto merge of #94737 - lcnr:pass-stuff-by-value, r=davidtwco\n\nadd `#[rustc_pass_by_value]` to more types\n\nthe only interesting changes here should be to `TransitiveRelation`, but I believe to be highly unlikely that we will ever use a non `Copy` type with this type.", "tree": {"sha": "7560803aaf8a5f358dfe3b6750074be08e5ccb35", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7560803aaf8a5f358dfe3b6750074be08e5ccb35"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85ce7fdfa2f4af87516aac0b3878dc8c144015be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85ce7fdfa2f4af87516aac0b3878dc8c144015be", "html_url": "https://github.com/rust-lang/rust/commit/85ce7fdfa2f4af87516aac0b3878dc8c144015be", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85ce7fdfa2f4af87516aac0b3878dc8c144015be/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "458262b1315e0de7be940fe95e111bb045e4a2a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/458262b1315e0de7be940fe95e111bb045e4a2a4", "html_url": "https://github.com/rust-lang/rust/commit/458262b1315e0de7be940fe95e111bb045e4a2a4"}, {"sha": "b8135fd5c8e51a0578cff82096cbbf7e5d57fdeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8135fd5c8e51a0578cff82096cbbf7e5d57fdeb", "html_url": "https://github.com/rust-lang/rust/commit/b8135fd5c8e51a0578cff82096cbbf7e5d57fdeb"}], "stats": {"total": 317, "additions": 165, "deletions": 152}, "files": [{"sha": "c77bbeb86e5864506f999b48ed6566373d8e9135", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -220,8 +220,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 local,\n                 projection:\n-                    [\n-                        proj_base @ ..,\n+                    &[\n+                        ref proj_base @ ..,\n                         ProjectionElem::Deref,\n                         ProjectionElem::Field(field, _),\n                         ProjectionElem::Deref,\n@@ -342,7 +342,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     Applicability::MachineApplicable,\n                 );\n                 let tcx = self.infcx.tcx;\n-                if let ty::Closure(id, _) = the_place_err.ty(self.body, tcx).ty.kind() {\n+                if let ty::Closure(id, _) = *the_place_err.ty(self.body, tcx).ty.kind() {\n                     self.show_mutating_upvar(tcx, id, the_place_err, &mut err);\n                 }\n             }\n@@ -382,7 +382,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let tcx = self.infcx.tcx;\n                 if let ty::Ref(_, ty, Mutability::Mut) = the_place_err.ty(self.body, tcx).ty.kind()\n                 {\n-                    if let ty::Closure(id, _) = ty.kind() {\n+                    if let ty::Closure(id, _) = *ty.kind() {\n                         self.show_mutating_upvar(tcx, id, the_place_err, &mut err);\n                     }\n                 }\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     fn show_mutating_upvar(\n         &self,\n         tcx: TyCtxt<'_>,\n-        id: &hir::def_id::DefId,\n+        id: hir::def_id::DefId,\n         the_place_err: PlaceRef<'tcx>,\n         err: &mut Diagnostic,\n     ) {\n@@ -701,7 +701,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 let upvar = ty::place_to_string_for_capture(tcx, closure_kind_origin);\n                 let root_hir_id = upvar_id.var_path.hir_id;\n                 // we have an origin for this closure kind starting at this root variable so it's safe to unwrap here\n-                let captured_places = tables.closure_min_captures[id].get(&root_hir_id).unwrap();\n+                let captured_places = tables.closure_min_captures[&id].get(&root_hir_id).unwrap();\n \n                 let origin_projection = closure_kind_origin\n                     .projections\n@@ -1083,7 +1083,7 @@ fn is_closure_or_generator(ty: Ty<'_>) -> bool {\n fn get_mut_span_in_struct_field<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n-    field: &mir::Field,\n+    field: mir::Field,\n ) -> Option<Span> {\n     // Expect our local to be a reference to a struct of some kind.\n     if let ty::Ref(_, ty, _) = ty.kind()"}, {"sha": "c89da5514fd154e474a6a4a89853dad62d4d0d80", "filename": "compiler/rustc_borrowck/src/location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flocation.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -100,7 +100,7 @@ impl LocationTable {\n }\n \n impl LocationIndex {\n-    fn is_start(&self) -> bool {\n+    fn is_start(self) -> bool {\n         // even indices are start points; odd indices are mid points\n         (self.index() % 2) == 0\n     }"}, {"sha": "03b4a6ea98354f71ccbd5294b7bbaaa08e49761e", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -85,7 +85,7 @@ fn populate_polonius_move_facts(\n ) {\n     all_facts\n         .path_is_var\n-        .extend(move_data.rev_lookup.iter_locals_enumerated().map(|(v, &m)| (m, v)));\n+        .extend(move_data.rev_lookup.iter_locals_enumerated().map(|(l, r)| (r, l)));\n \n     for (child, move_path) in move_data.move_paths.iter_enumerated() {\n         if let Some(parent) = move_path.parent {\n@@ -135,7 +135,7 @@ fn populate_polonius_move_facts(\n         }\n     }\n \n-    for (local, &path) in move_data.rev_lookup.iter_locals_enumerated() {\n+    for (local, path) in move_data.rev_lookup.iter_locals_enumerated() {\n         if body.local_kind(local) != LocalKind::Arg {\n             // Non-arguments start out deinitialised; we simulate this with an\n             // initial move:\n@@ -226,7 +226,7 @@ pub(crate) fn compute_regions<'cx, 'tcx>(\n                      fr1={:?}, fr2={:?}\",\n                     fr1, fr2\n                 );\n-                all_facts.known_placeholder_subset.push((*fr1, *fr2));\n+                all_facts.known_placeholder_subset.push((fr1, fr2));\n             }\n         }\n     }"}, {"sha": "20f54d04777603f626cccef71c2b6cb6f2f7740a", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -942,14 +942,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             debug!(\"try_promote_type_test: ur={:?}\", ur);\n \n-            let non_local_ub = self.universal_region_relations.non_local_upper_bounds(&ur);\n+            let non_local_ub = self.universal_region_relations.non_local_upper_bounds(ur);\n             debug!(\"try_promote_type_test: non_local_ub={:?}\", non_local_ub);\n \n             // This is slightly too conservative. To show T: '1, given `'2: '1`\n             // and `'3: '1` we only need to prove that T: '2 *or* T: '3, but to\n             // avoid potential non-determinism we approximate this by requiring\n             // T: '1 and T: '2.\n-            for &upper_bound in non_local_ub {\n+            for upper_bound in non_local_ub {\n                 debug_assert!(self.universal_regions.is_universal_region(upper_bound));\n                 debug_assert!(!self.universal_regions.is_local_free_region(upper_bound));\n \n@@ -1588,12 +1588,12 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 // always will.)  We'll call them `shorter_fr+` -- they're ever\n                 // so slightly larger than `shorter_fr`.\n                 let shorter_fr_plus =\n-                    self.universal_region_relations.non_local_upper_bounds(&shorter_fr);\n+                    self.universal_region_relations.non_local_upper_bounds(shorter_fr);\n                 debug!(\n                     \"try_propagate_universal_region_error: shorter_fr_plus={:?}\",\n                     shorter_fr_plus\n                 );\n-                for &&fr in &shorter_fr_plus {\n+                for fr in shorter_fr_plus {\n                     // Push the constraint `fr-: shorter_fr+`\n                     propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n                         subject: ClosureOutlivesSubject::Region(fr_minus),"}, {"sha": "2e7798beb64845406f8d96c27ef64705a277bc29", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -99,18 +99,17 @@ impl UniversalRegionRelations<'_> {\n     crate fn postdom_upper_bound(&self, fr1: RegionVid, fr2: RegionVid) -> RegionVid {\n         assert!(self.universal_regions.is_universal_region(fr1));\n         assert!(self.universal_regions.is_universal_region(fr2));\n-        *self\n-            .inverse_outlives\n-            .postdom_upper_bound(&fr1, &fr2)\n-            .unwrap_or(&self.universal_regions.fr_static)\n+        self.inverse_outlives\n+            .postdom_upper_bound(fr1, fr2)\n+            .unwrap_or(self.universal_regions.fr_static)\n     }\n \n     /// Finds an \"upper bound\" for `fr` that is not local. In other\n     /// words, returns the smallest (*) known region `fr1` that (a)\n     /// outlives `fr` and (b) is not local.\n     ///\n     /// (*) If there are multiple competing choices, we return all of them.\n-    crate fn non_local_upper_bounds<'a>(&'a self, fr: &'a RegionVid) -> Vec<&'a RegionVid> {\n+    crate fn non_local_upper_bounds<'a>(&'a self, fr: RegionVid) -> Vec<RegionVid> {\n         debug!(\"non_local_upper_bound(fr={:?})\", fr);\n         let res = self.non_local_bounds(&self.inverse_outlives, fr);\n         assert!(!res.is_empty(), \"can't find an upper bound!?\");\n@@ -120,7 +119,7 @@ impl UniversalRegionRelations<'_> {\n     /// Returns the \"postdominating\" bound of the set of\n     /// `non_local_upper_bounds` for the given region.\n     crate fn non_local_upper_bound(&self, fr: RegionVid) -> RegionVid {\n-        let upper_bounds = self.non_local_upper_bounds(&fr);\n+        let upper_bounds = self.non_local_upper_bounds(fr);\n \n         // In case we find more than one, reduce to one for\n         // convenience.  This is to prevent us from generating more\n@@ -130,7 +129,7 @@ impl UniversalRegionRelations<'_> {\n         debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n \n         post_dom\n-            .and_then(|&post_dom| {\n+            .and_then(|post_dom| {\n                 // If the mutual immediate postdom is not local, then\n                 // there is no non-local result we can return.\n                 if !self.universal_regions.is_local_free_region(post_dom) {\n@@ -150,7 +149,7 @@ impl UniversalRegionRelations<'_> {\n     /// one. See `TransitiveRelation::postdom_upper_bound` for details.\n     crate fn non_local_lower_bound(&self, fr: RegionVid) -> Option<RegionVid> {\n         debug!(\"non_local_lower_bound(fr={:?})\", fr);\n-        let lower_bounds = self.non_local_bounds(&self.outlives, &fr);\n+        let lower_bounds = self.non_local_bounds(&self.outlives, fr);\n \n         // In case we find more than one, reduce to one for\n         // convenience.  This is to prevent us from generating more\n@@ -159,7 +158,7 @@ impl UniversalRegionRelations<'_> {\n \n         debug!(\"non_local_bound: post_dom={:?}\", post_dom);\n \n-        post_dom.and_then(|&post_dom| {\n+        post_dom.and_then(|post_dom| {\n             // If the mutual immediate postdom is not local, then\n             // there is no non-local result we can return.\n             if !self.universal_regions.is_local_free_region(post_dom) {\n@@ -176,19 +175,19 @@ impl UniversalRegionRelations<'_> {\n     fn non_local_bounds<'a>(\n         &self,\n         relation: &'a TransitiveRelation<RegionVid>,\n-        fr0: &'a RegionVid,\n-    ) -> Vec<&'a RegionVid> {\n+        fr0: RegionVid,\n+    ) -> Vec<RegionVid> {\n         // This method assumes that `fr0` is one of the universally\n         // quantified region variables.\n-        assert!(self.universal_regions.is_universal_region(*fr0));\n+        assert!(self.universal_regions.is_universal_region(fr0));\n \n         let mut external_parents = vec![];\n         let mut queue = vec![fr0];\n \n         // Keep expanding `fr` into its parents until we reach\n         // non-local regions.\n         while let Some(fr) = queue.pop() {\n-            if !self.universal_regions.is_local_free_region(*fr) {\n+            if !self.universal_regions.is_local_free_region(fr) {\n                 external_parents.push(fr);\n                 continue;\n             }\n@@ -205,17 +204,17 @@ impl UniversalRegionRelations<'_> {\n     ///\n     /// This will only ever be true for universally quantified regions.\n     crate fn outlives(&self, fr1: RegionVid, fr2: RegionVid) -> bool {\n-        self.outlives.contains(&fr1, &fr2)\n+        self.outlives.contains(fr1, fr2)\n     }\n \n     /// Returns a vector of free regions `x` such that `fr1: x` is\n     /// known to hold.\n-    crate fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<&RegionVid> {\n-        self.outlives.reachable_from(&fr1)\n+    crate fn regions_outlived_by(&self, fr1: RegionVid) -> Vec<RegionVid> {\n+        self.outlives.reachable_from(fr1)\n     }\n \n     /// Returns the _non-transitive_ set of known `outlives` constraints between free regions.\n-    crate fn known_outlives(&self) -> impl Iterator<Item = (&RegionVid, &RegionVid)> {\n+    crate fn known_outlives(&self) -> impl Iterator<Item = (RegionVid, RegionVid)> + '_ {\n         self.outlives.base_edges()\n     }\n }"}, {"sha": "95018e51b0e7a551480a4936f9fe8da197ef9122", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -1198,7 +1198,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 tcx,\n                 self.param_env,\n                 proj,\n-                |this, field, &()| {\n+                |this, field, ()| {\n                     let ty = this.field_ty(tcx, field);\n                     self.normalize(ty, locations)\n                 },"}, {"sha": "98ba38356a4c30c8cafcd806115ebff394581817", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmod.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -90,7 +90,7 @@ impl<'ll, 'tcx> CoverageInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     /// call. Since the function is never called, all other `CodeRegion`s can be\n     /// added as `unreachable_region`s.\n     fn define_unused_fn(&self, def_id: DefId) {\n-        let instance = declare_unused_fn(self, &def_id);\n+        let instance = declare_unused_fn(self, def_id);\n         codegen_unused_fn_and_counter(self, instance);\n         add_unused_function_coverage(self, instance, def_id);\n     }\n@@ -184,12 +184,12 @@ impl<'tcx> CoverageInfoBuilderMethods<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n-fn declare_unused_fn<'tcx>(cx: &CodegenCx<'_, 'tcx>, def_id: &DefId) -> Instance<'tcx> {\n+fn declare_unused_fn<'tcx>(cx: &CodegenCx<'_, 'tcx>, def_id: DefId) -> Instance<'tcx> {\n     let tcx = cx.tcx;\n \n     let instance = Instance::new(\n-        *def_id,\n-        InternalSubsts::for_item(tcx, *def_id, |param, _| {\n+        def_id,\n+        InternalSubsts::for_item(tcx, def_id, |param, _| {\n             if let ty::GenericParamDefKind::Lifetime = param.kind {\n                 tcx.lifetimes.re_erased.into()\n             } else {"}, {"sha": "780753ed200e997abb27b87f5a28f3c162924e56", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -49,7 +49,7 @@ struct Edge {\n     target: Index,\n }\n \n-impl<T: Eq + Hash> TransitiveRelation<T> {\n+impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n     pub fn is_empty(&self) -> bool {\n         self.edges.is_empty()\n     }\n@@ -58,8 +58,8 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n         self.elements.iter()\n     }\n \n-    fn index(&self, a: &T) -> Option<Index> {\n-        self.elements.get_index_of(a).map(Index)\n+    fn index(&self, a: T) -> Option<Index> {\n+        self.elements.get_index_of(&a).map(Index)\n     }\n \n     fn add_index(&mut self, a: T) -> Index {\n@@ -76,12 +76,12 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n     /// `None`.\n     pub fn maybe_map<F, U>(&self, mut f: F) -> Option<TransitiveRelation<U>>\n     where\n-        F: FnMut(&T) -> Option<U>,\n-        U: Clone + Debug + Eq + Hash + Clone,\n+        F: FnMut(T) -> Option<U>,\n+        U: Clone + Debug + Eq + Hash + Copy,\n     {\n         let mut result = TransitiveRelation::default();\n         for edge in &self.edges {\n-            result.add(f(&self.elements[edge.source.0])?, f(&self.elements[edge.target.0])?);\n+            result.add(f(self.elements[edge.source.0])?, f(self.elements[edge.target.0])?);\n         }\n         Some(result)\n     }\n@@ -100,7 +100,7 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n     }\n \n     /// Checks whether `a < target` (transitively)\n-    pub fn contains(&self, a: &T, b: &T) -> bool {\n+    pub fn contains(&self, a: T, b: T) -> bool {\n         match (self.index(a), self.index(b)) {\n             (Some(a), Some(b)) => self.with_closure(|closure| closure.contains(a.0, b.0)),\n             (None, _) | (_, None) => false,\n@@ -113,10 +113,10 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n     /// Really this probably ought to be `impl Iterator<Item = &T>`, but\n     /// I'm too lazy to make that work, and -- given the caching\n     /// strategy -- it'd be a touch tricky anyhow.\n-    pub fn reachable_from(&self, a: &T) -> Vec<&T> {\n+    pub fn reachable_from(&self, a: T) -> Vec<T> {\n         match self.index(a) {\n             Some(a) => {\n-                self.with_closure(|closure| closure.iter(a.0).map(|i| &self.elements[i]).collect())\n+                self.with_closure(|closure| closure.iter(a.0).map(|i| self.elements[i]).collect())\n             }\n             None => vec![],\n         }\n@@ -157,15 +157,15 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n     /// a -> a1\n     /// b -> b1\n     /// ```\n-    pub fn postdom_upper_bound(&self, a: &T, b: &T) -> Option<&T> {\n+    pub fn postdom_upper_bound(&self, a: T, b: T) -> Option<T> {\n         let mubs = self.minimal_upper_bounds(a, b);\n         self.mutual_immediate_postdominator(mubs)\n     }\n \n     /// Viewing the relation as a graph, computes the \"mutual\n     /// immediate postdominator\" of a set of points (if one\n     /// exists). See `postdom_upper_bound` for details.\n-    pub fn mutual_immediate_postdominator<'a>(&'a self, mut mubs: Vec<&'a T>) -> Option<&'a T> {\n+    pub fn mutual_immediate_postdominator<'a>(&'a self, mut mubs: Vec<T>) -> Option<T> {\n         loop {\n             match mubs.len() {\n                 0 => return None,\n@@ -189,7 +189,7 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n     ///     internal indices).\n     ///\n     /// Note that this set can, in principle, have any size.\n-    pub fn minimal_upper_bounds(&self, a: &T, b: &T) -> Vec<&T> {\n+    pub fn minimal_upper_bounds(&self, a: T, b: T) -> Vec<T> {\n         let (Some(mut a), Some(mut b)) = (self.index(a), self.index(b)) else {\n             return vec![];\n         };\n@@ -267,7 +267,7 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n         lub_indices\n             .into_iter()\n             .rev() // (4)\n-            .map(|i| &self.elements[i])\n+            .map(|i| self.elements[i])\n             .collect()\n     }\n \n@@ -290,7 +290,7 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n     ///\n     /// then `parents(a)` returns `[b, c]`. The `postdom_parent` function\n     /// would further reduce this to just `f`.\n-    pub fn parents(&self, a: &T) -> Vec<&T> {\n+    pub fn parents(&self, a: T) -> Vec<T> {\n         let Some(a) = self.index(a) else {\n             return vec![];\n         };\n@@ -314,7 +314,7 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n         ancestors\n             .into_iter()\n             .rev() // (4)\n-            .map(|i| &self.elements[i])\n+            .map(|i| self.elements[i])\n             .collect()\n     }\n \n@@ -350,10 +350,10 @@ impl<T: Eq + Hash> TransitiveRelation<T> {\n \n     /// Lists all the base edges in the graph: the initial _non-transitive_ set of element\n     /// relations, which will be later used as the basis for the transitive closure computation.\n-    pub fn base_edges(&self) -> impl Iterator<Item = (&T, &T)> {\n+    pub fn base_edges(&self) -> impl Iterator<Item = (T, T)> + '_ {\n         self.edges\n             .iter()\n-            .map(move |edge| (&self.elements[edge.source.0], &self.elements[edge.target.0]))\n+            .map(move |edge| (self.elements[edge.source.0], self.elements[edge.target.0]))\n     }\n }\n "}, {"sha": "f63b1be1ddce35a2efafe766fa39820b3ec7a4c2", "filename": "compiler/rustc_data_structures/src/transitive_relation/tests.rs", "status": "modified", "additions": 53, "deletions": 53, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation%2Ftests.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -1,9 +1,9 @@\n use super::*;\n \n-impl<T: Eq + Hash> TransitiveRelation<T> {\n+impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n     /// A \"best\" parent in some sense. See `parents` and\n     /// `postdom_upper_bound` for more details.\n-    fn postdom_parent(&self, a: &T) -> Option<&T> {\n+    fn postdom_parent(&self, a: T) -> Option<T> {\n         self.mutual_immediate_postdominator(self.parents(a))\n     }\n }\n@@ -13,10 +13,10 @@ fn test_one_step() {\n     let mut relation = TransitiveRelation::default();\n     relation.add(\"a\", \"b\");\n     relation.add(\"a\", \"c\");\n-    assert!(relation.contains(&\"a\", &\"c\"));\n-    assert!(relation.contains(&\"a\", &\"b\"));\n-    assert!(!relation.contains(&\"b\", &\"a\"));\n-    assert!(!relation.contains(&\"a\", &\"d\"));\n+    assert!(relation.contains(\"a\", \"c\"));\n+    assert!(relation.contains(\"a\", \"b\"));\n+    assert!(!relation.contains(\"b\", \"a\"));\n+    assert!(!relation.contains(\"a\", \"d\"));\n }\n \n #[test]\n@@ -32,17 +32,17 @@ fn test_many_steps() {\n \n     relation.add(\"e\", \"g\");\n \n-    assert!(relation.contains(&\"a\", &\"b\"));\n-    assert!(relation.contains(&\"a\", &\"c\"));\n-    assert!(relation.contains(&\"a\", &\"d\"));\n-    assert!(relation.contains(&\"a\", &\"e\"));\n-    assert!(relation.contains(&\"a\", &\"f\"));\n-    assert!(relation.contains(&\"a\", &\"g\"));\n+    assert!(relation.contains(\"a\", \"b\"));\n+    assert!(relation.contains(\"a\", \"c\"));\n+    assert!(relation.contains(\"a\", \"d\"));\n+    assert!(relation.contains(\"a\", \"e\"));\n+    assert!(relation.contains(\"a\", \"f\"));\n+    assert!(relation.contains(\"a\", \"g\"));\n \n-    assert!(relation.contains(&\"b\", &\"g\"));\n+    assert!(relation.contains(\"b\", \"g\"));\n \n-    assert!(!relation.contains(&\"a\", &\"x\"));\n-    assert!(!relation.contains(&\"b\", &\"f\"));\n+    assert!(!relation.contains(\"a\", \"x\"));\n+    assert!(!relation.contains(\"b\", \"f\"));\n }\n \n #[test]\n@@ -54,9 +54,9 @@ fn mubs_triangle() {\n     let mut relation = TransitiveRelation::default();\n     relation.add(\"a\", \"tcx\");\n     relation.add(\"b\", \"tcx\");\n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"tcx\"]);\n-    assert_eq!(relation.parents(&\"a\"), vec![&\"tcx\"]);\n-    assert_eq!(relation.parents(&\"b\"), vec![&\"tcx\"]);\n+    assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"tcx\"]);\n+    assert_eq!(relation.parents(\"a\"), vec![\"tcx\"]);\n+    assert_eq!(relation.parents(\"b\"), vec![\"tcx\"]);\n }\n \n #[test]\n@@ -81,10 +81,10 @@ fn mubs_best_choice1() {\n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"2\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"2\"]);\n-    assert_eq!(relation.parents(&\"2\"), vec![&\"1\"]);\n-    assert!(relation.parents(&\"1\").is_empty());\n+    assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"2\"]);\n+    assert_eq!(relation.parents(\"0\"), vec![\"2\"]);\n+    assert_eq!(relation.parents(\"2\"), vec![\"1\"]);\n+    assert!(relation.parents(\"1\").is_empty());\n }\n \n #[test]\n@@ -108,10 +108,10 @@ fn mubs_best_choice2() {\n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n-    assert_eq!(relation.parents(&\"1\"), vec![&\"2\"]);\n-    assert!(relation.parents(&\"2\").is_empty());\n+    assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\"]);\n+    assert_eq!(relation.parents(\"0\"), vec![\"1\"]);\n+    assert_eq!(relation.parents(\"1\"), vec![\"2\"]);\n+    assert!(relation.parents(\"2\").is_empty());\n }\n \n #[test]\n@@ -125,9 +125,9 @@ fn mubs_no_best_choice() {\n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\", &\"2\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"1\", &\"2\"]);\n-    assert_eq!(relation.parents(&\"3\"), vec![&\"1\", &\"2\"]);\n+    assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\", \"2\"]);\n+    assert_eq!(relation.parents(\"0\"), vec![\"1\", \"2\"]);\n+    assert_eq!(relation.parents(\"3\"), vec![\"1\", \"2\"]);\n }\n \n #[test]\n@@ -145,8 +145,8 @@ fn mubs_best_choice_scc() {\n     relation.add(\"3\", \"1\");\n     relation.add(\"3\", \"2\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n-    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n+    assert_eq!(relation.minimal_upper_bounds(\"0\", \"3\"), vec![\"1\"]);\n+    assert_eq!(relation.parents(\"0\"), vec![\"1\"]);\n }\n \n #[test]\n@@ -165,10 +165,10 @@ fn pdub_crisscross() {\n     relation.add(\"a1\", \"x\");\n     relation.add(\"b1\", \"x\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"a1\", &\"b1\"]);\n-    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n+    assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"a1\", \"b1\"]);\n+    assert_eq!(relation.postdom_upper_bound(\"a\", \"b\"), Some(\"x\"));\n+    assert_eq!(relation.postdom_parent(\"a\"), Some(\"x\"));\n+    assert_eq!(relation.postdom_parent(\"b\"), Some(\"x\"));\n }\n \n #[test]\n@@ -195,12 +195,12 @@ fn pdub_crisscross_more() {\n     relation.add(\"a3\", \"x\");\n     relation.add(\"b2\", \"x\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"a1\", &\"b1\"]);\n-    assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"), vec![&\"a2\", &\"b2\"]);\n-    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+    assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"a1\", \"b1\"]);\n+    assert_eq!(relation.minimal_upper_bounds(\"a1\", \"b1\"), vec![\"a2\", \"b2\"]);\n+    assert_eq!(relation.postdom_upper_bound(\"a\", \"b\"), Some(\"x\"));\n \n-    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(\"a\"), Some(\"x\"));\n+    assert_eq!(relation.postdom_parent(\"b\"), Some(\"x\"));\n }\n \n #[test]\n@@ -216,13 +216,13 @@ fn pdub_lub() {\n     relation.add(\"a1\", \"x\");\n     relation.add(\"b1\", \"x\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"x\"]);\n-    assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+    assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"x\"]);\n+    assert_eq!(relation.postdom_upper_bound(\"a\", \"b\"), Some(\"x\"));\n \n-    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"a1\"));\n-    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"b1\"));\n-    assert_eq!(relation.postdom_parent(&\"a1\"), Some(&\"x\"));\n-    assert_eq!(relation.postdom_parent(&\"b1\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(\"a\"), Some(\"a1\"));\n+    assert_eq!(relation.postdom_parent(\"b\"), Some(\"b1\"));\n+    assert_eq!(relation.postdom_parent(\"a1\"), Some(\"x\"));\n+    assert_eq!(relation.postdom_parent(\"b1\"), Some(\"x\"));\n }\n \n #[test]\n@@ -238,7 +238,7 @@ fn mubs_intermediate_node_on_one_side_only() {\n     relation.add(\"c\", \"d\");\n     relation.add(\"b\", \"d\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"d\"]);\n+    assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"d\"]);\n }\n \n #[test]\n@@ -259,7 +259,7 @@ fn mubs_scc_1() {\n     relation.add(\"a\", \"d\");\n     relation.add(\"b\", \"d\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+    assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n \n #[test]\n@@ -279,7 +279,7 @@ fn mubs_scc_2() {\n     relation.add(\"b\", \"d\");\n     relation.add(\"b\", \"c\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+    assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n \n #[test]\n@@ -300,7 +300,7 @@ fn mubs_scc_3() {\n     relation.add(\"b\", \"d\");\n     relation.add(\"b\", \"e\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+    assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n \n #[test]\n@@ -322,7 +322,7 @@ fn mubs_scc_4() {\n     relation.add(\"a\", \"d\");\n     relation.add(\"b\", \"e\");\n \n-    assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n+    assert_eq!(relation.minimal_upper_bounds(\"a\", \"b\"), vec![\"c\"]);\n }\n \n #[test]\n@@ -357,6 +357,6 @@ fn parent() {\n         relation.add(a, b);\n     }\n \n-    let p = relation.postdom_parent(&3);\n-    assert_eq!(p, Some(&0));\n+    let p = relation.postdom_parent(3);\n+    assert_eq!(p, Some(0));\n }"}, {"sha": "f23e3ce1901319b91788a93d76eda14e7f9c8664", "filename": "compiler/rustc_hir/src/hir_id.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir_id.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -13,6 +13,7 @@ use std::fmt;\n /// the code base.\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n #[derive(Encodable, Decodable)]\n+#[rustc_pass_by_value]\n pub struct HirId {\n     pub owner: LocalDefId,\n     pub local_id: ItemLocalId,"}, {"sha": "d56230e1dc57d46a76c9a03db4314f1cc472feb4", "filename": "compiler/rustc_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flib.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -9,6 +9,7 @@\n #![feature(once_cell)]\n #![feature(min_specialization)]\n #![feature(never_type)]\n+#![feature(rustc_attrs)]\n #![recursion_limit = \"256\"]\n \n #[macro_use]"}, {"sha": "082eb1bf11101456b1896ee85ed62a57158481d0", "filename": "compiler/rustc_infer/src/infer/free_regions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffree_regions.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -86,7 +86,7 @@ impl<'tcx> FreeRegionMap<'tcx> {\n \n     /// Check whether `r_a <= r_b` is found in the relation.\n     fn check_relation(&self, r_a: Region<'tcx>, r_b: Region<'tcx>) -> bool {\n-        r_a == r_b || self.relation.contains(&r_a, &r_b)\n+        r_a == r_b || self.relation.contains(r_a, r_b)\n     }\n \n     /// True for free regions other than `'static`.\n@@ -119,9 +119,9 @@ impl<'tcx> FreeRegionMap<'tcx> {\n         let result = if r_a == r_b {\n             r_a\n         } else {\n-            match self.relation.postdom_upper_bound(&r_a, &r_b) {\n+            match self.relation.postdom_upper_bound(r_a, r_b) {\n                 None => tcx.lifetimes.re_static,\n-                Some(r) => *r,\n+                Some(r) => r,\n             }\n         };\n         debug!(\"lub_free_regions(r_a={:?}, r_b={:?}) = {:?}\", r_a, r_b, result);\n@@ -132,6 +132,6 @@ impl<'tcx> FreeRegionMap<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<FreeRegionMap<'tcx>> {\n-        self.relation.maybe_map(|&fr| tcx.lift(fr)).map(|relation| FreeRegionMap { relation })\n+        self.relation.maybe_map(|fr| tcx.lift(fr)).map(|relation| FreeRegionMap { relation })\n     }\n }"}, {"sha": "c8b31cd0c4d784e2a04ac612f53deeb39202ee59", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -197,6 +197,7 @@ impl Parse for Newtype {\n             #(#attrs)*\n             #[derive(Clone, Copy, PartialEq, Eq, Hash, #(#derive_paths),*)]\n             #[rustc_layout_scalar_valid_range_end(#max)]\n+            #[rustc_pass_by_value]\n             #vis struct #name {\n                 private: u32,\n             }"}, {"sha": "a575f27ad3860206028497b52a38ec2ea2928d50", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -44,6 +44,7 @@\n #![feature(let_else)]\n #![feature(min_specialization)]\n #![feature(trusted_len)]\n+#![feature(type_alias_impl_trait)]\n #![feature(crate_visibility_modifier)]\n #![feature(associated_type_bounds)]\n #![feature(rustc_attrs)]"}, {"sha": "2336d460407e1df12faa2ca94be2241d000f6d54", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -46,7 +46,7 @@ impl CounterValueReference {\n \n     /// Returns explicitly-requested zero-based version of the counter id, used\n     /// during codegen. LLVM expects zero-based indexes.\n-    pub fn zero_based_index(&self) -> u32 {\n+    pub fn zero_based_index(self) -> u32 {\n         let one_based_index = self.as_u32();\n         debug_assert!(one_based_index > 0);\n         one_based_index - 1"}, {"sha": "632164b897a6f2ab02ac4ad9f34d3cdbe3ed56a3", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -1292,6 +1292,8 @@ pub enum InlineAsmOperand<'tcx> {\n /// Type for MIR `Assert` terminator error messages.\n pub type AssertMessage<'tcx> = AssertKind<Operand<'tcx>>;\n \n+// FIXME: Change `Successors` to `impl Iterator<Item = BasicBlock>`.\n+#[allow(rustc::pass_by_value)]\n pub type Successors<'a> =\n     iter::Chain<option::IntoIter<&'a BasicBlock>, slice::Iter<'a, BasicBlock>>;\n pub type SuccessorsMut<'a> =\n@@ -1832,7 +1834,8 @@ impl<V, T> ProjectionElem<V, T> {\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n \n-// At least on 64 bit systems, `PlaceElem` should not be larger than two pointers.\n+// This type is fairly frequently used, so we shouldn't unintentionally increase\n+// its size.\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n static_assert_size!(PlaceElem<'_>, 24);\n "}, {"sha": "6f85854fc745cc47c413bf349d58f5c57661b717", "filename": "compiler/rustc_middle/src/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Ftcx.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -33,7 +33,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// not carry a `Ty` for `T`.)\n     ///\n     /// Note that the resulting type has not been normalized.\n-    pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: &Field) -> Ty<'tcx> {\n+    pub fn field_ty(self, tcx: TyCtxt<'tcx>, f: Field) -> Ty<'tcx> {\n         let answer = match self.ty.kind() {\n             ty::Adt(adt_def, substs) => {\n                 let variant_def = match self.variant_index {\n@@ -57,7 +57,7 @@ impl<'tcx> PlaceTy<'tcx> {\n     /// `PlaceElem`, where we can just use the `Ty` that is already\n     /// stored inline on field projection elems.\n     pub fn projection_ty(self, tcx: TyCtxt<'tcx>, elem: PlaceElem<'tcx>) -> PlaceTy<'tcx> {\n-        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, &ty| ty)\n+        self.projection_ty_core(tcx, ty::ParamEnv::empty(), &elem, |_, _, ty| ty)\n     }\n \n     /// `place_ty.projection_ty_core(tcx, elem, |...| { ... })`\n@@ -70,11 +70,11 @@ impl<'tcx> PlaceTy<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         elem: &ProjectionElem<V, T>,\n-        mut handle_field: impl FnMut(&Self, &Field, &T) -> Ty<'tcx>,\n+        mut handle_field: impl FnMut(&Self, Field, T) -> Ty<'tcx>,\n     ) -> PlaceTy<'tcx>\n     where\n         V: ::std::fmt::Debug,\n-        T: ::std::fmt::Debug,\n+        T: ::std::fmt::Debug + Copy,\n     {\n         let answer = match *elem {\n             ProjectionElem::Deref => {\n@@ -105,7 +105,7 @@ impl<'tcx> PlaceTy<'tcx> {\n             ProjectionElem::Downcast(_name, index) => {\n                 PlaceTy { ty: self.ty, variant_index: Some(index) }\n             }\n-            ProjectionElem::Field(ref f, ref fty) => PlaceTy::from_ty(handle_field(&self, f, fty)),\n+            ProjectionElem::Field(f, fty) => PlaceTy::from_ty(handle_field(&self, f, fty)),\n         };\n         debug!(\"projection_ty self: {:?} elem: {:?} yields: {:?}\", self, elem, answer);\n         answer"}, {"sha": "aeb0f956eb4f78c7337f48df710ed012a9a09110", "filename": "compiler/rustc_middle/src/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fvisit.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -225,12 +225,14 @@ macro_rules! make_mir_visitor {\n                 self.super_var_debug_info(var_debug_info);\n             }\n \n+            #[allow(rustc::pass_by_value)]\n             fn visit_local(&mut self,\n                             _local: & $($mutability)? Local,\n                             _context: PlaceContext,\n                             _location: Location) {\n             }\n \n+            #[allow(rustc::pass_by_value)]\n             fn visit_source_scope(&mut self,\n                                       scope: & $($mutability)? SourceScope) {\n                 self.super_source_scope(scope);\n@@ -851,6 +853,7 @@ macro_rules! make_mir_visitor {\n                 }\n             }\n \n+            #[allow(rustc::pass_by_value)]\n             fn super_source_scope(&mut self,\n                                       _scope: & $($mutability)? SourceScope) {\n             }"}, {"sha": "1af789b4885e61c276d9f60106952dfb570b7c40", "filename": "compiler/rustc_mir_dataflow/src/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fmove_paths%2Fmod.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -37,8 +37,8 @@ rustc_index::newtype_index! {\n }\n \n impl MoveOutIndex {\n-    pub fn move_path_index(&self, move_data: &MoveData<'_>) -> MovePathIndex {\n-        move_data.moves[*self].path\n+    pub fn move_path_index(self, move_data: &MoveData<'_>) -> MovePathIndex {\n+        move_data.moves[self].path\n     }\n }\n \n@@ -338,8 +338,8 @@ impl MovePathLookup {\n     /// `MovePathIndex`es.\n     pub fn iter_locals_enumerated(\n         &self,\n-    ) -> impl DoubleEndedIterator<Item = (Local, &MovePathIndex)> + ExactSizeIterator {\n-        self.locals.iter_enumerated()\n+    ) -> impl DoubleEndedIterator<Item = (Local, MovePathIndex)> + ExactSizeIterator + '_ {\n+        self.locals.iter_enumerated().map(|(l, &idx)| (l, idx))\n     }\n }\n "}, {"sha": "87b9244c068edd7044aa68297c4748a9245a00eb", "filename": "compiler/rustc_mir_transform/src/check_unsafety.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_unsafety.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -127,7 +127,10 @@ impl<'tcx> Visitor<'tcx> for UnsafetyChecker<'_, 'tcx> {\n                 &AggregateKind::Closure(def_id, _) | &AggregateKind::Generator(def_id, _, _) => {\n                     let UnsafetyCheckResult { violations, used_unsafe_blocks, .. } =\n                         self.tcx.unsafety_check_result(def_id.expect_local());\n-                    self.register_violations(violations, used_unsafe_blocks);\n+                    self.register_violations(\n+                        violations,\n+                        used_unsafe_blocks.iter().map(|(&h, &d)| (h, d)),\n+                    );\n                 }\n             },\n             _ => {}\n@@ -261,7 +264,7 @@ impl<'tcx> UnsafetyChecker<'_, 'tcx> {\n     fn register_violations<'a>(\n         &mut self,\n         violations: impl IntoIterator<Item = &'a UnsafetyViolation>,\n-        new_used_unsafe_blocks: impl IntoIterator<Item = (&'a HirId, &'a UsedUnsafeBlockData)>,\n+        new_used_unsafe_blocks: impl IntoIterator<Item = (HirId, UsedUnsafeBlockData)>,\n     ) {\n         use UsedUnsafeBlockData::{AllAllowedInUnsafeFn, SomeDisallowedInUnsafeFn};\n \n@@ -318,7 +321,7 @@ impl<'tcx> UnsafetyChecker<'_, 'tcx> {\n \n         new_used_unsafe_blocks\n             .into_iter()\n-            .for_each(|(&hir_id, &usage_data)| update_entry(self, hir_id, usage_data));\n+            .for_each(|(hir_id, usage_data)| update_entry(self, hir_id, usage_data));\n     }\n     fn check_mut_borrowing_layout_constrained_field(\n         &mut self,"}, {"sha": "6bb7e676e851c6fa234c27c8768bbb4b963b798c", "filename": "compiler/rustc_mir_transform/src/coverage/graph.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fgraph.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -48,7 +48,7 @@ impl CoverageGraph {\n                 let mut bcb_successors = Vec::new();\n                 for successor in\n                     bcb_filtered_successors(&mir_body, &bcb_data.terminator(mir_body).kind)\n-                        .filter_map(|&successor_bb| bb_to_bcb[successor_bb])\n+                        .filter_map(|successor_bb| bb_to_bcb[successor_bb])\n                 {\n                     if !seen[successor] {\n                         seen[successor] = true;\n@@ -483,7 +483,7 @@ impl std::fmt::Debug for BcbBranch {\n fn bcb_filtered_successors<'a, 'tcx>(\n     body: &'tcx &'a mir::Body<'tcx>,\n     term_kind: &'tcx TerminatorKind<'tcx>,\n-) -> Box<dyn Iterator<Item = &'a BasicBlock> + 'a> {\n+) -> Box<dyn Iterator<Item = BasicBlock> + 'a> {\n     let mut successors = term_kind.successors();\n     Box::new(\n         match &term_kind {\n@@ -494,9 +494,8 @@ fn bcb_filtered_successors<'a, 'tcx>(\n             // `next().into_iter()`) into the `mir::Successors` aliased type.\n             _ => successors.next().into_iter().chain(&[]),\n         }\n-        .filter(move |&&successor| {\n-            body[successor].terminator().kind != TerminatorKind::Unreachable\n-        }),\n+        .copied()\n+        .filter(move |&successor| body[successor].terminator().kind != TerminatorKind::Unreachable),\n     )\n }\n \n@@ -695,7 +694,7 @@ pub struct ShortCircuitPreorder<\n     F: Fn(\n         &'tcx &'a mir::Body<'tcx>,\n         &'tcx TerminatorKind<'tcx>,\n-    ) -> Box<dyn Iterator<Item = &'a BasicBlock> + 'a>,\n+    ) -> Box<dyn Iterator<Item = BasicBlock> + 'a>,\n > {\n     body: &'tcx &'a mir::Body<'tcx>,\n     visited: BitSet<BasicBlock>,\n@@ -709,7 +708,7 @@ impl<\n     F: Fn(\n         &'tcx &'a mir::Body<'tcx>,\n         &'tcx TerminatorKind<'tcx>,\n-    ) -> Box<dyn Iterator<Item = &'a BasicBlock> + 'a>,\n+    ) -> Box<dyn Iterator<Item = BasicBlock> + 'a>,\n > ShortCircuitPreorder<'a, 'tcx, F>\n {\n     pub fn new(\n@@ -733,7 +732,7 @@ impl<\n     F: Fn(\n         &'tcx &'a mir::Body<'tcx>,\n         &'tcx TerminatorKind<'tcx>,\n-    ) -> Box<dyn Iterator<Item = &'a BasicBlock> + 'a>,\n+    ) -> Box<dyn Iterator<Item = BasicBlock> + 'a>,\n > Iterator for ShortCircuitPreorder<'a, 'tcx, F>\n {\n     type Item = (BasicBlock, &'a BasicBlockData<'tcx>);"}, {"sha": "abd75c20524e9640fe6ceb652721855cce0ada3f", "filename": "compiler/rustc_mir_transform/src/simplify_try.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify_try.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -707,7 +707,7 @@ impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n     ) -> StatementEquality {\n         let helper = |rhs: &Rvalue<'tcx>,\n                       place: &Place<'tcx>,\n-                      variant_index: &VariantIdx,\n+                      variant_index: VariantIdx,\n                       switch_value: u128,\n                       side_to_choose| {\n             let place_type = place.ty(self.body, self.tcx).ty;\n@@ -717,7 +717,7 @@ impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n             };\n             // We need to make sure that the switch value that targets the bb with\n             // SetDiscriminant is the same as the variant discriminant.\n-            let variant_discr = adt.discriminant_for_variant(self.tcx, *variant_index).val;\n+            let variant_discr = adt.discriminant_for_variant(self.tcx, variant_index).val;\n             if variant_discr != switch_value {\n                 trace!(\n                     \"NO: variant discriminant {} does not equal switch value {}\",\n@@ -726,7 +726,7 @@ impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n                 );\n                 return StatementEquality::NotEqual;\n             }\n-            let variant_is_fieldless = adt.variants[*variant_index].fields.is_empty();\n+            let variant_is_fieldless = adt.variants[variant_index].fields.is_empty();\n             if !variant_is_fieldless {\n                 trace!(\"NO: variant {:?} was not fieldless\", variant_index);\n                 return StatementEquality::NotEqual;\n@@ -753,7 +753,7 @@ impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n             // check for case A\n             (\n                 StatementKind::Assign(box (_, rhs)),\n-                StatementKind::SetDiscriminant { place, variant_index },\n+                &StatementKind::SetDiscriminant { ref place, variant_index },\n             ) if y_target_and_value.value.is_some() => {\n                 // choose basic block of x, as that has the assign\n                 helper(\n@@ -765,8 +765,8 @@ impl<'tcx> SimplifyBranchSameOptimizationFinder<'_, 'tcx> {\n                 )\n             }\n             (\n-                StatementKind::SetDiscriminant { place, variant_index },\n-                StatementKind::Assign(box (_, rhs)),\n+                &StatementKind::SetDiscriminant { ref place, variant_index },\n+                &StatementKind::Assign(box (_, ref rhs)),\n             ) if x_target_and_value.value.is_some() => {\n                 // choose basic block of y, as that has the assign\n                 helper("}, {"sha": "6d1b36796d869fec88463521d022bc76dea66489", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -27,8 +27,8 @@ impl CrateNum {\n     }\n \n     #[inline]\n-    pub fn as_def_id(&self) -> DefId {\n-        DefId { krate: *self, index: CRATE_DEF_INDEX }\n+    pub fn as_def_id(self) -> DefId {\n+        DefId { krate: self, index: CRATE_DEF_INDEX }\n     }\n }\n \n@@ -222,6 +222,7 @@ impl<D: Decoder> Decodable<D> for DefIndex {\n // On below-64 bit systems we can simply use the derived `Hash` impl\n #[cfg_attr(not(target_pointer_width = \"64\"), derive(Hash))]\n #[repr(C)]\n+#[rustc_pass_by_value]\n // We guarantee field order. Note that the order is essential here, see below why.\n pub struct DefId {\n     // cfg-ing the order of fields so that the `DefIndex` which is high entropy always ends up in"}, {"sha": "2b5ff11501abe9b98dbfee42f1d612d27d94babe", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -785,7 +785,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             // Add a label pointing to where a captured variable affected by drop order\n                             // is dropped\n                             if lint_note.reason.drop_order {\n-                                let drop_location_span = drop_location_span(self.tcx, &closure_hir_id);\n+                                let drop_location_span = drop_location_span(self.tcx, closure_hir_id);\n \n                                 match &lint_note.captures_info {\n                                     UpvarMigrationInfo::CapturingPrecise { var_name: captured_name, .. } => {\n@@ -1697,8 +1697,8 @@ fn apply_capture_kind_on_capture_ty<'tcx>(\n }\n \n /// Returns the Span of where the value with the provided HirId would be dropped\n-fn drop_location_span<'tcx>(tcx: TyCtxt<'tcx>, hir_id: &hir::HirId) -> Span {\n-    let owner_id = tcx.hir().get_enclosing_scope(*hir_id).unwrap();\n+fn drop_location_span<'tcx>(tcx: TyCtxt<'tcx>, hir_id: hir::HirId) -> Span {\n+    let owner_id = tcx.hir().get_enclosing_scope(hir_id).unwrap();\n \n     let owner_node = tcx.hir().get(owner_id);\n     let owner_span = match owner_node {"}, {"sha": "62598d23bd64e9536372257af02338e4f3707af8", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -702,10 +702,10 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     fn walk_captures(&mut self, closure_expr: &hir::Expr<'_>) {\n         fn upvar_is_local_variable<'tcx>(\n             upvars: Option<&'tcx FxIndexMap<hir::HirId, hir::Upvar>>,\n-            upvar_id: &hir::HirId,\n+            upvar_id: hir::HirId,\n             body_owner_is_closure: bool,\n         ) -> bool {\n-            upvars.map(|upvars| !upvars.contains_key(upvar_id)).unwrap_or(body_owner_is_closure)\n+            upvars.map(|upvars| !upvars.contains_key(&upvar_id)).unwrap_or(body_owner_is_closure)\n         }\n \n         debug!(\"walk_captures({:?})\", closure_expr);\n@@ -727,7 +727,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n                     PlaceBase::Upvar(upvar_id) => {\n                         if upvar_is_local_variable(\n                             upvars,\n-                            &upvar_id.var_path.hir_id,\n+                            upvar_id.var_path.hir_id,\n                             body_owner_is_closure,\n                         ) {\n                             // The nested closure might be fake reading the current (enclosing) closure's local variables."}, {"sha": "1f134be2cbc886339c47584cb5bf471eabdeb10e", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -543,10 +543,10 @@ impl<'a, 'tcx> PossibleBorrowerVisitor<'a, 'tcx> {\n                 continue;\n             }\n \n-            let borrowers = self.possible_borrower.reachable_from(&row);\n+            let borrowers = self.possible_borrower.reachable_from(row);\n             if !borrowers.is_empty() {\n                 let mut bs = HybridBitSet::new_empty(self.body.local_decls.len());\n-                for &c in borrowers {\n+                for c in borrowers {\n                     if c != mir::Local::from_usize(0) {\n                         bs.insert(c);\n                     }\n@@ -663,10 +663,10 @@ impl<'a, 'tcx> PossibleOriginVisitor<'a, 'tcx> {\n                 continue;\n             }\n \n-            let borrowers = self.possible_origin.reachable_from(&row);\n+            let borrowers = self.possible_origin.reachable_from(row);\n             if !borrowers.is_empty() {\n                 let mut bs = HybridBitSet::new_empty(self.body.local_decls.len());\n-                for &c in borrowers {\n+                for c in borrowers {\n                     if c != mir::Local::from_usize(0) {\n                         bs.insert(c);\n                     }"}, {"sha": "8c14f0dd761a20be5e0dd7a318aa53085a8911fe", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/85ce7fdfa2f4af87516aac0b3878dc8c144015be/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85ce7fdfa2f4af87516aac0b3878dc8c144015be/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=85ce7fdfa2f4af87516aac0b3878dc8c144015be", "patch": "@@ -489,7 +489,8 @@ pub fn def_path_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n     fn find_crate(tcx: TyCtxt<'_>, name: &str) -> Option<DefId> {\n         tcx.crates(())\n             .iter()\n-            .find(|&&num| tcx.crate_name(num).as_str() == name)\n+            .copied()\n+            .find(|&num| tcx.crate_name(num).as_str() == name)\n             .map(CrateNum::as_def_id)\n     }\n "}]}