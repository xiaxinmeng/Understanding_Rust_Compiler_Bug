{"sha": "47f37d67f14ef50829c4ff95a3a27a680fd4e1ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3ZjM3ZDY3ZjE0ZWY1MDgyOWM0ZmY5NWEzYTI3YTY4MGZkNGUxYmE=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-02T21:34:25Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-02T21:34:25Z"}, "message": "Correctly access ScalarPair fields during const eval", "tree": {"sha": "51e71813cffefd1d36c7c3efa9402a0117635355", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51e71813cffefd1d36c7c3efa9402a0117635355"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba", "html_url": "https://github.com/rust-lang/rust/commit/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d830f46b77bbb97fbff6397f0d9c352a880f796d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d830f46b77bbb97fbff6397f0d9c352a880f796d", "html_url": "https://github.com/rust-lang/rust/commit/d830f46b77bbb97fbff6397f0d9c352a880f796d"}], "stats": {"total": 159, "additions": 80, "deletions": 79}, "files": [{"sha": "d1f3b8b86de375d3f923f3eba4c0e8c1a5e06565", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=47f37d67f14ef50829c4ff95a3a27a680fd4e1ba", "patch": "@@ -136,8 +136,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Value::ScalarPair(..) |\n             Value::Scalar(_) if offset.bytes() == 0 && field.size == base_layout.size => Ok(Some((base, field.ty))),\n             // split fat pointers, 2 element tuples, ...\n-            Value::ScalarPair(a, b) if base_layout.fields.count() == 2 => {\n-                let val = [a, b][field_index];\n+            Value::ScalarPair(a, b) => {\n+                let val = if offset.bytes() == 0 { a } else { b };\n                 Ok(Some((Value::Scalar(val), field.ty)))\n             },\n             // FIXME(oli-obk): figure out whether we should be calling `try_read_value` here"}, {"sha": "8ed60b2325a82602171a3ad3942af5ba069ae446", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 32, "deletions": 58, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=47f37d67f14ef50829c4ff95a3a27a680fd4e1ba", "patch": "@@ -4,7 +4,7 @@ use rustc::ty::layout::LayoutOf;\n use syntax::codemap::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{EvalResult, Scalar, Value};\n+use rustc::mir::interpret::{EvalResult, Value};\n use super::{EvalContext, Place, Machine, ValTy};\n \n use rustc_data_structures::indexed_vec::Idx;\n@@ -338,65 +338,39 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n \n                         // unpack and write all other args\n                         let layout = self.layout_of(args[1].ty)?;\n-                        if let ty::TyTuple(..) = args[1].ty.sty {\n+                        if let ty::TyTuple(_) = args[1].ty.sty {\n+                            if layout.is_zst() {\n+                                // Nothing to do, no need to unpack zsts\n+                                return Ok(());\n+                            }\n                             if self.frame().mir.args_iter().count() == layout.fields.count() + 1 {\n-                                match args[1].value {\n-                                    Value::ByRef(ptr, align) => {\n-                                        for (i, arg_local) in arg_locals.enumerate() {\n-                                            let field = layout.field(&self, i)?;\n-                                            let offset = layout.fields.offset(i);\n-                                            let arg = Value::ByRef(ptr.ptr_offset(offset, &self)?,\n-                                                                   align.min(field.align));\n-                                            let dest =\n-                                                self.eval_place(&mir::Place::Local(arg_local))?;\n-                                            trace!(\n-                                                \"writing arg {:?} to {:?} (type: {})\",\n-                                                arg,\n-                                                dest,\n-                                                field.ty\n-                                            );\n-                                            let valty = ValTy {\n-                                                value: arg,\n-                                                ty: field.ty,\n-                                            };\n-                                            self.write_value(valty, dest)?;\n-                                        }\n-                                    }\n-                                    Value::Scalar(Scalar::Bits { defined: 0, .. }) => {}\n-                                    other => {\n-                                        trace!(\"{:#?}, {:#?}\", other, layout);\n-                                        let mut layout = layout;\n-                                        'outer: loop {\n-                                            for i in 0..layout.fields.count() {\n-                                                let field = layout.field(&self, i)?;\n-                                                if layout.fields.offset(i).bytes() == 0 && layout.size == field.size {\n-                                                    layout = field;\n-                                                    continue 'outer;\n-                                                }\n-                                            }\n-                                            break;\n-                                        }\n-                                        {\n-                                            let mut write_next = |value| {\n-                                                let dest = self.eval_place(&mir::Place::Local(\n-                                                    arg_locals.next().unwrap(),\n-                                                ))?;\n-                                                let valty = ValTy {\n-                                                    value: Value::Scalar(value),\n-                                                    ty: layout.ty,\n-                                                };\n-                                                self.write_value(valty, dest)\n-                                            };\n-                                            match other {\n-                                                Value::Scalar(value) | Value::ScalarPair(value, _) => write_next(value)?,\n-                                                _ => unreachable!(),\n-                                            }\n-                                            if let Value::ScalarPair(_, value) = other {\n-                                                write_next(value)?;\n-                                            }\n-                                        }\n-                                        assert!(arg_locals.next().is_none());\n+                                for (i, arg_local) in arg_locals.enumerate() {\n+                                    let field = layout.field(&self, i)?;\n+                                    if field.is_zst() {\n+                                        continue;\n                                     }\n+                                    let offset = layout.fields.offset(i);\n+                                    let value = match args[1].value {\n+                                        Value::ByRef(ptr, align) => Value::ByRef(\n+                                            ptr.ptr_offset(offset, &self)?,\n+                                            align.min(field.align),\n+                                        ),\n+                                        other if field.size == layout.size => {\n+                                            // this is the case where the field covers the entire type\n+                                            assert_eq!(offset.bytes(), 0);\n+                                            other\n+                                        },\n+                                        Value::ScalarPair(a, _) if offset.bytes() == 0 => Value::Scalar(a),\n+                                        Value::ScalarPair(_, b) => Value::Scalar(b),\n+                                        Value::Scalar(_) => bug!(\"Scalar does not cover entire type\"),\n+                                    };\n+                                    let dest =\n+                                        self.eval_place(&mir::Place::Local(arg_local))?;\n+                                    let valty = ValTy {\n+                                        value,\n+                                        ty: field.ty,\n+                                    };\n+                                    self.write_value(valty, dest)?;\n                                 }\n                             } else {\n                                 trace!(\"manual impl of rust-call ABI\");"}, {"sha": "4ef3fb5663f7b3236fdf3028e8dcbea6fb271e32", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=47f37d67f14ef50829c4ff95a3a27a680fd4e1ba", "patch": "@@ -29,7 +29,7 @@ use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc::ty::ParamEnv;\n use rustc::ty::layout::{\n-    LayoutOf, TyLayout, LayoutError, LayoutCx,\n+    LayoutOf, TyLayout, LayoutError,\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n@@ -214,24 +214,10 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 ProjectionElem::Field(field, _) => {\n                     trace!(\"field proj on {:?}\", proj.base);\n                     let (base, ty, span) = self.eval_place(&proj.base)?;\n-                    match base {\n-                        Value::ScalarPair(a, b) => {\n-                            trace!(\"by val pair: {:?}, {:?}\", a, b);\n-                            let base_layout = self.tcx.layout_of(self.param_env.and(ty)).ok()?;\n-                            trace!(\"layout computed\");\n-                            use rustc_data_structures::indexed_vec::Idx;\n-                            let field_index = field.index();\n-                            let val = [a, b][field_index];\n-                            let cx = LayoutCx {\n-                                tcx: self.tcx,\n-                                param_env: self.param_env,\n-                            };\n-                            let field = base_layout.field(cx, field_index).ok()?;\n-                            trace!(\"projection resulted in: {:?}\", val);\n-                            Some((Value::Scalar(val), field.ty, span))\n-                        },\n-                        _ => None,\n-                    }\n+                    let (value, field_ty) = self.use_ecx(span, |this| {\n+                        this.ecx.read_field(base, None, field, ty)\n+                    })??;\n+                    Some((value, field_ty, span))\n                 },\n                 _ => None,\n             },"}, {"sha": "f91711c3c0f242c64321ed3af4876c629a0b5b31", "filename": "src/test/ui/const-eval/issue-51300.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba/src%2Ftest%2Fui%2Fconst-eval%2Fissue-51300.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47f37d67f14ef50829c4ff95a3a27a680fd4e1ba/src%2Ftest%2Fui%2Fconst-eval%2Fissue-51300.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-eval%2Fissue-51300.rs?ref=47f37d67f14ef50829c4ff95a3a27a680fd4e1ba", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+// https://github.com/rust-lang/rust/issues/51300\n+\n+#[derive(PartialEq, Eq, Clone, Copy)]\n+pub struct Stat {\n+    pub id: u8,\n+    pub index: usize,\n+}\n+\n+impl Stat {\n+    pub const STUDENT_HAPPINESS: Stat = Stat{\n+        id: 0,\n+        index: 0,\n+    };\n+    pub const STUDENT_HUNGER: Stat = Stat{\n+        id: 0,\n+        index: Self::STUDENT_HAPPINESS.index + 1,\n+    };\n+\n+}\n+\n+pub fn from_index(id: u8, index: usize) -> Option<Stat> {\n+    let stat = Stat{id, index};\n+    match stat {\n+        Stat::STUDENT_HAPPINESS => Some(Stat::STUDENT_HAPPINESS),\n+        Stat::STUDENT_HUNGER => Some(Stat::STUDENT_HUNGER),\n+        _ => None,\n+    }\n+}\n+\n+fn main() { }"}]}