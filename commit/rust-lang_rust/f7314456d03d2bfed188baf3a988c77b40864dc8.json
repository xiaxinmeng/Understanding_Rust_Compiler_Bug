{"sha": "f7314456d03d2bfed188baf3a988c77b40864dc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3MzE0NDU2ZDAzZDJiZmVkMTg4YmFmM2E5ODhjNzdiNDA4NjRkYzg=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-18T14:52:32Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2018-12-18T14:54:06Z"}, "message": "Mark tuple structs as live if their constructors are used", "tree": {"sha": "139790089c657b0748b0f50c698e1d3e91e249ae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/139790089c657b0748b0f50c698e1d3e91e249ae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f7314456d03d2bfed188baf3a988c77b40864dc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f7314456d03d2bfed188baf3a988c77b40864dc8", "html_url": "https://github.com/rust-lang/rust/commit/f7314456d03d2bfed188baf3a988c77b40864dc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f7314456d03d2bfed188baf3a988c77b40864dc8/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "041254b81495a5aa67af839e00b890e78ed0cbeb", "url": "https://api.github.com/repos/rust-lang/rust/commits/041254b81495a5aa67af839e00b890e78ed0cbeb", "html_url": "https://github.com/rust-lang/rust/commit/041254b81495a5aa67af839e00b890e78ed0cbeb"}], "stats": {"total": 104, "additions": 61, "deletions": 43}, "files": [{"sha": "3f5b614df9dc236ff9f8bb481afbf5568a30509c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f7314456d03d2bfed188baf3a988c77b40864dc8/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7314456d03d2bfed188baf3a988c77b40864dc8/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f7314456d03d2bfed188baf3a988c77b40864dc8", "patch": "@@ -2119,7 +2119,7 @@ impl StructField {\n /// Id of the whole enum lives in `Item`.\n ///\n /// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n-/// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n+/// used for `Struct`-structs (but still present). Structures don't have an analogue of \"Id of\n /// the variant itself\" from enum variants.\n /// Id of the whole struct lives in `Item`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "d2175c28309b1093c34a72f7c247bfebf81ced91", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/f7314456d03d2bfed188baf3a988c77b40864dc8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7314456d03d2bfed188baf3a988c77b40864dc8/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f7314456d03d2bfed188baf3a988c77b40864dc8", "patch": "@@ -25,6 +25,8 @@ use middle::privacy;\n use ty::{self, TyCtxt};\n use util::nodemap::FxHashSet;\n \n+use rustc_data_structures::fx::FxHashMap;\n+\n use syntax::{ast, source_map};\n use syntax::attr;\n use syntax_pos;\n@@ -55,12 +57,15 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     in_pat: bool,\n     inherited_pub_visibility: bool,\n     ignore_variant_stack: Vec<DefId>,\n+    // maps from tuple struct constructors to tuple struct items\n+    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-            if should_explore(self.tcx, node_id) {\n+            if should_explore(self.tcx, node_id) ||\n+               self.struct_constructors.contains_key(&node_id) {\n                 self.worklist.push(node_id);\n             }\n             self.live_symbols.insert(node_id);\n@@ -137,19 +142,23 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref node) = self.tcx.hir().find(id) {\n+            // in the case of tuple struct constructors we want to check the item, not the generated\n+            // tuple struct constructor function\n+            let id = self.struct_constructors.get(&id).cloned().unwrap_or(id);\n+\n+            if let Some(node) = self.tcx.hir().find(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }\n         }\n     }\n \n-    fn visit_node(&mut self, node: &Node<'tcx>) {\n+    fn visit_node(&mut self, node: Node<'tcx>) {\n         let had_repr_c = self.repr_has_repr_c;\n         self.repr_has_repr_c = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n         self.inherited_pub_visibility = false;\n-        match *node {\n+        match node {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n@@ -337,6 +346,8 @@ struct LifeSeeder<'k, 'tcx: 'k> {\n     worklist: Vec<ast::NodeId>,\n     krate: &'k hir::Crate,\n     tcx: TyCtxt<'k, 'tcx, 'tcx>,\n+    // see `MarkSymbolVisitor::struct_constructors`\n+    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n }\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n@@ -379,6 +390,9 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     }\n                 }\n             }\n+            hir::ItemKind::Struct(ref variant_data, _) => {\n+                self.struct_constructors.insert(variant_data.id(), item.id);\n+            }\n             _ => ()\n         }\n     }\n@@ -392,11 +406,11 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     }\n }\n \n-fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      access_levels: &privacy::AccessLevels,\n-                                      krate: &hir::Crate)\n-                                      -> Vec<ast::NodeId>\n-{\n+fn create_and_seed_worklist<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    access_levels: &privacy::AccessLevels,\n+    krate: &hir::Crate,\n+) -> (Vec<ast::NodeId>, FxHashMap<ast::NodeId, ast::NodeId>) {\n     let worklist = access_levels.map.iter().filter_map(|(&id, level)| {\n         if level >= &privacy::AccessLevel::Reachable {\n             Some(id)\n@@ -413,17 +427,18 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         worklist,\n         krate,\n         tcx,\n+        struct_constructors: Default::default(),\n     };\n     krate.visit_all_item_likes(&mut life_seeder);\n \n-    return life_seeder.worklist;\n+    (life_seeder.worklist, life_seeder.struct_constructors)\n }\n \n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n                        -> FxHashSet<ast::NodeId> {\n-    let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n+    let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n         tcx,\n@@ -433,20 +448,12 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         in_pat: false,\n         inherited_pub_visibility: false,\n         ignore_variant_stack: vec![],\n+        struct_constructors,\n     };\n     symbol_visitor.mark_live_symbols();\n     symbol_visitor.live_symbols\n }\n \n-fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n-    match item.node {\n-        hir::ItemKind::Struct(ref struct_def, _) if !struct_def.is_struct() => {\n-            Some(struct_def.id())\n-        }\n-        _ => None\n-    }\n-}\n-\n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     live_symbols: FxHashSet<ast::NodeId>,\n@@ -464,46 +471,35 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             | hir::ItemKind::Union(..) => true,\n             _ => false\n         };\n-        let ctor_id = get_struct_ctor_id(item);\n-        should_warn && !self.symbol_is_live(item.id, ctor_id)\n+        should_warn && !self.symbol_is_live(item.id)\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n         let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n         !field.is_positional()\n-            && !self.symbol_is_live(field.id, None)\n+            && !self.symbol_is_live(field.id)\n             && !field_type.is_phantom_data()\n             && !has_allow_dead_code_or_lang_attr(self.tcx, field.id, &field.attrs)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n-        !self.symbol_is_live(variant.data.id(), None)\n+        !self.symbol_is_live(variant.data.id())\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n                                                  variant.data.id(),\n                                                  &variant.attrs)\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem) -> bool {\n-        !self.symbol_is_live(fi.id, None)\n+        !self.symbol_is_live(fi.id)\n             && !has_allow_dead_code_or_lang_attr(self.tcx, fi.id, &fi.attrs)\n     }\n \n     // id := node id of an item's definition.\n-    // ctor_id := `Some` if the item is a struct_ctor (tuple struct),\n-    //            `None` otherwise.\n-    // If the item is a struct_ctor, then either its `id` or\n-    // `ctor_id` (unwrapped) is in the live_symbols set. More specifically,\n-    // DefMap maps the ExprKind::Path of a struct_ctor to the node referred by\n-    // `ctor_id`. On the other hand, in a statement like\n-    // `type <ident> <generics> = <ty>;` where <ty> refers to a struct_ctor,\n-    // DefMap maps <ty> to `id` instead.\n-    fn symbol_is_live(&mut self,\n-                      id: ast::NodeId,\n-                      ctor_id: Option<ast::NodeId>)\n-                      -> bool {\n-        if self.live_symbols.contains(&id)\n-           || ctor_id.map_or(false, |ctor| self.live_symbols.contains(&ctor))\n-        {\n+    fn symbol_is_live(\n+        &mut self,\n+        id: ast::NodeId,\n+    ) -> bool {\n+        if self.live_symbols.contains(&id) {\n             return true;\n         }\n         // If it's a type whose items are live, then it's live, too.\n@@ -611,7 +607,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id, None) {\n+                if !self.symbol_is_live(impl_item.id) {\n                     self.warn_dead_code(impl_item.id,\n                                         impl_item.span,\n                                         impl_item.ident.name,\n@@ -621,7 +617,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id, None) {\n+                if !self.symbol_is_live(impl_item.id) {\n                     let span = self.tcx.sess.source_map().def_span(impl_item.span);\n                     self.warn_dead_code(impl_item.id, span, impl_item.ident.name, \"method\", \"used\");\n                 }"}, {"sha": "f4989fa1037d3f04fc5cfbdde3f6a6142168955f", "filename": "src/test/ui/dead-code-tuple-struct-field.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f7314456d03d2bfed188baf3a988c77b40864dc8/src%2Ftest%2Fui%2Fdead-code-tuple-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f7314456d03d2bfed188baf3a988c77b40864dc8/src%2Ftest%2Fui%2Fdead-code-tuple-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdead-code-tuple-struct-field.rs?ref=f7314456d03d2bfed188baf3a988c77b40864dc8", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-pass\n+\n+#![deny(dead_code)]\n+\n+const LEN: usize = 4;\n+\n+#[derive(Debug)]\n+struct Wrapper([u8; LEN]);\n+\n+fn main() {\n+    println!(\"{:?}\", Wrapper([0, 1, 2, 3]));\n+}"}]}