{"sha": "6a28fb42a8b8f1f67fe854c2206148171e434d73", "node_id": "C_kwDOAAsO6NoAKDZhMjhmYjQyYThiOGYxZjY3ZmU4NTRjMjIwNjE0ODE3MWU0MzRkNzM", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-16T20:34:16Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-01-17T08:09:33Z"}, "message": "Remove double spaces after dots in comments", "tree": {"sha": "eeab4f46bee891a43cc8aa71db6692a55a8dde73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eeab4f46bee891a43cc8aa71db6692a55a8dde73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a28fb42a8b8f1f67fe854c2206148171e434d73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a28fb42a8b8f1f67fe854c2206148171e434d73", "html_url": "https://github.com/rust-lang/rust/commit/6a28fb42a8b8f1f67fe854c2206148171e434d73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a28fb42a8b8f1f67fe854c2206148171e434d73/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "279f1c9d8c26a8d227ae8ab806d262bb784b251b", "url": "https://api.github.com/repos/rust-lang/rust/commits/279f1c9d8c26a8d227ae8ab806d262bb784b251b", "html_url": "https://github.com/rust-lang/rust/commit/279f1c9d8c26a8d227ae8ab806d262bb784b251b"}], "stats": {"total": 626, "additions": 313, "deletions": 313}, "files": [{"sha": "accdb6da782d8b5fc35f354676fd714849473385", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1263,8 +1263,8 @@ pub enum Variants<V: Idx> {\n \n     /// Enum-likes with more than one inhabited variant: each variant comes with\n     /// a *discriminant* (usually the same as the variant index but the user can\n-    /// assign explicit discriminant values).  That discriminant is encoded\n-    /// as a *tag* on the machine.  The layout of each variant is\n+    /// assign explicit discriminant values). That discriminant is encoded\n+    /// as a *tag* on the machine. The layout of each variant is\n     /// a struct, and they all have space reserved for the tag.\n     /// For enums, the tag is the sole field of the layout.\n     Multiple {"}, {"sha": "4f7099c7be8a6561492a22b210643768b9db4a2a", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -304,7 +304,7 @@ impl ExprPrecedence {\n             | ExprPrecedence::Yeet => PREC_JUMP,\n \n             // `Range` claims to have higher precedence than `Assign`, but `x .. x = x` fails to\n-            // parse, instead of parsing as `(x .. x) = x`.  Giving `Range` a lower precedence\n+            // parse, instead of parsing as `(x .. x) = x`. Giving `Range` a lower precedence\n             // ensures that `pprust` will add parentheses in the right places to get the desired\n             // parse.\n             ExprPrecedence::Range => PREC_RANGE,"}, {"sha": "63033085bec674de5bbc4159cf980c8f5a5ed289", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -38,7 +38,7 @@ pub(super) fn index_hir<'hir>(\n ) -> (IndexVec<ItemLocalId, Option<ParentedNode<'hir>>>, FxHashMap<LocalDefId, ItemLocalId>) {\n     let mut nodes = IndexVec::new();\n     // This node's parent should never be accessed: the owner's parent is computed by the\n-    // hir_owner_parent query.  Make it invalid (= ItemLocalId::MAX) to force an ICE whenever it is\n+    // hir_owner_parent query. Make it invalid (= ItemLocalId::MAX) to force an ICE whenever it is\n     // used.\n     nodes.push(Some(ParentedNode { parent: ItemLocalId::INVALID, node: item.into() }));\n     let mut collector = NodeCollector {"}, {"sha": "5d2589cb2b2f7817a8603a1319eed39a727fd597", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -523,7 +523,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 //\n                 // The first two are produced by recursively invoking\n                 // `lower_use_tree` (and indeed there may be things\n-                // like `use foo::{a::{b, c}}` and so forth).  They\n+                // like `use foo::{a::{b, c}}` and so forth). They\n                 // wind up being directly added to\n                 // `self.items`. However, the structure of this\n                 // function also requires us to return one item, and"}, {"sha": "1f3473dcf2290d8e44548670ac1b68dfaec94e4d", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -663,7 +663,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         self.arena.alloc(hir::OwnerInfo { nodes, parenting, attrs, trait_map })\n     }\n \n-    /// Hash the HIR node twice, one deep and one shallow hash.  This allows to differentiate\n+    /// Hash the HIR node twice, one deep and one shallow hash. This allows to differentiate\n     /// queries which depend on the full HIR tree and those which only depend on the item signature.\n     fn hash_owner(\n         &mut self,\n@@ -1194,7 +1194,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         itctx: &ImplTraitContext,\n     ) -> hir::Ty<'hir> {\n         // Check whether we should interpret this as a bare trait object.\n-        // This check mirrors the one in late resolution.  We only introduce this special case in\n+        // This check mirrors the one in late resolution. We only introduce this special case in\n         // the rare occurrence we need to lower `Fresh` anonymous lifetimes.\n         // The other cases when a qpath should be opportunistically made a trait object are handled\n         // by `ty_path`.\n@@ -1919,7 +1919,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             this.with_remapping(new_remapping, |this| {\n                 // We have to be careful to get elision right here. The\n                 // idea is that we create a lifetime parameter for each\n-                // lifetime in the return type.  So, given a return type\n+                // lifetime in the return type. So, given a return type\n                 // like `async fn foo(..) -> &[&u32]`, we lower to `impl\n                 // Future<Output = &'1 [ &'2 u32 ]>`.\n                 //\n@@ -2013,7 +2013,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n         // Foo = impl Trait` is, internally, created as a child of the\n-        // async fn, so the *type parameters* are inherited.  It's\n+        // async fn, so the *type parameters* are inherited. It's\n         // only the lifetime parameters that we must supply.\n         let opaque_ty_ref = hir::TyKind::OpaqueDef(\n             hir::ItemId { owner_id: hir::OwnerId { def_id: opaque_ty_def_id } },"}, {"sha": "2a18e5164a309bbb360ccae43d46565b4e83f9ff", "filename": "compiler/rustc_ast_pretty/src/pprust/state/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate%2Fexpr.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -473,10 +473,10 @@ impl<'a> State<'a> {\n                 self.word(\"]\");\n             }\n             ast::ExprKind::Range(start, end, limits) => {\n-                // Special case for `Range`.  `AssocOp` claims that `Range` has higher precedence\n+                // Special case for `Range`. `AssocOp` claims that `Range` has higher precedence\n                 // than `Assign`, but `x .. x = x` gives a parse error instead of `x .. (x = x)`.\n                 // Here we use a fake precedence value so that any child with lower precedence than\n-                // a \"normal\" binop gets parenthesized.  (`LOr` is the lowest-precedence binop.)\n+                // a \"normal\" binop gets parenthesized. (`LOr` is the lowest-precedence binop.)\n                 let fake_prec = AssocOp::LOr.precedence() as i8;\n                 if let Some(e) = start {\n                     self.print_expr_maybe_paren(e, fake_prec);"}, {"sha": "2384f851a662d60c945d4c8d5b668e6886129231", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -2173,7 +2173,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     // `self.foo` -- we want to double\n                                     // check that the location `*self`\n                                     // is mutable (i.e., this is not a\n-                                    // `Fn` closure).  But if that\n+                                    // `Fn` closure). But if that\n                                     // check succeeds, we want to\n                                     // *blame* the mutability on\n                                     // `place` (that is,"}, {"sha": "4af324f740aef686c98d68bd329660555744bae2", "filename": "compiler/rustc_borrowck/src/member_constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fmember_constraints.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -109,7 +109,7 @@ where\n     R1: Copy + Hash + Eq,\n {\n     /// Remap the \"member region\" key using `map_fn`, producing a new\n-    /// member constraint set.  This is used in the NLL code to map from\n+    /// member constraint set. This is used in the NLL code to map from\n     /// the original `RegionVid` to an scc index. In some cases, we\n     /// may have multiple `R1` values mapping to the same `R2` key -- that\n     /// is ok, the two sets will be merged.\n@@ -158,7 +158,7 @@ where\n     }\n \n     /// Iterate down the constraint indices associated with a given\n-    /// peek-region.  You can then use `choice_regions` and other\n+    /// peek-region. You can then use `choice_regions` and other\n     /// methods to access data.\n     pub(crate) fn indices(\n         &self,"}, {"sha": "b2d92d0dba7a4de1cb38292dc7e9cb545f880d86", "filename": "compiler/rustc_borrowck/src/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fnll.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -385,7 +385,7 @@ pub(super) fn dump_annotation<'tcx>(\n \n     // When the enclosing function is tagged with `#[rustc_regions]`,\n     // we dump out various bits of state as warnings. This is useful\n-    // for verifying that the compiler is behaving as expected.  These\n+    // for verifying that the compiler is behaving as expected. These\n     // warnings focus on the closure region requirements -- for\n     // viewing the intraprocedural state, the -Zdump-mir output is\n     // better."}, {"sha": "85d207b2fc9a7530afd0724e001c6881d6389eab", "filename": "compiler/rustc_borrowck/src/place_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fplace_ext.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -63,7 +63,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                     ty::RawPtr(..) | ty::Ref(_, _, hir::Mutability::Not) => {\n                         // For both derefs of raw pointers and `&T`\n                         // references, the original path is `Copy` and\n-                        // therefore not significant.  In particular,\n+                        // therefore not significant. In particular,\n                         // there is nothing the user can do to the\n                         // original path that would invalidate the\n                         // newly created reference -- and if there"}, {"sha": "89788c16cbb0fb30653acb6307d0d8ee233bdea6", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -680,7 +680,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// enforce the constraint).\n     ///\n     /// The current value of `scc` at the time the method is invoked\n-    /// is considered a *lower bound*.  If possible, we will modify\n+    /// is considered a *lower bound*. If possible, we will modify\n     /// the constraint to set it equal to one of the option regions.\n     /// If we make any changes, returns true, else false.\n     #[instrument(skip(self, member_constraint_index), level = \"debug\")]\n@@ -959,7 +959,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             //\n             // This is needed because -- particularly in the case\n             // where `ur` is a local bound -- we are sometimes in a\n-            // position to prove things that our caller cannot.  See\n+            // position to prove things that our caller cannot. See\n             // #53570 for an example.\n             if self.eval_verify_bound(infcx, param_env, generic_ty, ur, &type_test.verify_bound) {\n                 continue;\n@@ -2035,7 +2035,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         //    '5: '6 ('6 is the target)\n         //\n         // Some of those regions are unified with `'6` (in the same\n-        // SCC).  We want to screen those out. After that point, the\n+        // SCC). We want to screen those out. After that point, the\n         // \"closest\" constraint we have to the end is going to be the\n         // most likely to be the point where the value escapes -- but\n         // we still want to screen for an \"interesting\" point to"}, {"sha": "e15d1b99ad205229e2d7b901e101da1bcc5614b5", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         closure_substs: ty::SubstsRef<'tcx>,\n     ) {\n         // Extract the values of the free regions in `closure_substs`\n-        // into a vector.  These are the regions that we will be\n+        // into a vector. These are the regions that we will be\n         // relating to one another.\n         let closure_mapping = &UniversalRegions::closure_mapping(\n             self.tcx,"}, {"sha": "a125600899063e6023426431233bc98192c1688d", "filename": "compiler/rustc_borrowck/src/type_check/free_region_relations.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Ffree_region_relations.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -98,7 +98,7 @@ impl UniversalRegionRelations<'_> {\n         let upper_bounds = self.non_local_upper_bounds(fr);\n \n         // In case we find more than one, reduce to one for\n-        // convenience.  This is to prevent us from generating more\n+        // convenience. This is to prevent us from generating more\n         // complex constraints, but it will cause spurious errors.\n         let post_dom = self.inverse_outlives.mutual_immediate_postdominator(upper_bounds);\n \n@@ -128,7 +128,7 @@ impl UniversalRegionRelations<'_> {\n         let lower_bounds = self.non_local_bounds(&self.outlives, fr);\n \n         // In case we find more than one, reduce to one for\n-        // convenience.  This is to prevent us from generating more\n+        // convenience. This is to prevent us from generating more\n         // complex constraints, but it will cause spurious errors.\n         let post_dom = self.outlives.mutual_immediate_postdominator(lower_bounds);\n "}, {"sha": "3ff5d188a3d35233cf381cfb460655ee6b62c3ca", "filename": "compiler/rustc_borrowck/src/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fliveness%2Ftrace.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -328,7 +328,7 @@ impl<'me, 'typeck, 'flow, 'tcx> LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         debug_assert!(self.drop_live_at.contains(term_point));\n \n         // Otherwise, scan backwards through the statements in the\n-        // block.  One of them may be either a definition or use\n+        // block. One of them may be either a definition or use\n         // live point.\n         let term_location = self.cx.elements.to_location(term_point);\n         debug_assert_eq!(self.cx.body.terminator_loc(term_location.block), term_location,);"}, {"sha": "81bd4c2a783e906b30a4d1999bbea53b62522998", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1665,7 +1665,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn ensure_place_sized(&mut self, ty: Ty<'tcx>, span: Span) {\n         let tcx = self.tcx();\n \n-        // Erase the regions from `ty` to get a global type.  The\n+        // Erase the regions from `ty` to get a global type. The\n         // `Sized` bound in no way depends on precise regions, so this\n         // shouldn't affect `is_sized`.\n         let erased_ty = tcx.erase_regions(ty);"}, {"sha": "5b4d99682d98633a632e6974eba70f73c2a35c25", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -637,7 +637,7 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 let closure_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n \n                 // The \"inputs\" of the closure in the\n-                // signature appear as a tuple.  The MIR side\n+                // signature appear as a tuple. The MIR side\n                 // flattens this tuple.\n                 let (&output, tuplized_inputs) =\n                     inputs_and_output.skip_binder().split_last().unwrap();"}, {"sha": "3f174e2d9014a84c7360bb169bdf18e09d2f411d", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -20,7 +20,7 @@ pub fn expand_deriving_clone(\n     // some additional `AssertParamIsClone` assertions.\n     //\n     // We can use the simple form if either of the following are true.\n-    // - The type derives Copy and there are no generic parameters.  (If we\n+    // - The type derives Copy and there are no generic parameters. (If we\n     //   used the simple form with generics, we'd have to bound the generics\n     //   with Clone + Copy, and then there'd be no Clone impl at all if the\n     //   user fills in something that is Clone but not Copy. After"}, {"sha": "e5a5e606930f00e213c7bca7c893889955598892", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1,4 +1,4 @@\n-// The compiler code necessary to support the env! extension.  Eventually this\n+// The compiler code necessary to support the env! extension. Eventually this\n // should all get sucked into either the compiler syntax extension plugin\n // interface.\n //"}, {"sha": "9f4bbbc62c819e516273c409c89eeec3fc72877a", "filename": "compiler/rustc_builtin_macros/src/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -583,7 +583,7 @@ fn report_missing_placeholders(\n     if detect_foreign_fmt {\n         use super::format_foreign as foreign;\n \n-        // The set of foreign substitutions we've explained.  This prevents spamming the user\n+        // The set of foreign substitutions we've explained. This prevents spamming the user\n         // with `%d should be written as {}` over and over again.\n         let mut explained = FxHashSet::default();\n "}, {"sha": "bd9e903b6ba297cdda9ce8de7efa4404e6c4325d", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -253,7 +253,7 @@ pub(crate) mod printf {\n     #[derive(Copy, Clone, PartialEq, Debug)]\n     pub enum Num {\n         // The range of these values is technically bounded by `NL_ARGMAX`... but, at least for GNU\n-        // libc, it apparently has no real fixed limit.  A `u16` is used here on the basis that it\n+        // libc, it apparently has no real fixed limit. A `u16` is used here on the basis that it\n         // is *vanishingly* unlikely that *anyone* is going to try formatting something wider, or\n         // with more precision, than 32 thousand positions which is so wide it couldn't possibly fit\n         // on a screen."}, {"sha": "51450897bfc11278afe11293a8c2e92de48ef52e", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -304,7 +304,7 @@ fn data_id_for_static(\n \n         // Comment copied from https://github.com/rust-lang/rust/blob/45060c2a66dfd667f88bd8b94261b28a58d85bd5/src/librustc_codegen_llvm/consts.rs#L141\n         // Declare an internal global `extern_with_linkage_foo` which\n-        // is initialized with the address of `foo`.  If `foo` is\n+        // is initialized with the address of `foo`. If `foo` is\n         // discarded during linking (for example, if `foo` has weak\n         // linkage and there are no definitions), then\n         // `extern_with_linkage_foo` will instead be initialized to"}, {"sha": "28be6d033f8bf3d82c3731d60f7837e7d8760df1", "filename": "compiler/rustc_codegen_llvm/src/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fabi.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -221,7 +221,7 @@ impl<'ll, 'tcx> ArgAbiExt<'ll, 'tcx> for ArgAbi<'tcx, Ty<'tcx>> {\n                 bx.store(val, cast_dst, self.layout.align.abi);\n             } else {\n                 // The actual return type is a struct, but the ABI\n-                // adaptation code has cast it into some scalar type.  The\n+                // adaptation code has cast it into some scalar type. The\n                 // code that follows is the only reliable way I have\n                 // found to do a transform like i64 -> {i32,i32}.\n                 // Basically we dump the data onto the stack then memcpy it."}, {"sha": "52c8b51796c0bf7712e38ddfb44bca2f64c4bdb5", "filename": "compiler/rustc_codegen_llvm/src/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fasm.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -445,7 +445,7 @@ pub(crate) fn inline_asm_call<'ll>(\n             };\n \n             // Store mark in a metadata node so we can map LLVM errors\n-            // back to source locations.  See #17552.\n+            // back to source locations. See #17552.\n             let key = \"srcloc\";\n             let kind = llvm::LLVMGetMDKindIDInContext(\n                 bx.llcx,"}, {"sha": "426f57c0608009dd437c508b1944f3a2305fc518", "filename": "compiler/rustc_codegen_llvm/src/back/archive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Farchive.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -145,7 +145,7 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n             // The binutils linker used on -windows-gnu targets cannot read the import\n             // libraries generated by LLVM: in our attempts, the linker produced an .EXE\n             // that loaded but crashed with an AV upon calling one of the imported\n-            // functions.  Therefore, use binutils to create the import library instead,\n+            // functions. Therefore, use binutils to create the import library instead,\n             // by writing a .DEF file to the temp dir and calling binutils's dlltool.\n             let def_file_path =\n                 tmpdir.join(format!(\"{}{}\", lib_name, name_suffix)).with_extension(\"def\");\n@@ -219,7 +219,7 @@ impl ArchiveBuilderBuilder for LlvmArchiveBuilderBuilder {\n \n             // All import names are Rust identifiers and therefore cannot contain \\0 characters.\n             // FIXME: when support for #[link_name] is implemented, ensure that the import names\n-            // still don't contain any \\0 characters.  Also need to check that the names don't\n+            // still don't contain any \\0 characters. Also need to check that the names don't\n             // contain substrings like \" @\" or \"NONAME\" that are keywords or otherwise reserved\n             // in definition files.\n             let cstring_import_name_and_ordinal_vector: Vec<(CString, Option<u16>)> =\n@@ -433,7 +433,7 @@ fn find_binutils_dlltool(sess: &Session) -> OsString {\n     }\n \n     // The user didn't specify the location of the dlltool binary, and we weren't able\n-    // to find the appropriate one on the PATH.  Just return the name of the tool\n+    // to find the appropriate one on the PATH. Just return the name of the tool\n     // and let the invocation fail with a hopefully useful error message.\n     tool_name\n }"}, {"sha": "b2af9f31e4494175aad3d4140b32b7dd232247a5", "filename": "compiler/rustc_codegen_llvm/src/back/write.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Fwrite.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -909,7 +909,7 @@ unsafe fn embed_bitcode(\n \n // Create a `__imp_<symbol> = &symbol` global for every public static `symbol`.\n // This is required to satisfy `dllimport` references to static data in .rlibs\n-// when using MSVC linker.  We do this only for data, as linker can fix up\n+// when using MSVC linker. We do this only for data, as linker can fix up\n // code references on its own.\n // See #26591, #27438\n fn create_msvc_imps("}, {"sha": "f1d01a4602a5e313e06ff3ef816f42c2423a42a2", "filename": "compiler/rustc_codegen_llvm/src/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcallee.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -49,8 +49,8 @@ pub fn get_fn<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>, instance: Instance<'tcx>) ->\n         let llptrty = fn_abi.ptr_to_llvm_type(cx);\n \n         // This is subtle and surprising, but sometimes we have to bitcast\n-        // the resulting fn pointer.  The reason has to do with external\n-        // functions.  If you have two crates that both bind the same C\n+        // the resulting fn pointer. The reason has to do with external\n+        // functions. If you have two crates that both bind the same C\n         // library, they may not use precisely the same types: for\n         // example, they will probably each declare their own structs,\n         // which are distinct types from LLVM's point of view (nominal"}, {"sha": "16467b614feafd3015d192b3734244dee1a6058a", "filename": "compiler/rustc_codegen_llvm/src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fconsts.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -140,7 +140,7 @@ pub fn codegen_static_initializer<'ll, 'tcx>(\n fn set_global_alignment<'ll>(cx: &CodegenCx<'ll, '_>, gv: &'ll Value, mut align: Align) {\n     // The target may require greater alignment for globals than the type does.\n     // Note: GCC and Clang also allow `__attribute__((aligned))` on variables,\n-    // which can force it to be smaller.  Rust doesn't support this yet.\n+    // which can force it to be smaller. Rust doesn't support this yet.\n     if let Some(min) = cx.sess().target.min_global_align {\n         match Align::from_bits(min) {\n             Ok(min) => align = align.max(min),\n@@ -171,7 +171,7 @@ fn check_and_apply_linkage<'ll, 'tcx>(\n             llvm::LLVMRustSetLinkage(g1, base::linkage_to_llvm(linkage));\n \n             // Declare an internal global `extern_with_linkage_foo` which\n-            // is initialized with the address of `foo`.  If `foo` is\n+            // is initialized with the address of `foo`. If `foo` is\n             // discarded during linking (for example, if `foo` has weak\n             // linkage and there are no definitions), then\n             // `extern_with_linkage_foo` will instead be initialized to"}, {"sha": "a6a75eff9a36d24e0c331aa3e171f09b3f839ebc", "filename": "compiler/rustc_codegen_llvm/src/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fintrinsic.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -654,7 +654,7 @@ fn codegen_gnu_try<'ll>(\n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n-        // being thrown.  The second value is a \"selector\" indicating which of\n+        // being thrown. The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         // rust_try ignores the selector.\n         bx.switch_to_block(catch);\n@@ -718,7 +718,7 @@ fn codegen_emcc_try<'ll>(\n         // Type indicator for the exception being thrown.\n         //\n         // The first value in this tuple is a pointer to the exception object\n-        // being thrown.  The second value is a \"selector\" indicating which of\n+        // being thrown. The second value is a \"selector\" indicating which of\n         // the landing pad clauses the exception's type had been matched to.\n         bx.switch_to_block(catch);\n         let tydesc = bx.eh_catch_typeinfo();"}, {"sha": "75cd5df972316366807d06a8d5cfa4d6a399ff0a", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -352,10 +352,10 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         let scalar = [a, b][index];\n \n         // Make sure to return the same type `immediate_llvm_type` would when\n-        // dealing with an immediate pair.  This means that `(bool, bool)` is\n+        // dealing with an immediate pair. This means that `(bool, bool)` is\n         // effectively represented as `{i8, i8}` in memory and two `i1`s as an\n         // immediate, just like `bool` is typically `i8` in memory and only `i1`\n-        // when immediate.  We need to load/store `bool` as `i8` to avoid\n+        // when immediate. We need to load/store `bool` as `i8` to avoid\n         // crippling LLVM optimizations or triggering other LLVM bugs with `i1`.\n         if immediate && scalar.is_bool() {\n             return cx.type_i1();"}, {"sha": "c79dcb0f65e44edbf791e64deef509bef4123387", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -445,7 +445,7 @@ fn link_rlib<'a>(\n /// Extract all symbols defined in raw-dylib libraries, collated by library name.\n ///\n /// If we have multiple extern blocks that specify symbols defined in the same raw-dylib library,\n-/// then the CodegenResults value contains one NativeLib instance for each block.  However, the\n+/// then the CodegenResults value contains one NativeLib instance for each block. However, the\n /// linker appears to expect only a single import library for each library used, so we need to\n /// collate the symbols together by library name before generating the import libraries.\n fn collate_raw_dylibs<'a, 'b>(\n@@ -1197,7 +1197,7 @@ pub fn linker_and_flavor(sess: &Session) -> (PathBuf, LinkerFlavor) {\n                         if cfg!(any(target_os = \"solaris\", target_os = \"illumos\")) {\n                             // On historical Solaris systems, \"cc\" may have\n                             // been Sun Studio, which is not flag-compatible\n-                            // with \"gcc\".  This history casts a long shadow,\n+                            // with \"gcc\". This history casts a long shadow,\n                             // and many modern illumos distributions today\n                             // ship GCC as \"gcc\" without also making it\n                             // available as \"cc\"."}, {"sha": "eaf1e9817c2038a7934948e9b5fffb50fafa48ce", "filename": "compiler/rustc_codegen_ssa/src/back/linker.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flinker.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -544,7 +544,7 @@ impl<'a> Linker for GccLinker<'a> {\n         // link times negatively.\n         //\n         // -dead_strip can't be part of the pre_link_args because it's also used\n-        // for partial linking when using multiple codegen units (-r).  So we\n+        // for partial linking when using multiple codegen units (-r). So we\n         // insert it here.\n         if self.sess.target.is_like_osx {\n             self.linker_arg(\"-dead_strip\");"}, {"sha": "9f1614af7b16c9a232546c56ab9f5d5016c22472", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -105,7 +105,7 @@ pub struct ModuleConfig {\n     pub emit_thin_lto: bool,\n     pub bc_cmdline: String,\n \n-    // Miscellaneous flags.  These are mostly copied from command-line\n+    // Miscellaneous flags. These are mostly copied from command-line\n     // options.\n     pub verify_llvm_ir: bool,\n     pub no_prepopulate_passes: bool,\n@@ -538,7 +538,7 @@ fn produce_final_output_artifacts(\n \n     let copy_if_one_unit = |output_type: OutputType, keep_numbered: bool| {\n         if compiled_modules.modules.len() == 1 {\n-            // 1) Only one codegen unit.  In this case it's no difficulty\n+            // 1) Only one codegen unit. In this case it's no difficulty\n             //    to copy `foo.0.x` to `foo.x`.\n             let module_name = Some(&compiled_modules.modules[0].name[..]);\n             let path = crate_output.temp_path(output_type, module_name);\n@@ -557,15 +557,15 @@ fn produce_final_output_artifacts(\n                 .to_owned();\n \n             if crate_output.outputs.contains_key(&output_type) {\n-                // 2) Multiple codegen units, with `--emit foo=some_name`.  We have\n+                // 2) Multiple codegen units, with `--emit foo=some_name`. We have\n                 //    no good solution for this case, so warn the user.\n                 sess.emit_warning(errors::IgnoringEmitPath { extension });\n             } else if crate_output.single_output_file.is_some() {\n-                // 3) Multiple codegen units, with `-o some_name`.  We have\n+                // 3) Multiple codegen units, with `-o some_name`. We have\n                 //    no good solution for this case, so warn the user.\n                 sess.emit_warning(errors::IgnoringOutput { extension });\n             } else {\n-                // 4) Multiple codegen units, but no explicit name.  We\n+                // 4) Multiple codegen units, but no explicit name. We\n                 //    just leave the `foo.0.x` files in place.\n                 // (We don't have to do any work in this case.)\n             }\n@@ -579,7 +579,7 @@ fn produce_final_output_artifacts(\n         match *output_type {\n             OutputType::Bitcode => {\n                 user_wants_bitcode = true;\n-                // Copy to .bc, but always keep the .0.bc.  There is a later\n+                // Copy to .bc, but always keep the .0.bc. There is a later\n                 // check to figure out if we should delete .0.bc files, or keep\n                 // them for making an rlib.\n                 copy_if_one_unit(OutputType::Bitcode, true);\n@@ -611,7 +611,7 @@ fn produce_final_output_artifacts(\n     // `-C save-temps` or `--emit=` flags).\n \n     if !sess.opts.cg.save_temps {\n-        // Remove the temporary .#module-name#.o objects.  If the user didn't\n+        // Remove the temporary .#module-name#.o objects. If the user didn't\n         // explicitly request bitcode (with --emit=bc), and the bitcode is not\n         // needed for building an rlib, then we must remove .#module-name#.bc as\n         // well."}, {"sha": "8808ad2dcd135ab3c009656beb2bd6f9cf9f67d9", "filename": "compiler/rustc_codegen_ssa/src/codegen_attrs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcodegen_attrs.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -658,13 +658,13 @@ fn check_link_ordinal(tcx: TyCtxt<'_>, attr: &ast::Attribute) -> Option<u16> {\n         sole_meta_list\n     {\n         // According to the table at https://docs.microsoft.com/en-us/windows/win32/debug/pe-format#import-header,\n-        // the ordinal must fit into 16 bits.  Similarly, the Ordinal field in COFFShortExport (defined\n+        // the ordinal must fit into 16 bits. Similarly, the Ordinal field in COFFShortExport (defined\n         // in llvm/include/llvm/Object/COFFImportFile.h), which we use to communicate import information\n         // to LLVM for `#[link(kind = \"raw-dylib\"_])`, is also defined to be uint16_t.\n         //\n         // FIXME: should we allow an ordinal of 0?  The MSVC toolchain has inconsistent support for this:\n         // both LINK.EXE and LIB.EXE signal errors and abort when given a .DEF file that specifies\n-        // a zero ordinal.  However, llvm-dlltool is perfectly happy to generate an import library\n+        // a zero ordinal. However, llvm-dlltool is perfectly happy to generate an import library\n         // for such a .DEF file, and MSVC's LINK.EXE is also perfectly happy to consume an import\n         // library produced by LLVM with an ordinal of 0, and it generates an .EXE.  (I don't know yet\n         // if the resulting EXE runs, as I haven't yet built the necessary DLL -- see earlier comment"}, {"sha": "e9bc40c33107706b6167373a5ace60f8b8ac6a2b", "filename": "compiler/rustc_codegen_ssa/src/mir/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fdebuginfo.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -57,9 +57,9 @@ pub struct DebugScope<S, L> {\n }\n \n impl<'tcx, S: Copy, L: Copy> DebugScope<S, L> {\n-    /// DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n+    /// DILocations inherit source file name from the parent DIScope. Due to macro expansions\n     /// it may so happen that the current span belongs to a different file than the DIScope\n-    /// corresponding to span's containing source scope.  If so, we need to create a DIScope\n+    /// corresponding to span's containing source scope. If so, we need to create a DIScope\n     /// \"extension\" into that file.\n     pub fn adjust_dbg_scope_for_span<Cx: CodegenMethods<'tcx, DIScope = S, DILocation = L>>(\n         &self,"}, {"sha": "4f7c1fc96f13f1e770235f0cdbb369447efa3029", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -408,7 +408,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         // Only check non-glue functions\n         if let ty::InstanceDef::Item(def) = instance.def {\n             // Execution might have wandered off into other crates, so we cannot do a stability-\n-            // sensitive check here.  But we can at least rule out functions that are not const\n+            // sensitive check here. But we can at least rule out functions that are not const\n             // at all.\n             if !ecx.tcx.is_const_fn_raw(def.did) {\n                 // allow calling functions inside a trait marked with #[const_trait]."}, {"sha": "d13fed7a9c2631fa366200f8686433831c9d558b", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -196,7 +196,7 @@ impl<'tcx, Prov: Provenance + 'static> LocalState<'tcx, Prov> {\n         }\n     }\n \n-    /// Overwrite the local.  If the local can be overwritten in place, return a reference\n+    /// Overwrite the local. If the local can be overwritten in place, return a reference\n     /// to do so; otherwise return the `MemPlace` to consult instead.\n     ///\n     /// Note: This may only be invoked from the `Machine::access_local_mut` hook and not from\n@@ -592,7 +592,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 );\n \n                 // Recurse to get the size of the dynamically sized field (must be\n-                // the last field).  Can't have foreign types here, how would we\n+                // the last field). Can't have foreign types here, how would we\n                 // adjust alignment and size for them?\n                 let field = layout.field(self, layout.fields.count() - 1);\n                 let Some((unsized_size, mut unsized_align)) = self.size_and_align_of(metadata, &field)? else {"}, {"sha": "54528b1dbf4a0e252fe90929b9c1945ae43ca3a5", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -59,7 +59,7 @@ struct InternVisitor<'rt, 'mir, 'tcx, M: CompileTimeMachine<'mir, 'tcx, const_ev\n \n #[derive(Copy, Clone, Debug, PartialEq, Hash, Eq)]\n enum InternMode {\n-    /// A static and its current mutability.  Below shared references inside a `static mut`,\n+    /// A static and its current mutability. Below shared references inside a `static mut`,\n     /// this is *immutable*, and below mutable references inside an `UnsafeCell`, this\n     /// is *mutable*.\n     Static(hir::Mutability),\n@@ -296,7 +296,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n                         }\n                     }\n                     InternMode::Const => {\n-                        // Ignore `UnsafeCell`, everything is immutable.  Validity does some sanity\n+                        // Ignore `UnsafeCell`, everything is immutable. Validity does some sanity\n                         // checking for mutable references that we encounter -- they must all be\n                         // ZST.\n                         InternMode::Const\n@@ -330,7 +330,7 @@ pub enum InternKind {\n \n /// Intern `ret` and everything it references.\n ///\n-/// This *cannot raise an interpreter error*.  Doing so is left to validation, which\n+/// This *cannot raise an interpreter error*. Doing so is left to validation, which\n /// tracks where in the value we are and thus can show much better error messages.\n #[instrument(level = \"debug\", skip(ecx))]\n pub fn intern_const_alloc_recursive<\n@@ -379,7 +379,7 @@ pub fn intern_const_alloc_recursive<\n             inside_unsafe_cell: false,\n         }\n         .visit_value(&mplace);\n-        // We deliberately *ignore* interpreter errors here.  When there is a problem, the remaining\n+        // We deliberately *ignore* interpreter errors here. When there is a problem, the remaining\n         // references are \"leftover\"-interned, and later validation will show a proper error\n         // and point at the right part of the value causing the problem.\n         match res {\n@@ -454,7 +454,7 @@ pub fn intern_const_alloc_recursive<\n             return Err(reported);\n         } else if ecx.tcx.try_get_global_alloc(alloc_id).is_none() {\n             // We have hit an `AllocId` that is neither in local or global memory and isn't\n-            // marked as dangling by local memory.  That should be impossible.\n+            // marked as dangling by local memory. That should be impossible.\n             span_bug!(ecx.tcx.span, \"encountered unknown alloc id {:?}\", alloc_id);\n         }\n     }"}, {"sha": "248953de8672828a7889da54697268517eddd90e", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -180,7 +180,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>>;\n \n-    /// Execute `fn_val`.  It is the hook's responsibility to advance the instruction\n+    /// Execute `fn_val`. It is the hook's responsibility to advance the instruction\n     /// pointer as appropriate.\n     fn call_extra_fn(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n@@ -439,7 +439,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n }\n \n /// A lot of the flexibility above is just needed for `Miri`, but all \"compile-time\" machines\n-/// (CTFE and ConstProp) use the same instance.  Here, we share that code.\n+/// (CTFE and ConstProp) use the same instance. Here, we share that code.\n pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type Provenance = AllocId;\n     type ProvenanceExtra = ();"}, {"sha": "2f31bfc91005ef3302571ab0137a503f71c3d2bf", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -146,7 +146,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n-    /// the machine pointer to the allocation.  Must never be used\n+    /// the machine pointer to the allocation. Must never be used\n     /// for any other pointers, nor for TLS statics.\n     ///\n     /// Using the resulting pointer represents a *direct* access to that memory\n@@ -536,7 +536,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::Provenance, M::AllocExtra>> {\n-        // The error type of the inner closure here is somewhat funny.  We have two\n+        // The error type of the inner closure here is somewhat funny. We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::Provenance>>`."}, {"sha": "7e93f1b8ef51f7ee128f8f86f5c150125a32bc97", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -488,7 +488,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(OpTy { op, layout: place.layout, align: Some(place.align) })\n     }\n \n-    /// Evaluate a place with the goal of reading from it.  This lets us sometimes\n+    /// Evaluate a place with the goal of reading from it. This lets us sometimes\n     /// avoid allocations.\n     pub fn eval_place_to_op(\n         &self,"}, {"sha": "274af61ee7c1d5899b1d2d8b3a2700c912d9a0fa", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -233,7 +233,7 @@ impl<'tcx, Prov: Provenance> MPlaceTy<'tcx, Prov> {\n                 _ => bug!(\"len not supported on unsized type {:?}\", self.layout.ty),\n             }\n         } else {\n-            // Go through the layout.  There are lots of types that support a length,\n+            // Go through the layout. There are lots of types that support a length,\n             // e.g., SIMD types. (But not all repr(simd) types even have FieldsShape::Array!)\n             match self.layout.fields {\n                 abi::FieldsShape::Array { count, .. } => Ok(count),\n@@ -294,7 +294,7 @@ where\n     M: Machine<'mir, 'tcx, Provenance = Prov>,\n {\n     /// Take a value, which represents a (thin or wide) reference, and make it a place.\n-    /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n+    /// Alignment is just based on the type. This is the inverse of `MemPlace::to_ref()`.\n     ///\n     /// Only call this if you are sure the place is \"valid\" (aligned and inbounds), or do not\n     /// want to ever use the place for memory access!\n@@ -703,7 +703,7 @@ where\n                     &mut Operand::Immediate(local_val) => {\n                         // We need to make an allocation.\n \n-                        // We need the layout of the local.  We can NOT use the layout we got,\n+                        // We need the layout of the local. We can NOT use the layout we got,\n                         // that might e.g., be an inner field of a struct with `Scalar` layout,\n                         // that has different alignment than the outer field.\n                         let local_layout ="}, {"sha": "da320cd1cd5f0c6444b1ce8a8d56fffe2e776c78", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -446,7 +446,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // they go to.\n \n                     // For where they come from: If the ABI is RustCall, we untuple the\n-                    // last incoming argument.  These two iterators do not have the same type,\n+                    // last incoming argument. These two iterators do not have the same type,\n                     // so to keep the code paths uniform we accept an allocation\n                     // (for RustCall ABI only).\n                     let caller_args: Cow<'_, [OpTy<'tcx, M::Provenance>]> =\n@@ -481,7 +481,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .filter(|arg_and_abi| !matches!(arg_and_abi.1.mode, PassMode::Ignore));\n \n                     // Now we have to spread them out across the callee's locals,\n-                    // taking into account the `spread_arg`.  If we could write\n+                    // taking into account the `spread_arg`. If we could write\n                     // this is a single iterator (that handles `spread_arg`), then\n                     // `pass_argument` would be the loop body. It takes care to\n                     // not advance `caller_iter` for ZSTs.\n@@ -648,8 +648,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"drop_in_place: {:?},\\n  {:?}, {:?}\", *place, place.layout.ty, instance);\n-        // We take the address of the object.  This may well be unaligned, which is fine\n-        // for us here.  However, unaligned accesses will probably make the actual drop\n+        // We take the address of the object. This may well be unaligned, which is fine\n+        // for us here. However, unaligned accesses will probably make the actual drop\n         // implementation fail -- a problem shared by rustc.\n         let place = self.force_allocation(place)?;\n "}, {"sha": "43bea23b651e90472d3420af05c6991b600f43d1", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -175,7 +175,7 @@ fn write_path(out: &mut String, path: &[PathElem]) {\n             TupleElem(idx) => write!(out, \".{}\", idx),\n             ArrayElem(idx) => write!(out, \"[{}]\", idx),\n             // `.<deref>` does not match Rust syntax, but it is more readable for long paths -- and\n-            // some of the other items here also are not Rust syntax.  Actually we can't\n+            // some of the other items here also are not Rust syntax. Actually we can't\n             // even use the usual syntax because we are just showing the projections,\n             // not the root.\n             Deref => write!(out, \".<deref>\"),\n@@ -484,7 +484,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n     }\n \n     /// Check if this is a value of primitive type, and if yes check the validity of the value\n-    /// at that type.  Return `true` if the type is indeed primitive.\n+    /// at that type. Return `true` if the type is indeed primitive.\n     fn try_visit_primitive(\n         &mut self,\n         value: &OpTy<'tcx, M::Provenance>,\n@@ -623,7 +623,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 // Can only happen during CTFE.\n                 // We support 2 kinds of ranges here: full range, and excluding zero.\n                 if start == 1 && end == max_value {\n-                    // Only null is the niche.  So make sure the ptr is NOT null.\n+                    // Only null is the niche. So make sure the ptr is NOT null.\n                     if self.ecx.scalar_may_be_null(scalar)? {\n                         throw_validation_failure!(self.path,\n                             { \"a potentially null pointer\" }\n@@ -759,7 +759,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         // Recursively walk the value at its type.\n         self.walk_value(op)?;\n \n-        // *After* all of this, check the ABI.  We need to check the ABI to handle\n+        // *After* all of this, check the ABI. We need to check the ABI to handle\n         // types like `NonNull` where the `Scalar` info is more restrictive than what\n         // the fields say (`rustc_layout_scalar_valid_range_start`).\n         // But in most cases, this will just propagate what the fields say,\n@@ -857,10 +857,10 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // Optimization: we just check the entire range at once.\n                 // NOTE: Keep this in sync with the handling of integer and float\n                 // types above, in `visit_primitive`.\n-                // In run-time mode, we accept pointers in here.  This is actually more\n+                // In run-time mode, we accept pointers in here. This is actually more\n                 // permissive than a per-element check would be, e.g., we accept\n                 // a &[u8] that contains a pointer even though bytewise checking would\n-                // reject it.  However, that's good: We don't inherently want\n+                // reject it. However, that's good: We don't inherently want\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept uninit, for consistency with the slow path."}, {"sha": "73190574667f32135a490a3f717a777c72037793", "filename": "compiler/rustc_data_structures/src/frozen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ffrozen.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -36,7 +36,7 @@\n //! ```\n //!\n //! `Frozen` impls `Deref`, so we can ergonomically call methods on `Bar`, but it doesn't `impl\n-//! DerefMut`.  Now calling `foo.compute.mutate()` will result in a compile-time error stating that\n+//! DerefMut`. Now calling `foo.compute.mutate()` will result in a compile-time error stating that\n //! `mutate` requires a mutable reference but we don't have one.\n //!\n //! # Caveats"}, {"sha": "820a70fc8e446c8094763ee5ad25db9f3e9c6cc9", "filename": "compiler/rustc_data_structures/src/graph/scc/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fscc%2Ftests.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -84,7 +84,7 @@ fn test_find_state_2() {\n     // 0 -> 1 -> 2 -> 1\n     //\n     // and at this point detect a cycle. The state of 2 will thus be\n-    // `InCycleWith { 1 }`.  We will then visit the 1 -> 3 edge, which\n+    // `InCycleWith { 1 }`. We will then visit the 1 -> 3 edge, which\n     // will attempt to visit 0 as well, thus going to the state\n     // `InCycleWith { 0 }`. Finally, node 1 will complete; the lowest\n     // depth of any successor was 3 which had depth 0, and thus it"}, {"sha": "cd391fe357a6f0b76f9975649bd6898fe547bf43", "filename": "compiler/rustc_data_structures/src/transitive_relation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Ftransitive_relation.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -250,7 +250,7 @@ impl<T: Eq + Hash + Copy> TransitiveRelation<T> {\n             // values. So here is what we do:\n             //\n             // 1. Find the vector `[X | a < X && b < X]` of all values\n-            //    `X` where `a < X` and `b < X`.  In terms of the\n+            //    `X` where `a < X` and `b < X`. In terms of the\n             //    graph, this means all values reachable from both `a`\n             //    and `b`. Note that this vector is also a set, but we\n             //    use the term vector because the order matters"}, {"sha": "6d7fba36fb3d071f182ab20a105e485a0f2efc47", "filename": "compiler/rustc_driver/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_driver%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_driver%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2FREADME.md?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1,5 +1,5 @@\n The `driver` crate is effectively the \"main\" function for the rust\n-compiler.  It orchestrates the compilation process and \"knits together\"\n+compiler. It orchestrates the compilation process and \"knits together\"\n the code from the other crates within rustc. This crate itself does\n not contain any of the \"main logic\" of the compiler (though it does\n have some code related to pretty printing or other minor compiler"}, {"sha": "2746396b75abdfa7062f0d44cb207aa83399fd14", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1,5 +1,5 @@\n-// Error messages for EXXXX errors.  Each message should start and end with a\n-// new line, and be wrapped to 80 characters.  In vim you can `:set tw=80` and\n+// Error messages for EXXXX errors. Each message should start and end with a\n+// new line, and be wrapped to 80 characters. In vim you can `:set tw=80` and\n // use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n //\n // /!\\ IMPORTANT /!\\"}, {"sha": "1c62d410efe4799503ce55a0087140ed15a1ed59", "filename": "compiler/rustc_error_codes/src/error_codes/E0387.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0387.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0387.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0387.md?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -17,7 +17,7 @@ fn mutable() {\n     foo(|| x = 2);\n }\n \n-// Attempts to take a mutable reference to closed-over data.  Error message\n+// Attempts to take a mutable reference to closed-over data. Error message\n // reads: `cannot borrow data mutably in a captured outer variable...`\n fn mut_addr() {\n     let mut x = 0u32;"}, {"sha": "a7b9bbeb122f70fcbc03c15dd4f33ad4b4d52ab2", "filename": "compiler/rustc_error_codes/src/error_codes/E0713.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0713.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0713.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0713.md?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -22,7 +22,7 @@ gets called when they go out of scope. This destructor gets exclusive\n access to the fields of the struct when it runs.\n \n This means that when `s` reaches the end of `demo`, its destructor\n-gets exclusive access to its `&mut`-borrowed string data.  allowing\n+gets exclusive access to its `&mut`-borrowed string data. allowing\n another borrow of that string data (`p`), to exist across the drop of\n `s` would be a violation of the principle that `&mut`-borrows have\n exclusive, unaliased access to their referenced data."}, {"sha": "b75735d602e053677ebcdc2efb7c6338a1d87910", "filename": "compiler/rustc_error_codes/src/error_codes/E0714.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0714.md", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0714.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0714.md?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -15,5 +15,5 @@ fn main() {}\n ```\n \n The items of marker traits cannot be overridden, so there's no need to have them\n-when they cannot be changed per-type anyway.  If you wanted them for ergonomic\n+when they cannot be changed per-type anyway. If you wanted them for ergonomic\n reasons, consider making an extension trait instead."}, {"sha": "51b2ff6a003812c01fb5f7e3762539cfa5d10c63", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -114,9 +114,9 @@ pub struct Diagnostic {\n     pub suggestions: Result<Vec<CodeSuggestion>, SuggestionsDisabled>,\n     args: FxHashMap<DiagnosticArgName<'static>, DiagnosticArgValue<'static>>,\n \n-    /// This is not used for highlighting or rendering any error message.  Rather, it can be used\n-    /// as a sort key to sort a buffer of diagnostics.  By default, it is the primary span of\n-    /// `span` if there is one.  Otherwise, it is `DUMMY_SP`.\n+    /// This is not used for highlighting or rendering any error message. Rather, it can be used\n+    /// as a sort key to sort a buffer of diagnostics. By default, it is the primary span of\n+    /// `span` if there is one. Otherwise, it is `DUMMY_SP`.\n     pub sort_span: Span,\n \n     /// If diagnostic is from Lint, custom hash function ignores notes"}, {"sha": "628e199992152937392392452603f05f8662ff62", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1791,7 +1791,7 @@ impl EmitterWriter {\n \n             if let Some(span) = span.primary_span() {\n                 // Compare the primary span of the diagnostic with the span of the suggestion\n-                // being emitted.  If they belong to the same file, we don't *need* to show the\n+                // being emitted. If they belong to the same file, we don't *need* to show the\n                 // file name, saving in verbosity, but if it *isn't* we do need it, otherwise we're\n                 // telling users to make a change but not clarifying *where*.\n                 let loc = sm.lookup_char_pos(parts[0].span.lo());\n@@ -2529,11 +2529,11 @@ fn emit_to_destination(\n     //\n     // On Unix systems, we write into a buffered terminal rather than directly to a terminal. When\n     // the .flush() is called we take the buffer created from the buffered writes and write it at\n-    // one shot.  Because the Unix systems use ANSI for the colors, which is a text-based styling\n+    // one shot. Because the Unix systems use ANSI for the colors, which is a text-based styling\n     // scheme, this buffered approach works and maintains the styling.\n     //\n     // On Windows, styling happens through calls to a terminal API. This prevents us from using the\n-    // same buffering approach.  Instead, we use a global Windows mutex, which we acquire long\n+    // same buffering approach. Instead, we use a global Windows mutex, which we acquire long\n     // enough to output the full error message, then we release.\n     let _buffer_lock = lock::acquire_global_lock(\"rustc_errors\");\n     for (pos, line) in rendered_buffer.iter().enumerate() {"}, {"sha": "bc298b0ad2b1e37f8d78faa0d3433edbe7bea88a", "filename": "compiler/rustc_expand/src/mbe/quoted.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fquoted.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -171,7 +171,7 @@ fn parse_tree(\n                     } else {\n                         match delim {\n                             Delimiter::Brace => {\n-                                // The delimiter is `{`.  This indicates the beginning\n+                                // The delimiter is `{`. This indicates the beginning\n                                 // of a meta-variable expression (e.g. `${count(ident)}`).\n                                 // Try to parse the meta-variable expression.\n                                 match MetaVarExpr::parse(&tts, delim_span.entire(), sess) {\n@@ -200,7 +200,7 @@ fn parse_tree(\n                         }\n                     }\n                     // If we didn't find a metavar expression above, then we must have a\n-                    // repetition sequence in the macro (e.g. `$(pat)*`).  Parse the\n+                    // repetition sequence in the macro (e.g. `$(pat)*`). Parse the\n                     // contents of the sequence itself\n                     let sequence = parse(tts, parsing_patterns, sess, node_id, features, edition);\n                     // Get the Kleene operator and optional separator"}, {"sha": "af38077b08060b43d350994a2be5e158a220f113", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -230,7 +230,7 @@ impl FromInternal<(TokenStream, &mut Rustc<'_, '_>)> for Vec<TokenTree<TokenStre\n                     let stream = TokenStream::from_nonterminal_ast(&nt);\n                     // A hack used to pass AST fragments to attribute and derive\n                     // macros as a single nonterminal token instead of a token\n-                    // stream.  Such token needs to be \"unwrapped\" and not\n+                    // stream. Such token needs to be \"unwrapped\" and not\n                     // represented as a delimited group.\n                     // FIXME: It needs to be removed, but there are some\n                     // compatibility issues (see #73345)."}, {"sha": "cca5ead0f83951c19594d3704afb0264164245c6", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -751,7 +751,7 @@ pub enum LifetimeRes {\n         binder: NodeId,\n     },\n     /// This variant is used for anonymous lifetimes that we did not resolve during\n-    /// late resolution.  Those lifetimes will be inferred by typechecking.\n+    /// late resolution. Those lifetimes will be inferred by typechecking.\n     Infer,\n     /// Explicit `'static` lifetime.\n     Static,"}, {"sha": "56f0e0b3e7df6a9350d5fe29de95cdd1a03ea311", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -94,7 +94,7 @@ pub enum LifetimeName {\n     /// Implicit lifetime in a context like `dyn Foo`. This is\n     /// distinguished from implicit lifetimes elsewhere because the\n     /// lifetime that they default to must appear elsewhere within the\n-    /// enclosing type.  This means that, in an `impl Trait` context, we\n+    /// enclosing type. This means that, in an `impl Trait` context, we\n     /// don't have to create a parameter for them. That is, `impl\n     /// Trait<Item = &u32>` expands to an opaque type like `type\n     /// Foo<'a> = impl Trait<Item = &'a u32>`, but `impl Trait<item =\n@@ -826,7 +826,7 @@ pub struct OwnerNodes<'tcx> {\n     pub hash_without_bodies: Fingerprint,\n     /// Full HIR for the current owner.\n     // The zeroth node's parent should never be accessed: the owner's parent is computed by the\n-    // hir_owner_parent query.  It is set to `ItemLocalId::INVALID` to force an ICE if accidentally\n+    // hir_owner_parent query. It is set to `ItemLocalId::INVALID` to force an ICE if accidentally\n     // used.\n     pub nodes: IndexVec<ItemLocalId, Option<ParentedNode<'tcx>>>,\n     /// Content of local bodies."}, {"sha": "232ef2079d6bb9eb3c37e95a0547ed2772c4ada9", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -331,7 +331,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             if potential_assoc_types.len() == assoc_items.len() {\n                 // When the amount of missing associated types equals the number of\n-                // extra type arguments present.  A suggesting to replace the generic args with\n+                // extra type arguments present. A suggesting to replace the generic args with\n                 // associated types is already emitted.\n                 already_has_generics_args_suggestion = true;\n             } else if let (Ok(snippet), false) ="}, {"sha": "7a499327dbf240f1f08e9874a417a24e3e31ee82", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -337,13 +337,13 @@ pub fn create_substs_for_generic_args<'tcx, 'a>(\n                     // We should never be able to reach this point with well-formed input.\n                     // There are three situations in which we can encounter this issue.\n                     //\n-                    //  1.  The number of arguments is incorrect. In this case, an error\n-                    //      will already have been emitted, and we can ignore it.\n-                    //  2.  There are late-bound lifetime parameters present, yet the\n-                    //      lifetime arguments have also been explicitly specified by the\n-                    //      user.\n-                    //  3.  We've inferred some lifetimes, which have been provided later (i.e.\n-                    //      after a type or const). We want to throw an error in this case.\n+                    //  1. The number of arguments is incorrect. In this case, an error\n+                    //     will already have been emitted, and we can ignore it.\n+                    //  2. There are late-bound lifetime parameters present, yet the\n+                    //     lifetime arguments have also been explicitly specified by the\n+                    //     user.\n+                    //  3. We've inferred some lifetimes, which have been provided later (i.e.\n+                    //     after a type or const). We want to throw an error in this case.\n \n                     if arg_count.correct.is_ok()\n                         && arg_count.explicit_late_bound == ExplicitLateBound::No"}, {"sha": "6a673e8ae4e3bef5709923d777b90814ea27c6ef", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -993,7 +993,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// ```\n     ///\n     /// The `sized_by_default` parameter indicates if, in this context, the `param_ty` should be\n-    /// considered `Sized` unless there is an explicit `?Sized` bound.  This would be true in the\n+    /// considered `Sized` unless there is an explicit `?Sized` bound. This would be true in the\n     /// example above, but is not true in supertrait listings like `trait Foo: Bar + Baz`.\n     ///\n     /// `span` should be the declaration size of the parameter.\n@@ -1498,7 +1498,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             i.trait_ref().map_bound(|trait_ref: ty::TraitRef<'tcx>| {\n                 assert_eq!(trait_ref.self_ty(), dummy_self);\n \n-                // Verify that `dummy_self` did not leak inside default type parameters.  This\n+                // Verify that `dummy_self` did not leak inside default type parameters. This\n                 // could not be done at path creation, since we need to see through trait aliases.\n                 let mut missing_type_params = vec![];\n                 let mut references_self = false;\n@@ -2694,7 +2694,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     /// Parses the programmer's textual representation of a type into our\n-    /// internal notion of a type.  This is meant to be used within a path.\n+    /// internal notion of a type. This is meant to be used within a path.\n     pub fn ast_ty_to_ty_in_path(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         self.ast_ty_to_ty_inner(ast_ty, false, true)\n     }"}, {"sha": "b193e7b4d4cd2629b95ee961ba2fceac3958c2cb", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -136,7 +136,7 @@ pub(super) fn compare_impl_method<'tcx>(\n ///     <'a> fn(t: &'i0 U0, m: &'a) -> Foo\n ///\n /// This type is also the same but the name of the bound region (`'a`\n-/// vs `'b`).  However, the normal subtyping rules on fn types handle\n+/// vs `'b`). However, the normal subtyping rules on fn types handle\n /// this kind of equivalency just fine.\n ///\n /// We now use these substitutions to ensure that all declared bounds are\n@@ -625,7 +625,7 @@ pub(super) fn collect_return_position_impl_trait_in_trait_tys<'tcx>(\n         match infcx.fully_resolve(ty) {\n             Ok(ty) => {\n                 // `ty` contains free regions that we created earlier while liberating the\n-                // trait fn signature.  However, projection normalization expects `ty` to\n+                // trait fn signature. However, projection normalization expects `ty` to\n                 // contains `def_id`'s early-bound regions.\n                 let id_substs = InternalSubsts::identity_for_item(tcx, def_id);\n                 debug!(?id_substs, ?substs);\n@@ -883,7 +883,7 @@ fn check_region_bounds_on_impl_item<'tcx>(\n \n     // Must have same number of early-bound lifetime parameters.\n     // Unfortunately, if the user screws up the bounds, then this\n-    // will change classification between early and late.  E.g.,\n+    // will change classification between early and late. E.g.,\n     // if in trait we have `<'a,'b:'a>`, and in impl we just have\n     // `<'a,'b>`, then we have 2 early-bound lifetime parameters\n     // in trait but 0 in the impl. But if we report \"expected 2\n@@ -994,9 +994,9 @@ fn compare_self_type<'tcx>(\n     impl_trait_ref: ty::TraitRef<'tcx>,\n ) -> Result<(), ErrorGuaranteed> {\n     // Try to give more informative error messages about self typing\n-    // mismatches.  Note that any mismatch will also be detected\n+    // mismatches. Note that any mismatch will also be detected\n     // below, where we construct a canonical function type that\n-    // includes the self parameter as a normal parameter.  It's just\n+    // includes the self parameter as a normal parameter. It's just\n     // that the error messages you get out of this code are a bit more\n     // inscrutable, particularly for cases where one method has no\n     // self."}, {"sha": "64fd61c1359b599edbd2ae97bb5baae89e6e41b0", "filename": "compiler/rustc_hir_analysis/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fdropck.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -46,7 +46,7 @@ pub fn check_drop_impl(tcx: TyCtxt<'_>, drop_impl_did: DefId) -> Result<(), Erro\n             )\n         }\n         _ => {\n-            // Destructors only work on nominal types.  This was\n+            // Destructors only work on nominal types. This was\n             // already checked by coherence, but compilation may\n             // not have been terminated.\n             let span = tcx.def_span(drop_impl_did);"}, {"sha": "14bca34b77bea005d5057b464da32dbeb7606ef4", "filename": "compiler/rustc_hir_analysis/src/check/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -14,32 +14,32 @@ can be broken down into several distinct phases:\n \n - main: the main pass does the lion's share of the work: it\n   determines the types of all expressions, resolves\n-  methods, checks for most invalid conditions, and so forth.  In\n+  methods, checks for most invalid conditions, and so forth. In\n   some cases, where a type is unknown, it may create a type or region\n   variable and use that as the type of an expression.\n \n   In the process of checking, various constraints will be placed on\n   these type variables through the subtyping relationships requested\n-  through the `demand` module.  The `infer` module is in charge\n+  through the `demand` module. The `infer` module is in charge\n   of resolving those constraints.\n \n - regionck: after main is complete, the regionck pass goes over all\n   types looking for regions and making sure that they did not escape\n-  into places where they are not in scope.  This may also influence the\n+  into places where they are not in scope. This may also influence the\n   final assignments of the various region variables if there is some\n   flexibility.\n \n - writeback: writes the final types within a function body, replacing\n-  type variables with their final inferred types.  These final types\n+  type variables with their final inferred types. These final types\n   are written into the `tcx.node_types` table, which should *never* contain\n   any reference to a type variable.\n \n ## Intermediate types\n \n While type checking a function, the intermediate types for the\n expressions, blocks, and so forth contained within the function are\n-stored in `fcx.node_types` and `fcx.node_substs`.  These types\n-may contain unresolved type variables.  After type checking is\n+stored in `fcx.node_types` and `fcx.node_substs`. These types\n+may contain unresolved type variables. After type checking is\n complete, the functions in the writeback module are used to take the\n types from this table, resolve them, and then write them into their\n permanent home in the type context `tcx`.\n@@ -51,12 +51,12 @@ nodes within the function.\n The types of top-level items, which never contain unbound type\n variables, are stored directly into the `tcx` typeck_results.\n \n-N.B., a type variable is not the same thing as a type parameter.  A\n+N.B., a type variable is not the same thing as a type parameter. A\n type variable is an instance of a type parameter. That is,\n given a generic function `fn foo<T>(t: T)`, while checking the\n function `foo`, the type `ty_param(0)` refers to the type `T`, which\n is treated in abstract. However, when `foo()` is called, `T` will be\n-substituted for a fresh type variable `N`.  This variable will\n+substituted for a fresh type variable `N`. This variable will\n eventually be resolved to some concrete type (which might itself be\n a type parameter).\n \n@@ -441,7 +441,7 @@ fn suggestion_signature(assoc: &ty::AssocItem, tcx: TyCtxt<'_>) -> String {\n         ty::AssocKind::Fn => {\n             // We skip the binder here because the binder would deanonymize all\n             // late-bound regions, and we don't want method signatures to show up\n-            // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n+            // `as for<'r> fn(&'r MyType)`. Pretty-printing handles late-bound\n             // regions just fine, showing `fn(&MyType)`.\n             fn_sig_suggestion(\n                 tcx,"}, {"sha": "479a10d6000a0ae10d0f63ee67368b7b7f400c3a", "filename": "compiler/rustc_hir_analysis/src/check/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fregion.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -325,7 +325,7 @@ fn resolve_expr<'tcx>(visitor: &mut RegionResolutionVisitor<'tcx>, expr: &'tcx h\n                 // The idea is that call.callee_id represents *the time when\n                 // the invoked function is actually running* and call.id\n                 // represents *the time to prepare the arguments and make the\n-                // call*.  See the section \"Borrows in Calls\" borrowck/README.md\n+                // call*. See the section \"Borrows in Calls\" borrowck/README.md\n                 // for an extended explanation of why this distinction is\n                 // important.\n                 //"}, {"sha": "ebb78213a63a13dd052f0b3b4e7c48f5c5acc451", "filename": "compiler/rustc_hir_analysis/src/check_unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck_unused.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -50,7 +50,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) {\n fn unused_crates_lint(tcx: TyCtxt<'_>) {\n     let lint = lint::builtin::UNUSED_EXTERN_CRATES;\n \n-    // Collect first the crates that are completely unused.  These we\n+    // Collect first the crates that are completely unused. These we\n     // can always suggest removing (no matter which edition we are\n     // in).\n     let unused_extern_crates: FxHashMap<LocalDefId, Span> = tcx"}, {"sha": "74179a2bc68c934051b699aaf78ee5afd1726101", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -438,7 +438,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             // when this coercion occurs, we would be changing the\n             // field `ptr` from a thin pointer of type `*mut [i32;\n             // 3]` to a fat pointer of type `*mut [i32]` (with\n-            // extra data `3`).  **The purpose of this check is to\n+            // extra data `3`). **The purpose of this check is to\n             // make sure that we know how to do this conversion.**\n             //\n             // To check if this impl is legal, we would walk down"}, {"sha": "ba347851af880871f567a9aa238a0d92cf64b76d", "filename": "compiler/rustc_hir_analysis/src/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -171,7 +171,7 @@ fn check_object_overlap<'tcx>(\n         for component_def_id in component_def_ids {\n             if !tcx.is_object_safe(component_def_id) {\n                 // Without the 'object_safe_for_dispatch' feature this is an error\n-                // which will be reported by wfcheck.  Ignore it here.\n+                // which will be reported by wfcheck. Ignore it here.\n                 // This is tested by `coherence-impl-trait-for-trait-object-safe.rs`.\n                 // With the feature enabled, the trait is not implemented automatically,\n                 // so this is valid."}, {"sha": "9435022ddf0e1cb65dc122e627483696e8129651", "filename": "compiler/rustc_hir_analysis/src/collect/lifetimes.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Flifetimes.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1,9 +1,9 @@\n //! Resolution of early vs late bound lifetimes.\n //!\n-//! Name resolution for lifetimes is performed on the AST and embedded into HIR.  From this\n+//! Name resolution for lifetimes is performed on the AST and embedded into HIR. From this\n //! information, typechecking needs to transform the lifetime parameters into bound lifetimes.\n-//! Lifetimes can be early-bound or late-bound.  Construction of typechecking terms needs to visit\n-//! the types in HIR to identify late-bound lifetimes and assign their Debruijn indices.  This file\n+//! Lifetimes can be early-bound or late-bound. Construction of typechecking terms needs to visit\n+//! the types in HIR to identify late-bound lifetimes and assign their Debruijn indices. This file\n //! is also responsible for assigning their semantics to implicit lifetimes in trait objects.\n \n use rustc_ast::walk_list;\n@@ -70,7 +70,7 @@ impl RegionExt for Region {\n /// that it corresponds to.\n ///\n /// FIXME. This struct gets converted to a `ResolveLifetimes` for\n-/// actual use. It has the same data, but indexed by `LocalDefId`.  This\n+/// actual use. It has the same data, but indexed by `LocalDefId`. This\n /// is silly.\n #[derive(Debug, Default)]\n struct NamedRegionMap {\n@@ -1283,7 +1283,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         // We may fail to resolve higher-ranked lifetimes that are mentioned by APIT.\n         // AST-based resolution does not care for impl-trait desugaring, which are the\n-        // responibility of lowering.  This may create a mismatch between the resolution\n+        // responibility of lowering. This may create a mismatch between the resolution\n         // AST found (`region_def_id`) which points to HRTB, and what HIR allows.\n         // ```\n         // fn foo(x: impl for<'a> Trait<'a, Assoc = impl Copy + 'a>) {}\n@@ -1434,7 +1434,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         DefKind::ConstParam => Some(ObjectLifetimeDefault::Empty),\n                         DefKind::TyParam => Some(self.tcx.object_lifetime_default(param.def_id)),\n                         // We may also get a `Trait` or `TraitAlias` because of how generics `Self` parameter\n-                        // works.  Ignore it because it can't have a meaningful lifetime default.\n+                        // works. Ignore it because it can't have a meaningful lifetime default.\n                         DefKind::LifetimeParam | DefKind::Trait | DefKind::TraitAlias => None,\n                         dk => bug!(\"unexpected def_kind {:?}\", dk),\n                     }"}, {"sha": "d43a2d72ceccf50999dc1ffd8e022f1ecba0c3be", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -246,7 +246,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n \n     // Subtle: before we store the predicates into the tcx, we\n     // sort them so that predicates like `T: Foo<Item=U>` come\n-    // before uses of `U`.  This avoids false ambiguity errors\n+    // before uses of `U`. This avoids false ambiguity errors\n     // in trait checking. See `setup_constraining_predicates`\n     // for details.\n     if let Node::Item(&Item { kind: ItemKind::Impl { .. }, .. }) = node {"}, {"sha": "9f8da463650fdaa69d30f8d69ce7ea84a0b1853e", "filename": "compiler/rustc_hir_analysis/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Flib.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -22,7 +22,7 @@ several major phases:\n 4. Finally, the check phase then checks function bodies and so forth.\n    Within the check phase, we check each function body one at a time\n    (bodies of function expressions are checked as part of the\n-   containing function).  Inference is used to supply types wherever\n+   containing function). Inference is used to supply types wherever\n    they are unknown. The actual checking of a function itself has\n    several phases (check, regionck, writeback), as discussed in the\n    documentation for the [`check`] module.\n@@ -46,7 +46,7 @@ independently:\n   local variables, type parameters, etc as necessary.\n \n - infer: finds the types to use for each type variable such that\n-  all subtyping and assignment constraints are met.  In essence, the check\n+  all subtyping and assignment constraints are met. In essence, the check\n   module specifies the constraints, and the infer module solves them.\n \n ## Note\n@@ -542,7 +542,7 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorGuaranteed> {\n pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n-    // scope.  This is derived from the enclosing item-like thing.\n+    // scope. This is derived from the enclosing item-like thing.\n     let env_def_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     item_cx.astconv().ast_ty_to_ty(hir_ty)\n@@ -555,7 +555,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n ) -> Bounds<'tcx> {\n     // In case there are any projections, etc., find the \"environment\"\n     // def-ID that will be used to determine the traits/predicates in\n-    // scope.  This is derived from the enclosing item-like thing.\n+    // scope. This is derived from the enclosing item-like thing.\n     let env_def_id = tcx.hir().get_parent_item(hir_trait.hir_ref_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     let mut bounds = Bounds::default();"}, {"sha": "925042436dec150821c957051f7f13283069b84e", "filename": "compiler/rustc_hir_analysis/src/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -139,7 +139,7 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n                 if let Some(unsubstituted_predicates) = global_inferred_outlives.get(&def.did()) {\n                     for (unsubstituted_predicate, &span) in &unsubstituted_predicates.0 {\n                         // `unsubstituted_predicate` is `U: 'b` in the\n-                        // example above.  So apply the substitution to\n+                        // example above. So apply the substitution to\n                         // get `T: 'a` (or `predicate`):\n                         let predicate = unsubstituted_predicates\n                             .rebind(*unsubstituted_predicate)"}, {"sha": "c930b921b75c9bd59e91a3e3ee3f870c96b12a34", "filename": "compiler/rustc_hir_analysis/src/outlives/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Futils.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -48,7 +48,7 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n                         // ```\n                         //\n                         // Here `outlived_region = 'a` and `kind = &'b\n-                        // u32`.  Decomposing `&'b u32` into\n+                        // u32`. Decomposing `&'b u32` into\n                         // components would yield `'b`, and we add the\n                         // where clause that `'b: 'a`.\n                         insert_outlives_predicate(\n@@ -71,7 +71,7 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n                         // ```\n                         //\n                         // Here `outlived_region = 'a` and `kind =\n-                        // Vec<U>`.  Decomposing `Vec<U>` into\n+                        // Vec<U>`. Decomposing `Vec<U>` into\n                         // components would yield `U`, and we add the\n                         // where clause that `U: 'a`.\n                         let ty: Ty<'tcx> = param_ty.to_ty(tcx);\n@@ -115,7 +115,7 @@ pub(crate) fn insert_outlives_predicate<'tcx>(\n \n                     Component::EscapingProjection(_) => {\n                         // As above, but the projection involves\n-                        // late-bound regions.  Therefore, the WF\n+                        // late-bound regions. Therefore, the WF\n                         // requirement is not checked in type definition\n                         // but at fn call site, so ignore it.\n                         //\n@@ -175,7 +175,7 @@ fn is_free_region(region: Region<'_>) -> bool {\n         //     }\n         //\n         // The type above might generate a `T: 'b` bound, but we can\n-        // ignore it.  We can't put it on the struct header anyway.\n+        // ignore it. We can't put it on the struct header anyway.\n         ty::ReLateBound(..) => false,\n \n         // These regions don't appear in types from type declarations:"}, {"sha": "c9b59d35704b2846b25833245d6588d44735ed05", "filename": "compiler/rustc_hir_analysis/src/variance/solve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fvariance%2Fsolve.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -44,7 +44,7 @@ pub fn solve_constraints<'tcx>(\n \n impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n     fn solve(&mut self) {\n-        // Propagate constraints until a fixed point is reached.  Note\n+        // Propagate constraints until a fixed point is reached. Note\n         // that the maximum number of iterations is 2C where C is the\n         // number of constraints (each variable can change values at most\n         // twice). Since number of constraints is linear in size of the"}, {"sha": "26e8dd654c13f57d823a9263437d04f96be79f4f", "filename": "compiler/rustc_hir_typeck/src/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fclosure.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -524,7 +524,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // FIXME(#45727): As discussed in [this comment][c1], naively\n         // forcing equality here actually results in suboptimal error\n-        // messages in some cases.  For now, if there would have been\n+        // messages in some cases. For now, if there would have been\n         // an obvious error, we fallback to declaring the type of the\n         // closure to be the one the user gave, which allows other\n         // error message code to trigger."}, {"sha": "bbf7b81a2cc66ca82ccff36b50b0947c99710b77", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -313,7 +313,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n         // If we have a parameter of type `&M T_a` and the value\n         // provided is `expr`, we will be adding an implicit borrow,\n-        // meaning that we convert `f(expr)` to `f(&M *expr)`.  Therefore,\n+        // meaning that we convert `f(expr)` to `f(&M *expr)`. Therefore,\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n@@ -340,7 +340,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 continue;\n             }\n \n-            // At this point, we have deref'd `a` to `referent_ty`.  So\n+            // At this point, we have deref'd `a` to `referent_ty`. So\n             // imagine we are coercing from `&'a mut Vec<T>` to `&'b mut [T]`.\n             // In the autoderef loop for `&'a mut Vec<T>`, we would get\n             // three callbacks:\n@@ -371,7 +371,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // - if in sub mode, that means we want to use `'b` (the\n             //   region from the target reference) for both\n             //   pointers [2]. This is because sub mode (somewhat\n-            //   arbitrarily) returns the subtype region.  In the case\n+            //   arbitrarily) returns the subtype region. In the case\n             //   where we are coercing to a target type, we know we\n             //   want to use that target type region (`'b`) because --\n             //   for the program to type-check -- it must be the\n@@ -383,7 +383,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             //     annotate the region of a borrow), and regionck has\n             //     code that adds edges from the region of a borrow\n             //     (`'b`, here) into the regions in the borrowed\n-            //     expression (`*x`, here).  (Search for \"link\".)\n+            //     expression (`*x`, here). (Search for \"link\".)\n             // - if in lub mode, things can get fairly complicated. The\n             //   easiest thing is just to make a fresh\n             //   region variable [4], which effectively means we defer\n@@ -457,7 +457,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         if ty == a && mt_a.mutbl.is_not() && autoderef.step_count() == 1 {\n             // As a special case, if we would produce `&'a *x`, that's\n             // a total no-op. We end up with the type `&'a T` just as\n-            // we started with.  In that case, just skip it\n+            // we started with. In that case, just skip it\n             // altogether. This is just an optimization.\n             //\n             // Note that for `&mut`, we DO want to reborrow --\n@@ -1476,7 +1476,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n             //     if let Some(x) = ... { }\n             //\n             // we wind up with a second match arm that is like `_ =>\n-            // ()`.  That is the case we are considering here. We take\n+            // ()`. That is the case we are considering here. We take\n             // a different path to get the right \"expected, found\"\n             // message and so forth (and because we know that\n             // `expression_ty` will be unit)."}, {"sha": "bc7474cdfcf3de1023b1b2af40ab46d7a82cb52b", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -459,9 +459,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             hir::BorrowKind::Ref => {\n                 // Note: at this point, we cannot say what the best lifetime\n-                // is to use for resulting pointer.  We want to use the\n+                // is to use for resulting pointer. We want to use the\n                 // shortest lifetime possible so as to avoid spurious borrowck\n-                // errors.  Moreover, the longest lifetime will depend on the\n+                // errors. Moreover, the longest lifetime will depend on the\n                 // precise details of the value whose address is being taken\n                 // (and how long it is valid), which we don't know yet until\n                 // type inference is complete.\n@@ -687,7 +687,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             } else {\n                 // If `ctxt.coerce` is `None`, we can just ignore\n-                // the type of the expression.  This is because\n+                // the type of the expression. This is because\n                 // either this was a break *without* a value, in\n                 // which case it is always a legal type (`()`), or\n                 // else an error would have been flagged by the"}, {"sha": "dde8797804f04bb44fa7737865b044c496b3abff", "filename": "compiler/rustc_hir_typeck/src/fallback.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffallback.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n         // We now see if we can make progress. This might cause us to\n         // unify inference variables for opaque types, since we may\n         // have unified some other type variables during the first\n-        // phase of fallback.  This means that we only replace\n+        // phase of fallback. This means that we only replace\n         // inference variables with their underlying opaque types as a\n         // last resort.\n         //\n@@ -76,7 +76,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     //   (and the setting of `#![feature(never_type_fallback)]`).\n     //\n     // Fallback becomes very dubious if we have encountered\n-    // type-checking errors.  In that case, fallback to Error.\n+    // type-checking errors. In that case, fallback to Error.\n     //\n     // Sets `FnCtxt::fallback_has_occurred` if fallback is performed\n     // during this call.\n@@ -136,7 +136,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     /// constrained to have some other type).\n     ///\n     /// However, the fallback used to be `()` (before the `!` type was\n-    /// added).  Moreover, there are cases where the `!` type 'leaks\n+    /// added). Moreover, there are cases where the `!` type 'leaks\n     /// out' from dead code into type variables that affect live\n     /// code. The most common case is something like this:\n     ///\n@@ -149,7 +149,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     /// ```\n     ///\n     /// Here, coercing the type `!` into `?M` will create a diverging\n-    /// type variable `?X` where `?X <: ?M`.  We also have that `?D <:\n+    /// type variable `?X` where `?X <: ?M`. We also have that `?D <:\n     /// ?M`. If `?M` winds up unconstrained, then `?X` will\n     /// fallback. If it falls back to `!`, then all the type variables\n     /// will wind up equal to `!` -- this includes the type `?D`\n@@ -185,7 +185,7 @@ impl<'tcx> FnCtxt<'_, 'tcx> {\n     ///\n     /// The algorithm we use:\n     /// * Identify all variables that are coerced *into* by a\n-    ///   diverging variable.  Do this by iterating over each\n+    ///   diverging variable. Do this by iterating over each\n     ///   diverging, unsolved variable and finding all variables\n     ///   reachable from there. Call that set `D`.\n     /// * Walk over all unsolved, non-diverging variables, and find"}, {"sha": "156c02149e7c869e5144a1ac8de8797cdb973741", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -452,7 +452,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             && method_call_list.contains(&conversion_method.name)\n                             // If receiver is `.clone()` and found type has one of those methods,\n                             // we guess that the user wants to convert from a slice type (`&[]` or `&str`)\n-                            // to an owned type (`Vec` or `String`).  These conversions clone internally,\n+                            // to an owned type (`Vec` or `String`). These conversions clone internally,\n                             // so we remove the user's `clone` call.\n                         {\n                             vec![(\n@@ -649,7 +649,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             }\n             ty::Adt(def, _) if def.is_box() && self.can_coerce(box_found, expected) => {\n-                // Check if the parent expression is a call to Pin::new.  If it\n+                // Check if the parent expression is a call to Pin::new. If it\n                 // is and we were expecting a Box, ergo Pin<Box<expected>>, we\n                 // can suggest Box::pin.\n                 let parent = self.tcx.hir().parent_id(expr.hir_id);"}, {"sha": "ed3d890315704cefd1f2932e62b3f3e30a6c47e8", "filename": "compiler/rustc_hir_typeck/src/generator_interior/drop_ranges/record_consumed_borrow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fgenerator_interior%2Fdrop_ranges%2Frecord_consumed_borrow.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -116,7 +116,7 @@ impl<'tcx> ExprUseDelegate<'tcx> {\n         // where the `identity(...)` (the rvalue) produces a return type\n         // of `&'rv mut A`, where `'a: 'rv`. We then assign this result to\n         // `'y`, resulting in (transitively) `'a: 'y` (i.e., while `y` is in use,\n-        // `a` will be considered borrowed).  Other parts of the code will ensure\n+        // `a` will be considered borrowed). Other parts of the code will ensure\n         // that if `y` is live over a yield, `&'y mut A` appears in the generator\n         // state. If `'y` is live, then any sound region analysis must conclude\n         // that `'a` is also live. So if this causes a bug, blame some other"}, {"sha": "48c75cde9a5fc544948e231ea4077a86ad698f9d", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -736,7 +736,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n             }\n \n             PatKind::Box(ref subpat) | PatKind::Ref(ref subpat, _) => {\n-                // box p1, &p1, &mut p1.  we can ignore the mutability of\n+                // box p1, &p1, &mut p1. we can ignore the mutability of\n                 // PatKind::Ref since that information is already contained\n                 // in the type.\n                 let subplace = self.cat_deref(pat, place_with_id)?;"}, {"sha": "b810a967a2451192f670bab6edf6fb6f451c8329", "filename": "compiler/rustc_hir_typeck/src/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -413,7 +413,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Register obligations for the parameters. This will include the\n         // `Self` parameter, which in turn has a bound of the main trait,\n-        // so this also effectively registers `obligation` as well.  (We\n+        // so this also effectively registers `obligation` as well. (We\n         // used to register `obligation` explicitly, but that resulted in\n         // double error messages being reported.)\n         //"}, {"sha": "33a9a0cabb9d5067266f1d9025e4d04bc8cf324a", "filename": "compiler/rustc_incremental/src/assert_dep_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_dep_graph.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -368,7 +368,7 @@ fn walk_between<'q>(\n ) -> FxHashSet<DepKind> {\n     // This is a bit tricky. We want to include a node only if it is:\n     // (a) reachable from a source and (b) will reach a target. And we\n-    // have to be careful about cycles etc.  Luckily efficiency is not\n+    // have to be careful about cycles etc. Luckily efficiency is not\n     // a big concern!\n \n     #[derive(Copy, Clone, PartialEq)]"}, {"sha": "ed7b272b13d178087c969aa3bda7f25da0bdec9a", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1,4 +1,4 @@\n-//! Debugging code to test fingerprints computed for query results.  For each node marked with\n+//! Debugging code to test fingerprints computed for query results. For each node marked with\n //! `#[rustc_clean]` we will compare the fingerprint from the current and from the previous\n //! compilation session as appropriate:\n //!"}, {"sha": "72676b718fabe61853a9820a3282e271b8aed203", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -331,7 +331,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         debug_assert!(self.infcx.inner.borrow_mut().type_variables().probe(b_vid).is_unknown());\n \n         // Generalize type of `a_ty` appropriately depending on the\n-        // direction.  As an example, assume:\n+        // direction. As an example, assume:\n         //\n         // - `a_ty == &'x ?1`, where `'x` is some free region and `?1` is an\n         //   inference variable,"}, {"sha": "99431567edac413f4aef86a04e49516ddf932599", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -370,7 +370,7 @@ impl<'tcx> NiceRegionError<'_, 'tcx> {\n         //   in the types are about to print\n         // - Meanwhile, the `maybe_highlighting_region` calls set up\n         //   highlights so that, if they do appear, we will replace\n-        //   them `'0` and whatever.  (This replacement takes place\n+        //   them `'0` and whatever. (This replacement takes place\n         //   inside the closure given to `maybe_highlighting_region`.)\n         //\n         // There is some duplication between the calls -- i.e., the"}, {"sha": "4dbb4b4d7b4da8b681d38180acc87270092f1fd6", "filename": "compiler/rustc_infer/src/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flattice.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -78,7 +78,7 @@ where\n         //\n         // Example: if the LHS is a type variable, and RHS is\n         // `Box<i32>`, then we current compare `v` to the RHS first,\n-        // which will instantiate `v` with `Box<i32>`.  Then when `v`\n+        // which will instantiate `v` with `Box<i32>`. Then when `v`\n         // is compared to the LHS, we instantiate LHS with `Box<i32>`.\n         // But if we did in reverse order, we would create a `v <:\n         // LHS` (or vice versa) constraint and then instantiate"}, {"sha": "0b478f4cf5cd0701d6293af19f2bab9b2d5af568", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -52,7 +52,7 @@ pub struct LexicalRegionResolutions<'tcx> {\n \n #[derive(Copy, Clone, Debug)]\n pub(crate) enum VarValue<'tcx> {\n-    /// Empty lifetime is for data that is never accessed.  We tag the\n+    /// Empty lifetime is for data that is never accessed. We tag the\n     /// empty lifetime with a universe -- the idea is that we don't\n     /// want `exists<'a> { forall<'b> { 'b: 'a } }` to be satisfiable.\n     /// Therefore, the `'empty` in a universe `U` is less than all\n@@ -510,7 +510,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n \n         // If both `a` and `b` are free, consult the declared\n-        // relationships.  Note that this can be more precise than the\n+        // relationships. Note that this can be more precise than the\n         // `lub` relationship defined below, since sometimes the \"lub\"\n         // is actually the `postdom_upper_bound` (see\n         // `TransitiveRelation` for more details).\n@@ -665,7 +665,7 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         // conflicting regions to report to the user. As we walk, we\n         // trip the flags from false to true, and if we find that\n         // we've already reported an error involving any particular\n-        // node we just stop and don't report the current error.  The\n+        // node we just stop and don't report the current error. The\n         // idea is to report errors that derive from independent\n         // regions of the graph, but not those that derive from\n         // overlapping locations."}, {"sha": "f0e42c1fce49c3ea685f6301b22f1d09e702e774", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1105,7 +1105,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.tcx.mk_region(ty::ReVar(region_var))\n     }\n \n-    /// Return the universe that the region `r` was created in.  For\n+    /// Return the universe that the region `r` was created in. For\n     /// most regions (e.g., `'static`, named regions from the user,\n     /// etc) this is the root universe U0. For inference variables or\n     /// placeholders, however, it will return the universe which they\n@@ -1361,7 +1361,7 @@ impl<'tcx> InferCtxt<'tcx> {\n     }\n \n     /// Resolve any type variables found in `value` -- but only one\n-    /// level.  So, if the variable `?X` is bound to some type\n+    /// level. So, if the variable `?X` is bound to some type\n     /// `Foo<?Y>`, then this would return `Foo<?Y>` (but `?Y` may\n     /// itself be bound to a type).\n     ///\n@@ -1720,7 +1720,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n         if let None = self.tainted_by_errors() {\n             // As a heuristic, just skip reporting region errors\n             // altogether if other errors have been reported while\n-            // this infcx was in use.  This is totally hokey but\n+            // this infcx was in use. This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n             self.report_region_errors(generic_param_scope, &errors);"}, {"sha": "985cb6463a0646939a0609c09004787d5a39355b", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -439,7 +439,7 @@ trait VidValuePair<'tcx>: Debug {\n     fn value_ty(&self) -> Ty<'tcx>;\n \n     /// Extract the scopes that apply to whichever side of the tuple\n-    /// the vid was found on.  See the comment where this is called\n+    /// the vid was found on. See the comment where this is called\n     /// for more details on why we want them.\n     fn vid_scopes<'r, D: TypeRelatingDelegate<'tcx>>(\n         &self,\n@@ -831,7 +831,7 @@ where\n /// (these are not explicitly present in the ty representation right\n /// now). This visitor handles that: it descends the type, tracking\n /// binder depth, and finds late-bound regions targeting the\n-/// `for<..`>.  For each of those, it creates an entry in\n+/// `for<..`>. For each of those, it creates an entry in\n /// `bound_region_scope`.\n struct ScopeInstantiator<'me, 'tcx> {\n     next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,"}, {"sha": "6b54ee9576f6703978ef6d7d091984c5735058be", "filename": "compiler/rustc_infer/src/infer/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fopaque_types.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                     DefiningAnchor::Bind(_) => {\n                         // Check that this is `impl Trait` type is\n                         // declared by `parent_def_id` -- i.e., one whose\n-                        // value we are inferring.  At present, this is\n+                        // value we are inferring. At present, this is\n                         // always true during the first phase of\n                         // type-check, but not always true later on during\n                         // NLL. Once we support named opaque types more fully,\n@@ -380,7 +380,7 @@ impl<'tcx> InferCtxt<'tcx> {\n         };\n         let item_kind = &self.tcx.hir().expect_item(def_id).kind;\n \n-        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, ..  }) = item_kind else {\n+        let hir::ItemKind::OpaqueTy(hir::OpaqueTy { origin, .. }) = item_kind else {\n             span_bug!(\n                 span,\n                 \"weird opaque type: {:#?}, {:#?}\","}, {"sha": "31d978b4ccb2b902006ff20d871e8df1f269418d", "filename": "compiler/rustc_infer/src/infer/outlives/components.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fcomponents.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -153,7 +153,7 @@ fn compute_components<'tcx>(\n                     out.push(Component::Projection(*data));\n                 } else {\n                     // fallback case: hard code\n-                    // OutlivesProjectionComponents.  Continue walking\n+                    // OutlivesProjectionComponents. Continue walking\n                     // through and constrain Pi.\n                     let mut subcomponents = smallvec![];\n                     let mut subvisited = SsoHashSet::new();\n@@ -195,7 +195,7 @@ fn compute_components<'tcx>(\n             ty::Error(_) => {\n                 // (*) Function pointers and trait objects are both binders.\n                 // In the RFC, this means we would add the bound regions to\n-                // the \"bound regions list\".  In our representation, no such\n+                // the \"bound regions list\". In our representation, no such\n                 // list is maintained explicitly, because bound regions\n                 // themselves can be readily identified.\n                 compute_components_recursive(tcx, ty.into(), out, visited);"}, {"sha": "07838911c885eacdac83e701f8a7bc14f6e92ae2", "filename": "compiler/rustc_infer/src/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fobligations.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -371,7 +371,7 @@ where\n         // particular). :) First off, we have to choose between using the\n         // OutlivesProjectionEnv, OutlivesProjectionTraitDef, and\n         // OutlivesProjectionComponent rules, any one of which is\n-        // sufficient.  If there are no inference variables involved, it's\n+        // sufficient. If there are no inference variables involved, it's\n         // not hard to pick the right rule, but if there are, we're in a\n         // bit of a catch 22: if we picked which rule we were going to\n         // use, we could add constraints to the region inference graph"}, {"sha": "263c6a47dd2af79f791343f418ca911376d44a52", "filename": "compiler/rustc_infer/src/infer/type_variable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ftype_variable.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -433,7 +433,7 @@ impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n     fn unify_values(value1: &Self, value2: &Self) -> Result<Self, ut::NoError> {\n         match (value1, value2) {\n             // We never equate two type variables, both of which\n-            // have known types.  Instead, we recursively equate\n+            // have known types. Instead, we recursively equate\n             // those types.\n             (&TypeVariableValue::Known { .. }, &TypeVariableValue::Known { .. }) => {\n                 bug!(\"equating two type variables, both of which have known types\")"}, {"sha": "c2ac2c5db26e4814b78d77cd8ad295f819d69c45", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -333,7 +333,7 @@ pub fn transitive_bounds<'tcx>(\n /// A specialized variant of `elaborate_trait_refs` that only elaborates trait references that may\n /// define the given associated type `assoc_name`. It uses the\n /// `super_predicates_that_define_assoc_type` query to avoid enumerating super-predicates that\n-/// aren't related to `assoc_item`.  This is used when resolving types like `Self::Item` or\n+/// aren't related to `assoc_item`. This is used when resolving types like `Self::Item` or\n /// `T::Item` and helps to avoid cycle errors (see e.g. #35237).\n pub fn transitive_bounds_that_define_assoc_type<'tcx>(\n     tcx: TyCtxt<'tcx>,"}, {"sha": "6e815863d06ff9e226d6fa1f5bb06fd0152a6e5d", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -2,7 +2,7 @@\n //!\n //! The idea with `rustc_lexer` is to make a reusable library,\n //! by separating out pure lexing and rustc-specific concerns, like spans,\n-//! error reporting, and interning.  So, rustc_lexer operates directly on `&str`,\n+//! error reporting, and interning. So, rustc_lexer operates directly on `&str`,\n //! produces simple tokens which are a pair of type-tag and a bit of original text,\n //! and does not report errors, instead storing them as flags on the token.\n //!"}, {"sha": "8507ca9d89ed776b77228fec41521ab835ce75e3", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -299,7 +299,7 @@ where\n         let tail = &tail[first_non_space..];\n         if let Some(c) = tail.chars().nth(0) {\n             // For error reporting, we would like the span to contain the character that was not\n-            // skipped.  The +1 is necessary to account for the leading \\ that started the escape.\n+            // skipped. The +1 is necessary to account for the leading \\ that started the escape.\n             let end = start + first_non_space + c.len_utf8() + 1;\n             if c.is_whitespace() {\n                 callback(start..end, Err(EscapeError::UnskippedWhitespaceWarning));"}, {"sha": "cca36913dea113650269b7376a8bef5b31da5c31", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -50,7 +50,7 @@ rustc_index::newtype_index! {\n     }\n }\n \n-/// Specifications found at this position in the stack.  This map only represents the lints\n+/// Specifications found at this position in the stack. This map only represents the lints\n /// found for one set of attributes (like `shallow_lint_levels_on` does).\n ///\n /// We store the level specifications as a linked list.\n@@ -163,7 +163,7 @@ fn shallow_lint_levels_on(tcx: TyCtxt<'_>, owner: hir::OwnerId) -> ShallowLintLe\n     match attrs.map.range(..) {\n         // There is only something to do if there are attributes at all.\n         [] => {}\n-        // Most of the time, there is only one attribute.  Avoid fetching HIR in that case.\n+        // Most of the time, there is only one attribute. Avoid fetching HIR in that case.\n         [(local_id, _)] => levels.add_id(HirId { owner, local_id: *local_id }),\n         // Otherwise, we need to visit the attributes in source code order, so we fetch HIR and do\n         // a standard visit."}, {"sha": "c997d8945d16ebdf2d5ac2f4a3f9dbee0e41d8b3", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -277,7 +277,7 @@ impl AddToDiagnostic for SuggestChangingAssocTypes<'_, '_> {\n         ) -> rustc_errors::SubdiagnosticMessage,\n     {\n         // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n-        // bound.  Let's see if this type does that.\n+        // bound. Let's see if this type does that.\n \n         // We use a HIR visitor to walk the type.\n         use rustc_hir::intravisit::{self, Visitor};"}, {"sha": "f728bff0e3b91a3a1665ae58eab72654474ed1c9", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -461,7 +461,7 @@ extern \"C\" void LLVMRustAddLibraryInfo(LLVMPassManagerRef PMR, LLVMModuleRef M,\n \n extern \"C\" void LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n   // Initializing the command-line options more than once is not allowed. So,\n-  // check if they've already been initialized.  (This could happen if we're\n+  // check if they've already been initialized. (This could happen if we're\n   // being called from rustpkg, for example). If the arguments change, then\n   // that's just kinda unfortunate.\n   static bool Initialized = false;\n@@ -1428,7 +1428,7 @@ LLVMRustThinLTOBufferLen(const LLVMRustThinLTOBuffer *Buffer) {\n }\n \n // This is what we used to parse upstream bitcode for actual ThinLTO\n-// processing.  We'll call this once per module optimized through ThinLTO, and\n+// processing. We'll call this once per module optimized through ThinLTO, and\n // it'll be called concurrently on many threads.\n extern \"C\" LLVMModuleRef\n LLVMRustParseBitcodeForLTO(LLVMContextRef Context,"}, {"sha": "f6431899731fffdeea6d97a3170f96e924ba984c", "filename": "compiler/rustc_metadata/src/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Ffs.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -90,7 +90,7 @@ pub fn encode_and_write_metadata(tcx: TyCtxt<'_>) -> (EncodedMetadata, bool) {\n     let _prof_timer = tcx.sess.prof.generic_activity(\"write_crate_metadata\");\n \n     // If the user requests metadata as output, rename `metadata_filename`\n-    // to the expected output `out_filename`.  The match above should ensure\n+    // to the expected output `out_filename`. The match above should ensure\n     // this file always exists.\n     let need_metadata_file = tcx.sess.opts.output_types.contains_key(&OutputType::Metadata);\n     let (metadata_filename, metadata_tmpdir) = if need_metadata_file {"}, {"sha": "0f5f74007c1060536912477a6b5815635a37a7d1", "filename": "compiler/rustc_metadata/src/locator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Flocator.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -591,7 +591,7 @@ impl<'a> CrateLocator<'a> {\n                     Err(MetadataError::LoadFailure(err)) => {\n                         info!(\"no metadata found: {}\", err);\n                         // The file was present and created by the same compiler version, but we\n-                        // couldn't load it for some reason.  Give a hard error instead of silently\n+                        // couldn't load it for some reason. Give a hard error instead of silently\n                         // ignoring it, but only if we would have given an error anyway.\n                         self.crate_rejections\n                             .via_invalid"}, {"sha": "6f05c76e89de1adc89b5e7344f186dd3d565c8c4", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -433,10 +433,10 @@ impl<'tcx> Collector<'tcx> {\n         }\n \n         // Update kind and, optionally, the name of all native libraries\n-        // (there may be more than one) with the specified name.  If any\n+        // (there may be more than one) with the specified name. If any\n         // library is mentioned more than once, keep the latest mention\n         // of it, so that any possible dependent libraries appear before\n-        // it.  (This ensures that the linker is able to see symbols from\n+        // it. (This ensures that the linker is able to see symbols from\n         // all possible dependent libraries before linking in the library\n         // in question.)\n         for passed_lib in &self.tcx.sess.opts.libs {"}, {"sha": "6407ff7d0971400479bfd6ce40e67aefe9239dcf", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -172,7 +172,7 @@ impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for SyntaxContext {\n impl<'a, 'tcx> Encodable<EncodeContext<'a, 'tcx>> for ExpnId {\n     fn encode(&self, s: &mut EncodeContext<'a, 'tcx>) {\n         if self.krate == LOCAL_CRATE {\n-            // We will only write details for local expansions.  Non-local expansions will fetch\n+            // We will only write details for local expansions. Non-local expansions will fetch\n             // data from the corresponding crate's metadata.\n             // FIXME(#43047) FIXME(#74731) We may eventually want to avoid relying on external\n             // metadata from proc-macro crates."}, {"sha": "9e63c2bd2216ff652f879dd787d551ce5a13471a", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -582,10 +582,10 @@ impl<'hir> Map<'hir> {\n \n     /// Visits all item-likes in the crate in some deterministic (but unspecified) order. If you\n     /// need to process every item-like, and don't care about visiting nested items in a particular\n-    /// order then this method is the best choice.  If you do care about this nesting, you should\n+    /// order then this method is the best choice. If you do care about this nesting, you should\n     /// use the `tcx.hir().walk_toplevel_module`.\n     ///\n-    /// Note that this function will access HIR for all the item-likes in the crate.  If you only\n+    /// Note that this function will access HIR for all the item-likes in the crate. If you only\n     /// need to access some of them, it is usually better to manually loop on the iterators\n     /// provided by `tcx.hir_crate_items(())`.\n     ///"}, {"sha": "96d36b441f31aa4d73278d86734b8368b3faf274", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -36,7 +36,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Owner<'tcx> {\n }\n \n /// Gather the LocalDefId for each item-like within a module, including items contained within\n-/// bodies.  The Ids are in visitor order.  This is used to partition a pass between modules.\n+/// bodies. The Ids are in visitor order. This is used to partition a pass between modules.\n #[derive(Debug, HashStable, Encodable, Decodable)]\n pub struct ModuleItems {\n     submodules: Box<[OwnerId]>,"}, {"sha": "5f425a287687e60a562e446be171d156c959ebae", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -509,7 +509,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.reserve_and_set_dedup(GlobalAlloc::Static(static_id))\n     }\n \n-    /// Generates an `AllocId` for a function.  Depending on the function type,\n+    /// Generates an `AllocId` for a function. Depending on the function type,\n     /// this might get deduplicated or assigned a new ID each time.\n     pub fn create_fn_alloc(self, instance: Instance<'tcx>) -> AllocId {\n         // Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n@@ -518,7 +518,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // We thus generate a new `AllocId` for every mention of a function. This means that\n         // `main as fn() == main as fn()` is false, while `let x = main as fn(); x == x` is true.\n         // However, formatting code relies on function identity (see #58320), so we only do\n-        // this for generic functions.  Lifetime parameters are ignored.\n+        // this for generic functions. Lifetime parameters are ignored.\n         let is_generic = instance\n             .substs\n             .into_iter()\n@@ -535,7 +535,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    /// Generates an `AllocId` for a (symbolic, not-reified) vtable.  Will get deduplicated.\n+    /// Generates an `AllocId` for a (symbolic, not-reified) vtable. Will get deduplicated.\n     pub fn create_vtable_alloc(\n         self,\n         ty: Ty<'tcx>,"}, {"sha": "e52b243ecf635fa82eaf406ca40d5301d38e2c4a", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -2483,7 +2483,7 @@ impl<'tcx> ConstantKind<'tcx> {\n \n         // FIXME(const_generics): We currently have to special case parameters because `min_const_generics`\n         // does not provide the parents generics to anonymous constants. We still allow generic const\n-        // parameters by themselves however, e.g. `N`.  These constants would cause an ICE if we were to\n+        // parameters by themselves however, e.g. `N`. These constants would cause an ICE if we were to\n         // ever try to substitute the generic parameters in their bodies.\n         //\n         // While this doesn't happen as these constants are always used as `ty::ConstKind::Param`, it does"}, {"sha": "6e905224c1336b5d6e0d1839d078523058648834", "filename": "compiler/rustc_middle/src/mir/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fterminator.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -74,7 +74,7 @@ impl SwitchTargets {\n     }\n \n     /// Finds the `BasicBlock` to which this `SwitchInt` will branch given the\n-    /// specific value.  This cannot fail, as it'll return the `otherwise`\n+    /// specific value. This cannot fail, as it'll return the `otherwise`\n     /// branch if there's not a specific match for the value.\n     pub fn target_for_value(&self, value: u128) -> BasicBlock {\n         self.iter().find_map(|(v, t)| (v == value).then_some(t)).unwrap_or_else(|| self.otherwise())"}, {"sha": "859a58c8998c770f5fe2100f836c1c60e867d4c7", "filename": "compiler/rustc_middle/src/ty/assoc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fassoc.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -72,7 +72,7 @@ impl AssocItem {\n             ty::AssocKind::Fn => {\n                 // We skip the binder here because the binder would deanonymize all\n                 // late-bound regions, and we don't want method signatures to show up\n-                // `as for<'r> fn(&'r MyType)`.  Pretty-printing handles late-bound\n+                // `as for<'r> fn(&'r MyType)`. Pretty-printing handles late-bound\n                 // regions just fine, showing `fn(&MyType)`.\n                 tcx.fn_sig(self.def_id).skip_binder().to_string()\n             }"}, {"sha": "c1d2672f2792df5caebb3df6721c9dd3414dc4a1", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -891,7 +891,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.dep_graph.read_index(DepNodeIndex::FOREVER_RED_NODE);\n \n         // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n-        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n+        // while iterating. If some query needs to add definitions, it should be `ensure`d above.\n         let definitions = self.untracked.definitions.leak();\n         definitions.def_path_table()\n     }\n@@ -903,7 +903,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // definitions change.\n         self.ensure().hir_crate(());\n         // Leak a read lock once we start iterating on definitions, to prevent adding new ones\n-        // while iterating.  If some query needs to add definitions, it should be `ensure`d above.\n+        // while iterating. If some query needs to add definitions, it should be `ensure`d above.\n         let definitions = self.untracked.definitions.leak();\n         definitions.def_path_hash_to_def_index_map()\n     }"}, {"sha": "6b9a37d848da2966870256959d7e1d10ecb672cc", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -290,7 +290,7 @@ pub struct RegionFolder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n     /// Stores the index of a binder *just outside* the stuff we have\n-    /// visited.  So this begins as INNERMOST; when we pass through a\n+    /// visited. So this begins as INNERMOST; when we pass through a\n     /// binder, it is incremented (via `shift_in`).\n     current_index: ty::DebruijnIndex,\n "}, {"sha": "6ac00d16c53de8f859a2395f1c0ff4979653e086", "filename": "compiler/rustc_middle/src/ty/instance.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finstance.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -756,14 +756,14 @@ fn needs_fn_once_adapter_shim(\n             Ok(false)\n         }\n         (ty::ClosureKind::Fn, ty::ClosureKind::FnMut) => {\n-            // The closure fn `llfn` is a `fn(&self, ...)`.  We want a\n+            // The closure fn `llfn` is a `fn(&self, ...)`. We want a\n             // `fn(&mut self, ...)`. In fact, at codegen time, these are\n             // basically the same thing, so we can just return llfn.\n             Ok(false)\n         }\n         (ty::ClosureKind::Fn | ty::ClosureKind::FnMut, ty::ClosureKind::FnOnce) => {\n             // The closure fn `llfn` is a `fn(&self, ...)` or `fn(&mut\n-            // self, ...)`.  We want a `fn(self, ...)`. We can produce\n+            // self, ...)`. We want a `fn(self, ...)`. We can produce\n             // this by doing something like:\n             //\n             //     fn call_once(self, ...) { call_mut(&self, ...) }"}, {"sha": "dfd016569c27a51de3135d2dbcef1706291d9747", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -879,7 +879,7 @@ where\n                     //\n                     // If the niche is a pointer, it's either valid (according\n                     // to its type), or null (which the niche field's scalar\n-                    // validity range encodes).  This allows using\n+                    // validity range encodes). This allows using\n                     // `dereferenceable_or_null` for e.g., `Option<&T>`, and\n                     // this will continue to work as long as we don't start\n                     // using more niches than just null (e.g., the first page of"}, {"sha": "1df19a2abf334b95407d8d9a262ef27c63d92f78", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -689,7 +689,7 @@ impl<'tcx> Predicate<'tcx> {\n         //\n         // In terms of why this is sound, the idea is that whenever there\n         // is an impl of `T:Foo<'a>`, it must show that `T:Bar<'a,'a>`\n-        // holds.  So if there is an impl of `T:Foo<'a>` that applies to\n+        // holds. So if there is an impl of `T:Foo<'a>` that applies to\n         // all `'a`, then we must know that `T:Bar<'a,'a>` holds for all\n         // `'a`.\n         //\n@@ -701,7 +701,7 @@ impl<'tcx> Predicate<'tcx> {\n         // Here, if we have `for<'x> T: Foo1<'x>`, then what do we know?\n         // The answer is that we know `for<'x,'b> T: Bar1<'x,'b>`. The\n         // reason is similar to the previous example: any impl of\n-        // `T:Foo1<'x>` must show that `for<'b> T: Bar1<'x, 'b>`.  So\n+        // `T:Foo1<'x>` must show that `for<'b> T: Bar1<'x, 'b>`. So\n         // basically we would want to collapse the bound lifetimes from\n         // the input (`trait_ref`) and the supertraits.\n         //\n@@ -1330,7 +1330,7 @@ impl<'tcx> OpaqueHiddenType<'tcx> {\n         debug!(?id_substs);\n \n         // This zip may have several times the same lifetime in `substs` paired with a different\n-        // lifetime from `id_substs`.  Simply `collect`ing the iterator is the correct behaviour:\n+        // lifetime from `id_substs`. Simply `collect`ing the iterator is the correct behaviour:\n         // it will pick the last one, which is the one we introduced in the impl-trait desugaring.\n         let map = substs.iter().zip(id_substs);\n \n@@ -2141,7 +2141,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Look up the name of a definition across crates. This does not look at HIR.\n     ///\n-    /// This method will ICE if the corresponding item does not have a name.  In these cases, use\n+    /// This method will ICE if the corresponding item does not have a name. In these cases, use\n     /// [`opt_item_name`] instead.\n     ///\n     /// [`opt_item_name`]: Self::opt_item_name"}, {"sha": "42fc78a4715f49dd15b8508cfcfa22b9ca33b26e", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -2132,9 +2132,9 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n \n         let identify_regions = self.tcx.sess.opts.unstable_opts.identify_regions;\n \n-        // These printouts are concise.  They do not contain all the information\n+        // These printouts are concise. They do not contain all the information\n         // the user might want to diagnose an error, but there is basically no way\n-        // to fit that into a short string.  Hence the recommendation to use\n+        // to fit that into a short string. Hence the recommendation to use\n         // `explain_region()` or `note_and_explain_region()`.\n         match *region {\n             ty::ReEarlyBound(ref data) => {"}, {"sha": "7c5563ac1aedeb597b8646603c27017da0488232", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -455,7 +455,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Rc<T> {\n             let slot = Rc::get_mut_unchecked(&mut unique);\n \n             // Semantically move the contained type out from `unique`, fold\n-            // it, then move the folded value back into `unique`.  Should\n+            // it, then move the folded value back into `unique`. Should\n             // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n             // value is not re-dropped.\n             let owned = ManuallyDrop::take(slot);\n@@ -501,7 +501,7 @@ impl<'tcx, T: TypeFoldable<'tcx>> TypeFoldable<'tcx> for Arc<T> {\n             let slot = Arc::get_mut_unchecked(&mut unique);\n \n             // Semantically move the contained type out from `unique`, fold\n-            // it, then move the folded value back into `unique`.  Should\n+            // it, then move the folded value back into `unique`. Should\n             // folding fail, `ManuallyDrop` ensures that the \"moved-out\"\n             // value is not re-dropped.\n             let owned = ManuallyDrop::take(slot);"}, {"sha": "14e5f01099a0832b94fa095941dc837402babc4d", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -205,7 +205,7 @@ static_assert_size!(TyKind<'_>, 32);\n ///\n /// ## Generators\n ///\n-/// Generators are handled similarly in `GeneratorSubsts`.  The set of\n+/// Generators are handled similarly in `GeneratorSubsts`. The set of\n /// type parameters is similar, but `CK` and `CS` are replaced by the\n /// following type parameters:\n ///"}, {"sha": "1018dd7e2adf69b238e8375e2a95e077695d4493", "filename": "compiler/rustc_middle/src/ty/typeck_results.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ftypeck_results.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -397,10 +397,10 @@ impl<'tcx> TypeckResults<'tcx> {\n \n     /// Returns the type of an expression as a monotype.\n     ///\n-    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression.  That is, in\n+    /// NB (1): This is the PRE-ADJUSTMENT TYPE for the expression. That is, in\n     /// some cases, we insert `Adjustment` annotations such as auto-deref or\n-    /// auto-ref.  The type returned by this function does not consider such\n-    /// adjustments.  See `expr_ty_adjusted()` instead.\n+    /// auto-ref. The type returned by this function does not consider such\n+    /// adjustments. See `expr_ty_adjusted()` instead.\n     ///\n     /// NB (2): This type doesn't provide type parameter substitutions; e.g., if you\n     /// ask for the type of `id` in `id(3)`, it will return `fn(&isize) -> isize`"}, {"sha": "c621efb3b3a523e888da8f8670f926d19cb9d09c", "filename": "compiler/rustc_mir_build/src/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_operand.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -27,7 +27,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// suitable also to be passed as function arguments.\n     ///\n     /// The operand returned from this function will *not be valid* after an ExprKind::Scope is\n-    /// passed, so please do *not* return it from functions to avoid bad miscompiles.  Returns an\n+    /// passed, so please do *not* return it from functions to avoid bad miscompiles. Returns an\n     /// operand suitable for use as a call argument. This is almost always equivalent to\n     /// `as_operand`, except for the particular case of passing values of (potentially) unsized\n     /// types \"by value\" (see details below)."}, {"sha": "a73ab344718a0c9ed9d745dc921a802d45a300a3", "filename": "compiler/rustc_mir_build/src/build/expr/stmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fstmt.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -57,7 +57,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 // question raised here -- should we \"freeze\" the\n                 // value of the lhs here?  I'm inclined to think not,\n                 // since it seems closer to the semantics of the\n-                // overloaded version, which takes `&mut self`.  This\n+                // overloaded version, which takes `&mut self`. This\n                 // only affects weird things like `x += {x += 1; x}`\n                 // -- is that equal to `x + (x + 1)` or `2*(x+1)`?\n "}, {"sha": "0961ce11e2f9a0f710d78e7bce6f96ecd496655e", "filename": "compiler/rustc_mir_build/src/build/matches/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1870,7 +1870,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // ```\n         // let place = Foo::new();\n         // match place { foo if inspect(foo)\n-        //     => feed(foo), ...  }\n+        //     => feed(foo), ... }\n         // ```\n         //\n         // will be treated as if it were really something like:\n@@ -1885,7 +1885,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         // ```\n         // let place = Foo::new();\n         // match place { ref mut foo if inspect(foo)\n-        //     => feed(foo), ...  }\n+        //     => feed(foo), ... }\n         // ```\n         //\n         // will be treated as if it were really something like:"}, {"sha": "ad7a568a231814fcf8c7dbe9aed308eb125716f6", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -456,7 +456,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     span: source_info.span,\n \n                     // FIXME(#54571): This constant comes from user input (a\n-                    // constant in a pattern).  Are there forms where users can add\n+                    // constant in a pattern). Are there forms where users can add\n                     // type annotations here?  For example, an associated constant?\n                     // Need to experiment.\n                     user_ty: None,\n@@ -504,7 +504,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     /// This is used by the overall `match_candidates` algorithm to structure\n     /// the match as a whole. See `match_candidates` for more details.\n     ///\n-    /// FIXME(#29623). In some cases, we have some tricky choices to make.  for\n+    /// FIXME(#29623). In some cases, we have some tricky choices to make. for\n     /// example, if we are testing that `x == 22`, but the candidate is `x @\n     /// 13..55`, what should we do? In the event that the test is true, we know\n     /// that the candidate applies, but in the event of false, we don't know"}, {"sha": "591b416337b3595c36380af7d0197cccf9562086", "filename": "compiler/rustc_mir_build/src/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fscope.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -53,7 +53,7 @@ loop {\n ```\n \n When processing the `let x`, we will add one drop to the scope for\n-`x`.  The break will then insert a drop for `x`. When we process `let\n+`x`. The break will then insert a drop for `x`. When we process `let\n y`, we will add another drop (in fact, to a subscope, but let's ignore\n that for now); any later drops would also drop `y`.\n \n@@ -757,7 +757,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             if self.tcx.sess.opts.unstable_opts.maximal_hir_to_mir_coverage {\n                 // Some consumers of rustc need to map MIR locations back to HIR nodes. Currently the\n                 // the only part of rustc that tracks MIR -> HIR is the `SourceScopeLocalData::lint_root`\n-                // field that tracks lint levels for MIR locations.  Normally the number of source scopes\n+                // field that tracks lint levels for MIR locations. Normally the number of source scopes\n                 // is limited to the set of nodes with lint annotations. The -Zmaximal-hir-to-mir-coverage\n                 // flag changes this behavior to maximize the number of source scopes, increasing the\n                 // granularity of the MIR->HIR mapping."}, {"sha": "fac4997fcbf6dc27b660319da5f07207dc0bc3de", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -60,7 +60,7 @@ impl<'mir, 'tcx> Search<'mir, 'tcx> {\n     /// Returns `true` if `func` refers to the function we are searching in.\n     fn is_recursive_call(&self, func: &Operand<'tcx>, args: &[Operand<'tcx>]) -> bool {\n         let Search { tcx, body, trait_substs, .. } = *self;\n-        // Resolving function type to a specific instance that is being called is expensive.  To\n+        // Resolving function type to a specific instance that is being called is expensive. To\n         // avoid the cost we check the number of arguments first, which is sufficient to reject\n         // most of calls as non-recursive.\n         if args.len() != body.arg_count {"}, {"sha": "4b5324e203aa3725aad358ad587e2eb714b366b1", "filename": "compiler/rustc_mir_dataflow/src/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Fimpls%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -750,7 +750,7 @@ where\n \n /// Calls `f` for each mutable borrow or raw reference in the program.\n ///\n-/// This DOES NOT call `f` for a shared borrow of a type with interior mutability.  That's okay for\n+/// This DOES NOT call `f` for a shared borrow of a type with interior mutability. That's okay for\n /// initializedness, because we cannot move from an `UnsafeCell` (outside of `core::cell`), but\n /// other analyses will likely need to check for `!Freeze`.\n fn for_each_mut_borrow<'tcx>("}, {"sha": "7d2146214c6dc2128040b12ab248e32272d1b016", "filename": "compiler/rustc_mir_transform/src/add_retag.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fadd_retag.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> MirPass<'tcx> for AddRetag {\n         // PART 3\n         // Add retag after assignments where data \"enters\" this function: the RHS is behind a deref and the LHS is not.\n         for block_data in basic_blocks {\n-            // We want to insert statements as we iterate.  To this end, we\n+            // We want to insert statements as we iterate. To this end, we\n             // iterate backwards using indices.\n             for i in (0..block_data.statements.len()).rev() {\n                 let (retag_kind, place) = match block_data.statements[i].kind {"}, {"sha": "42124f5a4808d0a3ff074da042b6db40791be5e1", "filename": "compiler/rustc_mir_transform/src/sroa.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsroa.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -215,7 +215,7 @@ struct ReplacementVisitor<'tcx, 'll> {\n     replacements: ReplacementMap<'tcx>,\n     /// This is used to check that we are not leaving references to replaced locals behind.\n     all_dead_locals: BitSet<Local>,\n-    /// Pre-computed list of all \"new\" locals for each \"old\" local.  This is used to expand storage\n+    /// Pre-computed list of all \"new\" locals for each \"old\" local. This is used to expand storage\n     /// and deinit statement and debuginfo.\n     fragments: IndexVec<Local, Vec<(&'tcx [PlaceElem<'tcx>], Local)>>,\n }"}, {"sha": "ffb23b50a160de4101fb021faff9b6af54166b4c", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -542,9 +542,9 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Expect next token to be edible or inedible token.  If edible,\n+    /// Expect next token to be edible or inedible token. If edible,\n     /// then consume it; if inedible, then return without consuming\n-    /// anything.  Signal a fatal error if next token is unexpected.\n+    /// anything. Signal a fatal error if next token is unexpected.\n     pub fn expect_one_of(\n         &mut self,\n         edible: &[TokenKind],"}, {"sha": "6afdcc37fe86ea9d15652bcd848aec739c6ad4b8", "filename": "compiler/rustc_passes/src/liveness.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -191,9 +191,9 @@ pub fn provide(providers: &mut Providers) {\n // Creating ir_maps\n //\n // This is the first pass and the one that drives the main\n-// computation.  It walks up and down the IR once.  On the way down,\n+// computation. It walks up and down the IR once. On the way down,\n // we count for each function the number of variables as well as\n-// liveness nodes.  A liveness node is basically an expression or\n+// liveness nodes. A liveness node is basically an expression or\n // capture clause that does something of interest: either it has\n // interesting control flow or it uses/defines a local variable.\n //\n@@ -203,11 +203,11 @@ pub fn provide(providers: &mut Providers) {\n // of live variables at each program point.\n //\n // Finally, we run back over the IR one last time and, using the\n-// computed liveness, check various safety conditions.  For example,\n+// computed liveness, check various safety conditions. For example,\n // there must be no live nodes at the definition site for a variable\n-// unless it has an initializer.  Similarly, each non-mutable local\n+// unless it has an initializer. Similarly, each non-mutable local\n // variable must not be assigned if there is some successor\n-// assignment.  And so forth.\n+// assignment. And so forth.\n \n struct CaptureInfo {\n     ln: LiveNode,\n@@ -417,7 +417,7 @@ impl<'tcx> Visitor<'tcx> for IrMaps<'tcx> {\n                 self.add_live_node_for_node(expr.hir_id, ExprNode(expr.span, expr.hir_id));\n \n                 // Make a live_node for each mentioned variable, with the span\n-                // being the location that the variable is used.  This results\n+                // being the location that the variable is used. This results\n                 // in better error messages than just pointing at the closure\n                 // construction site.\n                 let mut call_caps = Vec::new();\n@@ -792,7 +792,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         match stmt.kind {\n             hir::StmtKind::Local(ref local) => {\n                 // Note: we mark the variable as defined regardless of whether\n-                // there is an initializer.  Initially I had thought to only mark\n+                // there is an initializer. Initially I had thought to only mark\n                 // the live variable as defined if it was initialized, and then we\n                 // could check for uninit variables just by scanning what is live\n                 // at the start of the function. But that doesn't work so well for\n@@ -1169,24 +1169,24 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         //\n         // # Tracked places\n         //\n-        // A tracked place is a local variable/argument `x`.  In\n+        // A tracked place is a local variable/argument `x`. In\n         // these cases, the link_node where the write occurs is linked\n-        // to node id of `x`.  The `write_place()` routine generates\n-        // the contents of this node.  There are no subcomponents to\n+        // to node id of `x`. The `write_place()` routine generates\n+        // the contents of this node. There are no subcomponents to\n         // consider.\n         //\n         // # Non-tracked places\n         //\n-        // These are places like `x[5]` or `x.f`.  In that case, we\n+        // These are places like `x[5]` or `x.f`. In that case, we\n         // basically ignore the value which is written to but generate\n-        // reads for the components---`x` in these two examples.  The\n+        // reads for the components---`x` in these two examples. The\n         // components reads are generated by\n         // `propagate_through_place_components()` (this fn).\n         //\n         // # Illegal places\n         //\n         // It is still possible to observe assignments to non-places;\n-        // these errors are detected in the later pass borrowck.  We\n+        // these errors are detected in the later pass borrowck. We\n         // just ignore such cases and treat them as reads.\n \n         match expr.kind {\n@@ -1204,7 +1204,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             }\n \n             // We do not track other places, so just propagate through\n-            // to their subcomponents.  Also, it may happen that\n+            // to their subcomponents. Also, it may happen that\n             // non-places occur here, because those are detected in the\n             // later pass borrowck.\n             _ => succ,"}, {"sha": "34e1abb78b2d4fa33323c278cd85d36d24a70fce", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -147,7 +147,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         }\n \n         if !self.tcx.features().staged_api {\n-            // Propagate unstability.  This can happen even for non-staged-api crates in case\n+            // Propagate unstability. This can happen even for non-staged-api crates in case\n             // -Zforce-unstable-if-unmarked is set.\n             if let Some(stab) = self.parent_stab {\n                 if inherit_deprecation.yes() && stab.is_unstable() {"}, {"sha": "47b2fd8f8f47a4d31da672b7e76c5de3b69d5d2f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -490,8 +490,8 @@ impl<K: DepKind> DepGraph<K> {\n     /// This is used to remove cycles during type-checking const generic parameters.\n     ///\n     /// As usual in the query system, we consider the current state of the calling query\n-    /// only depends on the list of dependencies up to now.  As a consequence, the value\n-    /// that this query gives us can only depend on those dependencies too.  Therefore,\n+    /// only depends on the list of dependencies up to now. As a consequence, the value\n+    /// that this query gives us can only depend on those dependencies too. Therefore,\n     /// it is sound to use the current dependency set for the created node.\n     ///\n     /// During replay, the order of the nodes is relevant in the dependency graph.\n@@ -510,9 +510,9 @@ impl<K: DepKind> DepGraph<K> {\n         hash_result: Option<fn(&mut StableHashingContext<'_>, &R) -> Fingerprint>,\n     ) -> DepNodeIndex {\n         if let Some(data) = self.data.as_ref() {\n-            // The caller query has more dependencies than the node we are creating.  We may\n+            // The caller query has more dependencies than the node we are creating. We may\n             // encounter a case where this created node is marked as green, but the caller query is\n-            // subsequently marked as red or recomputed.  In this case, we will end up feeding a\n+            // subsequently marked as red or recomputed. In this case, we will end up feeding a\n             // value to an existing node.\n             //\n             // For sanity, we still check that the loaded stable hash and the new one match.\n@@ -980,7 +980,7 @@ rustc_index::newtype_index! {\n /// graph: they are only added.\n ///\n /// The nodes in it are identified by a `DepNodeIndex`. We avoid keeping the nodes\n-/// in memory.  This is important, because these graph structures are some of the\n+/// in memory. This is important, because these graph structures are some of the\n /// largest in the compiler.\n ///\n /// For this reason, we avoid storing `DepNode`s more than once as map"}, {"sha": "a81595b2420c041e9c8e535483c8fc3f5f601dfd", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1,14 +1,14 @@\n //! The data that we will serialize and deserialize.\n //!\n //! The dep-graph is serialized as a sequence of NodeInfo, with the dependencies\n-//! specified inline.  The total number of nodes and edges are stored as the last\n+//! specified inline. The total number of nodes and edges are stored as the last\n //! 16 bytes of the file, so we can find them easily at decoding time.\n //!\n //! The serialisation is performed on-demand when each node is emitted. Using this\n //! scheme, we do not need to keep the current graph in memory.\n //!\n //! The deserialization is performed manually, in order to convert from the stored\n-//! sequence of NodeInfos to the different arrays in SerializedDepGraph.  Since the\n+//! sequence of NodeInfos to the different arrays in SerializedDepGraph. Since the\n //! node and edge count are stored at the end of the file, all the arrays can be\n //! pre-allocated with the right length.\n "}, {"sha": "77d0d0314fc17de7a36de449436e484118bec350", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -116,7 +116,7 @@ where\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n-        // We may be overwriting another value.  This is all right, since the dep-graph\n+        // We may be overwriting another value. This is all right, since the dep-graph\n         // will check that the fingerprint matches.\n         lock.insert(key, (value.clone(), index));\n         value\n@@ -203,7 +203,7 @@ where\n         let mut lock = self.cache.get_shard_by_value(&key).lock();\n         #[cfg(not(parallel_compiler))]\n         let mut lock = self.cache.lock();\n-        // We may be overwriting another value.  This is all right, since the dep-graph\n+        // We may be overwriting another value. This is all right, since the dep-graph\n         // will check that the fingerprint matches.\n         lock.insert(key, value);\n         &value.0"}, {"sha": "d6491b8b0146619de3fb1ed2544b8b9309bb6846", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -668,7 +668,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     && let Some(partial_res) = self.r.partial_res_map.get(&ty.id)\n                     && let Some(Res::Def(DefKind::Trait | DefKind::TraitAlias, _)) = partial_res.full_res()\n                 {\n-                    // This path is actually a bare trait object.  In case of a bare `Fn`-trait\n+                    // This path is actually a bare trait object. In case of a bare `Fn`-trait\n                     // object with anonymous lifetimes, we need this rib to correctly place the\n                     // synthetic lifetimes.\n                     let span = ty.span.shrink_to_lo().to(path.span.shrink_to_lo());\n@@ -1046,7 +1046,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     // Probe the lifetime ribs to know how to behave.\n                     for rib in self.lifetime_ribs.iter().rev() {\n                         match rib.kind {\n-                            // We are inside a `PolyTraitRef`.  The lifetimes are\n+                            // We are inside a `PolyTraitRef`. The lifetimes are\n                             // to be intoduced in that (maybe implicit) `for<>` binder.\n                             LifetimeRibKind::Generics {\n                                 binder,\n@@ -1069,7 +1069,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                                 );\n                                 break;\n                             }\n-                            // We have nowhere to introduce generics.  Code is malformed,\n+                            // We have nowhere to introduce generics. Code is malformed,\n                             // so use regular lifetime resolution to avoid spurious errors.\n                             LifetimeRibKind::Item | LifetimeRibKind::Generics { .. } => {\n                                 visit::walk_generic_args(self, args);\n@@ -1775,7 +1775,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         break;\n                     }\n                     // `LifetimeRes::Error`, which would usually be used in the case of\n-                    // `ReportError`, is unsuitable here, as we don't emit an error yet.  Instead,\n+                    // `ReportError`, is unsuitable here, as we don't emit an error yet. Instead,\n                     // we simply resolve to an implicit lifetime, which will be checked later, at\n                     // which point a suitable error will be emitted.\n                     LifetimeRibKind::AnonymousReportError | LifetimeRibKind::Item => {\n@@ -3647,7 +3647,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         if let Some(qself) = qself {\n             if qself.position == 0 {\n                 // This is a case like `<T>::B`, where there is no\n-                // trait to resolve.  In that case, we leave the `B`\n+                // trait to resolve. In that case, we leave the `B`\n                 // segment to be resolved by type-check.\n                 return Ok(Some(PartialRes::with_unresolved_segments(\n                     Res::Def(DefKind::Mod, CRATE_DEF_ID.to_def_id()),\n@@ -3658,7 +3658,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // Make sure `A::B` in `<T as A::B>::C` is a trait item.\n             //\n             // Currently, `path` names the full item (`A::B::C`, in\n-            // our example).  so we extract the prefix of that that is\n+            // our example). so we extract the prefix of that that is\n             // the trait (the slice upto and including\n             // `qself.position`). And then we recursively resolve that,\n             // but with `qself` set to `None`."}, {"sha": "1f9d634017135ee0420e0eb5a3ccd99e6098cf34", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -715,7 +715,7 @@ impl OutputFilenames {\n pub fn host_triple() -> &'static str {\n     // Get the host triple out of the build environment. This ensures that our\n     // idea of the host triple is the same as for the set of libraries we've\n-    // actually built.  We can't just take LLVM's host triple because they\n+    // actually built. We can't just take LLVM's host triple because they\n     // normalize all ix86 architectures to i386.\n     //\n     // Instead of grabbing the host triple (for the current host), we grab (at\n@@ -1271,7 +1271,7 @@ impl RustcOptGroup {\n \n // The `opt` local module holds wrappers around the `getopts` API that\n // adds extra rustc-specific metadata to each option; such metadata\n-// is exposed by .  The public\n+// is exposed by . The public\n // functions below ending with `_u` are the functions that return\n // *unstable* options, i.e., options that are only enabled when the\n // user also passes the `-Z unstable-options` debugging flag."}, {"sha": "4ae9a3fae474b3c9a993b97f77cf765de06ed3a7", "filename": "compiler/rustc_session/src/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_session%2Fsrc%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fcstore.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -228,7 +228,7 @@ pub trait CrateStore: std::fmt::Debug {\n     fn def_path_hash(&self, def: DefId) -> DefPathHash;\n \n     // This information is safe to access, since it's hashed as part of the StableCrateId, which\n-    // incr.  comp. uses to identify a CrateNum.\n+    // incr. comp. uses to identify a CrateNum.\n     fn crate_name(&self, cnum: CrateNum) -> Symbol;\n     fn stable_crate_id(&self, cnum: CrateNum) -> StableCrateId;\n     fn stable_crate_id_to_crate_num(&self, stable_crate_id: StableCrateId) -> CrateNum;"}, {"sha": "b6a328908ce085834d74cb534ba1503486cca6cf", "filename": "compiler/rustc_session/src/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Ffilesearch.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -155,7 +155,7 @@ pub fn sysroot_candidates() -> SmallVec<[PathBuf; 2]> {\n /// This function checks if sysroot is found using env::args().next(), and if it\n /// is not found, finds sysroot from current rustc_driver dll.\n pub fn get_or_default_sysroot() -> Result<PathBuf, String> {\n-    // Follow symlinks.  If the resolved path is relative, make it absolute.\n+    // Follow symlinks. If the resolved path is relative, make it absolute.\n     fn canonicalize(path: PathBuf) -> PathBuf {\n         let path = fs::canonicalize(&path).unwrap_or(path);\n         // See comments on this target function, but the gist is that"}, {"sha": "cf45d6f1aa5c55c3c629731b287b5915aa39a3a7", "filename": "compiler/rustc_session/src/output.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_session%2Fsrc%2Foutput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Foutput.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -29,9 +29,9 @@ pub fn out_filename(\n     out_filename\n }\n \n-/// Make sure files are writeable.  Mac, FreeBSD, and Windows system linkers\n+/// Make sure files are writeable. Mac, FreeBSD, and Windows system linkers\n /// check this already -- however, the Linux linker will happily overwrite a\n-/// read-only file.  We should be consistent.\n+/// read-only file. We should be consistent.\n pub fn check_file_is_writeable(file: &Path, sess: &Session) {\n     if !is_writeable(file) {\n         sess.emit_fatal(FileIsNotWriteable { file });"}, {"sha": "8d92954ec94972ee875ab2ed460c68f280f49ee9", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -197,7 +197,7 @@ pub struct Session {\n     pub ctfe_backtrace: Lock<CtfeBacktrace>,\n \n     /// This tracks where `-Zunleash-the-miri-inside-of-you` was used to get around a\n-    /// const check, optionally with the relevant feature gate.  We use this to\n+    /// const check, optionally with the relevant feature gate. We use this to\n     /// warn about unleashing, but with a single diagnostic instead of dozens that\n     /// drown everything else in noise.\n     miri_unleashed_features: Lock<Vec<(Span, Option<Symbol>)>>,"}, {"sha": "dee823eefde689b013e18644f0572b3bc9363678", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -338,7 +338,7 @@ pub struct HygieneData {\n     /// first and then resolved later), so we use an `Option` here.\n     local_expn_data: IndexVec<LocalExpnId, Option<ExpnData>>,\n     local_expn_hashes: IndexVec<LocalExpnId, ExpnHash>,\n-    /// Data and hash information from external crates.  We may eventually want to remove these\n+    /// Data and hash information from external crates. We may eventually want to remove these\n     /// maps, and fetch the information directly from the other crate's metadata like DefIds do.\n     foreign_expn_data: FxHashMap<ExpnId, ExpnData>,\n     foreign_expn_hashes: FxHashMap<ExpnId, ExpnHash>,"}, {"sha": "b69ade7e4aa08eee89426153ea3d6b427e62af92", "filename": "compiler/rustc_target/src/spec/aarch64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Faarch64_apple_darwin.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -12,7 +12,7 @@ pub fn target() -> Target {\n \n     Target {\n         // Clang automatically chooses a more specific target based on\n-        // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work\n+        // MACOSX_DEPLOYMENT_TARGET. To enable cross-language LTO to work\n         // correctly, we do too.\n         llvm_target: macos_llvm_target(arch).into(),\n         pointer_width: 64,"}, {"sha": "b5103d15db695d95de98d7ebc8b4936f832f3446", "filename": "compiler/rustc_target/src/spec/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fi686_apple_darwin.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -12,7 +12,7 @@ pub fn target() -> Target {\n \n     Target {\n         // Clang automatically chooses a more specific target based on\n-        // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work\n+        // MACOSX_DEPLOYMENT_TARGET. To enable cross-language LTO to work\n         // correctly, we do too.\n         //\n         // While ld64 doesn't understand i686, LLVM does."}, {"sha": "e63e789752bc74eed91ae7601bc287bfe8e0d024", "filename": "compiler/rustc_target/src/spec/illumos_base.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fillumos_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fillumos_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fillumos_base.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -5,8 +5,8 @@ pub fn opts() -> TargetOptions {\n         LinkerFlavor::Unix(Cc::Yes),\n         &[\n             // The illumos libc contains a stack unwinding implementation, as\n-            // does libgcc_s.  The latter implementation includes several\n-            // additional symbols that are not always in base libc.  To force\n+            // does libgcc_s. The latter implementation includes several\n+            // additional symbols that are not always in base libc. To force\n             // the consistent use of just one unwinder, we ensure libc appears\n             // after libgcc_s in the NEEDED list for the resultant binary by\n             // ignoring any attempts to add it as a dynamic dependency until the\n@@ -17,7 +17,7 @@ pub fn opts() -> TargetOptions {\n             \"-lc\",\n             // LLVM will insert calls to the stack protector functions\n             // \"__stack_chk_fail\" and \"__stack_chk_guard\" into code in native\n-            // object files.  Some platforms include these symbols directly in\n+            // object files. Some platforms include these symbols directly in\n             // libc, but at least historically these have been provided in\n             // libssp.so on illumos and Solaris systems.\n             \"-lssp\",\n@@ -40,16 +40,16 @@ pub fn opts() -> TargetOptions {\n         // cleanup handlers (in C, this would be something along the lines of:\n         // void register_callback(void (*fn)(void *), void *arg);\n         // (see src/libstd/sys/unix/fast_thread_local.rs) that is currently\n-        // missing in illumos.  For now at least, we must fallback to using\n+        // missing in illumos. For now at least, we must fallback to using\n         // pthread_{get,set}specific.\n         //has_thread_local: true,\n \n         // FIXME: Currently, rust is invoking cc to link, which ends up\n-        // causing these to get included twice.  We should eventually transition\n+        // causing these to get included twice. We should eventually transition\n         // to having rustc invoke ld directly, in which case these will need to\n         // be uncommented.\n         //\n-        // We want XPG6 behavior from libc and libm.  See standards(5)\n+        // We want XPG6 behavior from libc and libm. See standards(5)\n         //pre_link_objects_exe: vec![\n         //    \"/usr/lib/amd64/values-Xc.o\".into(),\n         //    \"/usr/lib/amd64/values-xpg6.o\".into(),"}, {"sha": "a094c2c545269bede5d2eb6764e3eb2df611c51b", "filename": "compiler/rustc_target/src/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -2622,7 +2622,7 @@ impl Target {\n     /// Search for a JSON file specifying the given target triple.\n     ///\n     /// If none is found in `$RUST_TARGET_PATH`, look for a file called `target.json` inside the\n-    /// sysroot under the target-triple's `rustlib` directory.  Note that it could also just be a\n+    /// sysroot under the target-triple's `rustlib` directory. Note that it could also just be a\n     /// bare filename already, so also check for that. If one of the hardcoded targets we know\n     /// about, just return it directly.\n     ///"}, {"sha": "4d2bc98ab7831fff14840eaf35281f25d1e6143c", "filename": "compiler/rustc_target/src/spec/sparcv9_sun_solaris.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsparcv9_sun_solaris.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsparcv9_sun_solaris.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fsparcv9_sun_solaris.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -15,7 +15,7 @@ pub fn target() -> Target {\n         pointer_width: 64,\n         data_layout: \"E-m:e-i64:64-n32:64-S128\".into(),\n         // Use \"sparc64\" instead of \"sparcv9\" here, since the former is already\n-        // used widely in the source base.  If we ever needed ABI\n+        // used widely in the source base. If we ever needed ABI\n         // differentiation from the sparc64, we could, but that would probably\n         // just be confusing.\n         arch: \"sparc64\".into(),"}, {"sha": "e90bda9c9a8718683ddc2cec4c0ed46fed7626bf", "filename": "compiler/rustc_target/src/spec/x86_64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fspec%2Fx86_64_apple_darwin.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -14,7 +14,7 @@ pub fn target() -> Target {\n \n     Target {\n         // Clang automatically chooses a more specific target based on\n-        // MACOSX_DEPLOYMENT_TARGET.  To enable cross-language LTO to work\n+        // MACOSX_DEPLOYMENT_TARGET. To enable cross-language LTO to work\n         // correctly, we do too.\n         llvm_target: macos_llvm_target(arch).into(),\n         pointer_width: 64,"}, {"sha": "5ee2514652cbcbe1e4b99f191780132c88d54199", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -2193,7 +2193,7 @@ impl<'tcx> InferCtxtPrivExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 // This is kind of a hack: it frequently happens that some earlier\n                 // error prevents types from being fully inferred, and then we get\n                 // a bunch of uninteresting errors saying something like \"<generic\n-                // #0> doesn't implement Sized\".  It may even be true that we\n+                // #0> doesn't implement Sized\". It may even be true that we\n                 // could just skip over all checks where the self-ty is an\n                 // inference variable, but I was afraid that there might be an\n                 // inference variable created, registered as an obligation, and"}, {"sha": "cabf51e01da345124e306a3d41848fb0117ace2f", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -2259,7 +2259,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // generator interior are not generally known, so we\n             // want to erase them when comparing (and anyway,\n             // `Send` and other bounds are generally unaffected by\n-            // the choice of region).  When erasing regions, we\n+            // the choice of region). When erasing regions, we\n             // also have to erase late-bound regions. This is\n             // because the types that appear in the generator\n             // interior generally contain \"bound regions\" to\n@@ -2275,7 +2275,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n         };\n \n         // Get the typeck results from the infcx if the generator is the function we are currently\n-        // type-checking; otherwise, get them by performing a query.  This is needed to avoid\n+        // type-checking; otherwise, get them by performing a query. This is needed to avoid\n         // cycles. If we can't use resolved types because the generator comes from another crate,\n         // we still provide a targeted error but without all the relevant spans.\n         let generator_data = match &self.typeck_results {"}, {"sha": "9a0e3d298eda1b708cefa699c82e24fd89361e9a", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -809,7 +809,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeVisitable<'tcx>>(\n                     // SomeTrait` is in fact a supertrait of the\n                     // current trait. In that case, this type is\n                     // legal, because the type `X` will be specified\n-                    // in the object type.  Note that we can just use\n+                    // in the object type. Note that we can just use\n                     // direct equality here because all of these types\n                     // are part of the formal parameter listing, and\n                     // hence there should be no inference variables."}, {"sha": "eecd4cf03beb0d7117023039e57d99b6538355be", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -148,7 +148,7 @@ impl<'tcx> ProjectionCandidateSet<'tcx> {\n                 }\n \n                 // Prefer where-clauses. As in select, if there are multiple\n-                // candidates, we prefer where-clause candidates over impls.  This\n+                // candidates, we prefer where-clause candidates over impls. This\n                 // may seem a bit surprising, since impls are the source of\n                 // \"truth\" in some sense, but in fact some of the impls that SEEM\n                 // applicable are not, because of nested obligations. Where\n@@ -1034,7 +1034,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n         }\n         Err(ProjectionCacheEntry::InProgress) => {\n             // Under lazy normalization, this can arise when\n-            // bootstrapping.  That is, imagine an environment with a\n+            // bootstrapping. That is, imagine an environment with a\n             // where-clause like `A::B == u32`. Now, if we are asked\n             // to normalize `A::B`, we will want to check the\n             // where-clauses in scope. So we will try to unify `A::B`"}, {"sha": "98bf1cd7a7ccdd19c79ccbae328a2a5d948653d5", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -398,7 +398,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n                 ty::Param(..) | ty::Alias(ty::Projection, ..) => {\n                     // In these cases, we don't know what the actual\n-                    // type is.  Therefore, we cannot break it down\n+                    // type is. Therefore, we cannot break it down\n                     // into its constituent types. So we don't\n                     // consider the `..` impl but instead just add no\n                     // candidates: this means that typeck will only"}, {"sha": "f41d3c460acd9903afc3fa1ed1afa7d7f2efe36d", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -2,7 +2,7 @@\n //!\n //! Confirmation unifies the output type parameters of the trait\n //! with the values found in the obligation, possibly yielding a\n-//! type error.  See the [rustc dev guide] for more details.\n+//! type error. See the [rustc dev guide] for more details.\n //!\n //! [rustc dev guide]:\n //! https://rustc-dev-guide.rust-lang.org/traits/resolution.html#confirmation\n@@ -357,8 +357,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nested,\n             );\n \n-            // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n-            // predicate as usual.  It won't have any effect since auto traits are coinductive.\n+            // Adds the predicates from the trait. Note that this contains a `Self: Trait`\n+            // predicate as usual. It won't have any effect since auto traits are coinductive.\n             obligations.extend(trait_obligations);\n \n             debug!(?obligations, \"vtable_auto_impl\");"}, {"sha": "b217b5c32885b119991447973c04e60d124ff604", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -430,7 +430,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         //     impl<T:Clone> Vec<T> { fn push_clone(...) { ... } }\n         //\n         // and we were to see some code `foo.push_clone()` where `boo`\n-        // is a `Vec<Bar>` and `Bar` does not implement `Clone`.  If\n+        // is a `Vec<Bar>` and `Bar` does not implement `Clone`. If\n         // we were to winnow, we'd wind up with zero candidates.\n         // Instead, we select the right impl now but report \"`Bar` does\n         // not implement `Clone`\".\n@@ -2324,7 +2324,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     // Matching\n     //\n     // Matching is a common path used for both evaluation and\n-    // confirmation.  It basically unifies types that appear in impls\n+    // confirmation. It basically unifies types that appear in impls\n     // and traits. This does affect the surrounding environment;\n     // therefore, when used during evaluation, match routines must be\n     // run inside of a `probe()` so that their side-effects are\n@@ -2644,7 +2644,7 @@ impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n /// In Issue #60010, we found a bug in rustc where it would cache\n /// these intermediate results. This was fixed in #60444 by disabling\n /// *all* caching for things involved in a cycle -- in our example,\n-/// that would mean we don't cache that `Bar<T>: Send`.  But this led\n+/// that would mean we don't cache that `Bar<T>: Send`. But this led\n /// to large slowdowns.\n ///\n /// Specifically, imagine this scenario, where proving `Baz<T>: Send`\n@@ -2670,7 +2670,7 @@ impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n /// a result at `reached_depth`, so it marks the *current* solution as\n /// provisional as well. If an error is encountered, we toss out any\n /// provisional results added from the subtree that encountered the\n-/// error.  When we pop the node at `reached_depth` from the stack, we\n+/// error. When we pop the node at `reached_depth` from the stack, we\n /// can commit all the things that remain in the provisional cache.\n struct ProvisionalEvaluationCache<'tcx> {\n     /// next \"depth first number\" to issue -- just a counter\n@@ -2781,7 +2781,7 @@ impl<'tcx> ProvisionalEvaluationCache<'tcx> {\n     }\n \n     /// Invoked when the node with dfn `dfn` does not get a successful\n-    /// result.  This will clear out any provisional cache entries\n+    /// result. This will clear out any provisional cache entries\n     /// that were added since `dfn` was created. This is because the\n     /// provisional entries are things which must assume that the\n     /// things on the stack at the time of their creation succeeded --"}, {"sha": "03cd4ea27e131b64b33b9e46eeee2c4ec64ddfe5", "filename": "compiler/rustc_trait_selection/src/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -417,7 +417,7 @@ pub(crate) fn assoc_def(\n     } else {\n         // This is saying that neither the trait nor\n         // the impl contain a definition for this\n-        // associated type.  Normally this situation\n+        // associated type. Normally this situation\n         // could only arise through a compiler bug --\n         // if the user wrote a bad item name, it\n         // should have failed in astconv."}, {"sha": "e6f3dd17d2189c04a03ebdbe9958e847b5b907b0", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -76,7 +76,7 @@ pub fn obligations<'tcx>(\n }\n \n /// Returns the obligations that make this trait reference\n-/// well-formed.  For example, if there is a trait `Set` defined like\n+/// well-formed. For example, if there is a trait `Set` defined like\n /// `trait Set<K:Eq>`, then the trait reference `Foo: Set<Bar>` is WF\n /// if `Bar: Eq`.\n pub fn trait_obligations<'tcx>("}, {"sha": "c0da8a8169e5bbde54cf52783300c2f5cd50a9f4", "filename": "compiler/rustc_traits/src/codegen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fcodegen.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -1,5 +1,5 @@\n // This file contains various trait resolution methods used by codegen.\n-// They all assume regions can be erased and monomorphic types.  It\n+// They all assume regions can be erased and monomorphic types. It\n // seems likely that they should eventually be merged into more\n // general routines.\n "}, {"sha": "5f29588ae4d2602b4e36c868c540ada95d0b5548", "filename": "compiler/rustc_type_ir/src/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a28fb42a8b8f1f67fe854c2206148171e434d73/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Fsty.rs?ref=6a28fb42a8b8f1f67fe854c2206148171e434d73", "patch": "@@ -807,7 +807,7 @@ where\n ///\n /// Note that inference variables and bound regions are not included\n /// in this diagram. In the case of inference variables, they should\n-/// be inferred to some other region from the diagram.  In the case of\n+/// be inferred to some other region from the diagram. In the case of\n /// bound regions, they are excluded because they don't make sense to\n /// include -- the diagram indicates the relationship between free\n /// regions."}]}