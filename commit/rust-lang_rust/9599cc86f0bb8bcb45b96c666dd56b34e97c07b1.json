{"sha": "9599cc86f0bb8bcb45b96c666dd56b34e97c07b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1OTljYzg2ZjBiYjhiY2I0NWI5NmM2NjZkZDU2YjM0ZTk3YzA3YjE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-08T02:03:13Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-08T03:28:58Z"}, "message": "implement BaseIter for LinearMap", "tree": {"sha": "004e4bcfc0be40f9d10bc04be1a8422e66dd9679", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/004e4bcfc0be40f9d10bc04be1a8422e66dd9679"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1", "html_url": "https://github.com/rust-lang/rust/commit/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fe841f3e56291f2b1521fb124fcf9277b931c53f", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe841f3e56291f2b1521fb124fcf9277b931c53f", "html_url": "https://github.com/rust-lang/rust/commit/fe841f3e56291f2b1521fb124fcf9277b931c53f"}], "stats": {"total": 60, "additions": 32, "deletions": 28}, "files": [{"sha": "af86911426fdbdbb02fed40219eb4b1ebd91a9a1", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=9599cc86f0bb8bcb45b96c666dd56b34e97c07b1", "patch": "@@ -495,7 +495,7 @@ pub fn try_parse_sources(filename: &Path,\n     let c = io::read_whole_file_str(filename);\n     match json::from_str(c.get()) {\n         Ok(json::Object(j)) => {\n-            for j.each |k, v| {\n+            for j.each |&(k, v)| {\n                 sources.insert(copy *k, parse_source(*k, v));\n                 debug!(\"source: %s\", *k);\n             }"}, {"sha": "a69cf4611bb7f83441aaa25cb7e233eafd7d4187", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=9599cc86f0bb8bcb45b96c666dd56b34e97c07b1", "patch": "@@ -235,6 +235,23 @@ pub mod linear {\n         }\n     }\n \n+    impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: BaseIter<(&K, &V)> {\n+        /// Visit all key-value pairs\n+        pure fn each(&self, blk: fn(&(&self/K, &self/V)) -> bool) {\n+            for uint::range(0, self.buckets.len()) |i| {\n+                let mut broke = false;\n+                do self.buckets[i].map |bucket| {\n+                    if !blk(&(&bucket.key, &bucket.value)) {\n+                        broke = true; // FIXME(#3064) just write \"break;\"\n+                    }\n+                };\n+                if broke { break; }\n+            }\n+        }\n+        pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    }\n+\n+\n     impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: Container {\n         /// Return the number of elements in the map\n         pure fn len(&self) -> uint { self.size }\n@@ -264,12 +281,12 @@ pub mod linear {\n \n         /// Visit all keys\n         pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n-            self.each(|k, _| blk(k))\n+            self.each(|&(k, _)| blk(k))\n         }\n \n         /// Visit all values\n         pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n-            self.each(|_, v| blk(v))\n+            self.each(|&(_, v)| blk(v))\n         }\n \n         /// Return the value corresponding to the key in the map\n@@ -322,19 +339,6 @@ pub mod linear {\n             linear_map_with_capacity(INITIAL_CAPACITY)\n         }\n \n-        /// Visit all key-value pairs\n-        pure fn each(&self, blk: fn(k: &K, v: &V) -> bool) {\n-            for self.buckets.each |slot| {\n-                let mut broke = false;\n-                do slot.iter |bucket| {\n-                    if !blk(&bucket.key, &bucket.value) {\n-                        broke = true; // FIXME(#3064) just write \"break;\"\n-                    }\n-                }\n-                if broke { break; }\n-            }\n-        }\n-\n         fn pop(&mut self, k: &K) -> Option<V> {\n             let hash = k.hash_keyed(self.k0, self.k1) as uint;\n             self.pop_internal(hash, k)\n@@ -388,7 +392,7 @@ pub mod linear {\n         pure fn eq(&self, other: &LinearMap<K, V>) -> bool {\n             if self.len() != other.len() { return false; }\n \n-            for self.each |key, value| {\n+            for self.each |&(key, value)| {\n                 match other.find(key) {\n                     None => return false,\n                     Some(v) => if value != v { return false },\n@@ -603,7 +607,7 @@ mod test_map {\n             assert m.insert(i, i*2);\n         }\n         let mut observed = 0;\n-        for m.each |k, v| {\n+        for m.each |&(k, v)| {\n             assert *v == *k * 2;\n             observed |= (1 << *k);\n         }"}, {"sha": "d5c91ea51478342d91fcf38828a72816fe016789", "filename": "src/libstd/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=9599cc86f0bb8bcb45b96c666dd56b34e97c07b1", "patch": "@@ -302,7 +302,7 @@ pub impl<S: serialize::Encoder> Json: serialize::Encodable<S> {\n             Object(ref v) => {\n                 do s.emit_rec || {\n                     let mut idx = 0;\n-                    for v.each |key, value| {\n+                    for v.each |&(key, value)| {\n                         do s.emit_field(*key, idx) {\n                             value.encode(s);\n                         }\n@@ -936,7 +936,7 @@ impl Json : Eq {\n                     &Object(ref d1) => {\n                         if d0.len() == d1.len() {\n                             let mut equal = true;\n-                            for d0.each |k, v0| {\n+                            for d0.each |&(k, v0)| {\n                                 match d1.find(k) {\n                                     Some(v1) if v0 == v1 => { },\n                                     _ => { equal = false; break }\n@@ -1000,12 +1000,12 @@ impl Json : Ord {\n                             let mut d1_flat = ~[];\n \n                             // FIXME #4430: this is horribly inefficient...\n-                            for d0.each |k, v| {\n+                            for d0.each |&(k, v)| {\n                                  d0_flat.push((@copy *k, @copy *v));\n                             }\n                             d0_flat.qsort();\n \n-                            for d1.each |k, v| {\n+                            for d1.each |&(k, v)| {\n                                 d1_flat.push((@copy *k, @copy *v));\n                             }\n                             d1_flat.qsort();\n@@ -1146,7 +1146,7 @@ impl <A: ToJson> ~[A]: ToJson {\n impl <A: ToJson Copy> LinearMap<~str, A>: ToJson {\n     fn to_json() -> Json {\n         let mut d = LinearMap::new();\n-        for self.each() |key, value| {\n+        for self.each |&(key, value)| {\n             d.insert(copy *key, value.to_json());\n         }\n         Object(~d)"}, {"sha": "1da3a64251405ac32eef42dc3f9de9d96a7d89c9", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=9599cc86f0bb8bcb45b96c666dd56b34e97c07b1", "patch": "@@ -219,10 +219,10 @@ pub fn encode_form_urlencoded(m: &LinearMap<~str, ~[~str]>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n-    for m.each |key, values| {\n+    for m.each |&(key, values)| {\n         let key = encode_plus(*key);\n \n-        for (*values).each |value| {\n+        for values.each |value| {\n             if first {\n                 first = false;\n             } else {"}, {"sha": "593d26d0124042607e8c7207de6f89d6a6cc9a41", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9599cc86f0bb8bcb45b96c666dd56b34e97c07b1/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=9599cc86f0bb8bcb45b96c666dd56b34e97c07b1", "patch": "@@ -142,7 +142,7 @@ type WorkMap = LinearMap<WorkKey, ~str>;\n pub impl<S: Encoder> WorkMap: Encodable<S> {\n     fn encode(&self, s: &S) {\n         let d = dvec::DVec();\n-        for self.each |k, v| {\n+        for self.each |&(k, v)| {\n             d.push((copy *k, copy *v))\n         }\n         let mut v = d.get();\n@@ -155,7 +155,7 @@ pub impl<D: Decoder> WorkMap: Decodable<D> {\n     static fn decode(&self, d: &D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n         let mut w = LinearMap::new();\n-        for v.each |&(k,v)| {\n+        for v.each |&(k, v)| {\n             w.insert(copy k, copy v);\n         }\n         w\n@@ -312,7 +312,7 @@ impl @Mut<Prep> : TPrep {\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n-        for map.each |k,v| {\n+        for map.each |&(k, v)| {\n             if ! self.is_fresh(cat, k.kind, k.name, *v) {\n                 return false;\n             }"}]}