{"sha": "72ac3ebf6858bf4bc19db3916f9835a3a1566a50", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyYWMzZWJmNjg1OGJmNGJjMTlkYjM5MTZmOTgzNWEzYTE1NjZhNTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-04-05T15:49:19Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-04-05T18:18:16Z"}, "message": "Rollup merge of #49497 - scalexm:hrtb, r=nikomatsakis\n\nChalkify - Tweak `Clause` definition and HRTBs\n\nr? @nikomatsakis", "tree": {"sha": "79cd8f12211f08ed633539f88783034f183bf9ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79cd8f12211f08ed633539f88783034f183bf9ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/72ac3ebf6858bf4bc19db3916f9835a3a1566a50", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/72ac3ebf6858bf4bc19db3916f9835a3a1566a50", "html_url": "https://github.com/rust-lang/rust/commit/72ac3ebf6858bf4bc19db3916f9835a3a1566a50", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/72ac3ebf6858bf4bc19db3916f9835a3a1566a50/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46492ffabd7194bb134035cadcd66d47f1b97db8", "url": "https://api.github.com/repos/rust-lang/rust/commits/46492ffabd7194bb134035cadcd66d47f1b97db8", "html_url": "https://github.com/rust-lang/rust/commit/46492ffabd7194bb134035cadcd66d47f1b97db8"}, {"sha": "1074a22905c6c96f2b7013073510d5f57a555436", "url": "https://api.github.com/repos/rust-lang/rust/commits/1074a22905c6c96f2b7013073510d5f57a555436", "html_url": "https://github.com/rust-lang/rust/commit/1074a22905c6c96f2b7013073510d5f57a555436"}], "stats": {"total": 141, "additions": 88, "deletions": 53}, "files": [{"sha": "da1a2592f14db64a88b9c5b7f7ac44e64222a86a", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/72ac3ebf6858bf4bc19db3916f9835a3a1566a50/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ac3ebf6858bf4bc19db3916f9835a3a1566a50/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=72ac3ebf6858bf4bc19db3916f9835a3a1566a50", "patch": "@@ -1392,6 +1392,12 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Goal<'tcx> {\n     }\n }\n \n+impl_stable_hash_for!(\n+    impl<'tcx> for struct traits::ProgramClause<'tcx> {\n+        goal, hypotheses\n+    }\n+);\n+\n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -1400,11 +1406,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for traits::Clause<'tcx> {\n \n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match self {\n-            Implies(hypotheses, goal) => {\n-                hypotheses.hash_stable(hcx, hasher);\n-                goal.hash_stable(hcx, hasher);\n-            }\n-            DomainGoal(domain_goal) => domain_goal.hash_stable(hcx, hasher),\n+            Implies(clause) => clause.hash_stable(hcx, hasher),\n             ForAll(clause) => clause.hash_stable(hcx, hasher),\n         }\n     }"}, {"sha": "b30fb2ce016dff62ac902dc6a3ca408d165462cc", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/72ac3ebf6858bf4bc19db3916f9835a3a1566a50/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ac3ebf6858bf4bc19db3916f9835a3a1566a50/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=72ac3ebf6858bf4bc19db3916f9835a3a1566a50", "patch": "@@ -272,6 +272,8 @@ pub enum DomainGoal<'tcx> {\n     TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n }\n \n+pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n+\n #[derive(Copy, Clone, PartialEq, Eq, Hash, Debug)]\n pub enum QuantifierKind {\n     Universal,\n@@ -294,20 +296,39 @@ impl<'tcx> From<DomainGoal<'tcx>> for Goal<'tcx> {\n     }\n }\n \n-impl<'tcx> From<DomainGoal<'tcx>> for Clause<'tcx> {\n-    fn from(domain_goal: DomainGoal<'tcx>) -> Self {\n-        Clause::DomainGoal(domain_goal)\n+impl<'tcx> From<PolyDomainGoal<'tcx>> for Goal<'tcx> {\n+    fn from(domain_goal: PolyDomainGoal<'tcx>) -> Self {\n+        match domain_goal.no_late_bound_regions() {\n+            Some(p) => p.into(),\n+            None => Goal::Quantified(\n+                QuantifierKind::Universal,\n+                Box::new(domain_goal.map_bound(|p| p.into()))\n+            ),\n+        }\n     }\n }\n \n /// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n /// Harrop Formulas\".\n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum Clause<'tcx> {\n-    // FIXME: again, use interned refs instead of `Box`\n-    Implies(Vec<Goal<'tcx>>, DomainGoal<'tcx>),\n-    DomainGoal(DomainGoal<'tcx>),\n-    ForAll(Box<ty::Binder<Clause<'tcx>>>),\n+    Implies(ProgramClause<'tcx>),\n+    ForAll(ty::Binder<ProgramClause<'tcx>>),\n+}\n+\n+/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n+/// that the domain goal `D` is true if `G1...Gn` are provable. This\n+/// is equivalent to the implication `G1..Gn => D`; we usually write\n+/// it with the reverse implication operator `:-` to emphasize the way\n+/// that programs are actually solved (via backchaining, which starts\n+/// with the goal to solve and proceeds from there).\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub struct ProgramClause<'tcx> {\n+    /// This goal will be considered true...\n+    pub goal: DomainGoal<'tcx>,\n+\n+    /// ...if we can prove these hypotheses (there may be no hypotheses at all):\n+    pub hypotheses: Vec<Goal<'tcx>>,\n }\n \n pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;"}, {"sha": "865a9a34aaa25614fa50021f004e7f21f0d4a191", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/72ac3ebf6858bf4bc19db3916f9835a3a1566a50/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ac3ebf6858bf4bc19db3916f9835a3a1566a50/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=72ac3ebf6858bf4bc19db3916f9835a3a1566a50", "patch": "@@ -493,25 +493,29 @@ impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n     }\n }\n \n+impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        let traits::ProgramClause { goal, hypotheses } = self;\n+        write!(fmt, \"{}\", goal)?;\n+        if !hypotheses.is_empty() {\n+            write!(fmt, \" :- \")?;\n+            for (index, condition) in hypotheses.iter().enumerate() {\n+                if index > 0 {\n+                    write!(fmt, \", \")?;\n+                }\n+                write!(fmt, \"{}\", condition)?;\n+            }\n+        }\n+        write!(fmt, \".\")\n+    }\n+}\n+\n impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         use traits::Clause::*;\n \n         match self {\n-            Implies(hypotheses, goal) => {\n-                write!(fmt, \"{}\", goal)?;\n-                if !hypotheses.is_empty() {\n-                    write!(fmt, \" :- \")?;\n-                    for (index, condition) in hypotheses.iter().enumerate() {\n-                        if index > 0 {\n-                            write!(fmt, \", \")?;\n-                        }\n-                        write!(fmt, \"{}\", condition)?;\n-                    }\n-                }\n-                write!(fmt, \".\")\n-            }\n-            DomainGoal(domain_goal) => write!(fmt, \"{}.\", domain_goal),\n+            Implies(clause) => write!(fmt, \"{}\", clause),\n             ForAll(clause) => {\n                 // FIXME: appropriate binder names\n                 write!(fmt, \"forall<> {{ {} }}\", clause.skip_binder())\n@@ -553,10 +557,16 @@ EnumTypeFoldableImpl! {\n     }\n }\n \n+BraceStructTypeFoldableImpl! {\n+    impl<'tcx> TypeFoldable<'tcx> for traits::ProgramClause<'tcx> {\n+        goal,\n+        hypotheses\n+    }\n+}\n+\n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for traits::Clause<'tcx> {\n-        (traits::Clause::Implies)(hypotheses, goal),\n-        (traits::Clause::DomainGoal)(domain_goal),\n+        (traits::Clause::Implies)(clause),\n         (traits::Clause::ForAll)(clause),\n     }\n }"}, {"sha": "153b2e730337dadd3b1519e5ad58521e4e1e4a0b", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/72ac3ebf6858bf4bc19db3916f9835a3a1566a50/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/72ac3ebf6858bf4bc19db3916f9835a3a1566a50/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=72ac3ebf6858bf4bc19db3916f9835a3a1566a50", "patch": "@@ -13,7 +13,7 @@ use rustc::hir::def_id::DefId;\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::ty::{self, TyCtxt};\n use rustc::ty::subst::Substs;\n-use rustc::traits::{QuantifierKind, Goal, DomainGoal, Clause, WhereClauseAtom};\n+use rustc::traits::{WhereClauseAtom, PolyDomainGoal, DomainGoal, ProgramClause, Clause};\n use syntax::ast;\n use rustc_data_structures::sync::Lrc;\n \n@@ -61,36 +61,27 @@ impl<'tcx> Lower<DomainGoal<'tcx>> for ty::TypeOutlivesPredicate<'tcx> {\n /// `ty::Binder` is used for wrapping a rustc construction possibly containing generic\n /// lifetimes, e.g. `for<'a> T: Fn(&'a i32)`. Instead of representing higher-ranked things\n /// in that leaf-form (i.e. `Holds(Implemented(Binder<TraitPredicate>))` in the previous\n-/// example), we model them with quantified goals, e.g. as for the previous example:\n+/// example), we model them with quantified domain goals, e.g. as for the previous example:\n /// `forall<'a> { T: Fn(&'a i32) }` which corresponds to something like\n /// `Binder<Holds(Implemented(TraitPredicate))>`.\n-///\n-/// Also, if `self` does not contain generic lifetimes, we can safely drop the binder and we\n-/// can directly lower to a leaf goal instead of a quantified goal.\n-impl<'tcx, T> Lower<Goal<'tcx>> for ty::Binder<T>\n-    where T: Lower<DomainGoal<'tcx>> + ty::fold::TypeFoldable<'tcx> + Copy\n+impl<'tcx, T> Lower<PolyDomainGoal<'tcx>> for ty::Binder<T>\n+    where T: Lower<DomainGoal<'tcx>> + ty::fold::TypeFoldable<'tcx>\n {\n-    fn lower(&self) -> Goal<'tcx> {\n-        match self.no_late_bound_regions() {\n-            Some(p) => p.lower().into(),\n-            None => Goal::Quantified(\n-                QuantifierKind::Universal,\n-                Box::new(self.map_bound(|p| p.lower().into()))\n-            ),\n-        }\n+    fn lower(&self) -> PolyDomainGoal<'tcx> {\n+        self.map_bound_ref(|p| p.lower())\n     }\n }\n \n-impl<'tcx> Lower<Goal<'tcx>> for ty::Predicate<'tcx> {\n-    fn lower(&self) -> Goal<'tcx> {\n+impl<'tcx> Lower<PolyDomainGoal<'tcx>> for ty::Predicate<'tcx> {\n+    fn lower(&self) -> PolyDomainGoal<'tcx> {\n         use rustc::ty::Predicate::*;\n \n         match self {\n             Trait(predicate) => predicate.lower(),\n             RegionOutlives(predicate) => predicate.lower(),\n             TypeOutlives(predicate) => predicate.lower(),\n             Projection(predicate) => predicate.lower(),\n-            WellFormed(ty) => DomainGoal::WellFormedTy(*ty).into(),\n+            WellFormed(ty) => ty::Binder::dummy(DomainGoal::WellFormedTy(*ty)),\n             ObjectSafe(..) |\n             ClosureKind(..) |\n             Subtype(..) |\n@@ -134,13 +125,16 @@ fn program_clauses_for_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefI\n         }\n     };\n     // `FromEnv(Self: Trait<P1..Pn>)`\n-    let from_env = Goal::DomainGoal(DomainGoal::FromEnv(trait_pred.lower()));\n+    let from_env = DomainGoal::FromEnv(trait_pred.lower()).into();\n     // `Implemented(Self: Trait<P1..Pn>)`\n     let impl_trait = DomainGoal::Holds(WhereClauseAtom::Implemented(trait_pred));\n \n     // `Implemented(Self: Trait<P1..Pn>) :- FromEnv(Self: Trait<P1..Pn>)`\n-    let clause = Clause::Implies(vec![from_env], impl_trait);\n-    Lrc::new(vec![clause])\n+    let clause = ProgramClause {\n+        goal: impl_trait,\n+        hypotheses: vec![from_env],\n+    };\n+    Lrc::new(vec![Clause::ForAll(ty::Binder::dummy(clause))])\n }\n \n fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n@@ -167,8 +161,11 @@ fn program_clauses_for_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId\n     let where_clauses = tcx.predicates_of(def_id).predicates.lower();\n \n      // `Implemented(A0: Trait<A1..An>) :- WC`\n-    let clause = Clause::Implies(where_clauses, trait_pred);\n-    Lrc::new(vec![clause])\n+    let clause = ProgramClause {\n+        goal: trait_pred,\n+        hypotheses: where_clauses.into_iter().map(|wc| wc.into()).collect()\n+    };\n+    Lrc::new(vec![Clause::ForAll(ty::Binder::dummy(clause))])\n }\n \n pub fn dump_program_clauses<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n@@ -184,14 +181,19 @@ struct ClauseDumper<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n-impl <'a, 'tcx> ClauseDumper<'a, 'tcx > {\n+impl<'a, 'tcx> ClauseDumper<'a, 'tcx > {\n     fn process_attrs(&mut self, node_id: ast::NodeId, attrs: &[ast::Attribute]) {\n         let def_id = self.tcx.hir.local_def_id(node_id);\n         for attr in attrs {\n             if attr.check_name(\"rustc_dump_program_clauses\") {\n                 let clauses = self.tcx.program_clauses_for(def_id);\n                 for clause in &*clauses {\n-                    self.tcx.sess.struct_span_err(attr.span, &format!(\"{}\", clause)).emit();\n+                    // Skip the top-level binder for a less verbose output\n+                    let program_clause = match clause {\n+                        Clause::Implies(program_clause) => program_clause,\n+                        Clause::ForAll(program_clause) => program_clause.skip_binder(),\n+                    };\n+                    self.tcx.sess.struct_span_err(attr.span, &format!(\"{}\", program_clause)).emit();\n                 }\n             }\n         }"}]}