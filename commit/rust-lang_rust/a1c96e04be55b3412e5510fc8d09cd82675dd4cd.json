{"sha": "a1c96e04be55b3412e5510fc8d09cd82675dd4cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYzk2ZTA0YmU1NWIzNDEyZTU1MTBmYzhkMDljZDgyNjc1ZGQ0Y2Q=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-14T15:12:38Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-03-15T11:14:34Z"}, "message": "Introduce Semantics::visit_file_defs", "tree": {"sha": "09f1fd2e8538b5b8b764bb64c1832a62cde8b996", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09f1fd2e8538b5b8b764bb64c1832a62cde8b996"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1c96e04be55b3412e5510fc8d09cd82675dd4cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1c96e04be55b3412e5510fc8d09cd82675dd4cd", "html_url": "https://github.com/rust-lang/rust/commit/a1c96e04be55b3412e5510fc8d09cd82675dd4cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1c96e04be55b3412e5510fc8d09cd82675dd4cd/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5138baf2ac742de601f29d22fc64e386da56c4c2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5138baf2ac742de601f29d22fc64e386da56c4c2", "html_url": "https://github.com/rust-lang/rust/commit/5138baf2ac742de601f29d22fc64e386da56c4c2"}], "stats": {"total": 171, "additions": 103, "deletions": 68}, "files": [{"sha": "2a0a36de42f3c3d8ca7c26cd72b34d4f208f69ae", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a1c96e04be55b3412e5510fc8d09cd82675dd4cd/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c96e04be55b3412e5510fc8d09cd82675dd4cd/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=a1c96e04be55b3412e5510fc8d09cd82675dd4cd", "patch": "@@ -2,10 +2,12 @@\n \n mod source_to_def;\n \n-use std::{cell::RefCell, fmt, iter::successors};\n+use std::{cell::RefCell, collections::VecDeque, fmt, iter::successors};\n \n use base_db::{FileId, FileRange};\n+use either::Either;\n use hir_def::{\n+    nameres::ModuleSource,\n     resolver::{self, HasResolver, Resolver, TypeNs},\n     AsMacroCall, FunctionId, TraitId, VariantId,\n };\n@@ -155,6 +157,28 @@ impl<'db, DB: HirDatabase> Semantics<'db, DB> {\n         self.imp.ancestors_at_offset_with_macros(node, offset)\n     }\n \n+    /// Iterates all `ModuleDef`s and `Impl` blocks of the given file.\n+    pub fn visit_file_defs(&self, file_id: FileId, cb: &mut dyn FnMut(Either<ModuleDef, Impl>)) {\n+        let module = match self.to_module_def(file_id) {\n+            Some(it) => it,\n+            None => return,\n+        };\n+        let mut defs: VecDeque<_> = module.declarations(self.db).into();\n+        while let Some(def) = defs.pop_front() {\n+            if let ModuleDef::Module(submodule) = def {\n+                if let ModuleSource::Module(_) = submodule.definition_source(self.db).value {\n+                    defs.extend(submodule.declarations(self.db));\n+                    submodule\n+                        .impl_defs(self.db)\n+                        .into_iter()\n+                        .for_each(|impl_| cb(Either::Right(impl_)));\n+                }\n+            }\n+            cb(Either::Left(def));\n+        }\n+        module.impl_defs(self.db).into_iter().for_each(|impl_| cb(Either::Right(impl_)));\n+    }\n+\n     /// Find a AstNode by offset inside SyntaxNode, if it is inside *Macrofile*,\n     /// search up until it is of the target AstNode type\n     pub fn find_node_at_offset_with_macros<N: AstNode>("}, {"sha": "c3422ce70b7e9a40ac400348c66c59bec1842000", "filename": "crates/ide/src/annotations.rs", "status": "modified", "additions": 58, "deletions": 28, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a1c96e04be55b3412e5510fc8d09cd82675dd4cd/crates%2Fide%2Fsrc%2Fannotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c96e04be55b3412e5510fc8d09cd82675dd4cd/crates%2Fide%2Fsrc%2Fannotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations.rs?ref=a1c96e04be55b3412e5510fc8d09cd82675dd4cd", "patch": "@@ -1,17 +1,17 @@\n-use hir::Semantics;\n+use either::Either;\n+use hir::{HasSource, Semantics};\n use ide_db::{\n-    base_db::{FileId, FilePosition, FileRange, SourceDatabase},\n-    RootDatabase, SymbolKind,\n+    base_db::{FileId, FilePosition, FileRange},\n+    RootDatabase,\n };\n-use syntax::TextRange;\n+use syntax::{ast::NameOwner, AstNode, TextRange, TextSize};\n \n use crate::{\n-    file_structure::file_structure,\n     fn_references::find_all_methods,\n     goto_implementation::goto_implementation,\n     references::find_all_refs,\n     runnables::{runnables, Runnable},\n-    NavigationTarget, RunnableKind, StructureNodeKind,\n+    NavigationTarget, RunnableKind,\n };\n \n // Feature: Annotations\n@@ -75,41 +75,56 @@ pub(crate) fn annotations(\n         }\n     }\n \n-    file_structure(&db.parse(file_id).tree())\n-        .into_iter()\n-        .filter(|node| {\n-            matches!(\n-                node.kind,\n-                StructureNodeKind::SymbolKind(SymbolKind::Trait)\n-                    | StructureNodeKind::SymbolKind(SymbolKind::Struct)\n-                    | StructureNodeKind::SymbolKind(SymbolKind::Enum)\n-                    | StructureNodeKind::SymbolKind(SymbolKind::Union)\n-                    | StructureNodeKind::SymbolKind(SymbolKind::Const)\n-            )\n-        })\n-        .for_each(|node| {\n-            if config.annotate_impls\n-                && node.kind != StructureNodeKind::SymbolKind(SymbolKind::Const)\n-            {\n+    Semantics::new(db).visit_file_defs(file_id, &mut |def| match def {\n+        Either::Left(def) => {\n+            let node = match def {\n+                hir::ModuleDef::Const(konst) => {\n+                    konst.source(db).and_then(|node| range_and_position_of(&node.value))\n+                }\n+                hir::ModuleDef::Trait(trait_) => {\n+                    trait_.source(db).and_then(|node| range_and_position_of(&node.value))\n+                }\n+                hir::ModuleDef::Adt(hir::Adt::Struct(strukt)) => {\n+                    strukt.source(db).and_then(|node| range_and_position_of(&node.value))\n+                }\n+                hir::ModuleDef::Adt(hir::Adt::Enum(enum_)) => {\n+                    enum_.source(db).and_then(|node| range_and_position_of(&node.value))\n+                }\n+                hir::ModuleDef::Adt(hir::Adt::Union(union)) => {\n+                    union.source(db).and_then(|node| range_and_position_of(&node.value))\n+                }\n+                _ => None,\n+            };\n+            let (offset, range) = match node {\n+                Some(node) => node,\n+                None => return,\n+            };\n+\n+            if config.annotate_impls && !matches!(def, hir::ModuleDef::Const(_)) {\n                 annotations.push(Annotation {\n-                    range: node.node_range,\n+                    range,\n                     kind: AnnotationKind::HasImpls {\n-                        position: FilePosition { file_id, offset: node.navigation_range.start() },\n+                        position: FilePosition { file_id, offset },\n                         data: None,\n                     },\n                 });\n             }\n-\n             if config.annotate_references {\n                 annotations.push(Annotation {\n-                    range: node.node_range,\n+                    range,\n                     kind: AnnotationKind::HasReferences {\n-                        position: FilePosition { file_id, offset: node.navigation_range.start() },\n+                        position: FilePosition { file_id, offset },\n                         data: None,\n                     },\n                 });\n             }\n-        });\n+\n+            fn range_and_position_of(node: &dyn NameOwner) -> Option<(TextSize, TextRange)> {\n+                Some((node.name()?.syntax().text_range().start(), node.syntax().text_range()))\n+            }\n+        }\n+        Either::Right(_) => (),\n+    });\n \n     if config.annotate_method_references {\n         annotations.extend(find_all_methods(db, file_id).into_iter().map(|method| Annotation {\n@@ -936,4 +951,19 @@ mod tests {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn test_no_annotations_outside_module_tree() {\n+        check(\n+            r#\"\n+//- /foo.rs\n+struct Foo;\n+//- /lib.rs\n+// this file comes last since `check` checks the first file only\n+\"#,\n+            expect![[r#\"\n+                []\n+            \"#]],\n+        );\n+    }\n }"}, {"sha": "17454f270dd4340c1a77e2d1544f44375adf43a0", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 20, "deletions": 39, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/a1c96e04be55b3412e5510fc8d09cd82675dd4cd/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1c96e04be55b3412e5510fc8d09cd82675dd4cd/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=a1c96e04be55b3412e5510fc8d09cd82675dd4cd", "patch": "@@ -2,6 +2,7 @@ use std::fmt;\n \n use ast::NameOwner;\n use cfg::CfgExpr;\n+use either::Either;\n use hir::{AsAssocItem, HasAttrs, HasSource, HirDisplay, Semantics};\n use ide_assists::utils::test_related_attribute;\n use ide_db::{\n@@ -102,13 +103,27 @@ impl Runnable {\n // |===\n pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     let sema = Semantics::new(db);\n-    let module = match sema.to_module_def(file_id) {\n-        None => return Vec::new(),\n-        Some(it) => it,\n-    };\n \n     let mut res = Vec::new();\n-    runnables_mod(&sema, &mut res, module);\n+    sema.visit_file_defs(file_id, &mut |def| match def {\n+        Either::Left(def) => {\n+            let runnable = match def {\n+                hir::ModuleDef::Module(it) => runnable_mod(&sema, it),\n+                hir::ModuleDef::Function(it) => runnable_fn(&sema, it),\n+                _ => None,\n+            };\n+            res.extend(runnable.or_else(|| module_def_doctest(&sema, def)))\n+        }\n+        Either::Right(impl_) => {\n+            res.extend(impl_.items(db).into_iter().filter_map(|assoc| match assoc {\n+                hir::AssocItem::Function(it) => {\n+                    runnable_fn(&sema, it).or_else(|| module_def_doctest(&sema, it.into()))\n+                }\n+                hir::AssocItem::Const(it) => module_def_doctest(&sema, it.into()),\n+                hir::AssocItem::TypeAlias(it) => module_def_doctest(&sema, it.into()),\n+            }))\n+        }\n+    });\n     res\n }\n \n@@ -211,39 +226,6 @@ fn parent_test_module(sema: &Semantics<RootDatabase>, fn_def: &ast::Fn) -> Optio\n     })\n }\n \n-fn runnables_mod(sema: &Semantics<RootDatabase>, acc: &mut Vec<Runnable>, module: hir::Module) {\n-    acc.extend(module.declarations(sema.db).into_iter().filter_map(|def| {\n-        let runnable = match def {\n-            hir::ModuleDef::Module(it) => runnable_mod(&sema, it),\n-            hir::ModuleDef::Function(it) => runnable_fn(&sema, it),\n-            _ => None,\n-        };\n-        runnable.or_else(|| module_def_doctest(&sema, def))\n-    }));\n-\n-    acc.extend(module.impl_defs(sema.db).into_iter().flat_map(|it| it.items(sema.db)).filter_map(\n-        |def| match def {\n-            hir::AssocItem::Function(it) => {\n-                runnable_fn(&sema, it).or_else(|| module_def_doctest(&sema, it.into()))\n-            }\n-            hir::AssocItem::Const(it) => module_def_doctest(&sema, it.into()),\n-            hir::AssocItem::TypeAlias(it) => module_def_doctest(&sema, it.into()),\n-        },\n-    ));\n-\n-    for def in module.declarations(sema.db) {\n-        if let hir::ModuleDef::Module(submodule) = def {\n-            match submodule.definition_source(sema.db).value {\n-                hir::ModuleSource::Module(_) => runnables_mod(sema, acc, submodule),\n-                hir::ModuleSource::SourceFile(_) => {\n-                    cov_mark::hit!(dont_recurse_in_outline_submodules)\n-                }\n-                hir::ModuleSource::BlockExpr(_) => {} // inner items aren't runnable\n-            }\n-        }\n-    }\n-}\n-\n pub(crate) fn runnable_fn(sema: &Semantics<RootDatabase>, def: hir::Function) -> Option<Runnable> {\n     let func = def.source(sema.db)?;\n     let name_string = def.name(sema.db).to_string();\n@@ -1178,7 +1160,6 @@ mod tests {\n \n     #[test]\n     fn dont_recurse_in_outline_submodules() {\n-        cov_mark::check!(dont_recurse_in_outline_submodules);\n         check(\n             r#\"\n //- /lib.rs"}]}