{"sha": "e08a805b306398b316a489f76960569ac19b25b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwOGE4MDViMzA2Mzk4YjMxNmE0ODlmNzY5NjA1NjlhYzE5YjI1YjI=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-02-04T19:07:36Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2013-02-04T19:58:30Z"}, "message": "Merge remote-tracking branch 'bstrie/rimov' into incoming\n\nConflicts:\n\tsrc/libsyntax/parse/parser.rs\n\tsrc/test/bench/graph500-bfs.rs\n\tsrc/test/bench/sudoku.rs\n\tsrc/test/run-pass/borrowck-mut-vec-as-imm-slice.rs\n\tsrc/test/run-pass/empty-mutable-vec.rs\n\tsrc/test/run-pass/foreach-nested.rs\n\tsrc/test/run-pass/swap-2.rs", "tree": {"sha": "2099ffddadee1671642155cf2086fca581f5cfbc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2099ffddadee1671642155cf2086fca581f5cfbc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e08a805b306398b316a489f76960569ac19b25b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e08a805b306398b316a489f76960569ac19b25b2", "html_url": "https://github.com/rust-lang/rust/commit/e08a805b306398b316a489f76960569ac19b25b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e08a805b306398b316a489f76960569ac19b25b2/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27e1ac5bb93626da70135e167a6596d854e7e679", "url": "https://api.github.com/repos/rust-lang/rust/commits/27e1ac5bb93626da70135e167a6596d854e7e679", "html_url": "https://github.com/rust-lang/rust/commit/27e1ac5bb93626da70135e167a6596d854e7e679"}, {"sha": "aa9c28ef47d8b6a57e91b5468d70900d8e4172de", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa9c28ef47d8b6a57e91b5468d70900d8e4172de", "html_url": "https://github.com/rust-lang/rust/commit/aa9c28ef47d8b6a57e91b5468d70900d8e4172de"}], "stats": {"total": 327, "additions": 161, "deletions": 166}, "files": [{"sha": "fc8ce9f9c38fc35d46870b1e383a428d1d84d4be", "filename": "doc/rust.md", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -1719,15 +1719,12 @@ vec_elems : [expr [',' expr]*] | [expr ',' \"..\" expr]\n \n A [_vector_](#vector-types) _expression_ is written by enclosing zero or\n more comma-separated expressions of uniform type in square brackets.\n-The keyword `mut` can be written after the opening bracket to\n-indicate that the elements of the resulting vector may be mutated.\n-When no mutability is specified, the vector is immutable.\n \n ~~~~\n [1, 2, 3, 4];\n [\"a\", \"b\", \"c\", \"d\"];\n [0, ..128];             // vector with 128 zeros\n-[mut 0u8, 0u8, 0u8, 0u8];\n+[0u8, 0u8, 0u8, 0u8];\n ~~~~\n \n ### Index expressions\n@@ -1749,7 +1746,6 @@ task in a _failing state_.\n # do task::spawn_unlinked {\n \n ([1, 2, 3, 4])[0];\n-([mut 'x', 'y'])[1] = 'z';\n ([\"a\", \"b\"])[10]; // fails\n \n # }\n@@ -1912,8 +1908,8 @@ No allocation or destruction is entailed.\n An example of three different swap expressions:\n \n ~~~~~~~~\n-# let mut x = &[mut 0];\n-# let mut a = &[mut 0];\n+# let mut x = &mut [0];\n+# let mut a = &mut [0];\n # let i = 0;\n # let y = {mut z: 0};\n # let b = {mut c: 0};\n@@ -2008,11 +2004,11 @@ the unary copy operator is typically only used to cause an argument to a functio\n An example of a copy expression:\n \n ~~~~\n-fn mutate(vec: ~[mut int]) {\n+fn mutate(mut vec: ~[int]) {\n    vec[0] = 10;\n }\n \n-let v = ~[mut 1,2,3];\n+let v = ~[1,2,3];\n \n mutate(copy v);   // Pass a copy\n "}, {"sha": "1087689b9bee17e5dbeab310b492eb42628c1ed6", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -1795,7 +1795,7 @@ Generic `type`, `struct`, and `enum` declarations follow the same pattern:\n type Set<T> = HashMap<T, ()>;\n \n struct Stack<T> {\n-    elements: ~[mut T]\n+    elements: ~[T]\n }\n \n enum Option<T> {"}, {"sha": "a64700494c8975c7070242d0253674596f755033", "filename": "src/libfuzzer/cycles.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibfuzzer%2Fcycles.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibfuzzer%2Fcycles.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Fcycles.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -43,7 +43,7 @@ type pointy = {\n     mut g : fn~()->(),\n \n     mut m : ~[maybe_pointy],\n-    mut n : ~[mut maybe_pointy],\n+    mut n : ~[maybe_pointy],\n     mut o : {x : int, y : maybe_pointy}\n };\n // To add: objects; traits; anything type-parameterized?\n@@ -58,7 +58,7 @@ fn empty_pointy() -> @pointy {\n         mut g : fn~()->(){},\n \n         mut m : ~[],\n-        mut n : ~[mut],\n+        mut n : ~[],\n         mut o : {x : 0, y : none}\n     }\n }\n@@ -68,7 +68,7 @@ fn nop<T>(_x: T) { }\n \n fn test_cycles(r : rand::rng, k: uint, n: uint)\n {\n-    let v : ~[mut @pointy] = ~[mut];\n+    let mut v : ~[@pointy] = ~[];\n \n     // Create a graph with no edges\n     range(0u, vlen) {|_i|"}, {"sha": "ea8bd05c38ba796411f48e92f27113a06f612dd6", "filename": "src/libfuzzer/rand_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibfuzzer%2Frand_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibfuzzer%2Frand_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Frand_util.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -25,7 +25,7 @@ fn choice<T: copy>(r : rand::rng, v : ~[T]) -> T {\n fn unlikely(r : rand::rng, n : uint) -> bool { under(r, n) == 0u }\n \n // shuffle a vec in place\n-fn shuffle<T>(r : rand::rng, &v : ~[mut T]) {\n+fn shuffle<T>(r : rand::rng, &v : ~[T]) {\n     let i = vec::len(v);\n     while i >= 2u {\n         // Loop invariant: elements with index >= i have been locked in place.\n@@ -86,7 +86,7 @@ fn main()\n     log(error, choice(r, ~[10, 20, 30]));\n     log(error, if unlikely(r, 5u) { \"unlikely\" } else { \"likely\" });\n \n-    let a = ~[mut 1, 2, 3];\n+    let mut a = ~[1, 2, 3];\n     shuffle(r, a);\n     log(error, a);\n "}, {"sha": "9b5efb7c90dac11545c72777312dd7bd8a8cf3e2", "filename": "src/librustdoc/markdown_writer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibrustdoc%2Fmarkdown_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibrustdoc%2Fmarkdown_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_writer.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -156,7 +156,7 @@ fn readclose(fd: libc::c_int) -> ~str {\n         let file = os::fdopen(fd);\n         let reader = io::FILE_reader(file, false);\n         let buf = io::with_bytes_writer(|writer| {\n-            let mut bytes = [mut 0, ..4096];\n+            let mut bytes = [0, ..4096];\n             while !reader.eof() {\n                 let nread = reader.read(bytes, bytes.len());\n                 writer.write(bytes.view(0, nread));"}, {"sha": "d49c2ef95f6af8064944990083f1728f0ffa5d4d", "filename": "src/libstd/bitv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitv.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -106,10 +106,10 @@ impl SmallBitv {\n \n struct BigBitv {\n     // only mut b/c of clone and lack of other constructor\n-    mut storage: ~[mut uint]\n+    mut storage: ~[uint]\n }\n \n-fn BigBitv(storage: ~[mut uint]) -> BigBitv {\n+fn BigBitv(storage: ~[uint]) -> BigBitv {\n     BigBitv {storage: move storage}\n }\n \n@@ -233,7 +233,7 @@ pub fn Bitv (nbits: uint, init: bool) -> Bitv {\n         let nelems = nbits/uint_bits +\n                      if nbits % uint_bits == 0 {0} else {1};\n         let elem = if init {!0} else {0};\n-        let s = cast_to_mut(from_elem(nelems, elem));\n+        let s = from_elem(nelems, elem);\n         Big(~BigBitv(move s))\n     };\n     Bitv {rep: move rep, nbits: nbits}\n@@ -518,7 +518,7 @@ impl Bitv: Clone {\n             Bitv{nbits: self.nbits, rep: Small(~SmallBitv{bits: b.bits})}\n           }\n           Big(ref b) => {\n-            let st = cast_to_mut(from_elem(self.nbits / uint_bits + 1, 0));\n+            let mut st = from_elem(self.nbits / uint_bits + 1, 0);\n             let len = st.len();\n             for uint::range(0, len) |i| { st[i] = b.storage[i]; };\n             Bitv{nbits: self.nbits, rep: Big(~BigBitv{storage: move st})}"}, {"sha": "9a90b811e44c540fbca0a48fa328754356ef0ff3", "filename": "src/libstd/io_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Fio_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Fio_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio_util.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -43,7 +43,7 @@ pub impl BufReader {\n }\n \n impl BufReader: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         self.as_bytes_reader(|r| r.read(bytes, len) )\n     }\n     fn read_byte(&self) -> int {"}, {"sha": "429bd6ae474556539ffc5fd927a7cae5e24823f0", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -863,7 +863,7 @@ impl TcpSocket {\n \n /// Implementation of `io::reader` trait for a buffered `net::tcp::tcp_socket`\n impl TcpSocketBuf: io::Reader {\n-    fn read(&self, buf: &[mut u8], len: uint) -> uint {\n+    fn read(&self, buf: &mut [u8], len: uint) -> uint {\n         if len == 0 { return 0 }\n         let mut count: uint = 0;\n "}, {"sha": "a4d4a4e806b0dd566b0dd64e486fa5ab0d625e5c", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -66,7 +66,7 @@ pub mod chained {\n \n     struct HashMap_<K, V> {\n         mut count: uint,\n-        mut chains: ~[mut Option<@Entry<K,V>>]\n+        mut chains: ~[Option<@Entry<K,V>>]\n     }\n \n     pub type T<K, V> = @HashMap_<K, V>;\n@@ -131,7 +131,7 @@ pub mod chained {\n         fn rehash() {\n             let n_old_chains = self.chains.len();\n             let n_new_chains: uint = uint::next_power_of_two(n_old_chains+1u);\n-            let new_chains = chains(n_new_chains);\n+            let mut new_chains = chains(n_new_chains);\n             for self.each_entry |entry| {\n                 let idx = entry.hash % n_new_chains;\n                 entry.next = new_chains[idx];\n@@ -369,8 +369,8 @@ pub mod chained {\n         }\n     }\n \n-    fn chains<K,V>(nchains: uint) -> ~[mut Option<@Entry<K,V>>] {\n-        vec::cast_to_mut(vec::from_elem(nchains, None))\n+    fn chains<K,V>(nchains: uint) -> ~[Option<@Entry<K,V>>] {\n+        vec::from_elem(nchains, None)\n     }\n \n     pub fn mk<K:Eq IterBytes Hash, V: Copy>() -> T<K,V> {"}, {"sha": "c7601f6b6b5f5e49cbd72f1dd4ee5f84907f205e", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -788,7 +788,7 @@ pub mod node {\n      * * forest - The forest. This vector is progressively rewritten during\n      *            execution and should be discarded as meaningless afterwards.\n      */\n-    pub fn tree_from_forest_destructive(forest: &[mut @Node]) -> @Node {\n+    pub fn tree_from_forest_destructive(forest: &mut [@Node]) -> @Node {\n         let mut i;\n         let mut len = vec::len(forest);\n         while len > 1u {\n@@ -1158,18 +1158,17 @@ pub mod node {\n         use core::vec;\n \n         pub struct T {\n-            stack: ~[mut @Node],\n+            mut stack: ~[@Node],\n             mut stackpos: int,\n         }\n \n         pub fn empty() -> T {\n-            let stack : ~[mut @Node] = ~[mut];\n+            let mut stack : ~[@Node] = ~[];\n             T { stack: stack, stackpos: -1 }\n         }\n \n         pub fn start(node: @Node) -> T {\n-            let stack = vec::cast_to_mut(\n-                vec::from_elem(height(node)+1u, node));\n+            let stack = vec::from_elem(height(node)+1u, node);\n             T {\n                 stack: stack,\n                 stackpos:  0,"}, {"sha": "6e89cd9e24f9233faf00ce5af8578a9de3510122", "filename": "src/libstd/sort.rs", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsort.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -64,7 +64,7 @@ pub pure fn merge_sort<T: Copy>(v: &[const T], le: Le<T>) -> ~[T] {\n     }\n }\n \n-fn part<T: Copy>(arr: &[mut T], left: uint,\n+fn part<T: Copy>(arr: &mut [T], left: uint,\n                 right: uint, pivot: uint, compare_func: Le<T>) -> uint {\n     let pivot_value = arr[pivot];\n     arr[pivot] <-> arr[right];\n@@ -81,7 +81,7 @@ fn part<T: Copy>(arr: &[mut T], left: uint,\n     return storage_index;\n }\n \n-fn qsort<T: Copy>(arr: &[mut T], left: uint,\n+fn qsort<T: Copy>(arr: &mut [T], left: uint,\n              right: uint, compare_func: Le<T>) {\n     if right > left {\n         let pivot = (left + right) / 2u;\n@@ -100,12 +100,12 @@ fn qsort<T: Copy>(arr: &[mut T], left: uint,\n  * Has worst case O(n^2) performance, average case O(n log n).\n  * This is an unstable sort.\n  */\n-pub fn quick_sort<T: Copy>(arr: &[mut T], compare_func: Le<T>) {\n+pub fn quick_sort<T: Copy>(arr: &mut [T], compare_func: Le<T>) {\n     if len::<T>(arr) == 0u { return; }\n     qsort::<T>(arr, 0u, len::<T>(arr) - 1u, compare_func);\n }\n \n-fn qsort3<T: Copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n+fn qsort3<T: Copy Ord Eq>(arr: &mut [T], left: int, right: int) {\n     if right <= left { return; }\n     let v: T = arr[right];\n     let mut i: int = left - 1;\n@@ -162,7 +162,7 @@ fn qsort3<T: Copy Ord Eq>(arr: &[mut T], left: int, right: int) {\n  *\n  * This is an unstable sort.\n  */\n-pub fn quick_sort3<T: Copy Ord Eq>(arr: &[mut T]) {\n+pub fn quick_sort3<T: Copy Ord Eq>(arr: &mut [T]) {\n     if arr.len() <= 1 { return; }\n     qsort3(arr, 0, (arr.len() - 1) as int);\n }\n@@ -171,15 +171,15 @@ pub trait Sort {\n     fn qsort(self);\n }\n \n-impl<T: Copy Ord Eq> &[mut T] : Sort {\n+impl<T: Copy Ord Eq> &mut [T] : Sort {\n     fn qsort(self) { quick_sort3(self); }\n }\n \n const MIN_MERGE: uint = 64;\n const MIN_GALLOP: uint = 7;\n const INITIAL_TMP_STORAGE: uint = 128;\n \n-pub fn tim_sort<T: Copy Ord>(array: &[mut T]) {\n+pub fn tim_sort<T: Copy Ord>(array: &mut [T]) {\n     let size = array.len();\n     if size < 2 {\n         return;\n@@ -218,7 +218,7 @@ pub fn tim_sort<T: Copy Ord>(array: &[mut T]) {\n     ms.merge_force_collapse(array);\n }\n \n-fn binarysort<T: Copy Ord>(array: &[mut T], start: uint) {\n+fn binarysort<T: Copy Ord>(array: &mut [T], start: uint) {\n     let size = array.len();\n     let mut start = start;\n     assert start <= size;\n@@ -249,7 +249,7 @@ fn binarysort<T: Copy Ord>(array: &[mut T], start: uint) {\n }\n \n // Reverse the order of elements in a slice, in place\n-fn reverse_slice<T>(v: &[mut T], start: uint, end:uint) {\n+fn reverse_slice<T>(v: &mut [T], start: uint, end:uint) {\n     let mut i = start;\n     while i < end / 2 {\n         util::swap(&mut v[i], &mut v[end - i - 1]);\n@@ -268,7 +268,7 @@ pure fn min_run_length(n: uint) -> uint {\n     return n + r;\n }\n \n-fn count_run_ascending<T: Copy Ord>(array: &[mut T]) -> uint {\n+fn count_run_ascending<T: Copy Ord>(array: &mut [T]) -> uint {\n     let size = array.len();\n     assert size > 0;\n     if size == 1 { return 1; }\n@@ -412,7 +412,7 @@ impl<T: Copy Ord> MergeState<T> {\n         self.runs.push(tmp);\n     }\n \n-    fn merge_at(&self, n: uint, array: &[mut T]) {\n+    fn merge_at(&self, n: uint, array: &mut [T]) {\n         let mut size = self.runs.len();\n         assert size >= 2;\n         assert n == size-2 || n == size-3;\n@@ -453,7 +453,7 @@ impl<T: Copy Ord> MergeState<T> {\n         self.runs.pop();\n     }\n \n-    fn merge_lo(&self, array: &[mut T], base1: uint, len1: uint,\n+    fn merge_lo(&self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 0 && len2 != 0 && base1+len1 == base2;\n \n@@ -556,7 +556,7 @@ impl<T: Copy Ord> MergeState<T> {\n         }\n     }\n \n-    fn merge_hi(&self, array: &[mut T], base1: uint, len1: uint,\n+    fn merge_hi(&self, array: &mut [T], base1: uint, len1: uint,\n                 base2: uint, len2: uint) {\n         assert len1 != 1 && len2 != 0 && base1 + len1 == base2;\n \n@@ -674,7 +674,7 @@ impl<T: Copy Ord> MergeState<T> {\n         }\n     }\n \n-    fn merge_collapse(&self, array: &[mut T]) {\n+    fn merge_collapse(&self, array: &mut [T]) {\n         while self.runs.len() > 1 {\n             let mut n = self.runs.len()-2;\n             let chk = do self.runs.borrow |arr| {\n@@ -692,7 +692,7 @@ impl<T: Copy Ord> MergeState<T> {\n         }\n     }\n \n-    fn merge_force_collapse(&self, array: &[mut T]) {\n+    fn merge_force_collapse(&self, array: &mut [T]) {\n         while self.runs.len() > 1 {\n             let mut n = self.runs.len()-2;\n             if n > 0 {\n@@ -708,7 +708,7 @@ impl<T: Copy Ord> MergeState<T> {\n }\n \n #[inline(always)]\n-fn copy_vec<T: Copy>(dest: &[mut T], s1: uint,\n+fn copy_vec<T: Copy>(dest: &mut [T], s1: uint,\n                     from: &[const T], s2: uint, len: uint) {\n     assert s1+len <= dest.len() && s2+len <= from.len();\n \n@@ -726,7 +726,7 @@ mod test_qsort3 {\n \n     use core::vec;\n \n-    pub fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         quick_sort3::<int>(v1);\n         let mut i = 0;\n@@ -740,24 +740,24 @@ mod test_qsort3 {\n     #[test]\n     pub fn test() {\n         {\n-            let v1 = ~[mut 3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = ~[mut 2, 3, 4, 5, 5, 7, 8, 9];\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1 = ~[mut 1, 1, 1];\n-            let v2 = ~[mut 1, 1, 1];\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1: ~[mut int] = ~[mut];\n-            let v2: ~[mut int] = ~[mut];\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n             check_sort(v1, v2);\n         }\n-        { let v1 = ~[mut 9]; let v2 = ~[mut 9]; check_sort(v1, v2); }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n         {\n-            let v1 = ~[mut 9, 3, 3, 3, 9];\n-            let v2 = ~[mut 3, 3, 3, 9, 9];\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n             check_sort(v1, v2);\n         }\n     }\n@@ -772,7 +772,7 @@ mod test_qsort {\n     use core::int;\n     use core::vec;\n \n-    pub fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    pub fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         pure fn leual(a: &int, b: &int) -> bool { *a <= *b }\n         quick_sort::<int>(v1, leual);\n@@ -787,38 +787,38 @@ mod test_qsort {\n     #[test]\n     pub fn test() {\n         {\n-            let v1 = ~[mut 3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = ~[mut 2, 3, 4, 5, 5, 7, 8, 9];\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1 = ~[mut 1, 1, 1];\n-            let v2 = ~[mut 1, 1, 1];\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1: ~[mut int] = ~[mut];\n-            let v2: ~[mut int] = ~[mut];\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n             check_sort(v1, v2);\n         }\n-        { let v1 = ~[mut 9]; let v2 = ~[mut 9]; check_sort(v1, v2); }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n         {\n-            let v1 = ~[mut 9, 3, 3, 3, 9];\n-            let v2 = ~[mut 3, 3, 3, 9, 9];\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n             check_sort(v1, v2);\n         }\n     }\n \n     // Regression test for #750\n     #[test]\n     pub fn test_simple() {\n-        let names = ~[mut 2, 1, 3];\n+        let mut names = ~[2, 1, 3];\n \n         let expected = ~[1, 2, 3];\n \n         do quick_sort(names) |x, y| { int::le(*x, *y) };\n \n-        let immut_names = vec::cast_from_mut(move names);\n+        let immut_names = move names;\n \n         let pairs = vec::zip_slice(expected, immut_names);\n         for vec::each(pairs) |p| {\n@@ -870,7 +870,7 @@ mod tests {\n     #[test]\n     pub fn test_merge_sort_mutable() {\n         pub pure fn le(a: &int, b: &int) -> bool { *a <= *b }\n-        let v1 = ~[mut 3, 2, 1];\n+        let mut v1 = ~[3, 2, 1];\n         let v2 = merge_sort(v1, le);\n         assert v2 == ~[1, 2, 3];\n     }\n@@ -923,7 +923,7 @@ mod test_tim_sort {\n         pure fn ge(&self, other: &CVal) -> bool { (*self).val >= other.val }\n     }\n \n-    fn check_sort(v1: &[mut int], v2: &[mut int]) {\n+    fn check_sort(v1: &mut [int], v2: &mut [int]) {\n         let len = vec::len::<int>(v1);\n         tim_sort::<int>(v1);\n         let mut i = 0u;\n@@ -937,24 +937,24 @@ mod test_tim_sort {\n     #[test]\n     fn test() {\n         {\n-            let v1 = ~[mut 3, 7, 4, 5, 2, 9, 5, 8];\n-            let v2 = ~[mut 2, 3, 4, 5, 5, 7, 8, 9];\n+            let mut v1 = ~[3, 7, 4, 5, 2, 9, 5, 8];\n+            let mut v2 = ~[2, 3, 4, 5, 5, 7, 8, 9];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1 = ~[mut 1, 1, 1];\n-            let v2 = ~[mut 1, 1, 1];\n+            let mut v1 = ~[1, 1, 1];\n+            let mut v2 = ~[1, 1, 1];\n             check_sort(v1, v2);\n         }\n         {\n-            let v1: ~[mut int] = ~[mut];\n-            let v2: ~[mut int] = ~[mut];\n+            let mut v1: ~[int] = ~[];\n+            let mut v2: ~[int] = ~[];\n             check_sort(v1, v2);\n         }\n-        { let v1 = ~[mut 9]; let v2 = ~[mut 9]; check_sort(v1, v2); }\n+        { let mut v1 = ~[9]; let mut v2 = ~[9]; check_sort(v1, v2); }\n         {\n-            let v1 = ~[mut 9, 3, 3, 3, 9];\n-            let v2 = ~[mut 3, 3, 3, 9, 9];\n+            let mut v1 = ~[9, 3, 3, 3, 9];\n+            let mut v2 = ~[3, 3, 3, 9, 9];\n             check_sort(v1, v2);\n         }\n     }\n@@ -1019,12 +1019,12 @@ mod big_tests {\n         tabulate_managed(low, high);\n     }\n \n-    fn multiplyVec<T: Copy>(arr: &[const T], num: uint) -> ~[mut T] {\n+    fn multiplyVec<T: Copy>(arr: &[const T], num: uint) -> ~[T] {\n         let size = arr.len();\n         let res = do vec::from_fn(num) |i| {\n             arr[i % size]\n         };\n-        vec::cast_to_mut(move res)\n+        move res\n     }\n \n     fn makeRange(n: uint) -> ~[uint] {\n@@ -1050,7 +1050,7 @@ mod big_tests {\n             let arr = do vec::from_fn(n) |_i| {\n                 rng.gen_float()\n             };\n-            let arr = vec::cast_to_mut(move arr);\n+            let mut arr = move arr;\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1088,7 +1088,7 @@ mod big_tests {\n             tim_sort(arr);\n             isSorted(arr);\n \n-            let arr = if n > 4 {\n+            let mut arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);\n                 multiplyVec(part, n)\n             } else { move arr };\n@@ -1122,7 +1122,7 @@ mod big_tests {\n             let arr = do vec::from_fn(n) |_i| {\n                 @rng.gen_float()\n             };\n-            let arr = vec::cast_to_mut(move arr);\n+            let mut arr = move arr;\n \n             tim_sort(arr); // *sort\n             isSorted(arr);\n@@ -1160,7 +1160,7 @@ mod big_tests {\n             tim_sort(arr);\n             isSorted(arr);\n \n-            let arr = if n > 4 {\n+            let mut arr = if n > 4 {\n                 let part = vec::view(arr, 0, 4);\n                 multiplyVec(part, n)\n             } else { move arr };"}, {"sha": "31c596c50382d01036ef07cece952c70fc71dce8", "filename": "src/libstd/sync.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibstd%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -92,12 +92,12 @@ fn new_sem<Q: Owned>(count: int, q: Q) -> Sem<Q> {\n }\n #[doc(hidden)]\n fn new_sem_and_signal(count: int, num_condvars: uint)\n-        -> Sem<~[mut Waitqueue]> {\n+        -> Sem<~[Waitqueue]> {\n     let mut queues = ~[];\n     for num_condvars.times {\n         queues.push(new_waitqueue());\n     }\n-    new_sem(count, vec::cast_to_mut(move queues))\n+    new_sem(count, queues)\n }\n \n #[doc(hidden)]\n@@ -150,7 +150,7 @@ impl &Sem<()> {\n     }\n }\n #[doc(hidden)]\n-impl &Sem<~[mut Waitqueue]> {\n+impl &Sem<~[Waitqueue]> {\n     fn access<U>(blk: fn() -> U) -> U {\n         let mut release = None;\n         unsafe {\n@@ -166,7 +166,7 @@ impl &Sem<~[mut Waitqueue]> {\n // FIXME(#3588) should go inside of access()\n #[doc(hidden)]\n type SemRelease = SemReleaseGeneric<()>;\n-type SemAndSignalRelease = SemReleaseGeneric<~[mut Waitqueue]>;\n+type SemAndSignalRelease = SemReleaseGeneric<~[Waitqueue]>;\n struct SemReleaseGeneric<Q> { sem: &Sem<Q> }\n \n impl<Q: Owned> SemReleaseGeneric<Q> : Drop {\n@@ -181,15 +181,15 @@ fn SemRelease(sem: &r/Sem<()>) -> SemRelease/&r {\n     }\n }\n \n-fn SemAndSignalRelease(sem: &r/Sem<~[mut Waitqueue]>)\n+fn SemAndSignalRelease(sem: &r/Sem<~[Waitqueue]>)\n     -> SemAndSignalRelease/&r {\n     SemReleaseGeneric {\n         sem: sem\n     }\n }\n \n /// A mechanism for atomic-unlock-and-deschedule blocking and signalling.\n-pub struct Condvar { priv sem: &Sem<~[mut Waitqueue]> }\n+pub struct Condvar { priv sem: &Sem<~[Waitqueue]> }\n \n impl Condvar : Drop { fn finalize(&self) {} }\n \n@@ -259,7 +259,7 @@ impl &Condvar {\n         // mutex during unwinding. As long as the wrapper (mutex, etc) is\n         // bounded in when it gets released, this shouldn't hang forever.\n         struct SemAndSignalReacquire {\n-            sem: &Sem<~[mut Waitqueue]>,\n+            sem: &Sem<~[Waitqueue]>,\n         }\n \n         impl SemAndSignalReacquire : Drop {\n@@ -273,7 +273,7 @@ impl &Condvar {\n             }\n         }\n \n-        fn SemAndSignalReacquire(sem: &r/Sem<~[mut Waitqueue]>)\n+        fn SemAndSignalReacquire(sem: &r/Sem<~[Waitqueue]>)\n             -> SemAndSignalReacquire/&r {\n             SemAndSignalReacquire {\n                 sem: sem\n@@ -345,7 +345,7 @@ fn check_cvar_bounds<U>(out_of_bounds: Option<uint>, id: uint, act: &str,\n }\n \n #[doc(hidden)]\n-impl &Sem<~[mut Waitqueue]> {\n+impl &Sem<~[Waitqueue]> {\n     // The only other place that condvars get built is rwlock_write_mode.\n     fn access_cond<U>(blk: fn(c: &Condvar) -> U) -> U {\n         do self.access { blk(&Condvar { sem: self }) }\n@@ -400,7 +400,7 @@ impl &Semaphore {\n  * A task which fails while holding a mutex will unlock the mutex as it\n  * unwinds.\n  */\n-struct Mutex { priv sem: Sem<~[mut Waitqueue]> }\n+struct Mutex { priv sem: Sem<~[Waitqueue]> }\n \n /// Create a new mutex, with one associated condvar.\n pub fn Mutex() -> Mutex { mutex_with_condvars(1) }\n@@ -450,7 +450,7 @@ struct RWlockInner {\n  */\n struct RWlock {\n     priv order_lock:  Semaphore,\n-    priv access_lock: Sem<~[mut Waitqueue]>,\n+    priv access_lock: Sem<~[Waitqueue]>,\n     priv state:       Exclusive<RWlockInner>\n }\n "}, {"sha": "ca28641c4a3bc62845d327101ec2a93cb62dab99", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -269,9 +269,9 @@ pub fn sort_meta_items(+items: ~[@ast::meta_item]) -> ~[@ast::meta_item] {\n     }\n \n     // This is sort of stupid here, converting to a vec of mutables and back\n-    let v: ~[mut @ast::meta_item] = vec::cast_to_mut(items);\n+    let mut v: ~[@ast::meta_item] = items;\n     std::sort::quick_sort(v, lteq);\n-    vec::cast_from_mut(move v)\n+    move v\n }\n \n pub fn remove_meta_items_by_name(items: ~[@ast::meta_item], name: ~str) ->"}, {"sha": "5cd78dd90490b5f3243e6b584654cb99b57fb0f2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -194,7 +194,7 @@ pub fn Parser(sess: parse_sess,\n         token: tok0.tok,\n         span: span0,\n         last_span: span0,\n-        buffer: [mut TokenAndSpan {tok: tok0.tok, sp: span0}, ..4],\n+        mut buffer: [TokenAndSpan {tok: tok0.tok, sp: span0}, ..4],\n         buffer_start: 0,\n         buffer_end: 0,\n         tokens_consumed: 0u,\n@@ -214,7 +214,7 @@ pub struct Parser {\n     mut token: token::Token,\n     mut span: span,\n     mut last_span: span,\n-    mut buffer: [mut TokenAndSpan * 4],\n+    mut buffer: [TokenAndSpan * 4],\n     mut buffer_start: int,\n     mut buffer_end: int,\n     mut tokens_consumed: uint,"}, {"sha": "34ba4526c477ef99cfb9db0658c410965b995d22", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -119,7 +119,7 @@ pub fn tok_str(++t: token) -> ~str {\n     }\n }\n \n-pub fn buf_str(toks: ~[mut token], szs: ~[mut int], left: uint, right: uint,\n+pub fn buf_str(toks: ~[token], szs: ~[int], left: uint, right: uint,\n                lim: uint) -> ~str {\n     let n = vec::len(toks);\n     assert (n == vec::len(szs));\n@@ -148,17 +148,17 @@ pub fn mk_printer(out: io::Writer, linewidth: uint) -> printer {\n     // fall behind.\n     let n: uint = 3 * linewidth;\n     debug!(\"mk_printer %u\", linewidth);\n-    let token: ~[mut token] = vec::cast_to_mut(vec::from_elem(n, EOF));\n-    let size: ~[mut int] = vec::cast_to_mut(vec::from_elem(n, 0));\n-    let scan_stack: ~[mut uint] = vec::cast_to_mut(vec::from_elem(n, 0u));\n+    let mut token: ~[token] = vec::from_elem(n, EOF);\n+    let mut size: ~[int] = vec::from_elem(n, 0);\n+    let mut scan_stack: ~[uint] = vec::from_elem(n, 0u);\n     printer_(@{out: out,\n                buf_len: n,\n                mut margin: linewidth as int,\n                mut space: linewidth as int,\n                mut left: 0,\n                mut right: 0,\n-               token: move token,\n-               size: move size,\n+               mut token: move token,\n+               mut size: move size,\n                mut left_total: 0,\n                mut right_total: 0,\n                mut scan_stack: move scan_stack,\n@@ -254,8 +254,8 @@ pub type printer_ = {\n     mut space: int, // number of spaces left on line\n     mut left: uint, // index of left side of input stream\n     mut right: uint, // index of right side of input stream\n-    token: ~[mut token], // ring-buffr stream goes through\n-    size: ~[mut int], // ring-buffer of calculated sizes\n+    mut token: ~[token], // ring-buffr stream goes through\n+    mut size: ~[int], // ring-buffer of calculated sizes\n     mut left_total: int, // running size of stream \"...left\"\n     mut right_total: int, // running size of stream \"...right\"\n     // pseudo-stack, really a ring too. Holds the\n@@ -264,7 +264,7 @@ pub type printer_ = {\n     // BEGIN (if there is any) on top of it. Stuff is flushed off the\n     // bottom as it becomes irrelevant due to the primary ring-buffer\n     // advancing.\n-    mut scan_stack: ~[mut uint],\n+    mut scan_stack: ~[uint],\n     mut scan_stack_empty: bool, // top==bottom disambiguator\n     mut top: uint, // index of top of scan_stack\n     mut bottom: uint, // index of bottom of scan_stack"}, {"sha": "5ade0c9ed25db9dc342139fc0ace76f4123e45bb", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -120,8 +120,8 @@ fn gen_search_keys(graph: graph, n: uint) -> ~[node_id] {\n  * Nodes that are unreachable have a parent of -1.\n  */\n fn bfs(graph: graph, key: node_id) -> bfs_result {\n-    let marks : ~[mut node_id]\n-        = vec::cast_to_mut(vec::from_elem(vec::len(graph), -1i64));\n+    let mut marks : ~[node_id]\n+        = vec::from_elem(vec::len(graph), -1i64);\n \n     let Q = deque::create();\n \n@@ -140,7 +140,7 @@ fn bfs(graph: graph, key: node_id) -> bfs_result {\n         };\n     }\n \n-    vec::cast_from_mut(move marks)\n+    move marks\n }\n \n /**"}, {"sha": "b679b83228589de369a6c42ad24ca55f43b79fba", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -16,7 +16,7 @@ fn eval_A(i: uint, j: uint) -> float {\n     1.0/(((i+j)*(i+j+1u)/2u+i+1u) as float)\n }\n \n-fn eval_A_times_u(u: &[const float], Au: &[mut float]) {\n+fn eval_A_times_u(u: &[const float], Au: &mut [float]) {\n     let N = vec::len(u);\n     let mut i = 0u;\n     while i < N {\n@@ -30,7 +30,7 @@ fn eval_A_times_u(u: &[const float], Au: &[mut float]) {\n     }\n }\n \n-fn eval_At_times_u(u: &[const float], Au: &[mut float]) {\n+fn eval_At_times_u(u: &[const float], Au: &mut [float]) {\n     let N = vec::len(u);\n     let mut i = 0u;\n     while i < N {\n@@ -44,7 +44,7 @@ fn eval_At_times_u(u: &[const float], Au: &[mut float]) {\n     }\n }\n \n-fn eval_AtA_times_u(u: &[const float], AtAu: &[mut float]) {\n+fn eval_AtA_times_u(u: &[const float], AtAu: &mut [float]) {\n     let v = vec::cast_to_mut(vec::from_elem(vec::len(u), 0.0));\n     eval_A_times_u(u, v);\n     eval_At_times_u(v, AtAu);"}, {"sha": "750874e80c3a4c69ada680f34e960eee6f2b8b19", "filename": "src/test/bench/sudoku.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Fbench%2Fsudoku.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Fbench%2Fsudoku.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fsudoku.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -30,7 +30,7 @@ use io::{ReaderUtil, WriterUtil};\n //\n \n // internal type of sudoku grids\n-type grid = ~[~[mut u8]];\n+type grid = ~[~[u8]];\n \n // exported type of sudoku grids\n pub enum grid_t { grid_ctor(grid), }\n@@ -39,8 +39,8 @@ pub enum grid_t { grid_ctor(grid), }\n pub fn read_grid(f: io::Reader) -> grid_t {\n     assert f.read_line() == ~\"9,9\"; /* assert first line is exactly \"9,9\" */\n \n-    let g = vec::from_fn(10u, {|_i|\n-        vec::cast_to_mut(vec::from_elem(10u, 0 as u8))\n+    let mut g = vec::from_fn(10u, {|_i|\n+        vec::from_elem(10u, 0 as u8)\n     });\n     while !f.eof() {\n         let comps = str::split_char(str::trim(f.read_line()), ',');\n@@ -55,7 +55,7 @@ pub fn read_grid(f: io::Reader) -> grid_t {\n \n // solve sudoku grid\n pub fn solve_grid(g: grid_t) {\n-    fn next_color(g: grid, row: u8, col: u8, start_color: u8) -> bool {\n+    fn next_color(mut g: grid, row: u8, col: u8, start_color: u8) -> bool {\n         if start_color < 10u8 {\n             // colors not yet used\n             let avail = bitv::Bitv(10u, false);\n@@ -139,8 +139,8 @@ fn main() {\n     let grid = if vec::len(args) == 1u {\n         // FIXME create sudoku inline since nested vec consts dont work yet\n         // (#3733)\n-        let g = vec::from_fn(10u, |_i| {\n-            vec::cast_to_mut(vec::from_elem(10u, 0 as u8))\n+        let mut g = vec::from_fn(10u, |_i| {\n+            vec::from_elem(10u, 0 as u8)\n         });\n         g[0][1] = 4u8;\n         g[0][3] = 6u8;"}, {"sha": "9126a327d861d60349e04b80f75a70eb480a7344", "filename": "src/test/run-pass/borrowck-mut-vec-as-imm-slice.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-mut-vec-as-imm-slice.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -14,10 +14,10 @@ fn want_slice(v: &[int]) -> int {\n     return sum;\n }\n \n-fn has_mut_vec(+v: ~[mut int]) -> int {\n+fn has_mut_vec(+v: ~[int]) -> int {\n     want_slice(v)\n }\n \n pub fn main() {\n-    assert has_mut_vec(~[mut 1, 2, 3]) == 6;\n+    assert has_mut_vec(~[1, 2, 3]) == 6;\n }\n\\ No newline at end of file"}, {"sha": "ba7d78ba04f11691098772531302e75dc0cd5cd5", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-arg.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-arg.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -4,7 +4,7 @@ pure fn sum(x: &[int]) -> int {\n     return sum;\n }\n \n-fn sum_mut(y: &[mut int]) -> int {\n+fn sum_mut(y: &mut [int]) -> int {\n     sum(y)\n }\n \n@@ -16,4 +16,4 @@ fn sum_const(y: &[const int]) -> int {\n     sum(y)\n }\n \n-pub fn main() {}\n\\ No newline at end of file\n+pub fn main() {}"}, {"sha": "7b01fe81c67487ced937fd6fd504350445593b8e", "filename": "src/test/run-pass/coerce-reborrow-imm-vec-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-imm-vec-rcvr.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -2,7 +2,7 @@ fn foo(v: &[const uint]) -> ~[uint] {\n     v.to_vec()\n }\n \n-fn bar(v: &[mut uint]) -> ~[uint] {\n+fn bar(v: &mut [uint]) -> ~[uint] {\n     v.to_vec()\n }\n "}, {"sha": "0c31560e981529fd918408e784ea007f6738f42f", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -2,7 +2,7 @@ trait Reverser {\n     fn reverse(&self);\n }\n \n-fn bar(v: &[mut uint]) {\n+fn bar(v: &mut [uint]) {\n     vec::reverse(v);\n     vec::reverse(v);\n     vec::reverse(v);"}, {"sha": "0820af24c49eaa6838bb363f9366e09b71a69d09", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -2,13 +2,13 @@ trait Reverser {\n     fn reverse(&self);\n }\n \n-impl &[mut uint] : Reverser {\n+impl &mut [uint] : Reverser {\n     fn reverse(&self) {\n         vec::reverse(*self);\n     }\n }\n \n-fn bar(v: &[mut uint]) {\n+fn bar(v: &mut [uint]) {\n     v.reverse();\n     v.reverse();\n     v.reverse();"}, {"sha": "d7e649a8fb684e57d2ca22af113fead0c5c81678", "filename": "src/test/run-pass/empty-mutable-vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fempty-mutable-vec.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -10,4 +10,4 @@\n \n \n \n-pub fn main() { let v: ~[mut int] = ~[mut]; }\n+pub fn main() { let mut v: ~[int] = ~[]; }"}, {"sha": "f6a6ae5ed49e1dff925302e6f051e3903ea79831", "filename": "src/test/run-pass/explicit-self-objects-ext-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-1.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -4,7 +4,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint;\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n }\n \n pub trait ReaderUtil {\n@@ -16,7 +16,7 @@ pub trait ReaderUtil {\n impl<T: Reader> T : ReaderUtil {\n \n     fn read_bytes(&self, len: uint) {\n-        let count = self.read(&[mut 0], len);\n+        let mut count = self.read(&mut [0], len);\n     }\n \n }\n@@ -27,7 +27,7 @@ struct S {\n }\n \n impl S: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         0\n     }\n }"}, {"sha": "f6a6ae5ed49e1dff925302e6f051e3903ea79831", "filename": "src/test/run-pass/explicit-self-objects-ext-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-2.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -4,7 +4,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint;\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n }\n \n pub trait ReaderUtil {\n@@ -16,7 +16,7 @@ pub trait ReaderUtil {\n impl<T: Reader> T : ReaderUtil {\n \n     fn read_bytes(&self, len: uint) {\n-        let count = self.read(&[mut 0], len);\n+        let mut count = self.read(&mut [0], len);\n     }\n \n }\n@@ -27,7 +27,7 @@ struct S {\n }\n \n impl S: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         0\n     }\n }"}, {"sha": "1804c24708bac9f72c37e05fe83298025b5822fa", "filename": "src/test/run-pass/explicit-self-objects-ext-3.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-3.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -4,7 +4,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint;\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint;\n }\n \n pub trait ReaderUtil {\n@@ -16,7 +16,7 @@ pub trait ReaderUtil {\n impl<T: Reader> T : ReaderUtil {\n \n     fn read_bytes(len: uint) {\n-        let count = self.read(&[mut 0], len);\n+        let mut count = self.read(&mut [0], len);\n     }\n \n }\n@@ -27,7 +27,7 @@ struct S {\n }\n \n impl S: Reader {\n-    fn read(&self, bytes: &[mut u8], len: uint) -> uint {\n+    fn read(&self, bytes: &mut [u8], len: uint) -> uint {\n         0\n     }\n }"}, {"sha": "b460131461232d0a7f358270983c5f925f969f3e", "filename": "src/test/run-pass/explicit-self-objects-ext-4.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexplicit-self-objects-ext-4.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -4,7 +4,7 @@ pub trait Reader {\n     /// Read up to len bytes (or EOF) and put them into bytes (which\n     /// must be at least len bytes long). Return number of bytes read.\n     // FIXME (#2982): This should probably return an error.\n-    fn read(bytes: &[mut u8], len: uint) -> uint;\n+    fn read(bytes: &mut [u8], len: uint) -> uint;\n }\n \n pub trait ReaderUtil {\n@@ -16,7 +16,7 @@ pub trait ReaderUtil {\n impl<T: Reader> T : ReaderUtil {\n \n     fn read_bytes(len: uint) {\n-        let count = self.read(&[mut 0], len);\n+        let mut count = self.read(&mut [0], len);\n     }\n \n }\n@@ -27,7 +27,7 @@ struct S {\n }\n \n impl S: Reader {\n-    fn read(bytes: &[mut u8], len: uint) -> uint {\n+    fn read(bytes: &mut [u8], len: uint) -> uint {\n         0\n     }\n }"}, {"sha": "4d7486b72634197f525ea2216564a287588be003", "filename": "src/test/run-pass/foreach-nested.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fforeach-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-nested.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -15,7 +15,7 @@\n fn two(it: fn(int)) { it(0); it(1); }\n \n pub fn main() {\n-    let a: ~[mut int] = ~[mut -1, -1, -1, -1];\n+    let mut a: ~[int] = ~[-1, -1, -1, -1];\n     let mut p: int = 0;\n     do two |i| {\n         do two |j| { a[p] = 10 * i + j; p += 1; }"}, {"sha": "972bd959a1d276c078031409c687b07f60b9aec8", "filename": "src/test/run-pass/impl-variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fimpl-variance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fimpl-variance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimpl-variance.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -21,6 +21,6 @@ pub fn main() {\n     assert v.foo() == 1u;\n     let v = ~[0];\n     assert v.foo() == 1u;\n-    let v = ~[mut 0];\n+    let mut v = ~[0];\n     assert v.foo() == 1u;\n }"}, {"sha": "88f31189a0c8fa725445f6bdb5554d92f0f796a3", "filename": "src/test/run-pass/issue-3563-3.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3563-3.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -51,7 +51,7 @@ struct AsciiArt\n     width: uint,\n     height: uint,\n     priv fill: char,\n-    priv lines: ~[~[mut char]],\n+    priv lines: ~[~[char]],\n \n     // This struct can be quite large so we'll disable copying: developers need\n     // to either pass these structs around via borrowed pointers or move them.\n@@ -65,14 +65,14 @@ fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt\n {\n     // Use an anonymous function to build a vector of vectors containing\n     // blank characters for each position in our canvas.\n-    let lines = do vec::build_sized(height)\n+    let mut lines = do vec::build_sized(height)\n         |push|\n         {\n             for height.times\n             {\n                 let mut line = ~[];   \n                 vec::grow_set(&mut line, width-1, &'.', '.');\n-                push(vec::cast_to_mut(line));\n+                push(line);\n             }\n         };\n \n@@ -84,7 +84,7 @@ fn AsciiArt(width: uint, height: uint, fill: char) -> AsciiArt\n // Methods particular to the AsciiArt struct.\n impl AsciiArt\n {\n-    fn add_pt(x: int, y: int)\n+    fn add_pt(&mut self, x: int, y: int)\n     {\n         if x >= 0 && x < self.width as int\n         {\n@@ -99,7 +99,7 @@ impl AsciiArt\n                 // element is:\n                 // 1) potentially large\n                 // 2) needs to be modified\n-                let row = &self.lines[v];\n+                let row = &mut self.lines[v];\n                 row[h] = self.fill;\n             }\n         }\n@@ -125,12 +125,12 @@ impl AsciiArt : ToStr\n #[allow(default_methods)]\n trait Canvas\n {\n-    fn add_point(shape: Point);\n-    fn add_rect(shape: Rect);\n+    fn add_point(&mut self, shape: Point);\n+    fn add_rect(&mut self, shape: Rect);\n \n     // Unlike interfaces traits support default implementations.\n     // Got an ICE as soon as I added this method.\n-    fn add_points(shapes: &[Point])\n+    fn add_points(&mut self, shapes: &[Point])\n     {\n         for shapes.each |pt| {self.add_point(*pt)};\n     }\n@@ -141,12 +141,12 @@ trait Canvas\n // and code can use them polymorphically via the Canvas trait.\n impl AsciiArt : Canvas\n {\n-    fn add_point(shape: Point)\n+    fn add_point(&mut self, shape: Point)\n     {\n         self.add_pt(shape.x, shape.y);\n     }\n \n-    fn add_rect(shape: Rect)\n+    fn add_rect(&mut self, shape: Rect)\n     {\n         // Add the top and bottom lines.\n         for int::range(shape.top_left.x, shape.top_left.x + shape.size.width)\n@@ -188,7 +188,7 @@ fn test_ascii_art_ctor()\n \n fn test_add_pt()\n {\n-    let art = AsciiArt(3, 3, '*');\n+    let mut art = AsciiArt(3, 3, '*');\n     art.add_pt(0, 0);\n     art.add_pt(0, -10);\n     art.add_pt(1, 2);\n@@ -198,7 +198,7 @@ fn test_add_pt()\n \n fn test_shapes()\n {\n-    let art = AsciiArt(4, 4, '*');\n+    let mut art = AsciiArt(4, 4, '*');\n     art.add_rect(Rect {top_left: Point {x: 0, y: 0}, size: Size {width: 4, height: 4}});\n     art.add_point(Point {x: 2, y: 2});\n     assert check_strs(art.to_str(), \"****\\n*..*\\n*.**\\n****\");"}, {"sha": "db0b24fca1d2d8863980a04bad1d9dcaa62cb285", "filename": "src/test/run-pass/log-linearized.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Flog-linearized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Flog-linearized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-linearized.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -15,12 +15,12 @@ enum option<T> {\n     some(T),\n }\n \n-struct Smallintmap<T> {mut v: ~[mut option<T>]}\n+struct Smallintmap<T> {mut v: ~[option<T>]}\n \n-struct V<T> { v: ~[mut option<T>] }\n+struct V<T> { v: ~[option<T>] }\n \n fn mk<T>() -> @Smallintmap<T> {\n-    let v: ~[mut option<T>] = ~[mut];\n+    let mut v: ~[option<T>] = ~[];\n     return @Smallintmap {mut v: move v};\n }\n "}, {"sha": "c2532369942aa38561956fee2aedd4b75ebeed23", "filename": "src/test/run-pass/maybe-mutable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmaybe-mutable.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -21,6 +21,6 @@ fn len(v: ~[const int]) -> uint {\n pub fn main() {\n     let v0 = ~[1, 2, 3, 4, 5];\n     log(debug, len(v0));\n-    let v1 = ~[mut 1, 2, 3, 4, 5];\n+    let mut v1 = ~[1, 2, 3, 4, 5];\n     log(debug, len(v1));\n }"}, {"sha": "d807791027f5601fe33b55281d7ef5769d0ff558", "filename": "src/test/run-pass/mutable-vec-drop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -13,6 +13,6 @@ struct Pair { a: int, b: int}\n \n pub fn main() {\n     // This just tests whether the vec leaks its members.\n-    let pvec: ~[mut @Pair] =\n-        ~[mut @Pair{a: 1, b: 2}, @Pair{a: 3, b: 4}, @Pair{a: 5, b: 6}];\n+    let mut pvec: ~[@Pair] =\n+        ~[@Pair{a: 1, b: 2}, @Pair{a: 3, b: 4}, @Pair{a: 5, b: 6}];\n }"}, {"sha": "51f4b4c953d0cd73aaeee9389b7486a761d4a4c5", "filename": "src/test/run-pass/rcvr-borrowed-to-slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frcvr-borrowed-to-slice.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -29,7 +29,7 @@ pub fn main() {\n     debug!(\"y==%d\", y);\n     assert y == 6;\n \n-    let x = ~[mut 1, 2, 3];\n+    let mut x = ~[1, 2, 3];\n     let y = x.sum();\n     debug!(\"y==%d\", y);\n     assert y == 6;"}, {"sha": "0f1ad1624c69c7c04df4f6eba8a5b2087bd9f857", "filename": "src/test/run-pass/swap-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fswap-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e08a805b306398b316a489f76960569ac19b25b2/src%2Ftest%2Frun-pass%2Fswap-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fswap-2.rs?ref=e08a805b306398b316a489f76960569ac19b25b2", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-fn swap<T>(v: &[mut T], i: int, j: int) { v[i] <-> v[j]; }\n+fn swap<T>(v: &mut [T], i: int, j: int) { v[i] <-> v[j]; }\n \n pub fn main() {\n-    let a: ~[mut int] = ~[mut 0, 1, 2, 3, 4, 5, 6];\n+    let mut a: ~[int] = ~[0, 1, 2, 3, 4, 5, 6];\n     swap(a, 2, 4);\n     assert (a[2] == 4);\n     assert (a[4] == 2);"}]}