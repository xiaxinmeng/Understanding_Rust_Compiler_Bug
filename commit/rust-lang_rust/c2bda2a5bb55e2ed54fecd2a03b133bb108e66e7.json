{"sha": "c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYmRhMmE1YmI1NWUyZWQ1NGZlY2QyYTAzYjEzM2JiMTA4ZTY2ZTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-01T19:07:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-01T19:07:11Z"}, "message": "Auto merge of #21806 - edwardw:new-range-impl, r=alexcrichton\n\nThe new `::ops::Range` has separated implementations for each of the\r\nnumeric types, while the old `::iter::Range` has one for type `Int`.\r\nHowever, we do not take output bindings into account when selecting\r\ntraits. So it confuses `typeck` and makes the new range does not work as\r\ngood as the old one when it comes to type inference.\r\n\r\nThis patch implements `Iterator` for the new range for one type `Int`.\r\nThis limitation could be lifted, however, if we ever reconsider the\r\noutput types' role in type inference.\r\n\r\nCloses #21595\r\nCloses #21649\r\nCloses #21672", "tree": {"sha": "7ea0304042dc35d8bd08991b4d9a509b06c3f3be", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ea0304042dc35d8bd08991b4d9a509b06c3f3be"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7", "html_url": "https://github.com/rust-lang/rust/commit/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76ce1ea42158b5be3f3896df708602918d202947", "url": "https://api.github.com/repos/rust-lang/rust/commits/76ce1ea42158b5be3f3896df708602918d202947", "html_url": "https://github.com/rust-lang/rust/commit/76ce1ea42158b5be3f3896df708602918d202947"}, {"sha": "b9c055cc70816585ccd715f24b5fc965fe286174", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9c055cc70816585ccd715f24b5fc965fe286174", "html_url": "https://github.com/rust-lang/rust/commit/b9c055cc70816585ccd715f24b5fc965fe286174"}], "stats": {"total": 149, "additions": 76, "deletions": 73}, "files": [{"sha": "c782452d4cfca8f05ef8764118c50141f4030adb", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 47, "deletions": 69, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7", "patch": "@@ -2797,93 +2797,71 @@ impl<A: Int> Iterator for RangeStepInclusive<A> {\n     }\n }\n \n-macro_rules! range_impl {\n+macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Iterator for ::ops::Range<$t> {\n-            type Item = $t;\n-\n+        impl ExactSizeIterator for ::ops::Range<$t> {\n             #[inline]\n-            fn next(&mut self) -> Option<$t> {\n-                if self.start < self.end {\n-                    let result = self.start;\n-                    self.start += 1;\n-                    return Some(result);\n-                }\n-\n-                return None;\n-            }\n-\n-            #[inline]\n-            fn size_hint(&self) -> (usize, Option<usize>) {\n+            fn len(&self) -> usize {\n                 debug_assert!(self.end >= self.start);\n-                let hint = (self.end - self.start) as usize;\n-                (hint, Some(hint))\n+                (self.end - self.start) as usize\n             }\n         }\n-\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl ExactSizeIterator for ::ops::Range<$t> {}\n     )*)\n }\n \n-macro_rules! range_impl_no_hint {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Iterator for ::ops::Range<$t> {\n-            type Item = $t;\n-\n-            #[inline]\n-            fn next(&mut self) -> Option<$t> {\n-                if self.start < self.end {\n-                    let result = self.start;\n-                    self.start += 1;\n-                    return Some(result);\n-                }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Int> Iterator for ::ops::Range<A> {\n+    type Item = A;\n \n-                return None;\n-            }\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        if self.start < self.end {\n+            let result = self.start;\n+            self.start = self.start + Int::one();\n+            Some(result)\n+        } else {\n+            None\n         }\n-    )*)\n-}\n-\n-macro_rules! range_other_impls {\n-    ($($t:ty)*) => ($(\n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl DoubleEndedIterator for ::ops::Range<$t> {\n-            #[inline]\n-            fn next_back(&mut self) -> Option<$t> {\n-                if self.start < self.end {\n-                    self.end -= 1;\n-                    return Some(self.end);\n-                }\n+    }\n \n-                return None;\n-            }\n-        }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        debug_assert!(self.end >= self.start);\n+        let hint = (self.end - self.start).to_uint();\n+        (hint.unwrap_or(0), hint)\n+    }\n+}\n \n-        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl Iterator for ::ops::RangeFrom<$t> {\n-            type Item = $t;\n+range_exact_iter_impl!(usize u8 u16 u32 isize i8 i16 i32);\n+#[cfg(target_pointer_width = \"64\")]\n+range_exact_iter_impl!(u64 i64);\n \n-            #[inline]\n-            fn next(&mut self) -> Option<$t> {\n-                let result = self.start;\n-                self.start += 1;\n-                debug_assert!(result < self.start);\n-                return Some(result);\n-            }\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Int> DoubleEndedIterator for ::ops::Range<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        if self.start < self.end {\n+            self.end = self.end - Int::one();\n+            Some(self.end)\n+        } else {\n+            None\n         }\n-    )*)\n+    }\n }\n \n-range_impl!(usize u8 u16 u32 isize i8 i16 i32);\n-#[cfg(target_pointer_width = \"64\")]\n-range_impl!(u64 i64);\n-#[cfg(target_pointer_width = \"32\")]\n-range_impl_no_hint!(u64 i64);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<A: Int> Iterator for ::ops::RangeFrom<A> {\n+    type Item = A;\n \n-range_other_impls!(usize u8 u16 u32 u64 isize i8 i16 i32 i64);\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        let result = self.start;\n+        self.start = self.start + Int::one();\n+        debug_assert!(result < self.start);\n+        Some(result)\n+    }\n+}\n \n /// An iterator that repeats an element endlessly\n #[derive(Clone)]"}, {"sha": "a8b6e399418f7ef430f333d95aaa993894594ecb", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7", "patch": "@@ -17,10 +17,7 @@ pub fn main() {\n \n     // Float => does not implement iterator.\n     for i in 0f32..42f32 {}\n-    //~^ ERROR `core::iter::Iterator` is not implemented for the type `core::ops::Range<f32>`\n-    //~^^ ERROR\n-    //~^^^ ERROR\n-    // FIXME(#21528) not fulfilled obligation error should be reported once, not thrice\n+    //~^ ERROR the trait `core::num::Int` is not implemented for the type `f32`\n \n     // Unsized type.\n     let arr: &[_] = &[1u32, 2, 3];"}, {"sha": "51945a4677d916c41a81dd48cc90b77717fc659f", "filename": "src/test/run-pass/range-type-infer.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7/src%2Ftest%2Frun-pass%2Frange-type-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7/src%2Ftest%2Frun-pass%2Frange-type-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frange-type-infer.rs?ref=c2bda2a5bb55e2ed54fecd2a03b133bb108e66e7", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure the type inference for the new range expression work as\n+// good as the old one. Check out issue #21672, #21595 and #21649 for\n+// more details.\n+\n+fn main() {\n+    let xs = (0..8).map(|i| i == 1u64).collect::<Vec<_>>();\n+    assert_eq!(xs[1], true);\n+    let xs = (0..8).map(|i| 1u64 == i).collect::<Vec<_>>();\n+    assert_eq!(xs[1], true);\n+    let xs: Vec<u8> = (0..10).collect();\n+    assert_eq!(xs.len(), 10);\n+\n+    for x in 0..10 { x % 2; }\n+    for x in 0..100 { x as f32; }\n+\n+    let array = [true, false];\n+    for i in 0..1 { array[i]; }\n+}"}]}