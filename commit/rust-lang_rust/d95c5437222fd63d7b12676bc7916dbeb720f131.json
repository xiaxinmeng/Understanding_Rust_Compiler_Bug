{"sha": "d95c5437222fd63d7b12676bc7916dbeb720f131", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5NWM1NDM3MjIyZmQ2M2Q3YjEyNjc2YmM3OTE2ZGJlYjcyMGYxMzE=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertaylorj@gmail.com", "date": "2017-02-17T23:12:47Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertaylorj@gmail.com", "date": "2017-03-12T06:26:52Z"}, "message": "Add catch expr to AST and disallow catch as a struct name", "tree": {"sha": "a6090479d0d7489e29aec30a2bb3848b6671c8d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6090479d0d7489e29aec30a2bb3848b6671c8d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d95c5437222fd63d7b12676bc7916dbeb720f131", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d95c5437222fd63d7b12676bc7916dbeb720f131", "html_url": "https://github.com/rust-lang/rust/commit/d95c5437222fd63d7b12676bc7916dbeb720f131", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d95c5437222fd63d7b12676bc7916dbeb720f131/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b19284ad9d85f2848650be6dd466ad0e1e2d82c", "html_url": "https://github.com/rust-lang/rust/commit/1b19284ad9d85f2848650be6dd466ad0e1e2d82c"}], "stats": {"total": 201, "additions": 196, "deletions": 5}, "files": [{"sha": "d92eaee6f0c8ec9e72902fa48a3b5c54aac5b969", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -84,6 +84,7 @@ pub struct LoweringContext<'a> {\n     trait_impls: BTreeMap<DefId, Vec<NodeId>>,\n     trait_default_impl: BTreeMap<DefId, NodeId>,\n \n+    catch_scopes: Vec<NodeId>,\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n \n@@ -123,6 +124,7 @@ pub fn lower_crate(sess: &Session,\n         trait_impls: BTreeMap::new(),\n         trait_default_impl: BTreeMap::new(),\n         exported_macros: Vec::new(),\n+        catch_scopes: Vec::new(),\n         loop_scopes: Vec::new(),\n         is_in_loop_condition: false,\n         type_def_lifetime_params: DefIdMap(),\n@@ -261,6 +263,21 @@ impl<'a> LoweringContext<'a> {\n         span\n     }\n \n+    fn with_catch_scope<T, F>(&mut self, catch_id: NodeId, f: F) -> T\n+        where F: FnOnce(&mut LoweringContext) -> T\n+    {\n+        let len = self.catch_scopes.len();\n+        self.catch_scopes.push(catch_id);\n+\n+        let result = f(self);\n+        assert_eq!(len + 1, self.catch_scopes.len(),\n+            \"catch scopes should be added and removed in stack order\");\n+\n+        self.catch_scopes.pop().unwrap();\n+\n+        result\n+    }\n+\n     fn with_loop_scope<T, F>(&mut self, loop_id: NodeId, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n@@ -295,15 +312,17 @@ impl<'a> LoweringContext<'a> {\n         result\n     }\n \n-    fn with_new_loop_scopes<T, F>(&mut self, f: F) -> T\n+    fn with_new_scopes<T, F>(&mut self, f: F) -> T\n         where F: FnOnce(&mut LoweringContext) -> T\n     {\n         let was_in_loop_condition = self.is_in_loop_condition;\n         self.is_in_loop_condition = false;\n \n+        let catch_scopes = mem::replace(&mut self.catch_scopes, Vec::new());\n         let loop_scopes = mem::replace(&mut self.loop_scopes, Vec::new());\n         let result = f(self);\n-        mem::replace(&mut self.loop_scopes, loop_scopes);\n+        self.catch_scopes = catch_scopes;\n+        self.loop_scopes = loop_scopes;\n \n         self.is_in_loop_condition = was_in_loop_condition;\n \n@@ -1065,7 +1084,7 @@ impl<'a> LoweringContext<'a> {\n                                self.record_body(value, None))\n             }\n             ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, ref body) => {\n-                self.with_new_loop_scopes(|this| {\n+                self.with_new_scopes(|this| {\n                     let body = this.lower_block(body);\n                     let body = this.expr_block(body, ThinVec::new());\n                     let body_id = this.record_body(body, Some(decl));\n@@ -1665,13 +1684,17 @@ impl<'a> LoweringContext<'a> {\n                                       this.lower_opt_sp_ident(opt_ident),\n                                       hir::LoopSource::Loop))\n                 }\n+                ExprKind::Catch(ref body) => {\n+                    // FIXME(cramertj): Add catch to HIR\n+                    self.with_catch_scope(e.id, |this| hir::ExprBlock(this.lower_block(body)))\n+                }\n                 ExprKind::Match(ref expr, ref arms) => {\n                     hir::ExprMatch(P(self.lower_expr(expr)),\n                                    arms.iter().map(|x| self.lower_arm(x)).collect(),\n                                    hir::MatchSource::Normal)\n                 }\n                 ExprKind::Closure(capture_clause, ref decl, ref body, fn_decl_span) => {\n-                    self.with_new_loop_scopes(|this| {\n+                    self.with_new_scopes(|this| {\n                         this.with_parent_def(e.id, |this| {\n                             let expr = this.lower_expr(body);\n                             hir::ExprClosure(this.lower_capture_clause(capture_clause),\n@@ -2069,6 +2092,12 @@ impl<'a> LoweringContext<'a> {\n                     //     Err(err) => #[allow(unreachable_code)]\n                     //                 return Carrier::from_error(From::from(err)),\n                     // }\n+\n+                    // FIXME(cramertj): implement breaking to catch\n+                    if !self.catch_scopes.is_empty() {\n+                        bug!(\"`?` in catch scopes is unimplemented\")\n+                    }\n+\n                     let unstable_span = self.allow_internal_unstable(\"?\", e.span);\n \n                     // Carrier::translate(<expr>)"}, {"sha": "f4e5fd0783b1438f0abcec4f1240eb8c71578bd8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -935,6 +935,8 @@ pub enum ExprKind {\n     Closure(CaptureBy, P<FnDecl>, P<Expr>, Span),\n     /// A block (`{ ... }`)\n     Block(P<Block>),\n+    /// A catch block (`catch { ... }`)\n+    Catch(P<Block>),\n \n     /// An assignment (`a = foo()`)\n     Assign(P<Expr>, P<Expr>),"}, {"sha": "15913d56d162f0cba362d22881b496c066a6fcd0", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -339,6 +339,9 @@ declare_features! (\n \n     // `extern \"x86-interrupt\" fn()`\n     (active, abi_x86_interrupt, \"1.17.0\", Some(40180)),\n+\n+    // Allows the `catch {...}` expression\n+    (active, catch_expr, \"1.17.0\", Some(31436)),\n );\n \n declare_features! (\n@@ -1287,6 +1290,9 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                     }\n                 }\n             }\n+            ast::ExprKind::Catch(_) => {\n+                gate_feature_post!(&self, catch_expr, e.span, \"`catch` expression is experimental\");\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "fe543280264065bfcc4bd1e7670300e261d8fcf7", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -1268,6 +1268,7 @@ pub fn noop_fold_expr<T: Folder>(Expr {id, node, span, attrs}: Expr, folder: &mu\n                 };\n             }\n             ExprKind::Try(ex) => ExprKind::Try(folder.fold_expr(ex)),\n+            ExprKind::Catch(body) => ExprKind::Catch(folder.fold_block(body)),\n         },\n         id: folder.new_id(id),\n         span: folder.new_span(span),"}, {"sha": "c0ee778b7ee9ea8eba7e12cf09fd808455338eee", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -602,6 +602,12 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n+    pub fn error_if_typename_is_catch(&mut self, ident: ast::Ident) {\n+        if ident.name == keywords::Catch.name() {\n+            self.span_err(self.span, \"cannot use `catch` as the name of a type\");\n+        }\n+    }\n+\n     /// Check if the next token is `tok`, and return `true` if so.\n     ///\n     /// This method will automatically add `tok` to `expected_tokens` if `tok` is not\n@@ -2273,6 +2279,11 @@ impl<'a> Parser<'a> {\n                         BlockCheckMode::Unsafe(ast::UserProvided),\n                         attrs);\n                 }\n+                if self.is_catch_expr() {\n+                    assert!(self.eat_keyword(keywords::Catch));\n+                    let lo = self.prev_span.lo;\n+                    return self.parse_catch_expr(lo, attrs);\n+                }\n                 if self.eat_keyword(keywords::Return) {\n                     if self.token.can_begin_expr() {\n                         let e = self.parse_expr()?;\n@@ -3092,6 +3103,16 @@ impl<'a> Parser<'a> {\n         Ok(self.mk_expr(span_lo, hi, ExprKind::Loop(body, opt_ident), attrs))\n     }\n \n+    /// Parse a `catch {...}` expression (`catch` token already eaten)\n+    pub fn parse_catch_expr(&mut self, span_lo: BytePos, mut attrs: ThinVec<Attribute>)\n+        -> PResult<'a, P<Expr>>\n+    {\n+        let (iattrs, body) = self.parse_inner_attrs_and_block()?;\n+        attrs.extend(iattrs);\n+        let hi = body.span.hi;\n+        Ok(self.mk_expr(span_lo, hi, ExprKind::Catch(body), attrs))\n+    }\n+\n     // `match` token already eaten\n     fn parse_match_expr(&mut self, mut attrs: ThinVec<Attribute>) -> PResult<'a, P<Expr>> {\n         let match_span = self.prev_span;\n@@ -3699,6 +3720,14 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    fn is_catch_expr(&mut self) -> bool {\n+        self.token.is_keyword(keywords::Catch) &&\n+        self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n+\n+        // prevent `while catch {} {}`, `if catch {} {} else {}`, etc.\n+        !self.restrictions.contains(Restrictions::RESTRICTION_NO_STRUCT_LITERAL)\n+    }\n+\n     fn is_union_item(&self) -> bool {\n         self.token.is_keyword(keywords::Union) &&\n         self.look_ahead(1, |t| t.is_ident() && !t.is_any_keyword())\n@@ -4875,6 +4904,8 @@ impl<'a> Parser<'a> {\n     /// Parse struct Foo { ... }\n     fn parse_item_struct(&mut self) -> PResult<'a, ItemInfo> {\n         let class_name = self.parse_ident()?;\n+        self.error_if_typename_is_catch(class_name);\n+\n         let mut generics = self.parse_generics()?;\n \n         // There is a special case worth noting here, as reported in issue #17904.\n@@ -4924,6 +4955,8 @@ impl<'a> Parser<'a> {\n     /// Parse union Foo { ... }\n     fn parse_item_union(&mut self) -> PResult<'a, ItemInfo> {\n         let class_name = self.parse_ident()?;\n+        self.error_if_typename_is_catch(class_name);\n+\n         let mut generics = self.parse_generics()?;\n \n         let vdata = if self.token.is_keyword(keywords::Where) {\n@@ -5440,6 +5473,7 @@ impl<'a> Parser<'a> {\n             let struct_def;\n             let mut disr_expr = None;\n             let ident = self.parse_ident()?;\n+            self.error_if_typename_is_catch(ident);\n             if self.check(&token::OpenDelim(token::Brace)) {\n                 // Parse a struct variant.\n                 all_nullary = false;\n@@ -5481,6 +5515,7 @@ impl<'a> Parser<'a> {\n     /// Parse an \"enum\" declaration\n     fn parse_item_enum(&mut self) -> PResult<'a, ItemInfo> {\n         let id = self.parse_ident()?;\n+        self.error_if_typename_is_catch(id);\n         let mut generics = self.parse_generics()?;\n         generics.where_clause = self.parse_where_clause()?;\n         self.expect(&token::OpenDelim(token::Brace))?;"}, {"sha": "c44153d0d32453824fda00e2baea3f31999d14b2", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -2279,6 +2279,11 @@ impl<'a> State<'a> {\n                 self.print_expr(e)?;\n                 word(&mut self.s, \"?\")?\n             }\n+            ast::ExprKind::Catch(ref blk) => {\n+                self.head(\"catch\")?;\n+                space(&mut self.s)?;\n+                self.print_block_with_attrs(&blk, attrs)?\n+            }\n         }\n         self.ann.post(self, NodeExpr(expr))?;\n         self.end()"}, {"sha": "6642c60d256b3c4e40e0cc437ddb60993544e1f6", "filename": "src/libsyntax/symbol.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsymbol.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -221,9 +221,10 @@ declare_keywords! {\n     (53, Default,        \"default\")\n     (54, StaticLifetime, \"'static\")\n     (55, Union,          \"union\")\n+    (56, Catch,          \"catch\")\n \n     // A virtual keyword that resolves to the crate root when used in a lexical scope.\n-    (56, CrateRoot, \"{{root}}\")\n+    (57, CrateRoot, \"{{root}}\")\n }\n \n // If an interner exists in TLS, return it. Otherwise, prepare a fresh one."}, {"sha": "a5333f3bb6a6e46c1f3af1c8e1d30194c194d897", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -779,6 +779,9 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::Try(ref subexpression) => {\n             visitor.visit_expr(subexpression)\n         }\n+        ExprKind::Catch(ref body) => {\n+            visitor.visit_block(body)\n+        }\n     }\n \n     visitor.visit_expr_post(expression)"}, {"sha": "257cb802cc0f870a012e23ab9c7991e92d7f4753", "filename": "src/test/compile-fail/catch-empty-struct-name.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Fcompile-fail%2Fcatch-empty-struct-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Fcompile-fail%2Fcatch-empty-struct-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcatch-empty-struct-name.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types)]\n+#![allow(dead_code)]\n+#![feature(catch_expr)]\n+\n+struct catch; //~ ERROR cannot use `catch` as the name of a type"}, {"sha": "7aa162750d189b28a568bdf9396db1823c24709f", "filename": "src/test/compile-fail/catch-enum-variant.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Fcompile-fail%2Fcatch-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Fcompile-fail%2Fcatch-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcatch-enum-variant.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types)]\n+#![allow(dead_code)]\n+#![feature(catch_expr)]\n+\n+enum Enum {\n+    catch {} //~ ERROR cannot use `catch` as the name of a type\n+}"}, {"sha": "63661ccf607a0d260361cec5ab8a89c09dc58f03", "filename": "src/test/compile-fail/catch-struct-name.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Fcompile-fail%2Fcatch-struct-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Fcompile-fail%2Fcatch-struct-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcatch-struct-name.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types)]\n+#![allow(dead_code)]\n+#![feature(catch_expr)]\n+\n+struct catch {} //~ ERROR cannot use `catch` as the name of a type\n\\ No newline at end of file"}, {"sha": "1a8866d85430d3d6b0f708cd643055eb7b9d6bd7", "filename": "src/test/compile-fail/catch-tuple-struct-name.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Fcompile-fail%2Fcatch-tuple-struct-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Fcompile-fail%2Fcatch-tuple-struct-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcatch-tuple-struct-name.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types)]\n+#![allow(dead_code)]\n+#![feature(catch_expr)]\n+\n+struct catch(); //~ ERROR cannot use `catch` as the name of a type"}, {"sha": "8a1a5ceae89e00716914151bf30e3bb05988e4bf", "filename": "src/test/compile-fail/feature-gate-catch_expr.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Fcompile-fail%2Ffeature-gate-catch_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Fcompile-fail%2Ffeature-gate-catch_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-catch_expr.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn main() {\n+    let catch_result = catch { //~ ERROR `catch` expression is experimental\n+        let x = 5;\n+        x\n+    };\n+    assert_eq!(catch_result, 5);\n+}"}, {"sha": "c70b6100efe4fd83c8af80dfc4d69cdcdbf43592", "filename": "src/test/run-pass/catch-expr.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Frun-pass%2Fcatch-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d95c5437222fd63d7b12676bc7916dbeb720f131/src%2Ftest%2Frun-pass%2Fcatch-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcatch-expr.rs?ref=d95c5437222fd63d7b12676bc7916dbeb720f131", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(catch_expr)]\n+\n+pub fn main() {\n+    let catch_result = catch {\n+        let x = 5;\n+        x\n+    };\n+    assert_eq!(catch_result, 5);\n+\n+    let mut catch = true;\n+    while catch { catch = false; }\n+    assert_eq!(catch, false);\n+\n+    catch = if catch { false } else { true };\n+    assert_eq!(catch, true);\n+\n+    match catch {\n+        _ => {}\n+    };\n+}"}]}