{"sha": "5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmZDJmMDZlOTlhOTg1ZGQ4OTY2ODRjYjJjOWY4YzcwOTBlY2ExYWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-31T17:14:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-31T17:14:44Z"}, "message": "Auto merge of #72767 - pnkfelix:track-devirtualized-filenames-issue-70924, r=eddyb\n\nTrack devirtualized filenames\n\nSplit payload of FileName::Real to track both real and virtualized paths.\n\n(Such splits arise from metadata refs into libstd; the virtualized paths look like `/rustc/1.45.0/src/libstd/io/cursor.rs` rather than `/Users/felixklock/Dev/Mozilla/rust.git/src/libstd/io/cursor.rs`)\n\nThis way, we can emit the virtual name into things like the like the StableSourceFileId (as was done back before PR #70642) that ends up in incremental build artifacts, while still using the devirtualized file path when we want to access the file.\n\nFix #70924", "tree": {"sha": "e3ddf9eeaff46e86c691e6746efc885c8e68f482", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e3ddf9eeaff46e86c691e6746efc885c8e68f482"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "html_url": "https://github.com/rust-lang/rust/commit/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6072cab136beea206b7cfe79f8d10fccf5af591", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6072cab136beea206b7cfe79f8d10fccf5af591", "html_url": "https://github.com/rust-lang/rust/commit/f6072cab136beea206b7cfe79f8d10fccf5af591"}, {"sha": "a8e4236edc1e118ccb6c3f3a8d0139e4cd90b5b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8e4236edc1e118ccb6c3f3a8d0139e4cd90b5b8", "html_url": "https://github.com/rust-lang/rust/commit/a8e4236edc1e118ccb6c3f3a8d0139e4cd90b5b8"}], "stats": {"total": 171, "additions": 130, "deletions": 41}, "files": [{"sha": "13637e58c93645b4edfc20921245be3f649117b5", "filename": "src/librustc_expand/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_expand%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_expand%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fbase.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -1095,7 +1095,7 @@ impl<'a> ExtCtxt<'a> {\n         if !path.is_absolute() {\n             let callsite = span.source_callsite();\n             let mut result = match self.source_map().span_to_unmapped_path(callsite) {\n-                FileName::Real(path) => path,\n+                FileName::Real(name) => name.into_local_path(),\n                 FileName::DocTest(path, _) => path,\n                 other => {\n                     return Err(self.struct_span_err("}, {"sha": "5214ca0dc7fff338ae84eb0bee7e16b366763215", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -341,7 +341,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         let mut module = ModuleData {\n             mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n             directory: match self.cx.source_map().span_to_unmapped_path(krate.span) {\n-                FileName::Real(path) => path,\n+                FileName::Real(name) => name.into_local_path(),\n                 other => PathBuf::from(other.to_string()),\n             },\n         };"}, {"sha": "82215c7297ed6cbbb03723f806cde58979519ce5", "filename": "src/librustc_expand/module.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_expand%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_expand%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fmodule.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -71,7 +71,7 @@ crate fn parse_external_mod(\n     // Extract the directory path for submodules of `module`.\n     let path = sess.source_map().span_to_unmapped_path(module.inner);\n     let mut path = match path {\n-        FileName::Real(path) => path,\n+        FileName::Real(name) => name.into_local_path(),\n         other => PathBuf::from(other.to_string()),\n     };\n     path.pop();\n@@ -189,7 +189,8 @@ fn error_cannot_declare_mod_here<'a, T>(\n     let mut err =\n         sess.span_diagnostic.struct_span_err(span, \"cannot declare a new module at this location\");\n     if !span.is_dummy() {\n-        if let FileName::Real(src_path) = sess.source_map().span_to_filename(span) {\n+        if let FileName::Real(src_name) = sess.source_map().span_to_filename(span) {\n+            let src_path = src_name.into_local_path();\n             if let Some(stem) = src_path.file_stem() {\n                 let mut dest_path = src_path.clone();\n                 dest_path.set_file_name(stem);"}, {"sha": "36af83711f7e4c8ecad9c894c69159a094560ba4", "filename": "src/librustc_expand/proc_macro_server.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_expand%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_expand%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fproc_macro_server.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -602,7 +602,8 @@ impl server::SourceFile for Rustc<'_> {\n     }\n     fn path(&mut self, file: &Self::SourceFile) -> String {\n         match file.name {\n-            FileName::Real(ref path) => path\n+            FileName::Real(ref name) => name\n+                .local_path()\n                 .to_str()\n                 .expect(\"non-UTF8 file path in `proc_macro::SourceFile::path`\")\n                 .to_string(),"}, {"sha": "a01170db807f2fbffa7e6dc088824a49a25a7883", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -33,7 +33,7 @@ use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n-use rustc_span::FileName;\n+use rustc_span::{FileName, RealFileName};\n use rustc_trait_selection::traits;\n use rustc_typeck as typeck;\n \n@@ -569,13 +569,16 @@ fn write_out_deps(\n                 for cnum in resolver.cstore().crates_untracked() {\n                     let source = resolver.cstore().crate_source_untracked(cnum);\n                     if let Some((path, _)) = source.dylib {\n-                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                        let file_name = FileName::Real(RealFileName::Named(path));\n+                        files.push(escape_dep_filename(&file_name));\n                     }\n                     if let Some((path, _)) = source.rlib {\n-                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                        let file_name = FileName::Real(RealFileName::Named(path));\n+                        files.push(escape_dep_filename(&file_name));\n                     }\n                     if let Some((path, _)) = source.rmeta {\n-                        files.push(escape_dep_filename(&FileName::Real(path)));\n+                        let file_name = FileName::Real(RealFileName::Named(path));\n+                        files.push(escape_dep_filename(&file_name));\n                     }\n                 }\n             });"}, {"sha": "f5a9dceb78295707c2b5fc7b9dc66787ddac40cf", "filename": "src/librustc_metadata/rmeta/decoder.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fdecoder.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -1471,15 +1471,22 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n \n             if let Some(virtual_dir) = virtual_rust_source_base_dir {\n                 if let Some(real_dir) = &sess.real_rust_source_base_dir {\n-                    if let rustc_span::FileName::Real(path) = name {\n-                        if let Ok(rest) = path.strip_prefix(virtual_dir) {\n-                            let new_path = real_dir.join(rest);\n-                            debug!(\n-                                \"try_to_translate_virtual_to_real: `{}` -> `{}`\",\n-                                path.display(),\n-                                new_path.display(),\n-                            );\n-                            *path = new_path;\n+                    if let rustc_span::FileName::Real(old_name) = name {\n+                        if let rustc_span::RealFileName::Named(one_path) = old_name {\n+                            if let Ok(rest) = one_path.strip_prefix(virtual_dir) {\n+                                let virtual_name = one_path.clone();\n+                                let new_path = real_dir.join(rest);\n+                                debug!(\n+                                    \"try_to_translate_virtual_to_real: `{}` -> `{}`\",\n+                                    virtual_name.display(),\n+                                    new_path.display(),\n+                                );\n+                                let new_name = rustc_span::RealFileName::Devirtualized {\n+                                    local_path: new_path,\n+                                    virtual_name,\n+                                };\n+                                *old_name = new_name;\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "9964c9c94c9510594f7c4337c676031805661a03", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -396,6 +396,7 @@ impl<'tcx> EncodeContext<'tcx> {\n                     // any relative paths are potentially relative to a\n                     // wrong directory.\n                     FileName::Real(ref name) => {\n+                        let name = name.stable_name();\n                         let mut adapted = (**source_file).clone();\n                         adapted.name = Path::new(&working_dir).join(name).into();\n                         adapted.name_hash = {"}, {"sha": "d5f992b0de05d70d4ee3071830eb97ec52ad30af", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -16,12 +16,13 @@ impl<'a> SpanUtils<'a> {\n \n     pub fn make_filename_string(&self, file: &SourceFile) -> String {\n         match &file.name {\n-            FileName::Real(path) if !file.name_was_remapped => {\n+            FileName::Real(name) if !file.name_was_remapped => {\n+                let path = name.local_path();\n                 if path.is_absolute() {\n                     self.sess\n                         .source_map()\n                         .path_mapping()\n-                        .map_prefix(path.clone())\n+                        .map_prefix(path.into())\n                         .0\n                         .display()\n                         .to_string()"}, {"sha": "c7d2205eb1c2739451e677cb8b3a026cf1af0c00", "filename": "src/librustc_span/lib.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_span%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_span%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Flib.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -53,7 +53,7 @@ use std::cmp::{self, Ordering};\n use std::fmt;\n use std::hash::Hash;\n use std::ops::{Add, Sub};\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n use md5::Md5;\n@@ -81,11 +81,61 @@ impl Globals {\n \n scoped_tls::scoped_thread_local!(pub static GLOBALS: Globals);\n \n+// FIXME: Perhaps this should not implement Rustc{Decodable, Encodable}\n+//\n+// FIXME: We should use this enum or something like it to get rid of the\n+// use of magic `/rust/1.x/...` paths across the board.\n+#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(HashStable_Generic)]\n+pub enum RealFileName {\n+    Named(PathBuf),\n+    /// For de-virtualized paths (namely paths into libstd that have been mapped\n+    /// to the appropriate spot on the local host's file system),\n+    Devirtualized {\n+        /// `local_path` is the (host-dependent) local path to the file.\n+        local_path: PathBuf,\n+        /// `virtual_name` is the stable path rustc will store internally within\n+        /// build artifacts.\n+        virtual_name: PathBuf,\n+    },\n+}\n+\n+impl RealFileName {\n+    /// Returns the path suitable for reading from the file system on the local host.\n+    /// Avoid embedding this in build artifacts; see `stable_name` for that.\n+    pub fn local_path(&self) -> &Path {\n+        match self {\n+            RealFileName::Named(p)\n+            | RealFileName::Devirtualized { local_path: p, virtual_name: _ } => &p,\n+        }\n+    }\n+\n+    /// Returns the path suitable for reading from the file system on the local host.\n+    /// Avoid embedding this in build artifacts; see `stable_name` for that.\n+    pub fn into_local_path(self) -> PathBuf {\n+        match self {\n+            RealFileName::Named(p)\n+            | RealFileName::Devirtualized { local_path: p, virtual_name: _ } => p,\n+        }\n+    }\n+\n+    /// Returns the path suitable for embedding into build artifacts. Note that\n+    /// a virtualized path will not correspond to a valid file system path; see\n+    /// `local_path` for something that is more likely to return paths into the\n+    /// local host file system.\n+    pub fn stable_name(&self) -> &Path {\n+        match self {\n+            RealFileName::Named(p)\n+            | RealFileName::Devirtualized { local_path: _, virtual_name: p } => &p,\n+        }\n+    }\n+}\n+\n /// Differentiates between real files and common virtual files.\n #[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash, RustcDecodable, RustcEncodable)]\n #[derive(HashStable_Generic)]\n pub enum FileName {\n-    Real(PathBuf),\n+    Real(RealFileName),\n     /// Call to `quote!`.\n     QuoteExpansion(u64),\n     /// Command line.\n@@ -109,7 +159,13 @@ impl std::fmt::Display for FileName {\n     fn fmt(&self, fmt: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n         use FileName::*;\n         match *self {\n-            Real(ref path) => write!(fmt, \"{}\", path.display()),\n+            Real(RealFileName::Named(ref path)) => write!(fmt, \"{}\", path.display()),\n+            // FIXME: might be nice to display both compoments of Devirtualized.\n+            // But for now (to backport fix for issue #70924), best to not\n+            // perturb diagnostics so its obvious test suite still works.\n+            Real(RealFileName::Devirtualized { ref local_path, virtual_name: _ }) => {\n+                write!(fmt, \"{}\", local_path.display())\n+            }\n             QuoteExpansion(_) => write!(fmt, \"<quote expansion>\"),\n             MacroExpansion(_) => write!(fmt, \"<macro expansion>\"),\n             Anon(_) => write!(fmt, \"<anon>\"),\n@@ -126,7 +182,7 @@ impl std::fmt::Display for FileName {\n impl From<PathBuf> for FileName {\n     fn from(p: PathBuf) -> Self {\n         assert!(!p.to_string_lossy().ends_with('>'));\n-        FileName::Real(p)\n+        FileName::Real(RealFileName::Named(p))\n     }\n }\n "}, {"sha": "c33c1dd29cb72a935c3ecf8960b8d46e317e9dc1", "filename": "src/librustc_span/source_map.rs", "status": "modified", "additions": 28, "deletions": 10, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_span%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustc_span%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsource_map.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -86,6 +86,8 @@ impl FileLoader for RealFileLoader {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, Debug)]\n pub struct StableSourceFileId(u128);\n \n+// FIXME: we need a more globally consistent approach to the problem solved by\n+// StableSourceFileId, perhaps built atop source_file.name_hash.\n impl StableSourceFileId {\n     pub fn new(source_file: &SourceFile) -> StableSourceFileId {\n         StableSourceFileId::new_from_pieces(\n@@ -95,14 +97,21 @@ impl StableSourceFileId {\n         )\n     }\n \n-    pub fn new_from_pieces(\n+    fn new_from_pieces(\n         name: &FileName,\n         name_was_remapped: bool,\n         unmapped_path: Option<&FileName>,\n     ) -> StableSourceFileId {\n         let mut hasher = StableHasher::new();\n \n-        name.hash(&mut hasher);\n+        if let FileName::Real(real_name) = name {\n+            // rust-lang/rust#70924: Use the stable (virtualized) name when\n+            // available. (We do not want artifacts from transient file system\n+            // paths for libstd to leak into our build artifacts.)\n+            real_name.stable_name().hash(&mut hasher)\n+        } else {\n+            name.hash(&mut hasher);\n+        }\n         name_was_remapped.hash(&mut hasher);\n         unmapped_path.hash(&mut hasher);\n \n@@ -235,7 +244,7 @@ impl SourceMap {\n \n     fn try_new_source_file(\n         &self,\n-        filename: FileName,\n+        mut filename: FileName,\n         src: String,\n     ) -> Result<Lrc<SourceFile>, OffsetOverflowError> {\n         // The path is used to determine the directory for loading submodules and\n@@ -245,13 +254,22 @@ impl SourceMap {\n         // be empty, so the working directory will be used.\n         let unmapped_path = filename.clone();\n \n-        let (filename, was_remapped) = match filename {\n-            FileName::Real(filename) => {\n-                let (filename, was_remapped) = self.path_mapping.map_prefix(filename);\n-                (FileName::Real(filename), was_remapped)\n+        let was_remapped;\n+        if let FileName::Real(real_filename) = &mut filename {\n+            match real_filename {\n+                RealFileName::Named(path_to_be_remapped)\n+                | RealFileName::Devirtualized {\n+                    local_path: path_to_be_remapped,\n+                    virtual_name: _,\n+                } => {\n+                    let mapped = self.path_mapping.map_prefix(path_to_be_remapped.clone());\n+                    was_remapped = mapped.1;\n+                    *path_to_be_remapped = mapped.0;\n+                }\n             }\n-            other => (other, false),\n-        };\n+        } else {\n+            was_remapped = false;\n+        }\n \n         let file_id =\n             StableSourceFileId::new_from_pieces(&filename, was_remapped, Some(&unmapped_path));\n@@ -998,7 +1016,7 @@ impl SourceMap {\n     }\n     pub fn ensure_source_file_source_present(&self, source_file: Lrc<SourceFile>) -> bool {\n         source_file.add_external_src(|| match source_file.name {\n-            FileName::Real(ref name) => self.file_loader.read_file(name).ok(),\n+            FileName::Real(ref name) => self.file_loader.read_file(name.local_path()).ok(),\n             _ => None,\n         })\n     }"}, {"sha": "07631093edda4039b781a5211e437fb904e81a58", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -473,7 +473,7 @@ pub fn run(\n     } = options;\n \n     let src_root = match krate.src {\n-        FileName::Real(ref p) => match p.parent() {\n+        FileName::Real(ref p) => match p.local_path().parent() {\n             Some(p) => p.to_path_buf(),\n             None => PathBuf::new(),\n         },\n@@ -1621,9 +1621,10 @@ impl Context {\n \n         // We can safely ignore synthetic `SourceFile`s.\n         let file = match item.source.filename {\n-            FileName::Real(ref path) => path,\n+            FileName::Real(ref path) => path.local_path().to_path_buf(),\n             _ => return None,\n         };\n+        let file = &file;\n \n         let (krate, path) = if item.source.cnum == LOCAL_CRATE {\n             if let Some(path) = self.shared.local_sources.get(file) {"}, {"sha": "225940773413e4519ff23bdc5a0afde3bbd1267b", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -173,7 +173,7 @@ impl Cache {\n         // Cache where all our extern crates are located\n         for &(n, ref e) in &krate.externs {\n             let src_root = match e.src {\n-                FileName::Real(ref p) => match p.parent() {\n+                FileName::Real(ref p) => match p.local_path().parent() {\n                     Some(p) => p.to_path_buf(),\n                     None => PathBuf::new(),\n                 },"}, {"sha": "018c0e82c4561c1d41e19328c56de4ccb1b9042e", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -67,10 +67,10 @@ impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n     fn emit_source(&mut self, filename: &FileName) -> Result<(), Error> {\n         let p = match *filename {\n-            FileName::Real(ref file) => file,\n+            FileName::Real(ref file) => file.local_path().to_path_buf(),\n             _ => return Ok(()),\n         };\n-        if self.scx.local_sources.contains_key(&**p) {\n+        if self.scx.local_sources.contains_key(&*p) {\n             // We've already emitted this source\n             return Ok(());\n         }"}, {"sha": "4b15a591da71f2b05bc954ac56190ec0d99972dd", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd2f06e99a985dd896684cb2c9f8c7090eca1ab/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=5fd2f06e99a985dd896684cb2c9f8c7090eca1ab", "patch": "@@ -688,7 +688,7 @@ impl Collector {\n             let filename = source_map.span_to_filename(self.position);\n             if let FileName::Real(ref filename) = filename {\n                 if let Ok(cur_dir) = env::current_dir() {\n-                    if let Ok(path) = filename.strip_prefix(&cur_dir) {\n+                    if let Ok(path) = filename.local_path().strip_prefix(&cur_dir) {\n                         return path.to_owned().into();\n                     }\n                 }\n@@ -718,7 +718,7 @@ impl Tester for Collector {\n         // FIXME(#44940): if doctests ever support path remapping, then this filename\n         // needs to be the result of `SourceMap::span_to_unmapped_path`.\n         let path = match &filename {\n-            FileName::Real(path) => path.clone(),\n+            FileName::Real(path) => path.local_path().to_path_buf(),\n             _ => PathBuf::from(r\"doctest.rs\"),\n         };\n "}]}