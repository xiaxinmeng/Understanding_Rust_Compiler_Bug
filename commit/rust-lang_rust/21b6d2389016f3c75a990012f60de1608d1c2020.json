{"sha": "21b6d2389016f3c75a990012f60de1608d1c2020", "node_id": "C_kwDOAAsO6NoAKDIxYjZkMjM4OTAxNmYzYzc1YTk5MDAxMmY2MGRlMTYwOGQxYzIwMjA", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-24T13:49:00Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-27T20:03:26Z"}, "message": "Collect extra lifetime parameters during late resolution.", "tree": {"sha": "710bfb7cb08b7e33d373b4d14a2a89d1e0e241b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/710bfb7cb08b7e33d373b4d14a2a89d1e0e241b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21b6d2389016f3c75a990012f60de1608d1c2020", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21b6d2389016f3c75a990012f60de1608d1c2020", "html_url": "https://github.com/rust-lang/rust/commit/21b6d2389016f3c75a990012f60de1608d1c2020", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21b6d2389016f3c75a990012f60de1608d1c2020/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b590e3062ce20d551366d3f045d5637bd2c34e63", "url": "https://api.github.com/repos/rust-lang/rust/commits/b590e3062ce20d551366d3f045d5637bd2c34e63", "html_url": "https://github.com/rust-lang/rust/commit/b590e3062ce20d551366d3f045d5637bd2c34e63"}], "stats": {"total": 360, "additions": 138, "deletions": 222}, "files": [{"sha": "90339f8ee2b69a73b72519e7d6cb3ea2f6c24a60", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 22, "deletions": 63, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/21b6d2389016f3c75a990012f60de1608d1c2020/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21b6d2389016f3c75a990012f60de1608d1c2020/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=21b6d2389016f3c75a990012f60de1608d1c2020", "patch": "@@ -84,9 +84,6 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             generator_kind: None,\n             task_context: None,\n             current_item: None,\n-            lifetimes_to_define: Default::default(),\n-            is_collecting_anonymous_lifetimes: None,\n-            in_scope_lifetimes: Vec::new(),\n             captured_lifetimes: None,\n             allow_try_trait: Some([sym::try_trait_v2][..].into()),\n             allow_gen_future: Some([sym::gen_future][..].into()),\n@@ -149,36 +146,8 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             // This is used to track which lifetimes have already been defined,\n             // and which need to be replicated when lowering an async fn.\n             match parent_hir.node().expect_item().kind {\n-                hir::ItemKind::Impl(hir::Impl { ref of_trait, ref generics, .. }) => {\n+                hir::ItemKind::Impl(hir::Impl { ref of_trait, .. }) => {\n                     lctx.is_in_trait_impl = of_trait.is_some();\n-                    lctx.in_scope_lifetimes = generics\n-                        .params\n-                        .iter()\n-                        .filter(|param| {\n-                            matches!(param.kind, hir::GenericParamKind::Lifetime { .. })\n-                        })\n-                        .map(|param| {\n-                            let def_id =\n-                                parent_hir.nodes.local_id_to_def_id[&param.hir_id.local_id];\n-                            let name = param.name;\n-                            (name, def_id)\n-                        })\n-                        .collect();\n-                }\n-                hir::ItemKind::Trait(_, _, ref generics, ..) => {\n-                    lctx.in_scope_lifetimes = generics\n-                        .params\n-                        .iter()\n-                        .filter(|param| {\n-                            matches!(param.kind, hir::GenericParamKind::Lifetime { .. })\n-                        })\n-                        .map(|param| {\n-                            let def_id =\n-                                parent_hir.nodes.local_id_to_def_id[&param.hir_id.local_id];\n-                            let name = param.name;\n-                            (name, def_id)\n-                        })\n-                        .collect();\n                 }\n                 _ => {}\n             };\n@@ -286,7 +255,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ref body,\n                 ..\n             }) => {\n-                let fn_def_id = self.resolver.local_def_id(id);\n                 self.with_new_scopes(|this| {\n                     this.current_item = Some(ident.span);\n \n@@ -299,7 +267,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n \n                     let (generics, decl) =\n-                        this.add_implicit_generics(generics, fn_def_id, |this, idty| {\n+                        this.add_implicit_generics(generics, id, |this, idty| {\n                             let ret_id = asyncness.opt_return_id();\n                             this.lower_fn_decl(&decl, Some((id, idty)), FnDeclKind::Fn, ret_id)\n                         });\n@@ -415,9 +383,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // method, it will not be considered an in-band\n                 // lifetime to be added, but rather a reference to a\n                 // parent lifetime.\n-                let lowered_trait_def_id = hir_id.expect_owner();\n                 let (generics, (trait_ref, lowered_ty)) =\n-                    self.add_implicit_generics(ast_generics, lowered_trait_def_id, |this, _| {\n+                    self.add_implicit_generics(ast_generics, id, |this, _| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(\n                                 trait_ref,\n@@ -431,12 +398,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         (trait_ref, lowered_ty)\n                     });\n \n-                let new_impl_items =\n-                    self.with_in_scope_lifetime_defs(&ast_generics.params, |this| {\n-                        this.arena.alloc_from_iter(\n-                            impl_items.iter().map(|item| this.lower_impl_item_ref(item)),\n-                        )\n-                    });\n+                let new_impl_items = self\n+                    .arena\n+                    .alloc_from_iter(impl_items.iter().map(|item| self.lower_impl_item_ref(item)));\n \n                 // `defaultness.has_value()` is never called for an `impl`, always `true` in order\n                 // to not cause an assertion failure inside the `lower_defaultness` function.\n@@ -743,7 +707,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n                     let fdec = &sig.decl;\n                     let (generics, (fn_dec, fn_args)) =\n-                        self.add_implicit_generics(generics, def_id, |this, _| {\n+                        self.add_implicit_generics(generics, i.id, |this, _| {\n                             (\n                                 // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(fdec, None, FnDeclKind::ExternFn, None),\n@@ -1343,9 +1307,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         kind: FnDeclKind,\n         is_async: Option<NodeId>,\n     ) -> (hir::Generics<'hir>, hir::FnSig<'hir>) {\n-        let fn_def_id = self.resolver.local_def_id(id);\n         let header = self.lower_fn_header(sig.header);\n-        let (generics, decl) = self.add_implicit_generics(generics, fn_def_id, |this, idty| {\n+        let (generics, decl) = self.add_implicit_generics(generics, id, |this, idty| {\n             this.lower_fn_decl(&sig.decl, Some((id, idty)), kind, is_async)\n         });\n         (generics, hir::FnSig { header, decl, span: self.lower_span(sig.span) })\n@@ -1487,24 +1450,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ref bounded_ty,\n                 ref bounds,\n                 span,\n-            }) => self.with_in_scope_lifetime_defs(&bound_generic_params, |this| {\n-                hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                    bound_generic_params: this.lower_generic_params(\n-                        bound_generic_params,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    ),\n-                    bounded_ty: this.lower_ty(\n-                        bounded_ty,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Type),\n-                    ),\n-                    bounds: this.arena.alloc_from_iter(bounds.iter().map(|bound| {\n-                        this.lower_param_bound(\n-                            bound,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n-                        )\n-                    })),\n-                    span: this.lower_span(span),\n-                })\n+            }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                bound_generic_params: self.lower_generic_params(\n+                    bound_generic_params,\n+                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                ),\n+                bounded_ty: self\n+                    .lower_ty(bounded_ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n+                bounds: self.arena.alloc_from_iter(bounds.iter().map(|bound| {\n+                    self.lower_param_bound(\n+                        bound,\n+                        ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n+                    )\n+                })),\n+                span: self.lower_span(span),\n             }),\n             WherePredicate::RegionPredicate(WhereRegionPredicate {\n                 ref lifetime,"}, {"sha": "b71d81f11da8babf7d8cfd4d30ef680b66a8d62f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 72, "deletions": 150, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/21b6d2389016f3c75a990012f60de1608d1c2020/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21b6d2389016f3c75a990012f60de1608d1c2020/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=21b6d2389016f3c75a990012f60de1608d1c2020", "patch": "@@ -45,7 +45,7 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n@@ -122,20 +122,6 @@ struct LoweringContext<'a, 'hir: 'a> {\n     is_in_trait_impl: bool,\n     is_in_dyn_type: bool,\n \n-    /// Used to create lifetime definitions for anonymous lifetimes.\n-    /// When an anonymous lifetime is encountered in a function or impl header and\n-    /// requires to create a fresh lifetime parameter, it is added\n-    /// to this list. The results of this list are then added to the list of\n-    /// lifetime definitions in the corresponding impl or function generics.\n-    lifetimes_to_define: FxIndexMap<NodeId, Span>,\n-\n-    /// If anonymous lifetimes are being collected, this field holds the parent\n-    /// `LocalDefId` to create the fresh lifetime parameters' `LocalDefId`.\n-    is_collecting_anonymous_lifetimes: Option<LocalDefId>,\n-\n-    /// Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n-    in_scope_lifetimes: Vec<(ParamName, LocalDefId)>,\n-\n     /// Used to handle lifetimes appearing in impl-traits.\n     captured_lifetimes: Option<LifetimeCaptureContext>,\n \n@@ -173,8 +159,6 @@ pub enum LifetimeRes {\n     Fresh {\n         /// Id of the generic parameter that introduced it.\n         param: LocalDefId,\n-        /// Id to create the HirId.  This is used when creating the `Fresh` lifetime parameters.\n-        introducer: Option<NodeId>,\n         /// Id of the introducing place. See `Param`.\n         binder: NodeId,\n     },\n@@ -237,6 +221,9 @@ pub trait ResolverAstLowering {\n     /// Obtains resolution for a lifetime with the given `NodeId`.\n     fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n \n+    /// Obtain the list of lifetimes parameters to add to an item.\n+    fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)>;\n+\n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_>;\n \n     fn definitions(&self) -> &Definitions;\n@@ -694,46 +681,34 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     /// Converts a lifetime into a new generic parameter.\n-    fn fresh_lifetime_to_generic_param(\n+    fn lifetime_res_to_generic_param(\n         &mut self,\n-        span: Span,\n+        ident: Ident,\n         node_id: NodeId,\n-    ) -> hir::GenericParam<'hir> {\n+        res: LifetimeRes,\n+    ) -> Option<hir::GenericParam<'hir>> {\n+        let (name, kind) = match res {\n+            LifetimeRes::Param { .. } => {\n+                (hir::ParamName::Plain(ident), hir::LifetimeParamKind::Explicit)\n+            }\n+            LifetimeRes::Fresh { param, .. } => {\n+                (hir::ParamName::Fresh(param), hir::LifetimeParamKind::Elided)\n+            }\n+            LifetimeRes::Static | LifetimeRes::Error => return None,\n+            res => panic!(\n+                \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n+                res, ident, ident.span\n+            ),\n+        };\n         let hir_id = self.lower_node_id(node_id);\n-        let def_id = self.resolver.local_def_id(node_id);\n-        hir::GenericParam {\n+        Some(hir::GenericParam {\n             hir_id,\n-            name: hir::ParamName::Fresh(def_id),\n+            name,\n             bounds: &[],\n-            span: self.lower_span(span),\n+            span: self.lower_span(ident.span),\n             pure_wrt_drop: false,\n-            kind: hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Elided },\n-        }\n-    }\n-\n-    /// Evaluates `f` with the lifetimes in `params` in-scope.\n-    /// This is used to track which lifetimes have already been defined,\n-    /// which need to be duplicated for async fns.\n-    fn with_in_scope_lifetime_defs<T>(\n-        &mut self,\n-        params: &[GenericParam],\n-        f: impl FnOnce(&mut Self) -> T,\n-    ) -> T {\n-        let old_len = self.in_scope_lifetimes.len();\n-        let lt_def_names = params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => {\n-                let def_id = self.resolver.local_def_id(param.id);\n-                let name = ParamName::Plain(param.ident);\n-                Some((name, def_id))\n-            }\n-            _ => None,\n-        });\n-        self.in_scope_lifetimes.extend(lt_def_names);\n-\n-        let res = f(self);\n-\n-        self.in_scope_lifetimes.truncate(old_len);\n-        res\n+            kind: hir::GenericParamKind::Lifetime { kind },\n+        })\n     }\n \n     /// Creates a new `hir::GenericParam` for every new `Fresh` lifetime and\n@@ -742,39 +717,23 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn add_implicit_generics<T>(\n         &mut self,\n         generics: &Generics,\n-        parent_def_id: LocalDefId,\n+        parent_node_id: NodeId,\n         f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     ) -> (hir::Generics<'hir>, T) {\n-        let lifetime_stash = std::mem::take(&mut self.lifetimes_to_define);\n-        let was_collecting =\n-            std::mem::replace(&mut self.is_collecting_anonymous_lifetimes, Some(parent_def_id));\n-\n         let mut impl_trait_defs = Vec::new();\n+        let mut lowered_generics = self.lower_generics_mut(\n+            generics,\n+            ImplTraitContext::Universal(&mut impl_trait_defs, self.current_hir_id_owner),\n+        );\n+        let res = f(self, &mut impl_trait_defs);\n \n-        let (mut lowered_generics, res) =\n-            self.with_in_scope_lifetime_defs(&generics.params, |this| {\n-                // Note: it is necessary to lower generics *before* calling `f`.\n-                // When lowering `async fn`, there's a final step when lowering\n-                // the return type that assumes that all in-scope lifetimes have\n-                // already been added to either `in_scope_lifetimes` or\n-                // `lifetimes_to_define`. If we swapped the order of these two,\n-                // fresh lifetimes introduced by generics or where-clauses\n-                // wouldn't have been added yet.\n-                let generics = this.lower_generics_mut(\n-                    generics,\n-                    ImplTraitContext::Universal(&mut impl_trait_defs, this.current_hir_id_owner),\n-                );\n-                let res = f(this, &mut impl_trait_defs);\n-                (generics, res)\n-            });\n-\n-        self.is_collecting_anonymous_lifetimes = was_collecting;\n-        let lifetimes_to_define = std::mem::replace(&mut self.lifetimes_to_define, lifetime_stash);\n-\n+        let extra_lifetimes = self.resolver.take_extra_lifetime_params(parent_node_id);\n         lowered_generics.params.extend(\n-            lifetimes_to_define\n+            extra_lifetimes\n                 .into_iter()\n-                .map(|(node_id, span)| self.fresh_lifetime_to_generic_param(span, node_id))\n+                .filter_map(|(ident, node_id, res)| {\n+                    self.lifetime_res_to_generic_param(ident, node_id, res)\n+                })\n                 .chain(impl_trait_defs),\n         );\n \n@@ -1227,19 +1186,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 let lifetime = self.lower_lifetime(&region);\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n-            TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(&f.generic_params, |this| {\n-                this.with_lifetime_binder(t.id, |this| {\n-                    hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n-                        generic_params: this.lower_generic_params(\n-                            &f.generic_params,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                        ),\n-                        unsafety: this.lower_unsafety(f.unsafety),\n-                        abi: this.lower_extern(f.ext),\n-                        decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n-                        param_names: this.lower_fn_params_to_names(&f.decl),\n-                    }))\n-                })\n+            TyKind::BareFn(ref f) => self.with_lifetime_binder(t.id, |this| {\n+                hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n+                    generic_params: this.lower_generic_params(\n+                        &f.generic_params,\n+                        ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    ),\n+                    unsafety: this.lower_unsafety(f.unsafety),\n+                    abi: this.lower_extern(f.ext),\n+                    decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n+                    param_names: this.lower_fn_params_to_names(&f.decl),\n+                }))\n             }),\n             TyKind::Never => hir::TyKind::Never,\n             TyKind::Tup(ref tys) => {\n@@ -1676,70 +1633,50 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // should be figured out using the ordinary elision rules, and\n         // this desugaring achieves that.\n \n-        debug!(\"lower_async_fn_ret_ty: in_scope_lifetimes={:#?}\", self.in_scope_lifetimes);\n-        debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", self.lifetimes_to_define);\n-\n         // Calculate all the lifetimes that should be captured\n         // by the opaque type. This should include all in-scope\n         // lifetime parameters, including those defined in-band.\n \n-        // Input lifetime like `'a`:\n         let mut captures = FxHashMap::default();\n-        for &(p_name, def_id) in &self.in_scope_lifetimes {\n-            let Ident { name, span } = p_name.ident();\n-            let node_id = self.resolver.next_node_id();\n+\n+        let extra_lifetime_params = self.resolver.take_extra_lifetime_params(opaque_ty_node_id);\n+        debug!(?extra_lifetime_params);\n+        for (ident, outer_node_id, outer_res) in extra_lifetime_params {\n+            let Ident { name, span } = ident;\n+            let outer_def_id = self.resolver.local_def_id(outer_node_id);\n+            let inner_node_id = self.resolver.next_node_id();\n \n             // Add a definition for the in scope lifetime def.\n             self.resolver.create_def(\n                 opaque_ty_def_id,\n-                node_id,\n+                inner_node_id,\n                 DefPathData::LifetimeNs(name),\n                 ExpnId::root(),\n                 span.with_parent(None),\n             );\n \n-            let res = match p_name {\n-                hir::ParamName::Plain(_) => {\n-                    LifetimeRes::Param { param: def_id, binder: fn_node_id }\n+            let (p_name, inner_res) = match outer_res {\n+                // Input lifetime like `'a`:\n+                LifetimeRes::Param { param, .. } => {\n+                    (hir::ParamName::Plain(ident), LifetimeRes::Param { param, binder: fn_node_id })\n                 }\n-                hir::ParamName::Fresh(_) => {\n-                    LifetimeRes::Fresh { param: def_id, introducer: None, binder: fn_node_id }\n+                // Input lifetime like `'1`:\n+                LifetimeRes::Fresh { param, .. } => (\n+                    hir::ParamName::Fresh(outer_def_id),\n+                    LifetimeRes::Fresh { param, binder: fn_node_id },\n+                ),\n+                LifetimeRes::Static | LifetimeRes::Error => continue,\n+                res => {\n+                    panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span)\n                 }\n-                hir::ParamName::Error => LifetimeRes::Error,\n             };\n \n-            captures.insert(def_id, (span, node_id, p_name, res));\n-        }\n-\n-        // Input lifetime like `'1`:\n-        for (&node_id, &span) in &self.lifetimes_to_define {\n-            let def_id = self.resolver.local_def_id(node_id);\n-            let new_node_id = self.resolver.next_node_id();\n-\n-            // Add a definition for the `Fresh` lifetime def.\n-            let new_def_id = self.resolver.create_def(\n-                opaque_ty_def_id,\n-                new_node_id,\n-                DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-                ExpnId::root(),\n-                span.with_parent(None),\n-            );\n-\n-            captures.insert(\n-                def_id,\n-                (\n-                    span,\n-                    new_node_id,\n-                    hir::ParamName::Fresh(new_def_id),\n-                    LifetimeRes::Fresh { param: def_id, introducer: None, binder: fn_node_id },\n-                ),\n-            );\n+            captures.insert(outer_def_id, (span, inner_node_id, p_name, inner_res));\n         }\n \n         debug!(?captures);\n \n         self.with_hir_id_owner(opaque_ty_node_id, |this| {\n-            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", this.lifetimes_to_define);\n             let future_bound =\n                 this.while_capturing_lifetimes(opaque_ty_def_id, &mut captures, |this| {\n                     // We have to be careful to get elision right here. The\n@@ -1923,11 +1860,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 }\n                 hir::LifetimeName::Param(p_name)\n             }\n-            LifetimeRes::Fresh { mut param, introducer, binder } => {\n+            LifetimeRes::Fresh { mut param, binder } => {\n                 debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n-                // Only items are allowed to introduce fresh lifetimes,\n-                // so we know `binder` has a `LocalDefId`.\n-                let binder_def_id = self.resolver.local_def_id(binder);\n                 if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n                     &mut self.captured_lifetimes\n                     && !binders_to_ignore.contains(&binder)\n@@ -1949,16 +1883,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             param = p_def_id;\n                         }\n                     }\n-                } else if let Some(introducer) = introducer {\n-                    if self.is_collecting_anonymous_lifetimes == Some(binder_def_id)\n-                        && self.resolver.opt_local_def_id(introducer) == Some(param)\n-                    {\n-                        debug!(\n-                            \"lifetime_to_define += id={:?} span={:?} res={:?}\",\n-                            introducer, span, res\n-                        );\n-                        self.lifetimes_to_define.insert(introducer, span);\n-                    }\n                 }\n                 let p_name = ParamName::Fresh(param);\n                 hir::LifetimeName::Param(p_name)\n@@ -2091,10 +2015,8 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let bound_generic_params =\n             self.lower_generic_params(&p.bound_generic_params, itctx.reborrow());\n \n-        let trait_ref = self.with_in_scope_lifetime_defs(&p.bound_generic_params, |this| {\n-            this.with_lifetime_binder(p.trait_ref.ref_id, |this| {\n-                this.lower_trait_ref(&p.trait_ref, itctx.reborrow())\n-            })\n+        let trait_ref = self.with_lifetime_binder(p.trait_ref.ref_id, |this| {\n+            this.lower_trait_ref(&p.trait_ref, itctx.reborrow())\n         });\n \n         hir::PolyTraitRef { bound_generic_params, trait_ref, span: self.lower_span(p.span) }"}, {"sha": "b3197977d6fbea194662b384c19da692f8e55d8f", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 37, "deletions": 9, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/21b6d2389016f3c75a990012f60de1608d1c2020/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21b6d2389016f3c75a990012f60de1608d1c2020/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=21b6d2389016f3c75a990012f60de1608d1c2020", "patch": "@@ -15,7 +15,7 @@ use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n use rustc_ast_lowering::{LifetimeRes, ResolverAstLowering};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_errors::DiagnosticId;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, PartialRes, PerNS};\n@@ -244,7 +244,8 @@ impl LifetimeBinderKind {\n #[derive(Debug)]\n struct LifetimeRib {\n     kind: LifetimeRibKind,\n-    bindings: IdentMap<LifetimeRes>,\n+    // We need to preserve insertion order for async fns.\n+    bindings: FxIndexMap<Ident, (NodeId, LifetimeRes)>,\n }\n \n impl LifetimeRib {\n@@ -718,6 +719,32 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         },\n                     );\n \n+                    // Construct the list of in-scope lifetime parameters for async lowering.\n+                    // We include all lifetime parameters, either named or \"Fresh\".\n+                    // The order of those parameters does not matter, as long as it is\n+                    // deterministic.\n+                    let mut extra_lifetime_params =\n+                        this.r.extra_lifetime_params_map.get(&fn_id).cloned().unwrap_or_default();\n+                    for rib in this.lifetime_ribs.iter().rev() {\n+                        extra_lifetime_params.extend(\n+                            rib.bindings\n+                                .iter()\n+                                .map(|(&ident, &(node_id, res))| (ident, node_id, res)),\n+                        );\n+                        match rib.kind {\n+                            LifetimeRibKind::Item => break,\n+                            LifetimeRibKind::AnonymousCreateParameter(id) => {\n+                                if let Some(earlier_fresh) =\n+                                    this.r.extra_lifetime_params_map.get(&id)\n+                                {\n+                                    extra_lifetime_params.extend(earlier_fresh);\n+                                }\n+                            }\n+                            _ => {}\n+                        }\n+                    }\n+                    this.r.extra_lifetime_params_map.insert(async_node_id, extra_lifetime_params);\n+\n                     this.with_lifetime_rib(\n                         LifetimeRibKind::AnonymousPassThrough(async_node_id),\n                         |this| visit::walk_fn_ret_ty(this, &declaration.output),\n@@ -1126,7 +1153,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         for i in &mut indices {\n             let rib = &self.lifetime_ribs[i];\n             let normalized_ident = ident.normalize_to_macros_2_0();\n-            if let Some(&region) = rib.bindings.get(&normalized_ident) {\n+            if let Some(&(_, region)) = rib.bindings.get(&normalized_ident) {\n                 self.record_lifetime_res(lifetime.id, region);\n                 return;\n             }\n@@ -1229,12 +1256,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         );\n         debug!(?def_id);\n \n-        let region = LifetimeRes::Fresh {\n-            param: def_id,\n-            introducer: Some(def_node_id),\n-            binder: item_node_id,\n-        };\n+        let region = LifetimeRes::Fresh { param: def_id, binder: item_node_id };\n         self.record_lifetime_res(id, region);\n+        self.r.extra_lifetime_params_map.entry(item_node_id).or_insert_with(Vec::new).push((\n+            ident,\n+            def_node_id,\n+            region,\n+        ));\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n@@ -1818,7 +1846,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     let LifetimeRibKind::Generics { parent, .. } = lifetime_kind else { panic!() };\n                     let res = LifetimeRes::Param { param: def_id, binder: parent };\n                     self.record_lifetime_res(param.id, res);\n-                    function_lifetime_rib.bindings.insert(ident, res);\n+                    function_lifetime_rib.bindings.insert(ident, (param.id, res));\n                     continue;\n                 }\n             };"}, {"sha": "8df2ae5c33ba0560f9ed24cafa47027150fef5fc", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/21b6d2389016f3c75a990012f60de1608d1c2020/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21b6d2389016f3c75a990012f60de1608d1c2020/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=21b6d2389016f3c75a990012f60de1608d1c2020", "patch": "@@ -903,6 +903,8 @@ pub struct Resolver<'a> {\n     label_res_map: NodeMap<NodeId>,\n     /// Resolutions for lifetimes.\n     lifetimes_res_map: NodeMap<LifetimeRes>,\n+    /// Lifetime parameters that lowering will have to introduce.\n+    extra_lifetime_params_map: NodeMap<Vec<(Ident, NodeId, LifetimeRes)>>,\n \n     /// `CrateNum` resolutions of `extern crate` items.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n@@ -1159,6 +1161,10 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.lifetimes_res_map.get(&id).copied()\n     }\n \n+    fn take_extra_lifetime_params(&mut self, id: NodeId) -> Vec<(Ident, NodeId, LifetimeRes)> {\n+        self.extra_lifetime_params_map.remove(&id).unwrap_or_default()\n+    }\n+\n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n         StableHashingContext::new(self.session, &self.definitions, self.crate_loader.cstore())\n     }\n@@ -1308,6 +1314,7 @@ impl<'a> Resolver<'a> {\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n             lifetimes_res_map: Default::default(),\n+            extra_lifetime_params_map: Default::default(),\n             extern_crate_map: Default::default(),\n             reexport_map: FxHashMap::default(),\n             trait_map: NodeMap::default(),"}]}