{"sha": "db7ee7cc0ddf46a52f53a8a141cd0747f829999a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiN2VlN2NjMGRkZjQ2YTUyZjUzYThhMTQxY2QwNzQ3ZjgyOTk5OWE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-28T00:58:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-28T00:58:40Z"}, "message": "Auto merge of #75295 - tmiasko:fds, r=Amanieu\n\nReopen standard file descriptors when they are missing on Unix\n\nThe syscalls returning a new file descriptors generally return lowest-numbered\nfile descriptor not currently opened, without any exceptions for those\ncorresponding to stdin, sdout, or stderr.\n\nPreviously when any of standard file descriptors has been closed before starting\nthe application, operations on std::io::{stderr,stdin,stdout} were likely to\neither succeed while being performed on unrelated file descriptor, or fail with\nEBADF which is silently ignored.\n\nAvoid the issue by using /dev/null as a replacement when the standard file\ndescriptors are missing.\n\nThe implementation is based on the one found in musl. It was selected among a\nfew others on the basis of the lowest overhead in the case when all descriptors\nare already present (measured on GNU/Linux).\n\nCloses #57728.\nCloses #46981.\nCloses #60447.\n\nBenefits:\n* Makes applications robust in the absence of standard file descriptors.\n* Upholds IntoRawFd / FromRawFd safety contract (which was broken previously).\n\nDrawbacks:\n* Additional syscall during startup.\n* The standard descriptors might have been closed intentionally.\n* Requires /dev/null.\n\nAlternatives:\n* Check if stdin, stdout, stderr are opened and provide no-op substitutes in std::io::{stdin,stdout,stderr} without reopening them directly.\n* Leave the status quo, expect robust applications to reopen them manually.", "tree": {"sha": "88b7f3367761025765b85fdc791a9f3f405608aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88b7f3367761025765b85fdc791a9f3f405608aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db7ee7cc0ddf46a52f53a8a141cd0747f829999a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db7ee7cc0ddf46a52f53a8a141cd0747f829999a", "html_url": "https://github.com/rust-lang/rust/commit/db7ee7cc0ddf46a52f53a8a141cd0747f829999a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db7ee7cc0ddf46a52f53a8a141cd0747f829999a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a", "html_url": "https://github.com/rust-lang/rust/commit/c0b15cc6ed37e626b2b5b324bbb0fdbf6688650a"}, {"sha": "7d98d2207a20d95e731bfc742d89389a67d6618d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d98d2207a20d95e731bfc742d89389a67d6618d", "html_url": "https://github.com/rust-lang/rust/commit/7d98d2207a20d95e731bfc742d89389a67d6618d"}], "stats": {"total": 84, "additions": 82, "deletions": 2}, "files": [{"sha": "b48d2162eca92df57414542aac8aff859a312009", "filename": "library/std/src/sys/unix/mod.rs", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/db7ee7cc0ddf46a52f53a8a141cd0747f829999a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7ee7cc0ddf46a52f53a8a141cd0747f829999a/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmod.rs?ref=db7ee7cc0ddf46a52f53a8a141cd0747f829999a", "patch": "@@ -75,6 +75,13 @@ pub use crate::sys_common::os_str_bytes as os_str;\n \n #[cfg(not(test))]\n pub fn init() {\n+    // The standard streams might be closed on application startup. To prevent\n+    // std::io::{stdin, stdout,stderr} objects from using other unrelated file\n+    // resources opened later, we reopen standards streams when they are closed.\n+    unsafe {\n+        sanitize_standard_fds();\n+    }\n+\n     // By default, some platforms will send a *signal* when an EPIPE error\n     // would otherwise be delivered. This runtime doesn't install a SIGPIPE\n     // handler, causing it to kill the program, which isn't exactly what we\n@@ -86,6 +93,61 @@ pub fn init() {\n         reset_sigpipe();\n     }\n \n+    // In the case when all file descriptors are open, the poll has been\n+    // observed to perform better than fcntl (on GNU/Linux).\n+    #[cfg(not(any(\n+        miri,\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        // The poll on Darwin doesn't set POLLNVAL for closed fds.\n+        target_os = \"macos\",\n+        target_os = \"ios\",\n+        target_os = \"redox\",\n+    )))]\n+    unsafe fn sanitize_standard_fds() {\n+        use crate::sys::os::errno;\n+        let pfds: &mut [_] = &mut [\n+            libc::pollfd { fd: 0, events: 0, revents: 0 },\n+            libc::pollfd { fd: 1, events: 0, revents: 0 },\n+            libc::pollfd { fd: 2, events: 0, revents: 0 },\n+        ];\n+        while libc::poll(pfds.as_mut_ptr(), 3, 0) == -1 {\n+            if errno() == libc::EINTR {\n+                continue;\n+            }\n+            libc::abort();\n+        }\n+        for pfd in pfds {\n+            if pfd.revents & libc::POLLNVAL == 0 {\n+                continue;\n+            }\n+            if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+                // If the stream is closed but we failed to reopen it, abort the\n+                // process. Otherwise we wouldn't preserve the safety of\n+                // operations on the corresponding Rust object Stdin, Stdout, or\n+                // Stderr.\n+                libc::abort();\n+            }\n+        }\n+    }\n+    #[cfg(any(target_os = \"macos\", target_os = \"ios\", target_os = \"redox\"))]\n+    unsafe fn sanitize_standard_fds() {\n+        use crate::sys::os::errno;\n+        for fd in 0..3 {\n+            if libc::fcntl(fd, libc::F_GETFD) == -1 && errno() == libc::EBADF {\n+                if libc::open(\"/dev/null\\0\".as_ptr().cast(), libc::O_RDWR, 0) == -1 {\n+                    libc::abort();\n+                }\n+            }\n+        }\n+    }\n+    #[cfg(any(\n+        // The standard fds are always available in Miri.\n+        miri,\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\"))]\n+    unsafe fn sanitize_standard_fds() {}\n+\n     #[cfg(not(any(target_os = \"emscripten\", target_os = \"fuchsia\")))]\n     unsafe fn reset_sigpipe() {\n         assert!(signal(libc::SIGPIPE, libc::SIG_IGN) != libc::SIG_ERR);"}, {"sha": "1b0ad930da6d7f571b51bf8a224659d9c325f173", "filename": "src/test/ui/no-stdio.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/db7ee7cc0ddf46a52f53a8a141cd0747f829999a/src%2Ftest%2Fui%2Fno-stdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db7ee7cc0ddf46a52f53a8a141cd0747f829999a/src%2Ftest%2Fui%2Fno-stdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fno-stdio.rs?ref=db7ee7cc0ddf46a52f53a8a141cd0747f829999a", "patch": "@@ -36,6 +36,16 @@ unsafe fn without_stdio<R, F: FnOnce() -> R>(f: F) -> R {\n     return r\n }\n \n+#[cfg(unix)]\n+fn assert_fd_is_valid(fd: libc::c_int) {\n+    if unsafe { libc::fcntl(fd, libc::F_GETFD) == -1 } {\n+        panic!(\"file descriptor {} is not valid: {}\", fd, io::Error::last_os_error());\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn assert_fd_is_valid(_fd: libc::c_int) {}\n+\n #[cfg(windows)]\n unsafe fn without_stdio<R, F: FnOnce() -> R>(f: F) -> R {\n     type DWORD = u32;\n@@ -77,10 +87,18 @@ unsafe fn without_stdio<R, F: FnOnce() -> R>(f: F) -> R {\n \n fn main() {\n     if env::args().len() > 1 {\n+        // Writing to stdout & stderr should not panic.\n         println!(\"test\");\n         assert!(io::stdout().write(b\"test\\n\").is_ok());\n         assert!(io::stderr().write(b\"test\\n\").is_ok());\n+\n+        // Stdin should be at EOF.\n         assert_eq!(io::stdin().read(&mut [0; 10]).unwrap(), 0);\n+\n+        // Standard file descriptors should be valid on UNIX:\n+        assert_fd_is_valid(0);\n+        assert_fd_is_valid(1);\n+        assert_fd_is_valid(2);\n         return\n     }\n \n@@ -109,12 +127,12 @@ fn main() {\n                         .stdout(Stdio::null())\n                         .stderr(Stdio::null())\n                         .status().unwrap();\n-    assert!(status.success(), \"{:?} isn't a success\", status);\n+    assert!(status.success(), \"{} isn't a success\", status);\n \n     // Finally, close everything then spawn a child to make sure everything is\n     // *still* ok.\n     let status = unsafe {\n         without_stdio(|| Command::new(&me).arg(\"next\").status())\n     }.unwrap();\n-    assert!(status.success(), \"{:?} isn't a success\", status);\n+    assert!(status.success(), \"{} isn't a success\", status);\n }"}]}