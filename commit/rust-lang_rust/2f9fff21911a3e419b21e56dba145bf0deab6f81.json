{"sha": "2f9fff21911a3e419b21e56dba145bf0deab6f81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmOWZmZjIxOTExYTNlNDE5YjIxZTU2ZGJhMTQ1YmYwZGVhYjZmODE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-25T14:51:14Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-07-28T16:05:45Z"}, "message": "Keep multiple files per work-product\n\nIn the older version, a `.o` and ` .bc` file were separate\nwork-products.  This newer version keeps, for each codegen-unit, a set\nof files of different kinds. We assume that if any kinds are available\nthen all the kinds we need are available, since the precise set of\nswitches will depend on attributes and command-line switches.\n\nShould probably test this: the effect of changing attributes in\nparticular might not be successfully tracked?", "tree": {"sha": "b3643b7ddf227f658472806fbcb148f7a176960a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3643b7ddf227f658472806fbcb148f7a176960a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f9fff21911a3e419b21e56dba145bf0deab6f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f9fff21911a3e419b21e56dba145bf0deab6f81", "html_url": "https://github.com/rust-lang/rust/commit/2f9fff21911a3e419b21e56dba145bf0deab6f81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f9fff21911a3e419b21e56dba145bf0deab6f81/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceeb158e0a04c3a73a4c5014609020ee628b4c06", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceeb158e0a04c3a73a4c5014609020ee628b4c06", "html_url": "https://github.com/rust-lang/rust/commit/ceeb158e0a04c3a73a4c5014609020ee628b4c06"}], "stats": {"total": 294, "additions": 202, "deletions": 92}, "files": [{"sha": "c9247539990a9a8273508a2ea673a6ce6d65a0aa", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -246,7 +246,5 @@ impl<D: Clone + Debug> DepNode<D> {\n /// the need to be mapped or unmapped. (This ensures we can serialize\n /// them even in the absence of a tcx.)\n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n-pub enum WorkProductId {\n-    PartitionObjectFile(String), // see (*TransPartition) below\n-}\n+pub struct WorkProductId(pub String);\n "}, {"sha": "bb027b11b45afa6bed09f25340ab648b6cbb8c00", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -10,6 +10,7 @@\n \n use hir::def_id::DefId;\n use rustc_data_structures::fnv::FnvHashMap;\n+use session::config::OutputType;\n use std::cell::{Ref, RefCell};\n use std::rc::Rc;\n use std::sync::Arc;\n@@ -157,11 +158,11 @@ impl DepGraph {\n /// previous hash. If it matches up, we can reuse the object file.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct WorkProduct {\n-    /// extra hash used to decide if work-product is still suitable;\n+    /// Extra hash used to decide if work-product is still suitable;\n     /// note that this is *not* a hash of the work-product itself.\n     /// See documentation on `WorkProduct` type for an example.\n     pub input_hash: u64,\n \n-    /// filename storing this work-product (found in the incr. comp. directory)\n-    pub file_name: String,\n+    /// Saved files associated with this CGU\n+    pub saved_files: Vec<(OutputType, String)>,\n }"}, {"sha": "690395399efa166cd1bf244415a60a7f894151a6", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -61,7 +61,7 @@ pub enum DebugInfoLevel {\n     FullDebugInfo,\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq, Hash)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum OutputType {\n     Bitcode,\n     Assembly,\n@@ -105,6 +105,17 @@ impl OutputType {\n             OutputType::DepInfo => \"dep-info\",\n         }\n     }\n+\n+    pub fn extension(&self) -> &'static str {\n+        match *self {\n+            OutputType::Bitcode => \"bc\",\n+            OutputType::Assembly => \"s\",\n+            OutputType::LlvmAssembly => \"ll\",\n+            OutputType::Object => \"o\",\n+            OutputType::DepInfo => \"d\",\n+            OutputType::Exe => \"\",\n+        }\n+    }\n }\n \n #[derive(Clone)]\n@@ -215,15 +226,7 @@ impl OutputFilenames {\n                      flavor: OutputType,\n                      codegen_unit_name: Option<&str>)\n                      -> PathBuf {\n-        let extension = match flavor {\n-            OutputType::Bitcode => \"bc\",\n-            OutputType::Assembly => \"s\",\n-            OutputType::LlvmAssembly => \"ll\",\n-            OutputType::Object => \"o\",\n-            OutputType::DepInfo => \"d\",\n-            OutputType::Exe => \"\",\n-        };\n-\n+        let extension = flavor.extension();\n         self.temp_path_ext(extension, codegen_unit_name)\n     }\n "}, {"sha": "36b6c79c40f5dc9379fac023bb43b567d0334198", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -260,11 +260,20 @@ fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             debug!(\"reconcile_work_products: dep-node for {:?} is dirty\", swp);\n             delete_dirty_work_product(tcx, swp);\n         } else {\n-            let path = in_incr_comp_dir(tcx.sess, &swp.work_product.file_name).unwrap();\n-            if path.exists() {\n+            let all_files_exist =\n+                swp.work_product\n+                   .saved_files\n+                   .iter()\n+                   .all(|&(_, ref file_name)| {\n+                       let path = in_incr_comp_dir(tcx.sess, &file_name).unwrap();\n+                       path.exists()\n+                   });\n+            if all_files_exist {\n+                debug!(\"reconcile_work_products: all files for {:?} exist\", swp);\n                 tcx.dep_graph.insert_previous_work_product(&swp.id, swp.work_product);\n             } else {\n-                debug!(\"reconcile_work_products: file for {:?} does not exist\", swp);\n+                debug!(\"reconcile_work_products: some file for {:?} does not exist\", swp);\n+                delete_dirty_work_product(tcx, swp);\n             }\n         }\n     }\n@@ -273,13 +282,15 @@ fn reconcile_work_products<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn delete_dirty_work_product(tcx: TyCtxt,\n                              swp: SerializedWorkProduct) {\n     debug!(\"delete_dirty_work_product({:?})\", swp);\n-    let path = in_incr_comp_dir(tcx.sess, &swp.work_product.file_name).unwrap();\n-    match fs::remove_file(&path) {\n-        Ok(()) => { }\n-        Err(err) => {\n-            tcx.sess.warn(\n-                &format!(\"file-system error deleting outdated file `{}`: {}\",\n-                         path.display(), err));\n+    for &(_, ref file_name) in &swp.work_product.saved_files {\n+        let path = in_incr_comp_dir(tcx.sess, file_name).unwrap();\n+        match fs::remove_file(&path) {\n+            Ok(()) => { }\n+            Err(err) => {\n+                tcx.sess.warn(\n+                    &format!(\"file-system error deleting outdated file `{}`: {}\",\n+                             path.display(), err));\n+            }\n         }\n     }\n }"}, {"sha": "c106ea8f262691ec83cfe693efaaadc6663734c2", "filename": "src/librustc_incremental/persist/work_product.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fwork_product.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -13,47 +13,51 @@\n use persist::util::*;\n use rustc::dep_graph::{WorkProduct, WorkProductId};\n use rustc::session::Session;\n+use rustc::session::config::OutputType;\n use rustc::util::fs::link_or_copy;\n-use std::fs;\n-use std::path::Path;\n+use std::path::PathBuf;\n use std::sync::Arc;\n \n pub fn save_trans_partition(sess: &Session,\n-                            partition_name: &str,\n+                            cgu_name: &str,\n                             partition_hash: u64,\n-                            path_to_obj_file: &Path) {\n-    debug!(\"save_trans_partition({:?},{},{})\",\n-           partition_name,\n+                            files: &[(OutputType, PathBuf)]) {\n+    debug!(\"save_trans_partition({:?},{},{:?})\",\n+           cgu_name,\n            partition_hash,\n-           path_to_obj_file.display());\n+           files);\n     if sess.opts.incremental.is_none() {\n         return;\n     }\n-    let id = Arc::new(WorkProductId::PartitionObjectFile(partition_name.to_string()));\n-    let file_name = format!(\"cgu-{}\", partition_name);\n-    let path_in_incr_dir = in_incr_comp_dir(sess, &file_name).unwrap();\n+    let work_product_id = Arc::new(WorkProductId(cgu_name.to_string()));\n \n-    // try to delete the file if it already exists\n-    //\n-    // FIXME(#34955) we can be smarter here -- if we are re-using, no need to do anything\n-    if path_in_incr_dir.exists() {\n-        let _ = fs::remove_file(&path_in_incr_dir);\n-    }\n+    let saved_files: Option<Vec<_>> =\n+        files.iter()\n+             .map(|&(kind, ref path)| {\n+                 let file_name = format!(\"cgu-{}.{}\", cgu_name, kind.extension());\n+                 let path_in_incr_dir = in_incr_comp_dir(sess, &file_name).unwrap();\n+                 match link_or_copy(path, &path_in_incr_dir) {\n+                     Ok(_) => Some((kind, file_name)),\n+                     Err(err) => {\n+                         sess.warn(&format!(\"error copying object file `{}` \\\n+                                             to incremental directory as `{}`: {}\",\n+                                            path.display(),\n+                                            path_in_incr_dir.display(),\n+                                            err));\n+                         None\n+                     }\n+                 }\n+             })\n+             .collect();\n+    let saved_files = match saved_files {\n+        Some(v) => v,\n+        None => return,\n+    };\n \n-    match link_or_copy(path_to_obj_file, &path_in_incr_dir) {\n-        Ok(_) => {\n-            let work_product = WorkProduct {\n-                input_hash: partition_hash,\n-                file_name: file_name,\n-            };\n-            sess.dep_graph.insert_work_product(&id, work_product);\n-        }\n-        Err(err) => {\n-            sess.warn(&format!(\"error copying object file `{}` \\\n-                                to incremental directory as `{}`: {}\",\n-                               path_to_obj_file.display(),\n-                               path_in_incr_dir.display(),\n-                               err));\n-        }\n-    }\n+    let work_product = WorkProduct {\n+        input_hash: partition_hash,\n+        saved_files: saved_files,\n+    };\n+\n+    sess.dep_graph.insert_work_product(&work_product_id, work_product);\n }"}, {"sha": "4b9d5dd9e8d67a2342b4e2333c9187655c700624", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -337,6 +337,8 @@ struct CodegenContext<'a> {\n     remark: Passes,\n     // Worker thread number\n     worker: usize,\n+    // Directory where incremental data is stored (if any)\n+    incremental: Option<PathBuf>,\n }\n \n impl<'a> CodegenContext<'a> {\n@@ -347,6 +349,7 @@ impl<'a> CodegenContext<'a> {\n             plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n             remark: sess.opts.cg.remark.clone(),\n             worker: 0,\n+            incremental: sess.opts.incremental.clone(),\n         }\n     }\n }\n@@ -612,7 +615,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     if copy_bc_to_obj {\n         debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n-        if let Err(e) = fs::copy(&bc_out, &obj_out) {\n+        if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n             cgcx.handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n         }\n     }\n@@ -754,9 +757,19 @@ pub fn run_passes(sess: &Session,\n \n     // If in incr. comp. mode, preserve the `.o` files for potential re-use\n     for mtrans in trans.modules.iter() {\n-        let path_to_obj = crate_output.temp_path(OutputType::Object, Some(&mtrans.name));\n-        debug!(\"wrote module {:?} to {:?}\", mtrans.name, path_to_obj);\n-        save_trans_partition(sess, &mtrans.name, mtrans.symbol_name_hash, &path_to_obj);\n+        let mut files = vec![];\n+\n+        if modules_config.emit_obj {\n+            let path = crate_output.temp_path(OutputType::Object, Some(&mtrans.name));\n+            files.push((OutputType::Object, path));\n+        }\n+\n+        if modules_config.emit_bc {\n+            let path = crate_output.temp_path(OutputType::Bitcode, Some(&mtrans.name));\n+            files.push((OutputType::Bitcode, path));\n+        }\n+\n+        save_trans_partition(sess, &mtrans.name, mtrans.symbol_name_hash, &files);\n     }\n \n     // All codegen is finished.\n@@ -941,20 +954,24 @@ fn execute_work_item(cgcx: &CodegenContext,\n                                      work_item.config,\n                                      work_item.output_names);\n             }\n-            ModuleSource::Preexisting(ref buf) => {\n-                let obj_out = work_item.output_names.temp_path(OutputType::Object,\n-                                                               Some(&work_item.mtrans.name));\n-                debug!(\"copying pre-existing module `{}` from {} to {}\",\n-                       work_item.mtrans.name,\n-                       buf.display(),\n-                       obj_out.display());\n-                match link_or_copy(buf, &obj_out) {\n-                    Ok(()) => { }\n-                    Err(err) => {\n-                        cgcx.handler.err(&format!(\"unable to copy {} to {}: {}\",\n-                                                  buf.display(),\n-                                                  obj_out.display(),\n-                                                  err));\n+            ModuleSource::Preexisting(wp) => {\n+                let incremental = cgcx.incremental.as_ref().unwrap();\n+                let name = &work_item.mtrans.name;\n+                for (kind, saved_file) in wp.saved_files {\n+                    let obj_out = work_item.output_names.temp_path(kind, Some(name));\n+                    let source_file = incremental.join(&saved_file);\n+                    debug!(\"copying pre-existing module `{}` from {:?} to {}\",\n+                           work_item.mtrans.name,\n+                           source_file,\n+                           obj_out.display());\n+                    match link_or_copy(&source_file, &obj_out) {\n+                        Ok(()) => { }\n+                        Err(err) => {\n+                            cgcx.handler.err(&format!(\"unable to copy {} to {}: {}\",\n+                                                      source_file.display(),\n+                                                      obj_out.display(),\n+                                                      err));\n+                        }\n                     }\n                 }\n             }\n@@ -994,6 +1011,8 @@ fn run_work_multithreaded(sess: &Session,\n         let mut tx = Some(tx);\n         futures.push(rx);\n \n+        let incremental = sess.opts.incremental.clone();\n+\n         thread::Builder::new().name(format!(\"codegen-{}\", i)).spawn(move || {\n             let diag_handler = Handler::with_emitter(true, false, box diag_emitter);\n \n@@ -1005,6 +1024,7 @@ fn run_work_multithreaded(sess: &Session,\n                 plugin_passes: plugin_passes,\n                 remark: remark,\n                 worker: i,\n+                incremental: incremental,\n             };\n \n             loop {"}, {"sha": "5a19ddff7462af5130a5b909334e19a34f2d22da", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -43,10 +43,9 @@ use rustc::ty::subst::{self, Substs};\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n-use rustc::dep_graph::DepNode;\n+use rustc::dep_graph::{DepNode, WorkProduct};\n use rustc::hir::map as hir_map;\n use rustc::util::common::time;\n-use rustc_incremental::in_incr_comp_dir;\n use rustc::mir::mir_map::MirMap;\n use rustc_data_structures::graph::OUTGOING;\n use session::config::{self, NoDebugInfo, FullDebugInfo};\n@@ -103,7 +102,6 @@ use std::cell::{Cell, RefCell};\n use std::collections::HashMap;\n use std::ptr;\n use std::rc::Rc;\n-use std::path::PathBuf;\n use std::str;\n use std::{i8, i16, i32, i64};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -2721,7 +2719,7 @@ pub fn trans_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn trans_reuse_previous_work_products(tcx: TyCtxt,\n                                       codegen_units: &[CodegenUnit],\n                                       symbol_map: &SymbolMap)\n-                                      -> Vec<Option<PathBuf>> {\n+                                      -> Vec<Option<WorkProduct>> {\n     debug!(\"trans_reuse_previous_work_products()\");\n     codegen_units\n         .iter()\n@@ -2735,7 +2733,7 @@ fn trans_reuse_previous_work_products(tcx: TyCtxt,\n             if let Some(work_product) = tcx.dep_graph.previous_work_product(&id) {\n                 if work_product.input_hash == hash {\n                     debug!(\"trans_reuse_previous_work_products: reusing {:?}\", work_product);\n-                    return Some(in_incr_comp_dir(tcx.sess, &work_product.file_name).unwrap());\n+                    return Some(work_product);\n                 } else {\n                     debug!(\"trans_reuse_previous_work_products: \\\n                             not reusing {:?} because hash changed to {:?}\","}, {"sha": "a8f8474e94070dc25a0891e52752df9ac3323924", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -10,7 +10,7 @@\n \n use llvm;\n use llvm::{ContextRef, ModuleRef, ValueRef, BuilderRef};\n-use rustc::dep_graph::{DepNode, DepTrackingMap, DepTrackingMapConfig};\n+use rustc::dep_graph::{DepNode, DepTrackingMap, DepTrackingMapConfig, WorkProduct};\n use middle::cstore::LinkMeta;\n use rustc::hir::def::ExportMap;\n use rustc::hir::def_id::DefId;\n@@ -40,7 +40,6 @@ use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n \n use std::ffi::{CStr, CString};\n use std::cell::{Cell, RefCell};\n-use std::path::PathBuf;\n use std::marker::PhantomData;\n use std::ptr;\n use std::rc::Rc;\n@@ -96,7 +95,7 @@ pub struct SharedCrateContext<'a, 'tcx: 'a> {\n pub struct LocalCrateContext<'tcx> {\n     llmod: ModuleRef,\n     llcx: ContextRef,\n-    previous_work_product: Option<PathBuf>,\n+    previous_work_product: Option<WorkProduct>,\n     tn: TypeNames, // FIXME: This seems to be largely unused.\n     codegen_unit: CodegenUnit<'tcx>,\n     needs_unwind_cleanup_cache: RefCell<FnvHashMap<Ty<'tcx>, bool>>,\n@@ -202,13 +201,13 @@ pub struct CrateContextList<'a, 'tcx: 'a> {\n impl<'a, 'tcx: 'a> CrateContextList<'a, 'tcx> {\n     pub fn new(shared_ccx: &'a SharedCrateContext<'a, 'tcx>,\n                codegen_units: Vec<CodegenUnit<'tcx>>,\n-               previous_work_products: Vec<Option<PathBuf>>,\n+               previous_work_products: Vec<Option<WorkProduct>>,\n                symbol_map: Rc<SymbolMap<'tcx>>)\n                -> CrateContextList<'a, 'tcx> {\n         CrateContextList {\n             shared: shared_ccx,\n-            local_ccxs: codegen_units.into_iter().zip(previous_work_products).map(|(cgu, path)| {\n-                LocalCrateContext::new(shared_ccx, cgu, path, symbol_map.clone())\n+            local_ccxs: codegen_units.into_iter().zip(previous_work_products).map(|(cgu, wp)| {\n+                LocalCrateContext::new(shared_ccx, cgu, wp, symbol_map.clone())\n             }).collect()\n         }\n     }\n@@ -541,7 +540,7 @@ impl<'b, 'tcx> SharedCrateContext<'b, 'tcx> {\n impl<'tcx> LocalCrateContext<'tcx> {\n     fn new<'a>(shared: &SharedCrateContext<'a, 'tcx>,\n                codegen_unit: CodegenUnit<'tcx>,\n-               previous_work_product: Option<PathBuf>,\n+               previous_work_product: Option<WorkProduct>,\n                symbol_map: Rc<SymbolMap<'tcx>>)\n            -> LocalCrateContext<'tcx> {\n         unsafe {\n@@ -727,7 +726,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         self.local().llcx\n     }\n \n-    pub fn previous_work_product(&self) -> Option<&PathBuf> {\n+    pub fn previous_work_product(&self) -> Option<&WorkProduct> {\n         self.local().previous_work_product.as_ref()\n     }\n "}, {"sha": "81a1dbeb7fe74db7431b49909611326134d1d58c", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -37,7 +37,7 @@\n #![feature(unicode)]\n #![feature(question_mark)]\n \n-use std::path::PathBuf;\n+use rustc::dep_graph::WorkProduct;\n \n extern crate arena;\n extern crate flate;\n@@ -135,14 +135,22 @@ mod value;\n \n #[derive(Clone)]\n pub struct ModuleTranslation {\n+    /// The name of the module. When the crate may be saved between\n+    /// compilations, incremental compilation requires that name be\n+    /// unique amongst **all** crates.  Therefore, it should contain\n+    /// something unique to this crate (e.g., a module path) as well\n+    /// as the crate name and disambiguator.\n     pub name: String,\n     pub symbol_name_hash: u64,\n     pub source: ModuleSource,\n }\n \n #[derive(Clone)]\n pub enum ModuleSource {\n-    Preexisting(PathBuf),\n+    /// Copy the `.o` files or whatever from the incr. comp. directory.\n+    Preexisting(WorkProduct),\n+\n+    /// Rebuild from this LLVM module.\n     Translated(ModuleLlvm),\n }\n "}, {"sha": "ade6e8abeb32a5ac07d27eba578131c015c9cac4", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -143,7 +143,12 @@ pub enum PartitioningStrategy {\n }\n \n pub struct CodegenUnit<'tcx> {\n+    /// A name for this CGU. Incremental compilation requires that\n+    /// name be unique amongst **all** crates.  Therefore, it should\n+    /// contain something unique to this crate (e.g., a module path)\n+    /// as well as the crate name and disambiguator.\n     name: InternedString,\n+\n     items: FnvHashMap<TransItem<'tcx>, llvm::Linkage>,\n }\n \n@@ -174,7 +179,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n     }\n \n     pub fn work_product_id(&self) -> Arc<WorkProductId> {\n-        Arc::new(WorkProductId::PartitionObjectFile(self.name().to_string()))\n+        Arc::new(WorkProductId(self.name().to_string()))\n     }\n \n     pub fn work_product_dep_node(&self) -> DepNode<DefId> {"}, {"sha": "ff5fd634714497bf53a38f11bc1aa323844a5a8c", "filename": "src/test/incremental/rlib_cross_crate/auxiliary/a.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fauxiliary%2Fa.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type=\"rlib\"]\n+\n+#[cfg(rpass1)]\n+pub type X = u32;\n+\n+#[cfg(rpass2)]\n+pub type X = i32;\n+\n+// this version doesn't actually change anything:\n+#[cfg(rpass3)]\n+pub type X = i32;\n+\n+pub type Y = char;"}, {"sha": "55398370425a3bcecedd4b3d0e12a8bee55d73a2", "filename": "src/test/incremental/rlib_cross_crate/b.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9fff21911a3e419b21e56dba145bf0deab6f81/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Frlib_cross_crate%2Fb.rs?ref=2f9fff21911a3e419b21e56dba145bf0deab6f81", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Same test as `type_alias_cross_crate`, but with\n+// `no-prefer-dynamic`, ensuring that we test what happens when we\n+// build rlibs (before we were only testing dylibs, which meant we\n+// didn't realize we had to preserve a `bc` file as well).\n+\n+// aux-build:a.rs\n+// revisions:rpass1 rpass2 rpass3\n+// no-prefer-dynamic\n+\n+\n+#![feature(rustc_attrs)]\n+\n+extern crate a;\n+\n+#[rustc_dirty(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass3\")]\n+pub fn use_X() -> u32 {\n+    let x: a::X = 22;\n+    x as u32\n+}\n+\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass2\")]\n+#[rustc_clean(label=\"TypeckItemBody\", cfg=\"rpass3\")]\n+pub fn use_Y() {\n+    let x: a::Y = 'c';\n+}\n+\n+pub fn main() { }"}]}