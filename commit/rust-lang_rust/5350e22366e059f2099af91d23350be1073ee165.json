{"sha": "5350e22366e059f2099af91d23350be1073ee165", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNTBlMjIzNjZlMDU5ZjIwOTlhZjkxZDIzMzUwYmUxMDczZWUxNjU=", "commit": {"author": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-07-02T00:09:21Z"}, "committer": {"name": "Stjepan Glavina", "email": "stjepang@gmail.com", "date": "2017-07-02T00:09:21Z"}, "message": "Stabilize feature sort_unstable", "tree": {"sha": "6023b28bccb7698e7971c488a54e224f02fb1545", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6023b28bccb7698e7971c488a54e224f02fb1545"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5350e22366e059f2099af91d23350be1073ee165", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5350e22366e059f2099af91d23350be1073ee165", "html_url": "https://github.com/rust-lang/rust/commit/5350e22366e059f2099af91d23350be1073ee165", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5350e22366e059f2099af91d23350be1073ee165/comments", "author": null, "committer": null, "parents": [{"sha": "d41b791c1af56b1f538cc6f77e597b7ad5b4d223", "url": "https://api.github.com/repos/rust-lang/rust/commits/d41b791c1af56b1f538cc6f77e597b7ad5b4d223", "html_url": "https://github.com/rust-lang/rust/commit/d41b791c1af56b1f538cc6f77e597b7ad5b4d223"}], "stats": {"total": 71, "additions": 17, "deletions": 54}, "files": [{"sha": "9effcfc774c7743bc55a7756741ed2ad263680ff", "filename": "src/doc/unstable-book/src/library-features/sort-unstable.md", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d41b791c1af56b1f538cc6f77e597b7ad5b4d223/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsort-unstable.md", "raw_url": "https://github.com/rust-lang/rust/raw/d41b791c1af56b1f538cc6f77e597b7ad5b4d223/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsort-unstable.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fsort-unstable.md?ref=d41b791c1af56b1f538cc6f77e597b7ad5b4d223", "patch": "@@ -1,40 +0,0 @@\n-# `sort_unstable`\n-\n-The tracking issue for this feature is: [#40585]\n-\n-[#40585]: https://github.com/rust-lang/rust/issues/40585\n-\n-------------------------\n-\n-The default `sort` method on slices is stable. In other words, it guarantees\n-that the original order of equal elements is preserved after sorting. The\n-method has several undesirable characteristics:\n-\n-1. It allocates a sizable chunk of memory.\n-2. If you don't need stability, it is not as performant as it could be.\n-\n-An alternative is the new `sort_unstable` feature, which includes these\n-methods for sorting slices:\n-\n-1. `sort_unstable`\n-2. `sort_unstable_by`\n-3. `sort_unstable_by_key`\n-\n-Unstable sorting is generally faster and makes no allocations. The majority\n-of real-world sorting needs doesn't require stability, so these methods can\n-very often come in handy.\n-\n-Another important difference is that `sort` lives in `libstd` and\n-`sort_unstable` lives in `libcore`. The reason is that the former makes\n-allocations and the latter doesn't.\n-\n-A simple example:\n-\n-```rust\n-#![feature(sort_unstable)]\n-\n-let mut v = [-5, 4, 1, -3, 2];\n-\n-v.sort_unstable();\n-assert!(v == [-5, -3, 1, 2, 4]);\n-```"}, {"sha": "b0e872aeb69d66f9857e6d9a43aabaf20d443770", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5350e22366e059f2099af91d23350be1073ee165/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5350e22366e059f2099af91d23350be1073ee165/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=5350e22366e059f2099af91d23350be1073ee165", "patch": "@@ -1144,6 +1144,10 @@ impl<T> [T] {\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n+    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n+    /// sorting and it doesn't allocate auxiliary memory.\n+    /// See [`sort_unstable`](#method.sort_unstable).\n+    ///\n     /// # Current implementation\n     ///\n     /// The current algorithm is an adaptive, iterative merge sort inspired by\n@@ -1174,6 +1178,10 @@ impl<T> [T] {\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n+    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n+    /// sorting and it doesn't allocate auxiliary memory.\n+    /// See [`sort_unstable_by`](#method.sort_unstable_by).\n+    ///\n     /// # Current implementation\n     ///\n     /// The current algorithm is an adaptive, iterative merge sort inspired by\n@@ -1207,6 +1215,10 @@ impl<T> [T] {\n     ///\n     /// This sort is stable (i.e. does not reorder equal elements) and `O(n log n)` worst-case.\n     ///\n+    /// When applicable, unstable sorting is preferred because it is generally faster than stable\n+    /// sorting and it doesn't allocate auxiliary memory.\n+    /// See [`sort_unstable_by_key`](#method.sort_unstable_by_key).\n+    ///\n     /// # Current implementation\n     ///\n     /// The current algorithm is an adaptive, iterative merge sort inspired by\n@@ -1251,17 +1263,14 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(sort_unstable)]\n-    ///\n     /// let mut v = [-5, 4, 1, -3, 2];\n     ///\n     /// v.sort_unstable();\n     /// assert!(v == [-5, -3, 1, 2, 4]);\n     /// ```\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n-    // FIXME #40585: Mention `sort_unstable` in the documentation for `sort`.\n-    #[unstable(feature = \"sort_unstable\", issue = \"40585\")]\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n     pub fn sort_unstable(&mut self)\n         where T: Ord\n@@ -1288,8 +1297,6 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(sort_unstable)]\n-    ///\n     /// let mut v = [5, 4, 1, 3, 2];\n     /// v.sort_unstable_by(|a, b| a.cmp(b));\n     /// assert!(v == [1, 2, 3, 4, 5]);\n@@ -1300,8 +1307,7 @@ impl<T> [T] {\n     /// ```\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n-    // FIXME #40585: Mention `sort_unstable_by` in the documentation for `sort_by`.\n-    #[unstable(feature = \"sort_unstable\", issue = \"40585\")]\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n     pub fn sort_unstable_by<F>(&mut self, compare: F)\n         where F: FnMut(&T, &T) -> Ordering\n@@ -1328,17 +1334,14 @@ impl<T> [T] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(sort_unstable)]\n-    ///\n     /// let mut v = [-5i32, 4, 1, -3, 2];\n     ///\n     /// v.sort_unstable_by_key(|k| k.abs());\n     /// assert!(v == [1, 2, -3, 4, -5]);\n     /// ```\n     ///\n     /// [pdqsort]: https://github.com/orlp/pdqsort\n-    // FIXME #40585: Mention `sort_unstable_by_key` in the documentation for `sort_by_key`.\n-    #[unstable(feature = \"sort_unstable\", issue = \"40585\")]\n+    #[stable(feature = \"sort_unstable\", since = \"1.20.0\")]\n     #[inline]\n     pub fn sort_unstable_by_key<B, F>(&mut self, f: F)\n         where F: FnMut(&T) -> B,"}, {"sha": "518d56095d60105ecf05392ad73c45f2efa1769c", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5350e22366e059f2099af91d23350be1073ee165/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5350e22366e059f2099af91d23350be1073ee165/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=5350e22366e059f2099af91d23350be1073ee165", "patch": "@@ -351,7 +351,7 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n \n     if start_l < end_l {\n         // The left block remains.\n-        // Move it's remaining out-of-order elements to the far right.\n+        // Move its remaining out-of-order elements to the far right.\n         debug_assert_eq!(width(l, r), block_l);\n         while start_l < end_l {\n             unsafe {\n@@ -363,7 +363,7 @@ fn partition_in_blocks<T, F>(v: &mut [T], pivot: &T, is_less: &mut F) -> usize\n         width(v.as_mut_ptr(), r)\n     } else if start_r < end_r {\n         // The right block remains.\n-        // Move it's remaining out-of-order elements to the far left.\n+        // Move its remaining out-of-order elements to the far left.\n         debug_assert_eq!(width(l, r), block_r);\n         while start_r < end_r {\n             unsafe {"}]}