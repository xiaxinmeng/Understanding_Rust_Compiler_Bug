{"sha": "f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzZmI1OWQ3MDc3ODAxYTNhNjhkMmQwM2VlZjE3ZDU5YzI5MjVhZTg=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-31T17:59:17Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-31T18:01:51Z"}, "message": "Move completion to ra_analysis\n\nWhile we should handle completion for isolated file, it's better\nachieved by using empty Analysis, rather than working only with &File:\nwe need memoization for type inference even inside a single file.", "tree": {"sha": "7665461636576d121063d7cc391351b284a399b9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7665461636576d121063d7cc391351b284a399b9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "html_url": "https://github.com/rust-lang/rust/commit/f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c02be1502c76cc504ccf7f73dce929585c94377c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c02be1502c76cc504ccf7f73dce929585c94377c", "html_url": "https://github.com/rust-lang/rust/commit/c02be1502c76cc504ccf7f73dce929585c94377c"}], "stats": {"total": 774, "additions": 711, "deletions": 63}, "files": [{"sha": "340ae3f664319320c3c6684dc21d3ef989bba0d6", "filename": "crates/ra_analysis/src/completion.rs", "status": "modified", "additions": 618, "deletions": 4, "changes": 622, "blob_url": "https://github.com/rust-lang/rust/blob/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion.rs?ref=f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "patch": "@@ -1,17 +1,32 @@\n-use ra_editor::{CompletionItem, find_node_at_offset};\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use ra_editor::{find_node_at_offset};\n use ra_syntax::{\n-    AtomEdit, File, TextUnit, AstNode,\n-    ast,\n+    AtomEdit, File, TextUnit, AstNode, SyntaxNodeRef,\n+    algo::visit::{visitor, visitor_ctx, Visitor, VisitorCtx},\n+    ast::{self, AstChildren, LoopBodyOwner, ModuleItemOwner},\n+    SyntaxKind::*,\n };\n \n use crate::{\n     FileId, Cancelable,\n     input::FilesDatabase,\n     db::{self, SyntaxDatabase},\n     descriptors::DescriptorDatabase,\n-    descriptors::module::{ModuleTree, ModuleId},\n+    descriptors::function::FnScopes,\n+    descriptors::module::{ModuleTree, ModuleId, ModuleScope},\n };\n \n+\n+#[derive(Debug)]\n+pub struct CompletionItem {\n+    /// What user sees in pop-up\n+    pub label: String,\n+    /// What string is used for filtering, defaults to label\n+    pub lookup: Option<String>,\n+    /// What is inserted, defaults to label\n+    pub snippet: Option<String>,\n+}\n+\n pub(crate) fn resolve_based_completion(db: &db::RootDatabase, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {\n     let source_root_id = db.file_source_root(file_id);\n     let file = db.file_syntax(file_id);\n@@ -73,3 +88,602 @@ fn crate_path(name_ref: ast::NameRef) -> Option<Vec<ast::NameRef>> {\n     res.reverse();\n     Some(res)\n }\n+\n+\n+pub(crate) fn scope_completion(\n+    db: &db::RootDatabase,\n+    file_id: FileId,\n+    offset: TextUnit,\n+) -> Option<Vec<CompletionItem>> {\n+    let original_file = db.file_syntax(file_id);\n+    // Insert a fake ident to get a valid parse tree\n+    let file = {\n+        let edit = AtomEdit::insert(offset, \"intellijRulezz\".to_string());\n+        original_file.reparse(&edit)\n+    };\n+    let mut has_completions = false;\n+    let mut res = Vec::new();\n+    if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(file.syntax(), offset) {\n+        has_completions = true;\n+        complete_name_ref(&file, name_ref, &mut res);\n+        // special case, `trait T { fn foo(i_am_a_name_ref) {} }`\n+        if is_node::<ast::Param>(name_ref.syntax()) {\n+            param_completions(name_ref.syntax(), &mut res);\n+        }\n+        let name_range = name_ref.syntax().range();\n+        let top_node = name_ref\n+            .syntax()\n+            .ancestors()\n+            .take_while(|it| it.range() == name_range)\n+            .last()\n+            .unwrap();\n+        match top_node.parent().map(|it| it.kind()) {\n+            Some(ROOT) | Some(ITEM_LIST) => complete_mod_item_snippets(&mut res),\n+            _ => (),\n+        }\n+    }\n+    if let Some(name) = find_node_at_offset::<ast::Name>(file.syntax(), offset) {\n+        if is_node::<ast::Param>(name.syntax()) {\n+            has_completions = true;\n+            param_completions(name.syntax(), &mut res);\n+        }\n+    }\n+    if has_completions {\n+        Some(res)\n+    } else {\n+        None\n+    }\n+}\n+\n+fn complete_module_items(\n+    file: &File,\n+    items: AstChildren<ast::ModuleItem>,\n+    this_item: Option<ast::NameRef>,\n+    acc: &mut Vec<CompletionItem>,\n+) {\n+    let scope = ModuleScope::from_items(items);\n+    acc.extend(\n+        scope\n+            .entries()\n+            .iter()\n+            .filter(|entry| {\n+                let syntax = entry.ptr().resolve(file);\n+                Some(syntax.borrowed()) != this_item.map(|it| it.syntax())\n+            })\n+            .map(|entry| CompletionItem {\n+                label: entry.name().to_string(),\n+                lookup: None,\n+                snippet: None,\n+            }),\n+    );\n+}\n+\n+fn complete_name_ref(\n+    file: &File,\n+    name_ref: ast::NameRef,\n+    acc: &mut Vec<CompletionItem>,\n+) {\n+    if !is_node::<ast::Path>(name_ref.syntax()) {\n+        return;\n+    }\n+    let mut visited_fn = false;\n+    for node in name_ref.syntax().ancestors() {\n+        if let Some(items) = visitor()\n+            .visit::<ast::Root, _>(|it| Some(it.items()))\n+            .visit::<ast::Module, _>(|it| Some(it.item_list()?.items()))\n+            .accept(node)\n+        {\n+            if let Some(items) = items {\n+                complete_module_items(file, items, Some(name_ref), acc);\n+            }\n+            break;\n+        } else if !visited_fn {\n+            if let Some(fn_def) = ast::FnDef::cast(node) {\n+                visited_fn = true;\n+                complete_expr_keywords(&file, fn_def, name_ref, acc);\n+                complete_expr_snippets(acc);\n+                let scopes = FnScopes::new(fn_def);\n+                complete_fn(name_ref, &scopes, acc);\n+            }\n+        }\n+    }\n+}\n+\n+fn param_completions(ctx: SyntaxNodeRef, acc: &mut Vec<CompletionItem>) {\n+    let mut params = FxHashMap::default();\n+    for node in ctx.ancestors() {\n+        let _ = visitor_ctx(&mut params)\n+            .visit::<ast::Root, _>(process)\n+            .visit::<ast::ItemList, _>(process)\n+            .accept(node);\n+    }\n+    params\n+        .into_iter()\n+        .filter_map(|(label, (count, param))| {\n+            let lookup = param.pat()?.syntax().text().to_string();\n+            if count < 2 {\n+                None\n+            } else {\n+                Some((label, lookup))\n+            }\n+        })\n+        .for_each(|(label, lookup)| {\n+            acc.push(CompletionItem {\n+                label,\n+                lookup: Some(lookup),\n+                snippet: None,\n+            })\n+        });\n+\n+    fn process<'a, N: ast::FnDefOwner<'a>>(\n+        node: N,\n+        params: &mut FxHashMap<String, (u32, ast::Param<'a>)>,\n+    ) {\n+        node.functions()\n+            .filter_map(|it| it.param_list())\n+            .flat_map(|it| it.params())\n+            .for_each(|param| {\n+                let text = param.syntax().text().to_string();\n+                params.entry(text).or_insert((0, param)).0 += 1;\n+            })\n+    }\n+}\n+\n+fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n+    match node.ancestors().filter_map(N::cast).next() {\n+        None => false,\n+        Some(n) => n.syntax().range() == node.range(),\n+    }\n+}\n+\n+fn complete_expr_keywords(\n+    file: &File,\n+    fn_def: ast::FnDef,\n+    name_ref: ast::NameRef,\n+    acc: &mut Vec<CompletionItem>,\n+) {\n+    acc.push(keyword(\"if\", \"if $0 {}\"));\n+    acc.push(keyword(\"match\", \"match $0 {}\"));\n+    acc.push(keyword(\"while\", \"while $0 {}\"));\n+    acc.push(keyword(\"loop\", \"loop {$0}\"));\n+\n+    if let Some(off) = name_ref.syntax().range().start().checked_sub(2.into()) {\n+        if let Some(if_expr) = find_node_at_offset::<ast::IfExpr>(file.syntax(), off) {\n+            if if_expr.syntax().range().end() < name_ref.syntax().range().start() {\n+                acc.push(keyword(\"else\", \"else {$0}\"));\n+                acc.push(keyword(\"else if\", \"else if $0 {}\"));\n+            }\n+        }\n+    }\n+    if is_in_loop_body(name_ref) {\n+        acc.push(keyword(\"continue\", \"continue\"));\n+        acc.push(keyword(\"break\", \"break\"));\n+    }\n+    acc.extend(complete_return(fn_def, name_ref));\n+}\n+\n+fn is_in_loop_body(name_ref: ast::NameRef) -> bool {\n+    for node in name_ref.syntax().ancestors() {\n+        if node.kind() == FN_DEF || node.kind() == LAMBDA_EXPR {\n+            break;\n+        }\n+        let loop_body = visitor()\n+            .visit::<ast::ForExpr, _>(LoopBodyOwner::loop_body)\n+            .visit::<ast::WhileExpr, _>(LoopBodyOwner::loop_body)\n+            .visit::<ast::LoopExpr, _>(LoopBodyOwner::loop_body)\n+            .accept(node);\n+        if let Some(Some(body)) = loop_body {\n+            if name_ref.syntax().range().is_subrange(&body.syntax().range()) {\n+                return true;\n+            }\n+        }\n+    }\n+    false\n+}\n+\n+fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<CompletionItem> {\n+    // let is_last_in_block = name_ref.syntax().ancestors().filter_map(ast::Expr::cast)\n+    //     .next()\n+    //     .and_then(|it| it.syntax().parent())\n+    //     .and_then(ast::Block::cast)\n+    //     .is_some();\n+\n+    // if is_last_in_block {\n+    //     return None;\n+    // }\n+\n+    let is_stmt = match name_ref\n+        .syntax()\n+        .ancestors()\n+        .filter_map(ast::ExprStmt::cast)\n+        .next()\n+    {\n+        None => false,\n+        Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n+    };\n+    let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n+        (true, true) => \"return $0;\",\n+        (true, false) => \"return;\",\n+        (false, true) => \"return $0\",\n+        (false, false) => \"return\",\n+    };\n+    Some(keyword(\"return\", snip))\n+}\n+\n+fn keyword(kw: &str, snip: &str) -> CompletionItem {\n+    CompletionItem {\n+        label: kw.to_string(),\n+        lookup: None,\n+        snippet: Some(snip.to_string()),\n+    }\n+}\n+\n+fn complete_expr_snippets(acc: &mut Vec<CompletionItem>) {\n+    acc.push(CompletionItem {\n+        label: \"pd\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\".to_string()),\n+    });\n+    acc.push(CompletionItem {\n+        label: \"ppd\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\".to_string()),\n+    });\n+}\n+\n+fn complete_mod_item_snippets(acc: &mut Vec<CompletionItem>) {\n+    acc.push(CompletionItem {\n+        label: \"tfn\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\".to_string()),\n+    });\n+    acc.push(CompletionItem {\n+        label: \"pub(crate)\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"pub(crate) $0\".to_string()),\n+    })\n+}\n+\n+fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n+    let mut shadowed = FxHashSet::default();\n+    acc.extend(\n+        scopes\n+            .scope_chain(name_ref.syntax())\n+            .flat_map(|scope| scopes.entries(scope).iter())\n+            .filter(|entry| shadowed.insert(entry.name()))\n+            .map(|entry| CompletionItem {\n+                label: entry.name().to_string(),\n+                lookup: None,\n+                snippet: None,\n+            }),\n+    );\n+    if scopes.self_param.is_some() {\n+        acc.push(CompletionItem {\n+            label: \"self\".to_string(),\n+            lookup: None,\n+            snippet: None,\n+        })\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use test_utils::{assert_eq_dbg, extract_offset};\n+\n+    use crate::FileId;\n+    use crate::mock_analysis::MockAnalysis;\n+\n+    use super::*;\n+\n+    fn check_scope_completion(code: &str, expected_completions: &str) {\n+        let (off, code) = extract_offset(&code);\n+        let analysis = MockAnalysis::with_files(&[(\"/main.rs\", &code)]).analysis();\n+        let file_id = FileId(1);\n+        let completions = scope_completion(&analysis.imp.db, file_id, off)\n+            .unwrap()\n+            .into_iter()\n+            .filter(|c| c.snippet.is_none())\n+            .collect::<Vec<_>>();\n+        assert_eq_dbg(expected_completions, &completions);\n+    }\n+\n+    fn check_snippet_completion(code: &str, expected_completions: &str) {\n+        let (off, code) = extract_offset(&code);\n+        let analysis = MockAnalysis::with_files(&[(\"/main.rs\", &code)]).analysis();\n+        let file_id = FileId(1);\n+        let completions = scope_completion(&analysis.imp.db, file_id, off)\n+            .unwrap()\n+            .into_iter()\n+            .filter(|c| c.snippet.is_some())\n+            .collect::<Vec<_>>();\n+        assert_eq_dbg(expected_completions, &completions);\n+    }\n+\n+    #[test]\n+    fn test_completion_let_scope() {\n+        check_scope_completion(\n+            r\"\n+            fn quux(x: i32) {\n+                let y = 92;\n+                1 + <|>;\n+                let z = ();\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"y\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"x\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_if_let_scope() {\n+        check_scope_completion(\n+            r\"\n+            fn quux() {\n+                if let Some(x) = foo() {\n+                    let y = 92;\n+                };\n+                if let Some(a) = bar() {\n+                    let b = 62;\n+                    1 + <|>\n+                }\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"b\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"a\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_for_scope() {\n+        check_scope_completion(\n+            r\"\n+            fn quux() {\n+                for x in &[1, 2, 3] {\n+                    <|>\n+                }\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"x\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope() {\n+        check_scope_completion(\n+            r\"\n+            struct Foo;\n+            enum Baz {}\n+            fn quux() {\n+                <|>\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"Baz\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope_no_self_use() {\n+        check_scope_completion(\n+            r\"\n+            use foo<|>;\n+            \",\n+            r#\"[]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_completion_mod_scope_nested() {\n+        check_scope_completion(\n+            r\"\n+            struct Foo;\n+            mod m {\n+                struct Bar;\n+                fn quux() { <|> }\n+            }\n+            \",\n+            r#\"[CompletionItem { label: \"Bar\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_complete_type() {\n+        check_scope_completion(\n+            r\"\n+            struct Foo;\n+            fn x() -> <|>\n+        \",\n+            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n+               CompletionItem { label: \"x\", lookup: None, snippet: None }]\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_complete_shadowing() {\n+        check_scope_completion(\n+            r\"\n+            fn foo() -> {\n+                let bar = 92;\n+                {\n+                    let bar = 62;\n+                    <|>\n+                }\n+            }\n+        \",\n+            r#\"[CompletionItem { label: \"bar\", lookup: None, snippet: None },\n+               CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_complete_self() {\n+        check_scope_completion(\n+            r\"\n+            impl S { fn foo(&self) { <|> } }\n+        \",\n+            r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None }]\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn test_completion_kewords() {\n+        check_snippet_completion(r\"\n+            fn quux() {\n+                <|>\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_completion_else() {\n+        check_snippet_completion(r\"\n+            fn quux() {\n+                if true {\n+                    ()\n+                } <|>\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"else\", lookup: None, snippet: Some(\"else {$0}\") },\n+                   CompletionItem { label: \"else if\", lookup: None, snippet: Some(\"else if $0 {}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_completion_return_value() {\n+        check_snippet_completion(r\"\n+            fn quux() -> i32 {\n+                <|>\n+                92\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0;\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+        check_snippet_completion(r\"\n+            fn quux() {\n+                <|>\n+                92\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return;\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_completion_return_no_stmt() {\n+        check_snippet_completion(r\"\n+            fn quux() -> i32 {\n+                match () {\n+                    () => <|>\n+                }\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_continue_break_completion() {\n+        check_snippet_completion(r\"\n+            fn quux() -> i32 {\n+                loop { <|> }\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"continue\", lookup: None, snippet: Some(\"continue\") },\n+                   CompletionItem { label: \"break\", lookup: None, snippet: Some(\"break\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+        check_snippet_completion(r\"\n+            fn quux() -> i32 {\n+                loop { || { <|> } }\n+            }\n+            \", r#\"[CompletionItem { label: \"if\", lookup: None, snippet: Some(\"if $0 {}\") },\n+                   CompletionItem { label: \"match\", lookup: None, snippet: Some(\"match $0 {}\") },\n+                   CompletionItem { label: \"while\", lookup: None, snippet: Some(\"while $0 {}\") },\n+                   CompletionItem { label: \"loop\", lookup: None, snippet: Some(\"loop {$0}\") },\n+                   CompletionItem { label: \"return\", lookup: None, snippet: Some(\"return $0\") },\n+                   CompletionItem { label: \"pd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\") },\n+                   CompletionItem { label: \"ppd\", lookup: None, snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\") }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_param_completion_last_param() {\n+        check_scope_completion(r\"\n+            fn foo(file_id: FileId) {}\n+            fn bar(file_id: FileId) {}\n+            fn baz(file<|>) {}\n+        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_param_completion_nth_param() {\n+        check_scope_completion(r\"\n+            fn foo(file_id: FileId) {}\n+            fn bar(file_id: FileId) {}\n+            fn baz(file<|>, x: i32) {}\n+        \", r#\"[CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_param_completion_trait_param() {\n+        check_scope_completion(r\"\n+            pub(crate) trait SourceRoot {\n+                pub fn contains(&self, file_id: FileId) -> bool;\n+                pub fn module_map(&self) -> &ModuleMap;\n+                pub fn lines(&self, file_id: FileId) -> &LineIndex;\n+                pub fn syntax(&self, file<|>)\n+            }\n+        \", r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None },\n+               CompletionItem { label: \"SourceRoot\", lookup: None, snippet: None },\n+               CompletionItem { label: \"file_id: FileId\", lookup: Some(\"file_id\"), snippet: None }]\"#);\n+    }\n+\n+    #[test]\n+    fn test_item_snippets() {\n+        // check_snippet_completion(r\"\n+        //     <|>\n+        //     \",\n+        //     r##\"[CompletionItem { label: \"tfn\", lookup: None, snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\") }]\"##,\n+        // );\n+        check_snippet_completion(r\"\n+            #[cfg(test)]\n+            mod tests {\n+                <|>\n+            }\n+            \",\n+            r##\"[CompletionItem { label: \"tfn\", lookup: None, snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\") },\n+                 CompletionItem { label: \"pub(crate)\", lookup: None, snippet: Some(\"pub(crate) $0\") }]\"##,\n+        );\n+    }\n+}"}, {"sha": "846b8b44f0aa5761cd18498d2c20a4fa5074d43a", "filename": "crates/ra_analysis/src/descriptors/module/scope.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors%2Fmodule%2Fscope.rs?ref=f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "patch": "@@ -30,8 +30,12 @@ enum EntryKind {\n \n impl ModuleScope {\n     pub fn new(file: &File) -> ModuleScope {\n+        ModuleScope::from_items(file.ast().items())\n+    }\n+\n+    pub fn from_items<'a>(items: impl Iterator<Item = ast::ModuleItem<'a>>) -> ModuleScope {\n         let mut entries = Vec::new();\n-        for item in file.ast().items() {\n+        for item in items {\n             let entry = match item {\n                 ast::ModuleItem::StructDef(item) => Entry::new(item),\n                 ast::ModuleItem::EnumDef(item) => Entry::new(item),"}, {"sha": "38d4b6a232aac98ce3f56886abb978a1792e205e", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "patch": "@@ -3,7 +3,7 @@ use std::{\n     sync::Arc,\n };\n \n-use ra_editor::{self, find_node_at_offset, FileSymbol, LineIndex, LocalEdit, CompletionItem};\n+use ra_editor::{self, find_node_at_offset, FileSymbol, LineIndex, LocalEdit};\n use ra_syntax::{\n     ast::{self, ArgListOwner, Expr, NameOwner},\n     AstNode, File, SmolStr,\n@@ -26,6 +26,7 @@ use crate::{\n         module::{ModuleTree, Problem},\n         function::{FnDescriptor, FnId},\n     },\n+    completion::{scope_completion, resolve_based_completion, CompletionItem},\n     symbol_index::SymbolIndex,\n     syntax_ptr::SyntaxPtrDatabase,\n     CrateGraph, CrateId, Diagnostic, FileId, FileResolver, FileSystemEdit, Position,\n@@ -179,7 +180,7 @@ impl AnalysisHostImpl {\n \n #[derive(Debug)]\n pub(crate) struct AnalysisImpl {\n-    db: db::RootDatabase,\n+    pub(crate) db: db::RootDatabase,\n }\n \n impl AnalysisImpl {\n@@ -249,12 +250,11 @@ impl AnalysisImpl {\n     pub fn completions(&self, file_id: FileId, offset: TextUnit) -> Cancelable<Option<Vec<CompletionItem>>> {\n         let mut res = Vec::new();\n         let mut has_completions = false;\n-        let file = self.file_syntax(file_id);\n-        if let Some(scope_based) = ra_editor::scope_completion(&file, offset) {\n+        if let Some(scope_based) = scope_completion(&self.db, file_id, offset) {\n             res.extend(scope_based);\n             has_completions = true;\n         }\n-        if let Some(scope_based) = crate::completion::resolve_based_completion(&self.db, file_id, offset)? {\n+        if let Some(scope_based) = resolve_based_completion(&self.db, file_id, offset)? {\n             res.extend(scope_based);\n             has_completions = true;\n         }"}, {"sha": "77601028165f06c94131da9ce043c193ec8336f2", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "patch": "@@ -13,6 +13,7 @@ mod imp;\n mod symbol_index;\n mod completion;\n mod syntax_ptr;\n+mod mock_analysis;\n \n use std::{\n     fmt,\n@@ -30,10 +31,12 @@ use crate::{\n \n pub use crate::{\n     descriptors::function::FnDescriptor,\n-    input::{FileId, FileResolver, CrateGraph, CrateId}\n+    completion::CompletionItem,\n+    input::{FileId, FileResolver, CrateGraph, CrateId},\n+    mock_analysis::MockAnalysis,\n };\n pub use ra_editor::{\n-    CompletionItem, FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, Runnable,\n+    FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, Runnable,\n     RunnableKind, StructureNode,\n };\n \n@@ -197,7 +200,7 @@ impl Query {\n \n #[derive(Debug)]\n pub struct Analysis {\n-    imp: AnalysisImpl,\n+    pub(crate) imp: AnalysisImpl,\n }\n \n impl Analysis {"}, {"sha": "1c1dbee7c75250387ca90e73104c31aef460d6a3", "filename": "crates/ra_analysis/src/mock_analysis.rs", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmock_analysis.rs?ref=f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "patch": "@@ -0,0 +1,71 @@\n+\n+use std::sync::Arc;\n+\n+use relative_path::{RelativePath, RelativePathBuf};\n+\n+use crate::{\n+    AnalysisChange, Analysis, AnalysisHost, FileId, FileResolver,\n+};\n+\n+/// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n+/// from a set of in-memory files.\n+#[derive(Debug, Default)]\n+pub struct MockAnalysis {\n+    files: Vec<(String, String)>,\n+}\n+\n+impl MockAnalysis {\n+    pub fn new() -> MockAnalysis {\n+        MockAnalysis::default()\n+    }\n+    pub fn with_files(files: &[(&str, &str)]) -> MockAnalysis {\n+        let files = files.iter()\n+            .map(|it| (it.0.to_string(), it.1.to_string()))\n+            .collect();\n+        MockAnalysis { files }\n+    }\n+    pub fn analysis_host(self) -> AnalysisHost {\n+        let mut host = AnalysisHost::new();\n+        let mut file_map = Vec::new();\n+        let mut change = AnalysisChange::new();\n+        for (id, (path, contents)) in self.files.into_iter().enumerate() {\n+            let file_id = FileId((id + 1) as u32);\n+            assert!(path.starts_with('/'));\n+            let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n+            change.add_file(file_id, contents);\n+            file_map.push((file_id, path));\n+        }\n+        change.set_file_resolver(Arc::new(FileMap(file_map)));\n+        host.apply_change(change);\n+        host\n+    }\n+    pub fn analysis(self) -> Analysis {\n+        self.analysis_host().analysis()\n+    }\n+}\n+\n+#[derive(Debug)]\n+struct FileMap(Vec<(FileId, RelativePathBuf)>);\n+\n+impl FileMap {\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = (FileId, &'a RelativePath)> + 'a {\n+        self.0\n+            .iter()\n+            .map(|(id, path)| (*id, path.as_relative_path()))\n+    }\n+\n+    fn path(&self, id: FileId) -> &RelativePath {\n+        self.iter().find(|&(it, _)| it == id).unwrap().1\n+    }\n+}\n+\n+impl FileResolver for FileMap {\n+    fn file_stem(&self, id: FileId) -> String {\n+        self.path(id).file_stem().unwrap().to_string()\n+    }\n+    fn resolve(&self, id: FileId, rel: &RelativePath) -> Option<FileId> {\n+        let path = self.path(id).join(rel).normalize();\n+        let id = self.iter().find(|&(_, p)| path == p)?.0;\n+        Some(id)\n+    }\n+}"}, {"sha": "f5683aec5b5cd36edc0e80dc84a6adf021c3fe00", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 6, "deletions": 50, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f3fb59d7077801a3a68d2d03eef17d59c2925ae8/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=f3fb59d7077801a3a68d2d03eef17d59c2925ae8", "patch": "@@ -5,62 +5,16 @@ extern crate relative_path;\n extern crate rustc_hash;\n extern crate test_utils;\n \n-use std::{\n-    sync::Arc,\n-};\n-\n use ra_syntax::TextRange;\n-use relative_path::{RelativePath, RelativePathBuf};\n use test_utils::{assert_eq_dbg, extract_offset};\n \n use ra_analysis::{\n-    AnalysisChange, Analysis, AnalysisHost, CrateGraph, CrateId, FileId, FileResolver, FnDescriptor,\n+    MockAnalysis,\n+    AnalysisChange, Analysis, CrateGraph, CrateId, FileId, FnDescriptor,\n };\n \n-#[derive(Debug)]\n-struct FileMap(Vec<(FileId, RelativePathBuf)>);\n-\n-impl FileMap {\n-    fn iter<'a>(&'a self) -> impl Iterator<Item = (FileId, &'a RelativePath)> + 'a {\n-        self.0\n-            .iter()\n-            .map(|(id, path)| (*id, path.as_relative_path()))\n-    }\n-\n-    fn path(&self, id: FileId) -> &RelativePath {\n-        self.iter().find(|&(it, _)| it == id).unwrap().1\n-    }\n-}\n-\n-impl FileResolver for FileMap {\n-    fn file_stem(&self, id: FileId) -> String {\n-        self.path(id).file_stem().unwrap().to_string()\n-    }\n-    fn resolve(&self, id: FileId, rel: &RelativePath) -> Option<FileId> {\n-        let path = self.path(id).join(rel).normalize();\n-        let id = self.iter().find(|&(_, p)| path == p)?.0;\n-        Some(id)\n-    }\n-}\n-\n-fn analysis_host(files: &[(&str, &str)]) -> AnalysisHost {\n-    let mut host = AnalysisHost::new();\n-    let mut file_map = Vec::new();\n-    let mut change = AnalysisChange::new();\n-    for (id, &(path, contents)) in files.iter().enumerate() {\n-        let file_id = FileId((id + 1) as u32);\n-        assert!(path.starts_with('/'));\n-        let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n-        change.add_file(file_id, contents.to_string());\n-        file_map.push((file_id, path));\n-    }\n-    change.set_file_resolver(Arc::new(FileMap(file_map)));\n-    host.apply_change(change);\n-    host\n-}\n-\n fn analysis(files: &[(&str, &str)]) -> Analysis {\n-    analysis_host(files).analysis()\n+    MockAnalysis::with_files(files).analysis()\n }\n \n fn get_signature(text: &str) -> (FnDescriptor, Option<usize>) {\n@@ -125,7 +79,9 @@ fn test_resolve_parent_module() {\n \n #[test]\n fn test_resolve_crate_root() {\n-    let mut host = analysis_host(&[(\"/lib.rs\", \"mod foo;\"), (\"/foo.rs\", \"\")]);\n+    let mut host = MockAnalysis::with_files(\n+        &[(\"/lib.rs\", \"mod foo;\"), (\"/foo.rs\", \"\")]\n+    ).analysis_host();\n     let snap = host.analysis();\n     assert!(snap.crate_for(FileId(2)).unwrap().is_empty());\n "}]}