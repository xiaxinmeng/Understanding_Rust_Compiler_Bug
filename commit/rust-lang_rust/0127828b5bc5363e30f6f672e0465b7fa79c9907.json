{"sha": "0127828b5bc5363e30f6f672e0465b7fa79c9907", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxMjc4MjhiNWJjNTM2M2UzMGY2ZjY3MmUwNDY1YjdmYTc5Yzk5MDc=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-09T00:20:36Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-02-09T00:20:36Z"}, "message": "oldmap: separate out the methods that need Copy", "tree": {"sha": "fad6dba4e7ca2b589e02af95057e90692c3fe9d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fad6dba4e7ca2b589e02af95057e90692c3fe9d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0127828b5bc5363e30f6f672e0465b7fa79c9907", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0127828b5bc5363e30f6f672e0465b7fa79c9907", "html_url": "https://github.com/rust-lang/rust/commit/0127828b5bc5363e30f6f672e0465b7fa79c9907", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0127828b5bc5363e30f6f672e0465b7fa79c9907/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a32c5c73ee6aad9cb4b2e06867eafa09bc1ece3a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a32c5c73ee6aad9cb4b2e06867eafa09bc1ece3a", "html_url": "https://github.com/rust-lang/rust/commit/a32c5c73ee6aad9cb4b2e06867eafa09bc1ece3a"}], "stats": {"total": 66, "additions": 34, "deletions": 32}, "files": [{"sha": "62ca25ed69d00707741f9755b93700693a7b8020", "filename": "src/libstd/oldmap.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/0127828b5bc5363e30f6f672e0465b7fa79c9907/src%2Flibstd%2Foldmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0127828b5bc5363e30f6f672e0465b7fa79c9907/src%2Flibstd%2Foldmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foldmap.rs?ref=0127828b5bc5363e30f6f672e0465b7fa79c9907", "patch": "@@ -76,7 +76,7 @@ pub mod chained {\n         FoundAfter(@Entry<K,V>, @Entry<K,V>)\n     }\n \n-    priv impl<K:Eq IterBytes Hash, V: Copy> T<K, V> {\n+    priv impl<K:Eq IterBytes Hash, V> T<K, V> {\n         pure fn search_rem(k: &K, h: uint, idx: uint,\n                            e_root: @Entry<K,V>) -> SearchResult<K,V> {\n             let mut e0 = e_root;\n@@ -172,7 +172,7 @@ pub mod chained {\n         }\n     }\n \n-    impl<K:Eq IterBytes Hash Copy, V: Copy> T<K, V> {\n+    impl<K: Eq IterBytes Hash, V> T<K, V> {\n         pure fn contains_key(&self, k: &K) -> bool {\n             let hash = k.hash_keyed(0,0) as uint;\n             match self.search_tbl(k, hash) {\n@@ -225,6 +225,38 @@ pub mod chained {\n             }\n         }\n \n+        fn remove(k: &K) -> bool {\n+            match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n+              NotFound => false,\n+              FoundFirst(idx, entry) => {\n+                self.count -= 1u;\n+                self.chains[idx] = entry.next;\n+                true\n+              }\n+              FoundAfter(eprev, entry) => {\n+                self.count -= 1u;\n+                eprev.next = entry.next;\n+                true\n+              }\n+            }\n+        }\n+\n+        pure fn each(&self, blk: fn(key: &K, value: &V) -> bool) {\n+            for self.each_entry |entry| {\n+                if !blk(&entry.key, &entry.value) { break; }\n+            }\n+        }\n+\n+        pure fn each_key(&self, blk: fn(key: &K) -> bool) {\n+            self.each(|k, _v| blk(k))\n+        }\n+\n+        pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n+            self.each(|_k, v| blk(v))\n+        }\n+    }\n+\n+    impl<K: Eq IterBytes Hash Copy, V: Copy> T<K, V> {\n         pure fn find(&self, k: &K) -> Option<V> {\n             unsafe {\n                 match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n@@ -297,36 +329,6 @@ pub mod chained {\n             }\n             option::unwrap(move opt_v)\n         }\n-\n-        fn remove(k: &K) -> bool {\n-            match self.search_tbl(k, k.hash_keyed(0,0) as uint) {\n-              NotFound => false,\n-              FoundFirst(idx, entry) => {\n-                self.count -= 1u;\n-                self.chains[idx] = entry.next;\n-                true\n-              }\n-              FoundAfter(eprev, entry) => {\n-                self.count -= 1u;\n-                eprev.next = entry.next;\n-                true\n-              }\n-            }\n-        }\n-\n-        pure fn each(&self, blk: fn(key: &K, value: &V) -> bool) {\n-            for self.each_entry |entry| {\n-                if !blk(&entry.key, &entry.value) { break; }\n-            }\n-        }\n-\n-        pure fn each_key(&self, blk: fn(key: &K) -> bool) {\n-            self.each(|k, _v| blk(k))\n-        }\n-\n-        pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n-            self.each(|_k, v| blk(v))\n-        }\n     }\n \n     impl<K:Eq IterBytes Hash Copy ToStr, V: ToStr Copy> T<K, V> {"}]}