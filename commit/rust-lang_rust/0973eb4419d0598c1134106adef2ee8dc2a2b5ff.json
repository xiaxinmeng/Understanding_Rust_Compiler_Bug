{"sha": "0973eb4419d0598c1134106adef2ee8dc2a2b5ff", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5NzNlYjQ0MTlkMDU5OGMxMTM0MTA2YWRlZjJlZThkYzJhMmI1ZmY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-16T18:46:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-06-16T18:46:45Z"}, "message": "auto merge of #14551 : alexcrichton/rust/issue-14467, r=kballard\n\nForking off a child which survives the parent is often a useful task, and is\r\ncurrently not possible because the Process type will invoke `wait()` in its\r\ndestructor in order to prevent leaking resources. This function adds a new safe\r\nmethod, `daemonize`, which can be used to consume an instance of `Process` which\r\nwill then not call `wait` in the destructor.\r\n\r\nThis new method is clearly documented as a leak of resources, but it must be\r\nforcibly opted in to.\r\n\r\nCloses #14467", "tree": {"sha": "104b15384719ebd66718f846f9dbeedaed85e0d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/104b15384719ebd66718f846f9dbeedaed85e0d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0973eb4419d0598c1134106adef2ee8dc2a2b5ff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0973eb4419d0598c1134106adef2ee8dc2a2b5ff", "html_url": "https://github.com/rust-lang/rust/commit/0973eb4419d0598c1134106adef2ee8dc2a2b5ff", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0973eb4419d0598c1134106adef2ee8dc2a2b5ff/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b672a63da3083ab6d4673cdb223bc1c978ed7d2", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b672a63da3083ab6d4673cdb223bc1c978ed7d2", "html_url": "https://github.com/rust-lang/rust/commit/4b672a63da3083ab6d4673cdb223bc1c978ed7d2"}, {"sha": "2fe926431bb198a052a5eae92ff820a4f572fd92", "url": "https://api.github.com/repos/rust-lang/rust/commits/2fe926431bb198a052a5eae92ff820a4f572fd92", "html_url": "https://github.com/rust-lang/rust/commit/2fe926431bb198a052a5eae92ff820a4f572fd92"}], "stats": {"total": 23, "additions": 23, "deletions": 0}, "files": [{"sha": "1dcf08b2322bbf802a03d79ae0f1a992a3327868", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0973eb4419d0598c1134106adef2ee8dc2a2b5ff/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0973eb4419d0598c1134106adef2ee8dc2a2b5ff/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=0973eb4419d0598c1134106adef2ee8dc2a2b5ff", "patch": "@@ -59,6 +59,7 @@ use c_str::CString;\n /// ```\n pub struct Process {\n     handle: Box<RtioProcess + Send>,\n+    forget: bool,\n \n     /// Handle to the child's stdin, if the `stdin` field of this process's\n     /// `ProcessConfig` was `CreatePipe`. By default, this handle is `Some`.\n@@ -262,6 +263,7 @@ impl Command {\n                 });\n                 Process {\n                     handle: p,\n+                    forget: false,\n                     stdin: io.next().unwrap(),\n                     stdout: io.next().unwrap(),\n                     stderr: io.next().unwrap(),\n@@ -540,10 +542,23 @@ impl Process {\n             error:  stderr.recv().ok().unwrap_or(Vec::new()),\n         })\n     }\n+\n+    /// Forgets this process, allowing it to outlive the parent\n+    ///\n+    /// This function will forcefully prevent calling `wait()` on the child\n+    /// process in the destructor, allowing the child to outlive the\n+    /// parent. Note that this operation can easily lead to leaking the\n+    /// resources of the child process, so care must be taken when\n+    /// invoking this method.\n+    pub fn forget(mut self) {\n+        self.forget = true;\n+    }\n }\n \n impl Drop for Process {\n     fn drop(&mut self) {\n+        if self.forget { return }\n+\n         // Close all I/O before exiting to ensure that the child doesn't wait\n         // forever to print some text or something similar.\n         drop(self.stdin.take());\n@@ -933,4 +948,12 @@ mod tests {\n         rx.recv();\n         rx.recv();\n     })\n+\n+    iotest!(fn forget() {\n+        let p = sleeper();\n+        let id = p.id();\n+        p.forget();\n+        assert!(Process::kill(id, 0).is_ok());\n+        assert!(Process::kill(id, PleaseExitSignal).is_ok());\n+    })\n }"}]}