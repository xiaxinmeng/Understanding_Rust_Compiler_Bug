{"sha": "caef91d7c6dcfc307b9e915bd9a80a25063cce22", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhZWY5MWQ3YzZkY2ZjMzA3YjllOTE1YmQ5YTgwYTI1MDYzY2NlMjI=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-09-14T19:50:18Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-11-19T00:14:30Z"}, "message": "rustc: introduce layout::Abi for reduced general ABI \"passing style\".", "tree": {"sha": "16402f874177b9d462263c3e68dea2be288023c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16402f874177b9d462263c3e68dea2be288023c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/caef91d7c6dcfc307b9e915bd9a80a25063cce22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/caef91d7c6dcfc307b9e915bd9a80a25063cce22", "html_url": "https://github.com/rust-lang/rust/commit/caef91d7c6dcfc307b9e915bd9a80a25063cce22", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/caef91d7c6dcfc307b9e915bd9a80a25063cce22/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1dc572b85e1f7bc245fb31ba659c822d68fda0bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/1dc572b85e1f7bc245fb31ba659c822d68fda0bc", "html_url": "https://github.com/rust-lang/rust/commit/1dc572b85e1f7bc245fb31ba659c822d68fda0bc"}], "stats": {"total": 232, "additions": 105, "deletions": 127}, "files": [{"sha": "99dd73e03c752397e0c6f1dbf27b22e02e668c4b", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 54, "deletions": 5, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/caef91d7c6dcfc307b9e915bd9a80a25063cce22/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caef91d7c6dcfc307b9e915bd9a80a25063cce22/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=caef91d7c6dcfc307b9e915bd9a80a25063cce22", "patch": "@@ -1054,6 +1054,15 @@ impl<'a> FieldPlacement<'a> {\n     }\n }\n \n+/// Describes how values of the type are passed by target ABIs,\n+/// in terms of categories of C types there are ABI rules for.\n+#[derive(Copy, Clone, Debug)]\n+pub enum Abi {\n+    Scalar(Primitive),\n+    Vector,\n+    Aggregate\n+}\n+\n /// Type layout, from which size and alignment can be cheaply computed.\n /// For ADTs, it also includes field placement and enum optimizations.\n /// NOTE: Because Layout is interned, redundant information should be\n@@ -1172,6 +1181,7 @@ impl<'tcx> fmt::Display for LayoutError<'tcx> {\n pub struct CachedLayout<'tcx> {\n     pub layout: &'tcx Layout,\n     pub fields: FieldPlacement<'tcx>,\n+    pub abi: Abi,\n }\n \n fn layout_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -1258,9 +1268,24 @@ impl<'a, 'tcx> Layout {\n                     }\n                 }\n             };\n+            let abi = match *layout {\n+                Scalar { value, .. } |\n+                RawNullablePointer { discr: value, .. } => Abi::Scalar(value),\n+                CEnum { discr, .. } => Abi::Scalar(Int(discr)),\n+\n+                Vector { .. } => Abi::Vector,\n+\n+                Array { .. } |\n+                FatPointer { .. } |\n+                Univariant(_) |\n+                UntaggedUnion(_) |\n+                General { .. } |\n+                StructWrappedNullablePointer { .. } => Abi::Aggregate\n+            };\n             Ok(CachedLayout {\n                 layout,\n-                fields\n+                fields,\n+                abi\n             })\n         };\n         assert!(!ty.has_infer_types());\n@@ -1670,7 +1695,8 @@ impl<'a, 'tcx> Layout {\n                 let layout = cx.layout_of(normalized)?;\n                 return Ok(CachedLayout {\n                     layout: layout.layout,\n-                    fields: layout.fields\n+                    fields: layout.fields,\n+                    abi: layout.abi\n                 });\n             }\n             ty::TyParam(_) => {\n@@ -2158,6 +2184,7 @@ pub struct FullLayout<'tcx> {\n     pub variant_index: Option<usize>,\n     pub layout: &'tcx Layout,\n     pub fields: FieldPlacement<'tcx>,\n+    pub abi: Abi,\n }\n \n impl<'tcx> Deref for FullLayout<'tcx> {\n@@ -2225,7 +2252,8 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (TyCtxt<'a, 'tcx, 'tcx>, ty::ParamEnv<'tcx\n             ty,\n             variant_index: None,\n             layout: cached.layout,\n-            fields: cached.fields\n+            fields: cached.fields,\n+            abi: cached.abi\n         })\n     }\n }\n@@ -2255,7 +2283,8 @@ impl<'a, 'tcx> LayoutOf<Ty<'tcx>> for (ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>,\n             ty,\n             variant_index: None,\n             layout: cached.layout,\n-            fields: cached.fields\n+            fields: cached.fields,\n+            abi: cached.abi\n         })\n     }\n }\n@@ -2492,9 +2521,29 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for FieldPlacement<'gcx> {\n     }\n }\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for Abi {\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        use ty::layout::Abi::*;\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+\n+        match *self {\n+            Scalar(value) => {\n+                value.hash_stable(hcx, hasher);\n+            }\n+            Vector => {\n+            }\n+            Aggregate => {\n+            }\n+        }\n+    }\n+}\n+\n impl_stable_hash_for!(struct ::ty::layout::CachedLayout<'tcx> {\n     layout,\n-    fields\n+    fields,\n+    abi\n });\n \n impl_stable_hash_for!(enum ::ty::layout::Integer {"}, {"sha": "8be2cb2a1d326ca3d8e83a7d8cadcfa3a08b65f2", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 31, "deletions": 77, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/caef91d7c6dcfc307b9e915bd9a80a25063cce22/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caef91d7c6dcfc307b9e915bd9a80a25063cce22/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=caef91d7c6dcfc307b9e915bd9a80a25063cce22", "patch": "@@ -40,7 +40,7 @@ use rustc::ty::layout::{HasDataLayout, LayoutOf};\n use rustc_back::PanicStrategy;\n \n use libc::c_uint;\n-use std::iter;\n+use std::{cmp, iter};\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n@@ -276,26 +276,17 @@ pub trait LayoutExt<'tcx> {\n \n impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n     fn is_aggregate(&self) -> bool {\n-        match *self.layout {\n-            Layout::Scalar { .. } |\n-            Layout::RawNullablePointer { .. } |\n-            Layout::CEnum { .. } |\n-            Layout::Vector { .. } => false,\n-\n-            Layout::Array { .. } |\n-            Layout::FatPointer { .. } |\n-            Layout::Univariant { .. } |\n-            Layout::UntaggedUnion { .. } |\n-            Layout::General { .. } |\n-            Layout::StructWrappedNullablePointer { .. } => true\n+        match self.abi {\n+            layout::Abi::Scalar(_) |\n+            layout::Abi::Vector => false,\n+            layout::Abi::Aggregate => true\n         }\n     }\n \n     fn homogeneous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg> {\n-        match *self.layout {\n-            // The primitives for this algorithm.\n-            Layout::Scalar { value, .. } |\n-            Layout::RawNullablePointer { discr: value, .. } => {\n+        match self.abi {\n+            // The primitive for this algorithm.\n+            layout::Abi::Scalar(value) => {\n                 let kind = match value {\n                     layout::Int(_) |\n                     layout::Pointer => RegKind::Integer,\n@@ -308,70 +299,35 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n                 })\n             }\n \n-            Layout::CEnum { .. } => {\n-                Some(Reg {\n-                    kind: RegKind::Integer,\n-                    size: self.size(ccx)\n-                })\n-            }\n-\n-            Layout::Vector { .. } => {\n+            layout::Abi::Vector => {\n                 Some(Reg {\n                     kind: RegKind::Vector,\n                     size: self.size(ccx)\n                 })\n             }\n \n-            Layout::Array { count, .. } => {\n-                if count > 0 {\n-                    self.field(ccx, 0).homogeneous_aggregate(ccx)\n-                } else {\n-                    None\n+            layout::Abi::Aggregate => {\n+                if let Layout::Array { count, .. } = *self.layout {\n+                    if count > 0 {\n+                        return self.field(ccx, 0).homogeneous_aggregate(ccx);\n+                    }\n                 }\n-            }\n \n-            Layout::Univariant(ref variant) => {\n-                let mut unaligned_offset = Size::from_bytes(0);\n+                let mut total = Size::from_bytes(0);\n                 let mut result = None;\n \n-                for i in 0..self.fields.count() {\n-                    if unaligned_offset != variant.offsets[i] {\n-                        return None;\n+                let is_union = match self.fields {\n+                    layout::FieldPlacement::Linear { stride, .. } => {\n+                        stride.bytes() == 0\n                     }\n+                    layout::FieldPlacement::Arbitrary { .. } => false\n+                };\n \n-                    let field = self.field(ccx, i);\n-                    match (result, field.homogeneous_aggregate(ccx)) {\n-                        // The field itself must be a homogeneous aggregate.\n-                        (_, None) => return None,\n-                        // If this is the first field, record the unit.\n-                        (None, Some(unit)) => {\n-                            result = Some(unit);\n-                        }\n-                        // For all following fields, the unit must be the same.\n-                        (Some(prev_unit), Some(unit)) => {\n-                            if prev_unit != unit {\n-                                return None;\n-                            }\n-                        }\n+                for i in 0..self.fields.count() {\n+                    if !is_union && total != self.fields.offset(i) {\n+                        return None;\n                     }\n \n-                    // Keep track of the offset (without padding).\n-                    unaligned_offset += field.size(ccx);\n-                }\n-\n-                // There needs to be no padding.\n-                if unaligned_offset != self.size(ccx) {\n-                    None\n-                } else {\n-                    result\n-                }\n-            }\n-\n-            Layout::UntaggedUnion { .. } => {\n-                let mut max = Size::from_bytes(0);\n-                let mut result = None;\n-\n-                for i in 0..self.fields.count() {\n                     let field = self.field(ccx, i);\n                     match (result, field.homogeneous_aggregate(ccx)) {\n                         // The field itself must be a homogeneous aggregate.\n@@ -390,23 +346,20 @@ impl<'tcx> LayoutExt<'tcx> for FullLayout<'tcx> {\n \n                     // Keep track of the offset (without padding).\n                     let size = field.size(ccx);\n-                    if size > max {\n-                        max = size;\n+                    if is_union {\n+                        total = cmp::max(total, size);\n+                    } else {\n+                        total += size;\n                     }\n                 }\n \n                 // There needs to be no padding.\n-                if max != self.size(ccx) {\n+                if total != self.size(ccx) {\n                     None\n                 } else {\n                     result\n                 }\n             }\n-\n-            // Rust-specific types, which we can ignore for C ABIs.\n-            Layout::FatPointer { .. } |\n-            Layout::General { .. } |\n-            Layout::StructWrappedNullablePointer { .. } => None\n         }\n     }\n }\n@@ -870,8 +823,9 @@ impl<'a, 'tcx> FnType<'tcx> {\n         if abi == Abi::Rust || abi == Abi::RustCall ||\n            abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             let fixup = |arg: &mut ArgType<'tcx>| {\n-                if !arg.layout.is_aggregate() {\n-                    return;\n+                match arg.layout.abi {\n+                    layout::Abi::Aggregate => {}\n+                    _ => return\n                 }\n \n                 let size = arg.layout.size(ccx);"}, {"sha": "2c3df8f02e6fb1a243fcdfac202ee89b141e2051", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 15, "deletions": 31, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/caef91d7c6dcfc307b9e915bd9a80a25063cce22/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caef91d7c6dcfc307b9e915bd9a80a25063cce22/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=caef91d7c6dcfc307b9e915bd9a80a25063cce22", "patch": "@@ -64,9 +64,8 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n             return Ok(());\n         }\n \n-        match *layout {\n-            Layout::Scalar { value, .. } |\n-            Layout::RawNullablePointer { discr: value, .. } => {\n+        match layout.abi {\n+            layout::Abi::Scalar(value) => {\n                 let reg = match value {\n                     layout::Int(_) |\n                     layout::Pointer => Class::Int,\n@@ -76,47 +75,32 @@ fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n                 unify(cls, off, reg);\n             }\n \n-            Layout::CEnum { .. } => {\n-                unify(cls, off, Class::Int);\n-            }\n-\n-            Layout::Vector { element, count } => {\n+            layout::Abi::Vector => {\n                 unify(cls, off, Class::Sse);\n \n                 // everything after the first one is the upper\n                 // half of a register.\n-                let eltsz = element.size(ccx);\n-                for i in 1..count {\n-                    unify(cls, off + eltsz * i, Class::SseUp);\n+                let eltsz = layout.field(ccx, 0).size(ccx);\n+                for i in 1..layout.fields.count() {\n+                    unify(cls, off + eltsz * (i as u64), Class::SseUp);\n                 }\n             }\n \n-            Layout::Array { count, .. } => {\n-                if count > 0 {\n-                    let elt = layout.field(ccx, 0);\n-                    let eltsz = elt.size(ccx);\n-                    for i in 0..count {\n-                        classify(ccx, elt, cls, off + eltsz * i)?;\n-                    }\n+            layout::Abi::Aggregate => {\n+                // FIXME(eddyb) have to work around Rust enums for now.\n+                // Fix is either guarantee no data where there is no field,\n+                // by putting variants in fields, or be more clever.\n+                match *layout {\n+                    Layout::General { .. } |\n+                    Layout::StructWrappedNullablePointer { .. } => return Err(Memory),\n+                    _ => {}\n                 }\n-            }\n-\n-            Layout::Univariant(ref variant) => {\n                 for i in 0..layout.fields.count() {\n-                    let field_off = off + variant.offsets[i];\n+                    let field_off = off + layout.fields.offset(i);\n                     classify(ccx, layout.field(ccx, i), cls, field_off)?;\n                 }\n             }\n \n-            Layout::UntaggedUnion { .. } => {\n-                for i in 0..layout.fields.count() {\n-                    classify(ccx, layout.field(ccx, i), cls, off)?;\n-                }\n-            }\n-\n-            Layout::FatPointer { .. } |\n-            Layout::General { .. } |\n-            Layout::StructWrappedNullablePointer { .. } => return Err(Memory)\n         }\n \n         Ok(())"}, {"sha": "b80fded638d767521594e8c7534803b0a69d4d7d", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/caef91d7c6dcfc307b9e915bd9a80a25063cce22/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/caef91d7c6dcfc307b9e915bd9a80a25063cce22/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=caef91d7c6dcfc307b9e915bd9a80a25063cce22", "patch": "@@ -27,7 +27,7 @@ use type_::Type;\n use value::Value;\n use rustc::traits;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::{HasDataLayout, Layout, LayoutOf};\n+use rustc::ty::layout::{self, HasDataLayout, Layout, LayoutOf};\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::hir;\n \n@@ -50,19 +50,10 @@ pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n \n pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n     let layout = ccx.layout_of(ty);\n-    match *layout {\n-        Layout::CEnum { .. } |\n-        Layout::Scalar { .. } |\n-        Layout::Vector { .. } => true,\n-\n-        Layout::FatPointer { .. } => false,\n-\n-        Layout::Array { .. } |\n-        Layout::Univariant { .. } |\n-        Layout::General { .. } |\n-        Layout::UntaggedUnion { .. } |\n-        Layout::RawNullablePointer { .. } |\n-        Layout::StructWrappedNullablePointer { .. } => {\n+    match layout.abi {\n+        layout::Abi::Scalar(_) | layout::Abi::Vector => true,\n+\n+        layout::Abi::Aggregate => {\n             !layout.is_unsized() && layout.size(ccx).bytes() == 0\n         }\n     }"}]}