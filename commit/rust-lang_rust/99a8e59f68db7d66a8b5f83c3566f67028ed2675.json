{"sha": "99a8e59f68db7d66a8b5f83c3566f67028ed2675", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk5YThlNTlmNjhkYjdkNjZhOGI1ZjgzYzM1NjZmNjcwMjhlZDI2NzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-11-04T12:30:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-11-04T12:30:09Z"}, "message": "Merge #6458\n\n6458: Qualify trait impl created by add_custom_impl assist r=matklad a=Veykril\n\nWhen we find at least one trait with the same name as the derive accessible from the current module we now generate a qualified path to that trait in the generated impl.\r\nIf we don't find any we just do what was done before and emit the trait name in the generated impl.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "2e5f04ab2783a90efeabdc39abe7cee5e829ac85", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e5f04ab2783a90efeabdc39abe7cee5e829ac85"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99a8e59f68db7d66a8b5f83c3566f67028ed2675", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfop7RCRBK7hj4Ov3rIwAAdHIIACV6koOnHOpCWqQiehYa525L\n351v51GR6yrWebTBhfppkGSbl1OdUE8ZHhEboNPQT0SfKgbqx5SrcID0I6N/pqpt\nhBVwu0hg4VhKUOD9ZxK0Vwm7cmj7AbJuFBfrLx4LQB3b055oaaWdK4dRhDPoFkAU\nMG4BZU7qKbW8jenrW6ooxgI2HZzwPCvULb5I4lGjtS/b7vV4vcTPpkXMJGoWgo2I\nqQYBs+tv0er/VFiXy0xirtP5OBMFIHWJMSFm2maUjOR2c5v2l22+HjvjyoUypDW5\n0g/FkRV1/YIbCfJAho5SiUQ95qJ/lO4gngWb+8D0PD9ee/kgxSuctiUpw8g4tXc=\n=KKTp\n-----END PGP SIGNATURE-----\n", "payload": "tree 2e5f04ab2783a90efeabdc39abe7cee5e829ac85\nparent bdfffa372be37cc57facc2fbead920fcf3134a91\nparent 4992b75e518ae1427a040efa7cc2601186e8898e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1604493009 +0000\ncommitter GitHub <noreply@github.com> 1604493009 +0000\n\nMerge #6458\n\n6458: Qualify trait impl created by add_custom_impl assist r=matklad a=Veykril\n\nWhen we find at least one trait with the same name as the derive accessible from the current module we now generate a qualified path to that trait in the generated impl.\r\nIf we don't find any we just do what was done before and emit the trait name in the generated impl.\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99a8e59f68db7d66a8b5f83c3566f67028ed2675", "html_url": "https://github.com/rust-lang/rust/commit/99a8e59f68db7d66a8b5f83c3566f67028ed2675", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99a8e59f68db7d66a8b5f83c3566f67028ed2675/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdfffa372be37cc57facc2fbead920fcf3134a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdfffa372be37cc57facc2fbead920fcf3134a91", "html_url": "https://github.com/rust-lang/rust/commit/bdfffa372be37cc57facc2fbead920fcf3134a91"}, {"sha": "4992b75e518ae1427a040efa7cc2601186e8898e", "url": "https://api.github.com/repos/rust-lang/rust/commits/4992b75e518ae1427a040efa7cc2601186e8898e", "html_url": "https://github.com/rust-lang/rust/commit/4992b75e518ae1427a040efa7cc2601186e8898e"}], "stats": {"total": 152, "additions": 114, "deletions": 38}, "files": [{"sha": "669dd9b2173a4a5c4a6182edce4dde4e7693da97", "filename": "crates/assists/src/handlers/add_custom_impl.rs", "status": "modified", "additions": 114, "deletions": 38, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/99a8e59f68db7d66a8b5f83c3566f67028ed2675/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99a8e59f68db7d66a8b5f83c3566f67028ed2675/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fhandlers%2Fadd_custom_impl.rs?ref=99a8e59f68db7d66a8b5f83c3566f67028ed2675", "patch": "@@ -1,13 +1,16 @@\n+use ide_db::imports_locator;\n use itertools::Itertools;\n use syntax::{\n-    ast::{self, AstNode},\n+    ast::{self, make, AstNode},\n     Direction, SmolStr,\n     SyntaxKind::{IDENT, WHITESPACE},\n     TextRange, TextSize,\n };\n \n use crate::{\n-    assist_context::{AssistContext, Assists},\n+    assist_config::SnippetCap,\n+    assist_context::{AssistBuilder, AssistContext, Assists},\n+    utils::mod_path_to_ast,\n     AssistId, AssistKind,\n };\n \n@@ -30,78 +33,151 @@ use crate::{\n // ```\n pub(crate) fn add_custom_impl(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n     let attr = ctx.find_node_at_offset::<ast::Attr>()?;\n-    let input = attr.token_tree()?;\n \n     let attr_name = attr\n         .syntax()\n         .descendants_with_tokens()\n         .filter(|t| t.kind() == IDENT)\n-        .find_map(|i| i.into_token())\n-        .filter(|t| *t.text() == \"derive\")?\n+        .find_map(syntax::NodeOrToken::into_token)\n+        .filter(|t| t.text() == \"derive\")?\n         .text()\n         .clone();\n \n     let trait_token =\n         ctx.token_at_offset().find(|t| t.kind() == IDENT && *t.text() != attr_name)?;\n+    let trait_path = make::path_unqualified(make::path_segment(make::name_ref(trait_token.text())));\n \n     let annotated = attr.syntax().siblings(Direction::Next).find_map(ast::Name::cast)?;\n     let annotated_name = annotated.syntax().text().to_string();\n-    let start_offset = annotated.syntax().parent()?.text_range().end();\n+    let insert_pos = annotated.syntax().parent()?.text_range().end();\n+\n+    let current_module = ctx.sema.scope(annotated.syntax()).module()?;\n+    let current_crate = current_module.krate();\n+\n+    let found_traits = imports_locator::find_imports(&ctx.sema, current_crate, trait_token.text())\n+        .into_iter()\n+        .filter_map(|candidate: either::Either<hir::ModuleDef, hir::MacroDef>| match candidate {\n+            either::Either::Left(hir::ModuleDef::Trait(trait_)) => Some(trait_),\n+            _ => None,\n+        })\n+        .flat_map(|trait_| {\n+            current_module\n+                .find_use_path(ctx.sema.db, hir::ModuleDef::Trait(trait_))\n+                .as_ref()\n+                .map(mod_path_to_ast)\n+                .zip(Some(trait_))\n+        });\n \n-    let label =\n-        format!(\"Add custom impl `{}` for `{}`\", trait_token.text().as_str(), annotated_name);\n+    let mut no_traits_found = true;\n+    for (trait_path, _trait) in found_traits.inspect(|_| no_traits_found = false) {\n+        add_assist(acc, ctx.config.snippet_cap, &attr, &trait_path, &annotated_name, insert_pos)?;\n+    }\n+    if no_traits_found {\n+        add_assist(acc, ctx.config.snippet_cap, &attr, &trait_path, &annotated_name, insert_pos)?;\n+    }\n+    Some(())\n+}\n \n+fn add_assist(\n+    acc: &mut Assists,\n+    snippet_cap: Option<SnippetCap>,\n+    attr: &ast::Attr,\n+    trait_path: &ast::Path,\n+    annotated_name: &str,\n+    insert_pos: TextSize,\n+) -> Option<()> {\n     let target = attr.syntax().text_range();\n-    acc.add(AssistId(\"add_custom_impl\", AssistKind::Refactor), label, target, |builder| {\n-        let new_attr_input = input\n-            .syntax()\n-            .descendants_with_tokens()\n-            .filter(|t| t.kind() == IDENT)\n-            .filter_map(|t| t.into_token().map(|t| t.text().clone()))\n-            .filter(|t| t != trait_token.text())\n-            .collect::<Vec<SmolStr>>();\n-        let has_more_derives = !new_attr_input.is_empty();\n-\n-        if has_more_derives {\n-            let new_attr_input = format!(\"({})\", new_attr_input.iter().format(\", \"));\n-            builder.replace(input.syntax().text_range(), new_attr_input);\n-        } else {\n-            let attr_range = attr.syntax().text_range();\n-            builder.delete(attr_range);\n-\n-            let line_break_range = attr\n-                .syntax()\n-                .next_sibling_or_token()\n-                .filter(|t| t.kind() == WHITESPACE)\n-                .map(|t| t.text_range())\n-                .unwrap_or_else(|| TextRange::new(TextSize::from(0), TextSize::from(0)));\n-            builder.delete(line_break_range);\n-        }\n+    let input = attr.token_tree()?;\n+    let label = format!(\"Add custom impl `{}` for `{}`\", trait_path, annotated_name);\n+    let trait_name = trait_path.segment().and_then(|seg| seg.name_ref())?;\n \n-        match ctx.config.snippet_cap {\n+    acc.add(AssistId(\"add_custom_impl\", AssistKind::Refactor), label, target, |builder| {\n+        update_attribute(builder, &input, &trait_name, &attr);\n+        match snippet_cap {\n             Some(cap) => {\n                 builder.insert_snippet(\n                     cap,\n-                    start_offset,\n-                    format!(\"\\n\\nimpl {} for {} {{\\n    $0\\n}}\", trait_token, annotated_name),\n+                    insert_pos,\n+                    format!(\"\\n\\nimpl {} for {} {{\\n    $0\\n}}\", trait_path, annotated_name),\n                 );\n             }\n             None => {\n                 builder.insert(\n-                    start_offset,\n-                    format!(\"\\n\\nimpl {} for {} {{\\n\\n}}\", trait_token, annotated_name),\n+                    insert_pos,\n+                    format!(\"\\n\\nimpl {} for {} {{\\n\\n}}\", trait_path, annotated_name),\n                 );\n             }\n         }\n     })\n }\n \n+fn update_attribute(\n+    builder: &mut AssistBuilder,\n+    input: &ast::TokenTree,\n+    trait_name: &ast::NameRef,\n+    attr: &ast::Attr,\n+) {\n+    let new_attr_input = input\n+        .syntax()\n+        .descendants_with_tokens()\n+        .filter(|t| t.kind() == IDENT)\n+        .filter_map(|t| t.into_token().map(|t| t.text().clone()))\n+        .filter(|t| t != trait_name.text())\n+        .collect::<Vec<SmolStr>>();\n+    let has_more_derives = !new_attr_input.is_empty();\n+\n+    if has_more_derives {\n+        let new_attr_input = format!(\"({})\", new_attr_input.iter().format(\", \"));\n+        builder.replace(input.syntax().text_range(), new_attr_input);\n+    } else {\n+        let attr_range = attr.syntax().text_range();\n+        builder.delete(attr_range);\n+\n+        let line_break_range = attr\n+            .syntax()\n+            .next_sibling_or_token()\n+            .filter(|t| t.kind() == WHITESPACE)\n+            .map(|t| t.text_range())\n+            .unwrap_or_else(|| TextRange::new(TextSize::from(0), TextSize::from(0)));\n+        builder.delete(line_break_range);\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::tests::{check_assist, check_assist_not_applicable};\n \n     use super::*;\n \n+    #[test]\n+    fn add_custom_impl_qualified() {\n+        check_assist(\n+            add_custom_impl,\n+            \"\n+mod fmt {\n+    pub trait Debug {}\n+}\n+\n+#[derive(Debu<|>g)]\n+struct Foo {\n+    bar: String,\n+}\n+\",\n+            \"\n+mod fmt {\n+    pub trait Debug {}\n+}\n+\n+struct Foo {\n+    bar: String,\n+}\n+\n+impl fmt::Debug for Foo {\n+    $0\n+}\n+\",\n+        )\n+    }\n     #[test]\n     fn add_custom_impl_for_unique_input() {\n         check_assist("}]}