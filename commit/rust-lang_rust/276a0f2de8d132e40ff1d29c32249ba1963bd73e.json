{"sha": "276a0f2de8d132e40ff1d29c32249ba1963bd73e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NmEwZjJkZThkMTMyZTQwZmYxZDI5YzMyMjQ5YmExOTYzYmQ3M2U=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-20T19:22:28Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-20T19:22:28Z"}, "message": "rustc: Precompute type hashes", "tree": {"sha": "d93dbff3718faef2dd0848460b15aeca41473968", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d93dbff3718faef2dd0848460b15aeca41473968"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/276a0f2de8d132e40ff1d29c32249ba1963bd73e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/276a0f2de8d132e40ff1d29c32249ba1963bd73e", "html_url": "https://github.com/rust-lang/rust/commit/276a0f2de8d132e40ff1d29c32249ba1963bd73e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/276a0f2de8d132e40ff1d29c32249ba1963bd73e/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cac7524c1aa63961973e3607d72a49dfccb09448", "url": "https://api.github.com/repos/rust-lang/rust/commits/cac7524c1aa63961973e3607d72a49dfccb09448", "html_url": "https://github.com/rust-lang/rust/commit/cac7524c1aa63961973e3607d72a49dfccb09448"}], "stats": {"total": 95, "additions": 56, "deletions": 39}, "files": [{"sha": "3a3d3105c68752216863dd9736e913dcd5343bef", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/276a0f2de8d132e40ff1d29c32249ba1963bd73e/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276a0f2de8d132e40ff1d29c32249ba1963bd73e/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=276a0f2de8d132e40ff1d29c32249ba1963bd73e", "patch": "@@ -136,6 +136,11 @@ fn sty_str(ty.sty st, def_str ds) -> str {\n         case (ty.ty_native) {ret \"E\";}\n         case (ty.ty_param(?id)) {ret \"p\" + common.uistr(id);}\n         case (ty.ty_type) {ret \"Y\";}\n+\n+        // These two don't appear in crate metadata, but are here because\n+        // `hash_ty()` uses this function.\n+        case (ty.ty_bound_param(?id)) {ret \"o\" + common.uistr(id);}\n+        case (ty.ty_local(?def)) {ret \"L\" + ds(def);}\n     }\n }\n "}, {"sha": "2f63782c2eeec03acdd6db7ec55992aae3bb4f08", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 51, "deletions": 39, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/276a0f2de8d132e40ff1d29c32249ba1963bd73e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/276a0f2de8d132e40ff1d29c32249ba1963bd73e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=276a0f2de8d132e40ff1d29c32249ba1963bd73e", "patch": "@@ -40,7 +40,7 @@ fn method_ty_to_fn_ty(method m) -> @ty.t {\n //\n // TODO: It'd be really nice to be able to hide this definition from the\n // outside world, to enforce the above invariant.\n-type t = rec(sty struct, option.t[str] cname);\n+type t = rec(sty struct, option.t[str] cname, uint hash);\n \n // NB: If you change this, you'll probably want to change the corresponding\n // AST structure in front/ast.rs as well.\n@@ -107,28 +107,34 @@ type type_cache = hashmap[ast.def_id,ty_param_count_and_ty];\n \n // Type constructors\n \n-fn mk_nil() -> @t                        { ret plain_ty(ty_nil); }\n-fn mk_bool() -> @t                       { ret plain_ty(ty_bool); }\n-fn mk_int() -> @t                        { ret plain_ty(ty_int); }\n-fn mk_float() -> @t                      { ret plain_ty(ty_float); }\n-fn mk_uint() -> @t                       { ret plain_ty(ty_uint); }\n-fn mk_mach(util.common.ty_mach tm) -> @t { ret plain_ty(ty_machine(tm)); }\n-fn mk_char() -> @t                       { ret plain_ty(ty_char); }\n-fn mk_str() -> @t                        { ret plain_ty(ty_str); }\n+// This is a private constructor to this module. External users should always\n+// use the mk_foo() functions below.\n+fn gen_ty(&sty st) -> @t {\n+    ret @rec(struct=st, cname=none[str], hash=hash_type_structure(st));\n+}\n+\n+fn mk_nil() -> @t                        { ret gen_ty(ty_nil); }\n+fn mk_bool() -> @t                       { ret gen_ty(ty_bool); }\n+fn mk_int() -> @t                        { ret gen_ty(ty_int); }\n+fn mk_float() -> @t                      { ret gen_ty(ty_float); }\n+fn mk_uint() -> @t                       { ret gen_ty(ty_uint); }\n+fn mk_mach(util.common.ty_mach tm) -> @t { ret gen_ty(ty_machine(tm)); }\n+fn mk_char() -> @t                       { ret gen_ty(ty_char); }\n+fn mk_str() -> @t                        { ret gen_ty(ty_str); }\n \n fn mk_tag(ast.def_id did, vec[@t] tys) -> @t {\n-    ret plain_ty(ty_tag(did, tys));\n+    ret gen_ty(ty_tag(did, tys));\n }\n \n-fn mk_box(mt tm) -> @t     { ret plain_ty(ty_box(tm)); }\n+fn mk_box(mt tm) -> @t     { ret gen_ty(ty_box(tm)); }\n fn mk_imm_box(@t ty) -> @t { ret mk_box(rec(ty=ty, mut=ast.imm)); }\n \n-fn mk_vec(mt tm) -> @t                   { ret plain_ty(ty_vec(tm)); }\n-fn mk_port(@t ty) -> @t                  { ret plain_ty(ty_port(ty)); }\n-fn mk_chan(@t ty) -> @t                  { ret plain_ty(ty_chan(ty)); }\n-fn mk_task() -> @t                       { ret plain_ty(ty_task); }\n+fn mk_vec(mt tm) -> @t                   { ret gen_ty(ty_vec(tm)); }\n+fn mk_port(@t ty) -> @t                  { ret gen_ty(ty_port(ty)); }\n+fn mk_chan(@t ty) -> @t                  { ret gen_ty(ty_chan(ty)); }\n+fn mk_task() -> @t                       { ret gen_ty(ty_task); }\n \n-fn mk_tup(vec[mt] tms) -> @t             { ret plain_ty(ty_tup(tms)); }\n+fn mk_tup(vec[mt] tms) -> @t             { ret gen_ty(ty_tup(tms)); }\n fn mk_imm_tup(vec[@t] tys) -> @t {\n     // TODO: map\n     let vec[ty.mt] mts = vec();\n@@ -138,23 +144,23 @@ fn mk_imm_tup(vec[@t] tys) -> @t {\n     ret mk_tup(mts);\n }\n \n-fn mk_rec(vec[field] fs) -> @t           { ret plain_ty(ty_rec(fs)); }\n+fn mk_rec(vec[field] fs) -> @t           { ret gen_ty(ty_rec(fs)); }\n \n fn mk_fn(ast.proto proto, vec[arg] args, @t ty) -> @t {\n-    ret plain_ty(ty_fn(proto, args, ty));\n+    ret gen_ty(ty_fn(proto, args, ty));\n }\n \n fn mk_native_fn(ast.native_abi abi, vec[arg] args, @t ty) -> @t {\n-    ret plain_ty(ty_native_fn(abi, args, ty));\n+    ret gen_ty(ty_native_fn(abi, args, ty));\n }\n \n-fn mk_obj(vec[method] meths) -> @t       { ret plain_ty(ty_obj(meths)); }\n-fn mk_var(int v) -> @t                   { ret plain_ty(ty_var(v)); }\n-fn mk_local(ast.def_id did) -> @t        { ret plain_ty(ty_local(did)); }\n-fn mk_param(uint n) -> @t                { ret plain_ty(ty_param(n)); }\n-fn mk_bound_param(uint n) -> @t          { ret plain_ty(ty_bound_param(n)); }\n-fn mk_type() -> @t                       { ret plain_ty(ty_type); }\n-fn mk_native() -> @t                     { ret plain_ty(ty_native); }\n+fn mk_obj(vec[method] meths) -> @t       { ret gen_ty(ty_obj(meths)); }\n+fn mk_var(int v) -> @t                   { ret gen_ty(ty_var(v)); }\n+fn mk_local(ast.def_id did) -> @t        { ret gen_ty(ty_local(did)); }\n+fn mk_param(uint n) -> @t                { ret gen_ty(ty_param(n)); }\n+fn mk_bound_param(uint n) -> @t          { ret gen_ty(ty_bound_param(n)); }\n+fn mk_type() -> @t                       { ret gen_ty(ty_type); }\n+fn mk_native() -> @t                     { ret gen_ty(ty_native); }\n \n \n // Stringification\n@@ -478,13 +484,15 @@ fn fold_ty(ty_fold fld, @t ty_0) -> @t {\n // Type utilities\n \n fn rename(@t typ, str new_cname) -> @t {\n-    ret @rec(struct=typ.struct, cname=some[str](new_cname));\n+    ret @rec(struct=typ.struct, cname=some[str](new_cname), hash=typ.hash);\n }\n \n // Returns a type with the structural part taken from `struct_ty` and the\n // canonical name from `cname_ty`.\n fn copy_cname(@t struct_ty, @t cname_ty) -> @t {\n-    ret @rec(struct=struct_ty.struct, cname=cname_ty.cname);\n+    ret @rec(struct=struct_ty.struct,\n+             cname=cname_ty.cname,\n+             hash=struct_ty.hash);\n }\n \n // FIXME: remove me when == works on these tags.\n@@ -707,16 +715,12 @@ fn type_param(@t ty) -> option.t[uint] {\n     ret none[uint];\n }\n \n-fn plain_ty(&sty st) -> @t {\n-    ret @rec(struct=st, cname=none[str]);\n-}\n-\n fn def_to_str(ast.def_id did) -> str {\n     ret #fmt(\"%d:%d\", did._0, did._1);\n }\n \n-fn simple_ty_code(&@t ty) -> uint {\n-    alt (ty.struct) {\n+fn simple_ty_code(&sty st) -> uint {\n+    alt (st) {\n         case (ty_nil) { ret 0u; }\n         case (ty_bool) { ret 1u; }\n         case (ty_int) { ret 2u; }\n@@ -749,20 +753,28 @@ fn simple_ty_code(&@t ty) -> uint {\n     ret 0xffffu;\n }\n \n-fn hash_ty(&@t ty) -> uint {\n-    auto s = simple_ty_code(ty);\n+// Type hashing. This function is private to this module (and slow); external\n+// users should use `hash_ty()` instead.\n+fn hash_type_structure(&sty st) -> uint {\n+\n+    auto s = simple_ty_code(st);\n     if (s != 0xffffu) {\n         ret s;\n     }\n     auto f = def_to_str;\n-    ret _str.hash(metadata.ty_str(ty, f));\n+\n+    // FIXME: Gross. Use structural hashing when we have it.\n+    auto fake_ty = @rec(struct=st, cname=none[str], hash=0u);\n+    ret _str.hash(metadata.ty_str(fake_ty, f));\n }\n \n+fn hash_ty(&@t typ) -> uint { ret typ.hash; }\n+\n fn eq_ty(&@t a, &@t b) -> bool {\n \n-    auto sa = simple_ty_code(a);\n+    auto sa = simple_ty_code(a.struct);\n     if (sa != 0xffffu) {\n-        auto sb = simple_ty_code(b);\n+        auto sb = simple_ty_code(b.struct);\n         ret sa == sb;\n     }\n "}]}