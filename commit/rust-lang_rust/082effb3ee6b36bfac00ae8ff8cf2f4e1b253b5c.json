{"sha": "082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4MmVmZmIzZWU2YjM2YmZhYzAwYWU4ZmY4Y2YyZjRlMWIyNTNiNWM=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-07-05T12:27:27Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2016-07-05T12:27:27Z"}, "message": "align allocations in the worst possible way", "tree": {"sha": "1467cefe07c74562179f31f02dc3dff5f073e7ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1467cefe07c74562179f31f02dc3dff5f073e7ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJXe6evAAoJEFbW7qD8Z6xGoA4P/RZGbTPf7bZ3XrN94F2fmxVT\n9IomsJ6j94CDuG2+eiDfY5Sj08SanDp1ZwQ4iTBz4jC4QimWKxbeonKZkMlXpY/y\niVmyLkWw21U4jRCRZctjY0sRecHubtElXknWu3ZspheRAXL5C+g9dJGw054J6HID\nb8r17214ODThk8C2oX+djJx5b7l9CTuVIs9CIlif28+o+JrKyioApYmICclI6ixo\n1ozjVfYgXbD2yz6XqQwOa73+TyqQv2wkciaWEX4koqrwo4gICAH4tDB83pCD4N+j\nscwHkUGfngZvSm2Ne0RB94Vhuk+S8br1yuzk72/9r4YENV7+t6iYHaq9y7oFHyv1\nCZD6DL90txiZxpTaBc/CetfsHwVUCE6VCgSsTT59OqvZR5Uwtv6HePl9uF2IUWiN\nizW3il71FHVLP91Xqi6SmM8wh5RUn0KdhLSyawXEEMT18aNWl9iXPM89i1q+G29U\nLhf0D+EKWjP5xyX42VTiYuTFdEWTVX6ukjCLNOQFmny9ACmu+PrFtf/cr9PzEg7u\nF5p4BkjeXEH3594Hb/OV76mV9GtPolHGYy6ZfuRUjYvRlFiweHrf/NWyupmquE3J\n0GUSnY1wCOE3ncOcfqtoO9Q6lJuaP3+SUas5zcYPijIPtGxtnJp34TTq6Kzalnm+\nRx1c0qCnU/kSC6vjAVR1\n=jTz7\n-----END PGP SIGNATURE-----", "payload": "tree 1467cefe07c74562179f31f02dc3dff5f073e7ca\nparent 4781a6ba5431e00b3bb6a5c085e4811f3b4d988f\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1467721647 +0200\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1467721647 +0200\n\nalign allocations in the worst possible way"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "html_url": "https://github.com/rust-lang/rust/commit/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4781a6ba5431e00b3bb6a5c085e4811f3b4d988f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4781a6ba5431e00b3bb6a5c085e4811f3b4d988f", "html_url": "https://github.com/rust-lang/rust/commit/4781a6ba5431e00b3bb6a5c085e4811f3b4d988f"}], "stats": {"total": 110, "additions": 71, "deletions": 39}, "files": [{"sha": "6f033557b965861018a65c1a1e04264a87de4742", "filename": "src/error.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/src%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/src%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ferror.rs?ref=082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "patch": "@@ -36,6 +36,10 @@ pub enum EvalError<'tcx> {\n     },\n     ExecutionTimeLimitReached,\n     StackFrameLimitReached,\n+    AlignmentCheckFailed {\n+        required: usize,\n+        has: usize,\n+    },\n }\n \n pub type EvalResult<'tcx, T> = Result<T, EvalError<'tcx>>;\n@@ -82,6 +86,8 @@ impl<'tcx> Error for EvalError<'tcx> {\n                 \"reached the configured maximum execution time\",\n             EvalError::StackFrameLimitReached =>\n                 \"reached the configured maximum number of stack frames\",\n+            EvalError::AlignmentCheckFailed{..} =>\n+                \"tried to execute a misaligned read or write\",\n         }\n     }\n \n@@ -106,6 +112,9 @@ impl<'tcx> fmt::Display for EvalError<'tcx> {\n             EvalError::OutOfMemory { allocation_size, memory_size, memory_usage } =>\n                 write!(f, \"tried to allocate {} more bytes, but only {} bytes are free of the {} byte memory\",\n                        allocation_size, memory_size - memory_usage, memory_size),\n+            EvalError::AlignmentCheckFailed { required, has } =>\n+               write!(f, \"tried to access memory with alignment {}, but alignment {} is required\",\n+                      has, required),\n             _ => write!(f, \"{}\", self.description()),\n         }\n     }"}, {"sha": "8d6c526c0c20c5b829702fb2497b804482c39b56", "filename": "src/interpreter/mod.rs", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/src%2Finterpreter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/src%2Finterpreter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fmod.rs?ref=082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "patch": "@@ -153,7 +153,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match output_ty {\n             ty::FnConverging(ty) => {\n                 let size = self.type_size_with_substs(ty, substs);\n-                self.memory.allocate(size).map(Some)\n+                let align = self.type_align_with_substs(ty, substs);\n+                self.memory.allocate(size, align).map(Some)\n             }\n             ty::FnDiverging => Ok(None),\n         }\n@@ -177,7 +178,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         use rustc_const_math::{ConstInt, ConstIsize, ConstUsize};\n         macro_rules! i2p {\n             ($i:ident, $n:expr) => {{\n-                let ptr = self.memory.allocate($n)?;\n+                let ptr = self.memory.allocate($n, $n)?;\n                 self.memory.write_int(ptr, $i as i64, $n)?;\n                 Ok(ptr)\n             }}\n@@ -202,28 +203,28 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             Integral(ConstInt::Usize(ConstUsize::Us64(i))) => i2p!(i, 8),\n             Str(ref s) => {\n                 let psize = self.memory.pointer_size();\n-                let static_ptr = self.memory.allocate(s.len())?;\n-                let ptr = self.memory.allocate(psize * 2)?;\n+                let static_ptr = self.memory.allocate(s.len(), 1)?;\n+                let ptr = self.memory.allocate(psize * 2, psize)?;\n                 self.memory.write_bytes(static_ptr, s.as_bytes())?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n                 self.memory.write_usize(ptr.offset(psize as isize), s.len() as u64)?;\n                 Ok(ptr)\n             }\n             ByteStr(ref bs) => {\n                 let psize = self.memory.pointer_size();\n-                let static_ptr = self.memory.allocate(bs.len())?;\n-                let ptr = self.memory.allocate(psize)?;\n+                let static_ptr = self.memory.allocate(bs.len(), 1)?;\n+                let ptr = self.memory.allocate(psize, psize)?;\n                 self.memory.write_bytes(static_ptr, bs)?;\n                 self.memory.write_ptr(ptr, static_ptr)?;\n                 Ok(ptr)\n             }\n             Bool(b) => {\n-                let ptr = self.memory.allocate(1)?;\n+                let ptr = self.memory.allocate(1, 1)?;\n                 self.memory.write_bool(ptr, b)?;\n                 Ok(ptr)\n             }\n             Char(c) => {\n-                let ptr = self.memory.allocate(4)?;\n+                let ptr = self.memory.allocate(4, 4)?;\n                 self.memory.write_uint(ptr, c as u64, 4)?;\n                 Ok(ptr)\n             },\n@@ -269,10 +270,18 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.type_size_with_substs(ty, self.substs())\n     }\n \n+    fn type_align(&self, ty: Ty<'tcx>) -> usize {\n+        self.type_align_with_substs(ty, self.substs())\n+    }\n+\n     fn type_size_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n         self.type_layout_with_substs(ty, substs).size(&self.tcx.data_layout).bytes() as usize\n     }\n \n+    fn type_align_with_substs(&self, ty: Ty<'tcx>, substs: &'tcx Substs<'tcx>) -> usize {\n+        self.type_layout_with_substs(ty, substs).align(&self.tcx.data_layout).pref() as usize\n+    }\n+\n     fn type_layout(&self, ty: Ty<'tcx>) -> &'tcx Layout {\n         self.type_layout_with_substs(ty, self.substs())\n     }\n@@ -306,7 +315,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n         let locals: EvalResult<'tcx, Vec<Pointer>> = arg_tys.chain(var_tys).chain(temp_tys).map(|ty| {\n             let size = self.type_size_with_substs(ty, substs);\n-            self.memory.allocate(size)\n+            let align = self.type_align_with_substs(ty, substs);\n+            self.memory.allocate(size, align)\n         }).collect();\n \n         self.stack.push(Frame {\n@@ -553,7 +563,8 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n             Box(ty) => {\n                 let size = self.type_size(ty);\n-                let ptr = self.memory.allocate(size)?;\n+                let align = self.type_align(ty);\n+                let ptr = self.memory.allocate(size, align)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n \n@@ -701,7 +712,7 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                     Item { def_id, substs } => {\n                         if let ty::TyFnDef(..) = ty.sty {\n                             // function items are zero sized\n-                            Ok(self.memory.allocate(0)?)\n+                            Ok(self.memory.allocate(0, 0)?)\n                         } else {\n                             let cid = ConstantId {\n                                 def_id: def_id,\n@@ -955,9 +966,9 @@ pub fn eval_main<'a, 'tcx: 'a>(\n     if mir.arg_decls.len() == 2 {\n         // start function\n         let ptr_size = ecx.memory().pointer_size();\n-        let nargs = ecx.memory_mut().allocate(ptr_size).expect(\"can't allocate memory for nargs\");\n+        let nargs = ecx.memory_mut().allocate(ptr_size, ptr_size).expect(\"can't allocate memory for nargs\");\n         ecx.memory_mut().write_usize(nargs, 0).unwrap();\n-        let args = ecx.memory_mut().allocate(ptr_size).expect(\"can't allocate memory for arg pointer\");\n+        let args = ecx.memory_mut().allocate(ptr_size, ptr_size).expect(\"can't allocate memory for arg pointer\");\n         ecx.memory_mut().write_usize(args, 0).unwrap();\n         ecx.frame_mut().locals[0] = nargs;\n         ecx.frame_mut().locals[1] = args;"}, {"sha": "28b130e3d572810866f03c9030f74ab7e59c0971", "filename": "src/interpreter/terminator.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/src%2Finterpreter%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/src%2Finterpreter%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Finterpreter%2Fterminator.rs?ref=082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "patch": "@@ -88,7 +88,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n                 match func_ty.sty {\n                     ty::TyFnPtr(bare_fn_ty) => {\n                         let ptr = self.eval_operand(func)?;\n-                        assert_eq!(ptr.offset, 0);\n                         let fn_ptr = self.memory.read_ptr(ptr)?;\n                         let FunctionDefinition { def_id, substs, fn_ty } = self.memory.get_fn(fn_ptr.alloc_id)?;\n                         if fn_ty != bare_fn_ty {\n@@ -416,14 +415,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         match &link_name[..] {\n             \"__rust_allocate\" => {\n                 let size = self.memory.read_usize(args[0])?;\n-                let ptr = self.memory.allocate(size as usize)?;\n+                let align = self.memory.read_usize(args[1])?;\n+                let ptr = self.memory.allocate(size as usize, align as usize)?;\n                 self.memory.write_ptr(dest, ptr)?;\n             }\n \n             \"__rust_reallocate\" => {\n                 let ptr = self.memory.read_ptr(args[0])?;\n                 let size = self.memory.read_usize(args[2])?;\n-                let new_ptr = self.memory.reallocate(ptr, size as usize)?;\n+                let align = self.memory.read_usize(args[3])?;\n+                let new_ptr = self.memory.reallocate(ptr, size as usize, align as usize)?;\n                 self.memory.write_ptr(dest, new_ptr)?;\n             }\n "}, {"sha": "ca041dc1d9539a4d343397049bd4cd7057eb26c2", "filename": "src/memory.rs", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "patch": "@@ -29,6 +29,7 @@ pub struct Allocation {\n     pub bytes: Vec<u8>,\n     pub relocations: BTreeMap<usize, AllocId>,\n     pub undef_mask: UndefMask,\n+    pub align: usize,\n }\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n@@ -98,10 +99,11 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n             bytes: Vec::new(),\n             relocations: BTreeMap::new(),\n             undef_mask: UndefMask::new(0),\n+            align: 0,\n         };\n         mem.alloc_map.insert(ZST_ALLOC_ID, alloc);\n         // check that additional zst allocs work\n-        debug_assert!(mem.allocate(0).unwrap().points_to_zst());\n+        debug_assert!(mem.allocate(0, 0).unwrap().points_to_zst());\n         debug_assert!(mem.get(ZST_ALLOC_ID).is_ok());\n         mem\n     }\n@@ -133,70 +135,79 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         }\n     }\n \n-    pub fn allocate(&mut self, size: usize) -> EvalResult<'tcx, Pointer> {\n+    pub fn allocate(&mut self, size: usize, align: usize) -> EvalResult<'tcx, Pointer> {\n         if size == 0 {\n             return Ok(Pointer::zst_ptr());\n         }\n+        // make sure we can offset the result pointer by the worst possible alignment\n+        // this allows cheaply checking for alignment directly in the pointer\n+        let least_aligned_size = size + align;\n         if self.memory_size - self.memory_usage < size as u64 {\n             return Err(EvalError::OutOfMemory {\n-                allocation_size: size as u64,\n+                allocation_size: least_aligned_size as u64,\n                 memory_size: self.memory_size,\n                 memory_usage: self.memory_usage,\n             });\n         }\n         self.memory_usage += size as u64;\n         let alloc = Allocation {\n-            bytes: vec![0; size],\n+            bytes: vec![0; least_aligned_size],\n             relocations: BTreeMap::new(),\n-            undef_mask: UndefMask::new(size),\n+            undef_mask: UndefMask::new(least_aligned_size),\n+            align: align,\n         };\n         let id = self.next_id;\n         self.next_id.0 += 1;\n         self.alloc_map.insert(id, alloc);\n         Ok(Pointer {\n             alloc_id: id,\n-            offset: 0,\n+            // offset by the alignment, so larger accesses will fail\n+            offset: align,\n         })\n     }\n \n     // TODO(solson): Track which allocations were returned from __rust_allocate and report an error\n     // when reallocating/deallocating any others.\n-    pub fn reallocate(&mut self, ptr: Pointer, new_size: usize) -> EvalResult<'tcx, Pointer> {\n-        if ptr.offset != 0 {\n+    pub fn reallocate(&mut self, ptr: Pointer, new_size: usize, align: usize) -> EvalResult<'tcx, Pointer> {\n+        if ptr.offset != self.get(ptr.alloc_id)?.align {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }\n         if ptr.points_to_zst() {\n-            return self.allocate(new_size);\n+            return self.allocate(new_size, align);\n         }\n \n-        let size = self.get_mut(ptr.alloc_id)?.bytes.len();\n+        let size = self.get(ptr.alloc_id)?.bytes.len();\n+        let least_aligned_size = new_size + align;\n \n-        if new_size > size {\n-            let amount = new_size - size;\n+        if least_aligned_size > size {\n+            let amount = least_aligned_size - size;\n             self.memory_usage += amount as u64;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n             alloc.bytes.extend(iter::repeat(0).take(amount));\n             alloc.undef_mask.grow(amount, false);\n-        } else if size > new_size {\n+        } else if size > least_aligned_size {\n             // it's possible to cause miri to use arbitrary amounts of memory that aren't detectable\n             // through the memory_usage value, by allocating a lot and reallocating to zero\n-            self.memory_usage -= (size - new_size) as u64;\n-            self.clear_relocations(ptr.offset(new_size as isize), size - new_size)?;\n+            self.memory_usage -= (size - least_aligned_size) as u64;\n+            self.clear_relocations(ptr.offset(least_aligned_size as isize), size - least_aligned_size)?;\n             let alloc = self.get_mut(ptr.alloc_id)?;\n-            alloc.bytes.truncate(new_size);\n-            alloc.undef_mask.truncate(new_size);\n+            alloc.bytes.truncate(least_aligned_size);\n+            alloc.undef_mask.truncate(least_aligned_size);\n         }\n \n-        Ok(ptr)\n+        Ok(Pointer {\n+            alloc_id: ptr.alloc_id,\n+            offset: align,\n+        })\n     }\n \n     // TODO(solson): See comment on `reallocate`.\n     pub fn deallocate(&mut self, ptr: Pointer) -> EvalResult<'tcx, ()> {\n         if ptr.points_to_zst() {\n             return Ok(());\n         }\n-        if ptr.offset != 0 {\n+        if ptr.offset != self.get(ptr.alloc_id)?.align {\n             // TODO(solson): Report error about non-__rust_allocate'd pointer.\n             return Err(EvalError::Unimplemented(format!(\"bad pointer offset: {}\", ptr.offset)));\n         }"}, {"sha": "d5f021bda704fe6a2c160e1aeb7afdb2ac044d1d", "filename": "tests/compile-fail/oom.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/tests%2Fcompile-fail%2Foom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/tests%2Fcompile-fail%2Foom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom.rs?ref=082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "patch": "@@ -6,6 +6,6 @@ fn bar() {\n     assert_eq!(x, 6);\n }\n \n-fn main() { //~ ERROR tried to allocate 4 more bytes, but only 0 bytes are free of the 0 byte memory\n+fn main() { //~ ERROR tried to allocate 8 more bytes, but only 0 bytes are free of the 0 byte memory\n     bar();\n }"}, {"sha": "65ef0dd0b7daa52d3255a3f7a500fb48fbbc7d37", "filename": "tests/compile-fail/oom2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/tests%2Fcompile-fail%2Foom2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/tests%2Fcompile-fail%2Foom2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Foom2.rs?ref=082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "patch": "@@ -3,7 +3,7 @@\n \n fn bar(i: i32) {\n     if i < 1000 {\n-        bar(i + 1) //~ ERROR tried to allocate 4 more bytes, but only 1 bytes are free of the 1000 byte memory\n+        bar(i + 1) //~ ERROR tried to allocate 8 more bytes, but only 1 bytes are free of the 1000 byte memory\n         //~^NOTE inside call to bar\n         //~|NOTE inside call to bar\n         //~|NOTE inside call to bar"}, {"sha": "29355992e44c06f114a63518af726c45ffb034cc", "filename": "tests/compile-fail/out_of_bounds_read.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/tests%2Fcompile-fail%2Fout_of_bounds_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/tests%2Fcompile-fail%2Fout_of_bounds_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_read.rs?ref=082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.get_unchecked(5) }; //~ ERROR: which has size 2\n+    let x = unsafe { *v.get_unchecked(5) }; //~ ERROR: which has size 3\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "388ed8b130639162c5a36d719851988907b309ca", "filename": "tests/compile-fail/out_of_bounds_read2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fout_of_bounds_read2.rs?ref=082effb3ee6b36bfac00ae8ff8cf2f4e1b253b5c", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let v: Vec<u8> = vec![1, 2];\n-    let x = unsafe { *v.get_unchecked(5) }; //~ ERROR: memory access of 5..6 outside bounds of allocation\n+    let x = unsafe { *v.get_unchecked(5) }; //~ ERROR: memory access of 6..7 outside bounds of allocation\n     panic!(\"this should never print: {}\", x);\n }"}]}