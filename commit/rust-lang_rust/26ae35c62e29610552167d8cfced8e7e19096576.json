{"sha": "26ae35c62e29610552167d8cfced8e7e19096576", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YWUzNWM2MmUyOTYxMDU1MjE2N2Q4Y2ZjZWQ4ZTdlMTkwOTY1NzY=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-03-06T19:50:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-06T19:50:55Z"}, "message": "Merge #3499\n\n3499: Resolve `Self::AssocTy` in impls r=matklad a=flodiebold\n\nTo do this we need to carry around the original resolution a bit, because `Self`\r\ngets resolved to the actual type immediately, but you're not allowed to write\r\nthe equivalent type in a projection. (I tried just comparing the projection base\r\ntype with the impl self type, but that seemed too dirty.) This is basically how\r\nrustc does it as well.\r\n\r\nFixes #3249.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>", "tree": {"sha": "7eaa1d80fffcd5a02f3652c1938d3eb7fbb5475c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7eaa1d80fffcd5a02f3652c1938d3eb7fbb5475c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26ae35c62e29610552167d8cfced8e7e19096576", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeYqmfCRBK7hj4Ov3rIwAAdHIIABP81uIQ8LNDR/pcSOgVgS2J\nSH9kmjOIJfVm0J6kHfh6idI9V2fQi+uzhXfhFGwv2FZJ7w6JS2vrqyw4lcHfKL1j\n+KSv8rJK6h4NSZDijySVA1SHaqyYeUizUWXhhzKKPeNYMEVm1jc6QGBqnqAcZ35q\nAfnsV5ChLWwtVHEnBkwrc8VXIH7ApWkqX2ofo2G3UcWITRZ71ctykFSGMaVXx/Df\nG5dZJ6RZ74/uAAvkyW4pOLbNcfCt+SOLrjjmh3TGr32wKPlSjKW3mtrz6JHmgMmS\nkTNp6ucIHzp8ZrNw2er94vJTnS73GgJyCIVkDK0xKZJK3tSDihbIDeuJ/SKIhwk=\n=axDN\n-----END PGP SIGNATURE-----\n", "payload": "tree 7eaa1d80fffcd5a02f3652c1938d3eb7fbb5475c\nparent a42f29166b2b771927fef6061dd427f82eb28d68\nparent d17c5416af3d90b4c827224d4cd73366fa5a294b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1583524255 +0000\ncommitter GitHub <noreply@github.com> 1583524255 +0000\n\nMerge #3499\n\n3499: Resolve `Self::AssocTy` in impls r=matklad a=flodiebold\n\nTo do this we need to carry around the original resolution a bit, because `Self`\r\ngets resolved to the actual type immediately, but you're not allowed to write\r\nthe equivalent type in a projection. (I tried just comparing the projection base\r\ntype with the impl self type, but that seemed too dirty.) This is basically how\r\nrustc does it as well.\r\n\r\nFixes #3249.\n\nCo-authored-by: Florian Diebold <florian.diebold@freiheit.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26ae35c62e29610552167d8cfced8e7e19096576", "html_url": "https://github.com/rust-lang/rust/commit/26ae35c62e29610552167d8cfced8e7e19096576", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26ae35c62e29610552167d8cfced8e7e19096576/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a42f29166b2b771927fef6061dd427f82eb28d68", "url": "https://api.github.com/repos/rust-lang/rust/commits/a42f29166b2b771927fef6061dd427f82eb28d68", "html_url": "https://github.com/rust-lang/rust/commit/a42f29166b2b771927fef6061dd427f82eb28d68"}, {"sha": "d17c5416af3d90b4c827224d4cd73366fa5a294b", "url": "https://api.github.com/repos/rust-lang/rust/commits/d17c5416af3d90b4c827224d4cd73366fa5a294b", "html_url": "https://github.com/rust-lang/rust/commit/d17c5416af3d90b4c827224d4cd73366fa5a294b"}], "stats": {"total": 131, "additions": 93, "deletions": 38}, "files": [{"sha": "c733b9e1d299b0e9aa824a13398244c93ea65fd6", "filename": "crates/ra_hir_ty/src/infer/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/26ae35c62e29610552167d8cfced8e7e19096576/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ae35c62e29610552167d8cfced8e7e19096576/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=26ae35c62e29610552167d8cfced8e7e19096576", "patch": "@@ -40,7 +40,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n             let ty = self.make_ty(type_ref);\n             let remaining_segments_for_ty = path.segments().take(path.segments().len() - 1);\n             let ctx = crate::lower::TyLoweringContext::new(self.db, &resolver);\n-            let ty = Ty::from_type_relative_path(&ctx, ty, remaining_segments_for_ty);\n+            let (ty, _) = Ty::from_type_relative_path(&ctx, ty, None, remaining_segments_for_ty);\n             self.resolve_ty_assoc_item(\n                 ty,\n                 &path.segments().last().expect(\"path had at least one segment\").name,\n@@ -115,7 +115,7 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                 let remaining_segments_for_ty =\n                     remaining_segments.take(remaining_segments.len() - 1);\n                 let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n-                let ty = Ty::from_partly_resolved_hir_path(\n+                let (ty, _) = Ty::from_partly_resolved_hir_path(\n                     &ctx,\n                     def,\n                     resolved_segment,"}, {"sha": "b96dc126cf9caa79b26ca92a5d9588a04dcffc85", "filename": "crates/ra_hir_ty/src/lower.rs", "status": "modified", "additions": 50, "deletions": 36, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/26ae35c62e29610552167d8cfced8e7e19096576/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ae35c62e29610552167d8cfced8e7e19096576/crates%2Fra_hir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Flower.rs?ref=26ae35c62e29610552167d8cfced8e7e19096576", "patch": "@@ -91,7 +91,14 @@ pub enum TypeParamLoweringMode {\n \n impl Ty {\n     pub fn from_hir(ctx: &TyLoweringContext<'_, impl HirDatabase>, type_ref: &TypeRef) -> Self {\n-        match type_ref {\n+        Ty::from_hir_ext(ctx, type_ref).0\n+    }\n+    pub fn from_hir_ext(\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        type_ref: &TypeRef,\n+    ) -> (Self, Option<TypeNs>) {\n+        let mut res = None;\n+        let ty = match type_ref {\n             TypeRef::Never => Ty::simple(TypeCtor::Never),\n             TypeRef::Tuple(inner) => {\n                 let inner_tys: Arc<[Ty]> = inner.iter().map(|tr| Ty::from_hir(ctx, tr)).collect();\n@@ -100,7 +107,11 @@ impl Ty {\n                     Substs(inner_tys),\n                 )\n             }\n-            TypeRef::Path(path) => Ty::from_hir_path(ctx, path),\n+            TypeRef::Path(path) => {\n+                let (ty, res_) = Ty::from_hir_path(ctx, path);\n+                res = res_;\n+                ty\n+            }\n             TypeRef::RawPtr(inner, mutability) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n                 Ty::apply_one(TypeCtor::RawPtr(*mutability), inner_ty)\n@@ -183,7 +194,8 @@ impl Ty {\n                 }\n             }\n             TypeRef::Error => Ty::Unknown,\n-        }\n+        };\n+        (ty, res)\n     }\n \n     /// This is only for `generic_predicates_for_param`, where we can't just\n@@ -217,17 +229,19 @@ impl Ty {\n     pub(crate) fn from_type_relative_path(\n         ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         ty: Ty,\n+        // We need the original resolution to lower `Self::AssocTy` correctly\n+        res: Option<TypeNs>,\n         remaining_segments: PathSegments<'_>,\n-    ) -> Ty {\n+    ) -> (Ty, Option<TypeNs>) {\n         if remaining_segments.len() == 1 {\n             // resolve unselected assoc types\n             let segment = remaining_segments.first().unwrap();\n-            Ty::select_associated_type(ctx, ty, segment)\n+            (Ty::select_associated_type(ctx, ty, res, segment), None)\n         } else if remaining_segments.len() > 1 {\n             // FIXME report error (ambiguous associated type)\n-            Ty::Unknown\n+            (Ty::Unknown, None)\n         } else {\n-            ty\n+            (ty, res)\n         }\n     }\n \n@@ -236,14 +250,14 @@ impl Ty {\n         resolution: TypeNs,\n         resolved_segment: PathSegment<'_>,\n         remaining_segments: PathSegments<'_>,\n-    ) -> Ty {\n+    ) -> (Ty, Option<TypeNs>) {\n         let ty = match resolution {\n             TypeNs::TraitId(trait_) => {\n                 // if this is a bare dyn Trait, we'll directly put the required ^0 for the self type in there\n                 let self_ty = if remaining_segments.len() == 0 { Some(Ty::Bound(0)) } else { None };\n                 let trait_ref =\n                     TraitRef::from_resolved_path(ctx, trait_, resolved_segment, self_ty);\n-                return if remaining_segments.len() == 1 {\n+                let ty = if remaining_segments.len() == 1 {\n                     let segment = remaining_segments.first().unwrap();\n                     let associated_ty = associated_type_by_name_including_super_traits(\n                         ctx.db,\n@@ -269,6 +283,7 @@ impl Ty {\n                 } else {\n                     Ty::Dyn(Arc::new([GenericPredicate::Implemented(trait_ref)]))\n                 };\n+                return (ty, None);\n             }\n             TypeNs::GenericParam(param_id) => {\n                 let generics =\n@@ -306,22 +321,25 @@ impl Ty {\n             TypeNs::BuiltinType(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n             TypeNs::TypeAliasId(it) => Ty::from_hir_path_inner(ctx, resolved_segment, it.into()),\n             // FIXME: report error\n-            TypeNs::EnumVariantId(_) => return Ty::Unknown,\n+            TypeNs::EnumVariantId(_) => return (Ty::Unknown, None),\n         };\n \n-        Ty::from_type_relative_path(ctx, ty, remaining_segments)\n+        Ty::from_type_relative_path(ctx, ty, Some(resolution), remaining_segments)\n     }\n \n-    pub(crate) fn from_hir_path(ctx: &TyLoweringContext<'_, impl HirDatabase>, path: &Path) -> Ty {\n+    pub(crate) fn from_hir_path(\n+        ctx: &TyLoweringContext<'_, impl HirDatabase>,\n+        path: &Path,\n+    ) -> (Ty, Option<TypeNs>) {\n         // Resolve the path (in type namespace)\n         if let Some(type_ref) = path.type_anchor() {\n-            let ty = Ty::from_hir(ctx, &type_ref);\n-            return Ty::from_type_relative_path(ctx, ty, path.segments());\n+            let (ty, res) = Ty::from_hir_ext(ctx, &type_ref);\n+            return Ty::from_type_relative_path(ctx, ty, res, path.segments());\n         }\n         let (resolution, remaining_index) =\n             match ctx.resolver.resolve_path_in_type_ns(ctx.db, path.mod_path()) {\n                 Some(it) => it,\n-                None => return Ty::Unknown,\n+                None => return (Ty::Unknown, None),\n             };\n         let (resolved_segment, remaining_segments) = match remaining_index {\n             None => (\n@@ -336,31 +354,27 @@ impl Ty {\n     fn select_associated_type(\n         ctx: &TyLoweringContext<'_, impl HirDatabase>,\n         self_ty: Ty,\n+        res: Option<TypeNs>,\n         segment: PathSegment<'_>,\n     ) -> Ty {\n-        let def = match ctx.resolver.generic_def() {\n-            Some(def) => def,\n-            None => return Ty::Unknown, // this can't actually happen\n-        };\n-        let param_id = match self_ty {\n-            Ty::Placeholder(id) if ctx.type_param_mode == TypeParamLoweringMode::Placeholder => id,\n-            Ty::Bound(idx) if ctx.type_param_mode == TypeParamLoweringMode::Variable => {\n-                let generics = generics(ctx.db, def);\n-                let param_id = if let Some((id, _)) = generics.iter().nth(idx as usize) {\n-                    id\n-                } else {\n-                    return Ty::Unknown;\n-                };\n-                param_id\n+        let traits_from_env: Vec<_> = match res {\n+            Some(TypeNs::SelfType(impl_id)) => match ctx.db.impl_trait(impl_id) {\n+                None => return Ty::Unknown,\n+                Some(trait_ref) => vec![trait_ref.value.trait_],\n+            },\n+            Some(TypeNs::GenericParam(param_id)) => {\n+                let predicates = ctx.db.generic_predicates_for_param(param_id);\n+                predicates\n+                    .iter()\n+                    .filter_map(|pred| match &pred.value {\n+                        GenericPredicate::Implemented(tr) => Some(tr.trait_),\n+                        _ => None,\n+                    })\n+                    .collect()\n             }\n-            _ => return Ty::Unknown, // Error: Ambiguous associated type\n+            _ => return Ty::Unknown,\n         };\n-        let predicates = ctx.db.generic_predicates_for_param(param_id);\n-        let traits_from_env = predicates.iter().filter_map(|pred| match &pred.value {\n-            GenericPredicate::Implemented(tr) => Some(tr.trait_),\n-            _ => None,\n-        });\n-        let traits = traits_from_env.flat_map(|t| all_super_traits(ctx.db, t));\n+        let traits = traits_from_env.into_iter().flat_map(|t| all_super_traits(ctx.db, t));\n         for t in traits {\n             if let Some(associated_ty) = ctx.db.trait_data(t).associated_type_by_name(&segment.name)\n             {"}, {"sha": "f009a708c36f3538946195e72337a32758f24574", "filename": "crates/ra_hir_ty/src/tests/traits.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/26ae35c62e29610552167d8cfced8e7e19096576/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ae35c62e29610552167d8cfced8e7e19096576/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=26ae35c62e29610552167d8cfced8e7e19096576", "patch": "@@ -1802,6 +1802,47 @@ fn test<T, U>() where T::Item: Trait2, T: Trait<U::Item>, U: Trait<()> {\n     assert_eq!(t, \"u32\");\n }\n \n+#[test]\n+fn unselected_projection_on_trait_self() {\n+    assert_snapshot!(infer(\n+        r#\"\n+//- /main.rs\n+trait Trait {\n+    type Item;\n+\n+    fn f(&self, x: Self::Item);\n+}\n+\n+struct S;\n+\n+impl Trait for S {\n+    type Item = u32;\n+    fn f(&self, x: Self::Item) { let y = x; }\n+}\n+\n+struct S2;\n+\n+impl Trait for S2 {\n+    type Item = i32;\n+    fn f(&self, x: <Self>::Item) { let y = x; }\n+}\n+\"#,\n+    ), @r###\"\n+    [54; 58) 'self': &Self\n+    [60; 61) 'x': {unknown}\n+    [140; 144) 'self': &S\n+    [146; 147) 'x': u32\n+    [161; 175) '{ let y = x; }': ()\n+    [167; 168) 'y': u32\n+    [171; 172) 'x': u32\n+    [242; 246) 'self': &S2\n+    [248; 249) 'x': i32\n+    [265; 279) '{ let y = x; }': ()\n+    [271; 272) 'y': i32\n+    [275; 276) 'x': i32\n+    \"###);\n+}\n+\n #[test]\n fn trait_impl_self_ty() {\n     let t = type_at("}]}