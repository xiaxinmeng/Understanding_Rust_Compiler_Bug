{"sha": "f5418b09e84883c4de2e652a147ab9faff4eee29", "node_id": "C_kwDOAAsO6NoAKGY1NDE4YjA5ZTg0ODgzYzRkZTJlNjUyYTE0N2FiOWZhZmY0ZWVlMjk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-08T03:04:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-08T03:04:51Z"}, "message": "Auto merge of #105425 - matthiaskrgr:rollup-3ngvxmt, r=matthiaskrgr\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #105267 (Don't ICE in ExprUseVisitor on FRU for non-existent struct)\n - #105343 (Simplify attribute handling in rustc_ast_lowering)\n - #105368 (Remove more `ref` patterns from the compiler)\n - #105400 (normalize before handling simple checks for evaluatability of `ty::Const`)\n - #105403 (rustdoc: simplify CSS selectors for item table `.stab`)\n - #105418 (fix: remove hack from link.rs)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "73cdc4abf6ee71619776094274d19d56569f87a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73cdc4abf6ee71619776094274d19d56569f87a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5418b09e84883c4de2e652a147ab9faff4eee29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5418b09e84883c4de2e652a147ab9faff4eee29", "html_url": "https://github.com/rust-lang/rust/commit/f5418b09e84883c4de2e652a147ab9faff4eee29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5418b09e84883c4de2e652a147ab9faff4eee29/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "01fbc5ae789fc0c7a2da71d3cd908451f175e4eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/01fbc5ae789fc0c7a2da71d3cd908451f175e4eb", "html_url": "https://github.com/rust-lang/rust/commit/01fbc5ae789fc0c7a2da71d3cd908451f175e4eb"}, {"sha": "4968af0ee84b3fd0a0bd32fda8caa294c21a2a6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4968af0ee84b3fd0a0bd32fda8caa294c21a2a6a", "html_url": "https://github.com/rust-lang/rust/commit/4968af0ee84b3fd0a0bd32fda8caa294c21a2a6a"}], "stats": {"total": 1095, "additions": 535, "deletions": 560}, "files": [{"sha": "24e2985cf567a3838ee13e168d5d944c7078e6f5", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 39, "deletions": 94, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -436,18 +436,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let lhs = self.lower_cond(lhs);\n                 let rhs = self.lower_cond(rhs);\n \n-                self.arena.alloc(self.expr(\n-                    cond.span,\n-                    hir::ExprKind::Binary(op, lhs, rhs),\n-                    AttrVec::new(),\n-                ))\n+                self.arena.alloc(self.expr(cond.span, hir::ExprKind::Binary(op, lhs, rhs)))\n             }\n             ExprKind::Let(..) => self.lower_expr(cond),\n             _ => {\n                 let cond = self.lower_expr(cond);\n                 let reason = DesugaringKind::CondTemporary;\n                 let span_block = self.mark_span_with_reason(reason, cond.span, None);\n-                self.expr_drop_temps(span_block, cond, AttrVec::new())\n+                self.expr_drop_temps(span_block, cond)\n             }\n         }\n     }\n@@ -477,12 +473,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     ) -> hir::ExprKind<'hir> {\n         let lowered_cond = self.with_loop_condition_scope(|t| t.lower_cond(cond));\n         let then = self.lower_block_expr(body);\n-        let expr_break = self.expr_break(span, AttrVec::new());\n+        let expr_break = self.expr_break(span);\n         let stmt_break = self.stmt_expr(span, expr_break);\n         let else_blk = self.block_all(span, arena_vec![self; stmt_break], None);\n-        let else_expr = self.arena.alloc(self.expr_block(else_blk, AttrVec::new()));\n+        let else_expr = self.arena.alloc(self.expr_block(else_blk));\n         let if_kind = hir::ExprKind::If(lowered_cond, self.arena.alloc(then), Some(else_expr));\n-        let if_expr = self.expr(span, if_kind, AttrVec::new());\n+        let if_expr = self.expr(span, if_kind);\n         let block = self.block_expr(self.arena.alloc(if_expr));\n         let span = self.lower_span(span.with_hi(cond.span.hi()));\n         let opt_label = self.lower_label(opt_label);\n@@ -538,12 +534,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         expr: &'hir hir::Expr<'hir>,\n         overall_span: Span,\n     ) -> &'hir hir::Expr<'hir> {\n-        let constructor = self.arena.alloc(self.expr_lang_item_path(\n-            method_span,\n-            lang_item,\n-            AttrVec::new(),\n-            None,\n-        ));\n+        let constructor = self.arena.alloc(self.expr_lang_item_path(method_span, lang_item, None));\n         self.expr_call(overall_span, constructor, std::slice::from_ref(expr))\n     }\n \n@@ -715,12 +706,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // E0700 in src/test/ui/self/self_lifetime-async.rs\n \n         // `future::identity_future`:\n-        let identity_future = self.expr_lang_item_path(\n-            unstable_span,\n-            hir::LangItem::IdentityFuture,\n-            AttrVec::new(),\n-            None,\n-        );\n+        let identity_future =\n+            self.expr_lang_item_path(unstable_span, hir::LangItem::IdentityFuture, None);\n \n         // `future::identity_future(generator)`:\n         hir::ExprKind::Call(self.arena.alloc(identity_future), arena_vec![self; generator])\n@@ -817,7 +804,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let break_x = self.with_loop_scope(loop_node_id, move |this| {\n                 let expr_break =\n                     hir::ExprKind::Break(this.lower_loop_destination(None), Some(x_expr));\n-                this.arena.alloc(this.expr(gen_future_span, expr_break, AttrVec::new()))\n+                this.arena.alloc(this.expr(gen_future_span, expr_break))\n             });\n             self.arm(ready_pat, break_x)\n         };\n@@ -850,17 +837,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             let yield_expr = self.expr(\n                 span,\n                 hir::ExprKind::Yield(unit, hir::YieldSource::Await { expr: Some(expr_hir_id) }),\n-                AttrVec::new(),\n             );\n             let yield_expr = self.arena.alloc(yield_expr);\n \n             if let Some(task_context_hid) = self.task_context {\n                 let lhs = self.expr_ident(span, task_context_ident, task_context_hid);\n-                let assign = self.expr(\n-                    span,\n-                    hir::ExprKind::Assign(lhs, yield_expr, self.lower_span(span)),\n-                    AttrVec::new(),\n-                );\n+                let assign =\n+                    self.expr(span, hir::ExprKind::Assign(lhs, yield_expr, self.lower_span(span)));\n                 self.stmt_expr(span, assign)\n             } else {\n                 // Use of `await` outside of an async context. Return `yield_expr` so that we can\n@@ -1044,7 +1027,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     hir::AsyncGeneratorKind::Closure,\n                     |this| this.with_new_scopes(|this| this.lower_expr_mut(body)),\n                 );\n-                this.expr(fn_decl_span, async_body, AttrVec::new())\n+                this.expr(fn_decl_span, async_body)\n             });\n             body_id\n         });\n@@ -1304,7 +1287,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let ident = self.expr_ident(lhs.span, ident, binding);\n         let assign =\n             hir::ExprKind::Assign(self.lower_expr(lhs), ident, self.lower_span(eq_sign_span));\n-        let expr = self.expr(lhs.span, assign, AttrVec::new());\n+        let expr = self.expr(lhs.span, assign);\n         assignments.push(self.stmt_expr(lhs.span, expr));\n         pat\n     }\n@@ -1345,8 +1328,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let e2 = self.lower_expr_mut(e2);\n         let fn_path =\n             hir::QPath::LangItem(hir::LangItem::RangeInclusiveNew, self.lower_span(span), None);\n-        let fn_expr =\n-            self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path), AttrVec::new()));\n+        let fn_expr = self.arena.alloc(self.expr(span, hir::ExprKind::Path(fn_path)));\n         hir::ExprKind::Call(fn_expr, arena_vec![self; e1, e2])\n     }\n \n@@ -1518,8 +1500,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         // `None => break`\n         let none_arm = {\n-            let break_expr =\n-                self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span, AttrVec::new()));\n+            let break_expr = self.with_loop_scope(e.id, |this| this.expr_break_alloc(for_span));\n             let pat = self.pat_none(for_span);\n             self.arm(pat, break_expr)\n         };\n@@ -1528,7 +1509,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let some_arm = {\n             let some_pat = self.pat_some(pat_span, pat);\n             let body_block = self.with_loop_scope(e.id, |this| this.lower_block(body, false));\n-            let body_expr = self.arena.alloc(self.expr_block(body_block, AttrVec::new()));\n+            let body_expr = self.arena.alloc(self.expr_block(body_block));\n             self.arm(some_pat, body_expr)\n         };\n \n@@ -1591,7 +1572,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // surrounding scope of the `match` since the `match` is not a terminating scope.\n         //\n         // Also, add the attributes to the outer returned expr node.\n-        self.expr_drop_temps_mut(for_span, match_expr, e.attrs.clone())\n+        let expr = self.expr_drop_temps_mut(for_span, match_expr);\n+        self.lower_attrs(expr.hir_id, &e.attrs);\n+        expr\n     }\n \n     /// Desugar `ExprKind::Try` from: `<expr>?` into:\n@@ -1646,12 +1629,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         let continue_arm = {\n             let val_ident = Ident::with_dummy_span(sym::val);\n             let (val_pat, val_pat_nid) = self.pat_ident(span, val_ident);\n-            let val_expr = self.arena.alloc(self.expr_ident_with_attrs(\n-                span,\n-                val_ident,\n-                val_pat_nid,\n-                attrs.clone(),\n-            ));\n+            let val_expr = self.expr_ident(span, val_ident, val_pat_nid);\n+            self.lower_attrs(val_expr.hir_id, &attrs);\n             let continue_pat = self.pat_cf_continue(unstable_span, val_pat);\n             self.arm(continue_pat, val_expr)\n         };\n@@ -1677,15 +1656,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         hir::Destination { label: None, target_id },\n                         Some(from_residual_expr),\n                     ),\n-                    attrs,\n                 ))\n             } else {\n-                self.arena.alloc(self.expr(\n-                    try_span,\n-                    hir::ExprKind::Ret(Some(from_residual_expr)),\n-                    attrs,\n-                ))\n+                self.arena.alloc(self.expr(try_span, hir::ExprKind::Ret(Some(from_residual_expr))))\n             };\n+            self.lower_attrs(ret_expr.hir_id, &attrs);\n \n             let break_pat = self.pat_cf_break(try_span, residual_local);\n             self.arm(break_pat, ret_expr)\n@@ -1750,18 +1725,16 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         expr: &'hir hir::Expr<'hir>,\n-        attrs: AttrVec,\n     ) -> &'hir hir::Expr<'hir> {\n-        self.arena.alloc(self.expr_drop_temps_mut(span, expr, attrs))\n+        self.arena.alloc(self.expr_drop_temps_mut(span, expr))\n     }\n \n     pub(super) fn expr_drop_temps_mut(\n         &mut self,\n         span: Span,\n         expr: &'hir hir::Expr<'hir>,\n-        attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::DropTemps(expr), attrs)\n+        self.expr(span, hir::ExprKind::DropTemps(expr))\n     }\n \n     fn expr_match(\n@@ -1771,29 +1744,25 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         arms: &'hir [hir::Arm<'hir>],\n         source: hir::MatchSource,\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Match(arg, arms, source), AttrVec::new())\n+        self.expr(span, hir::ExprKind::Match(arg, arms, source))\n     }\n \n-    fn expr_break(&mut self, span: Span, attrs: AttrVec) -> hir::Expr<'hir> {\n+    fn expr_break(&mut self, span: Span) -> hir::Expr<'hir> {\n         let expr_break = hir::ExprKind::Break(self.lower_loop_destination(None), None);\n-        self.expr(span, expr_break, attrs)\n+        self.expr(span, expr_break)\n     }\n \n-    fn expr_break_alloc(&mut self, span: Span, attrs: AttrVec) -> &'hir hir::Expr<'hir> {\n-        let expr_break = self.expr_break(span, attrs);\n+    fn expr_break_alloc(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n+        let expr_break = self.expr_break(span);\n         self.arena.alloc(expr_break)\n     }\n \n     fn expr_mut_addr_of(&mut self, span: Span, e: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n-        self.expr(\n-            span,\n-            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e),\n-            AttrVec::new(),\n-        )\n+        self.expr(span, hir::ExprKind::AddrOf(hir::BorrowKind::Ref, hir::Mutability::Mut, e))\n     }\n \n     fn expr_unit(&mut self, sp: Span) -> &'hir hir::Expr<'hir> {\n-        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[]), AttrVec::new()))\n+        self.arena.alloc(self.expr(sp, hir::ExprKind::Tup(&[])))\n     }\n \n     fn expr_call_mut(\n@@ -1802,7 +1771,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         e: &'hir hir::Expr<'hir>,\n         args: &'hir [hir::Expr<'hir>],\n     ) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Call(e, args), AttrVec::new())\n+        self.expr(span, hir::ExprKind::Call(e, args))\n     }\n \n     fn expr_call(\n@@ -1821,8 +1790,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         args: &'hir [hir::Expr<'hir>],\n         hir_id: Option<hir::HirId>,\n     ) -> hir::Expr<'hir> {\n-        let path =\n-            self.arena.alloc(self.expr_lang_item_path(span, lang_item, AttrVec::new(), hir_id));\n+        let path = self.arena.alloc(self.expr_lang_item_path(span, lang_item, hir_id));\n         self.expr_call_mut(span, path, args)\n     }\n \n@@ -1840,13 +1808,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         span: Span,\n         lang_item: hir::LangItem,\n-        attrs: AttrVec,\n         hir_id: Option<hir::HirId>,\n     ) -> hir::Expr<'hir> {\n         self.expr(\n             span,\n             hir::ExprKind::Path(hir::QPath::LangItem(lang_item, self.lower_span(span), hir_id)),\n-            attrs,\n         )\n     }\n \n@@ -1860,20 +1826,10 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     pub(super) fn expr_ident_mut(\n-        &mut self,\n-        sp: Span,\n-        ident: Ident,\n-        binding: hir::HirId,\n-    ) -> hir::Expr<'hir> {\n-        self.expr_ident_with_attrs(sp, ident, binding, AttrVec::new())\n-    }\n-\n-    fn expr_ident_with_attrs(\n         &mut self,\n         span: Span,\n         ident: Ident,\n         binding: hir::HirId,\n-        attrs: AttrVec,\n     ) -> hir::Expr<'hir> {\n         let hir_id = self.next_id();\n         let res = Res::Local(binding);\n@@ -1886,7 +1842,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }),\n         ));\n \n-        self.expr(span, expr_path, attrs)\n+        self.expr(span, expr_path)\n     }\n \n     fn expr_unsafe(&mut self, expr: &'hir hir::Expr<'hir>) -> hir::Expr<'hir> {\n@@ -1905,32 +1861,21 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 }),\n                 None,\n             ),\n-            AttrVec::new(),\n         )\n     }\n \n     fn expr_block_empty(&mut self, span: Span) -> &'hir hir::Expr<'hir> {\n         let blk = self.block_all(span, &[], None);\n-        let expr = self.expr_block(blk, AttrVec::new());\n+        let expr = self.expr_block(blk);\n         self.arena.alloc(expr)\n     }\n \n-    pub(super) fn expr_block(\n-        &mut self,\n-        b: &'hir hir::Block<'hir>,\n-        attrs: AttrVec,\n-    ) -> hir::Expr<'hir> {\n-        self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n+    pub(super) fn expr_block(&mut self, b: &'hir hir::Block<'hir>) -> hir::Expr<'hir> {\n+        self.expr(b.span, hir::ExprKind::Block(b, None))\n     }\n \n-    pub(super) fn expr(\n-        &mut self,\n-        span: Span,\n-        kind: hir::ExprKind<'hir>,\n-        attrs: AttrVec,\n-    ) -> hir::Expr<'hir> {\n+    pub(super) fn expr(&mut self, span: Span, kind: hir::ExprKind<'hir>) -> hir::Expr<'hir> {\n         let hir_id = self.next_id();\n-        self.lower_attrs(hir_id, &attrs);\n         hir::Expr { hir_id, kind, span: self.lower_span(span) }\n     }\n "}, {"sha": "d73d6d3918ea618dde2c3bbaa77e0954c73f5627", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -796,7 +796,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     /// Construct `ExprKind::Err` for the given `span`.\n     pub(crate) fn expr_err(&mut self, span: Span) -> hir::Expr<'hir> {\n-        self.expr(span, hir::ExprKind::Err, AttrVec::new())\n+        self.expr(span, hir::ExprKind::Err)\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> &'hir hir::ImplItem<'hir> {\n@@ -1151,11 +1151,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     // Transform into `drop-temps { <user-body> }`, an expression:\n                     let desugared_span =\n                         this.mark_span_with_reason(DesugaringKind::Async, user_body.span, None);\n-                    let user_body = this.expr_drop_temps(\n-                        desugared_span,\n-                        this.arena.alloc(user_body),\n-                        AttrVec::new(),\n-                    );\n+                    let user_body =\n+                        this.expr_drop_temps(desugared_span, this.arena.alloc(user_body));\n \n                     // As noted above, create the final block like\n                     //\n@@ -1172,14 +1169,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         Some(user_body),\n                     );\n \n-                    this.expr_block(body, AttrVec::new())\n+                    this.expr_block(body)\n                 },\n             );\n \n-            (\n-                this.arena.alloc_from_iter(parameters),\n-                this.expr(body.span, async_expr, AttrVec::new()),\n-            )\n+            (this.arena.alloc_from_iter(parameters), this.expr(body.span, async_expr))\n         })\n     }\n "}, {"sha": "07558ca075d3c022521fc73ba082a59b047149ac", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -2291,7 +2291,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// has no attributes and is not targeted by a `break`.\n     fn lower_block_expr(&mut self, b: &Block) -> hir::Expr<'hir> {\n         let block = self.lower_block(b, false);\n-        self.expr_block(block, AttrVec::new())\n+        self.expr_block(block)\n     }\n \n     fn lower_array_length(&mut self, c: &AnonConst) -> hir::ArrayLen {"}, {"sha": "ab5e19050ead2ffbb0a0d475c69d985ec86fb588", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 69, "deletions": 65, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -277,8 +277,7 @@ where\n             allowed_through_unstable_modules = true;\n         }\n         // attributes with data\n-        else if let Some(MetaItem { kind: MetaItemKind::List(ref metas), .. }) = meta {\n-            let meta = meta.as_ref().unwrap();\n+        else if let Some(meta @ MetaItem { kind: MetaItemKind::List(metas), .. }) = &meta {\n             let get = |meta: &MetaItem, item: &mut Option<Symbol>| {\n                 if item.is_some() {\n                     handle_errors(\n@@ -533,25 +532,24 @@ where\n \n     // Merge the const-unstable info into the stability info\n     if promotable {\n-        if let Some((ref mut stab, _)) = const_stab {\n-            stab.promotable = promotable;\n-        } else {\n-            sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp });\n+        match &mut const_stab {\n+            Some((stab, _)) => stab.promotable = promotable,\n+            _ => _ = sess.emit_err(session_diagnostics::RustcPromotablePairing { span: item_sp }),\n         }\n     }\n \n     if allowed_through_unstable_modules {\n-        if let Some((\n-            Stability {\n-                level: StabilityLevel::Stable { ref mut allowed_through_unstable_modules, .. },\n-                ..\n-            },\n-            _,\n-        )) = stab\n-        {\n-            *allowed_through_unstable_modules = true;\n-        } else {\n-            sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+        match &mut stab {\n+            Some((\n+                Stability {\n+                    level: StabilityLevel::Stable { allowed_through_unstable_modules, .. },\n+                    ..\n+                },\n+                _,\n+            )) => *allowed_through_unstable_modules = true,\n+            _ => {\n+                sess.emit_err(session_diagnostics::RustcAllowedUnstablePairing { span: item_sp });\n+            }\n         }\n     }\n \n@@ -654,8 +652,8 @@ pub fn eval_condition(\n     features: Option<&Features>,\n     eval: &mut impl FnMut(Condition) -> bool,\n ) -> bool {\n-    match cfg.kind {\n-        ast::MetaItemKind::List(ref mis) if cfg.name_or_empty() == sym::version => {\n+    match &cfg.kind {\n+        ast::MetaItemKind::List(mis) if cfg.name_or_empty() == sym::version => {\n             try_gate_cfg(sym::version, cfg.span, sess, features);\n             let (min_version, span) = match &mis[..] {\n                 [NestedMetaItem::Lit(MetaItemLit { kind: LitKind::Str(sym, ..), span, .. })] => {\n@@ -688,7 +686,7 @@ pub fn eval_condition(\n                 rustc_version >= min_version\n             }\n         }\n-        ast::MetaItemKind::List(ref mis) => {\n+        ast::MetaItemKind::List(mis) => {\n             for mi in mis.iter() {\n                 if !mi.is_meta_item() {\n                     handle_errors(\n@@ -759,7 +757,7 @@ pub fn eval_condition(\n             sess.emit_err(session_diagnostics::CfgPredicateIdentifier { span: cfg.path.span });\n             true\n         }\n-        MetaItemKind::NameValue(ref lit) if !lit.kind.is_str() => {\n+        MetaItemKind::NameValue(lit) if !lit.kind.is_str() => {\n             handle_errors(\n                 sess,\n                 lit.span,\n@@ -1036,52 +1034,58 @@ pub fn parse_repr_attr(sess: &Session, attr: &Attribute) -> Vec<ReprAttr> {\n                     });\n                 }\n             } else if let Some(meta_item) = item.meta_item() {\n-                if let MetaItemKind::NameValue(ref value) = meta_item.kind {\n-                    if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n-                        let name = meta_item.name_or_empty().to_ident_string();\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n-                            span: item.span(),\n-                            repr_arg: &name,\n-                            cause: IncorrectReprFormatGenericCause::from_lit_kind(\n-                                item.span(),\n-                                &value.kind,\n-                                &name,\n-                            ),\n-                        });\n-                    } else if matches!(\n-                        meta_item.name_or_empty(),\n-                        sym::C | sym::simd | sym::transparent\n-                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                    {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n-                            span: meta_item.span,\n-                            name: meta_item.name_or_empty().to_ident_string(),\n-                        });\n+                match &meta_item.kind {\n+                    MetaItemKind::NameValue(value) => {\n+                        if meta_item.has_name(sym::align) || meta_item.has_name(sym::packed) {\n+                            let name = meta_item.name_or_empty().to_ident_string();\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::IncorrectReprFormatGeneric {\n+                                span: item.span(),\n+                                repr_arg: &name,\n+                                cause: IncorrectReprFormatGenericCause::from_lit_kind(\n+                                    item.span(),\n+                                    &value.kind,\n+                                    &name,\n+                                ),\n+                            });\n+                        } else if matches!(\n+                            meta_item.name_or_empty(),\n+                            sym::C | sym::simd | sym::transparent\n+                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                        {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoValue {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n+                        }\n                     }\n-                } else if let MetaItemKind::List(_) = meta_item.kind {\n-                    if meta_item.has_name(sym::align) {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n-                            span: meta_item.span,\n-                        });\n-                    } else if meta_item.has_name(sym::packed) {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n-                            span: meta_item.span,\n-                        });\n-                    } else if matches!(\n-                        meta_item.name_or_empty(),\n-                        sym::C | sym::simd | sym::transparent\n-                    ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n-                    {\n-                        recognised = true;\n-                        sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n-                            span: meta_item.span,\n-                            name: meta_item.name_or_empty().to_ident_string(),\n-                        });\n+                    MetaItemKind::List(_) => {\n+                        if meta_item.has_name(sym::align) {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::IncorrectReprFormatAlignOneArg {\n+                                span: meta_item.span,\n+                            });\n+                        } else if meta_item.has_name(sym::packed) {\n+                            recognised = true;\n+                            sess.emit_err(\n+                                session_diagnostics::IncorrectReprFormatPackedOneOrZeroArg {\n+                                    span: meta_item.span,\n+                                },\n+                            );\n+                        } else if matches!(\n+                            meta_item.name_or_empty(),\n+                            sym::C | sym::simd | sym::transparent\n+                        ) || int_type_of_word(meta_item.name_or_empty()).is_some()\n+                        {\n+                            recognised = true;\n+                            sess.emit_err(session_diagnostics::InvalidReprHintNoParen {\n+                                span: meta_item.span,\n+                                name: meta_item.name_or_empty().to_ident_string(),\n+                            });\n+                        }\n                     }\n+                    _ => (),\n                 }\n             }\n             if !recognised {"}, {"sha": "5bb92a3582612f829cadce85e1b52118f4047916", "filename": "compiler/rustc_borrowck/src/borrow_set.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fborrow_set.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n         rvalue: &mir::Rvalue<'tcx>,\n         location: mir::Location,\n     ) {\n-        if let mir::Rvalue::Ref(region, kind, ref borrowed_place) = *rvalue {\n+        if let &mir::Rvalue::Ref(region, kind, borrowed_place) = rvalue {\n             if borrowed_place.ignore_borrow(self.tcx, self.body, &self.locals_state_at_exit) {\n                 debug!(\"ignoring_borrow of {:?}\", borrowed_place);\n                 return;\n@@ -211,7 +211,7 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n                 region,\n                 reserve_location: location,\n                 activation_location: TwoPhaseActivation::NotTwoPhase,\n-                borrowed_place: *borrowed_place,\n+                borrowed_place,\n                 assigned_place: *assigned_place,\n             };\n             let (idx, _) = self.location_map.insert_full(location, borrow);\n@@ -273,14 +273,14 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n     }\n \n     fn visit_rvalue(&mut self, rvalue: &mir::Rvalue<'tcx>, location: mir::Location) {\n-        if let mir::Rvalue::Ref(region, kind, ref place) = *rvalue {\n+        if let &mir::Rvalue::Ref(region, kind, place) = rvalue {\n             // double-check that we already registered a BorrowData for this\n \n             let borrow_data = &self.location_map[&location];\n             assert_eq!(borrow_data.reserve_location, location);\n             assert_eq!(borrow_data.kind, kind);\n             assert_eq!(borrow_data.region, region.to_region_vid());\n-            assert_eq!(borrow_data.borrowed_place, *place);\n+            assert_eq!(borrow_data.borrowed_place, place);\n         }\n \n         self.super_rvalue(rvalue, location)"}, {"sha": "f825b1d8f70ef502952699fe81e4aecf57edb849", "filename": "compiler/rustc_borrowck/src/dataflow.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdataflow.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -358,9 +358,9 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n         stmt: &mir::Statement<'tcx>,\n         location: Location,\n     ) {\n-        match stmt.kind {\n-            mir::StatementKind::Assign(box (lhs, ref rhs)) => {\n-                if let mir::Rvalue::Ref(_, _, place) = *rhs {\n+        match &stmt.kind {\n+            mir::StatementKind::Assign(box (lhs, rhs)) => {\n+                if let mir::Rvalue::Ref(_, _, place) = rhs {\n                     if place.ignore_borrow(\n                         self.tcx,\n                         self.body,\n@@ -377,13 +377,13 @@ impl<'tcx> rustc_mir_dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n \n                 // Make sure there are no remaining borrows for variables\n                 // that are assigned over.\n-                self.kill_borrows_on_place(trans, lhs);\n+                self.kill_borrows_on_place(trans, *lhs);\n             }\n \n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_place(trans, Place::from(local));\n+                self.kill_borrows_on_place(trans, Place::from(*local));\n             }\n \n             mir::StatementKind::FakeRead(..)"}, {"sha": "1550958ab8eee3942710ba5103fab472f560fa02", "filename": "compiler/rustc_borrowck/src/diagnostics/bound_region_errors.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fbound_region_errors.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -243,9 +243,9 @@ impl<'tcx> TypeOpInfo<'tcx> for PredicateQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n         type_op_prove_predicate_with_cause(&ocx, key, cause);\n         try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }\n@@ -284,9 +284,9 @@ where\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n \n         // FIXME(lqd): Unify and de-duplicate the following with the actual\n         // `rustc_traits::type_op::type_op_normalize` query to allow the span we need in the\n@@ -328,9 +328,9 @@ impl<'tcx> TypeOpInfo<'tcx> for AscribeUserTypeQuery<'tcx> {\n         placeholder_region: ty::Region<'tcx>,\n         error_region: Option<ty::Region<'tcx>>,\n     ) -> Option<DiagnosticBuilder<'tcx, ErrorGuaranteed>> {\n-        let (ref infcx, key, _) =\n+        let (infcx, key, _) =\n             mbcx.infcx.tcx.infer_ctxt().build_with_canonical(cause.span, &self.canonical_query);\n-        let ocx = ObligationCtxt::new(infcx);\n+        let ocx = ObligationCtxt::new(&infcx);\n         type_op_ascribe_user_type_with_span(&ocx, key, Some(cause.span)).ok()?;\n         try_extract_error_from_fulfill_cx(&ocx, placeholder_region, error_region)\n     }"}, {"sha": "5e3745f17353af8543cc8cbdf52dcf7b1e25cfd6", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -265,7 +265,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 DescribePlaceOpt { including_downcast: true, including_tuple_field: true },\n             );\n             let note_msg = match opt_name {\n-                Some(ref name) => format!(\"`{}`\", name),\n+                Some(name) => format!(\"`{}`\", name),\n                 None => \"value\".to_owned(),\n             };\n             if self.suggest_borrow_fn_like(&mut err, ty, &move_site_vec, &note_msg) {\n@@ -1417,7 +1417,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             // then just use the normal error. The closure isn't escaping\n             // and `move` will not help here.\n             (\n-                Some(ref name),\n+                Some(name),\n                 BorrowExplanation::MustBeValidFor {\n                     category:\n                         category @ (ConstraintCategory::Return(_)\n@@ -1438,7 +1438,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     &format!(\"`{}`\", name),\n                 ),\n             (\n-                ref name,\n+                name,\n                 BorrowExplanation::MustBeValidFor {\n                     category: ConstraintCategory::Assignment,\n                     from_closure: false,\n@@ -1450,7 +1450,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     span,\n                     ..\n                 },\n-            ) => self.report_escaping_data(borrow_span, name, upvar_span, upvar_name, span),\n+            ) => self.report_escaping_data(borrow_span, &name, upvar_span, upvar_name, span),\n             (Some(name), explanation) => self.report_local_value_does_not_live_long_enough(\n                 location,\n                 &name,\n@@ -2452,7 +2452,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // and it'll make sense.\n         let location = borrow.reserve_location;\n         debug!(\"annotate_argument_and_return_for_borrow: location={:?}\", location);\n-        if let Some(&Statement { kind: StatementKind::Assign(box (ref reservation, _)), .. }) =\n+        if let Some(Statement { kind: StatementKind::Assign(box (reservation, _)), .. }) =\n             &self.body[location.block].statements.get(location.statement_index)\n         {\n             debug!(\"annotate_argument_and_return_for_borrow: reservation={:?}\", reservation);\n@@ -2480,8 +2480,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         // Check if our `target` was captured by a closure.\n                         if let Rvalue::Aggregate(\n                             box AggregateKind::Closure(def_id, substs),\n-                            ref operands,\n-                        ) = *rvalue\n+                            operands,\n+                        ) = rvalue\n                         {\n                             for operand in operands {\n                                 let (Operand::Copy(assigned_from) | Operand::Move(assigned_from)) = operand else {\n@@ -2505,7 +2505,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 // into a place then we should annotate the closure in\n                                 // case it ends up being assigned into the return place.\n                                 annotated_closure =\n-                                    self.annotate_fn_sig(def_id, substs.as_closure().sig());\n+                                    self.annotate_fn_sig(*def_id, substs.as_closure().sig());\n                                 debug!(\n                                     \"annotate_argument_and_return_for_borrow: \\\n                                      annotated_closure={:?} assigned_from_local={:?} \\"}, {"sha": "304683618d83ef9dc531c7fcb7f7ed91ed329a7f", "filename": "compiler/rustc_borrowck/src/diagnostics/explain_borrow.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fexplain_borrow.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -469,8 +469,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 } else if self.was_captured_by_trait_object(borrow) {\n                     LaterUseKind::TraitCapture\n                 } else if location.statement_index == block.statements.len() {\n-                    if let TerminatorKind::Call { ref func, from_hir_call: true, .. } =\n-                        block.terminator().kind\n+                    if let TerminatorKind::Call { func, from_hir_call: true, .. } =\n+                        &block.terminator().kind\n                     {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n@@ -515,19 +515,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // will only ever have one item at any given time, but by using a vector, we can pop from\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n-        let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(box (ref place, _)),\n-            ..\n-        }) = stmt\n-        {\n-            if let Some(local) = place.as_local() {\n-                local\n+        let mut target =\n+            if let Some(Statement { kind: StatementKind::Assign(box (place, _)), .. }) = stmt {\n+                if let Some(local) = place.as_local() {\n+                    local\n+                } else {\n+                    return false;\n+                }\n             } else {\n                 return false;\n-            }\n-        } else {\n-            return false;\n-        };\n+            };\n \n         debug!(\"was_captured_by_trait: target={:?} queue={:?}\", target, queue);\n         while let Some(current_location) = queue.pop() {"}, {"sha": "4e2271a30672270a5ff8c49c1b4460ab8c11938b", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 21, "deletions": 26, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -78,7 +78,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             if let StatementKind::Assign(box (into, Rvalue::Use(from))) = &stmt.kind {\n                 debug!(\"add_fnonce_closure_note: into={:?} from={:?}\", into, from);\n                 match from {\n-                    Operand::Copy(ref place) | Operand::Move(ref place)\n+                    Operand::Copy(place) | Operand::Move(place)\n                         if target == place.local_or_deref_local() =>\n                     {\n                         target = into.local_or_deref_local()\n@@ -101,7 +101,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"add_moved_or_invoked_closure_note: id={:?}\", id);\n                 if Some(self.infcx.tcx.parent(id)) == self.infcx.tcx.lang_items().fn_once_trait() {\n                     let closure = match args.first() {\n-                        Some(Operand::Copy(ref place)) | Some(Operand::Move(ref place))\n+                        Some(Operand::Copy(place) | Operand::Move(place))\n                             if target == place.local_or_deref_local() =>\n                         {\n                             place.local_or_deref_local().unwrap()\n@@ -439,9 +439,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     if !is_terminator {\n                         continue;\n                     } else if let Some(Terminator {\n-                        kind: TerminatorKind::Call { ref func, from_hir_call: false, .. },\n+                        kind: TerminatorKind::Call { func, from_hir_call: false, .. },\n                         ..\n-                    }) = bbd.terminator\n+                    }) = &bbd.terminator\n                     {\n                         if let Some(source) =\n                             BorrowedContentSource::from_call(func.ty(self.body, tcx), tcx)\n@@ -811,33 +811,30 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         };\n \n         debug!(\"move_spans: moved_place={:?} location={:?} stmt={:?}\", moved_place, location, stmt);\n-        if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) = stmt.kind {\n-            match **kind {\n-                AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) => {\n-                    debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n-                    if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n-                        self.closure_span(def_id, moved_place, places)\n-                    {\n-                        return ClosureUse {\n-                            generator_kind,\n-                            args_span,\n-                            capture_kind_span,\n-                            path_span,\n-                        };\n-                    }\n-                }\n-                _ => {}\n+        if let StatementKind::Assign(box (_, Rvalue::Aggregate(kind, places))) = &stmt.kind\n+            && let AggregateKind::Closure(def_id, _) | AggregateKind::Generator(def_id, _, _) = **kind\n+        {\n+            debug!(\"move_spans: def_id={:?} places={:?}\", def_id, places);\n+            if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n+                self.closure_span(def_id, moved_place, places)\n+            {\n+                return ClosureUse {\n+                    generator_kind,\n+                    args_span,\n+                    capture_kind_span,\n+                    path_span,\n+                };\n             }\n         }\n \n         // StatementKind::FakeRead only contains a def_id if they are introduced as a result\n         // of pattern matching within a closure.\n-        if let StatementKind::FakeRead(box (cause, ref place)) = stmt.kind {\n+        if let StatementKind::FakeRead(box (cause, place)) = stmt.kind {\n             match cause {\n                 FakeReadCause::ForMatchedPlace(Some(closure_def_id))\n                 | FakeReadCause::ForLet(Some(closure_def_id)) => {\n                     debug!(\"move_spans: def_id={:?} place={:?}\", closure_def_id, place);\n-                    let places = &[Operand::Move(*place)];\n+                    let places = &[Operand::Move(place)];\n                     if let Some((args_span, generator_kind, capture_kind_span, path_span)) =\n                         self.closure_span(closure_def_id, moved_place, places)\n                     {\n@@ -924,7 +921,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         debug!(\"borrow_spans: use_span={:?} location={:?}\", use_span, location);\n \n         let target = match self.body[location.block].statements.get(location.statement_index) {\n-            Some(&Statement { kind: StatementKind::Assign(box (ref place, _)), .. }) => {\n+            Some(Statement { kind: StatementKind::Assign(box (place, _)), .. }) => {\n                 if let Some(local) = place.as_local() {\n                     local\n                 } else {\n@@ -940,9 +937,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n \n         for stmt in &self.body[location.block].statements[location.statement_index + 1..] {\n-            if let StatementKind::Assign(box (_, Rvalue::Aggregate(ref kind, ref places))) =\n-                stmt.kind\n-            {\n+            if let StatementKind::Assign(box (_, Rvalue::Aggregate(kind, places))) = &stmt.kind {\n                 let (&def_id, is_generator) = match kind {\n                     box AggregateKind::Closure(def_id, _) => (def_id, false),\n                     box AggregateKind::Generator(def_id, _, _) => (def_id, true),"}, {"sha": "3319a80681fde277dc0fd3f361c2656adfafe6b6", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -219,8 +219,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             PlaceRef {\n                 local,\n                 projection:\n-                    &[\n-                        ref proj_base @ ..,\n+                    [\n+                        proj_base @ ..,\n                         ProjectionElem::Deref,\n                         ProjectionElem::Field(field, _),\n                         ProjectionElem::Deref,\n@@ -231,7 +231,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 if let Some(span) = get_mut_span_in_struct_field(\n                     self.infcx.tcx,\n                     Place::ty_from(local, proj_base, self.body, self.infcx.tcx).ty,\n-                    field,\n+                    *field,\n                 ) {\n                     err.span_suggestion_verbose(\n                         span,"}, {"sha": "9bc2e79e29bc17c9b96a77b7ca99013312159a76", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -921,7 +921,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n             hir::ExprKind::Block(blk, _) => {\n-                if let Some(ref expr) = blk.expr {\n+                if let Some(expr) = blk.expr {\n                     // only when the block is a closure\n                     if let hir::ExprKind::Closure(hir::Closure {\n                         capture_clause: hir::CaptureBy::Ref,"}, {"sha": "171e62d91e136463dfd600eb3dc9b51977b6ca59", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -254,7 +254,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_impl_signature(fr))\n             .or_else(|| self.give_name_if_anonymous_region_appears_in_arg_position_impl_trait(fr));\n \n-        if let Some(ref value) = value {\n+        if let Some(value) = &value {\n             self.region_names.try_borrow_mut().unwrap().insert(fr, value.clone());\n         }\n "}, {"sha": "f66a7ab3c031aa87ae54fc658047f2b4cf8384be", "filename": "compiler/rustc_borrowck/src/invalidation.rs", "status": "modified", "additions": 32, "deletions": 33, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Finvalidation.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -69,9 +69,9 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 self.consume_operand(location, op);\n             }\n             StatementKind::Intrinsic(box NonDivergingIntrinsic::CopyNonOverlapping(mir::CopyNonOverlapping {\n-                ref src,\n-                ref dst,\n-                ref count,\n+                src,\n+                dst,\n+                count,\n             })) => {\n                 self.consume_operand(location, src);\n                 self.consume_operand(location, dst);\n@@ -106,7 +106,7 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n         self.check_activations(location);\n \n         match &terminator.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(location, discr);\n             }\n             TerminatorKind::Drop { place: drop_place, target: _, unwind: _ } => {\n@@ -119,16 +119,16 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::DropAndReplace {\n                 place: drop_place,\n-                value: ref new_value,\n+                value: new_value,\n                 target: _,\n                 unwind: _,\n             } => {\n                 self.mutate_place(location, *drop_place, Deep);\n                 self.consume_operand(location, new_value);\n             }\n             TerminatorKind::Call {\n-                ref func,\n-                ref args,\n+                func,\n+                args,\n                 destination,\n                 target: _,\n                 cleanup: _,\n@@ -141,15 +141,15 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n                 }\n                 self.mutate_place(location, *destination, Deep);\n             }\n-            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected: _, msg, target: _, cleanup: _ } => {\n                 self.consume_operand(location, cond);\n                 use rustc_middle::mir::AssertKind;\n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     self.consume_operand(location, len);\n                     self.consume_operand(location, index);\n                 }\n             }\n-            TerminatorKind::Yield { ref value, resume, resume_arg, drop: _ } => {\n+            TerminatorKind::Yield { value, resume, resume_arg, drop: _ } => {\n                 self.consume_operand(location, value);\n \n                 // Invalidate all borrows of local places\n@@ -175,25 +175,25 @@ impl<'cx, 'tcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx> {\n             }\n             TerminatorKind::InlineAsm {\n                 template: _,\n-                ref operands,\n+                operands,\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n                 cleanup: _,\n             } => {\n                 for op in operands {\n-                    match *op {\n-                        InlineAsmOperand::In { reg: _, ref value } => {\n+                    match op {\n+                        InlineAsmOperand::In { reg: _, value } => {\n                             self.consume_operand(location, value);\n                         }\n                         InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n-                            if let Some(place) = place {\n+                            if let &Some(place) = place {\n                                 self.mutate_place(location, place, Shallow(None));\n                             }\n                         }\n-                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                        InlineAsmOperand::InOut { reg: _, late: _, in_value, out_place } => {\n                             self.consume_operand(location, in_value);\n-                            if let Some(out_place) = out_place {\n+                            if let &Some(out_place) = out_place {\n                                 self.mutate_place(location, out_place, Shallow(None));\n                             }\n                         }\n@@ -252,8 +252,8 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n \n     // Simulates consumption of an rvalue\n     fn consume_rvalue(&mut self, location: Location, rvalue: &Rvalue<'tcx>) {\n-        match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n+        match rvalue {\n+            &Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -272,7 +272,7 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 self.access_place(location, place, access_kind, LocalMutationIsAllowed::No);\n             }\n \n-            Rvalue::AddressOf(mutability, place) => {\n+            &Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -288,20 +288,19 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n \n             Rvalue::ThreadLocalRef(_) => {}\n \n-            Rvalue::Use(ref operand)\n-            | Rvalue::Repeat(ref operand, _)\n-            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n-            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/)\n-            | Rvalue::ShallowInitBox(ref operand, _ /*ty*/) => {\n-                self.consume_operand(location, operand)\n-            }\n-            Rvalue::CopyForDeref(ref place) => {\n-                let op = &Operand::Copy(*place);\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, operand, _ /*ty*/)\n+            | Rvalue::ShallowInitBox(operand, _ /*ty*/) => self.consume_operand(location, operand),\n+\n+            &Rvalue::CopyForDeref(place) => {\n+                let op = &Operand::Copy(place);\n                 self.consume_operand(location, op);\n             }\n \n-            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n-                let af = match *rvalue {\n+            &(Rvalue::Len(place) | Rvalue::Discriminant(place)) => {\n+                let af = match rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n                     _ => unreachable!(),\n@@ -314,15 +313,15 @@ impl<'cx, 'tcx> InvalidationGenerator<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::BinaryOp(_bin_op, box (ref operand1, ref operand2))\n-            | Rvalue::CheckedBinaryOp(_bin_op, box (ref operand1, ref operand2)) => {\n+            Rvalue::BinaryOp(_bin_op, box (operand1, operand2))\n+            | Rvalue::CheckedBinaryOp(_bin_op, box (operand1, operand2)) => {\n                 self.consume_operand(location, operand1);\n                 self.consume_operand(location, operand2);\n             }\n \n             Rvalue::NullaryOp(_op, _ty) => {}\n \n-            Rvalue::Aggregate(_, ref operands) => {\n+            Rvalue::Aggregate(_, operands) => {\n                 for operand in operands {\n                     self.consume_operand(location, operand);\n                 }"}, {"sha": "74b4e4a0cabdd6826807ba410ff4af8884fb2c4d", "filename": "compiler/rustc_borrowck/src/lib.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Flib.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -578,12 +578,12 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n         self.check_activations(location, span, flow_state);\n \n         match &stmt.kind {\n-            StatementKind::Assign(box (lhs, ref rhs)) => {\n+            StatementKind::Assign(box (lhs, rhs)) => {\n                 self.consume_rvalue(location, (rhs, span), flow_state);\n \n                 self.mutate_place(location, (*lhs, span), Shallow(None), flow_state);\n             }\n-            StatementKind::FakeRead(box (_, ref place)) => {\n+            StatementKind::FakeRead(box (_, place)) => {\n                 // Read for match doesn't access any memory and is used to\n                 // assert that a place is safe and live. So we don't have to\n                 // do any checks here.\n@@ -601,7 +601,7 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                     flow_state,\n                 );\n             }\n-            StatementKind::Intrinsic(box ref kind) => match kind {\n+            StatementKind::Intrinsic(box kind) => match kind {\n                 NonDivergingIntrinsic::Assume(op) => self.consume_operand(location, (op, span), flow_state),\n                 NonDivergingIntrinsic::CopyNonOverlapping(..) => span_bug!(\n                     span,\n@@ -643,8 +643,8 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n \n         self.check_activations(loc, span, flow_state);\n \n-        match term.kind {\n-            TerminatorKind::SwitchInt { ref discr, switch_ty: _, targets: _ } => {\n+        match &term.kind {\n+            TerminatorKind::SwitchInt { discr, switch_ty: _, targets: _ } => {\n                 self.consume_operand(loc, (discr, span), flow_state);\n             }\n             TerminatorKind::Drop { place, target: _, unwind: _ } => {\n@@ -656,24 +656,24 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n \n                 self.access_place(\n                     loc,\n-                    (place, span),\n+                    (*place, span),\n                     (AccessDepth::Drop, Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n                 );\n             }\n             TerminatorKind::DropAndReplace {\n                 place: drop_place,\n-                value: ref new_value,\n+                value: new_value,\n                 target: _,\n                 unwind: _,\n             } => {\n-                self.mutate_place(loc, (drop_place, span), Deep, flow_state);\n+                self.mutate_place(loc, (*drop_place, span), Deep, flow_state);\n                 self.consume_operand(loc, (new_value, span), flow_state);\n             }\n             TerminatorKind::Call {\n-                ref func,\n-                ref args,\n+                func,\n+                args,\n                 destination,\n                 target: _,\n                 cleanup: _,\n@@ -684,43 +684,43 @@ impl<'cx, 'tcx> rustc_mir_dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtx\n                 for arg in args {\n                     self.consume_operand(loc, (arg, span), flow_state);\n                 }\n-                self.mutate_place(loc, (destination, span), Deep, flow_state);\n+                self.mutate_place(loc, (*destination, span), Deep, flow_state);\n             }\n-            TerminatorKind::Assert { ref cond, expected: _, ref msg, target: _, cleanup: _ } => {\n+            TerminatorKind::Assert { cond, expected: _, msg, target: _, cleanup: _ } => {\n                 self.consume_operand(loc, (cond, span), flow_state);\n                 use rustc_middle::mir::AssertKind;\n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     self.consume_operand(loc, (len, span), flow_state);\n                     self.consume_operand(loc, (index, span), flow_state);\n                 }\n             }\n \n-            TerminatorKind::Yield { ref value, resume: _, resume_arg, drop: _ } => {\n+            TerminatorKind::Yield { value, resume: _, resume_arg, drop: _ } => {\n                 self.consume_operand(loc, (value, span), flow_state);\n-                self.mutate_place(loc, (resume_arg, span), Deep, flow_state);\n+                self.mutate_place(loc, (*resume_arg, span), Deep, flow_state);\n             }\n \n             TerminatorKind::InlineAsm {\n                 template: _,\n-                ref operands,\n+                operands,\n                 options: _,\n                 line_spans: _,\n                 destination: _,\n                 cleanup: _,\n             } => {\n                 for op in operands {\n-                    match *op {\n-                        InlineAsmOperand::In { reg: _, ref value } => {\n+                    match op {\n+                        InlineAsmOperand::In { reg: _, value } => {\n                             self.consume_operand(loc, (value, span), flow_state);\n                         }\n                         InlineAsmOperand::Out { reg: _, late: _, place, .. } => {\n                             if let Some(place) = place {\n-                                self.mutate_place(loc, (place, span), Shallow(None), flow_state);\n+                                self.mutate_place(loc, (*place, span), Shallow(None), flow_state);\n                             }\n                         }\n-                        InlineAsmOperand::InOut { reg: _, late: _, ref in_value, out_place } => {\n+                        InlineAsmOperand::InOut { reg: _, late: _, in_value, out_place } => {\n                             self.consume_operand(loc, (in_value, span), flow_state);\n-                            if let Some(out_place) = out_place {\n+                            if let &Some(out_place) = out_place {\n                                 self.mutate_place(\n                                     loc,\n                                     (out_place, span),\n@@ -1164,8 +1164,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         (rvalue, span): (&'cx Rvalue<'tcx>, Span),\n         flow_state: &Flows<'cx, 'tcx>,\n     ) {\n-        match *rvalue {\n-            Rvalue::Ref(_ /*rgn*/, bk, place) => {\n+        match rvalue {\n+            &Rvalue::Ref(_ /*rgn*/, bk, place) => {\n                 let access_kind = match bk {\n                     BorrowKind::Shallow => {\n                         (Shallow(Some(ArtificialField::ShallowBorrow)), Read(ReadKind::Borrow(bk)))\n@@ -1203,7 +1203,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::AddressOf(mutability, place) => {\n+            &Rvalue::AddressOf(mutability, place) => {\n                 let access_kind = match mutability {\n                     Mutability::Mut => (\n                         Deep,\n@@ -1232,14 +1232,15 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n \n             Rvalue::ThreadLocalRef(_) => {}\n \n-            Rvalue::Use(ref operand)\n-            | Rvalue::Repeat(ref operand, _)\n-            | Rvalue::UnaryOp(_ /*un_op*/, ref operand)\n-            | Rvalue::Cast(_ /*cast_kind*/, ref operand, _ /*ty*/)\n-            | Rvalue::ShallowInitBox(ref operand, _ /*ty*/) => {\n+            Rvalue::Use(operand)\n+            | Rvalue::Repeat(operand, _)\n+            | Rvalue::UnaryOp(_ /*un_op*/, operand)\n+            | Rvalue::Cast(_ /*cast_kind*/, operand, _ /*ty*/)\n+            | Rvalue::ShallowInitBox(operand, _ /*ty*/) => {\n                 self.consume_operand(location, (operand, span), flow_state)\n             }\n-            Rvalue::CopyForDeref(place) => {\n+\n+            &Rvalue::CopyForDeref(place) => {\n                 self.access_place(\n                     location,\n                     (place, span),\n@@ -1257,7 +1258,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::Len(place) | Rvalue::Discriminant(place) => {\n+            &(Rvalue::Len(place) | Rvalue::Discriminant(place)) => {\n                 let af = match *rvalue {\n                     Rvalue::Len(..) => Some(ArtificialField::ArrayLength),\n                     Rvalue::Discriminant(..) => None,\n@@ -1278,8 +1279,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 );\n             }\n \n-            Rvalue::BinaryOp(_bin_op, box (ref operand1, ref operand2))\n-            | Rvalue::CheckedBinaryOp(_bin_op, box (ref operand1, ref operand2)) => {\n+            Rvalue::BinaryOp(_bin_op, box (operand1, operand2))\n+            | Rvalue::CheckedBinaryOp(_bin_op, box (operand1, operand2)) => {\n                 self.consume_operand(location, (operand1, span), flow_state);\n                 self.consume_operand(location, (operand2, span), flow_state);\n             }\n@@ -1288,7 +1289,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 // nullary ops take no dynamic input; no borrowck effect.\n             }\n \n-            Rvalue::Aggregate(ref aggregate_kind, ref operands) => {\n+            Rvalue::Aggregate(aggregate_kind, operands) => {\n                 // We need to report back the list of mutable upvars that were\n                 // moved into the closure and subsequently used by the closure,\n                 // in order to populate our used_mut set."}, {"sha": "6d4ec6b726eb027f6e330b084370048445bce315", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -1189,8 +1189,8 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     fn check_stmt(&mut self, body: &Body<'tcx>, stmt: &Statement<'tcx>, location: Location) {\n         let tcx = self.tcx();\n         debug!(\"stmt kind: {:?}\", stmt.kind);\n-        match stmt.kind {\n-            StatementKind::Assign(box (ref place, ref rv)) => {\n+        match &stmt.kind {\n+            StatementKind::Assign(box (place, rv)) => {\n                 // Assignments to temporaries are not \"interesting\";\n                 // they are not caused by the user, but rather artifacts\n                 // of lowering. Assignments to other sorts of places *are* interesting\n@@ -1279,11 +1279,11 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::AscribeUserType(box (ref place, ref projection), variance) => {\n+            StatementKind::AscribeUserType(box (place, projection), variance) => {\n                 let place_ty = place.ty(body, tcx).ty;\n                 if let Err(terr) = self.relate_type_and_user_type(\n                     place_ty,\n-                    variance,\n+                    *variance,\n                     projection,\n                     Locations::All(stmt.source_info.span),\n                     ConstraintCategory::TypeAnnotation,\n@@ -1300,7 +1300,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            StatementKind::Intrinsic(box ref kind) => match kind {\n+            StatementKind::Intrinsic(box kind) => match kind {\n                 NonDivergingIntrinsic::Assume(op) => self.check_operand(op, location),\n                 NonDivergingIntrinsic::CopyNonOverlapping(..) => span_bug!(\n                     stmt.source_info.span,\n@@ -1328,7 +1328,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n     ) {\n         let tcx = self.tcx();\n         debug!(\"terminator kind: {:?}\", term.kind);\n-        match term.kind {\n+        match &term.kind {\n             TerminatorKind::Goto { .. }\n             | TerminatorKind::Resume\n             | TerminatorKind::Abort\n@@ -1342,7 +1342,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 // no checks needed for these\n             }\n \n-            TerminatorKind::DropAndReplace { ref place, ref value, target: _, unwind: _ } => {\n+            TerminatorKind::DropAndReplace { place, value, target: _, unwind: _ } => {\n                 let place_ty = place.ty(body, tcx).ty;\n                 let rv_ty = value.ty(body, tcx);\n \n@@ -1360,13 +1360,13 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     );\n                 }\n             }\n-            TerminatorKind::SwitchInt { ref discr, switch_ty, .. } => {\n+            TerminatorKind::SwitchInt { discr, switch_ty, .. } => {\n                 self.check_operand(discr, term_location);\n \n                 let discr_ty = discr.ty(body, tcx);\n                 if let Err(terr) = self.sub_types(\n                     discr_ty,\n-                    switch_ty,\n+                    *switch_ty,\n                     term_location.to_locations(),\n                     ConstraintCategory::Assignment,\n                 ) {\n@@ -1384,14 +1384,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 }\n                 // FIXME: check the values\n             }\n-            TerminatorKind::Call {\n-                ref func,\n-                ref args,\n-                ref destination,\n-                from_hir_call,\n-                target,\n-                ..\n-            } => {\n+            TerminatorKind::Call { func, args, destination, from_hir_call, target, .. } => {\n                 self.check_operand(func, term_location);\n                 for arg in args {\n                     self.check_operand(arg, term_location);\n@@ -1431,7 +1424,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     ConstraintCategory::Boring,\n                 );\n                 let sig = self.normalize(sig, term_location);\n-                self.check_call_dest(body, term, &sig, *destination, target, term_location);\n+                self.check_call_dest(body, term, &sig, *destination, *target, term_location);\n \n                 // The ordinary liveness rules will ensure that all\n                 // regions in the type of the callee are live here. We\n@@ -1449,17 +1442,17 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                         .add_element(region_vid, term_location);\n                 }\n \n-                self.check_call_inputs(body, term, &sig, args, term_location, from_hir_call);\n+                self.check_call_inputs(body, term, &sig, args, term_location, *from_hir_call);\n             }\n-            TerminatorKind::Assert { ref cond, ref msg, .. } => {\n+            TerminatorKind::Assert { cond, msg, .. } => {\n                 self.check_operand(cond, term_location);\n \n                 let cond_ty = cond.ty(body, tcx);\n                 if cond_ty != tcx.types.bool {\n                     span_mirbug!(self, term, \"bad Assert ({:?}, not bool\", cond_ty);\n                 }\n \n-                if let AssertKind::BoundsCheck { ref len, ref index } = *msg {\n+                if let AssertKind::BoundsCheck { len, index } = msg {\n                     if len.ty(body, tcx) != tcx.types.usize {\n                         span_mirbug!(self, len, \"bounds-check length non-usize {:?}\", len)\n                     }\n@@ -1468,7 +1461,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n                 }\n             }\n-            TerminatorKind::Yield { ref value, .. } => {\n+            TerminatorKind::Yield { value, .. } => {\n                 self.check_operand(value, term_location);\n \n                 let value_ty = value.ty(body, tcx);\n@@ -2630,7 +2623,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         substs: SubstsRef<'tcx>,\n         location: Location,\n     ) -> ty::InstantiatedPredicates<'tcx> {\n-        if let Some(ref closure_requirements) = tcx.mir_borrowck(def_id).closure_requirements {\n+        if let Some(closure_requirements) = &tcx.mir_borrowck(def_id).closure_requirements {\n             constraint_conversion::ConstraintConversion::new(\n                 self.infcx,\n                 self.borrowck_context.universal_regions,"}, {"sha": "a4a0c5b90fed32d2a20372aa908806b81aa9a2fe", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -587,9 +587,9 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n         let typeck_root_def_id = tcx.typeck_root_def_id(self.mir_def.did.to_def_id());\n         let identity_substs = InternalSubsts::identity_for_item(tcx, typeck_root_def_id);\n         let fr_substs = match defining_ty {\n-            DefiningTy::Closure(_, ref substs)\n-            | DefiningTy::Generator(_, ref substs, _)\n-            | DefiningTy::InlineConst(_, ref substs) => {\n+            DefiningTy::Closure(_, substs)\n+            | DefiningTy::Generator(_, substs, _)\n+            | DefiningTy::InlineConst(_, substs) => {\n                 // In the case of closures, we rely on the fact that\n                 // the first N elements in the ClosureSubsts are\n                 // inherited from the `typeck_root_def_id`."}, {"sha": "95e38e4b053f496604f25079b22722e2fbf3dc4b", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -17,32 +17,23 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::alloc_error_handler);\n \n     let orig_item = item.clone();\n-    let not_function = || {\n-        ecx.sess\n-            .parse_sess\n-            .span_diagnostic\n-            .span_err(item.span(), \"alloc_error_handler must be a function\");\n-        vec![orig_item.clone()]\n-    };\n \n     // Allow using `#[alloc_error_handler]` on an item statement\n     // FIXME - if we get deref patterns, use them to reduce duplication here\n-    let (item, is_stmt, sig_span) = match &item {\n-        Annotatable::Item(item) => match item.kind {\n-            ItemKind::Fn(ref fn_kind) => (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span)),\n-            _ => return not_function(),\n-        },\n-        Annotatable::Stmt(stmt) => match &stmt.kind {\n-            StmtKind::Item(item_) => match item_.kind {\n-                ItemKind::Fn(ref fn_kind) => {\n-                    (item_, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n-                }\n-                _ => return not_function(),\n-            },\n-            _ => return not_function(),\n-        },\n-        _ => return not_function(),\n-    };\n+    let (item, is_stmt, sig_span) =\n+        if let Annotatable::Item(item) = &item\n+            && let ItemKind::Fn(fn_kind) = &item.kind\n+        {\n+            (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+        } else if let Annotatable::Stmt(stmt) = &item\n+            && let StmtKind::Item(item) = &stmt.kind\n+            && let ItemKind::Fn(fn_kind) = &item.kind\n+        {\n+            (item, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+        } else {\n+            ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"alloc_error_handler must be a function\");\n+            return vec![orig_item.clone()];\n+        };\n \n     // Generate a bunch of new items using the AllocFnFactory\n     let span = ecx.with_def_site_ctxt(item.span);"}, {"sha": "93b07801e035d7de24d995980ccd1568063ffb29", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -191,19 +191,19 @@ impl<'cx, 'a> Context<'cx, 'a> {\n     ///\n     /// See [Self::manage_initial_capture] and [Self::manage_try_capture]\n     fn manage_cond_expr(&mut self, expr: &mut P<Expr>) {\n-        match (*expr).kind {\n-            ExprKind::AddrOf(_, mutability, ref mut local_expr) => {\n+        match &mut expr.kind {\n+            ExprKind::AddrOf(_, mutability, local_expr) => {\n                 self.with_is_consumed_management(\n                     matches!(mutability, Mutability::Mut),\n                     |this| this.manage_cond_expr(local_expr)\n                 );\n             }\n-            ExprKind::Array(ref mut local_exprs) => {\n+            ExprKind::Array(local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Binary(ref op, ref mut lhs, ref mut rhs) => {\n+            ExprKind::Binary(op, lhs, rhs) => {\n                 self.with_is_consumed_management(\n                     matches!(\n                         op.node,\n@@ -226,56 +226,56 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     }\n                 );\n             }\n-            ExprKind::Call(_, ref mut local_exprs) => {\n+            ExprKind::Call(_, local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Cast(ref mut local_expr, _) => {\n+            ExprKind::Cast(local_expr, _) => {\n                 self.manage_cond_expr(local_expr);\n             }\n-            ExprKind::Index(ref mut prefix, ref mut suffix) => {\n+            ExprKind::Index(prefix, suffix) => {\n                 self.manage_cond_expr(prefix);\n                 self.manage_cond_expr(suffix);\n             }\n-            ExprKind::MethodCall(ref mut call) => {\n-                for arg in call.args.iter_mut() {\n+            ExprKind::MethodCall(call) => {\n+                for arg in &mut call.args {\n                     self.manage_cond_expr(arg);\n                 }\n             }\n-            ExprKind::Path(_, Path { ref segments, .. }) if let &[ref path_segment] = &segments[..] => {\n+            ExprKind::Path(_, Path { segments, .. }) if let [path_segment] = &segments[..] => {\n                 let path_ident = path_segment.ident;\n                 self.manage_initial_capture(expr, path_ident);\n             }\n-            ExprKind::Paren(ref mut local_expr) => {\n+            ExprKind::Paren(local_expr) => {\n                 self.manage_cond_expr(local_expr);\n             }\n-            ExprKind::Range(ref mut prefix, ref mut suffix, _) => {\n-                if let Some(ref mut elem) = prefix {\n+            ExprKind::Range(prefix, suffix, _) => {\n+                if let Some(elem) = prefix {\n                     self.manage_cond_expr(elem);\n                 }\n-                if let Some(ref mut elem) = suffix {\n+                if let Some(elem) = suffix {\n                     self.manage_cond_expr(elem);\n                 }\n             }\n-            ExprKind::Repeat(ref mut local_expr, ref mut elem) => {\n+            ExprKind::Repeat(local_expr, elem) => {\n                 self.manage_cond_expr(local_expr);\n                 self.manage_cond_expr(&mut elem.value);\n             }\n-            ExprKind::Struct(ref mut elem) => {\n+            ExprKind::Struct(elem) => {\n                 for field in &mut elem.fields {\n                     self.manage_cond_expr(&mut field.expr);\n                 }\n-                if let StructRest::Base(ref mut local_expr) = elem.rest {\n+                if let StructRest::Base(local_expr) = &mut elem.rest {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Tup(ref mut local_exprs) => {\n+            ExprKind::Tup(local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Unary(un_op, ref mut local_expr) => {\n+            ExprKind::Unary(un_op, local_expr) => {\n                 self.with_is_consumed_management(\n                     matches!(un_op, UnOp::Neg | UnOp::Not),\n                     |this| this.manage_cond_expr(local_expr)"}, {"sha": "e2d71825d556f69ca9bbc4277848b4aaf89047ad", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -20,7 +20,7 @@ pub fn expand_concat(\n     for e in es {\n         match e.kind {\n             ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n-                Ok(ast::LitKind::Str(ref s, _) | ast::LitKind::Float(ref s, _)) => {\n+                Ok(ast::LitKind::Str(s, _) | ast::LitKind::Float(s, _)) => {\n                     accumulator.push_str(s.as_str());\n                 }\n                 Ok(ast::LitKind::Char(c)) => {"}, {"sha": "d1124145dcbbb663febddf26081de93812aa39d5", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -144,8 +144,8 @@ pub fn expand_concat_bytes(\n     let mut missing_literals = vec![];\n     let mut has_errors = false;\n     for e in es {\n-        match e.kind {\n-            ast::ExprKind::Array(ref exprs) => {\n+        match &e.kind {\n+            ast::ExprKind::Array(exprs) => {\n                 for expr in exprs {\n                     if let Some(elem) =\n                         handle_array_element(cx, &mut has_errors, &mut missing_literals, expr)\n@@ -154,7 +154,7 @@ pub fn expand_concat_bytes(\n                     }\n                 }\n             }\n-            ast::ExprKind::Repeat(ref expr, ref count) => {\n+            ast::ExprKind::Repeat(expr, count) => {\n                 if let ast::ExprKind::Lit(token_lit) = count.value.kind\n                 && let Ok(ast::LitKind::Int(count_val, _)) =\n                     ast::LitKind::from_token_lit(token_lit)\n@@ -170,7 +170,7 @@ pub fn expand_concat_bytes(\n                     cx.span_err(count.value.span, \"repeat count is not a positive number\");\n                 }\n             }\n-            ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n+            &ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n                 Ok(ast::LitKind::Byte(val)) => {\n                     accumulator.push(val);\n                 }\n@@ -184,7 +184,7 @@ pub fn expand_concat_bytes(\n                     has_errors = true;\n                 }\n             },\n-            ast::ExprKind::IncludedBytes(ref bytes) => {\n+            ast::ExprKind::IncludedBytes(bytes) => {\n                 accumulator.extend_from_slice(bytes);\n             }\n             ast::ExprKind::Err => {"}, {"sha": "d59b3b8c86d35ef6303bb8a3adbd5e9aecf2d1f1", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -32,10 +32,10 @@ pub fn expand_deriving_clone(\n     let bounds;\n     let substructure;\n     let is_simple;\n-    match *item {\n-        Annotatable::Item(ref annitem) => match annitem.kind {\n-            ItemKind::Struct(_, Generics { ref params, .. })\n-            | ItemKind::Enum(_, Generics { ref params, .. }) => {\n+    match item {\n+        Annotatable::Item(annitem) => match &annitem.kind {\n+            ItemKind::Struct(_, Generics { params, .. })\n+            | ItemKind::Enum(_, Generics { params, .. }) => {\n                 let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n                 let has_derive_copy = cx.resolver.has_derive_copy(container_id);\n                 if has_derive_copy\n@@ -166,13 +166,13 @@ fn cs_clone(\n     };\n \n     let vdata;\n-    match *substr.fields {\n-        Struct(vdata_, ref af) => {\n+    match substr.fields {\n+        Struct(vdata_, af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident]);\n             all_fields = af;\n-            vdata = vdata_;\n+            vdata = *vdata_;\n         }\n-        EnumMatching(.., variant, ref af) => {\n+        EnumMatching(.., variant, af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.ident]);\n             all_fields = af;\n             vdata = &variant.data;"}, {"sha": "62af02c2bb4b2d35304cf4eafd42036fba31d5ef", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -78,11 +78,11 @@ fn decodable_substructure(\n     let blkarg = Ident::new(sym::_d, trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n-    let expr = match *substr.fields {\n-        StaticStruct(_, ref summary) => {\n-            let nfields = match *summary {\n-                Unnamed(ref fields, _) => fields.len(),\n-                Named(ref fields) => fields.len(),\n+    let expr = match substr.fields {\n+        StaticStruct(_, summary) => {\n+            let nfields = match summary {\n+                Unnamed(fields, _) => fields.len(),\n+                Named(fields) => fields.len(),\n             };\n             let fn_read_struct_field_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_struct_field]);\n@@ -119,7 +119,7 @@ fn decodable_substructure(\n                 ],\n             )\n         }\n-        StaticEnum(_, ref fields) => {\n+        StaticEnum(_, fields) => {\n             let variant = Ident::new(sym::i, trait_span);\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n@@ -194,10 +194,10 @@ fn decode_static_fields<F>(\n where\n     F: FnMut(&mut ExtCtxt<'_>, Span, Symbol, usize) -> P<Expr>,\n {\n-    match *fields {\n-        Unnamed(ref fields, is_tuple) => {\n+    match fields {\n+        Unnamed(fields, is_tuple) => {\n             let path_expr = cx.expr_path(outer_pat_path);\n-            if !is_tuple {\n+            if !*is_tuple {\n                 path_expr\n             } else {\n                 let fields = fields\n@@ -209,7 +209,7 @@ where\n                 cx.expr_call(trait_span, path_expr, fields)\n             }\n         }\n-        Named(ref fields) => {\n+        Named(fields) => {\n             // use the field's span to get nicer error messages.\n             let fields = fields\n                 .iter()"}, {"sha": "eb66c4a69a69bc25bab4126e1649d5f3097a940f", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -62,15 +62,12 @@ fn default_struct_substructure(\n     let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n     let expr = match summary {\n-        Unnamed(ref fields, is_tuple) => {\n-            if !is_tuple {\n-                cx.expr_ident(trait_span, substr.type_ident)\n-            } else {\n-                let exprs = fields.iter().map(|sp| default_call(*sp)).collect();\n-                cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n-            }\n+        Unnamed(_, false) => cx.expr_ident(trait_span, substr.type_ident),\n+        Unnamed(fields, true) => {\n+            let exprs = fields.iter().map(|sp| default_call(*sp)).collect();\n+            cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n         }\n-        Named(ref fields) => {\n+        Named(fields) => {\n             let default_fields = fields\n                 .iter()\n                 .map(|&(ident, span)| cx.field_imm(span, ident, default_call(span)))"}, {"sha": "68bc0ff2ec0b41c553339586a0874ef5fcb6a1f1", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -164,8 +164,8 @@ fn encodable_substructure(\n         ],\n     ));\n \n-    match *substr.fields {\n-        Struct(_, ref fields) => {\n+    match substr.fields {\n+        Struct(_, fields) => {\n             let fn_emit_struct_field_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct_field]);\n             let mut stmts = Vec::new();\n@@ -224,7 +224,7 @@ fn encodable_substructure(\n             BlockOrExpr::new_expr(expr)\n         }\n \n-        EnumMatching(idx, _, variant, ref fields) => {\n+        EnumMatching(idx, _, variant, fields) => {\n             // We're not generating an AST that the borrow checker is expecting,\n             // so we need to generate a unique local variable to take the\n             // mutable loan out on, otherwise we get conflicts which don't\n@@ -274,7 +274,7 @@ fn encodable_substructure(\n                 vec![\n                     blkencoder,\n                     name,\n-                    cx.expr_usize(trait_span, idx),\n+                    cx.expr_usize(trait_span, *idx),\n                     cx.expr_usize(trait_span, fields.len()),\n                     blk,\n                 ],"}, {"sha": "beac591bfc879065a2c6fd411be0673ba59a3383", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -369,15 +369,14 @@ fn find_type_parameters(\n \n     impl<'a, 'b> visit::Visitor<'a> for Visitor<'a, 'b> {\n         fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-            if let ast::TyKind::Path(_, ref path) = ty.kind {\n-                if let Some(segment) = path.segments.first() {\n-                    if self.ty_param_names.contains(&segment.ident.name) {\n-                        self.type_params.push(TypeParameter {\n-                            bound_generic_params: self.bound_generic_params_stack.clone(),\n-                            ty: P(ty.clone()),\n-                        });\n-                    }\n-                }\n+            if let ast::TyKind::Path(_, path) = &ty.kind\n+                && let Some(segment) = path.segments.first()\n+                && self.ty_param_names.contains(&segment.ident.name)\n+            {\n+                self.type_params.push(TypeParameter {\n+                    bound_generic_params: self.bound_generic_params_stack.clone(),\n+                    ty: P(ty.clone()),\n+                });\n             }\n \n             visit::walk_ty(self, ty)\n@@ -428,8 +427,8 @@ impl<'a> TraitDef<'a> {\n         push: &mut dyn FnMut(Annotatable),\n         from_scratch: bool,\n     ) {\n-        match *item {\n-            Annotatable::Item(ref item) => {\n+        match item {\n+            Annotatable::Item(item) => {\n                 let is_packed = item.attrs.iter().any(|attr| {\n                     for r in attr::find_repr_attrs(&cx.sess, attr) {\n                         if let attr::ReprPacked(_) = r {\n@@ -438,10 +437,10 @@ impl<'a> TraitDef<'a> {\n                     }\n                     false\n                 });\n-                let has_no_type_params = match item.kind {\n-                    ast::ItemKind::Struct(_, ref generics)\n-                    | ast::ItemKind::Enum(_, ref generics)\n-                    | ast::ItemKind::Union(_, ref generics) => !generics\n+                let has_no_type_params = match &item.kind {\n+                    ast::ItemKind::Struct(_, generics)\n+                    | ast::ItemKind::Enum(_, generics)\n+                    | ast::ItemKind::Union(_, generics) => !generics\n                         .params\n                         .iter()\n                         .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. })),\n@@ -451,24 +450,24 @@ impl<'a> TraitDef<'a> {\n                 let copy_fields =\n                     is_packed && has_no_type_params && cx.resolver.has_derive_copy(container_id);\n \n-                let newitem = match item.kind {\n-                    ast::ItemKind::Struct(ref struct_def, ref generics) => self.expand_struct_def(\n+                let newitem = match &item.kind {\n+                    ast::ItemKind::Struct(struct_def, generics) => self.expand_struct_def(\n                         cx,\n                         &struct_def,\n                         item.ident,\n                         generics,\n                         from_scratch,\n                         copy_fields,\n                     ),\n-                    ast::ItemKind::Enum(ref enum_def, ref generics) => {\n+                    ast::ItemKind::Enum(enum_def, generics) => {\n                         // We ignore `is_packed` here, because `repr(packed)`\n                         // enums cause an error later on.\n                         //\n                         // This can only cause further compilation errors\n                         // downstream in blatantly illegal code, so it is fine.\n                         self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n                     }\n-                    ast::ItemKind::Union(ref struct_def, ref generics) => {\n+                    ast::ItemKind::Union(struct_def, generics) => {\n                         if self.supports_unions {\n                             self.expand_struct_def(\n                                 cx,\n@@ -663,12 +662,11 @@ impl<'a> TraitDef<'a> {\n \n                     for field_ty_param in field_ty_params {\n                         // if we have already handled this type, skip it\n-                        if let ast::TyKind::Path(_, ref p) = field_ty_param.ty.kind {\n-                            if p.segments.len() == 1\n-                                && ty_param_names.contains(&p.segments[0].ident.name)\n-                            {\n-                                continue;\n-                            };\n+                        if let ast::TyKind::Path(_, p) = &field_ty_param.ty.kind\n+                            && let [sole_segment] = &*p.segments\n+                            && ty_param_names.contains(&sole_segment.ident.name)\n+                        {\n+                            continue;\n                         }\n                         let mut bounds: Vec<_> = self\n                             .additional_bounds"}, {"sha": "eaa4881906a8e3aed446cec6b99657d64972d02f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -115,7 +115,7 @@ impl Ty {\n         self_ty: Ident,\n         generics: &Generics,\n     ) -> ast::Path {\n-        match *self {\n+        match self {\n             Self_ => {\n                 let params: Vec<_> = generics\n                     .params\n@@ -135,7 +135,7 @@ impl Ty {\n \n                 cx.path_all(span, false, vec![self_ty], params)\n             }\n-            Path(ref p) => p.to_path(cx, span, self_ty, generics),\n+            Path(p) => p.to_path(cx, span, self_ty, generics),\n             Ref(..) => cx.span_bug(span, \"ref in a path in generic `derive`\"),\n             Unit => cx.span_bug(span, \"unit in a path in generic `derive`\"),\n         }\n@@ -180,10 +180,7 @@ impl Bounds {\n         let params = self\n             .bounds\n             .iter()\n-            .map(|t| {\n-                let (name, ref bounds) = *t;\n-                mk_ty_param(cx, span, name, &bounds, self_ty, self_generics)\n-            })\n+            .map(|&(name, ref bounds)| mk_ty_param(cx, span, name, &bounds, self_ty, self_generics))\n             .collect();\n \n         Generics {"}, {"sha": "de657e4e6006dcd8aea6ce578dd2657242a488b2", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -125,12 +125,12 @@ fn inject_impl_of_structural_trait(\n     structural_path: generic::ty::Path,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let Annotatable::Item(ref item) = *item else {\n+    let Annotatable::Item(item) = item else {\n         unreachable!();\n     };\n \n-    let generics = match item.kind {\n-        ItemKind::Struct(_, ref generics) | ItemKind::Enum(_, ref generics) => generics,\n+    let generics = match &item.kind {\n+        ItemKind::Struct(_, generics) | ItemKind::Enum(_, generics) => generics,\n         // Do not inject `impl Structural for Union`. (`PartialEq` does not\n         // support unions, so we will see error downstream.)\n         ItemKind::Union(..) => return,"}, {"sha": "0b4e545f7a3d0360757c9588e97742e7f4e1f0c6", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -53,7 +53,7 @@ pub fn expand_env<'cx>(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n-        Some(ref exprs) if exprs.is_empty() => {\n+        Some(exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::any(sp);\n         }"}, {"sha": "6f7fc3a95ba640e21311aca2d37b403f0f25a2c4", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -13,23 +13,23 @@ pub(crate) mod printf {\n \n     impl<'a> Substitution<'a> {\n         pub fn as_str(&self) -> &str {\n-            match *self {\n-                Substitution::Format(ref fmt) => fmt.span,\n+            match self {\n+                Substitution::Format(fmt) => fmt.span,\n                 Substitution::Escape(_) => \"%%\",\n             }\n         }\n \n         pub fn position(&self) -> Option<InnerSpan> {\n-            match *self {\n-                Substitution::Format(ref fmt) => Some(fmt.position),\n-                Substitution::Escape((start, end)) => Some(InnerSpan::new(start, end)),\n+            match self {\n+                Substitution::Format(fmt) => Some(fmt.position),\n+                &Substitution::Escape((start, end)) => Some(InnerSpan::new(start, end)),\n             }\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n             match self {\n-                Substitution::Format(ref mut fmt) => fmt.position = InnerSpan::new(start, end),\n-                Substitution::Escape(ref mut pos) => *pos = (start, end),\n+                Substitution::Format(fmt) => fmt.position = InnerSpan::new(start, end),\n+                Substitution::Escape(pos) => *pos = (start, end),\n             }\n         }\n \n@@ -38,8 +38,8 @@ pub(crate) mod printf {\n         /// This ignores cases where the substitution does not have an exact equivalent, or where\n         /// the substitution would be unnecessary.\n         pub fn translate(&self) -> Result<String, Option<String>> {\n-            match *self {\n-                Substitution::Format(ref fmt) => fmt.translate(),\n+            match self {\n+                Substitution::Format(fmt) => fmt.translate(),\n                 Substitution::Escape(_) => Err(None),\n             }\n         }\n@@ -635,23 +635,17 @@ pub mod shell {\n         }\n \n         pub fn position(&self) -> Option<InnerSpan> {\n-            match self {\n-                Substitution::Ordinal(_, pos)\n-                | Substitution::Name(_, pos)\n-                | Substitution::Escape(pos) => Some(InnerSpan::new(pos.0, pos.1)),\n-            }\n+            let (Self::Ordinal(_, pos) | Self::Name(_, pos) | Self::Escape(pos)) = self;\n+            Some(InnerSpan::new(pos.0, pos.1))\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n-            match self {\n-                Substitution::Ordinal(_, ref mut pos)\n-                | Substitution::Name(_, ref mut pos)\n-                | Substitution::Escape(ref mut pos) => *pos = (start, end),\n-            }\n+            let (Self::Ordinal(_, pos) | Self::Name(_, pos) | Self::Escape(pos)) = self;\n+            *pos = (start, end);\n         }\n \n         pub fn translate(&self) -> Result<String, Option<String>> {\n-            match *self {\n+            match self {\n                 Substitution::Ordinal(n, _) => Ok(format!(\"{{{}}}\", n)),\n                 Substitution::Name(n, _) => Ok(format!(\"{{{}}}\", n)),\n                 Substitution::Escape(_) => Err(None),"}, {"sha": "41531580c1987ca92c0a2e76c10dc993c1c7e16a", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -20,27 +20,23 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n \n     let orig_item = item.clone();\n-    let not_static = || {\n-        ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n-        vec![orig_item.clone()]\n-    };\n \n     // Allow using `#[global_allocator]` on an item statement\n     // FIXME - if we get deref patterns, use them to reduce duplication here\n-    let (item, is_stmt, ty_span) = match &item {\n-        Annotatable::Item(item) => match item.kind {\n-            ItemKind::Static(ref ty, ..) => (item, false, ecx.with_def_site_ctxt(ty.span)),\n-            _ => return not_static(),\n-        },\n-        Annotatable::Stmt(stmt) => match &stmt.kind {\n-            StmtKind::Item(item_) => match item_.kind {\n-                ItemKind::Static(ref ty, ..) => (item_, true, ecx.with_def_site_ctxt(ty.span)),\n-                _ => return not_static(),\n-            },\n-            _ => return not_static(),\n-        },\n-        _ => return not_static(),\n-    };\n+    let (item, is_stmt, ty_span) =\n+        if let Annotatable::Item(item) = &item\n+            && let ItemKind::Static(ty, ..) = &item.kind\n+        {\n+            (item, false, ecx.with_def_site_ctxt(ty.span))\n+        } else if let Annotatable::Stmt(stmt) = &item\n+            && let StmtKind::Item(item) = &stmt.kind\n+            && let ItemKind::Static(ty, ..) = &item.kind\n+        {\n+            (item, true, ecx.with_def_site_ctxt(ty.span))\n+        } else {\n+            ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n+            return vec![orig_item.clone()]\n+        };\n \n     // Generate a bunch of new items using the AllocFnFactory\n     let span = ecx.with_def_site_ctxt(item.span);"}, {"sha": "f5f02fc772ab6b5b08b1082ab3fdb8ee6ec99f3c", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -466,61 +466,67 @@ fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n     let sd = &cx.sess.parse_sess.span_diagnostic;\n-    if let ast::ItemKind::Fn(box ast::Fn { ref sig, ref generics, .. }) = i.kind {\n-        if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n-            sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n-                .span_label(span, \"`unsafe` because of this\")\n-                .emit();\n-            return false;\n-        }\n-        if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n-            sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n-                .span_label(span, \"`async` because of this\")\n-                .emit();\n-            return false;\n-        }\n-\n-        // If the termination trait is active, the compiler will check that the output\n-        // type implements the `Termination` trait as `libtest` enforces that.\n-        let has_output = match sig.decl.output {\n-            ast::FnRetTy::Default(..) => false,\n-            ast::FnRetTy::Ty(ref t) if t.kind.is_unit() => false,\n-            _ => true,\n-        };\n-\n-        if !sig.decl.inputs.is_empty() {\n-            sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n-            return false;\n-        }\n+    match &i.kind {\n+        ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {\n+            if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n+                sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n+                    .span_label(span, \"`unsafe` because of this\")\n+                    .emit();\n+                return false;\n+            }\n+            if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n+                sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n+                    .span_label(span, \"`async` because of this\")\n+                    .emit();\n+                return false;\n+            }\n \n-        match (has_output, has_should_panic_attr) {\n-            (true, true) => {\n-                sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n-                false\n+            // If the termination trait is active, the compiler will check that the output\n+            // type implements the `Termination` trait as `libtest` enforces that.\n+            let has_output = match &sig.decl.output {\n+                ast::FnRetTy::Default(..) => false,\n+                ast::FnRetTy::Ty(t) if t.kind.is_unit() => false,\n+                _ => true,\n+            };\n+\n+            if !sig.decl.inputs.is_empty() {\n+                sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n+                return false;\n             }\n-            (true, false) => {\n-                if !generics.params.is_empty() {\n-                    sd.span_err(i.span, \"functions used as tests must have signature fn() -> ()\");\n+\n+            match (has_output, has_should_panic_attr) {\n+                (true, true) => {\n+                    sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n                     false\n-                } else {\n-                    true\n                 }\n+                (true, false) => {\n+                    if !generics.params.is_empty() {\n+                        sd.span_err(\n+                            i.span,\n+                            \"functions used as tests must have signature fn() -> ()\",\n+                        );\n+                        false\n+                    } else {\n+                        true\n+                    }\n+                }\n+                (false, _) => true,\n             }\n-            (false, _) => true,\n         }\n-    } else {\n-        // should be unreachable because `is_test_fn_item` should catch all non-fn items\n-        false\n+        _ => {\n+            // should be unreachable because `is_test_fn_item` should catch all non-fn items\n+            debug_assert!(false);\n+            false\n+        }\n     }\n }\n \n fn has_bench_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_sig = if let ast::ItemKind::Fn(box ast::Fn { ref sig, .. }) = i.kind {\n+    let has_sig = match &i.kind {\n         // N.B., inadequate check, but we're running\n         // well before resolve, can't get too deep.\n-        sig.decl.inputs.len() == 1\n-    } else {\n-        false\n+        ast::ItemKind::Fn(box ast::Fn { sig, .. }) => sig.decl.inputs.len() == 1,\n+        _ => false,\n     };\n \n     if !has_sig {"}, {"sha": "ad8871080910640e11e123b8f27221101f2a543d", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -131,8 +131,9 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(_, ModKind::Loaded(.., ref spans)) = item.kind {\n-            let ast::ModSpans { inner_span: span, inject_use_span: _ } = *spans;\n+        if let ast::ItemKind::Mod(_, ModKind::Loaded(.., ast::ModSpans { inner_span: span, .. })) =\n+            item.kind\n+        {\n             let prev_tests = mem::take(&mut self.tests);\n             noop_visit_item_kind(&mut item.kind, self);\n             self.add_test_cases(item.id, span, prev_tests);"}, {"sha": "540f15c89e928f8724df8943e370647330b1c9cf", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -2352,15 +2352,6 @@ fn add_native_libs_from_crate(\n                                 &search_paths.get_or_init(|| archive_search_paths(sess)),\n                             );\n                         } else {\n-                            // HACK/FIXME: Fixup a circular dependency between libgcc and libc\n-                            // with glibc. This logic should be moved to the libc crate.\n-                            if cnum != LOCAL_CRATE\n-                                && sess.target.os == \"linux\"\n-                                && sess.target.env == \"gnu\"\n-                                && name == \"c\"\n-                            {\n-                                cmd.link_staticlib(\"gcc\", false);\n-                            }\n                             cmd.link_staticlib(name, verbatim)\n                         }\n                     }"}, {"sha": "ed87b94a040d0f87b4d665898481ea2efa3c10d9", "filename": "compiler/rustc_hir_typeck/src/expr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -1647,6 +1647,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // the fields with the base_expr. This could cause us to hit errors later\n         // when certain fields are assumed to exist that in fact do not.\n         if error_happened {\n+            if let Some(base_expr) = base_expr {\n+                self.check_expr(base_expr);\n+            }\n             return;\n         }\n "}, {"sha": "03b174c77955fb400eab47aa6071b3cec6bef94a", "filename": "compiler/rustc_hir_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -523,6 +523,11 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         // Consume the expressions supplying values for each field.\n         for field in fields {\n             self.consume_expr(field.expr);\n+\n+            // The struct path probably didn't resolve\n+            if self.mc.typeck_results.opt_field_index(field.hir_id).is_none() {\n+                self.tcx().sess.delay_span_bug(field.span, \"couldn't resolve index for field\");\n+            }\n         }\n \n         let with_expr = match *opt_with {\n@@ -540,9 +545,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             ty::Adt(adt, substs) if adt.is_struct() => {\n                 // Consume those fields of the with expression that are needed.\n                 for (f_index, with_field) in adt.non_enum_variant().fields.iter().enumerate() {\n-                    let is_mentioned = fields.iter().any(|f| {\n-                        self.tcx().field_index(f.hir_id, self.mc.typeck_results) == f_index\n-                    });\n+                    let is_mentioned = fields\n+                        .iter()\n+                        .any(|f| self.mc.typeck_results.opt_field_index(f.hir_id) == Some(f_index));\n                     if !is_mentioned {\n                         let field_place = self.mc.cat_projection(\n                             &*with_expr,"}, {"sha": "d0d34d8d2b40ee23be061701dc4bf7926d070f32", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -259,7 +259,7 @@ impl<'tcx> LateLintPass<'tcx> for NonShorthandFieldPatterns {\n                 }\n                 if let PatKind::Binding(binding_annot, _, ident, None) = fieldpat.pat.kind {\n                     if cx.tcx.find_field_index(ident, &variant)\n-                        == Some(cx.tcx.field_index(fieldpat.hir_id, cx.typeck_results()))\n+                        == Some(cx.typeck_results().field_index(fieldpat.hir_id))\n                     {\n                         cx.struct_span_lint(\n                             NON_SHORTHAND_FIELD_PATTERNS,"}, {"sha": "af573376a26bc433a88b067a83989f7fc115d939", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -667,6 +667,14 @@ impl<'tcx> TypeckResults<'tcx> {\n         LocalTableInContextMut { hir_owner: self.hir_owner, data: &mut self.field_indices }\n     }\n \n+    pub fn field_index(&self, id: hir::HirId) -> usize {\n+        self.field_indices().get(id).cloned().expect(\"no index for a field\")\n+    }\n+\n+    pub fn opt_field_index(&self, id: hir::HirId) -> Option<usize> {\n+        self.field_indices().get(id).cloned()\n+    }\n+\n     pub fn user_provided_types(&self) -> LocalTableInContext<'_, CanonicalUserType<'tcx>> {\n         LocalTableInContext { hir_owner: self.hir_owner, data: &self.user_provided_types }\n     }"}, {"sha": "c062e508ee3df26ed93a1fd7b48aa34f6625b126", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -2142,10 +2142,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn field_index(self, hir_id: hir::HirId, typeck_results: &TypeckResults<'_>) -> usize {\n-        typeck_results.field_indices().get(hir_id).cloned().expect(\"no index for a field\")\n-    }\n-\n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n         variant\n             .fields"}, {"sha": "261b95ba95b0e36781448e9fdc7be376773f99cb", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -704,7 +704,7 @@ impl<'tcx> Cx<'tcx> {\n             hir::ExprKind::Field(ref source, ..) => ExprKind::Field {\n                 lhs: self.mirror_expr(source),\n                 variant_index: VariantIdx::new(0),\n-                name: Field::new(tcx.field_index(expr.hir_id, self.typeck_results)),\n+                name: Field::new(self.typeck_results.field_index(expr.hir_id)),\n             },\n             hir::ExprKind::Cast(ref source, ref cast_ty) => {\n                 // Check for a user-given type annotation on this `cast`\n@@ -1079,7 +1079,7 @@ impl<'tcx> Cx<'tcx> {\n         fields\n             .iter()\n             .map(|field| FieldExpr {\n-                name: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n+                name: Field::new(self.typeck_results.field_index(field.hir_id)),\n                 expr: self.mirror_expr(field.expr),\n             })\n             .collect()"}, {"sha": "48a231a6cd6b7c4648396131e1743e0a71065b04", "filename": "compiler/rustc_mir_build/src/thir/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fmod.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -321,7 +321,7 @@ impl<'a, 'tcx> PatCtxt<'a, 'tcx> {\n                 let subpatterns = fields\n                     .iter()\n                     .map(|field| FieldPat {\n-                        field: Field::new(self.tcx.field_index(field.hir_id, self.typeck_results)),\n+                        field: Field::new(self.typeck_results.field_index(field.hir_id)),\n                         pattern: self.lower_pattern(&field.pat),\n                     })\n                     .collect();"}, {"sha": "a71ae717a508d37ee42db75d1a5add8a994fac0b", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -124,7 +124,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     fn handle_field_access(&mut self, lhs: &hir::Expr<'_>, hir_id: hir::HirId) {\n         match self.typeck_results().expr_ty_adjusted(lhs).kind() {\n             ty::Adt(def, _) => {\n-                let index = self.tcx.field_index(hir_id, self.typeck_results());\n+                let index = self.typeck_results().field_index(hir_id);\n                 self.insert_def_id(def.non_enum_variant().fields[index].did);\n             }\n             ty::Tuple(..) => {}\n@@ -208,7 +208,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n             if let PatKind::Wild = pat.pat.kind {\n                 continue;\n             }\n-            let index = self.tcx.field_index(pat.hir_id, self.typeck_results());\n+            let index = self.typeck_results().field_index(pat.hir_id);\n             self.insert_def_id(variant.fields[index].did);\n         }\n     }\n@@ -341,7 +341,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n     fn mark_as_used_if_union(&mut self, adt: ty::AdtDef<'tcx>, fields: &[hir::ExprField<'_>]) {\n         if adt.is_union() && adt.non_enum_variant().fields.len() > 1 && adt.did().is_local() {\n             for field in fields {\n-                let index = self.tcx.field_index(field.hir_id, self.typeck_results());\n+                let index = self.typeck_results().field_index(field.hir_id);\n                 self.insert_def_id(adt.non_enum_variant().fields[index].did);\n             }\n         }"}, {"sha": "a254c892478cf19815f2ccf79e670f3db96f08dd", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -1065,9 +1065,9 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n                 // are checked for privacy (RFC 736). Rather than computing the set of\n                 // unmentioned fields, just check them all.\n                 for (vf_index, variant_field) in variant.fields.iter().enumerate() {\n-                    let field = fields.iter().find(|f| {\n-                        self.tcx.field_index(f.hir_id, self.typeck_results()) == vf_index\n-                    });\n+                    let field = fields\n+                        .iter()\n+                        .find(|f| self.typeck_results().field_index(f.hir_id) == vf_index);\n                     let (use_ctxt, span) = match field {\n                         Some(field) => (field.ident.span, field.span),\n                         None => (base.span, base.span),\n@@ -1077,7 +1077,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n             } else {\n                 for field in fields {\n                     let use_ctxt = field.ident.span;\n-                    let index = self.tcx.field_index(field.hir_id, self.typeck_results());\n+                    let index = self.typeck_results().field_index(field.hir_id);\n                     self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n                 }\n             }\n@@ -1093,7 +1093,7 @@ impl<'tcx> Visitor<'tcx> for NamePrivacyVisitor<'tcx> {\n             let variant = adt.variant_of_res(res);\n             for field in fields {\n                 let use_ctxt = field.ident.span;\n-                let index = self.tcx.field_index(field.hir_id, self.typeck_results());\n+                let index = self.typeck_results().field_index(field.hir_id);\n                 self.check_field(use_ctxt, field.span, adt, &variant.fields[index], false);\n             }\n         }"}, {"sha": "7c9fde27420bc2b12ba79a6d08083b507dc2b8ec", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -30,7 +30,7 @@ pub fn is_const_evaluatable<'tcx>(\n     span: Span,\n ) -> Result<(), NotConstEvaluatable> {\n     let tcx = infcx.tcx;\n-    match unexpanded_ct.kind() {\n+    match tcx.expand_abstract_consts(unexpanded_ct).kind() {\n         ty::ConstKind::Unevaluated(_) | ty::ConstKind::Expr(_) => (),\n         ty::ConstKind::Param(_)\n         | ty::ConstKind::Bound(_, _)"}, {"sha": "111361796075b863cf22b061d09e015cf51705ca", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -212,8 +212,7 @@ pre.rust a,\n .mobile-topbar h2 a,\n h1 a,\n .search-results a,\n-.module-item .stab,\n-.import-item .stab,\n+.item-left .stab,\n .result-name .primitive > i, .result-name .keyword > i {\n \tcolor: var(--main-color);\n }\n@@ -1010,8 +1009,7 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \t\t0 -1px 0 black;\n }\n \n-.module-item .stab,\n-.import-item .stab {\n+.item-left .stab {\n \tborder-radius: 3px;\n \tdisplay: inline-block;\n \tline-height: 1.2;"}, {"sha": "28ad7767583cfbd3d994c37179783ad51d8326d6", "filename": "src/test/ui/async-await/drop-track-bad-field-in-fru.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -0,0 +1,10 @@\n+// compile-flags: -Zdrop-tracking\n+// edition: 2021\n+\n+fn main() {}\n+\n+async fn foo() {\n+    None { value: (), ..Default::default() }.await;\n+    //~^ ERROR `Option<_>` is not a future\n+    //~| ERROR variant `Option<_>::None` has no field named `value`\n+}"}, {"sha": "819b64ad77f5dd1b1f06a51ae52fa02ba38b0aab", "filename": "src/test/ui/async-await/drop-track-bad-field-in-fru.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fdrop-track-bad-field-in-fru.stderr?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -0,0 +1,23 @@\n+error[E0559]: variant `Option<_>::None` has no field named `value`\n+  --> $DIR/drop-track-bad-field-in-fru.rs:7:12\n+   |\n+LL |     None { value: (), ..Default::default() }.await;\n+   |            ^^^^^ `Option<_>::None` does not have this field\n+\n+error[E0277]: `Option<_>` is not a future\n+  --> $DIR/drop-track-bad-field-in-fru.rs:7:45\n+   |\n+LL |     None { value: (), ..Default::default() }.await;\n+   |                                             ^^^^^^\n+   |                                             |\n+   |                                             `Option<_>` is not a future\n+   |                                             help: remove the `.await`\n+   |\n+   = help: the trait `Future` is not implemented for `Option<_>`\n+   = note: Option<_> must be a future or must implement `IntoFuture` to be awaited\n+   = note: required for `Option<_>` to implement `IntoFuture`\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0277, E0559.\n+For more information about an error, try `rustc --explain E0277`."}, {"sha": "b37b354ae2146eeea732e6c57c6efd292bd8a0fa", "filename": "src/test/ui/const-generics/generic_const_exprs/normed_to_param_is_evaluatable.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fnormed_to_param_is_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fnormed_to_param_is_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fnormed_to_param_is_evaluatable.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -0,0 +1,12 @@\n+// check-pass\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features, unused_braces)]\n+\n+#[rustfmt::skip]\n+fn foo<const N: usize>() {\n+    bar::<{{{{{{ N }}}}}}>();\n+}\n+\n+fn bar<const N: usize>() {}\n+\n+fn main() {}"}, {"sha": "c9fdca4577279d244effc4bff1dad0b11a90f36a", "filename": "src/test/ui/structs/unresolved-struct-with-fru.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Ftest%2Fui%2Fstructs%2Funresolved-struct-with-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Ftest%2Fui%2Fstructs%2Funresolved-struct-with-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Funresolved-struct-with-fru.rs?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -0,0 +1,12 @@\n+struct S {\n+    a: u32,\n+}\n+\n+fn main() {\n+    let s1 = S { a: 1 };\n+\n+    let _ = || {\n+        let s2 = Oops { a: 2, ..s1 };\n+        //~^ ERROR cannot find struct, variant or union type `Oops` in this scope\n+    };\n+}"}, {"sha": "a5796a222256d89dfacdf425574d8ee11390d9e0", "filename": "src/test/ui/structs/unresolved-struct-with-fru.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Ftest%2Fui%2Fstructs%2Funresolved-struct-with-fru.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f5418b09e84883c4de2e652a147ab9faff4eee29/src%2Ftest%2Fui%2Fstructs%2Funresolved-struct-with-fru.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Funresolved-struct-with-fru.stderr?ref=f5418b09e84883c4de2e652a147ab9faff4eee29", "patch": "@@ -0,0 +1,9 @@\n+error[E0422]: cannot find struct, variant or union type `Oops` in this scope\n+  --> $DIR/unresolved-struct-with-fru.rs:9:18\n+   |\n+LL |         let s2 = Oops { a: 2, ..s1 };\n+   |                  ^^^^ not found in this scope\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0422`."}]}