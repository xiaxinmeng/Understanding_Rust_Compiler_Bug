{"sha": "957500b79348a89b2148a6d20f7de6c10af4eea2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NzUwMGI3OTM0OGE4OWIyMTQ4YTZkMjBmN2RlNmMxMGFmNGVlYTI=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-05-05T09:31:45Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-05-14T04:23:02Z"}, "message": "rewrite obligation forest. cycles still handled incorrectly.", "tree": {"sha": "d2931d603fde72241a9a2c477d437a0da016ce1a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2931d603fde72241a9a2c477d437a0da016ce1a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/957500b79348a89b2148a6d20f7de6c10af4eea2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/957500b79348a89b2148a6d20f7de6c10af4eea2", "html_url": "https://github.com/rust-lang/rust/commit/957500b79348a89b2148a6d20f7de6c10af4eea2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/957500b79348a89b2148a6d20f7de6c10af4eea2/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dee865a56db3833e74801b71acf26264817c1637", "url": "https://api.github.com/repos/rust-lang/rust/commits/dee865a56db3833e74801b71acf26264817c1637", "html_url": "https://github.com/rust-lang/rust/commit/dee865a56db3833e74801b71acf26264817c1637"}], "stats": {"total": 1365, "additions": 617, "deletions": 748}, "files": [{"sha": "43c956409bb1a31d8acf00aecd28185d65a97685", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 103, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -511,115 +511,14 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// that we can give a more helpful error message (and, in particular,\n     /// we do not suggest increasing the overflow limit, which is not\n     /// going to help).\n-    pub fn report_overflow_error_cycle(&self, cycle: &Vec<PredicateObligation<'tcx>>) -> ! {\n-        assert!(cycle.len() > 1);\n-\n-        debug!(\"report_overflow_error_cycle(cycle length = {})\", cycle.len());\n-\n-        let cycle = self.resolve_type_vars_if_possible(cycle);\n+    pub fn report_overflow_error_cycle(&self, cycle: &[PredicateObligation<'tcx>]) -> ! {\n+        let cycle = self.resolve_type_vars_if_possible(&cycle.to_owned());\n \n         debug!(\"report_overflow_error_cycle: cycle={:?}\", cycle);\n \n-        assert_eq!(&cycle[0].predicate, &cycle.last().unwrap().predicate);\n-\n-        self.try_report_overflow_error_type_of_infinite_size(&cycle);\n         self.report_overflow_error(&cycle[0], false);\n     }\n \n-    /// If a cycle results from evaluated whether something is Sized, that\n-    /// is a particular special case that always results from a struct or\n-    /// enum definition that lacks indirection (e.g., `struct Foo { x: Foo\n-    /// }`). We wish to report a targeted error for this case.\n-    pub fn try_report_overflow_error_type_of_infinite_size(&self,\n-        cycle: &[PredicateObligation<'tcx>])\n-    {\n-        let sized_trait = match self.tcx.lang_items.sized_trait() {\n-            Some(v) => v,\n-            None => return,\n-        };\n-        let top_is_sized = {\n-            match cycle[0].predicate {\n-                ty::Predicate::Trait(ref data) => data.def_id() == sized_trait,\n-                _ => false,\n-            }\n-        };\n-        if !top_is_sized {\n-            return;\n-        }\n-\n-        // The only way to have a type of infinite size is to have,\n-        // somewhere, a struct/enum type involved. Identify all such types\n-        // and report the cycle to the user.\n-\n-        let struct_enum_tys: Vec<_> =\n-            cycle.iter()\n-                 .flat_map(|obligation| match obligation.predicate {\n-                     ty::Predicate::Trait(ref data) => {\n-                         assert_eq!(data.def_id(), sized_trait);\n-                         let self_ty = data.skip_binder().trait_ref.self_ty(); // (*)\n-                         // (*) ok to skip binder because this is just\n-                         // error reporting and regions don't really\n-                         // matter\n-                         match self_ty.sty {\n-                             ty::TyEnum(..) | ty::TyStruct(..) => Some(self_ty),\n-                             _ => None,\n-                         }\n-                     }\n-                     _ => {\n-                         span_bug!(obligation.cause.span,\n-                                   \"Sized cycle involving non-trait-ref: {:?}\",\n-                                   obligation.predicate);\n-                     }\n-                 })\n-                 .collect();\n-\n-        assert!(!struct_enum_tys.is_empty());\n-\n-        // This is a bit tricky. We want to pick a \"main type\" in the\n-        // listing that is local to the current crate, so we can give a\n-        // good span to the user. But it might not be the first one in our\n-        // cycle list. So find the first one that is local and then\n-        // rotate.\n-        let (main_index, main_def_id) =\n-            struct_enum_tys.iter()\n-                           .enumerate()\n-                           .filter_map(|(index, ty)| match ty.sty {\n-                               ty::TyEnum(adt_def, _) | ty::TyStruct(adt_def, _)\n-                                   if adt_def.did.is_local() =>\n-                                   Some((index, adt_def.did)),\n-                               _ =>\n-                                   None,\n-                           })\n-                           .next()\n-                           .unwrap(); // should always be SOME local type involved!\n-\n-        // Rotate so that the \"main\" type is at index 0.\n-        let struct_enum_tys: Vec<_> =\n-            struct_enum_tys.iter()\n-                           .cloned()\n-                           .skip(main_index)\n-                           .chain(struct_enum_tys.iter().cloned().take(main_index))\n-                           .collect();\n-\n-        let tcx = self.tcx;\n-        let mut err = tcx.recursive_type_with_infinite_size_error(main_def_id);\n-        let len = struct_enum_tys.len();\n-        if len > 2 {\n-            err.note(&format!(\"type `{}` is embedded within `{}`...\",\n-                     struct_enum_tys[0],\n-                     struct_enum_tys[1]));\n-            for &next_ty in &struct_enum_tys[1..len-1] {\n-                err.note(&format!(\"...which in turn is embedded within `{}`...\", next_ty));\n-            }\n-            err.note(&format!(\"...which in turn is embedded within `{}`, \\\n-                               completing the cycle.\",\n-                              struct_enum_tys[len-1]));\n-        }\n-        err.emit();\n-        self.tcx.sess.abort_if_errors();\n-        bug!();\n-    }\n-\n     pub fn report_selection_error(&self,\n                                   obligation: &PredicateObligation<'tcx>,\n                                   error: &SelectionError<'tcx>,"}, {"sha": "de0489caaeb92fc94321257ed89bfe0597967981", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 51, "deletions": 264, "changes": 315, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -10,13 +10,13 @@\n \n use dep_graph::DepGraph;\n use infer::{InferCtxt, InferOk};\n-use ty::{self, Ty, TyCtxt, TypeFoldable, ToPolyTraitRef};\n-use rustc_data_structures::obligation_forest::{Backtrace, ObligationForest, Error};\n-use std::iter;\n+use ty::{self, Ty, TypeFoldable, ToPolyTraitRef, TyCtxt};\n+use rustc_data_structures::obligation_forest::{ObligationForest, Error};\n+use rustc_data_structures::obligation_forest::{ForestObligation, ObligationProcessor};\n use std::mem;\n use syntax::ast;\n use util::common::ErrorReported;\n-use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n+use util::nodemap::{FnvHashSet, NodeMap};\n \n use super::CodeAmbiguity;\n use super::CodeProjectionError;\n@@ -29,16 +29,17 @@ use super::project;\n use super::select::SelectionContext;\n use super::Unimplemented;\n \n+impl<'tcx> ForestObligation for PendingPredicateObligation<'tcx> {\n+    type Predicate = ty::Predicate<'tcx>;\n+\n+    fn as_predicate(&self) -> &Self::Predicate { &self.obligation.predicate }\n+}\n+\n pub struct GlobalFulfilledPredicates<'tcx> {\n     set: FnvHashSet<ty::PolyTraitPredicate<'tcx>>,\n     dep_graph: DepGraph,\n }\n \n-#[derive(Debug)]\n-pub struct LocalFulfilledPredicates<'tcx> {\n-    set: FnvHashSet<ty::Predicate<'tcx>>\n-}\n-\n /// The fulfillment context is used to drive trait resolution.  It\n /// consists of a list of obligations that must be (eventually)\n /// satisfied. The job is to track which are satisfied, which yielded\n@@ -50,23 +51,9 @@ pub struct LocalFulfilledPredicates<'tcx> {\n /// method `select_all_or_error` can be used to report any remaining\n /// ambiguous cases as errors.\n pub struct FulfillmentContext<'tcx> {\n-    // a simple cache that aims to cache *exact duplicate obligations*\n-    // and avoid adding them twice. This serves a different purpose\n-    // than the `SelectionCache`: it avoids duplicate errors and\n-    // permits recursive obligations, which are often generated from\n-    // traits like `Send` et al.\n-    //\n-    // Note that because of type inference, a predicate can still\n-    // occur twice in the predicates list, for example when 2\n-    // initially-distinct type variables are unified after being\n-    // inserted. Deduplicating the predicate set on selection had a\n-    // significant performance cost the last time I checked.\n-    duplicate_set: LocalFulfilledPredicates<'tcx>,\n-\n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    predicates: ObligationForest<PendingPredicateObligation<'tcx>,\n-                                 LocalFulfilledPredicates<'tcx>>,\n+    predicates: ObligationForest<PendingPredicateObligation<'tcx>>,\n \n     // A list of new obligations due to RFC1592.\n     rfc1592_obligations: Vec<PredicateObligation<'tcx>>,\n@@ -115,7 +102,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n-            duplicate_set: LocalFulfilledPredicates::new(),\n             predicates: ObligationForest::new(),\n             rfc1592_obligations: Vec::new(),\n             region_obligations: NodeMap(),\n@@ -184,19 +170,15 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         // debug output much nicer to read and so on.\n         let obligation = infcx.resolve_type_vars_if_possible(&obligation);\n \n-        assert!(!obligation.has_escaping_regions());\n-\n-        if self.is_duplicate_or_add(infcx.tcx, &obligation.predicate) {\n-            debug!(\"register_predicate_obligation({:?}) -- already seen, skip\", obligation);\n-            return;\n+        if infcx.tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate)\n+        {\n+            return\n         }\n \n-        debug!(\"register_predicate_obligation({:?})\", obligation);\n-        let obligation = PendingPredicateObligation {\n+        self.predicates.register_obligation(PendingPredicateObligation {\n             obligation: obligation,\n             stalled_on: vec![]\n-        };\n-        self.predicates.push_tree(obligation, LocalFulfilledPredicates::new());\n+        });\n     }\n \n     pub fn register_rfc1592_obligation(&mut self,\n@@ -261,32 +243,6 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n         self.predicates.pending_obligations()\n     }\n \n-    fn is_duplicate_or_add(&mut self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                           predicate: &ty::Predicate<'tcx>)\n-                           -> bool {\n-        // For \"global\" predicates -- that is, predicates that don't\n-        // involve type parameters, inference variables, or regions\n-        // other than 'static -- we can check the cache in the tcx,\n-        // which allows us to leverage work from other threads. Note\n-        // that we don't add anything to this cache yet (unlike the\n-        // local cache).  This is because the tcx cache maintains the\n-        // invariant that it only contains things that have been\n-        // proven, and we have not yet proven that `predicate` holds.\n-        if tcx.fulfilled_predicates.borrow().check_duplicate(predicate) {\n-            return true;\n-        }\n-\n-        // If `predicate` is not global, or not present in the tcx\n-        // cache, we can still check for it in our local cache and add\n-        // it if not present. Note that if we find this predicate in\n-        // the local cache we can stop immediately, without reporting\n-        // any errors, even though we don't know yet if it is\n-        // true. This is because, while we don't yet know if the\n-        // predicate holds, we know that this same fulfillment context\n-        // already is in the process of finding out.\n-        self.duplicate_set.is_duplicate_or_add(predicate)\n-    }\n-\n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it\n     /// only attempts to select obligations that haven't been seen before.\n     fn select(&mut self, selcx: &mut SelectionContext<'a, 'gcx, 'tcx>)\n@@ -299,18 +255,11 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n             debug!(\"select: starting another iteration\");\n \n             // Process pending obligations.\n-            let outcome = {\n-                let region_obligations = &mut self.region_obligations;\n-                let rfc1592_obligations = &mut self.rfc1592_obligations;\n-                self.predicates.process_obligations(\n-                    |obligation, tree, backtrace| process_predicate(selcx,\n-                                                                    tree,\n-                                                                    obligation,\n-                                                                    backtrace,\n-                                                                    region_obligations,\n-                                                                    rfc1592_obligations))\n-            };\n-\n+            let outcome = self.predicates.process_obligations(&mut FulfillProcessor {\n+                    selcx: selcx,\n+                    region_obligations: &mut self.region_obligations,\n+                    rfc1592_obligations: &mut self.rfc1592_obligations\n+            });\n             debug!(\"select: outcome={:?}\", outcome);\n \n             // these are obligations that were proven to be true.\n@@ -341,177 +290,38 @@ impl<'a, 'gcx, 'tcx> FulfillmentContext<'tcx> {\n     }\n }\n \n-/// Like `process_predicate1`, but wrap result into a pending predicate.\n-fn process_predicate<'a, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-    tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n-    pending_obligation: &mut PendingPredicateObligation<'tcx>,\n-    backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n-    region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n-    rfc1592_obligations: &mut Vec<PredicateObligation<'tcx>>)\n-    -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n-              FulfillmentErrorCode<'tcx>>\n-{\n-    match process_predicate1(selcx, pending_obligation, region_obligations,\n-                             rfc1592_obligations) {\n-        Ok(Some(v)) => process_child_obligations(selcx,\n-                                                 tree_cache,\n-                                                 &pending_obligation.obligation,\n-                                                 backtrace,\n-                                                 v),\n-        Ok(None) => Ok(None),\n-        Err(e) => Err(e)\n-    }\n+struct FulfillProcessor<'a, 'b: 'a, 'gcx: 'tcx, 'tcx: 'b> {\n+    selcx: &'a mut SelectionContext<'b, 'gcx, 'tcx>,\n+    region_obligations: &'a mut NodeMap<Vec<RegionObligation<'tcx>>>,\n+    rfc1592_obligations: &'a mut Vec<PredicateObligation<'tcx>>\n }\n \n-fn process_child_obligations<'a, 'gcx, 'tcx>(\n-    selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-    tree_cache: &mut LocalFulfilledPredicates<'tcx>,\n-    pending_obligation: &PredicateObligation<'tcx>,\n-    backtrace: Backtrace<PendingPredicateObligation<'tcx>>,\n-    child_obligations: Vec<PredicateObligation<'tcx>>)\n-    -> Result<Option<Vec<PendingPredicateObligation<'tcx>>>,\n-              FulfillmentErrorCode<'tcx>>\n-{\n-    // FIXME(#30977) The code below is designed to detect (and\n-    // permit) DAGs, while still ensuring that the reasoning\n-    // is acyclic. However, it does a few things\n-    // suboptimally. For example, it refreshes type variables\n-    // a lot, probably more than needed, but also less than\n-    // you might want.\n-    //\n-    //   - more than needed: I want to be very sure we don't\n-    //     accidentally treat a cycle as a DAG, so I am\n-    //     refreshing type variables as we walk the ancestors;\n-    //     but we are going to repeat this a lot, which is\n-    //     sort of silly, and it would be nicer to refresh\n-    //     them *in place* so that later predicate processing\n-    //     can benefit from the same work;\n-    //   - less than you might want: we only add items in the cache here,\n-    //     but maybe we learn more about type variables and could add them into\n-    //     the cache later on.\n-\n-    let tcx = selcx.tcx();\n-\n-    let mut ancestor_set = AncestorSet::new(&backtrace);\n-\n-    let pending_predicate_obligations: Vec<_> =\n-        child_obligations\n-        .into_iter()\n-        .filter_map(|obligation| {\n-            // Probably silly, but remove any inference\n-            // variables. This is actually crucial to the ancestor\n-            // check marked (*) below, but it's not clear that it\n-            // makes sense to ALWAYS do it.\n-            let obligation = selcx.infcx().resolve_type_vars_if_possible(&obligation);\n-\n-            // Screen out obligations that we know globally\n-            // are true.\n-            if tcx.fulfilled_predicates.borrow().check_duplicate(&obligation.predicate) {\n-                return None;\n-            }\n+impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx, 'tcx> {\n+    type Obligation = PendingPredicateObligation<'tcx>;\n+    type Error = FulfillmentErrorCode<'tcx>;\n \n-            // Check whether this obligation appears\n-            // somewhere else in the tree. If not, we have to\n-            // process it for sure.\n-            if !tree_cache.is_duplicate_or_add(&obligation.predicate) {\n-                return Some(PendingPredicateObligation {\n-                    obligation: obligation,\n-                    stalled_on: vec![]\n-                });\n-            }\n-\n-            debug!(\"process_child_obligations: duplicate={:?}\",\n-                   obligation.predicate);\n-\n-            // OK, the obligation appears elsewhere in the tree.\n-            // This is either a fatal error or else something we can\n-            // ignore. If the obligation appears in our *ancestors*\n-            // (rather than some more distant relative), that\n-            // indicates a cycle. Cycles are either considered\n-            // resolved (if this is a coinductive case) or a fatal\n-            // error.\n-            if let Some(index) = ancestor_set.has(selcx.infcx(), &obligation.predicate) {\n-                //                            ~~~ (*) see above\n-                debug!(\"process_child_obligations: cycle index = {}\", index);\n-\n-                let backtrace = backtrace.clone();\n-                let cycle: Vec<_> =\n-                    iter::once(&obligation)\n-                    .chain(Some(pending_obligation))\n-                    .chain(backtrace.take(index + 1).map(|p| &p.obligation))\n-                    .cloned()\n-                    .collect();\n-                if coinductive_match(selcx, &cycle) {\n-                    debug!(\"process_child_obligations: coinductive match\");\n-                    None\n-                } else {\n-                    selcx.infcx().report_overflow_error_cycle(&cycle);\n-                }\n-            } else {\n-                // Not a cycle. Just ignore this obligation then,\n-                // we're already in the process of proving it.\n-                debug!(\"process_child_obligations: not a cycle\");\n-                None\n-            }\n-        })\n-        .collect();\n-\n-    Ok(Some(pending_predicate_obligations))\n-}\n-\n-struct AncestorSet<'b, 'tcx: 'b> {\n-    populated: bool,\n-    cache: FnvHashMap<ty::Predicate<'tcx>, usize>,\n-    backtrace: Backtrace<'b, PendingPredicateObligation<'tcx>>,\n-}\n-\n-impl<'a, 'b, 'gcx, 'tcx> AncestorSet<'b, 'tcx> {\n-    fn new(backtrace: &Backtrace<'b, PendingPredicateObligation<'tcx>>) -> Self {\n-        AncestorSet {\n-            populated: false,\n-            cache: FnvHashMap(),\n-            backtrace: backtrace.clone(),\n-        }\n+    fn process_obligation(&mut self,\n+                          obligation: &mut Self::Obligation)\n+                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n+    {\n+        process_predicate(self.selcx,\n+                          obligation,\n+                          self.region_obligations,\n+                          self.rfc1592_obligations)\n+            .map(|os| os.map(|os| os.into_iter().map(|o| PendingPredicateObligation {\n+                obligation: o,\n+                stalled_on: vec![]\n+            }).collect()))\n     }\n \n-    /// Checks whether any of the ancestors in the backtrace are equal\n-    /// to `predicate` (`predicate` is assumed to be fully\n-    /// type-resolved).  Returns `None` if not; otherwise, returns\n-    /// `Some` with the index within the backtrace.\n-    fn has(&mut self,\n-           infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-           predicate: &ty::Predicate<'tcx>)\n-           -> Option<usize> {\n-        // the first time, we have to populate the cache\n-        if !self.populated {\n-            let backtrace = self.backtrace.clone();\n-            for (index, ancestor) in backtrace.enumerate() {\n-                // Ugh. This just feels ridiculously\n-                // inefficient.  But we need to compare\n-                // predicates without being concerned about\n-                // the vagaries of type inference, so for now\n-                // just ensure that they are always\n-                // up-to-date. (I suppose we could just use a\n-                // snapshot and check if they are unifiable?)\n-                let resolved_predicate =\n-                    infcx.resolve_type_vars_if_possible(\n-                        &ancestor.obligation.predicate);\n-\n-                // Though we try to avoid it, it can happen that a\n-                // cycle already exists in the predecessors. This\n-                // happens if the type variables were not fully known\n-                // at the time that the ancestors were pushed. We'll\n-                // just ignore such cycles for now, on the premise\n-                // that they will repeat themselves and we'll deal\n-                // with them properly then.\n-                self.cache.entry(resolved_predicate)\n-                          .or_insert(index);\n-            }\n-            self.populated = true;\n+    fn process_backedge(&mut self, cycle: &[Self::Obligation])\n+    {\n+        if coinductive_match(self.selcx, &cycle) {\n+            debug!(\"process_child_obligations: coinductive match\");\n+        } else {\n+            let cycle : Vec<_> = cycle.iter().map(|c| c.obligation.clone()).collect();\n+            self.selcx.infcx().report_overflow_error_cycle(&cycle);\n         }\n-\n-        self.cache.get(predicate).cloned()\n     }\n }\n \n@@ -533,7 +343,7 @@ fn trait_ref_type_vars<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 't\n /// - `Ok(Some(v))` if the predicate is true, presuming that `v` are also true\n /// - `Ok(None)` if we don't have enough info to be sure\n /// - `Err` if the predicate does not hold\n-fn process_predicate1<'a, 'gcx, 'tcx>(\n+fn process_predicate<'a, 'gcx, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n     pending_obligation: &mut PendingPredicateObligation<'tcx>,\n     region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>,\n@@ -726,17 +536,13 @@ fn process_predicate1<'a, 'gcx, 'tcx>(\n /// - all the predicates at positions `X..` between `X` an the top are\n ///   also defaulted traits.\n fn coinductive_match<'a, 'gcx, 'tcx>(selcx: &mut SelectionContext<'a, 'gcx, 'tcx>,\n-                                     cycle: &[PredicateObligation<'tcx>])\n+                              cycle: &[PendingPredicateObligation<'tcx>])\n                                      -> bool\n {\n-    let len = cycle.len();\n-\n-    assert_eq!(cycle[0].predicate, cycle[len - 1].predicate);\n-\n-    cycle[0..len-1]\n+    cycle\n         .iter()\n         .all(|bt_obligation| {\n-            let result = coinductive_obligation(selcx, bt_obligation);\n+            let result = coinductive_obligation(selcx, &bt_obligation.obligation);\n             debug!(\"coinductive_match: bt_obligation={:?} coinductive={}\",\n                    bt_obligation, result);\n             result\n@@ -774,25 +580,6 @@ fn register_region_obligation<'tcx>(t_a: Ty<'tcx>,\n \n }\n \n-impl<'tcx> LocalFulfilledPredicates<'tcx> {\n-    pub fn new() -> LocalFulfilledPredicates<'tcx> {\n-        LocalFulfilledPredicates {\n-            set: FnvHashSet()\n-        }\n-    }\n-\n-    fn is_duplicate_or_add(&mut self, key: &ty::Predicate<'tcx>) -> bool {\n-        // For a `LocalFulfilledPredicates`, if we find a match, we\n-        // don't need to add a read edge to the dep-graph. This is\n-        // because it means that the predicate has already been\n-        // considered by this `FulfillmentContext`, and hence the\n-        // containing task will already have an edge. (Here we are\n-        // assuming each `FulfillmentContext` only gets used from one\n-        // task; but to do otherwise makes no sense)\n-        !self.set.insert(key.clone())\n-    }\n-}\n-\n impl<'a, 'gcx, 'tcx> GlobalFulfilledPredicates<'gcx> {\n     pub fn new(dep_graph: DepGraph) -> GlobalFulfilledPredicates<'gcx> {\n         GlobalFulfilledPredicates {"}, {"sha": "747e2fc738697871c0f6e9a9c17d6d369c63d3d7", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 266, "deletions": 274, "changes": 540, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -15,20 +15,41 @@\n //! in the first place). See README.md for a general overview of how\n //! to use this class.\n \n+use fnv::{FnvHashMap, FnvHashSet};\n+\n+use std::collections::hash_map::Entry;\n use std::fmt::Debug;\n-use std::mem;\n+use std::hash;\n \n mod node_index;\n use self::node_index::NodeIndex;\n \n-mod tree_index;\n-use self::tree_index::TreeIndex;\n-\n-\n #[cfg(test)]\n mod test;\n \n-pub struct ObligationForest<O, T> {\n+pub trait ForestObligation : Clone {\n+    type Predicate : Clone + hash::Hash + Eq + ::std::fmt::Debug;\n+\n+    fn as_predicate(&self) -> &Self::Predicate;\n+}\n+\n+pub trait ObligationProcessor {\n+    type Obligation : ForestObligation;\n+    type Error : Debug;\n+\n+    fn process_obligation(&mut self,\n+                          obligation: &mut Self::Obligation)\n+                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>;\n+\n+    fn process_backedge(&mut self, cycle: &[Self::Obligation]);\n+}\n+\n+struct SnapshotData {\n+    node_len: usize,\n+    cache_list_len: usize,\n+}\n+\n+pub struct ObligationForest<O: ForestObligation> {\n     /// The list of obligations. In between calls to\n     /// `process_obligations`, this list only contains nodes in the\n     /// `Pending` or `Success` state (with a non-zero number of\n@@ -42,34 +63,37 @@ pub struct ObligationForest<O, T> {\n     /// at a higher index than its parent. This is needed by the\n     /// backtrace iterator (which uses `split_at`).\n     nodes: Vec<Node<O>>,\n-    trees: Vec<Tree<T>>,\n-    snapshots: Vec<usize>,\n+    done_cache: FnvHashSet<O::Predicate>,\n+    waiting_cache: FnvHashMap<O::Predicate, NodeIndex>,\n+    cache_list: Vec<O::Predicate>,\n+    snapshots: Vec<SnapshotData>,\n+    scratch: Option<Vec<usize>>,\n }\n \n pub struct Snapshot {\n     len: usize,\n }\n \n-struct Tree<T> {\n-    root: NodeIndex,\n-    state: T,\n-}\n-\n+#[derive(Debug)]\n struct Node<O> {\n-    state: NodeState<O>,\n+    obligation: O,\n+    state: NodeState,\n+\n+    // these both go *in the same direction*.\n     parent: Option<NodeIndex>,\n-    tree: TreeIndex,\n+    dependants: Vec<NodeIndex>,\n }\n \n /// The state of one node in some tree within the forest. This\n /// represents the current state of processing for the obligation (of\n /// type `O`) associated with this node.\n-#[derive(Debug)]\n-enum NodeState<O> {\n+#[derive(Debug, PartialEq, Eq)]\n+enum NodeState {\n     /// Obligation not yet resolved to success or error.\n-    Pending {\n-        obligation: O,\n-    },\n+    Pending,\n+\n+    /// Used before garbage collection\n+    Success,\n \n     /// Obligation resolved to success; `num_incomplete_children`\n     /// indicates the number of children still in an \"incomplete\"\n@@ -79,10 +103,11 @@ enum NodeState<O> {\n     ///\n     /// Once all children have completed, success nodes are removed\n     /// from the vector by the compression step.\n-    Success {\n-        obligation: O,\n-        num_incomplete_children: usize,\n-    },\n+    Waiting,\n+\n+    /// This obligation, along with its subobligations, are complete,\n+    /// and will be removed in the next collection.\n+    Done,\n \n     /// This obligation was resolved to an error. Error nodes are\n     /// removed from the vector by the compression step.\n@@ -113,12 +138,15 @@ pub struct Error<O, E> {\n     pub backtrace: Vec<O>,\n }\n \n-impl<O: Debug, T: Debug> ObligationForest<O, T> {\n-    pub fn new() -> ObligationForest<O, T> {\n+impl<O: Debug + ForestObligation> ObligationForest<O> {\n+    pub fn new() -> ObligationForest<O> {\n         ObligationForest {\n-            trees: vec![],\n             nodes: vec![],\n             snapshots: vec![],\n+            done_cache: FnvHashSet(),\n+            waiting_cache: FnvHashMap(),\n+            cache_list: vec![],\n+            scratch: Some(vec![]),\n         }\n     }\n \n@@ -129,57 +157,64 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n     }\n \n     pub fn start_snapshot(&mut self) -> Snapshot {\n-        self.snapshots.push(self.trees.len());\n+        self.snapshots.push(SnapshotData {\n+            node_len: self.nodes.len(),\n+            cache_list_len: self.cache_list.len()\n+        });\n         Snapshot { len: self.snapshots.len() }\n     }\n \n     pub fn commit_snapshot(&mut self, snapshot: Snapshot) {\n         assert_eq!(snapshot.len, self.snapshots.len());\n-        let trees_len = self.snapshots.pop().unwrap();\n-        assert!(self.trees.len() >= trees_len);\n+        let info = self.snapshots.pop().unwrap();\n+        assert!(self.nodes.len() >= info.node_len);\n+        assert!(self.cache_list.len() >= info.cache_list_len);\n     }\n \n     pub fn rollback_snapshot(&mut self, snapshot: Snapshot) {\n         // Check that we are obeying stack discipline.\n         assert_eq!(snapshot.len, self.snapshots.len());\n-        let trees_len = self.snapshots.pop().unwrap();\n+        let info = self.snapshots.pop().unwrap();\n \n-        // If nothing happened in snapshot, done.\n-        if self.trees.len() == trees_len {\n-            return;\n+        for entry in &self.cache_list[info.cache_list_len..] {\n+            self.done_cache.remove(entry);\n+            self.waiting_cache.remove(entry);\n         }\n \n-        // Find root of first tree; because nothing can happen in a\n-        // snapshot but pushing trees, all nodes after that should be\n-        // roots of other trees as well\n-        let first_root_index = self.trees[trees_len].root.get();\n-        debug_assert!(self.nodes[first_root_index..]\n-                          .iter()\n-                          .zip(first_root_index..)\n-                          .all(|(root, root_index)| {\n-                              self.trees[root.tree.get()].root.get() == root_index\n-                          }));\n-\n-        // Pop off tree/root pairs pushed during snapshot.\n-        self.trees.truncate(trees_len);\n-        self.nodes.truncate(first_root_index);\n+        self.nodes.truncate(info.node_len);\n+        self.cache_list.truncate(info.cache_list_len);\n     }\n \n     pub fn in_snapshot(&self) -> bool {\n         !self.snapshots.is_empty()\n     }\n \n-    /// Adds a new tree to the forest.\n+    /// Registers an obligation\n     ///\n-    /// This CAN be done during a snapshot.\n-    pub fn push_tree(&mut self, obligation: O, tree_state: T) {\n-        let index = NodeIndex::new(self.nodes.len());\n-        let tree = TreeIndex::new(self.trees.len());\n-        self.trees.push(Tree {\n-            root: index,\n-            state: tree_state,\n-        });\n-        self.nodes.push(Node::new(tree, None, obligation));\n+    /// This CAN be done in a snapshot\n+    pub fn register_obligation(&mut self, obligation: O) {\n+        self.register_obligation_at(obligation, None)\n+    }\n+\n+    fn register_obligation_at(&mut self, obligation: O, parent: Option<NodeIndex>) {\n+        if self.done_cache.contains(obligation.as_predicate()) { return }\n+\n+        match self.waiting_cache.entry(obligation.as_predicate().clone()) {\n+            Entry::Occupied(o) => {\n+                debug!(\"register_obligation_at({:?}, {:?}) - duplicate of {:?}!\",\n+                       obligation, parent, o.get());\n+                if let Some(parent) = parent {\n+                    self.nodes[o.get().get()].dependants.push(parent);\n+                }\n+            }\n+            Entry::Vacant(v) => {\n+                debug!(\"register_obligation_at({:?}, {:?}) - ok\",\n+                       obligation, parent);\n+                v.insert(NodeIndex::new(self.nodes.len()));\n+                self.cache_list.push(obligation.as_predicate().clone());\n+                self.nodes.push(Node::new(parent, obligation));\n+            }\n+        };\n     }\n \n     /// Convert all remaining obligations to the given error.\n@@ -190,9 +225,8 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n         let mut errors = vec![];\n         for index in 0..self.nodes.len() {\n             debug_assert!(!self.nodes[index].is_popped());\n-            self.inherit_error(index);\n-            if let NodeState::Pending { .. } = self.nodes[index].state {\n-                let backtrace = self.backtrace(index);\n+            if let NodeState::Pending = self.nodes[index].state {\n+                let backtrace = self.error_at(index);\n                 errors.push(Error {\n                     error: error.clone(),\n                     backtrace: backtrace,\n@@ -210,56 +244,36 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n     {\n         self.nodes\n             .iter()\n-            .filter_map(|n| {\n-                match n.state {\n-                    NodeState::Pending { ref obligation } => Some(obligation),\n-                    _ => None,\n-                }\n-            })\n-            .cloned()\n+            .filter(|n| n.state == NodeState::Pending)\n+            .map(|n| n.obligation.clone())\n             .collect()\n     }\n \n-    /// Process the obligations.\n+    /// Perform a pass through the obligation list. This must\n+    /// be called in a loop until `outcome.stalled` is false.\n     ///\n     /// This CANNOT be unrolled (presently, at least).\n-    pub fn process_obligations<E, F>(&mut self, mut action: F) -> Outcome<O, E>\n-        where E: Debug,\n-              F: FnMut(&mut O, &mut T, Backtrace<O>) -> Result<Option<Vec<O>>, E>\n+    pub fn process_obligations<P>(&mut self, processor: &mut P) -> Outcome<O, P::Error>\n+        where P: ObligationProcessor<Obligation=O>\n     {\n         debug!(\"process_obligations(len={})\", self.nodes.len());\n         assert!(!self.in_snapshot()); // cannot unroll this action\n \n         let mut errors = vec![];\n         let mut stalled = true;\n \n-        // We maintain the invariant that the list is in pre-order, so\n-        // parents occur before their children. Also, whenever an\n-        // error occurs, we propagate it from the child all the way to\n-        // the root of the tree. Together, these two facts mean that\n-        // when we visit a node, we can check if its root is in error,\n-        // and we will find out if any prior node within this forest\n-        // encountered an error.\n-\n         for index in 0..self.nodes.len() {\n             debug_assert!(!self.nodes[index].is_popped());\n-            self.inherit_error(index);\n \n             debug!(\"process_obligations: node {} == {:?}\",\n                    index,\n-                   self.nodes[index].state);\n-\n-            let result = {\n-                let Node { tree, parent, .. } = self.nodes[index];\n-                let (prefix, suffix) = self.nodes.split_at_mut(index);\n-                let backtrace = Backtrace::new(prefix, parent);\n-                match suffix[0].state {\n-                    NodeState::Error |\n-                    NodeState::Success { .. } => continue,\n-                    NodeState::Pending { ref mut obligation } => {\n-                        action(obligation, &mut self.trees[tree.get()].state, backtrace)\n-                    }\n+                   self.nodes[index]);\n+\n+            let result = match self.nodes[index] {\n+                Node { state: NodeState::Pending, ref mut obligation, .. } => {\n+                    processor.process_obligation(obligation)\n                 }\n+                _ => continue\n             };\n \n             debug!(\"process_obligations: node {} got result {:?}\",\n@@ -273,10 +287,15 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n                 Ok(Some(children)) => {\n                     // if we saw a Some(_) result, we are not (yet) stalled\n                     stalled = false;\n-                    self.success(index, children);\n+                    for child in children {\n+                        self.register_obligation_at(child,\n+                                                    Some(NodeIndex::new(index)));\n+                    }\n+\n+                    self.nodes[index].state = NodeState::Success;\n                 }\n                 Err(err) => {\n-                    let backtrace = self.backtrace(index);\n+                    let backtrace = self.error_at(index);\n                     errors.push(Error {\n                         error: err,\n                         backtrace: backtrace,\n@@ -285,82 +304,29 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n             }\n         }\n \n+        self.mark_as_waiting();\n+        self.process_cycles(processor);\n+\n         // Now we have to compress the result\n-        let successful_obligations = self.compress();\n+        let completed_obligations = self.compress();\n \n         debug!(\"process_obligations: complete\");\n \n         Outcome {\n-            completed: successful_obligations,\n+            completed: completed_obligations,\n             errors: errors,\n             stalled: stalled,\n         }\n     }\n \n-    /// Indicates that node `index` has been processed successfully,\n-    /// yielding `children` as the derivative work. If children is an\n-    /// empty vector, this will update the ref count on the parent of\n-    /// `index` to indicate that a child has completed\n-    /// successfully. Otherwise, adds new nodes to represent the child\n-    /// work.\n-    fn success(&mut self, index: usize, children: Vec<O>) {\n-        debug!(\"success(index={}, children={:?})\", index, children);\n-\n-        let num_incomplete_children = children.len();\n-\n-        if num_incomplete_children == 0 {\n-            // if there is no work left to be done, decrement parent's ref count\n-            self.update_parent(index);\n-        } else {\n-            // create child work\n-            let tree_index = self.nodes[index].tree;\n-            let node_index = NodeIndex::new(index);\n-            self.nodes.extend(children.into_iter()\n-                                      .map(|o| Node::new(tree_index, Some(node_index), o)));\n-        }\n-\n-        // change state from `Pending` to `Success`, temporarily swapping in `Error`\n-        let state = mem::replace(&mut self.nodes[index].state, NodeState::Error);\n-        self.nodes[index].state = match state {\n-            NodeState::Pending { obligation } => {\n-                NodeState::Success {\n-                    obligation: obligation,\n-                    num_incomplete_children: num_incomplete_children,\n-                }\n-            }\n-            NodeState::Success { .. } |\n-            NodeState::Error => unreachable!(),\n-        };\n-    }\n-\n-    /// Decrements the ref count on the parent of `child`; if the\n-    /// parent's ref count then reaches zero, proceeds recursively.\n-    fn update_parent(&mut self, child: usize) {\n-        debug!(\"update_parent(child={})\", child);\n-        if let Some(parent) = self.nodes[child].parent {\n-            let parent = parent.get();\n-            match self.nodes[parent].state {\n-                NodeState::Success { ref mut num_incomplete_children, .. } => {\n-                    *num_incomplete_children -= 1;\n-                    if *num_incomplete_children > 0 {\n-                        return;\n-                    }\n-                }\n-                _ => unreachable!(),\n+    pub fn process_cycles<P>(&mut self, _processor: &mut P)\n+        where P: ObligationProcessor<Obligation=O>\n+    {\n+        // TODO: implement\n+        for node in &mut self.nodes {\n+            if node.state == NodeState::Success {\n+                node.state = NodeState::Done;\n             }\n-            self.update_parent(parent);\n-        }\n-    }\n-\n-    /// If the root of `child` is in an error state, places `child`\n-    /// into an error state. This is used during processing so that we\n-    /// skip the remaining obligations from a tree once some other\n-    /// node in the tree is found to be in error.\n-    fn inherit_error(&mut self, child: usize) {\n-        let tree = self.nodes[child].tree;\n-        let root = self.trees[tree.get()].root;\n-        if let NodeState::Error = self.nodes[root.get()].state {\n-            self.nodes[child].state = NodeState::Error;\n         }\n     }\n \n@@ -369,175 +335,201 @@ impl<O: Debug, T: Debug> ObligationForest<O, T> {\n     /// The fact that the root is now marked as an error is used by\n     /// `inherit_error` above to propagate the error state to the\n     /// remainder of the tree.\n-    fn backtrace(&mut self, mut p: usize) -> Vec<O> {\n+    fn error_at(&mut self, p: usize) -> Vec<O> {\n+        let mut error_stack = self.scratch.take().unwrap();\n         let mut trace = vec![];\n+\n+        let mut n = p;\n         loop {\n-            let state = mem::replace(&mut self.nodes[p].state, NodeState::Error);\n-            match state {\n-                NodeState::Pending { obligation } |\n-                NodeState::Success { obligation, .. } => {\n-                    trace.push(obligation);\n-                }\n-                NodeState::Error => {\n-                    // we should not encounter an error, because if\n-                    // there was an error in the ancestors, it should\n-                    // have been propagated down and we should never\n-                    // have tried to process this obligation\n-                    panic!(\"encountered error in node {:?} when collecting stack trace\",\n-                           p);\n-                }\n-            }\n+            self.nodes[n].state = NodeState::Error;\n+            trace.push(self.nodes[n].obligation.clone());\n+            error_stack.extend(self.nodes[n].dependants.iter().map(|x| x.get()));\n \n             // loop to the parent\n-            match self.nodes[p].parent {\n-                Some(q) => {\n-                    p = q.get();\n-                }\n-                None => {\n-                    return trace;\n+            match self.nodes[n].parent {\n+                Some(q) => n = q.get(),\n+                None => break\n+            }\n+        }\n+\n+        loop {\n+            // non-standard `while let` to bypass #6393\n+            let i = match error_stack.pop() {\n+                Some(i) => i,\n+                None => break\n+            };\n+\n+            match self.nodes[i].state {\n+                NodeState::Error => continue,\n+                ref mut s => *s = NodeState::Error\n+            }\n+\n+            let node = &self.nodes[i];\n+            error_stack.extend(\n+                node.dependants.iter().cloned().chain(node.parent).map(|x| x.get())\n+            );\n+        }\n+\n+        self.scratch = Some(error_stack);\n+        trace\n+    }\n+\n+    fn mark_as_waiting(&mut self) {\n+        for node in &mut self.nodes {\n+            if node.state == NodeState::Waiting {\n+                node.state = NodeState::Success;\n+            }\n+        }\n+\n+        let mut undone_stack = self.scratch.take().unwrap();\n+        undone_stack.extend(\n+            self.nodes.iter().enumerate()\n+                .filter(|&(_i, n)| n.state == NodeState::Pending)\n+                .map(|(i, _n)| i));\n+\n+        loop {\n+            // non-standard `while let` to bypass #6393\n+            let i = match undone_stack.pop() {\n+                Some(i) => i,\n+                None => break\n+            };\n+\n+            match self.nodes[i].state {\n+                NodeState::Pending | NodeState::Done => {},\n+                NodeState::Waiting | NodeState::Error => continue,\n+                ref mut s @ NodeState::Success => {\n+                    *s = NodeState::Waiting;\n                 }\n             }\n+\n+            let node = &self.nodes[i];\n+            undone_stack.extend(\n+                node.dependants.iter().cloned().chain(node.parent).map(|x| x.get())\n+            );\n         }\n+\n+        self.scratch = Some(undone_stack);\n     }\n \n     /// Compresses the vector, removing all popped nodes. This adjusts\n     /// the indices and hence invalidates any outstanding\n     /// indices. Cannot be used during a transaction.\n+    ///\n+    /// Beforehand, all nodes must be marked as `Done` and no cycles\n+    /// on these nodes may be present. This is done by e.g. `process_cycles`.\n+    #[inline(never)]\n     fn compress(&mut self) -> Vec<O> {\n         assert!(!self.in_snapshot()); // didn't write code to unroll this action\n-        let mut node_rewrites: Vec<_> = (0..self.nodes.len()).collect();\n-        let mut tree_rewrites: Vec<_> = (0..self.trees.len()).collect();\n \n-        // Finish propagating error state. Note that in this case we\n-        // only have to check immediate parents, rather than all\n-        // ancestors, because all errors have already occurred that\n-        // are going to occur.\n         let nodes_len = self.nodes.len();\n-        for i in 0..nodes_len {\n-            if !self.nodes[i].is_popped() {\n-                self.inherit_error(i);\n-            }\n-        }\n+        let mut node_rewrites: Vec<_> = self.scratch.take().unwrap();\n+        node_rewrites.extend(0..nodes_len);\n+        let mut dead_nodes = 0;\n \n-        // Determine which trees to remove by checking if their root\n-        // is popped.\n-        let mut dead_trees = 0;\n-        let trees_len = self.trees.len();\n-        for i in 0..trees_len {\n-            let root_node = self.trees[i].root;\n-            if self.nodes[root_node.get()].is_popped() {\n-                dead_trees += 1;\n-            } else if dead_trees > 0 {\n-                self.trees.swap(i, i - dead_trees);\n-                tree_rewrites[i] -= dead_trees;\n+        // Now move all popped nodes to the end. Try to keep the order.\n+        //\n+        // LOOP INVARIANT:\n+        //     self.nodes[0..i - dead_nodes] are the first remaining nodes\n+        //     self.nodes[i - dead_nodes..i] are all dead\n+        //     self.nodes[i..] are unchanged\n+        for i in 0..self.nodes.len() {\n+            if let NodeState::Done = self.nodes[i].state {\n+                self.done_cache.insert(self.nodes[i].obligation.as_predicate().clone());\n             }\n-        }\n \n-        // Now go through and move all nodes that are either\n-        // successful or which have an error over into to the end of\n-        // the list, preserving the relative order of the survivors\n-        // (which is important for the `inherit_error` logic).\n-        let mut dead_nodes = 0;\n-        for i in 0..nodes_len {\n             if self.nodes[i].is_popped() {\n+                self.waiting_cache.remove(self.nodes[i].obligation.as_predicate());\n+                node_rewrites[i] = nodes_len;\n                 dead_nodes += 1;\n-            } else if dead_nodes > 0 {\n-                self.nodes.swap(i, i - dead_nodes);\n-                node_rewrites[i] -= dead_nodes;\n+            } else {\n+                if dead_nodes > 0 {\n+                    self.nodes.swap(i, i - dead_nodes);\n+                    node_rewrites[i] -= dead_nodes;\n+                }\n             }\n         }\n \n         // No compression needed.\n-        if dead_nodes == 0 && dead_trees == 0 {\n+        if dead_nodes == 0 {\n+            node_rewrites.truncate(0);\n+            self.scratch = Some(node_rewrites);\n             return vec![];\n         }\n \n-        // Pop off the trees we killed.\n-        self.trees.truncate(trees_len - dead_trees);\n-\n         // Pop off all the nodes we killed and extract the success\n         // stories.\n         let successful = (0..dead_nodes)\n                              .map(|_| self.nodes.pop().unwrap())\n                              .flat_map(|node| {\n                                  match node.state {\n                                      NodeState::Error => None,\n-                                     NodeState::Pending { .. } => unreachable!(),\n-                                     NodeState::Success { obligation, num_incomplete_children } => {\n-                                         assert_eq!(num_incomplete_children, 0);\n-                                         Some(obligation)\n-                                     }\n+                                     NodeState::Done => Some(node.obligation),\n+                                     _ => unreachable!()\n                                  }\n                              })\n-                             .collect();\n+            .collect();\n+        self.apply_rewrites(&node_rewrites);\n+\n+        node_rewrites.truncate(0);\n+        self.scratch = Some(node_rewrites);\n+\n+        successful\n+    }\n+\n+    fn apply_rewrites(&mut self, node_rewrites: &[usize]) {\n+        let nodes_len = node_rewrites.len();\n \n-        // Adjust the various indices, since we compressed things.\n-        for tree in &mut self.trees {\n-            tree.root = NodeIndex::new(node_rewrites[tree.root.get()]);\n-        }\n         for node in &mut self.nodes {\n-            if let Some(ref mut index) = node.parent {\n+            if let Some(index) = node.parent {\n                 let new_index = node_rewrites[index.get()];\n-                debug_assert!(new_index < (nodes_len - dead_nodes));\n-                *index = NodeIndex::new(new_index);\n+                if new_index >= nodes_len {\n+                    // parent dead due to error\n+                    node.parent = None;\n+                } else {\n+                    node.parent = Some(NodeIndex::new(new_index));\n+                }\n             }\n \n-            node.tree = TreeIndex::new(tree_rewrites[node.tree.get()]);\n+            let mut i = 0;\n+            while i < node.dependants.len() {\n+                let new_index = node_rewrites[node.dependants[i].get()];\n+                if new_index >= nodes_len {\n+                    node.dependants.swap_remove(i);\n+                } else {\n+                    node.dependants[i] = NodeIndex::new(new_index);\n+                    i += 1;\n+                }\n+            }\n         }\n \n-        successful\n+        let mut kill_list = vec![];\n+        for (predicate, index) in self.waiting_cache.iter_mut() {\n+            let new_index = node_rewrites[index.get()];\n+            if new_index >= nodes_len {\n+                kill_list.push(predicate.clone());\n+            } else {\n+                *index = NodeIndex::new(new_index);\n+            }\n+        }\n+\n+        for predicate in kill_list { self.waiting_cache.remove(&predicate); }\n     }\n }\n \n impl<O> Node<O> {\n-    fn new(tree: TreeIndex, parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n+    fn new(parent: Option<NodeIndex>, obligation: O) -> Node<O> {\n         Node {\n+            obligation: obligation,\n             parent: parent,\n-            state: NodeState::Pending { obligation: obligation },\n-            tree: tree,\n+            state: NodeState::Pending,\n+            dependants: vec![],\n         }\n     }\n \n     fn is_popped(&self) -> bool {\n         match self.state {\n-            NodeState::Pending { .. } => false,\n-            NodeState::Success { num_incomplete_children, .. } => num_incomplete_children == 0,\n-            NodeState::Error => true,\n-        }\n-    }\n-}\n-\n-#[derive(Clone)]\n-pub struct Backtrace<'b, O: 'b> {\n-    nodes: &'b [Node<O>],\n-    pointer: Option<NodeIndex>,\n-}\n-\n-impl<'b, O> Backtrace<'b, O> {\n-    fn new(nodes: &'b [Node<O>], pointer: Option<NodeIndex>) -> Backtrace<'b, O> {\n-        Backtrace {\n-            nodes: nodes,\n-            pointer: pointer,\n-        }\n-    }\n-}\n-\n-impl<'b, O> Iterator for Backtrace<'b, O> {\n-    type Item = &'b O;\n-\n-    fn next(&mut self) -> Option<&'b O> {\n-        debug!(\"Backtrace: self.pointer = {:?}\", self.pointer);\n-        if let Some(p) = self.pointer {\n-            self.pointer = self.nodes[p.get()].parent;\n-            match self.nodes[p.get()].state {\n-                NodeState::Pending { ref obligation } |\n-                NodeState::Success { ref obligation, .. } => Some(obligation),\n-                NodeState::Error => {\n-                    panic!(\"Backtrace encountered an error.\");\n-                }\n-            }\n-        } else {\n-            None\n+            NodeState::Pending | NodeState::Success | NodeState::Waiting => false,\n+            NodeState::Error | NodeState::Done => true,\n         }\n     }\n }"}, {"sha": "6a2bee4584ef6d733bb2dc6c44ddbe6635b10fe6", "filename": "src/librustc_data_structures/obligation_forest/test.rs", "status": "modified", "additions": 279, "deletions": 96, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Ftest.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -8,30 +8,81 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{ObligationForest, Outcome, Error};\n+#![cfg(test)]\n+\n+use super::{ObligationForest, ObligationProcessor, Outcome, Error};\n+\n+use std::fmt;\n+use std::marker::PhantomData;\n+\n+impl<'a> super::ForestObligation for &'a str {\n+    type Predicate = &'a str;\n+\n+    fn as_predicate(&self) -> &Self::Predicate {\n+        self\n+    }\n+}\n+\n+struct ClosureObligationProcessor<OF, BF, O, E> {\n+    process_obligation: OF,\n+    process_backedge: BF,\n+    marker: PhantomData<(O, E)>,\n+}\n+\n+#[allow(non_snake_case)]\n+fn C<OF, BF, O>(of: OF, bf: BF) -> ClosureObligationProcessor<OF, BF, O, &'static str>\n+    where OF: FnMut(&mut O) -> Result<Option<Vec<O>>, &'static str>,\n+          BF: FnMut(&[O])\n+{\n+    ClosureObligationProcessor {\n+        process_obligation: of,\n+        process_backedge: bf,\n+        marker: PhantomData\n+    }\n+}\n+\n+impl<OF, BF, O, E> ObligationProcessor for ClosureObligationProcessor<OF, BF, O, E>\n+    where O: super::ForestObligation + fmt::Debug,\n+          E: fmt::Debug,\n+          OF: FnMut(&mut O) -> Result<Option<Vec<O>>, E>,\n+          BF: FnMut(&[O])\n+{\n+    type Obligation = O;\n+    type Error = E;\n+\n+    fn process_obligation(&mut self,\n+                          obligation: &mut Self::Obligation)\n+                          -> Result<Option<Vec<Self::Obligation>>, Self::Error>\n+    {\n+        (self.process_obligation)(obligation)\n+    }\n+\n+    fn process_backedge(&mut self, cycle: &[Self::Obligation]) {\n+        (self.process_backedge)(cycle);\n+    }\n+}\n+\n \n #[test]\n fn push_pop() {\n     let mut forest = ObligationForest::new();\n-    forest.push_tree(\"A\", \"A\");\n-    forest.push_tree(\"B\", \"B\");\n-    forest.push_tree(\"C\", \"C\");\n+    forest.register_obligation(\"A\");\n+    forest.register_obligation(\"B\");\n+    forest.register_obligation(\"C\");\n \n     // first round, B errors out, A has subtasks, and C completes, creating this:\n     //      A |-> A.1\n     //        |-> A.2\n     //        |-> A.3\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation,\n-                                                                                 tree,\n-                                                                                 _| {\n-        assert_eq!(obligation.chars().next(), tree.chars().next());\n-        match *obligation {\n-            \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n-            \"B\" => Err(\"B is for broken\"),\n-            \"C\" => Ok(Some(vec![])),\n-            _ => unreachable!(),\n-        }\n-    });\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n+                \"B\" => Err(\"B is for broken\"),\n+                \"C\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        }, |_| {}));\n     assert_eq!(ok, vec![\"C\"]);\n     assert_eq!(err,\n                vec![Error {\n@@ -45,56 +96,53 @@ fn push_pop() {\n     //        |-> A.3 |-> A.3.i\n     //      D |-> D.1\n     //        |-> D.2\n-    forest.push_tree(\"D\", \"D\");\n-    let Outcome { completed: ok, errors: err, .. }: Outcome<&'static str, ()> =\n-        forest.process_obligations(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+    forest.register_obligation(\"D\");\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A.1\" => Ok(None),\n                 \"A.2\" => Ok(None),\n                 \"A.3\" => Ok(Some(vec![\"A.3.i\"])),\n                 \"D\" => Ok(Some(vec![\"D.1\", \"D.2\"])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_| {}));\n     assert_eq!(ok, Vec::<&'static str>::new());\n     assert_eq!(err, Vec::new());\n \n \n     // third round: ok in A.1 but trigger an error in A.2. Check that it\n-    // propagates to A.3.i, but not D.1 or D.2.\n+    // propagates to A, but not D.1 or D.2.\n     //      D |-> D.1 |-> D.1.i\n     //        |-> D.2 |-> D.2.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation,\n-                                                                                 tree,\n-                                                                                 _| {\n-        assert_eq!(obligation.chars().next(), tree.chars().next());\n-        match *obligation {\n-            \"A.1\" => Ok(Some(vec![])),\n-            \"A.2\" => Err(\"A is for apple\"),\n-            \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n-            \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n-            _ => unreachable!(),\n-        }\n-    });\n-    assert_eq!(ok, vec![\"A.1\"]);\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A.1\" => Ok(Some(vec![])),\n+                \"A.2\" => Err(\"A is for apple\"),\n+                \"A.3.i\" => Ok(Some(vec![])),\n+                \"D.1\" => Ok(Some(vec![\"D.1.i\"])),\n+                \"D.2\" => Ok(Some(vec![\"D.2.i\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_| {}));\n+    assert_eq!(ok, vec![\"A.3\", \"A.1\", \"A.3.i\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"A is for apple\",\n                         backtrace: vec![\"A.2\", \"A\"],\n                     }]);\n \n-    // fourth round: error in D.1.i that should propagate to D.2.i\n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations(|obligation,\n-                                                                                 tree,\n-                                                                                 _| {\n-        assert_eq!(obligation.chars().next(), tree.chars().next());\n-        match *obligation {\n-            \"D.1.i\" => Err(\"D is for dumb\"),\n-            _ => panic!(\"unexpected obligation {:?}\", obligation),\n-        }\n-    });\n-    assert_eq!(ok, Vec::<&'static str>::new());\n+    // fourth round: error in D.1.i\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"D.1.i\" => Err(\"D is for dumb\"),\n+                \"D.2.i\" => Ok(Some(vec![])),\n+                _ => panic!(\"unexpected obligation {:?}\", obligation),\n+            }\n+        }, |_| {}));\n+    assert_eq!(ok, vec![\"D.2.i\", \"D.2\"]);\n     assert_eq!(err,\n                vec![Error {\n                         error: \"D is for dumb\",\n@@ -113,124 +161,259 @@ fn push_pop() {\n #[test]\n fn success_in_grandchildren() {\n     let mut forest = ObligationForest::new();\n-    forest.push_tree(\"A\", \"A\");\n+    forest.register_obligation(\"A\");\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_| {}));\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A.1\" => Ok(Some(vec![])),\n                 \"A.2\" => Ok(Some(vec![\"A.2.i\", \"A.2.ii\"])),\n                 \"A.3\" => Ok(Some(vec![])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_| {}));\n     assert_eq!(ok, vec![\"A.3\", \"A.1\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A.2.i\" => Ok(Some(vec![\"A.2.i.a\"])),\n                 \"A.2.ii\" => Ok(Some(vec![])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_| {}));\n     assert_eq!(ok, vec![\"A.2.ii\"]);\n     assert!(err.is_empty());\n \n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A.2.i.a\" => Ok(Some(vec![])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_| {}));\n     assert_eq!(ok, vec![\"A.2.i.a\", \"A.2.i\", \"A.2\", \"A\"]);\n     assert!(err.is_empty());\n \n-    let Outcome { completed: ok, errors: err, .. } = forest.process_obligations::<(), _>(|_,\n-                                                                                          _,\n-                                                                                          _| {\n-        unreachable!()\n-    });\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|_| unreachable!(), |_| {}));\n+\n     assert!(ok.is_empty());\n     assert!(err.is_empty());\n }\n \n #[test]\n fn to_errors_no_throw() {\n     // check that converting multiple children with common parent (A)\n-    // only yields one of them (and does not panic, in particular).\n+    // yields to correct errors (and does not panic, in particular).\n     let mut forest = ObligationForest::new();\n-    forest.push_tree(\"A\", \"A\");\n+    forest.register_obligation(\"A\");\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, _| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n                 \"A\" => Ok(Some(vec![\"A.1\", \"A.2\", \"A.3\"])),\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_|{}));\n     assert_eq!(ok.len(), 0);\n     assert_eq!(err.len(), 0);\n     let errors = forest.to_errors(());\n-    assert_eq!(errors.len(), 1);\n+    assert_eq!(errors[0].backtrace, vec![\"A.1\", \"A\"]);\n+    assert_eq!(errors[1].backtrace, vec![\"A.2\", \"A\"]);\n+    assert_eq!(errors[2].backtrace, vec![\"A.3\", \"A\"]);\n+    assert_eq!(errors.len(), 3);\n }\n \n #[test]\n-fn backtrace() {\n-    // check that converting multiple children with common parent (A)\n-    // only yields one of them (and does not panic, in particular).\n+fn diamond() {\n+    // check that diamond dependencies are handled correctly\n     let mut forest = ObligationForest::new();\n-    forest.push_tree(\"A\", \"A\");\n+    forest.register_obligation(\"A\");\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, mut backtrace| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n-            assert!(backtrace.next().is_none());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A\" => Ok(Some(vec![\"A.1\"])),\n+                \"A\" => Ok(Some(vec![\"A.1\", \"A.2\"])),\n                 _ => unreachable!(),\n             }\n-        });\n-    assert!(ok.is_empty());\n-    assert!(err.is_empty());\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err.len(), 0);\n+\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, mut backtrace| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n-            assert!(backtrace.next().unwrap() == &\"A\");\n-            assert!(backtrace.next().is_none());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1\" => Ok(Some(vec![\"A.1.i\"])),\n+                \"A.1\" => Ok(Some(vec![\"D\"])),\n+                \"A.2\" => Ok(Some(vec![\"D\"])),\n                 _ => unreachable!(),\n             }\n-        });\n-    assert!(ok.is_empty());\n-    assert!(err.is_empty());\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err.len(), 0);\n+\n+    let mut d_count = 0;\n     let Outcome { completed: ok, errors: err, .. } =\n-        forest.process_obligations::<(), _>(|obligation, tree, mut backtrace| {\n-            assert_eq!(obligation.chars().next(), tree.chars().next());\n-            assert!(backtrace.next().unwrap() == &\"A.1\");\n-            assert!(backtrace.next().unwrap() == &\"A\");\n-            assert!(backtrace.next().is_none());\n+        forest.process_obligations(&mut C(|obligation| {\n             match *obligation {\n-                \"A.1.i\" => Ok(None),\n+                \"D\" => { d_count += 1; Ok(Some(vec![])) },\n                 _ => unreachable!(),\n             }\n-        });\n+        }, |_|{}));\n+    assert_eq!(d_count, 1);\n+    assert_eq!(ok, vec![\"D\", \"A.2\", \"A.1\", \"A\"]);\n+    assert_eq!(err.len(), 0);\n+\n+    let errors = forest.to_errors(());\n+    assert_eq!(errors.len(), 0);\n+\n+    forest.register_obligation(\"A'\");\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A'\" => Ok(Some(vec![\"A'.1\", \"A'.2\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n     assert_eq!(ok.len(), 0);\n-    assert!(err.is_empty());\n+    assert_eq!(err.len(), 0);\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A'.1\" => Ok(Some(vec![\"D'\", \"A'\"])),\n+                \"A'.2\" => Ok(Some(vec![\"D'\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err.len(), 0);\n+\n+    let mut d_count = 0;\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"D'\" => { d_count += 1; Err(\"operation failed\") },\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(d_count, 1);\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err, vec![super::Error {\n+        error: \"operation failed\",\n+        backtrace: vec![\"D'\", \"A'.1\", \"A'\"]\n+    }]);\n+\n+    let errors = forest.to_errors(());\n+    assert_eq!(errors.len(), 0);\n+}\n+\n+#[test]\n+fn done_dependency() {\n+    // check that the local cache works\n+    let mut forest = ObligationForest::new();\n+    forest.register_obligation(\"A: Sized\");\n+    forest.register_obligation(\"B: Sized\");\n+    forest.register_obligation(\"C: Sized\");\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A: Sized\" | \"B: Sized\" | \"C: Sized\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok, vec![\"C: Sized\", \"B: Sized\", \"A: Sized\"]);\n+    assert_eq!(err.len(), 0);\n+\n+    forest.register_obligation(\"(A,B,C): Sized\");\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"(A,B,C): Sized\" => Ok(Some(vec![\n+                    \"A: Sized\",\n+                    \"B: Sized\",\n+                    \"C: Sized\"\n+                        ])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok, vec![\"(A,B,C): Sized\"]);\n+    assert_eq!(err.len(), 0);\n+\n+\n+}\n+\n+\n+#[test]\n+fn orphan() {\n+    // check that orphaned nodes are handled correctly\n+    let mut forest = ObligationForest::new();\n+    forest.register_obligation(\"A\");\n+    forest.register_obligation(\"B\");\n+    forest.register_obligation(\"C1\");\n+    forest.register_obligation(\"C2\");\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"A\" => Ok(Some(vec![\"D\", \"E\"])),\n+                \"B\" => Ok(None),\n+                \"C1\" => Ok(Some(vec![])),\n+                \"C2\" => Ok(Some(vec![])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok, vec![\"C2\", \"C1\"]);\n+    assert_eq!(err.len(), 0);\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"D\" | \"E\" => Ok(None),\n+                \"B\" => Ok(Some(vec![\"D\"])),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err.len(), 0);\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"D\" => Ok(None),\n+                \"E\" => Err(\"E is for error\"),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err, vec![super::Error {\n+        error: \"E is for error\",\n+        backtrace: vec![\"E\", \"A\"]\n+    }]);\n+\n+    let Outcome { completed: ok, errors: err, .. } =\n+        forest.process_obligations(&mut C(|obligation| {\n+            match *obligation {\n+                \"D\" => Err(\"D is dead\"),\n+                _ => unreachable!(),\n+            }\n+        }, |_|{}));\n+    assert_eq!(ok.len(), 0);\n+    assert_eq!(err, vec![super::Error {\n+        error: \"D is dead\",\n+        backtrace: vec![\"D\"]\n+    }]);\n+\n+    let errors = forest.to_errors(());\n+    assert_eq!(errors.len(), 0);\n }"}, {"sha": "4bf428ef46d9b4db5cc49918fd13e5b182d1bc38", "filename": "src/librustc_metadata/common.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc_metadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Flibrustc_metadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcommon.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -247,7 +247,8 @@ pub const tag_rustc_version: usize = 0x10f;\n pub fn rustc_version() -> String {\n     format!(\n         \"rustc {}\",\n-        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\")\n+//        option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\")\n+        \"nightly edition\"\n     )\n }\n "}, {"sha": "8aaf752125690d829c7e40518d6032191e8e8969", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -14,5 +14,4 @@ pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();\n     //~^ ERROR `Trait + Sized: std::marker::Sized` is not satisfied\n     //~| ERROR `Trait + Sized: std::marker::Sized` is not satisfied\n-    //~| ERROR `Trait + Sized: std::marker::Sized` is not satisfied\n }"}, {"sha": "2a86cdef9812fb88da2b80c8950634921f6648a9", "filename": "src/test/compile-fail/kindck-impl-type-params.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fkindck-impl-type-params.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -27,12 +27,14 @@ fn f<T>(val: T) {\n     let t: S<T> = S(marker::PhantomData);\n     let a = &t as &Gettable<T>;\n     //~^ ERROR : std::marker::Send` is not satisfied\n+    //~^^ ERROR : std::marker::Copy` is not satisfied\n }\n \n fn g<T>(val: T) {\n     let t: S<T> = S(marker::PhantomData);\n     let a: &Gettable<T> = &t;\n     //~^ ERROR : std::marker::Send` is not satisfied\n+    //~^^ ERROR : std::marker::Copy` is not satisfied\n }\n \n fn foo<'a>() {"}, {"sha": "58c0791b84ec5b25c05e30dc063c1a6a444e9b4c", "filename": "src/test/compile-fail/not-panic-safe-2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-2.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -18,6 +18,7 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<Rc<RefCell<i32>>>(); //~ ERROR E0277\n+    assert::<Rc<RefCell<i32>>>();\n+    //~^ ERROR `std::cell::UnsafeCell<i32>: std::panic::RefUnwindSafe` is not satisfied\n+    //~^^ ERROR `std::cell::UnsafeCell<usize>: std::panic::RefUnwindSafe` is not satisfied\n }\n-"}, {"sha": "481ffb802812a02f30718384c32fa9b4f6690d57", "filename": "src/test/compile-fail/not-panic-safe-3.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-3.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -18,5 +18,7 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<Arc<RefCell<i32>>>(); //~ ERROR E0277\n+    assert::<Arc<RefCell<i32>>>();\n+    //~^ ERROR `std::cell::UnsafeCell<i32>: std::panic::RefUnwindSafe` is not satisfied\n+    //~^^ ERROR `std::cell::UnsafeCell<usize>: std::panic::RefUnwindSafe` is not satisfied\n }"}, {"sha": "47302d3af78b2909d8159a4d3fb5dab267267e23", "filename": "src/test/compile-fail/not-panic-safe-4.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-4.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -17,5 +17,7 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<&RefCell<i32>>(); //~ ERROR E0277\n+    assert::<&RefCell<i32>>();\n+    //~^ ERROR `std::cell::UnsafeCell<i32>: std::panic::RefUnwindSafe` is not satisfied\n+    //~^^ ERROR `std::cell::UnsafeCell<usize>: std::panic::RefUnwindSafe` is not satisfied\n }"}, {"sha": "fe13b0a75c9eb18dd7f7de6ad99b7e42c74e7543", "filename": "src/test/compile-fail/not-panic-safe-6.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-panic-safe-6.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -17,6 +17,7 @@ use std::cell::RefCell;\n fn assert<T: RecoverSafe + ?Sized>() {}\n \n fn main() {\n-    assert::<*mut RefCell<i32>>(); //~ ERROR E0277\n+    assert::<*mut RefCell<i32>>();\n+    //~^ ERROR `std::cell::UnsafeCell<i32>: std::panic::RefUnwindSafe` is not satisfied\n+    //~^^ ERROR `std::cell::UnsafeCell<usize>: std::panic::RefUnwindSafe` is not satisfied\n }\n-"}, {"sha": "5b0dd256b4c41788670d51f2c66f4fddc3d30a4e", "filename": "src/test/compile-fail/range-1.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Frange-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frange-1.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -17,7 +17,9 @@ pub fn main() {\n \n     // Bool => does not implement iterator.\n     for i in false..true {}\n-    //~^ ERROR E0277\n+    //~^ ERROR `bool: std::num::One` is not satisfied\n+    //~^^ ERROR `bool: std::iter::Step` is not satisfied\n+    //~^^^ ERROR `for<'a> &'a bool: std::ops::Add` is not satisfied\n \n     // Unsized type.\n     let arr: &[_] = &[1, 2, 3];"}, {"sha": "2d4df77f960452a126928ce40ee05fb108324012", "filename": "src/test/compile-fail/trait-test-2.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/957500b79348a89b2148a6d20f7de6c10af4eea2/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-test-2.rs?ref=957500b79348a89b2148a6d20f7de6c10af4eea2", "patch": "@@ -21,7 +21,5 @@ fn main() {\n     (box 10 as Box<bar>).dup();\n     //~^ ERROR E0038\n     //~| ERROR E0038\n-    //~| ERROR E0038\n-    //~| ERROR E0038\n     //~| ERROR E0277\n }"}]}