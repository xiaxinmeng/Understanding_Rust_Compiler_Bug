{"sha": "923483e321acace3bbf38688bd70d4d38f49b35e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyMzQ4M2UzMjFhY2FjZTNiYmYzODY4OGJkNzBkNGQzOGY0OWIzNWU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-15T11:57:03Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-15T11:57:03Z"}, "message": "Merge #203\n\n203: Add roadmap r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\nCo-authored-by: Adolfo Ochagav\u00eda <github@adolfo.ochagavia.xyz>", "tree": {"sha": "869e0cfd0ed84c56dd519401096ef629c1fb67de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/869e0cfd0ed84c56dd519401096ef629c1fb67de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/923483e321acace3bbf38688bd70d4d38f49b35e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/923483e321acace3bbf38688bd70d4d38f49b35e", "html_url": "https://github.com/rust-lang/rust/commit/923483e321acace3bbf38688bd70d4d38f49b35e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/923483e321acace3bbf38688bd70d4d38f49b35e/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "9aebd9e6caf49467ca20caf2583c47cf5092c788", "url": "https://api.github.com/repos/rust-lang/rust/commits/9aebd9e6caf49467ca20caf2583c47cf5092c788", "html_url": "https://github.com/rust-lang/rust/commit/9aebd9e6caf49467ca20caf2583c47cf5092c788"}, {"sha": "a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28", "html_url": "https://github.com/rust-lang/rust/commit/a9cd2d60bc6d22854cbcb30ef73bbd3c79a8df28"}], "stats": {"total": 77, "additions": 77, "deletions": 0}, "files": [{"sha": "951a092b438e90cabed6f0dc9ebec7e6b06000bc", "filename": "ROADMAP.md", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/923483e321acace3bbf38688bd70d4d38f49b35e/ROADMAP.md", "raw_url": "https://github.com/rust-lang/rust/raw/923483e321acace3bbf38688bd70d4d38f49b35e/ROADMAP.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/ROADMAP.md?ref=923483e321acace3bbf38688bd70d4d38f49b35e", "patch": "@@ -0,0 +1,77 @@\n+# Rust Analyzer Roadmap 01\n+\n+Written on 2018-11-06, extends approximately to February 2019.\n+After that, we should coordinate with the compiler/rls developers to align goals and share code and experience.\n+\n+\n+# Overall Goals\n+\n+The mission is:\n+  * Provide an excellent \"code analyzed as you type\" IDE experience for the Rust language,\n+  * Implement the bulk of the features in Rust itself.\n+\n+\n+High-level architecture constraints:\n+  * Long-term, replace the current rustc frontend.\n+    It's *obvious* that the code should be shared, but OTOH, all great IDEs started as from-scratch rewrites.\n+  * Don't hard-code a particular protocol or mode of operation.\n+    Produce a library which could be used for implementing an LSP server, or for in-process embedding.\n+  * As long as possible, stick with stable Rust (NB: we currently use beta for 2018 edition and salsa).\n+\n+\n+# Current Goals\n+\n+Ideally, we would be coordinating with the compiler/rls teams, but they are busy working on making Rust 2018 at the moment.\n+The sync-up point will happen some time after the edition, probably early 2019.\n+In the meantime, the goal is to **experiment**, specifically, to figure out how a from-scratch written RLS might look like.\n+\n+\n+## Data Storage and Protocol implementation\n+\n+The fundamental part of any architecture is who owns which data, how the data is mutated and how the data is exposed to user.\n+For storage we use the [salsa](http://github.com/salsa-rs/salsa) library, which provides a solid model that seems to be the way to go.\n+\n+Modification to source files is mostly driven by the language client, but we also should support watching the file system. The current\n+file watching implementation is a stub.\n+\n+**Action Item:** implement reliable file watching service.\n+\n+We also should extract LSP bits as a reusable library. There's already `gen_lsp_server`, but it is pretty limited.\n+\n+**Action Item:** try using `gen_lsp_server` in more than one language server, for example for TOML and Nix.\n+\n+The ideal architecture for `gen_lsp_server` is still unclear. I'd rather avoid futures: they bring significant runtime complexity\n+(call stacks become insane) and the performance benefits are negligible for our use case (one thread per request is perfectly OK given\n+the low amount of requests a language server receives). The current interface is based on crossbeam-channel, but it's not clear\n+if that is the best choice.\n+\n+\n+## Low-effort, high payoff features\n+\n+Implementing 20% of type inference will give use 80% of completion.\n+Thus it makes sense to partially implement name resolution, type inference and trait matching, even though there is a chance that\n+this code is replaced later on when we integrate with the compiler\n+\n+Specifically, we need to:\n+\n+* **Action Item:** implement path resolution, so that we get completion in imports and such.\n+* **Action Item:** implement simple type inference, so that we get completion for inherent methods.\n+* **Action Item:** implement nicer completion infrastructure, so that we have icons, snippets, doc comments, after insert callbacks, ...\n+\n+\n+## Dragons to kill\n+\n+To make experiments most effective, we should try to prototype solutions for the hardest problems.\n+In the case of Rust, the two hardest problems are:\n+  * Conditional compilation and source/model mismatch.\n+    A single source file might correspond to several entities in the semantic model.\n+    For example, different cfg flags produce effectively different crates from the same source.\n+  * Macros are intertwined with name resolution in a single fix-point iteration algorithm.\n+    This is just plain hard to implement, but also interacts poorly with on-demand.\n+\n+\n+For the first bullet point, we need to design descriptors infra and explicit mapping step between sources and semantic model, which is intentionally fuzzy in one direction.\n+The **action item** here is basically \"write code, see what works, keep high-level picture in mind\".\n+\n+For the second bullet point, there's hope that salsa with its deep memoization will result in a fast enough solution even without being fully on-demand.\n+Again, the **action item** is to write the code and see what works. Salsa itself uses macros heavily, so it should be a great test."}]}