{"sha": "c98ca953b07c2afb8dd7ceab1215249e94c3025d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5OGNhOTUzYjA3YzJhZmI4ZGQ3Y2VhYjEyMTUyNDllOTRjMzAyNWQ=", "commit": {"author": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2017-06-15T05:49:07Z"}, "committer": {"name": "Taylor Cramer", "email": "cramertj@google.com", "date": "2017-06-15T05:49:07Z"}, "message": "Switch CrateNum queries to DefId", "tree": {"sha": "d30d90f4f8807d175a587ab71f1c9e3dfdd72705", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d30d90f4f8807d175a587ab71f1c9e3dfdd72705"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c98ca953b07c2afb8dd7ceab1215249e94c3025d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c98ca953b07c2afb8dd7ceab1215249e94c3025d", "html_url": "https://github.com/rust-lang/rust/commit/c98ca953b07c2afb8dd7ceab1215249e94c3025d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c98ca953b07c2afb8dd7ceab1215249e94c3025d/comments", "author": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cramertj", "id": 5963049, "node_id": "MDQ6VXNlcjU5NjMwNDk=", "avatar_url": "https://avatars.githubusercontent.com/u/5963049?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cramertj", "html_url": "https://github.com/cramertj", "followers_url": "https://api.github.com/users/cramertj/followers", "following_url": "https://api.github.com/users/cramertj/following{/other_user}", "gists_url": "https://api.github.com/users/cramertj/gists{/gist_id}", "starred_url": "https://api.github.com/users/cramertj/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cramertj/subscriptions", "organizations_url": "https://api.github.com/users/cramertj/orgs", "repos_url": "https://api.github.com/users/cramertj/repos", "events_url": "https://api.github.com/users/cramertj/events{/privacy}", "received_events_url": "https://api.github.com/users/cramertj/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48356987c18d77605342d3bd5f5dc98d88f1d245", "url": "https://api.github.com/repos/rust-lang/rust/commits/48356987c18d77605342d3bd5f5dc98d88f1d245", "html_url": "https://github.com/rust-lang/rust/commit/48356987c18d77605342d3bd5f5dc98d88f1d245"}], "stats": {"total": 212, "additions": 96, "deletions": 116}, "files": [{"sha": "c987a37c420d80c84b471805c31110276130da1e", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c98ca953b07c2afb8dd7ceab1215249e94c3025d", "patch": "@@ -305,7 +305,6 @@ define_dep_nodes!(\n     // Represents the metadata for a given HIR node, typically found\n     // in an extern crate.\n     MetaData(DefId),\n-    MetaDataByCrateNum(CrateNum),\n \n     // Represents some artifact that we save to disk. Note that these\n     // do not have a def-id as part of their identifier."}, {"sha": "95a27f065999c21bf00def7fdcf1acacc2ef5f6d", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=c98ca953b07c2afb8dd7ceab1215249e94c3025d", "patch": "@@ -58,6 +58,8 @@ impl CrateNum {\n     pub fn as_u32(&self) -> u32 {\n         self.0\n     }\n+\n+    pub fn as_def_id(&self) -> DefId { DefId { krate: *self, index: CRATE_DEF_INDEX } }\n }\n \n impl fmt::Display for CrateNum {"}, {"sha": "4e1f06cca06cc087b4b869db74ab7645c4d02c29", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=c98ca953b07c2afb8dd7ceab1215249e94c3025d", "patch": "@@ -172,7 +172,7 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if src.dylib.is_some() {\n             info!(\"adding dylib: {}\", name);\n             add_library(sess, cnum, RequireDynamic, &mut formats);\n-            let deps = tcx.dylib_dependency_formats(cnum);\n+            let deps = tcx.dylib_dependency_formats(cnum.as_def_id());\n             for &(depnum, style) in deps.iter() {\n                 info!(\"adding {:?}: {}\", style,\n                       sess.cstore.crate_name(depnum));\n@@ -215,9 +215,9 @@ fn calculate_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // Things like allocators and panic runtimes may not have been activated\n     // quite yet, so do so here.\n     activate_injected_dep(sess.injected_allocator.get(), &mut ret,\n-                          &|cnum| tcx.is_allocator(cnum));\n+                          &|cnum| tcx.is_allocator(cnum.as_def_id()));\n     activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum));\n+                          &|cnum| tcx.is_panic_runtime(cnum.as_def_id()));\n \n     // When dylib B links to dylib A, then when using B we must also link to A.\n     // It could be the case, however, that the rlib for A is present (hence we\n@@ -296,9 +296,9 @@ fn attempt_static<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<DependencyLis\n     // explicitly linked, which is the case for any injected dependency. Handle\n     // that here and activate them.\n     activate_injected_dep(sess.injected_allocator.get(), &mut ret,\n-                          &|cnum| tcx.is_allocator(cnum));\n+                          &|cnum| tcx.is_allocator(cnum.as_def_id()));\n     activate_injected_dep(sess.injected_panic_runtime.get(), &mut ret,\n-                          &|cnum| tcx.is_panic_runtime(cnum));\n+                          &|cnum| tcx.is_panic_runtime(cnum.as_def_id()));\n \n     Some(ret)\n }\n@@ -345,7 +345,7 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n             continue\n         }\n         let cnum = CrateNum::new(i + 1);\n-        if tcx.is_allocator(cnum) {\n+        if tcx.is_allocator(cnum.as_def_id()) {\n             if let Some(prev) = allocator {\n                 let prev_name = sess.cstore.crate_name(prev);\n                 let cur_name = sess.cstore.crate_name(cnum);\n@@ -356,7 +356,7 @@ fn verify_ok<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, list: &[Linkage]) {\n             allocator = Some(cnum);\n         }\n \n-        if tcx.is_panic_runtime(cnum) {\n+        if tcx.is_panic_runtime(cnum.as_def_id()) {\n             if let Some((prev, _)) = panic_runtime {\n                 let prev_name = sess.cstore.crate_name(prev);\n                 let cur_name = sess.cstore.crate_name(cnum);"}, {"sha": "09a3bcd06138056afaa89b6641d415a5b8ab4c56", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=c98ca953b07c2afb8dd7ceab1215249e94c3025d", "patch": "@@ -100,7 +100,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 //\n                 // Returns `None` for the local crate.\n                 if cnum != LOCAL_CRATE {\n-                    let opt_extern_crate = self.extern_crate(cnum);\n+                    let opt_extern_crate = self.extern_crate(cnum.as_def_id());\n                     let opt_extern_crate = opt_extern_crate.and_then(|extern_crate| {\n                         if extern_crate.direct {\n                             Some(extern_crate.def_id)\n@@ -136,7 +136,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             // If `cur_def` is a direct or injected extern crate, push the path to the crate\n             // followed by the path to the item within the crate and return.\n             if cur_def.index == CRATE_DEF_INDEX {\n-                match *self.extern_crate(cur_def.krate) {\n+                match *self.extern_crate(cur_def) {\n                     Some(ref extern_crate) if extern_crate.direct => {\n                         self.push_item_path(buffer, extern_crate.def_id);\n                         cur_path.iter().rev().map(|segment| buffer.push(&segment.as_str())).count();"}, {"sha": "dccc0a8283a9c5494c585922795ea4f5115bf217", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=c98ca953b07c2afb8dd7ceab1215249e94c3025d", "patch": "@@ -484,25 +484,25 @@ impl<'tcx> QueryDescription for queries::is_const_fn<'tcx> {\n }\n \n impl<'tcx> QueryDescription for queries::dylib_dependency_formats<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n         \"dylib dependency formats of crate\".to_string()\n     }\n }\n \n impl<'tcx> QueryDescription for queries::is_allocator<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n         \"checking if the crate is_allocator\".to_string()\n     }\n }\n \n impl<'tcx> QueryDescription for queries::is_panic_runtime<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n         \"checking if the crate is_panic_runtime\".to_string()\n     }\n }\n \n impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n-    fn describe(_: TyCtxt, _: CrateNum) -> String {\n+    fn describe(_: TyCtxt, _: DefId) -> String {\n         \"getting crate's ExternCrateData\".to_string()\n     }\n }\n@@ -964,13 +964,13 @@ define_maps! { <'tcx>\n     [] layout_raw: layout_dep_node(ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                                   -> Result<&'tcx Layout, LayoutError<'tcx>>,\n \n-    [] dylib_dependency_formats: MetaDataByCrateNum(CrateNum)\n+    [] dylib_dependency_formats: MetaData(DefId)\n                                     -> Rc<Vec<(CrateNum, LinkagePreference)>>,\n \n-    [] is_allocator: MetaDataByCrateNum(CrateNum) -> bool,\n-    [] is_panic_runtime: MetaDataByCrateNum(CrateNum) -> bool,\n+    [] is_allocator: MetaData(DefId) -> bool,\n+    [] is_panic_runtime: MetaData(DefId) -> bool,\n \n-    [] extern_crate: MetaDataByCrateNum(CrateNum) -> Rc<Option<ExternCrate>>,\n+    [] extern_crate: MetaData(DefId) -> Rc<Option<ExternCrate>>,\n }\n \n fn type_param_predicates((item_id, param_id): (DefId, DefId)) -> DepConstructor {"}, {"sha": "7e85c277979903cf161ec042110e94d8d773b480", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 74, "deletions": 95, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=c98ca953b07c2afb8dd7ceab1215249e94c3025d", "patch": "@@ -40,17 +40,10 @@ use rustc::hir::svh::Svh;\n use rustc::hir;\n \n macro_rules! provide {\n-    (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident, $cnum:ident,\n-        ByDefId {\n-            $($cdata_fn_name:ident => $cdata_fn_compute:block)*\n-        }\n-        ByCrateNum {\n-            $($cnum_fn_name:ident => $cnum_fn_compute:block)*\n-        }\n-    )=> {\n+    (<$lt:tt> $tcx:ident, $def_id:ident, $cdata:ident, $($name:ident => $compute:block)*) => {\n         pub fn provide<$lt>(providers: &mut Providers<$lt>) {\n-            $(fn $cdata_fn_name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n-                                    -> <ty::queries::$cdata_fn_name<$lt> as\n+            $(fn $name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $def_id: DefId)\n+                                    -> <ty::queries::$name<$lt> as\n                                         DepTrackingMapConfig>::Value {\n                 assert!(!$def_id.is_local());\n \n@@ -62,102 +55,88 @@ macro_rules! provide {\n                 let $cdata = $tcx.sess.cstore.crate_data_as_rc_any($def_id.krate);\n                 let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n                     .expect(\"CrateStore crated ata is not a CrateMetadata\");\n-                $cdata_fn_compute\n-            })*\n-\n-            $(fn $cnum_fn_name<'a, $lt:$lt>($tcx: TyCtxt<'a, $lt, $lt>, $cnum: CrateNum)\n-                        -> <ty::queries::$cnum_fn_name<$lt> as\n-                            DepTrackingMapConfig>::Value {\n-                let $cdata = $tcx.sess.cstore.crate_data_as_rc_any($cnum);\n-                let $cdata = $cdata.downcast_ref::<cstore::CrateMetadata>()\n-                    .expect(\"CrateStore crated ata is not a CrateMetadata\");\n-                $cnum_fn_compute\n+                $compute\n             })*\n \n             *providers = Providers {\n-                $($cdata_fn_name,)*\n-                $($cnum_fn_name,)*\n+                $($name,)*\n                 ..*providers\n             };\n         }\n     }\n }\n \n-provide! { <'tcx> tcx, def_id, cdata, cnum,\n-    ByDefId {\n-        type_of => { cdata.get_type(def_id.index, tcx) }\n-        generics_of => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n-        predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n-        super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n-        trait_def => {\n-            tcx.alloc_trait_def(cdata.get_trait_def(def_id.index))\n-        }\n-        adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n-        adt_destructor => {\n-            let _ = cdata;\n-            tcx.calculate_dtor(def_id, &mut |_,_| Ok(()))\n-        }\n-        variances_of => { Rc::new(cdata.get_item_variances(def_id.index)) }\n-        associated_item_def_ids => {\n-            let mut result = vec![];\n-            cdata.each_child_of_item(def_id.index,\n-              |child| result.push(child.def.def_id()), tcx.sess);\n-            Rc::new(result)\n-        }\n-        associated_item => { cdata.get_associated_item(def_id.index) }\n-        impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n-        impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n-        coerce_unsized_info => {\n-            cdata.get_coerce_unsized_info(def_id.index).unwrap_or_else(|| {\n-                bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n-            })\n-        }\n-        optimized_mir => {\n-            let mir = cdata.maybe_get_optimized_mir(tcx, def_id.index).unwrap_or_else(|| {\n-                bug!(\"get_optimized_mir: missing MIR for `{:?}`\", def_id)\n-            });\n-\n-            let mir = tcx.alloc_mir(mir);\n-\n-            mir\n-        }\n-        mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n-        typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n-        closure_kind => { cdata.closure_kind(def_id.index) }\n-        closure_type => { cdata.closure_ty(def_id.index, tcx) }\n-        inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n-        is_const_fn => { cdata.is_const_fn(def_id.index) }\n-        is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n-        is_default_impl => { cdata.is_default_impl(def_id.index) }\n-        describe_def => { cdata.get_def(def_id.index) }\n-        def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n-        stability => { cdata.get_stability(def_id.index) }\n-        deprecation => { cdata.get_deprecation(def_id.index) }\n-        item_attrs => { cdata.get_item_attrs(def_id.index, &tcx.dep_graph) }\n-        // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n-        // a `fn` when encoding, so the dep-tracking wouldn't work.\n-        // This is only used by rustdoc anyway, which shouldn't have\n-        // incremental recompilation ever enabled.\n-        fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n-        impl_parent => { cdata.get_parent_impl(def_id.index) }\n-        trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n-        is_exported_symbol => {\n-            let dep_node = cdata.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n-            cdata.exported_symbols.get(&tcx.dep_graph, dep_node).contains(&def_id.index)\n-        }\n-        item_body_nested_bodies => { Rc::new(cdata.item_body_nested_bodies(def_id.index)) }\n-        const_is_rvalue_promotable_to_static => {\n-            cdata.const_is_rvalue_promotable_to_static(def_id.index)\n-        }\n-        is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n+provide! { <'tcx> tcx, def_id, cdata,\n+    type_of => { cdata.get_type(def_id.index, tcx) }\n+    generics_of => { tcx.alloc_generics(cdata.get_generics(def_id.index)) }\n+    predicates_of => { cdata.get_predicates(def_id.index, tcx) }\n+    super_predicates_of => { cdata.get_super_predicates(def_id.index, tcx) }\n+    trait_def => {\n+        tcx.alloc_trait_def(cdata.get_trait_def(def_id.index))\n+    }\n+    adt_def => { cdata.get_adt_def(def_id.index, tcx) }\n+    adt_destructor => {\n+        let _ = cdata;\n+        tcx.calculate_dtor(def_id, &mut |_,_| Ok(()))\n+    }\n+    variances_of => { Rc::new(cdata.get_item_variances(def_id.index)) }\n+    associated_item_def_ids => {\n+        let mut result = vec![];\n+        cdata.each_child_of_item(def_id.index,\n+          |child| result.push(child.def.def_id()), tcx.sess);\n+        Rc::new(result)\n+    }\n+    associated_item => { cdata.get_associated_item(def_id.index) }\n+    impl_trait_ref => { cdata.get_impl_trait(def_id.index, tcx) }\n+    impl_polarity => { cdata.get_impl_polarity(def_id.index) }\n+    coerce_unsized_info => {\n+        cdata.get_coerce_unsized_info(def_id.index).unwrap_or_else(|| {\n+            bug!(\"coerce_unsized_info: `{:?}` is missing its info\", def_id);\n+        })\n     }\n+    optimized_mir => {\n+        let mir = cdata.maybe_get_optimized_mir(tcx, def_id.index).unwrap_or_else(|| {\n+            bug!(\"get_optimized_mir: missing MIR for `{:?}`\", def_id)\n+        });\n \n-    ByCrateNum {\n-        dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats(&tcx.dep_graph)) }\n-        is_allocator => { cdata.is_allocator(&tcx.dep_graph) }\n-        is_panic_runtime => { cdata.is_panic_runtime(&tcx.dep_graph) }\n-        extern_crate => { Rc::new(cdata.extern_crate.get()) }\n-    }\n+        let mir = tcx.alloc_mir(mir);\n+\n+        mir\n+    }\n+    mir_const_qualif => { cdata.mir_const_qualif(def_id.index) }\n+    typeck_tables_of => { cdata.item_body_tables(def_id.index, tcx) }\n+    closure_kind => { cdata.closure_kind(def_id.index) }\n+    closure_type => { cdata.closure_ty(def_id.index, tcx) }\n+    inherent_impls => { Rc::new(cdata.get_inherent_implementations_for_type(def_id.index)) }\n+    is_const_fn => { cdata.is_const_fn(def_id.index) }\n+    is_foreign_item => { cdata.is_foreign_item(def_id.index) }\n+    is_default_impl => { cdata.is_default_impl(def_id.index) }\n+    describe_def => { cdata.get_def(def_id.index) }\n+    def_span => { cdata.get_span(def_id.index, &tcx.sess) }\n+    stability => { cdata.get_stability(def_id.index) }\n+    deprecation => { cdata.get_deprecation(def_id.index) }\n+    item_attrs => { cdata.get_item_attrs(def_id.index, &tcx.dep_graph) }\n+    // FIXME(#38501) We've skipped a `read` on the `HirBody` of\n+    // a `fn` when encoding, so the dep-tracking wouldn't work.\n+    // This is only used by rustdoc anyway, which shouldn't have\n+    // incremental recompilation ever enabled.\n+    fn_arg_names => { cdata.get_fn_arg_names(def_id.index) }\n+    impl_parent => { cdata.get_parent_impl(def_id.index) }\n+    trait_of_item => { cdata.get_trait_of_item(def_id.index) }\n+    is_exported_symbol => {\n+        let dep_node = cdata.metadata_dep_node(GlobalMetaDataKind::ExportedSymbols);\n+        cdata.exported_symbols.get(&tcx.dep_graph, dep_node).contains(&def_id.index)\n+    }\n+    item_body_nested_bodies => { Rc::new(cdata.item_body_nested_bodies(def_id.index)) }\n+    const_is_rvalue_promotable_to_static => {\n+        cdata.const_is_rvalue_promotable_to_static(def_id.index)\n+    }\n+    is_mir_available => { cdata.is_item_mir_available(def_id.index) }\n+\n+    dylib_dependency_formats => { Rc::new(cdata.get_dylib_dependency_formats(&tcx.dep_graph)) }\n+    is_allocator => { cdata.is_allocator(&tcx.dep_graph) }\n+    is_panic_runtime => { cdata.is_panic_runtime(&tcx.dep_graph) }\n+    extern_crate => { Rc::new(cdata.extern_crate.get()) }\n }\n \n pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {"}, {"sha": "4ab2c1aa63c5c89d1664040bfc990cdf5b730eab", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c98ca953b07c2afb8dd7ceab1215249e94c3025d", "patch": "@@ -107,7 +107,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let mut result = Vec::new();\n \n         for n in self.tcx.sess.cstore.crates() {\n-            let span = match *self.tcx.extern_crate(n) {\n+            let span = match *self.tcx.extern_crate(n.as_def_id()) {\n                 Some(ref c) => c.span,\n                 None => {\n                     debug!(\"Skipping crate {}, no data\", n);"}, {"sha": "b38dc18838923196d527ee64900398c7a4f6c8bb", "filename": "src/librustc_trans/back/symbol_export.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c98ca953b07c2afb8dd7ceab1215249e94c3025d/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fsymbol_export.rs?ref=c98ca953b07c2afb8dd7ceab1215249e94c3025d", "patch": "@@ -92,8 +92,8 @@ impl ExportedSymbols {\n             // Down below we'll hardwire all of the symbols to the `Rust` export\n             // level instead.\n             let special_runtime_crate =\n-                scx.tcx().is_allocator(cnum) ||\n-                scx.tcx().is_panic_runtime(cnum) ||\n+                scx.tcx().is_allocator(cnum.as_def_id()) ||\n+                scx.tcx().is_panic_runtime(cnum.as_def_id()) ||\n                 scx.sess().cstore.is_compiler_builtins(cnum);\n \n             let crate_exports = scx"}]}