{"sha": "90eb44a5897c39e3dff9c7e48e3973671dcd9496", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZWI0NGE1ODk3YzM5ZTNkZmY5YzdlNDhlMzk3MzY3MWRjZDk0OTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-29T19:47:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-29T19:47:48Z"}, "message": "Auto merge of #47837 - eddyb:going-places, r=nikomatsakis\n\nReplace \"lvalue\" terminology with \"place\".\n\nSee #46425 for the previous PR (which only changed MIR-related code).\n\nr? @nikomatsakis", "tree": {"sha": "1212800f0d1d177b48815a15bf863498fc88f611", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1212800f0d1d177b48815a15bf863498fc88f611"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90eb44a5897c39e3dff9c7e48e3973671dcd9496", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90eb44a5897c39e3dff9c7e48e3973671dcd9496", "html_url": "https://github.com/rust-lang/rust/commit/90eb44a5897c39e3dff9c7e48e3973671dcd9496", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90eb44a5897c39e3dff9c7e48e3973671dcd9496/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "70f7d5842f29d4900f24420b030f144d21f3c5fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/70f7d5842f29d4900f24420b030f144d21f3c5fc", "html_url": "https://github.com/rust-lang/rust/commit/70f7d5842f29d4900f24420b030f144d21f3c5fc"}, {"sha": "bba81c975d9136d2bf10413826c743d25e54d97b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bba81c975d9136d2bf10413826c743d25e54d97b", "html_url": "https://github.com/rust-lang/rust/commit/bba81c975d9136d2bf10413826c743d25e54d97b"}], "stats": {"total": 953, "additions": 470, "deletions": 483}, "files": [{"sha": "297586f140e346e91391f075d68a2d56adf11224", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -1034,10 +1034,10 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           }\n \n           hir::ExprAssign(ref l, ref r) => {\n-            // see comment on lvalues in\n-            // propagate_through_lvalue_components()\n-            let succ = self.write_lvalue(&l, succ, ACC_WRITE);\n-            let succ = self.propagate_through_lvalue_components(&l, succ);\n+            // see comment on places in\n+            // propagate_through_place_components()\n+            let succ = self.write_place(&l, succ, ACC_WRITE);\n+            let succ = self.propagate_through_place_components(&l, succ);\n             self.propagate_through_expr(&r, succ)\n           }\n \n@@ -1047,11 +1047,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 let succ = self.propagate_through_expr(&l, succ);\n                 self.propagate_through_expr(&r, succ)\n             } else {\n-                // see comment on lvalues in\n-                // propagate_through_lvalue_components()\n-                let succ = self.write_lvalue(&l, succ, ACC_WRITE|ACC_READ);\n+                // see comment on places in\n+                // propagate_through_place_components()\n+                let succ = self.write_place(&l, succ, ACC_WRITE|ACC_READ);\n                 let succ = self.propagate_through_expr(&r, succ);\n-                self.propagate_through_lvalue_components(&l, succ)\n+                self.propagate_through_place_components(&l, succ)\n             }\n           }\n \n@@ -1121,14 +1121,14 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n           hir::ExprInlineAsm(ref ia, ref outputs, ref inputs) => {\n             let succ = ia.outputs.iter().zip(outputs).rev().fold(succ, |succ, (o, output)| {\n-                // see comment on lvalues\n-                // in propagate_through_lvalue_components()\n+                // see comment on places\n+                // in propagate_through_place_components()\n                 if o.is_indirect {\n                     self.propagate_through_expr(output, succ)\n                 } else {\n                     let acc = if o.is_rw { ACC_WRITE|ACC_READ } else { ACC_WRITE };\n-                    let succ = self.write_lvalue(output, succ, acc);\n-                    self.propagate_through_lvalue_components(output, succ)\n+                    let succ = self.write_place(output, succ, acc);\n+                    self.propagate_through_place_components(output, succ)\n                 }\n             });\n \n@@ -1146,11 +1146,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_through_lvalue_components(&mut self,\n+    fn propagate_through_place_components(&mut self,\n                                            expr: &Expr,\n                                            succ: LiveNode)\n                                            -> LiveNode {\n-        // # Lvalues\n+        // # Places\n         //\n         // In general, the full flow graph structure for an\n         // assignment/move/etc can be handled in one of two ways,\n@@ -1160,15 +1160,15 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         //\n         // The two kinds of graphs are:\n         //\n-        //    Tracked lvalue          Untracked lvalue\n+        //    Tracked place          Untracked place\n         // ----------------------++-----------------------\n         //                       ||\n         //         |             ||           |\n         //         v             ||           v\n         //     (rvalue)          ||       (rvalue)\n         //         |             ||           |\n         //         v             ||           v\n-        // (write of lvalue)     ||   (lvalue components)\n+        // (write of place)     ||   (place components)\n         //         |             ||           |\n         //         v             ||           v\n         //      (succ)           ||        (succ)\n@@ -1177,25 +1177,25 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         //\n         // I will cover the two cases in turn:\n         //\n-        // # Tracked lvalues\n+        // # Tracked places\n         //\n-        // A tracked lvalue is a local variable/argument `x`.  In\n+        // A tracked place is a local variable/argument `x`.  In\n         // these cases, the link_node where the write occurs is linked\n-        // to node id of `x`.  The `write_lvalue()` routine generates\n+        // to node id of `x`.  The `write_place()` routine generates\n         // the contents of this node.  There are no subcomponents to\n         // consider.\n         //\n-        // # Non-tracked lvalues\n+        // # Non-tracked places\n         //\n-        // These are lvalues like `x[5]` or `x.f`.  In that case, we\n+        // These are places like `x[5]` or `x.f`.  In that case, we\n         // basically ignore the value which is written to but generate\n         // reads for the components---`x` in these two examples.  The\n         // components reads are generated by\n-        // `propagate_through_lvalue_components()` (this fn).\n+        // `propagate_through_place_components()` (this fn).\n         //\n-        // # Illegal lvalues\n+        // # Illegal places\n         //\n-        // It is still possible to observe assignments to non-lvalues;\n+        // It is still possible to observe assignments to non-places;\n         // these errors are detected in the later pass borrowck.  We\n         // just ignore such cases and treat them as reads.\n \n@@ -1207,17 +1207,17 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         }\n     }\n \n-    // see comment on propagate_through_lvalue()\n-    fn write_lvalue(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n+    // see comment on propagate_through_place()\n+    fn write_place(&mut self, expr: &Expr, succ: LiveNode, acc: u32)\n                     -> LiveNode {\n         match expr.node {\n           hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n               self.access_path(expr.id, path, succ, acc)\n           }\n \n-          // We do not track other lvalues, so just propagate through\n+          // We do not track other places, so just propagate through\n           // to their subcomponents.  Also, it may happen that\n-          // non-lvalues occur here, because those are detected in the\n+          // non-places occur here, because those are detected in the\n           // later pass borrowck.\n           _ => succ\n         }\n@@ -1363,14 +1363,14 @@ fn check_arm<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, arm: &'tcx hir::Arm) {\n fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n     match expr.node {\n       hir::ExprAssign(ref l, _) => {\n-        this.check_lvalue(&l);\n+        this.check_place(&l);\n \n         intravisit::walk_expr(this, expr);\n       }\n \n       hir::ExprAssignOp(_, ref l, _) => {\n         if !this.tables.is_method_call(expr) {\n-            this.check_lvalue(&l);\n+            this.check_place(&l);\n         }\n \n         intravisit::walk_expr(this, expr);\n@@ -1381,10 +1381,10 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n           this.visit_expr(input);\n         }\n \n-        // Output operands must be lvalues\n+        // Output operands must be places\n         for (o, output) in ia.outputs.iter().zip(outputs) {\n           if !o.is_indirect {\n-            this.check_lvalue(output);\n+            this.check_place(output);\n           }\n           this.visit_expr(output);\n         }\n@@ -1409,7 +1409,7 @@ fn check_expr<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, expr: &'tcx Expr) {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn check_lvalue(&mut self, expr: &'tcx Expr) {\n+    fn check_place(&mut self, expr: &'tcx Expr) {\n         match expr.node {\n             hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n                 if let Def::Local(nid) = path.def {\n@@ -1423,7 +1423,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n                 }\n             }\n             _ => {\n-                // For other kinds of lvalues, no checks are required,\n+                // For other kinds of places, no checks are required,\n                 // and any embedded expressions are actually rvalues\n                 intravisit::walk_expr(self, expr);\n             }"}, {"sha": "45b595adfe7b8a8a5c104ecaf9ef0ffb9ee54cad", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -26,8 +26,8 @@\n //!       | E.comp    // access to an interior component\n //!\n //! Imagine a routine ToAddr(Expr) that evaluates an expression and returns an\n-//! address where the result is to be found.  If Expr is an lvalue, then this\n-//! is the address of the lvalue.  If Expr is an rvalue, this is the address of\n+//! address where the result is to be found.  If Expr is a place, then this\n+//! is the address of the place.  If Expr is an rvalue, this is the address of\n //! some temporary spot in memory where the result is stored.\n //!\n //! Now, cat_expr() classifies the expression Expr and the address A=ToAddr(Expr)\n@@ -182,7 +182,7 @@ pub struct cmt_<'tcx> {\n     pub id: ast::NodeId,           // id of expr/pat producing this value\n     pub span: Span,                // span of same expr/pat\n     pub cat: Categorization<'tcx>, // categorization of expr\n-    pub mutbl: MutabilityCategory, // mutability of expr as lvalue\n+    pub mutbl: MutabilityCategory, // mutability of expr as place\n     pub ty: Ty<'tcx>,              // type of the expr (*see WARNING above*)\n     pub note: Note,                // Note about the provenance of this cmt\n }\n@@ -517,7 +517,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                     // a bind-by-ref means that the base_ty will be the type of the ident itself,\n                     // but what we want here is the type of the underlying value being borrowed.\n                     // So peel off one-level, turning the &T into T.\n-                    match base_ty.builtin_deref(false, ty::NoPreference) {\n+                    match base_ty.builtin_deref(false) {\n                         Some(t) => t.ty,\n                         None => {\n                             debug!(\"By-ref binding of non-derefable type {:?}\", base_ty);\n@@ -603,7 +603,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         match expr.node {\n           hir::ExprUnary(hir::UnDeref, ref e_base) => {\n             if self.tables.is_method_call(expr) {\n-                self.cat_overloaded_lvalue(expr, e_base, false)\n+                self.cat_overloaded_place(expr, e_base, false)\n             } else {\n                 let base_cmt = self.cat_expr(&e_base)?;\n                 self.cat_deref(expr, base_cmt, false)\n@@ -631,7 +631,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n                 // The call to index() returns a `&T` value, which\n                 // is an rvalue. That is what we will be\n                 // dereferencing.\n-                self.cat_overloaded_lvalue(expr, base, true)\n+                self.cat_overloaded_place(expr, base, true)\n             } else {\n                 let base_cmt = self.cat_expr(&base)?;\n                 self.cat_index(expr, base_cmt, expr_ty, InteriorOffsetKind::Index)\n@@ -983,27 +983,27 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         ret\n     }\n \n-    fn cat_overloaded_lvalue(&self,\n+    fn cat_overloaded_place(&self,\n                              expr: &hir::Expr,\n                              base: &hir::Expr,\n                              implicit: bool)\n                              -> McResult<cmt<'tcx>> {\n-        debug!(\"cat_overloaded_lvalue: implicit={}\", implicit);\n+        debug!(\"cat_overloaded_place: implicit={}\", implicit);\n \n         // Reconstruct the output assuming it's a reference with the\n         // same region and mutability as the receiver. This holds for\n         // `Deref(Mut)::Deref(_mut)` and `Index(Mut)::index(_mut)`.\n-        let lvalue_ty = self.expr_ty(expr)?;\n+        let place_ty = self.expr_ty(expr)?;\n         let base_ty = self.expr_ty_adjusted(base)?;\n \n         let (region, mutbl) = match base_ty.sty {\n             ty::TyRef(region, mt) => (region, mt.mutbl),\n             _ => {\n-                span_bug!(expr.span, \"cat_overloaded_lvalue: base is not a reference\")\n+                span_bug!(expr.span, \"cat_overloaded_place: base is not a reference\")\n             }\n         };\n         let ref_ty = self.tcx.mk_ref(region, ty::TypeAndMut {\n-            ty: lvalue_ty,\n+            ty: place_ty,\n             mutbl,\n         });\n \n@@ -1019,7 +1019,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n         debug!(\"cat_deref: base_cmt={:?}\", base_cmt);\n \n         let base_cmt_ty = base_cmt.ty;\n-        let deref_ty = match base_cmt_ty.builtin_deref(true, ty::NoPreference) {\n+        let deref_ty = match base_cmt_ty.builtin_deref(true) {\n             Some(mt) => mt.ty,\n             None => {\n                 debug!(\"Explicit deref of non-derefable type: {:?}\",\n@@ -1386,7 +1386,7 @@ impl<'tcx> cmt_<'tcx> {\n         }\n     }\n \n-    /// Returns `FreelyAliasable(_)` if this lvalue represents a freely aliasable pointer type.\n+    /// Returns `FreelyAliasable(_)` if this place represents a freely aliasable pointer type.\n     pub fn freely_aliasable(&self) -> Aliasability {\n         // Maybe non-obvious: copied upvars can only be considered\n         // non-aliasable in once closures, since any other kind can be\n@@ -1453,7 +1453,7 @@ impl<'tcx> cmt_<'tcx> {\n                 \"static item\".to_string()\n             }\n             Categorization::Rvalue(..) => {\n-                \"non-lvalue\".to_string()\n+                \"non-place\".to_string()\n             }\n             Categorization::Local(vid) => {\n                 if tcx.hir.is_argument(vid) {"}, {"sha": "dad2d7a7c90fb4ffd33668b8b9844de3cd9cefa9", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -1112,7 +1112,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     //    I mean that creating a binding into a ref-counted or managed value\n     //    would still count.)\n     //\n-    // 3. `ET`, which matches both rvalues like `foo()` as well as lvalues\n+    // 3. `ET`, which matches both rvalues like `foo()` as well as places\n     //    based on rvalues like `foo().x[2].y`.\n     //\n     // A subexpression `<rvalue>` that appears in a let initializer\n@@ -1283,7 +1283,7 @@ fn resolve_local<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n     ///        | (ET)\n     ///        | <rvalue>\n     ///\n-    /// Note: ET is intended to match \"rvalues or lvalues based on rvalues\".\n+    /// Note: ET is intended to match \"rvalues or places based on rvalues\".\n     fn record_rvalue_scope<'a, 'tcx>(visitor: &mut RegionResolutionVisitor<'a, 'tcx>,\n                                      expr: &hir::Expr,\n                                      blk_scope: Option<Scope>) {"}, {"sha": "3b644aa13f321cc8e9183f3490b56432480f885d", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -733,29 +733,29 @@ pub enum TerminatorKind<'tcx> {\n     },\n \n     /// Drop the Place and assign the new value over it. This ensures\n-    /// that the assignment to LV occurs *even if* the destructor for\n+    /// that the assignment to `P` occurs *even if* the destructor for\n     /// place unwinds. Its semantics are best explained by by the\n     /// elaboration:\n     ///\n     /// ```\n     /// BB0 {\n-    ///   DropAndReplace(LV <- RV, goto BB1, unwind BB2)\n+    ///   DropAndReplace(P <- V, goto BB1, unwind BB2)\n     /// }\n     /// ```\n     ///\n     /// becomes\n     ///\n     /// ```\n     /// BB0 {\n-    ///   Drop(LV, goto BB1, unwind BB2)\n+    ///   Drop(P, goto BB1, unwind BB2)\n     /// }\n     /// BB1 {\n-    ///   // LV is now unitialized\n-    ///   LV <- RV\n+    ///   // P is now unitialized\n+    ///   P <- V\n     /// }\n     /// BB2 {\n-    ///   // LV is now unitialized -- its dtor panicked\n-    ///   LV <- RV\n+    ///   // P is now unitialized -- its dtor panicked\n+    ///   P <- V\n     /// }\n     /// ```\n     DropAndReplace {"}, {"sha": "53607764b3984ec4ddf1c27d1adfb68df640b873", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -52,7 +52,7 @@ impl<'a, 'gcx, 'tcx> PlaceTy<'tcx> {\n         match *elem {\n             ProjectionElem::Deref => {\n                 let ty = self.to_ty(tcx)\n-                             .builtin_deref(true, ty::LvaluePreference::NoPreference)\n+                             .builtin_deref(true)\n                              .unwrap_or_else(|| {\n                                  bug!(\"deref projection of non-dereferencable ty {:?}\", self)\n                              })"}, {"sha": "96d69b4fba21a9a0255db52ed91da9714cc2d184", "filename": "src/librustc/ty/adjustment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fty%2Fadjustment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fty%2Fadjustment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fadjustment.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -77,7 +77,7 @@ pub enum Adjust<'tcx> {\n     /// Go from a mut raw pointer to a const raw pointer.\n     MutToConstPointer,\n \n-    /// Dereference once, producing an lvalue.\n+    /// Dereference once, producing a place.\n     Deref(Option<OverloadedDeref<'tcx>>),\n \n     /// Take the address and produce either a `&` or `*` pointer."}, {"sha": "f52f2ea0f9fc8258b9d93964c6694a1da0cb9e9a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -12,7 +12,6 @@ pub use self::Variance::*;\n pub use self::AssociatedItemContainer::*;\n pub use self::BorrowKind::*;\n pub use self::IntVarValue::*;\n-pub use self::LvaluePreference::*;\n pub use self::fold::TypeFoldable;\n \n use hir::{map as hir_map, FreevarMap, TraitMap};\n@@ -2099,21 +2098,6 @@ impl<'tcx> TyS<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n-pub enum LvaluePreference {\n-    PreferMutLvalue,\n-    NoPreference\n-}\n-\n-impl LvaluePreference {\n-    pub fn from_mutbl(m: hir::Mutability) -> Self {\n-        match m {\n-            hir::MutMutable => PreferMutLvalue,\n-            hir::MutImmutable => NoPreference,\n-        }\n-    }\n-}\n-\n impl BorrowKind {\n     pub fn from_mutbl(m: hir::Mutability) -> BorrowKind {\n         match m {\n@@ -2193,60 +2177,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    pub fn expr_is_lval(self, expr: &hir::Expr) -> bool {\n-         match expr.node {\n-            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n-                match path.def {\n-                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n-                    _ => false,\n-                }\n-            }\n-\n-            hir::ExprType(ref e, _) => {\n-                self.expr_is_lval(e)\n-            }\n-\n-            hir::ExprUnary(hir::UnDeref, _) |\n-            hir::ExprField(..) |\n-            hir::ExprTupField(..) |\n-            hir::ExprIndex(..) => {\n-                true\n-            }\n-\n-            // Partially qualified paths in expressions can only legally\n-            // refer to associated items which are always rvalues.\n-            hir::ExprPath(hir::QPath::TypeRelative(..)) |\n-\n-            hir::ExprCall(..) |\n-            hir::ExprMethodCall(..) |\n-            hir::ExprStruct(..) |\n-            hir::ExprTup(..) |\n-            hir::ExprIf(..) |\n-            hir::ExprMatch(..) |\n-            hir::ExprClosure(..) |\n-            hir::ExprBlock(..) |\n-            hir::ExprRepeat(..) |\n-            hir::ExprArray(..) |\n-            hir::ExprBreak(..) |\n-            hir::ExprAgain(..) |\n-            hir::ExprRet(..) |\n-            hir::ExprWhile(..) |\n-            hir::ExprLoop(..) |\n-            hir::ExprAssign(..) |\n-            hir::ExprInlineAsm(..) |\n-            hir::ExprAssignOp(..) |\n-            hir::ExprLit(_) |\n-            hir::ExprUnary(..) |\n-            hir::ExprBox(..) |\n-            hir::ExprAddrOf(..) |\n-            hir::ExprBinary(..) |\n-            hir::ExprYield(..) |\n-            hir::ExprCast(..) => {\n-                false\n-            }\n-        }\n-    }\n-\n     pub fn provided_trait_methods(self, id: DefId) -> Vec<AssociatedItem> {\n         self.associated_items(id)\n             .filter(|item| item.kind == AssociatedKind::Method && item.defaultness.has_value())"}, {"sha": "0c1ebd1a2ba2f2f0c754d1ed8067c4bbdefcbfb1", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -1514,18 +1514,12 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n     ///\n     /// The parameter `explicit` indicates if this is an *explicit* dereference.\n     /// Some types---notably unsafe ptrs---can only be dereferenced explicitly.\n-    pub fn builtin_deref(&self, explicit: bool, pref: ty::LvaluePreference)\n-        -> Option<TypeAndMut<'tcx>>\n-    {\n+    pub fn builtin_deref(&self, explicit: bool) -> Option<TypeAndMut<'tcx>> {\n         match self.sty {\n             TyAdt(def, _) if def.is_box() => {\n                 Some(TypeAndMut {\n                     ty: self.boxed_ty(),\n-                    mutbl: if pref == ty::PreferMutLvalue {\n-                        hir::MutMutable\n-                    } else {\n-                        hir::MutImmutable\n-                    },\n+                    mutbl: hir::MutImmutable,\n                 })\n             },\n             TyRef(_, mt) => Some(mt),"}, {"sha": "da2b1ef0b1c02a3aef7b1345945d3858285a1e11", "filename": "src/librustc_borrowck/borrowck/README.md", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2FREADME.md?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -43,22 +43,22 @@ it is safe with respect to the in-scope loans.\n # Formal model\n \n Throughout the docs we'll consider a simple subset of Rust in which\n-you can only borrow from lvalues, defined like so:\n+you can only borrow from places, defined like so:\n \n ```text\n-LV = x | LV.f | *LV\n+P = x | P.f | *P\n ```\n \n-Here `x` represents some variable, `LV.f` is a field reference,\n-and `*LV` is a pointer dereference. There is no auto-deref or other\n+Here `x` represents some variable, `P.f` is a field reference,\n+and `*P` is a pointer dereference. There is no auto-deref or other\n niceties. This means that if you have a type like:\n \n ```rust\n struct S { f: i32 }\n ```\n \n and a variable `a: Box<S>`, then the rust expression `a.f` would correspond\n-to an `LV` of `(*a).f`.\n+to an `P` of `(*a).f`.\n \n Here is the formal grammar for the types we'll consider:\n \n@@ -99,7 +99,7 @@ this sort of thing.\n #### Loans and restrictions\n \n The way the borrow checker works is that it analyzes each borrow\n-expression (in our simple model, that's stuff like `&LV`, though in\n+expression (in our simple model, that's stuff like `&P`, though in\n real life there are a few other cases to consider). For each borrow\n expression, it computes a `Loan`, which is a data structure that\n records (1) the value being borrowed, (2) the mutability and scope of\n@@ -108,29 +108,29 @@ struct defined in `middle::borrowck`. Formally, we define `LOAN` as\n follows:\n \n ```text\n-LOAN = (LV, LT, MQ, RESTRICTION*)\n-RESTRICTION = (LV, ACTION*)\n+LOAN = (P, LT, MQ, RESTRICTION*)\n+RESTRICTION = (P, ACTION*)\n ACTION = MUTATE | CLAIM | FREEZE\n ```\n \n-Here the `LOAN` tuple defines the lvalue `LV` being borrowed; the\n+Here the `LOAN` tuple defines the place `P` being borrowed; the\n lifetime `LT` of that borrow; the mutability `MQ` of the borrow; and a\n list of restrictions. The restrictions indicate actions which, if\n taken, could invalidate the loan and lead to type safety violations.\n \n-Each `RESTRICTION` is a pair of a restrictive lvalue `LV` (which will\n+Each `RESTRICTION` is a pair of a restrictive place `P` (which will\n either be the path that was borrowed or some prefix of the path that\n was borrowed) and a set of restricted actions.  There are three kinds\n-of actions that may be restricted for the path `LV`:\n+of actions that may be restricted for the path `P`:\n \n-- `MUTATE` means that `LV` cannot be assigned to;\n-- `CLAIM` means that the `LV` cannot be borrowed mutably;\n-- `FREEZE` means that the `LV` cannot be borrowed immutably;\n+- `MUTATE` means that `P` cannot be assigned to;\n+- `CLAIM` means that the `P` cannot be borrowed mutably;\n+- `FREEZE` means that the `P` cannot be borrowed immutably;\n \n-Finally, it is never possible to move from an lvalue that appears in a\n-restriction. This implies that the \"empty restriction\" `(LV, [])`,\n+Finally, it is never possible to move from a place that appears in a\n+restriction. This implies that the \"empty restriction\" `(P, [])`,\n which contains an empty set of actions, still has a purpose---it\n-prevents moves from `LV`. I chose not to make `MOVE` a fourth kind of\n+prevents moves from `P`. I chose not to make `MOVE` a fourth kind of\n action because that would imply that sometimes moves are permitted\n from restricted values, which is not the case.\n \n@@ -239,22 +239,22 @@ live. (This is done via restrictions, read on.)\n \n We start with the `gather_loans` pass, which walks the AST looking for\n borrows.  For each borrow, there are three bits of information: the\n-lvalue `LV` being borrowed and the mutability `MQ` and lifetime `LT`\n+place `P` being borrowed and the mutability `MQ` and lifetime `LT`\n of the resulting pointer. Given those, `gather_loans` applies four\n validity tests:\n \n-1. `MUTABILITY(LV, MQ)`: The mutability of the reference is\n-compatible with the mutability of `LV` (i.e., not borrowing immutable\n+1. `MUTABILITY(P, MQ)`: The mutability of the reference is\n+compatible with the mutability of `P` (i.e., not borrowing immutable\n data as mutable).\n \n-2. `ALIASABLE(LV, MQ)`: The aliasability of the reference is\n-compatible with the aliasability of `LV`. The goal is to prevent\n+2. `ALIASABLE(P, MQ)`: The aliasability of the reference is\n+compatible with the aliasability of `P`. The goal is to prevent\n `&mut` borrows of aliasability data.\n \n-3. `LIFETIME(LV, LT, MQ)`: The lifetime of the borrow does not exceed\n+3. `LIFETIME(P, LT, MQ)`: The lifetime of the borrow does not exceed\n the lifetime of the value being borrowed.\n \n-4. `RESTRICTIONS(LV, LT, ACTIONS) = RS`: This pass checks and computes the\n+4. `RESTRICTIONS(P, LT, ACTIONS) = RS`: This pass checks and computes the\n restrictions to maintain memory safety. These are the restrictions\n that will go into the final loan. We'll discuss in more detail below.\n \n@@ -263,7 +263,7 @@ that will go into the final loan. We'll discuss in more detail below.\n Checking mutability is fairly straightforward. We just want to prevent\n immutable data from being borrowed as mutable. Note that it is ok to borrow\n mutable data as immutable, since that is simply a freeze. The judgement\n-`MUTABILITY(LV, MQ)` means the mutability of `LV` is compatible with a borrow\n+`MUTABILITY(P, MQ)` means the mutability of `P` is compatible with a borrow\n of mutability `MQ`. The Rust code corresponding to this predicate is the\n function `check_mutability` in `middle::borrowck::gather_loans`.\n \n@@ -288,15 +288,15 @@ MUTABILITY(X, imm)                  // M-Var-Imm\n \n Fields and boxes inherit their mutability from\n their base expressions, so both of their rules basically\n-delegate the check to the base expression `LV`:\n+delegate the check to the base expression `P`:\n \n ```text\n-MUTABILITY(LV.f, MQ)                // M-Field\n-  MUTABILITY(LV, MQ)\n+MUTABILITY(P.f, MQ)                // M-Field\n+  MUTABILITY(P, MQ)\n \n-MUTABILITY(*LV, MQ)                 // M-Deref-Unique\n-  TYPE(LV) = Box<Ty>\n-  MUTABILITY(LV, MQ)\n+MUTABILITY(*P, MQ)                 // M-Deref-Unique\n+  TYPE(P) = Box<Ty>\n+  MUTABILITY(P, MQ)\n ```\n \n ### Checking mutability of immutable pointer types\n@@ -305,24 +305,24 @@ Immutable pointer types like `&T` can only\n be borrowed if MQ is immutable:\n \n ```text\n-MUTABILITY(*LV, imm)               // M-Deref-Borrowed-Imm\n-  TYPE(LV) = &Ty\n+MUTABILITY(*P, imm)               // M-Deref-Borrowed-Imm\n+  TYPE(P) = &Ty\n ```\n \n ### Checking mutability of mutable pointer types\n \n `&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n \n ```text\n-MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n-  TYPE(LV) = &mut Ty\n+MUTABILITY(*P, MQ)                 // M-Deref-Borrowed-Mut\n+  TYPE(P) = &mut Ty\n ```\n \n ## Checking aliasability\n \n The goal of the aliasability check is to ensure that we never permit `&mut`\n-borrows of aliasable data. The judgement `ALIASABLE(LV, MQ)` means the\n-aliasability of `LV` is compatible with a borrow of mutability `MQ`. The Rust\n+borrows of aliasable data. The judgement `ALIASABLE(P, MQ)` means the\n+aliasability of `P` is compatible with a borrow of mutability `MQ`. The Rust\n code corresponding to this predicate is the function `check_aliasability()` in\n `middle::borrowck::gather_loans`.\n \n@@ -340,11 +340,11 @@ the stack frame.\n Owned content is aliasable if it is found in an aliasable location:\n \n ```text\n-ALIASABLE(LV.f, MQ)                // M-Field\n-  ALIASABLE(LV, MQ)\n+ALIASABLE(P.f, MQ)                // M-Field\n+  ALIASABLE(P, MQ)\n \n-ALIASABLE(*LV, MQ)                 // M-Deref-Unique\n-  ALIASABLE(LV, MQ)\n+ALIASABLE(*P, MQ)                 // M-Deref-Unique\n+  ALIASABLE(P, MQ)\n ```\n \n ### Checking aliasability of immutable pointer types\n@@ -353,25 +353,25 @@ Immutable pointer types like `&T` are aliasable, and hence can only be\n borrowed immutably:\n \n ```text\n-ALIASABLE(*LV, imm)                // M-Deref-Borrowed-Imm\n-  TYPE(LV) = &Ty\n+ALIASABLE(*P, imm)                // M-Deref-Borrowed-Imm\n+  TYPE(P) = &Ty\n ```\n \n ### Checking aliasability of mutable pointer types\n \n `&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n \n ```text\n-ALIASABLE(*LV, MQ)                 // M-Deref-Borrowed-Mut\n-  TYPE(LV) = &mut Ty\n+ALIASABLE(*P, MQ)                 // M-Deref-Borrowed-Mut\n+  TYPE(P) = &mut Ty\n ```\n \n ## Checking lifetime\n \n These rules aim to ensure that no data is borrowed for a scope that exceeds\n its lifetime. These two computations wind up being intimately related.\n-Formally, we define a predicate `LIFETIME(LV, LT, MQ)`, which states that\n-\"the lvalue `LV` can be safely borrowed for the lifetime `LT` with mutability\n+Formally, we define a predicate `LIFETIME(P, LT, MQ)`, which states that\n+\"the place `P` can be safely borrowed for the lifetime `LT` with mutability\n `MQ`\". The Rust code corresponding to this predicate is the module\n `middle::borrowck::gather_loans::lifetime`.\n \n@@ -391,12 +391,12 @@ The lifetime of a field or box is the same as the lifetime\n of its owner:\n \n ```text\n-LIFETIME(LV.f, LT, MQ)              // L-Field\n-  LIFETIME(LV, LT, MQ)\n+LIFETIME(P.f, LT, MQ)              // L-Field\n+  LIFETIME(P, LT, MQ)\n \n-LIFETIME(*LV, LT, MQ)               // L-Deref-Send\n-  TYPE(LV) = Box<Ty>\n-  LIFETIME(LV, LT, MQ)\n+LIFETIME(*P, LT, MQ)               // L-Deref-Send\n+  TYPE(P) = Box<Ty>\n+  LIFETIME(P, LT, MQ)\n ```\n \n ### Checking lifetime for derefs of references\n@@ -408,26 +408,26 @@ of the borrow is shorter than the lifetime `LT'` of the pointer\n itself:\n \n ```text\n-LIFETIME(*LV, LT, MQ)               // L-Deref-Borrowed\n-  TYPE(LV) = &LT' Ty OR &LT' mut Ty\n+LIFETIME(*P, LT, MQ)               // L-Deref-Borrowed\n+  TYPE(P) = &LT' Ty OR &LT' mut Ty\n   LT <= LT'\n ```\n \n ## Computing the restrictions\n \n The final rules govern the computation of *restrictions*, meaning that\n we compute the set of actions that will be illegal for the life of the\n-loan. The predicate is written `RESTRICTIONS(LV, LT, ACTIONS) =\n+loan. The predicate is written `RESTRICTIONS(P, LT, ACTIONS) =\n RESTRICTION*`, which can be read \"in order to prevent `ACTIONS` from\n-occurring on `LV`, the restrictions `RESTRICTION*` must be respected\n+occurring on `P`, the restrictions `RESTRICTION*` must be respected\n for the lifetime of the loan\".\n \n Note that there is an initial set of restrictions: these restrictions\n are computed based on the kind of borrow:\n \n ```text\n-&mut LV =>   RESTRICTIONS(LV, LT, MUTATE|CLAIM|FREEZE)\n-&LV =>       RESTRICTIONS(LV, LT, MUTATE|CLAIM)\n+&mut P =>   RESTRICTIONS(P, LT, MUTATE|CLAIM|FREEZE)\n+&P =>       RESTRICTIONS(P, LT, MUTATE|CLAIM)\n ```\n \n The reasoning here is that a mutable borrow must be the only writer,\n@@ -451,8 +451,8 @@ Restricting a field is the same as restricting the owner of that\n field:\n \n ```text\n-RESTRICTIONS(LV.f, LT, ACTIONS) = RS, (LV.f, ACTIONS)  // R-Field\n-  RESTRICTIONS(LV, LT, ACTIONS) = RS\n+RESTRICTIONS(P.f, LT, ACTIONS) = RS, (P.f, ACTIONS)  // R-Field\n+  RESTRICTIONS(P, LT, ACTIONS) = RS\n ```\n \n The reasoning here is as follows. If the field must not be mutated,\n@@ -467,32 +467,32 @@ origin of inherited mutability.\n Because the mutability of owned referents is inherited, restricting an\n owned referent is similar to restricting a field, in that it implies\n restrictions on the pointer. However, boxes have an important\n-twist: if the owner `LV` is mutated, that causes the owned referent\n-`*LV` to be freed! So whenever an owned referent `*LV` is borrowed, we\n-must prevent the box `LV` from being mutated, which means\n+twist: if the owner `P` is mutated, that causes the owned referent\n+`*P` to be freed! So whenever an owned referent `*P` is borrowed, we\n+must prevent the box `P` from being mutated, which means\n that we always add `MUTATE` and `CLAIM` to the restriction set imposed\n-on `LV`:\n+on `P`:\n \n ```text\n-RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Send-Pointer\n-  TYPE(LV) = Box<Ty>\n-  RESTRICTIONS(LV, LT, ACTIONS|MUTATE|CLAIM) = RS\n+RESTRICTIONS(*P, LT, ACTIONS) = RS, (*P, ACTIONS)    // R-Deref-Send-Pointer\n+  TYPE(P) = Box<Ty>\n+  RESTRICTIONS(P, LT, ACTIONS|MUTATE|CLAIM) = RS\n ```\n \n ### Restrictions for loans of immutable borrowed referents\n \n Immutable borrowed referents are freely aliasable, meaning that\n the compiler does not prevent you from copying the pointer.  This\n implies that issuing restrictions is useless. We might prevent the\n-user from acting on `*LV` itself, but there could be another path\n-`*LV1` that refers to the exact same memory, and we would not be\n+user from acting on `*P` itself, but there could be another path\n+`*P1` that refers to the exact same memory, and we would not be\n restricting that path. Therefore, the rule for `&Ty` pointers\n always returns an empty set of restrictions, and it only permits\n restricting `MUTATE` and `CLAIM` actions:\n \n ```text\n-RESTRICTIONS(*LV, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n-  TYPE(LV) = &LT' Ty\n+RESTRICTIONS(*P, LT, ACTIONS) = []                    // R-Deref-Imm-Borrowed\n+  TYPE(P) = &LT' Ty\n   LT <= LT'                                            // (1)\n   ACTIONS subset of [MUTATE, CLAIM]\n ```\n@@ -546,7 +546,7 @@ This function is legal. The reason for this is that the inner pointer\n (`*point : &'b Point`) is enough to guarantee the memory is immutable\n and valid for the lifetime `'b`.  This is reflected in\n `RESTRICTIONS()` by the fact that we do not recurse (i.e., we impose\n-no restrictions on `LV`, which in this particular case is the pointer\n+no restrictions on `P`, which in this particular case is the pointer\n `point : &'a &'b Point`).\n \n #### Why both `LIFETIME()` and `RESTRICTIONS()`?\n@@ -612,10 +612,10 @@ while the new claimant is live.\n The rule for mutable borrowed pointers is as follows:\n \n ```text\n-RESTRICTIONS(*LV, LT, ACTIONS) = RS, (*LV, ACTIONS)    // R-Deref-Mut-Borrowed\n-  TYPE(LV) = &LT' mut Ty\n+RESTRICTIONS(*P, LT, ACTIONS) = RS, (*P, ACTIONS)    // R-Deref-Mut-Borrowed\n+  TYPE(P) = &LT' mut Ty\n   LT <= LT'                                            // (1)\n-  RESTRICTIONS(LV, LT, ACTIONS) = RS                   // (2)\n+  RESTRICTIONS(P, LT, ACTIONS) = RS                   // (2)\n ```\n \n Let's examine the two numbered clauses:\n@@ -670,7 +670,7 @@ fn foo(t0: &mut i32) {\n \n Remember that `&mut` pointers are linear, and hence `let t1 = t0` is a\n move of `t0` -- or would be, if it were legal. Instead, we get an\n-error, because clause (2) imposes restrictions on `LV` (`t0`, here),\n+error, because clause (2) imposes restrictions on `P` (`t0`, here),\n and any restrictions on a path make it impossible to move from that\n path.\n \n@@ -906,7 +906,7 @@ results of a dataflow computation.\n \n The `MovePath` tree tracks every path that is moved or assigned to.\n These paths have the same form as the `LoanPath` data structure, which\n-in turn is the \"real world version of the lvalues `LV` that we\n+in turn is the \"real world version of the places `P` that we\n introduced earlier. The difference between a `MovePath` and a `LoanPath`\n is that move paths are:\n \n@@ -1132,7 +1132,7 @@ is implied by the relevant moves.\n While writing up these docs, I encountered some rules I believe to be\n stricter than necessary:\n \n-- I think restricting the `&mut` LV against moves and `ALIAS` is sufficient,\n+- I think restricting the `&mut` P against moves and `ALIAS` is sufficient,\n   `MUTATE` and `CLAIM` are overkill. `MUTATE` was necessary when swap was\n   a built-in operator, but as it is not, it is implied by `CLAIM`,\n   and `CLAIM` is implied by `ALIAS`. The only net effect of this is an"}, {"sha": "97fa94b5e5cf9c159ccba5baaec181549904f300", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -104,7 +104,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n \n     fn scope(&self, cmt: &mc::cmt<'tcx>) -> ty::Region<'tcx> {\n         //! Returns the maximal region scope for the which the\n-        //! lvalue `cmt` is guaranteed to be valid without any\n+        //! place `cmt` is guaranteed to be valid without any\n         //! rooting etc, and presuming `cmt` is not mutated.\n \n         match cmt.cat {"}, {"sha": "84ca2a9318ab36a226efd894a4dc2ef1ac647ea8", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -170,7 +170,7 @@ fn build_borrowck_dataflow_data<'a, 'c, 'tcx, F>(this: &mut BorrowckCtxt<'a, 'tc\n     if !force_analysis && move_data.is_empty() && all_loans.is_empty() {\n         // large arrays of data inserted as constants can take a lot of\n         // time and memory to borrow-check - see issue #36799. However,\n-        // they don't have lvalues, so no borrow-check is actually needed.\n+        // they don't have places, so no borrow-check is actually needed.\n         // Recognize that case and skip borrow-checking.\n         debug!(\"skipping loan propagation for {:?} because of no loans\", body_id);\n         return None;\n@@ -384,9 +384,9 @@ impl ToInteriorKind for mc::InteriorKind {\n }\n \n // This can be:\n-// - a pointer dereference (`*LV` in README.md)\n+// - a pointer dereference (`*P` in README.md)\n // - a field reference, with an optional definition of the containing\n-//   enum variant (`LV.f` in README.md)\n+//   enum variant (`P.f` in README.md)\n // `DefId` is present when the field is part of struct that is in\n // a variant of an enum. For instance in:\n // `enum E { X { foo: u32 }, Y { foo: u32 }}`"}, {"sha": "a90dcd1072f9513d5319650ffebbb4f7074fb815", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -153,7 +153,7 @@ pub struct Assignment {\n     /// span of node where assignment occurs\n     pub span: Span,\n \n-    /// id for l-value expression on lhs of assignment\n+    /// id for place expression on lhs of assignment\n     pub assignee_id: hir::ItemLocalId,\n }\n "}, {"sha": "ba966c9d4e3166f1c729e86dc82c5210820dac5c", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -15,28 +15,28 @@\n \n use rustc::mir::{BasicBlock, Location};\n \n-use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use dataflow::{EverInitializedLvals, MovingOutStatements};\n+use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n+use dataflow::{EverInitializedPlaces, MovingOutStatements};\n use dataflow::{ActiveBorrows, FlowAtLocation, FlowsAtLocation};\n use dataflow::move_paths::HasMoveData;\n use std::fmt;\n \n // (forced to be `pub` due to its use as an associated type below.)\n pub(crate) struct Flows<'b, 'gcx: 'tcx, 'tcx: 'b> {\n     pub borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n-    pub inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-    pub uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+    pub inits: FlowAtLocation<MaybeInitializedPlaces<'b, 'gcx, 'tcx>>,\n+    pub uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n     pub move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-    pub ever_inits: FlowAtLocation<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+    pub ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n }\n \n impl<'b, 'gcx, 'tcx> Flows<'b, 'gcx, 'tcx> {\n     pub fn new(\n         borrows: FlowAtLocation<ActiveBorrows<'b, 'gcx, 'tcx>>,\n-        inits: FlowAtLocation<MaybeInitializedLvals<'b, 'gcx, 'tcx>>,\n-        uninits: FlowAtLocation<MaybeUninitializedLvals<'b, 'gcx, 'tcx>>,\n+        inits: FlowAtLocation<MaybeInitializedPlaces<'b, 'gcx, 'tcx>>,\n+        uninits: FlowAtLocation<MaybeUninitializedPlaces<'b, 'gcx, 'tcx>>,\n         move_outs: FlowAtLocation<MovingOutStatements<'b, 'gcx, 'tcx>>,\n-        ever_inits: FlowAtLocation<EverInitializedLvals<'b, 'gcx, 'tcx>>,\n+        ever_inits: FlowAtLocation<EverInitializedPlaces<'b, 'gcx, 'tcx>>,\n     ) -> Self {\n         Flows {\n             borrows,"}, {"sha": "9a6d83b8eb75904c81d2b45a128992cf328c4dde", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -35,8 +35,8 @@ use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::FlowAtLocation;\n use dataflow::MoveDataParamEnv;\n use dataflow::{DataflowAnalysis, DataflowResultsConsumer};\n-use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-use dataflow::{EverInitializedLvals, MovingOutStatements};\n+use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n+use dataflow::{EverInitializedPlaces, MovingOutStatements};\n use dataflow::{BorrowData, Borrows, ReserveOrActivateIndex};\n use dataflow::{ActiveBorrows, Reservations};\n use dataflow::indexes::BorrowIndex;\n@@ -160,7 +160,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+        MaybeInitializedPlaces::new(tcx, mir, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_uninits = FlowAtLocation::new(do_dataflow(\n@@ -169,7 +169,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+        MaybeUninitializedPlaces::new(tcx, mir, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]),\n     ));\n     let flow_move_outs = FlowAtLocation::new(do_dataflow(\n@@ -187,7 +187,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         id,\n         &attributes,\n         &dead_unwinds,\n-        EverInitializedLvals::new(tcx, mir, &mdpe),\n+        EverInitializedPlaces::new(tcx, mir, &mdpe),\n         |bd, i| DebugFormatted::new(&bd.move_data().inits[i]),\n     ));\n \n@@ -607,7 +607,7 @@ enum ArtificialField {\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum ShallowOrDeep {\n     /// From the RFC: \"A *shallow* access means that the immediate\n-    /// fields reached at LV are accessed, but references or pointers\n+    /// fields reached at P are accessed, but references or pointers\n     /// found within are not dereferenced. Right now, the only access\n     /// that is shallow is an assignment like `x = ...;`, which would\n     /// be a *shallow write* of `x`.\""}, {"sha": "66ca74b0139a31a31af1ae94c6272cf0ed8ebf60", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -19,7 +19,7 @@ use std::io;\n use transform::MirSource;\n use util::liveness::{LivenessResults, LocalSet};\n use dataflow::FlowAtLocation;\n-use dataflow::MaybeInitializedLvals;\n+use dataflow::MaybeInitializedPlaces;\n use dataflow::move_paths::MoveData;\n \n use util as mir_util;\n@@ -71,7 +71,7 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     universal_regions: UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n     param_env: ty::ParamEnv<'gcx>,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'cx, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> (\n     RegionInferenceContext<'tcx>,"}, {"sha": "6c2037810d3260d831b5227f6f6b88fcd18428e2", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -10,7 +10,7 @@\n \n use dataflow::{FlowAtLocation, FlowsAtLocation};\n use borrow_check::nll::region_infer::Cause;\n-use dataflow::MaybeInitializedLvals;\n+use dataflow::MaybeInitializedPlaces;\n use dataflow::move_paths::{HasMoveData, MoveData};\n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::mir::Local;\n@@ -34,7 +34,7 @@ pub(super) fn generate<'gcx, 'tcx>(\n     cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n     liveness: &LivenessResults,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'_, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) {\n     let tcx = cx.tcx();\n@@ -63,7 +63,7 @@ where\n     tcx: TyCtxt<'typeck, 'gcx, 'tcx>,\n     mir: &'gen Mir<'tcx>,\n     liveness: &'gen LivenessResults,\n-    flow_inits: &'gen mut FlowAtLocation<MaybeInitializedLvals<'flow, 'gcx, 'tcx>>,\n+    flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n     move_data: &'gen MoveData<'tcx>,\n }\n "}, {"sha": "015eb8a3b6643bfddf5ddaed9837fc899cd70433", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -15,7 +15,7 @@ use borrow_check::nll::region_infer::Cause;\n use borrow_check::nll::region_infer::ClosureRegionRequirementsExt;\n use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::FlowAtLocation;\n-use dataflow::MaybeInitializedLvals;\n+use dataflow::MaybeInitializedPlaces;\n use dataflow::move_paths::MoveData;\n use rustc::hir::def_id::DefId;\n use rustc::infer::{InferCtxt, InferOk, InferResult, LateBoundRegionConversionTime, UnitResult};\n@@ -100,7 +100,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n     mir_def_id: DefId,\n     universal_regions: &UniversalRegions<'tcx>,\n     liveness: &LivenessResults,\n-    flow_inits: &mut FlowAtLocation<MaybeInitializedLvals<'_, 'gcx, 'tcx>>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n ) -> MirTypeckRegionConstraints<'tcx> {\n     let body_id = infcx.tcx.hir.as_local_node_id(mir_def_id).unwrap();\n@@ -397,7 +397,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         let base_ty = base.to_ty(tcx);\n         match *pi {\n             ProjectionElem::Deref => {\n-                let deref_ty = base_ty.builtin_deref(true, ty::LvaluePreference::NoPreference);\n+                let deref_ty = base_ty.builtin_deref(true);\n                 PlaceTy::Ty {\n                     ty: deref_ty.map(|t| t.ty).unwrap_or_else(|| {\n                         span_mirbug_and_err!(self, place, \"deref of non-pointer {:?}\", base_ty)"}, {"sha": "632bb5b34284da8e3eb2fab4607dbbc01437a3fb", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -575,10 +575,10 @@ impl<'a, 'b, 'tcx> FindPlaceUses<'a, 'b, 'tcx> {\n     /// has a reservation at the time).\n     fn is_potential_use(context: PlaceContext) -> bool {\n         match context {\n-            // storage effects on an place do not activate it\n+            // storage effects on a place do not activate it\n             PlaceContext::StorageLive | PlaceContext::StorageDead => false,\n \n-            // validation effects do not activate an place\n+            // validation effects do not activate a place\n             //\n             // FIXME: Should they? Is it just another read? Or can we\n             // guarantee it won't dereference the stored address? How\n@@ -589,11 +589,11 @@ impl<'a, 'b, 'tcx> FindPlaceUses<'a, 'b, 'tcx> {\n             // AsmOutput existed, but it's not necessarily a pure overwrite.\n             // so it's possible this should activate the place.\n             PlaceContext::AsmOutput |\n-            // pure overwrites of an place do not activate it. (note\n+            // pure overwrites of a place do not activate it. (note\n             // PlaceContext::Call is solely about dest place)\n             PlaceContext::Store | PlaceContext::Call => false,\n \n-            // reads of an place *do* activate it\n+            // reads of a place *do* activate it\n             PlaceContext::Move |\n             PlaceContext::Copy |\n             PlaceContext::Drop |"}, {"sha": "e7c15625cbe2be9bbf946c81395ef3a0d8cde61c", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -36,7 +36,7 @@ pub use self::storage_liveness::*;\n #[allow(dead_code)]\n pub(super) mod borrows;\n \n-/// `MaybeInitializedLvals` tracks all l-values that might be\n+/// `MaybeInitializedPlaces` tracks all places that might be\n /// initialized upon reaching a particular point in the control flow\n /// for a function.\n ///\n@@ -63,35 +63,35 @@ pub(super) mod borrows;\n /// }\n /// ```\n ///\n-/// To determine whether an l-value *must* be initialized at a\n+/// To determine whether a place *must* be initialized at a\n /// particular control-flow point, one can take the set-difference\n-/// between this data and the data from `MaybeUninitializedLvals` at the\n+/// between this data and the data from `MaybeUninitializedPlaces` at the\n /// corresponding control-flow point.\n ///\n /// Similarly, at a given `drop` statement, the set-intersection\n-/// between this data and `MaybeUninitializedLvals` yields the set of\n-/// l-values that would require a dynamic drop-flag at that statement.\n-pub struct MaybeInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+/// between this data and `MaybeUninitializedPlaces` yields the set of\n+/// places that would require a dynamic drop-flag at that statement.\n+pub struct MaybeInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx: 'tcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        MaybeInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n+        MaybeInitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-/// `MaybeUninitializedLvals` tracks all l-values that might be\n+/// `MaybeUninitializedPlaces` tracks all places that might be\n /// uninitialized upon reaching a particular point in the control flow\n /// for a function.\n ///\n@@ -118,42 +118,42 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeInitializedLvals<'a, 'gcx, 'tcx>\n /// }\n /// ```\n ///\n-/// To determine whether an l-value *must* be uninitialized at a\n+/// To determine whether a place *must* be uninitialized at a\n /// particular control-flow point, one can take the set-difference\n-/// between this data and the data from `MaybeInitializedLvals` at the\n+/// between this data and the data from `MaybeInitializedPlaces` at the\n /// corresponding control-flow point.\n ///\n /// Similarly, at a given `drop` statement, the set-intersection\n-/// between this data and `MaybeInitializedLvals` yields the set of\n-/// l-values that would require a dynamic drop-flag at that statement.\n-pub struct MaybeUninitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+/// between this data and `MaybeInitializedPlaces` yields the set of\n+/// places that would require a dynamic drop-flag at that statement.\n+pub struct MaybeUninitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx> MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        MaybeUninitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n+        MaybeUninitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-/// `DefinitelyInitializedLvals` tracks all l-values that are definitely\n+/// `DefinitelyInitializedPlaces` tracks all places that are definitely\n /// initialized upon reaching a particular point in the control flow\n /// for a function.\n ///\n /// FIXME: Note that once flow-analysis is complete, this should be\n-/// the set-complement of MaybeUninitializedLvals; thus we can get rid\n+/// the set-complement of MaybeUninitializedPlaces; thus we can get rid\n /// of one or the other of these two. I'm inclined to get rid of\n-/// MaybeUninitializedLvals, simply because the sets will tend to be\n+/// MaybeUninitializedPlaces, simply because the sets will tend to be\n /// smaller in this analysis and thus easier for humans to process\n /// when debugging.\n ///\n@@ -180,43 +180,43 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MaybeUninitializedLvals<'a, 'gcx, 'tc\n /// }\n /// ```\n ///\n-/// To determine whether an l-value *may* be uninitialized at a\n+/// To determine whether a place *may* be uninitialized at a\n /// particular control-flow point, one can take the set-complement\n /// of this data.\n ///\n /// Similarly, at a given `drop` statement, the set-difference between\n-/// this data and `MaybeInitializedLvals` yields the set of l-values\n+/// this data and `MaybeInitializedPlaces` yields the set of places\n /// that would require a dynamic drop-flag at that statement.\n-pub struct DefinitelyInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+pub struct DefinitelyInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx: 'a> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        DefinitelyInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n+        DefinitelyInitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx: 'a> HasMoveData<'tcx> for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n /// `MovingOutStatements` tracks the statements that perform moves out\n-/// of particular l-values. More precisely, it tracks whether the\n+/// of particular places. More precisely, it tracks whether the\n /// *effect* of such moves (namely, the uninitialization of the\n-/// l-value in question) can reach some point in the control-flow of\n+/// place in question) can reach some point in the control-flow of\n /// the function, or if that effect is \"killed\" by some intervening\n-/// operation reinitializing that l-value.\n+/// operation reinitializing that place.\n ///\n /// The resulting dataflow is a more enriched version of\n-/// `MaybeUninitializedLvals`. Both structures on their own only tell\n-/// you if an l-value *might* be uninitialized at a given point in the\n+/// `MaybeUninitializedPlaces`. Both structures on their own only tell\n+/// you if a place *might* be uninitialized at a given point in the\n /// control flow. But `MovingOutStatements` also includes the added\n /// data of *which* particular statement causing the deinitialization\n /// that the borrow checker's error message may need to report.\n@@ -241,7 +241,7 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n-/// `EverInitializedLvals` tracks all l-values that might have ever been\n+/// `EverInitializedPlaces` tracks all places that might have ever been\n /// initialized upon reaching a particular point in the control flow\n /// for a function, without an intervening `Storage Dead`.\n ///\n@@ -270,28 +270,28 @@ impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for MovingOutStatements<'a, 'gcx, 'tcx> {\n ///     c = S;                                 // {a, b, c, d }\n /// }\n /// ```\n-pub struct EverInitializedLvals<'a, 'gcx: 'tcx, 'tcx: 'a> {\n+pub struct EverInitializedPlaces<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>,\n }\n \n-impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx: 'tcx, 'tcx: 'a> EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n                mdpe: &'a MoveDataParamEnv<'gcx, 'tcx>)\n                -> Self\n     {\n-        EverInitializedLvals { tcx: tcx, mir: mir, mdpe: mdpe }\n+        EverInitializedPlaces { tcx: tcx, mir: mir, mdpe: mdpe }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> HasMoveData<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     fn move_data(&self) -> &MoveData<'tcx> { &self.mdpe.move_data }\n }\n \n \n-impl<'a, 'gcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -302,7 +302,7 @@ impl<'a, 'gcx, 'tcx> MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -313,7 +313,7 @@ impl<'a, 'gcx, 'tcx> MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     fn update_bits(sets: &mut BlockSets<MovePathIndex>, path: MovePathIndex,\n                    state: DropFlagState)\n     {\n@@ -324,7 +324,7 @@ impl<'a, 'gcx, 'tcx> DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -375,7 +375,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"maybe_uninit\" }\n     fn bits_per_block(&self) -> usize {\n@@ -430,7 +430,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = MovePathIndex;\n     fn name() -> &'static str { \"definite_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -561,7 +561,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation for MovingOutStatements<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     type Idx = InitIndex;\n     fn name() -> &'static str { \"ever_init\" }\n     fn bits_per_block(&self) -> usize {\n@@ -657,21 +657,21 @@ impl<'a, 'gcx, 'tcx> BitDenotation for EverInitializedLvals<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // \"maybe\" means we union effects of both preds\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 & pred2 // \"definitely\" means we intersect effects of both preds\n@@ -685,7 +685,7 @@ impl<'a, 'gcx, 'tcx> BitwiseOperator for MovingOutStatements<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn join(&self, pred1: usize, pred2: usize) -> usize {\n         pred1 | pred2 // inits from both preds are in scope\n@@ -702,21 +702,21 @@ impl<'a, 'gcx, 'tcx> BitwiseOperator for EverInitializedLvals<'a, 'gcx, 'tcx> {\n // propagating, or you start at all-ones and then use Intersect as\n // your merge when propagating.\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for MaybeInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for MaybeInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = uninitialized\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for MaybeUninitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for MaybeUninitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = initialized (start_block_effect counters this at outset)\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for DefinitelyInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for DefinitelyInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         true // bottom = initialized (start_block_effect counters this at outset)\n@@ -730,7 +730,7 @@ impl<'a, 'gcx, 'tcx> InitialFlow for MovingOutStatements<'a, 'gcx, 'tcx> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> InitialFlow for EverInitializedLvals<'a, 'gcx, 'tcx> {\n+impl<'a, 'gcx, 'tcx> InitialFlow for EverInitializedPlaces<'a, 'gcx, 'tcx> {\n     #[inline]\n     fn bottom_value() -> bool {\n         false // bottom = no initialized variables by default"}, {"sha": "bd63198ecd0d273c127723a49efb48e62b00345d", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -26,9 +26,9 @@ use std::path::PathBuf;\n use std::usize;\n \n pub use self::impls::{MaybeStorageLive};\n-pub use self::impls::{MaybeInitializedLvals, MaybeUninitializedLvals};\n-pub use self::impls::{DefinitelyInitializedLvals, MovingOutStatements};\n-pub use self::impls::EverInitializedLvals;\n+pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n+pub use self::impls::{DefinitelyInitializedPlaces, MovingOutStatements};\n+pub use self::impls::EverInitializedPlaces;\n pub use self::impls::borrows::{Borrows, BorrowData};\n pub(crate) use self::impls::borrows::{ActiveBorrows, Reservations, ReserveOrActivateIndex};\n pub use self::at_location::{FlowAtLocation, FlowsAtLocation};"}, {"sha": "7b6ebc6fba8722e93d834113e02955e292e28c87", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -86,7 +86,7 @@ impl MoveOutIndex {\n /// It follows a tree structure.\n ///\n /// Given `struct X { m: M, n: N }` and `x: X`, moves like `drop x.m;`\n-/// move *out* of the l-value `x.m`.\n+/// move *out* of the place `x.m`.\n ///\n /// The MovePaths representing `x.m` and `x.n` are siblings (that is,\n /// one of them will link to the other via the `next_sibling` field,\n@@ -222,7 +222,7 @@ impl fmt::Debug for Init {\n     }\n }\n \n-/// Tables mapping from an l-value to its MovePathIndex.\n+/// Tables mapping from a place to its MovePathIndex.\n #[derive(Debug)]\n pub struct MovePathLookup<'tcx> {\n     locals: IndexVec<Local, MovePathIndex>,\n@@ -247,7 +247,7 @@ pub enum LookupResult {\n impl<'tcx> MovePathLookup<'tcx> {\n     // Unlike the builder `fn move_path_for` below, this lookup\n     // alternative will *not* create a MovePath on the fly for an\n-    // unknown l-value, but will rather return the nearest available\n+    // unknown place, but will rather return the nearest available\n     // parent.\n     pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n         match *place {"}, {"sha": "701b7a07ac988f131f710cb6e8f0730b021d3344", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -9,17 +9,17 @@ use interpret::memory::HasMemory;\n \n #[derive(Copy, Clone, Debug)]\n pub enum Place {\n-    /// An place referring to a value allocated in the `Memory` system.\n+    /// A place referring to a value allocated in the `Memory` system.\n     Ptr {\n-        /// An place may have an invalid (integral or undef) pointer,\n+        /// A place may have an invalid (integral or undef) pointer,\n         /// since it might be turned back into a reference\n         /// before ever being dereferenced.\n         ptr: Pointer,\n         align: Align,\n         extra: PlaceExtra,\n     },\n \n-    /// An place referring to a value on the stack. Represented by a stack frame index paired with\n+    /// A place referring to a value on the stack. Represented by a stack frame index paired with\n     /// a Mir local index.\n     Local { frame: usize, local: mir::Local },\n }\n@@ -33,7 +33,7 @@ pub enum PlaceExtra {\n }\n \n impl<'tcx> Place {\n-    /// Produces an Place that will error if attempted to be read from\n+    /// Produces a Place that will error if attempted to be read from\n     pub fn undef() -> Self {\n         Self::from_primval_ptr(PrimVal::Undef.into(), Align::from_bytes(1, 1).unwrap())\n     }"}, {"sha": "9eca343cb5edceb6fe45d11a0752fdb7d2f13252", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use dataflow::move_paths::{HasMoveData, MoveData, MovePathIndex, LookupResult};\n-use dataflow::{MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::{DataflowResults};\n use dataflow::{on_all_children_bits, on_all_drop_children_bits};\n use dataflow::{drop_flag_effects_for_location, on_lookup_result_bits};\n@@ -60,11 +60,11 @@ impl MirPass for ElaborateDrops {\n             let dead_unwinds = find_dead_unwinds(tcx, mir, id, &env);\n             let flow_inits =\n                 do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                            MaybeInitializedLvals::new(tcx, mir, &env),\n+                            MaybeInitializedPlaces::new(tcx, mir, &env),\n                             |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n             let flow_uninits =\n                 do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                            MaybeUninitializedLvals::new(tcx, mir, &env),\n+                            MaybeUninitializedPlaces::new(tcx, mir, &env),\n                             |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n \n             ElaborateDropsCtxt {\n@@ -97,7 +97,7 @@ fn find_dead_unwinds<'a, 'tcx>(\n     let mut dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n     let flow_inits =\n         do_dataflow(tcx, mir, id, &[], &dead_unwinds,\n-                    MaybeInitializedLvals::new(tcx, mir, &env),\n+                    MaybeInitializedPlaces::new(tcx, mir, &env),\n                     |bd, p| DebugFormatted::new(&bd.move_data().move_paths[p]));\n     for (bb, bb_data) in mir.basic_blocks().iter_enumerated() {\n         let location = match bb_data.terminator().kind {\n@@ -300,8 +300,8 @@ struct ElaborateDropsCtxt<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     mir: &'a Mir<'tcx>,\n     env: &'a MoveDataParamEnv<'tcx, 'tcx>,\n-    flow_inits: DataflowResults<MaybeInitializedLvals<'a, 'tcx, 'tcx>>,\n-    flow_uninits:  DataflowResults<MaybeUninitializedLvals<'a, 'tcx, 'tcx>>,\n+    flow_inits: DataflowResults<MaybeInitializedPlaces<'a, 'tcx, 'tcx>>,\n+    flow_uninits:  DataflowResults<MaybeUninitializedPlaces<'a, 'tcx, 'tcx>>,\n     drop_flags: FxHashMap<MovePathIndex, Local>,\n     patch: MirPatch<'tcx>,\n }"}, {"sha": "76283edac7284d60b711280aa7d341b647c8bafa", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -22,7 +22,7 @@ use dataflow::{do_dataflow, DebugFormatted};\n use dataflow::MoveDataParamEnv;\n use dataflow::BitDenotation;\n use dataflow::DataflowResults;\n-use dataflow::{DefinitelyInitializedLvals, MaybeInitializedLvals, MaybeUninitializedLvals};\n+use dataflow::{DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use dataflow::move_paths::{MovePathIndex, LookupResult};\n use dataflow::move_paths::{HasMoveData, MoveData};\n use dataflow;\n@@ -50,15 +50,15 @@ impl MirPass for SanityCheck {\n         let dead_unwinds = IdxSetBuf::new_empty(mir.basic_blocks().len());\n         let flow_inits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                        MaybeInitializedLvals::new(tcx, mir, &mdpe),\n+                        MaybeInitializedPlaces::new(tcx, mir, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_uninits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                        MaybeUninitializedLvals::new(tcx, mir, &mdpe),\n+                        MaybeUninitializedPlaces::new(tcx, mir, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n         let flow_def_inits =\n             do_dataflow(tcx, mir, id, &attributes, &dead_unwinds,\n-                        DefinitelyInitializedLvals::new(tcx, mir, &mdpe),\n+                        DefinitelyInitializedPlaces::new(tcx, mir, &mdpe),\n                         |bd, i| DebugFormatted::new(&bd.move_data().move_paths[i]));\n \n         if has_rustc_mir_with(&attributes, \"rustc_peek_maybe_init\").is_some() {"}, {"sha": "65771068014992d107740b8cc1ab4a3b97540321", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -560,7 +560,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n     ///        ptr = cur\n     ///        cur = cur.offset(1)\n     ///    } else {\n-    ///        ptr = &mut LV[cur]\n+    ///        ptr = &mut P[cur]\n     ///        cur = cur + 1\n     ///    }\n     ///    drop(ptr)\n@@ -731,7 +731,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         if ptr_based {\n             let tmp_ty = tcx.mk_mut_ptr(self.place_ty(self.place));\n             let tmp = Place::Local(self.new_temp(tmp_ty));\n-            // tmp = &LV;\n+            // tmp = &P;\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n             drop_block_stmts.push(self.assign(&tmp, Rvalue::Ref("}, {"sha": "12698964d2e65ec7dc76f9b40c4754323d0e926a", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -545,7 +545,7 @@ impl<'a, 'tcx> ArgType<'tcx> {\n         self.mode == PassMode::Ignore\n     }\n \n-    /// Get the LLVM type for an place of the original Rust type of\n+    /// Get the LLVM type for a place of the original Rust type of\n     /// this argument/return, i.e. the result of `type_of::type_of`.\n     pub fn memory_ty(&self, cx: &CodegenCx<'a, 'tcx>) -> Type {\n         self.layout.llvm_type(cx)\n@@ -674,7 +674,7 @@ impl<'a, 'tcx> FnType<'tcx> {\n                 _ => bug!(\"FnType::new_vtable: non-pair self {:?}\", self_arg)\n             }\n \n-            let pointee = self_arg.layout.ty.builtin_deref(true, ty::NoPreference)\n+            let pointee = self_arg.layout.ty.builtin_deref(true)\n                 .unwrap_or_else(|| {\n                     bug!(\"FnType::new_vtable: non-pointer self {:?}\", self_arg)\n                 }).ty;"}, {"sha": "a3e55205dd8759c46f5cca3075e78e990e612311", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -212,7 +212,7 @@ enum Base {\n     Static(ValueRef)\n }\n \n-/// An place as seen from a constant.\n+/// A place as seen from a constant.\n #[derive(Copy, Clone)]\n struct ConstPlace<'tcx> {\n     base: Base,\n@@ -743,7 +743,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                         operand.llval\n                     }\n                     mir::CastKind::Unsize => {\n-                        let pointee_ty = operand.ty.builtin_deref(true, ty::NoPreference)\n+                        let pointee_ty = operand.ty.builtin_deref(true)\n                             .expect(\"consts: unsizing got non-pointer type\").ty;\n                         let (base, old_info) = if !self.cx.type_is_sized(pointee_ty) {\n                             // Normally, the source is a thin pointer and we are\n@@ -758,7 +758,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                             (operand.llval, None)\n                         };\n \n-                        let unsized_ty = cast_ty.builtin_deref(true, ty::NoPreference)\n+                        let unsized_ty = cast_ty.builtin_deref(true)\n                             .expect(\"consts: unsizing got non-pointer target type\").ty;\n                         let ptr_ty = self.cx.layout_of(unsized_ty).llvm_type(self.cx).ptr_to();\n                         let base = consts::ptrcast(base, ptr_ty);"}, {"sha": "e1b906646aa437a9bfefe155ee459eee6596a31d", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty;\n use rustc::ty::layout::{self, Align, LayoutOf, TyLayout};\n use rustc::mir;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -100,7 +99,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     }\n \n     pub fn deref(self, cx: &CodegenCx<'a, 'tcx>) -> PlaceRef<'tcx> {\n-        let projected_ty = self.layout.ty.builtin_deref(true, ty::NoPreference)\n+        let projected_ty = self.layout.ty.builtin_deref(true)\n             .unwrap_or_else(|| bug!(\"deref of non-pointer {:?}\", self)).ty;\n         let (llptr, llextra) = match self.val {\n             OperandValue::Immediate(llptr) => (llptr, ptr::null_mut()),"}, {"sha": "1a285cd869aecad1a376251aa7e80001b1d80617", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -14,8 +14,8 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::infer;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::traits::ObligationCauseCode;\n-use rustc::ty::{self, Ty, TypeFoldable, LvaluePreference};\n-use check::{FnCtxt, Expectation, Diverges};\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use check::{FnCtxt, Expectation, Diverges, Needs};\n use check::coercion::CoerceMany;\n use util::nodemap::FxHashMap;\n \n@@ -500,7 +500,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn check_dereferencable(&self, span: Span, expected: Ty<'tcx>, inner: &hir::Pat) -> bool {\n         if let PatKind::Binding(..) = inner.node {\n-            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true, ty::NoPreference) {\n+            if let Some(mt) = self.shallow_resolve(expected).builtin_deref(true) {\n                 if let ty::TyDynamic(..) = mt.ty.sty {\n                     // This is \"x = SomeTrait\" being reduced from\n                     // \"let &x = &SomeTrait\" or \"let box x = Box<SomeTrait>\", an error.\n@@ -584,7 +584,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         });\n         let discrim_ty;\n         if let Some(m) = contains_ref_bindings {\n-            discrim_ty = self.check_expr_with_lvalue_pref(discrim, LvaluePreference::from_mutbl(m));\n+            discrim_ty = self.check_expr_with_needs(discrim, Needs::maybe_mut_place(m));\n         } else {\n             // ...but otherwise we want to use any supertype of the\n             // discriminant. This is sort of a workaround, see note (*) in"}, {"sha": "1d7c533178f075b3d9b5bfd25ae2da5e27a2502e", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -10,15 +10,14 @@\n \n use astconv::AstConv;\n \n-use super::{FnCtxt, LvalueOp};\n+use super::{FnCtxt, PlaceOp, Needs};\n use super::method::MethodCallee;\n \n use rustc::infer::InferOk;\n use rustc::session::DiagnosticMessageId;\n use rustc::traits;\n use rustc::ty::{self, Ty, TraitRef};\n use rustc::ty::{ToPredicate, TypeFoldable};\n-use rustc::ty::{LvaluePreference, NoPreference};\n use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n \n use syntax_pos::Span;\n@@ -85,7 +84,7 @@ impl<'a, 'gcx, 'tcx> Iterator for Autoderef<'a, 'gcx, 'tcx> {\n \n         // Otherwise, deref if type is derefable:\n         let (kind, new_ty) =\n-            if let Some(mt) = self.cur_ty.builtin_deref(self.include_raw_pointers, NoPreference) {\n+            if let Some(mt) = self.cur_ty.builtin_deref(self.include_raw_pointers) {\n                 (AutoderefKind::Builtin, mt.ty)\n             } else {\n                 let ty = self.overloaded_deref_ty(self.cur_ty)?;\n@@ -163,19 +162,19 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n     }\n \n     /// Returns the adjustment steps.\n-    pub fn adjust_steps(&self, pref: LvaluePreference)\n+    pub fn adjust_steps(&self, needs: Needs)\n                         -> Vec<Adjustment<'tcx>> {\n-        self.fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(pref))\n+        self.fcx.register_infer_ok_obligations(self.adjust_steps_as_infer_ok(needs))\n     }\n \n-    pub fn adjust_steps_as_infer_ok(&self, pref: LvaluePreference)\n+    pub fn adjust_steps_as_infer_ok(&self, needs: Needs)\n                                     -> InferOk<'tcx, Vec<Adjustment<'tcx>>> {\n         let mut obligations = vec![];\n         let targets = self.steps.iter().skip(1).map(|&(ty, _)| ty)\n             .chain(iter::once(self.cur_ty));\n         let steps: Vec<_> = self.steps.iter().map(|&(source, kind)| {\n             if let AutoderefKind::Overloaded = kind {\n-                self.fcx.try_overloaded_deref(self.span, source, pref)\n+                self.fcx.try_overloaded_deref(self.span, source, needs)\n                     .and_then(|InferOk { value: method, obligations: o }| {\n                         obligations.extend(o);\n                         if let ty::TyRef(region, mt) = method.sig.output().sty {\n@@ -238,8 +237,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn try_overloaded_deref(&self,\n                                 span: Span,\n                                 base_ty: Ty<'tcx>,\n-                                pref: LvaluePreference)\n+                                needs: Needs)\n                                 -> Option<InferOk<'tcx, MethodCallee<'tcx>>> {\n-        self.try_overloaded_lvalue_op(span, base_ty, &[], pref, LvalueOp::Deref)\n+        self.try_overloaded_place_op(span, base_ty, &[], needs, PlaceOp::Deref)\n     }\n }"}, {"sha": "76df9be48386d0df1678828d144c971003a646c5", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -8,14 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use super::{Expectation, FnCtxt, TupleArgumentsFlag};\n+use super::{Expectation, FnCtxt, Needs, TupleArgumentsFlag};\n use super::autoderef::Autoderef;\n use super::method::MethodCallee;\n \n use hir::def::Def;\n use hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::{infer, traits};\n-use rustc::ty::{self, TyCtxt, TypeFoldable, LvaluePreference, Ty};\n+use rustc::ty::{self, TyCtxt, TypeFoldable, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use syntax::abi;\n use syntax::symbol::Symbol;\n@@ -96,7 +96,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // If the callee is a bare function or a closure, then we're all set.\n         match adjusted_ty.sty {\n             ty::TyFnDef(..) | ty::TyFnPtr(_) => {\n-                let adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+                let adjustments = autoderef.adjust_steps(Needs::None);\n                 self.apply_adjustments(callee_expr, adjustments);\n                 return Some(CallStep::Builtin(adjusted_ty));\n             }\n@@ -113,7 +113,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                                                    infer::FnCall,\n                                                                    &closure_ty)\n                         .0;\n-                    let adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+                    let adjustments = autoderef.adjust_steps(Needs::None);\n                     self.record_deferred_call_resolution(def_id, DeferredCallResolution {\n                         call_expr,\n                         callee_expr,\n@@ -143,7 +143,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n \n         self.try_overloaded_call_traits(call_expr, adjusted_ty).map(|(autoref, method)| {\n-            let mut adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+            let mut adjustments = autoderef.adjust_steps(Needs::None);\n             adjustments.extend(autoref);\n             self.apply_adjustments(callee_expr, adjustments);\n             CallStep::Overloaded(method)"}, {"sha": "d0280bf0b30be058e53b8b47dc68174aae56f804", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -60,7 +60,7 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use check::{Diverges, FnCtxt};\n+use check::{Diverges, FnCtxt, Needs};\n \n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -69,8 +69,7 @@ use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::lint;\n use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n-use rustc::ty::{self, LvaluePreference, TypeAndMut,\n-                Ty, ClosureSubsts};\n+use rustc::ty::{self, TypeAndMut, Ty, ClosureSubsts};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::error::TypeError;\n use rustc::ty::relate::RelateResult;\n@@ -410,9 +409,9 @@ impl<'f, 'gcx, 'tcx> Coerce<'f, 'gcx, 'tcx> {\n             return success(vec![], ty, obligations);\n         }\n \n-        let pref = LvaluePreference::from_mutbl(mt_b.mutbl);\n+        let needs = Needs::maybe_mut_place(mt_b.mutbl);\n         let InferOk { value: mut adjustments, obligations: o }\n-            = autoderef.adjust_steps_as_infer_ok(pref);\n+            = autoderef.adjust_steps_as_infer_ok(needs);\n         obligations.extend(o);\n         obligations.extend(autoderef.into_obligations());\n "}, {"sha": "7f5b353f79ef7994a71c9410a2fd256a9a61dd2e", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -11,11 +11,11 @@\n use super::{probe, MethodCallee};\n \n use astconv::AstConv;\n-use check::{FnCtxt, LvalueOp, callee};\n+use check::{FnCtxt, PlaceOp, callee, Needs};\n use hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::traits;\n-use rustc::ty::{self, LvaluePreference, NoPreference, PreferMutLvalue, Ty};\n+use rustc::ty::{self, Ty};\n use rustc::ty::subst::Subst;\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, OverloadedDeref};\n use rustc::ty::fold::TypeFoldable;\n@@ -136,7 +136,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         };\n \n         if let Some(hir::MutMutable) = pick.autoref {\n-            self.convert_lvalue_derefs_to_mutable();\n+            self.convert_place_derefs_to_mutable();\n         }\n \n         ConfirmResult { callee, illegal_sized_bound }\n@@ -155,7 +155,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n         let (_, n) = autoderef.nth(pick.autoderefs).unwrap();\n         assert_eq!(n, pick.autoderefs);\n \n-        let mut adjustments = autoderef.adjust_steps(LvaluePreference::NoPreference);\n+        let mut adjustments = autoderef.adjust_steps(Needs::None);\n \n         let mut target = autoderef.unambiguous_final_ty();\n \n@@ -416,7 +416,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n     /// When we select a method with a mutable autoref, we have to go convert any\n     /// auto-derefs, indices, etc from `Deref` and `Index` into `DerefMut` and `IndexMut`\n     /// respectively.\n-    fn convert_lvalue_derefs_to_mutable(&self) {\n+    fn convert_place_derefs_to_mutable(&self) {\n         // Gather up expressions we want to munge.\n         let mut exprs = Vec::new();\n         exprs.push(self.self_expr);\n@@ -431,14 +431,14 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        debug!(\"convert_lvalue_derefs_to_mutable: exprs={:?}\", exprs);\n+        debug!(\"convert_place_derefs_to_mutable: exprs={:?}\", exprs);\n \n         // Fix up autoderefs and derefs.\n         for (i, &expr) in exprs.iter().rev().enumerate() {\n-            debug!(\"convert_lvalue_derefs_to_mutable: i={} expr={:?}\", i, expr);\n+            debug!(\"convert_place_derefs_to_mutable: i={} expr={:?}\", i, expr);\n \n             // Fix up the autoderefs. Autorefs can only occur immediately preceding\n-            // overloaded lvalue ops, and will be fixed by them in order to get\n+            // overloaded place ops, and will be fixed by them in order to get\n             // the correct region.\n             let mut source = self.node_ty(expr.hir_id);\n             // Do not mutate adjustments in place, but rather take them,\n@@ -449,10 +449,10 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n                                            .adjustments_mut()\n                                            .remove(expr.hir_id);\n             if let Some(mut adjustments) = previous_adjustments {\n-                let pref = LvaluePreference::PreferMutLvalue;\n+                let needs = Needs::MutPlace;\n                 for adjustment in &mut adjustments {\n                     if let Adjust::Deref(Some(ref mut deref)) = adjustment.kind {\n-                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, pref) {\n+                        if let Some(ok) = self.try_overloaded_deref(expr.span, source, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n                             if let ty::TyRef(region, mt) = method.sig.output().sty {\n                                 *deref = OverloadedDeref {\n@@ -470,53 +470,53 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             match expr.node {\n                 hir::ExprIndex(ref base_expr, ref index_expr) => {\n                     let index_expr_ty = self.node_ty(index_expr.hir_id);\n-                    self.convert_lvalue_op_to_mutable(\n-                        LvalueOp::Index, expr, base_expr, &[index_expr_ty]);\n+                    self.convert_place_op_to_mutable(\n+                        PlaceOp::Index, expr, base_expr, &[index_expr_ty]);\n                 }\n                 hir::ExprUnary(hir::UnDeref, ref base_expr) => {\n-                    self.convert_lvalue_op_to_mutable(\n-                        LvalueOp::Deref, expr, base_expr, &[]);\n+                    self.convert_place_op_to_mutable(\n+                        PlaceOp::Deref, expr, base_expr, &[]);\n                 }\n                 _ => {}\n             }\n         }\n     }\n \n-    fn convert_lvalue_op_to_mutable(&self,\n-                                    op: LvalueOp,\n+    fn convert_place_op_to_mutable(&self,\n+                                    op: PlaceOp,\n                                     expr: &hir::Expr,\n                                     base_expr: &hir::Expr,\n                                     arg_tys: &[Ty<'tcx>])\n     {\n-        debug!(\"convert_lvalue_op_to_mutable({:?}, {:?}, {:?}, {:?})\",\n+        debug!(\"convert_place_op_to_mutable({:?}, {:?}, {:?}, {:?})\",\n                op, expr, base_expr, arg_tys);\n         if !self.tables.borrow().is_method_call(expr) {\n-            debug!(\"convert_lvalue_op_to_mutable - builtin, nothing to do\");\n+            debug!(\"convert_place_op_to_mutable - builtin, nothing to do\");\n             return\n         }\n \n         let base_ty = self.tables.borrow().expr_adjustments(base_expr).last()\n             .map_or_else(|| self.node_ty(expr.hir_id), |adj| adj.target);\n         let base_ty = self.resolve_type_vars_if_possible(&base_ty);\n \n-        // Need to deref because overloaded lvalue ops take self by-reference.\n-        let base_ty = base_ty.builtin_deref(false, NoPreference)\n-            .expect(\"lvalue op takes something that is not a ref\")\n+        // Need to deref because overloaded place ops take self by-reference.\n+        let base_ty = base_ty.builtin_deref(false)\n+            .expect(\"place op takes something that is not a ref\")\n             .ty;\n \n-        let method = self.try_overloaded_lvalue_op(\n-            expr.span, base_ty, arg_tys, PreferMutLvalue, op);\n+        let method = self.try_overloaded_place_op(\n+            expr.span, base_ty, arg_tys, Needs::MutPlace, op);\n         let method = match method {\n             Some(ok) => self.register_infer_ok_obligations(ok),\n             None => return self.tcx.sess.delay_span_bug(expr.span, \"re-trying op failed\")\n         };\n-        debug!(\"convert_lvalue_op_to_mutable: method={:?}\", method);\n+        debug!(\"convert_place_op_to_mutable: method={:?}\", method);\n         self.write_method_call(expr.hir_id, method);\n \n         let (region, mutbl) = if let ty::TyRef(r, mt) = method.sig.inputs()[0].sty {\n             (r, mt.mutbl)\n         } else {\n-            span_bug!(expr.span, \"input to lvalue op is not a ref?\");\n+            span_bug!(expr.span, \"input to place op is not a ref?\");\n         };\n \n         // Convert the autoref in the base expr to mutable with the correct\n@@ -529,7 +529,7 @@ impl<'a, 'gcx, 'tcx> ConfirmContext<'a, 'gcx, 'tcx> {\n             let mut source = base_expr_ty;\n             for adjustment in &mut adjustments[..] {\n                 if let Adjust::Borrow(AutoBorrow::Ref(..)) = adjustment.kind {\n-                    debug!(\"convert_lvalue_op_to_mutable: converting autoref {:?}\", adjustment);\n+                    debug!(\"convert_place_op_to_mutable: converting autoref {:?}\", adjustment);\n                     adjustment.kind = Adjust::Borrow(AutoBorrow::Ref(region, mutbl));\n                     adjustment.target = self.tcx.mk_ref(region, ty::TypeAndMut {\n                         ty: source,"}, {"sha": "483dd345286d433601cdd3d2728b73ee6ff5865a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 141, "deletions": 74, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -95,7 +95,6 @@ use rustc::infer::type_variable::{TypeVariableOrigin};\n use rustc::middle::region;\n use rustc::ty::subst::{Kind, Subst, Substs};\n use rustc::traits::{self, FulfillmentContext, ObligationCause, ObligationCauseCode};\n-use rustc::ty::{ParamTy, LvaluePreference, NoPreference, PreferMutLvalue};\n use rustc::ty::{self, Ty, TyCtxt, Visibility, ToPredicate};\n use rustc::ty::adjustment::{Adjust, Adjustment, AutoBorrow};\n use rustc::ty::fold::TypeFoldable;\n@@ -368,6 +367,21 @@ impl<'a, 'gcx, 'tcx> Expectation<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Needs {\n+    MutPlace,\n+    None\n+}\n+\n+impl Needs {\n+    fn maybe_mut_place(m: hir::Mutability) -> Self {\n+        match m {\n+            hir::MutMutable => Needs::MutPlace,\n+            hir::MutImmutable => Needs::None,\n+        }\n+    }\n+}\n+\n #[derive(Copy, Clone)]\n pub struct UnsafetyState {\n     pub def: ast::NodeId,\n@@ -410,7 +424,7 @@ impl UnsafetyState {\n }\n \n #[derive(Debug, Copy, Clone)]\n-pub enum LvalueOp {\n+pub enum PlaceOp {\n     Deref,\n     Index\n }\n@@ -543,7 +557,7 @@ pub struct FnCtxt<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     ///   foo();}` or `{return; 22}`, where we would warn on the\n     ///   `foo()` or `22`.\n     ///\n-    /// - To permit assignment into a local variable or other lvalue\n+    /// - To permit assignment into a local variable or other place\n     ///   (including the \"return slot\") of type `!`.  This is allowed\n     ///   if **either** the type of value being assigned is `!`, which\n     ///   means the current code is dead, **or** the expression's\n@@ -2207,27 +2221,81 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// For the overloaded lvalue expressions (`*x`, `x[3]`), the trait\n+    fn is_place_expr(&self, expr: &hir::Expr) -> bool {\n+         match expr.node {\n+            hir::ExprPath(hir::QPath::Resolved(_, ref path)) => {\n+                match path.def {\n+                    Def::Local(..) | Def::Upvar(..) | Def::Static(..) | Def::Err => true,\n+                    _ => false,\n+                }\n+            }\n+\n+            hir::ExprType(ref e, _) => {\n+                self.is_place_expr(e)\n+            }\n+\n+            hir::ExprUnary(hir::UnDeref, _) |\n+            hir::ExprField(..) |\n+            hir::ExprTupField(..) |\n+            hir::ExprIndex(..) => {\n+                true\n+            }\n+\n+            // Partially qualified paths in expressions can only legally\n+            // refer to associated items which are always rvalues.\n+            hir::ExprPath(hir::QPath::TypeRelative(..)) |\n+\n+            hir::ExprCall(..) |\n+            hir::ExprMethodCall(..) |\n+            hir::ExprStruct(..) |\n+            hir::ExprTup(..) |\n+            hir::ExprIf(..) |\n+            hir::ExprMatch(..) |\n+            hir::ExprClosure(..) |\n+            hir::ExprBlock(..) |\n+            hir::ExprRepeat(..) |\n+            hir::ExprArray(..) |\n+            hir::ExprBreak(..) |\n+            hir::ExprAgain(..) |\n+            hir::ExprRet(..) |\n+            hir::ExprWhile(..) |\n+            hir::ExprLoop(..) |\n+            hir::ExprAssign(..) |\n+            hir::ExprInlineAsm(..) |\n+            hir::ExprAssignOp(..) |\n+            hir::ExprLit(_) |\n+            hir::ExprUnary(..) |\n+            hir::ExprBox(..) |\n+            hir::ExprAddrOf(..) |\n+            hir::ExprBinary(..) |\n+            hir::ExprYield(..) |\n+            hir::ExprCast(..) => {\n+                false\n+            }\n+        }\n+    }\n+\n+    /// For the overloaded place expressions (`*x`, `x[3]`), the trait\n     /// returns a type of `&T`, but the actual type we assign to the\n     /// *expression* is `T`. So this function just peels off the return\n     /// type by one layer to yield `T`.\n-    fn make_overloaded_lvalue_return_type(&self,\n+    fn make_overloaded_place_return_type(&self,\n                                           method: MethodCallee<'tcx>)\n                                           -> ty::TypeAndMut<'tcx>\n     {\n         // extract method return type, which will be &T;\n         let ret_ty = method.sig.output();\n \n         // method returns &T, but the type as visible to user is T, so deref\n-        ret_ty.builtin_deref(true, NoPreference).unwrap()\n+        ret_ty.builtin_deref(true).unwrap()\n     }\n \n     fn lookup_indexing(&self,\n                        expr: &hir::Expr,\n                        base_expr: &'gcx hir::Expr,\n                        base_ty: Ty<'tcx>,\n                        idx_ty: Ty<'tcx>,\n-                       lvalue_pref: LvaluePreference)\n+                       needs: Needs)\n                        -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n     {\n         // FIXME(#18741) -- this is almost but not quite the same as the\n@@ -2237,7 +2305,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let mut autoderef = self.autoderef(base_expr.span, base_ty);\n         let mut result = None;\n         while result.is_none() && autoderef.next().is_some() {\n-            result = self.try_index_step(expr, base_expr, &autoderef, lvalue_pref, idx_ty);\n+            result = self.try_index_step(expr, base_expr, &autoderef, needs, idx_ty);\n         }\n         autoderef.finalize();\n         result\n@@ -2252,7 +2320,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                       expr: &hir::Expr,\n                       base_expr: &hir::Expr,\n                       autoderef: &Autoderef<'a, 'gcx, 'tcx>,\n-                      lvalue_pref: LvaluePreference,\n+                      needs: Needs,\n                       index_ty: Ty<'tcx>)\n                       -> Option<(/*index type*/ Ty<'tcx>, /*element type*/ Ty<'tcx>)>\n     {\n@@ -2279,14 +2347,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // type from the method signature.\n             // If some lookup succeeded, install method in table\n             let input_ty = self.next_ty_var(TypeVariableOrigin::AutoDeref(base_expr.span));\n-            let method = self.try_overloaded_lvalue_op(\n-                expr.span, self_ty, &[input_ty], lvalue_pref, LvalueOp::Index);\n+            let method = self.try_overloaded_place_op(\n+                expr.span, self_ty, &[input_ty], needs, PlaceOp::Index);\n \n             let result = method.map(|ok| {\n                 debug!(\"try_index_step: success, using overloaded indexing\");\n                 let method = self.register_infer_ok_obligations(ok);\n \n-                let mut adjustments = autoderef.adjust_steps(lvalue_pref);\n+                let mut adjustments = autoderef.adjust_steps(needs);\n                 if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n                     adjustments.push(Adjustment {\n                         kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n@@ -2305,7 +2373,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 self.apply_adjustments(base_expr, adjustments);\n \n                 self.write_method_call(expr.hir_id, method);\n-                (input_ty, self.make_overloaded_lvalue_return_type(method).ty)\n+                (input_ty, self.make_overloaded_place_return_type(method).ty)\n             });\n             if result.is_some() {\n                 return result;\n@@ -2315,45 +2383,45 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    fn resolve_lvalue_op(&self, op: LvalueOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n+    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n         let (tr, name) = match (op, is_mut) {\n-            (LvalueOp::Deref, false) =>\n+            (PlaceOp::Deref, false) =>\n                 (self.tcx.lang_items().deref_trait(), \"deref\"),\n-            (LvalueOp::Deref, true) =>\n+            (PlaceOp::Deref, true) =>\n                 (self.tcx.lang_items().deref_mut_trait(), \"deref_mut\"),\n-            (LvalueOp::Index, false) =>\n+            (PlaceOp::Index, false) =>\n                 (self.tcx.lang_items().index_trait(), \"index\"),\n-            (LvalueOp::Index, true) =>\n+            (PlaceOp::Index, true) =>\n                 (self.tcx.lang_items().index_mut_trait(), \"index_mut\"),\n         };\n         (tr, Symbol::intern(name))\n     }\n \n-    fn try_overloaded_lvalue_op(&self,\n+    fn try_overloaded_place_op(&self,\n                                 span: Span,\n                                 base_ty: Ty<'tcx>,\n                                 arg_tys: &[Ty<'tcx>],\n-                                lvalue_pref: LvaluePreference,\n-                                op: LvalueOp)\n+                                needs: Needs,\n+                                op: PlaceOp)\n                                 -> Option<InferOk<'tcx, MethodCallee<'tcx>>>\n     {\n-        debug!(\"try_overloaded_lvalue_op({:?},{:?},{:?},{:?})\",\n+        debug!(\"try_overloaded_place_op({:?},{:?},{:?},{:?})\",\n                span,\n                base_ty,\n-               lvalue_pref,\n+               needs,\n                op);\n \n-        // Try Mut first, if preferred.\n-        let (mut_tr, mut_op) = self.resolve_lvalue_op(op, true);\n-        let method = match (lvalue_pref, mut_tr) {\n-            (PreferMutLvalue, Some(trait_did)) => {\n+        // Try Mut first, if needed.\n+        let (mut_tr, mut_op) = self.resolve_place_op(op, true);\n+        let method = match (needs, mut_tr) {\n+            (Needs::MutPlace, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span, mut_op, trait_did, base_ty, Some(arg_tys))\n             }\n             _ => None,\n         };\n \n         // Otherwise, fall back to the immutable version.\n-        let (imm_tr, imm_op) = self.resolve_lvalue_op(op, false);\n+        let (imm_tr, imm_op) = self.resolve_place_op(op, false);\n         let method = match (method, imm_tr) {\n             (None, Some(trait_did)) => {\n                 self.lookup_method_in_trait(span, imm_op, trait_did, base_ty, Some(arg_tys))\n@@ -2738,18 +2806,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_coercable_to_type(&self,\n                                     expr: &'gcx hir::Expr,\n                                     expected: Ty<'tcx>) -> Ty<'tcx> {\n-        self.check_expr_coercable_to_type_with_lvalue_pref(expr, expected, NoPreference)\n+        self.check_expr_coercable_to_type_with_needs(expr, expected, Needs::None)\n     }\n \n-    fn check_expr_coercable_to_type_with_lvalue_pref(&self,\n-                                                     expr: &'gcx hir::Expr,\n-                                                     expected: Ty<'tcx>,\n-                                                     lvalue_pref: LvaluePreference)\n-                                                     -> Ty<'tcx> {\n-        let ty = self.check_expr_with_expectation_and_lvalue_pref(\n+    fn check_expr_coercable_to_type_with_needs(&self,\n+                                               expr: &'gcx hir::Expr,\n+                                               expected: Ty<'tcx>,\n+                                               needs: Needs)\n+                                               -> Ty<'tcx> {\n+        let ty = self.check_expr_with_expectation_and_needs(\n             expr,\n             ExpectHasType(expected),\n-            lvalue_pref);\n+            needs);\n         self.demand_coerce(expr, ty, expected)\n     }\n \n@@ -2761,16 +2829,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_with_expectation(&self,\n                                    expr: &'gcx hir::Expr,\n                                    expected: Expectation<'tcx>) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_lvalue_pref(expr, expected, NoPreference)\n+        self.check_expr_with_expectation_and_needs(expr, expected, Needs::None)\n     }\n \n     fn check_expr(&self, expr: &'gcx hir::Expr) -> Ty<'tcx> {\n         self.check_expr_with_expectation(expr, NoExpectation)\n     }\n \n-    fn check_expr_with_lvalue_pref(&self, expr: &'gcx hir::Expr,\n-                                   lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n-        self.check_expr_with_expectation_and_lvalue_pref(expr, NoExpectation, lvalue_pref)\n+    fn check_expr_with_needs(&self, expr: &'gcx hir::Expr, needs: Needs) -> Ty<'tcx> {\n+        self.check_expr_with_expectation_and_needs(expr, NoExpectation, needs)\n     }\n \n     // determine the `self` type, using fresh variables for all variables\n@@ -2853,9 +2920,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          span: Span,\n                          args: &'gcx [hir::Expr],\n                          expected: Expectation<'tcx>,\n-                         lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n+                         needs: Needs) -> Ty<'tcx> {\n         let rcvr = &args[0];\n-        let rcvr_t = self.check_expr_with_lvalue_pref(&rcvr, lvalue_pref);\n+        let rcvr_t = self.check_expr_with_needs(&rcvr, needs);\n         // no need to check for bot/err -- callee does that\n         let rcvr_t = self.structurally_resolved_type(expr.span, rcvr_t);\n \n@@ -2965,10 +3032,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Check field access expressions\n     fn check_field(&self,\n                    expr: &'gcx hir::Expr,\n-                   lvalue_pref: LvaluePreference,\n+                   needs: Needs,\n                    base: &'gcx hir::Expr,\n                    field: &Spanned<ast::Name>) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_lvalue_pref(base, lvalue_pref);\n+        let expr_t = self.check_expr_with_needs(base, needs);\n         let expr_t = self.structurally_resolved_type(expr.span,\n                                                      expr_t);\n         let mut private_candidate = None;\n@@ -2983,7 +3050,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     if let Some(field) = fields.iter().find(|f| f.name.to_ident() == ident) {\n                         let field_ty = self.field_ty(expr.span, field, substs);\n                         if field.vis.is_accessible_from(def_scope, self.tcx) {\n-                            let adjustments = autoderef.adjust_steps(lvalue_pref);\n+                            let adjustments = autoderef.adjust_steps(needs);\n                             self.apply_adjustments(base, adjustments);\n                             autoderef.finalize();\n \n@@ -3102,10 +3169,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Check tuple index expressions\n     fn check_tup_field(&self,\n                        expr: &'gcx hir::Expr,\n-                       lvalue_pref: LvaluePreference,\n+                       needs: Needs,\n                        base: &'gcx hir::Expr,\n                        idx: codemap::Spanned<usize>) -> Ty<'tcx> {\n-        let expr_t = self.check_expr_with_lvalue_pref(base, lvalue_pref);\n+        let expr_t = self.check_expr_with_needs(base, needs);\n         let expr_t = self.structurally_resolved_type(expr.span,\n                                                      expr_t);\n         let mut private_candidate = None;\n@@ -3146,7 +3213,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             };\n \n             if let Some(field_ty) = field {\n-                let adjustments = autoderef.adjust_steps(lvalue_pref);\n+                let adjustments = autoderef.adjust_steps(needs);\n                 self.apply_adjustments(base, adjustments);\n                 autoderef.finalize();\n                 return field_ty;\n@@ -3476,10 +3543,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// Note that inspecting a type's structure *directly* may expose the fact\n     /// that there are actually multiple representations for `TyError`, so avoid\n     /// that when err needs to be handled differently.\n-    fn check_expr_with_expectation_and_lvalue_pref(&self,\n+    fn check_expr_with_expectation_and_needs(&self,\n                                                    expr: &'gcx hir::Expr,\n                                                    expected: Expectation<'tcx>,\n-                                                   lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n+                                                   needs: Needs) -> Ty<'tcx> {\n         debug!(\">> typechecking: expr={:?} expected={:?}\",\n                expr, expected);\n \n@@ -3492,7 +3559,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         self.diverges.set(Diverges::Maybe);\n         self.has_errors.set(false);\n \n-        let ty = self.check_expr_kind(expr, expected, lvalue_pref);\n+        let ty = self.check_expr_kind(expr, expected, needs);\n \n         // Warn for non-block expressions with diverging children.\n         match expr.node {\n@@ -3526,7 +3593,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn check_expr_kind(&self,\n                        expr: &'gcx hir::Expr,\n                        expected: Expectation<'tcx>,\n-                       lvalue_pref: LvaluePreference) -> Ty<'tcx> {\n+                       needs: Needs) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let id = expr.id;\n         match expr.node {\n@@ -3560,30 +3627,30 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     NoExpectation\n                 }\n             };\n-            let lvalue_pref = match unop {\n-                hir::UnDeref => lvalue_pref,\n-                _ => NoPreference\n+            let needs = match unop {\n+                hir::UnDeref => needs,\n+                _ => Needs::None\n             };\n-            let mut oprnd_t = self.check_expr_with_expectation_and_lvalue_pref(&oprnd,\n+            let mut oprnd_t = self.check_expr_with_expectation_and_needs(&oprnd,\n                                                                                expected_inner,\n-                                                                               lvalue_pref);\n+                                                                               needs);\n \n             if !oprnd_t.references_error() {\n                 oprnd_t = self.structurally_resolved_type(expr.span, oprnd_t);\n                 match unop {\n                     hir::UnDeref => {\n-                        if let Some(mt) = oprnd_t.builtin_deref(true, NoPreference) {\n+                        if let Some(mt) = oprnd_t.builtin_deref(true) {\n                             oprnd_t = mt.ty;\n                         } else if let Some(ok) = self.try_overloaded_deref(\n-                                expr.span, oprnd_t, lvalue_pref) {\n+                                expr.span, oprnd_t, needs) {\n                             let method = self.register_infer_ok_obligations(ok);\n                             if let ty::TyRef(region, mt) = method.sig.inputs()[0].sty {\n                                 self.apply_adjustments(oprnd, vec![Adjustment {\n                                     kind: Adjust::Borrow(AutoBorrow::Ref(region, mt.mutbl)),\n                                     target: method.sig.inputs()[0]\n                                 }]);\n                             }\n-                            oprnd_t = self.make_overloaded_lvalue_return_type(method).ty;\n+                            oprnd_t = self.make_overloaded_place_return_type(method).ty;\n                             self.write_method_call(expr.hir_id, method);\n                         } else {\n                             type_error_struct!(tcx.sess, expr.span, oprnd_t, E0614,\n@@ -3614,8 +3681,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let hint = expected.only_has_type(self).map_or(NoExpectation, |ty| {\n                 match ty.sty {\n                     ty::TyRef(_, ref mt) | ty::TyRawPtr(ref mt) => {\n-                        if self.tcx.expr_is_lval(&oprnd) {\n-                            // Lvalues may legitimately have unsized types.\n+                        if self.is_place_expr(&oprnd) {\n+                            // Places may legitimately have unsized types.\n                             // For example, dereferences of a fat pointer and\n                             // the last field of a struct can be unsized.\n                             ExpectHasType(mt.ty)\n@@ -3626,8 +3693,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     _ => NoExpectation\n                 }\n             });\n-            let lvalue_pref = LvaluePreference::from_mutbl(mutbl);\n-            let ty = self.check_expr_with_expectation_and_lvalue_pref(&oprnd, hint, lvalue_pref);\n+            let needs = Needs::maybe_mut_place(mutbl);\n+            let ty = self.check_expr_with_expectation_and_needs(&oprnd, hint, needs);\n \n             let tm = ty::TypeAndMut { ty: ty, mutbl: mutbl };\n             if tm.ty.references_error() {\n@@ -3771,7 +3838,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             tcx.types.never\n           }\n           hir::ExprAssign(ref lhs, ref rhs) => {\n-            let lhs_ty = self.check_expr_with_lvalue_pref(&lhs, PreferMutLvalue);\n+            let lhs_ty = self.check_expr_with_needs(&lhs, Needs::MutPlace);\n \n             let rhs_ty = self.check_expr_coercable_to_type(&rhs, lhs_ty);\n \n@@ -3783,7 +3850,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 _ => {\n                     // Only check this if not in an `if` condition, as the\n                     // mistyped comparison help is more appropriate.\n-                    if !self.tcx.expr_is_lval(&lhs) {\n+                    if !self.is_place_expr(&lhs) {\n                         struct_span_err!(self.tcx.sess, expr.span, E0070,\n                                          \"invalid left-hand side expression\")\n                             .span_label(expr.span, \"left-hand of expression not valid\")\n@@ -3872,7 +3939,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n               self.check_call(expr, &callee, args, expected)\n           }\n           hir::ExprMethodCall(ref segment, span, ref args) => {\n-              self.check_method_call(expr, segment, span, args, expected, lvalue_pref)\n+              self.check_method_call(expr, segment, span, args, expected, needs)\n           }\n           hir::ExprCast(ref e, ref t) => {\n             // Find the type of `e`. Supply hints based on the type we are casting to,\n@@ -4015,13 +4082,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             self.check_expr_struct(expr, expected, qpath, fields, base_expr)\n           }\n           hir::ExprField(ref base, ref field) => {\n-            self.check_field(expr, lvalue_pref, &base, field)\n+            self.check_field(expr, needs, &base, field)\n           }\n           hir::ExprTupField(ref base, idx) => {\n-            self.check_tup_field(expr, lvalue_pref, &base, idx)\n+            self.check_tup_field(expr, needs, &base, idx)\n           }\n           hir::ExprIndex(ref base, ref idx) => {\n-              let base_t = self.check_expr_with_lvalue_pref(&base, lvalue_pref);\n+              let base_t = self.check_expr_with_needs(&base, needs);\n               let idx_t = self.check_expr(&idx);\n \n               if base_t.references_error() {\n@@ -4030,7 +4097,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                   idx_t\n               } else {\n                   let base_t = self.structurally_resolved_type(expr.span, base_t);\n-                  match self.lookup_indexing(expr, base, base_t, idx_t, lvalue_pref) {\n+                  match self.lookup_indexing(expr, base, base_t, idx_t, needs) {\n                       Some((index_ty, element_ty)) => {\n                           self.demand_coerce(idx, idx_t, index_ty);\n                           element_ty\n@@ -4178,9 +4245,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // ref mut, for soundness (issue #23116). In particular, in\n             // the latter case, we need to be clear that the type of the\n             // referent for the reference that results is *equal to* the\n-            // type of the lvalue it is referencing, and not some\n+            // type of the place it is referencing, and not some\n             // supertype thereof.\n-            let init_ty = self.check_expr_with_lvalue_pref(init, LvaluePreference::from_mutbl(m));\n+            let init_ty = self.check_expr_with_needs(init, Needs::maybe_mut_place(m));\n             self.demand_eqtype(init.span, local_ty, init_ty);\n             init_ty\n         } else {\n@@ -5023,7 +5090,7 @@ pub fn check_bounds_are_used<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let lifetime_count = generics.lifetimes().count();\n \n     for leaf_ty in ty.walk() {\n-        if let ty::TyParam(ParamTy {idx, ..}) = leaf_ty.sty {\n+        if let ty::TyParam(ty::ParamTy {idx, ..}) = leaf_ty.sty {\n             debug!(\"Found use of ty param num {}\", idx);\n             tps_used[idx as usize - lifetime_count] = true;\n         } else if let ty::TyError = leaf_ty.sty {"}, {"sha": "0698e3ecb6eddb5000f412a1523beb7f06bca4b9", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -10,9 +10,9 @@\n \n //! Code related to processing overloaded binary and unary operators.\n \n-use super::FnCtxt;\n+use super::{FnCtxt, Needs};\n use super::method::MethodCallee;\n-use rustc::ty::{self, Ty, TypeFoldable, NoPreference, PreferMutLvalue, TypeVariants};\n+use rustc::ty::{self, Ty, TypeFoldable, TypeVariants};\n use rustc::ty::TypeVariants::{TyStr, TyRef};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::infer::type_variable::TypeVariableOrigin;\n@@ -40,10 +40,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return_ty\n         };\n \n-        let tcx = self.tcx;\n-        if !tcx.expr_is_lval(lhs_expr) {\n+        if !self.is_place_expr(lhs_expr) {\n             struct_span_err!(\n-                tcx.sess, lhs_expr.span,\n+                self.tcx.sess, lhs_expr.span,\n                 E0067, \"invalid left-hand side expression\")\n             .span_label(\n                 lhs_expr.span,\n@@ -166,18 +165,18 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                op,\n                is_assign);\n \n-        let lhs_pref = match is_assign {\n-            IsAssign::Yes => PreferMutLvalue,\n-            IsAssign::No => NoPreference\n+        let lhs_needs = match is_assign {\n+            IsAssign::Yes => Needs::MutPlace,\n+            IsAssign::No => Needs::None\n         };\n         // Find a suitable supertype of the LHS expression's type, by coercing to\n         // a type variable, to pass as the `Self` to the trait, avoiding invariant\n         // trait matching creating lifetime constraints that are too strict.\n         // E.g. adding `&'a T` and `&'b T`, given `&'x T: Add<&'x T>`, will result\n         // in `&'a T <: &'x T` and `&'b T <: &'x T`, instead of `'a = 'b = 'x`.\n-        let lhs_ty = self.check_expr_coercable_to_type_with_lvalue_pref(lhs_expr,\n+        let lhs_ty = self.check_expr_coercable_to_type_with_needs(lhs_expr,\n             self.next_ty_var(TypeVariableOrigin::MiscVariable(lhs_expr.span)),\n-            lhs_pref);\n+            lhs_needs);\n         let lhs_ty = self.resolve_type_vars_with_obligations(lhs_ty);\n \n         // NB: As we have not yet type-checked the RHS, we don't have the"}, {"sha": "ac7f54250d32b4a3e337b686605585688cf31784", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -732,8 +732,8 @@ and [RFC 809] for more details.\n \"##,\n \n E0067: r##\"\n-The left-hand side of a compound assignment expression must be an lvalue\n-expression. An lvalue expression represents a memory location and includes\n+The left-hand side of a compound assignment expression must be a place\n+expression. A place expression represents a memory location and includes\n item paths (ie, namespaced variables), dereferences, indexing expressions,\n and field references.\n \n@@ -742,7 +742,7 @@ Let's start with some erroneous code examples:\n ```compile_fail,E0067\n use std::collections::LinkedList;\n \n-// Bad: assignment to non-lvalue expression\n+// Bad: assignment to non-place expression\n LinkedList::new() += 1;\n \n // ...\n@@ -783,14 +783,14 @@ function's return type and the value being returned.\n \"##,\n \n E0070: r##\"\n-The left-hand side of an assignment operator must be an lvalue expression. An\n-lvalue expression represents a memory location and can be a variable (with\n+The left-hand side of an assignment operator must be a place expression. An\n+place expression represents a memory location and can be a variable (with\n optional namespacing), a dereference, an indexing expression or a field\n reference.\n \n More details can be found in the [Expressions] section of the Reference.\n \n-[Expressions]: https://doc.rust-lang.org/reference/expressions.html#lvalues-rvalues-and-temporaries\n+[Expressions]: https://doc.rust-lang.org/reference/expressions.html#places-rvalues-and-temporaries\n \n Now, we can go further. Here are some erroneous code examples:\n \n@@ -806,7 +806,7 @@ fn some_other_func() {}\n \n fn some_function() {\n     SOME_CONST = 14; // error : a constant value cannot be changed!\n-    1 = 3; // error : 1 isn't a valid lvalue!\n+    1 = 3; // error : 1 isn't a valid place!\n     some_other_func() = 4; // error : we can't assign value to a function!\n     SomeStruct.x = 12; // error : SomeStruct a structure name but it is used\n                        // like a variable!"}, {"sha": "0dfe9cb970efbd8d7e0024059f3e9b871d03cf84", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -1439,7 +1439,7 @@ impl<'a> MethodDef<'a> {\n                                                          &catch_all_substructure);\n \n             // Final wrinkle: the self_args are expressions that deref\n-            // down to desired l-values, but we cannot actually deref\n+            // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n@@ -1516,7 +1516,7 @@ impl<'a> MethodDef<'a> {\n         } else {\n \n             // Final wrinkle: the self_args are expressions that deref\n-            // down to desired l-values, but we cannot actually deref\n+            // down to desired places, but we cannot actually deref\n             // them when they are fed as r-values into a tuple\n             // expression; here add a layer of borrowing, turning\n             // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`."}, {"sha": "bb02d6d8bba8a2f7ee3ce51d731cbecac0da8811", "filename": "src/test/compile-fail/regions-adjusted-lvalue-op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Fcompile-fail%2Fregions-adjusted-lvalue-op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Fcompile-fail%2Fregions-adjusted-lvalue-op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-adjusted-lvalue-op.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// check that we link regions in mutable lvalue ops correctly - issue #41774\n+// check that we link regions in mutable place ops correctly - issue #41774\n \n struct Data(i32);\n "}, {"sha": "466690e7ca12bea49d1cfcd979e0469eeffa0fd4", "filename": "src/test/incremental/hashes/unary_and_binary_exprs.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Funary_and_binary_exprs.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -404,9 +404,9 @@ pub fn value_cast(a: u32) -> i32 {\n \n \n \n-// Change l-value in assignment ------------------------------------------------\n+// Change place in assignment --------------------------------------------------\n #[cfg(cfail1)]\n-pub fn lvalue() -> i32 {\n+pub fn place() -> i32 {\n     let mut x = 10;\n     let mut y = 11;\n     x = 9;\n@@ -416,7 +416,7 @@ pub fn lvalue() -> i32 {\n #[cfg(not(cfail1))]\n #[rustc_clean(except=\"HirBody,MirOptimized,MirValidated\", cfg=\"cfail2\")]\n #[rustc_clean(cfg=\"cfail3\")]\n-pub fn lvalue() -> i32 {\n+pub fn place() -> i32 {\n     let mut x = 10;\n     let mut y = 11;\n     y = 9;"}, {"sha": "2a1e55d867f72a67edf933231274d10fba38308d", "filename": "src/test/run-pass/issue-18514.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Frun-pass%2Fissue-18514.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Frun-pass%2Fissue-18514.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18514.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -10,7 +10,7 @@\n \n // Test that we don't ICE when translating a generic impl method from\n // an extern crate that contains a match expression on a local\n-// variable lvalue where one of the match case bodies contains an\n+// variable place where one of the match case bodies contains an\n // expression that autoderefs through an overloaded generic deref\n // impl.\n "}, {"sha": "241408ddef13596d68a6969571a9ccb430f05995", "filename": "src/test/run-pass/issue-18845.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Frun-pass%2Fissue-18845.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Frun-pass%2Fissue-18845.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18845.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -11,7 +11,7 @@\n // This used to generate invalid IR in that even if we took the\n // `false` branch we'd still try to free the Box from the other\n // arm. This was due to treating `*Box::new(9)` as an rvalue datum\n-// instead of as an lvalue.\n+// instead of as a place.\n \n fn test(foo: bool) -> u8 {\n     match foo {"}, {"sha": "4de8f6a7194159dafd8c68d0a0308cd69982a3dc", "filename": "src/test/run-pass/method-mut-self-modifies-mut-slice-lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmethod-mut-self-modifies-mut-slice-lvalue.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// Test that an `&mut self` method, when invoked on an lvalue whose\n-// type is `&mut [u8]`, passes in a pointer to the lvalue and not a\n+// Test that an `&mut self` method, when invoked on a place whose\n+// type is `&mut [u8]`, passes in a pointer to the place and not a\n // temporary. Issue #19147.\n \n use std::slice;"}, {"sha": "7ab133bbab4e1b44fd1820e2fb3e6cdccc3d6b09", "filename": "src/test/run-pass/mir_drop_order.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_drop_order.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -41,7 +41,7 @@ fn main() {\n         // all borrows are extended - nothing has been dropped yet\n         assert_eq!(get(), vec![]);\n     }\n-    // in a let-statement, extended lvalues are dropped\n+    // in a let-statement, extended places are dropped\n     // *after* the let result (tho they have the same scope\n     // as far as scope-based borrowck goes).\n     assert_eq!(get(), vec![0, 2, 3, 1]);"}, {"sha": "18fb8e2e408f196f5d599b2954a170a251dbd1d9", "filename": "src/test/run-pass/type-ascription.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Frun-pass%2Ftype-ascription.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Frun-pass%2Ftype-ascription.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-ascription.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -40,6 +40,6 @@ fn main() {\n     assert_eq!(b, 1: u16);\n \n     let mut v = Vec::new();\n-    v: Vec<u8> = vec![1, 2, 3]; // Lvalue type ascription\n+    v: Vec<u8> = vec![1, 2, 3]; // Place expression type ascription\n     assert_eq!(v, [1u8, 2, 3]);\n }"}, {"sha": "22751c4a37cdd0b97308047e4e0701a483fb63d1", "filename": "src/test/ui/issue-26093.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Fui%2Fissue-26093.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Fui%2Fissue-26093.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-26093.rs?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-macro_rules! not_an_lvalue {\n+macro_rules! not_a_place {\n     ($thing:expr) => {\n         $thing = 42;\n         //~^ ERROR invalid left-hand side expression\n     }\n }\n \n fn main() {\n-    not_an_lvalue!(99);\n+    not_a_place!(99);\n }"}, {"sha": "b850852623fd8ddd449c07b7a1cec039a67915d7", "filename": "src/test/ui/issue-26093.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Fui%2Fissue-26093.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src%2Ftest%2Fui%2Fissue-26093.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-26093.stderr?ref=90eb44a5897c39e3dff9c7e48e3973671dcd9496", "patch": "@@ -4,8 +4,8 @@ error[E0070]: invalid left-hand side expression\n 13 |         $thing = 42;\n    |         ^^^^^^^^^^^ left-hand of expression not valid\n ...\n-19 |     not_an_lvalue!(99);\n-   |     ------------------- in this macro invocation\n+19 |     not_a_place!(99);\n+   |     ----------------- in this macro invocation\n \n error: aborting due to previous error\n "}]}