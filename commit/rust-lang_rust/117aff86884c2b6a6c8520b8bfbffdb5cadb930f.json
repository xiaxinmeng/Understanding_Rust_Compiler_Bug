{"sha": "117aff86884c2b6a6c8520b8bfbffdb5cadb930f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExN2FmZjg2ODg0YzJiNmE2Yzg1MjBiOGJmYmZmZGI1Y2FkYjkzMGY=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-22T02:30:53Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-04-22T02:31:13Z"}, "message": "rustc: Intern types", "tree": {"sha": "cac4f02def475159f415ccd33c2a914ebd8c6700", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cac4f02def475159f415ccd33c2a914ebd8c6700"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/117aff86884c2b6a6c8520b8bfbffdb5cadb930f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/117aff86884c2b6a6c8520b8bfbffdb5cadb930f", "html_url": "https://github.com/rust-lang/rust/commit/117aff86884c2b6a6c8520b8bfbffdb5cadb930f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/117aff86884c2b6a6c8520b8bfbffdb5cadb930f/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b047bad6e1e33e460ead379534bb95829248a6a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b047bad6e1e33e460ead379534bb95829248a6a", "html_url": "https://github.com/rust-lang/rust/commit/3b047bad6e1e33e460ead379534bb95829248a6a"}], "stats": {"total": 404, "additions": 73, "deletions": 331}, "files": [{"sha": "f052661e17638d0b19c2cd4955c265e1c3423184", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/117aff86884c2b6a6c8520b8bfbffdb5cadb930f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117aff86884c2b6a6c8520b8bfbffdb5cadb930f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=117aff86884c2b6a6c8520b8bfbffdb5cadb930f", "patch": "@@ -2854,12 +2854,12 @@ fn target_type(@crate_ctxt cx, @ty.t t) -> @ty.t {\n         case (ty.ty_int) {\n             auto struct_ty = ty.mk_mach(cx.tystore,\n                                         cx.sess.get_targ_cfg().int_type);\n-            ret ty.copy_cname(struct_ty, t);\n+            ret ty.copy_cname(cx.tystore, struct_ty, t);\n         }\n         case (ty.ty_uint) {\n             auto struct_ty = ty.mk_mach(cx.tystore,\n                                         cx.sess.get_targ_cfg().uint_type);\n-            ret ty.copy_cname(struct_ty, t);\n+            ret ty.copy_cname(cx.tystore, struct_ty, t);\n         }\n         case (_) { /* fall through */ }\n     }"}, {"sha": "5829c0bed2dbdcf21b69410e8477ace47dcafc1a", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 67, "deletions": 327, "changes": 394, "blob_url": "https://github.com/rust-lang/rust/blob/117aff86884c2b6a6c8520b8bfbffdb5cadb930f/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117aff86884c2b6a6c8520b8bfbffdb5cadb930f/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=117aff86884c2b6a6c8520b8bfbffdb5cadb930f", "patch": "@@ -36,8 +36,7 @@ fn method_ty_to_fn_ty(@type_store tystore, method m) -> @ty.t {\n     ret mk_fn(tystore, m.proto, m.inputs, m.output);\n }\n \n-// Do not construct these manually. Soon we want to intern these, at which\n-// point that will break.\n+// Never construct these manually. These are interned.\n //\n // TODO: It'd be really nice to be able to hide this definition from the\n // outside world, to enforce the above invariant.\n@@ -101,21 +100,37 @@ type ty_param_count_and_ty = tup(uint, @t);\n type type_cache = hashmap[ast.def_id,ty_param_count_and_ty];\n \n \n-type type_store = hashmap[@t,()];\n+type type_store = hashmap[@t,@t];\n \n-fn mk_type_store() -> @hashmap[@t,()] {\n+fn mk_type_store() -> @type_store {\n     auto hasher = hash_ty;\n-    auto eqer = eq_ty;\n-    ret @map.mk_hashmap[@t,()](hasher, eqer);\n+    auto eqer = eq_ty_full;\n+    ret @map.mk_hashmap[@t,@t](hasher, eqer);\n }\n \n // Type constructors\n \n-// This is a private constructor to this module. External users should always\n+// These are private constructors to this module. External users should always\n // use the mk_foo() functions below.\n fn gen_ty(@type_store tystore, &sty st) -> @t {\n-    // TODO: Intern the type.\n-    ret @rec(struct=st, cname=none[str], hash=hash_type_structure(st));\n+    ret gen_ty_full(tystore, st, none[str]);\n+}\n+\n+fn gen_ty_full(@type_store tystore, &sty st, option.t[str] cname) -> @t {\n+    auto h = hash_type_structure(st);\n+    auto new_type = @rec(struct=st, cname=cname, hash=h);\n+\n+    // Is it interned?\n+    alt (tystore.find(new_type)) {\n+        case (some[@t](?typ)) {\n+            ret typ;\n+        }\n+        case (none[@t]) {\n+            // Nope. Insert it and return.\n+            tystore.insert(new_type, new_type);\n+            ret new_type;\n+        }\n+    }\n }\n \n fn mk_nil(@type_store ts) -> @t          { ret gen_ty(ts, ty_nil); }\n@@ -438,37 +453,38 @@ fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n         case (ty_type)          { /* no-op */ }\n         case (ty_native)        { /* no-op */ }\n         case (ty_box(?tm)) {\n-            ty = copy_cname(mk_box(tystore,\n+            ty = copy_cname(tystore,\n+                            mk_box(tystore,\n                                    rec(ty=fold_ty(tystore, fld, tm.ty),\n                                        mut=tm.mut)), ty);\n         }\n         case (ty_vec(?tm)) {\n-            ty = copy_cname(mk_vec(tystore,\n-                                   rec(ty=fold_ty(tystore, fld, tm.ty),\n-                                       mut=tm.mut)), ty);\n+            ty = copy_cname(tystore,\n+                mk_vec(tystore, rec(ty=fold_ty(tystore, fld, tm.ty),\n+                                    mut=tm.mut)), ty);\n         }\n         case (ty_port(?subty)) {\n-            ty = copy_cname(mk_port(tystore, fold_ty(tystore, fld, subty)),\n-                            ty);\n+            ty = copy_cname(tystore,\n+                mk_port(tystore, fold_ty(tystore, fld, subty)), ty);\n         }\n         case (ty_chan(?subty)) {\n-            ty = copy_cname(mk_chan(tystore, fold_ty(tystore, fld, subty)),\n-                            ty);\n+            ty = copy_cname(tystore,\n+                mk_chan(tystore, fold_ty(tystore, fld, subty)), ty);\n         }\n         case (ty_tag(?tid, ?subtys)) {\n             let vec[@t] new_subtys = vec();\n             for (@t subty in subtys) {\n                 new_subtys += vec(fold_ty(tystore, fld, subty));\n             }\n-            ty = copy_cname(mk_tag(tystore, tid, new_subtys), ty);\n+            ty = copy_cname(tystore, mk_tag(tystore, tid, new_subtys), ty);\n         }\n         case (ty_tup(?mts)) {\n             let vec[mt] new_mts = vec();\n             for (mt tm in mts) {\n                 auto new_subty = fold_ty(tystore, fld, tm.ty);\n                 new_mts += vec(rec(ty=new_subty, mut=tm.mut));\n             }\n-            ty = copy_cname(mk_tup(tystore, new_mts), ty);\n+            ty = copy_cname(tystore, mk_tup(tystore, new_mts), ty);\n         }\n         case (ty_rec(?fields)) {\n             let vec[field] new_fields = vec();\n@@ -477,15 +493,15 @@ fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n                 auto new_mt = rec(ty=new_ty, mut=fl.mt.mut);\n                 new_fields += vec(rec(ident=fl.ident, mt=new_mt));\n             }\n-            ty = copy_cname(mk_rec(tystore, new_fields), ty);\n+            ty = copy_cname(tystore, mk_rec(tystore, new_fields), ty);\n         }\n         case (ty_fn(?proto, ?args, ?ret_ty)) {\n             let vec[arg] new_args = vec();\n             for (arg a in args) {\n                 auto new_ty = fold_ty(tystore, fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ty = copy_cname(mk_fn(tystore, proto, new_args,\n+            ty = copy_cname(tystore, mk_fn(tystore, proto, new_args,\n                                   fold_ty(tystore, fld, ret_ty)),\n                             ty);\n         }\n@@ -495,7 +511,7 @@ fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n                 auto new_ty = fold_ty(tystore, fld, a.ty);\n                 new_args += vec(rec(mode=a.mode, ty=new_ty));\n             }\n-            ty = copy_cname(mk_native_fn(tystore, abi, new_args,\n+            ty = copy_cname(tystore, mk_native_fn(tystore, abi, new_args,\n                                          fold_ty(tystore, fld, ret_ty)),\n                             ty);\n         }\n@@ -512,7 +528,7 @@ fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n                                        output=fold_ty(tystore, fld,\n                                                       m.output)));\n             }\n-            ty = copy_cname(mk_obj(tystore, new_methods), ty);\n+            ty = copy_cname(tystore, mk_obj(tystore, new_methods), ty);\n         }\n         case (ty_var(_))         { /* no-op */ }\n         case (ty_local(_))       { /* no-op */ }\n@@ -525,16 +541,14 @@ fn fold_ty(@type_store tystore, ty_fold fld, @t ty_0) -> @t {\n \n // Type utilities\n \n-fn rename(@t typ, str new_cname) -> @t {\n-    ret @rec(struct=typ.struct, cname=some[str](new_cname), hash=typ.hash);\n+fn rename(@type_store tystore, @t typ, str new_cname) -> @t {\n+    ret gen_ty_full(tystore, typ.struct, some[str](new_cname));\n }\n \n // Returns a type with the structural part taken from `struct_ty` and the\n // canonical name from `cname_ty`.\n-fn copy_cname(@t struct_ty, @t cname_ty) -> @t {\n-    ret @rec(struct=struct_ty.struct,\n-             cname=cname_ty.cname,\n-             hash=struct_ty.hash);\n+fn copy_cname(@type_store tystore, @t struct_ty, @t cname_ty) -> @t {\n+    ret gen_ty_full(tystore, struct_ty.struct, cname_ty.cname);\n }\n \n // FIXME: remove me when == works on these tags.\n@@ -1028,7 +1042,7 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n         case (ty_tag(?id_a, ?tys_a)) {\n             alt (b) {\n                 case (ty_tag(?id_b, ?tys_b)) {\n-                    if (id_a != id_b) { ret false; }\n+                    if (!equal_def(id_a, id_b)) { ret false; }\n \n                     auto len = _vec.len[@ty.t](tys_a);\n                     if (len != _vec.len[@ty.t](tys_b)) { ret false; }\n@@ -1134,10 +1148,11 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n                         auto m_a = methods_a.(i); auto m_b = methods_b.(i);\n                         if (!equal_proto(m_a.proto, m_b.proto) ||\n                                 !_str.eq(m_a.ident, m_b.ident) ||\n-                                equal_fn(m_a.inputs, m_a.output,\n-                                         m_b.inputs, m_b.output)) {\n+                                !equal_fn(m_a.inputs, m_a.output,\n+                                          m_b.inputs, m_b.output)) {\n                             ret false;\n                         }\n+                        i += 1u;\n                     }\n                     ret true;\n                 }\n@@ -1183,315 +1198,40 @@ fn equal_type_structures(&sty a, &sty b) -> bool {\n     }\n }\n \n-\n-fn ty_is_simple(&@t a) -> bool {\n-    // a \"simple\" type is one in which the hash\n-    // field uniquely identifies the type. In\n-    // a world with sane compiler-generated\n-    // structural comparison code, we'd not\n-    // be producing this sort of thing.\n-    alt (a.struct) {\n-        case (ty_nil) { ret true; }\n-        case (ty_bool) { ret true; }\n-        case (ty_int) { ret true; }\n-        case (ty_float) { ret true; }\n-        case (ty_uint) { ret true; }\n-        case (ty_machine(_)) { ret true; }\n-        case (ty_char) { ret true; }\n-        case (ty_str) { ret true; }\n-        case (ty_task) { ret true; }\n-        case (ty_type) { ret true; }\n-        case (_) { ret false; }\n-    }\n-    ret false;\n-}\n-\n-\n-fn eq_args(vec[arg] az, vec[arg] bz) -> bool {\n-    if (_vec.len[arg](az) !=\n-        _vec.len[arg](bz)) { ret false; }\n-    let uint i = 0u;\n-    for (arg a in az) {\n-        if (a.mode != bz.(i).mode) {\n-            ret false;\n-        }\n-        if (!eq_ty(a.ty, bz.(i).ty)) {\n-            ret false;\n-        }\n-        i += 1u;\n-    }\n-    ret true;\n-}\n-\n-\n-fn eq_tys(vec[@t] az, vec[@t] bz) -> bool {\n-    if (_vec.len[@t](az) !=\n-        _vec.len[@t](bz)) { ret false; }\n-    let uint i = 0u;\n-    for (@t a in az) {\n-        if (!eq_ty(a, bz.(i))) {\n-            ret false;\n-        }\n-        i += 1u;\n-    }\n-    ret true;\n-}\n-\n-fn eq_mt(&mt a, &mt b) -> bool {\n-    if (a.mut != b.mut) {\n-        ret false;\n-    }\n-    ret eq_ty(a.ty, b.ty);\n-}\n-\n-fn eq_mts(vec[mt] az, vec[mt] bz) -> bool {\n-    if (_vec.len[mt](az) !=\n-        _vec.len[mt](bz)) { ret false; }\n-    let uint i = 0u;\n-    for (mt a in az) {\n-        if (!eq_mt(a, bz.(i))) {\n-            ret false;\n-        }\n-        i += 1u;\n-    }\n-    ret true;\n-}\n-\n-\n-fn eq_fields(vec[field] az, vec[field] bz) -> bool {\n-    if (_vec.len[field](az) !=\n-        _vec.len[field](bz)) { ret false; }\n-    let uint i = 0u;\n-    for (field a in az) {\n-        if (!_str.eq(a.ident, bz.(i).ident)) {\n-            ret false;\n-        }\n-        if (a.mt.mut != bz.(i).mt.mut) {\n-            ret false;\n-        }\n-        if (!eq_ty(a.mt.ty, bz.(i).mt.ty)) {\n-            ret false;\n-        }\n-        i += 1u;\n-    }\n-    ret true;\n-}\n-\n-fn eq_def_id(&ast.def_id a, &ast.def_id b) -> bool {\n-    ret a._0 == b._0 && a._1 == b._1;\n-}\n-\n-fn eq_ty(&@t a, &@t b) -> bool {\n-\n+// An expensive type equality function. This function is private to this\n+// module.\n+fn eq_ty_full(&@t a, &@t b) -> bool {\n+    // Check hashes (fast path).\n     if (a.hash != b.hash) {\n         ret false;\n     }\n \n-\n-    if (ty_is_simple(a)) {\n-        if (ty_is_simple(b)) {\n-            ret a.hash == b.hash;\n-        }\n-        ret false;\n-    }\n-\n-    alt (a.struct) {\n-        case (ty_tag(?did_a, ?tys_a)) {\n-            alt (b.struct) {\n-                case (ty_tag(?did_b, ?tys_b)) {\n-                    if (!eq_def_id(did_a, did_b)) {\n-                        ret false;\n-                    }\n-                    ret eq_tys(tys_a, tys_b);\n-                }\n+    // Check canonical names.\n+    alt (a.cname) {\n+        case (none[str]) {\n+            alt (b.cname) {\n+                case (none[str]) { /* ok */ }\n                 case (_) { ret false; }\n             }\n         }\n-\n-        case (ty_box(?mt_a)) {\n-            alt (b.struct) {\n-                case (ty_box(?mt_b)) {\n-                    ret eq_mt(mt_a, mt_b);\n-                }\n-                case (_) {\n-                    ret false;\n-                }\n-            }\n-        }\n-\n-        case (ty_vec(?mt_a)) {\n-            alt (b.struct) {\n-                case (ty_vec(?mt_b)) {\n-                    ret eq_mt(mt_a, mt_b);\n-                }\n-                case (_) {\n-                    ret false;\n-                }\n-            }\n-        }\n-\n-        case (ty_port(?t_a)) {\n-            alt (b.struct) {\n-                case (ty_port(?t_b)) {\n-                    ret eq_ty(t_a, t_b);\n-                }\n-                case (_) {\n-                    ret false;\n-                }\n-            }\n-        }\n-\n-        case (ty_chan(?t_a)) {\n-            alt (b.struct) {\n-                case (ty_chan(?t_b)) {\n-                    ret eq_ty(t_a, t_b);\n-                }\n-                case (_) {\n-                    ret false;\n-                }\n-            }\n-        }\n-\n-        case (ty_tup(?mts_a)) {\n-            alt (b.struct) {\n-                case (ty_tup(?mts_b)) {\n-                    ret eq_mts(mts_a, mts_b);\n-                }\n-                case (_) {\n-                    ret false;\n-                }\n-            }\n-        }\n-\n-        case (ty_rec(?fields_a)) {\n-            alt (b.struct) {\n-                case (ty_rec(?fields_b)) {\n-                    ret eq_fields(fields_a, fields_b);\n-                }\n-                case (_) {\n-                    ret false;\n-                }\n-            }\n-        }\n-\n-        case (ty_fn(?proto_a, ?args_a, ?rty_a)) {\n-            alt (b.struct) {\n-                case (ty_fn(?proto_b, ?args_b, ?rty_b)) {\n-                    if (proto_a != proto_b) {\n-                        ret false;\n-                    }\n-                    if (!eq_args(args_a, args_b)) {\n-                        ret false;\n-                    }\n-                    ret eq_ty(rty_a, rty_b);\n-                }\n-                case (_) {\n-                    ret false;\n-                }\n-            }\n-        }\n-\n-        case (ty_native_fn(?abi_a, ?args_a, ?rty_a)) {\n-            alt (b.struct) {\n-                case (ty_native_fn(?abi_b, ?args_b, ?rty_b)) {\n-                    if (abi_a != abi_b) {\n-                        ret false;\n-                    }\n-                    if (!eq_args(args_a, args_b)) {\n-                        ret false;\n-                    }\n-                    ret eq_ty(rty_a, rty_b);\n-                }\n-                case (_) {\n-                    ret false;\n-                }\n-            }\n-        }\n-\n-        case (ty_obj(?methods_a)) {\n-            alt (b.struct) {\n-                case (ty_obj(?methods_b)) {\n-                    if (_vec.len[method](methods_a) !=\n-                        _vec.len[method](methods_b)) {\n-                        ret false;\n-                    }\n-                    let uint i = 0u;\n-                    for (method m_a in methods_a) {\n-                        if (!_str.eq(m_a.ident,\n-                                     methods_b.(i).ident)) {\n-                            ret false;\n-                        }\n-                        if (!eq_args(m_a.inputs,\n-                                     methods_b.(i).inputs)) {\n-                            ret false;\n-                        }\n-                        if (!eq_ty(m_a.output,\n-                                   methods_b.(i).output)) {\n-                            ret false;\n-                        }\n-                        i += 1u;\n-                    }\n-                    ret true;\n-                }\n-                case (_) {\n-                    ret false;\n-                }\n-            }\n-        }\n-\n-        case (ty_var(?v_a)) {\n-            alt (b.struct) {\n-                case (ty_var(?v_b)) {\n-                    ret v_a == v_b;\n-                }\n-                case (_) { ret false; }\n-            }\n-        }\n-\n-        case (ty_local(?did_a)) {\n-            alt (b.struct) {\n-                case (ty_local(?did_b)) {\n-                    ret eq_def_id(did_a, did_b);\n-                }\n-                case (_) { ret false; }\n-            }\n-        }\n-\n-        case (ty_param(?pid_a)) {\n-            alt (b.struct) {\n-                case (ty_param(?pid_b)) {\n-                    ret pid_a == pid_b;\n+        case (some[str](?s_a)) {\n+            alt (b.cname) {\n+                case (some[str](?s_b)) {\n+                    if (!_str.eq(s_a, s_b)) { ret false; }\n                 }\n                 case (_) { ret false; }\n             }\n         }\n+    }\n \n-        case (ty_bound_param(?pid_a)) {\n-            alt (b.struct) {\n-                case (ty_bound_param(?pid_b)) {\n-                    ret pid_a == pid_b;\n-                }\n-                case (_) { ret false; }\n-            }\n-        }\n+    // Check structures.\n+    ret equal_type_structures(a.struct, b.struct);\n+}\n \n-        // FIXME: this should carry the native ID with it.\n-        case (ty_native) {\n-            alt (b.struct) {\n-                case (ty_native) {\n-                    ret true;\n-                }\n-                case (_) { ret false; }\n-            }\n-        }\n+// This is the equality function the public should use. It works as long as\n+// the types are interned.\n+fn eq_ty(&@t a, &@t b) -> bool { ret Box.ptr_eq[t](a, b); }\n \n-        case (_) {\n-            // Should be impossible.\n-            fail;\n-        }\n-    }\n-    ret false;\n-}\n \n fn ann_to_type(&ast.ann ann) -> @t {\n     alt (ann) {"}, {"sha": "b143a5a1739b1067aa2224dbf907925f3179e629", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/117aff86884c2b6a6c8520b8bfbffdb5cadb930f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/117aff86884c2b6a6c8520b8bfbffdb5cadb930f/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=117aff86884c2b6a6c8520b8bfbffdb5cadb930f", "patch": "@@ -330,7 +330,9 @@ fn ast_ty_to_ty(@ty.type_store tystore,\n \n     alt (cname) {\n         case (none[str]) { /* no-op */ }\n-        case (some[str](?cname_str)) { typ = ty.rename(typ, cname_str); }\n+        case (some[str](?cname_str)) {\n+            typ = ty.rename(tystore, typ, cname_str);\n+        }\n     }\n     ret typ;\n }\n@@ -440,7 +442,7 @@ mod Collect {\n         auto methods = _vec.map[@ast.method,method](f, obj_info.methods);\n \n         auto t_obj = ty.mk_obj(cx.tystore, ty.sort_methods(methods));\n-        t_obj = ty.rename(t_obj, id);\n+        t_obj = ty.rename(cx.tystore, t_obj, id);\n         auto ty_param_count = _vec.len[ast.ty_param](ty_params);\n         ret tup(ty_param_count, t_obj);\n     }"}]}