{"sha": "888262b337d90a275074a2ad2ac119984b55205a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4ODI2MmIzMzdkOTBhMjc1MDc0YTJhZDJhYzExOTk4NGI1NTIwNWE=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-26T14:23:04Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-01-26T14:23:11Z"}, "message": "Allow operator overloading of the indexing operator\n\nThe method `op_index` (which takes a single argument) is used for\nthis.\n\nIssue #1520", "tree": {"sha": "b01f62f580da8c3f46b42e5cf2393335af763868", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b01f62f580da8c3f46b42e5cf2393335af763868"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/888262b337d90a275074a2ad2ac119984b55205a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/888262b337d90a275074a2ad2ac119984b55205a", "html_url": "https://github.com/rust-lang/rust/commit/888262b337d90a275074a2ad2ac119984b55205a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/888262b337d90a275074a2ad2ac119984b55205a/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87b064b249657c8e65079d01beb77409f69d49cd", "url": "https://api.github.com/repos/rust-lang/rust/commits/87b064b249657c8e65079d01beb77409f69d49cd", "html_url": "https://github.com/rust-lang/rust/commit/87b064b249657c8e65079d01beb77409f69d49cd"}], "stats": {"total": 145, "additions": 88, "deletions": 57}, "files": [{"sha": "0548026c0c5d87c4ee517d1715614bfb79b9a985", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/888262b337d90a275074a2ad2ac119984b55205a/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888262b337d90a275074a2ad2ac119984b55205a/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=888262b337d90a275074a2ad2ac119984b55205a", "patch": "@@ -1983,9 +1983,12 @@ fn visit_mod_with_impl_scope(e: @env, m: ast::_mod, s: span, sc: iscopes,\n \n fn resolve_impl_in_expr(e: @env, x: @ast::expr, sc: iscopes, v: vt<iscopes>) {\n     alt x.node {\n+      // Store the visible impls in all exprs that might need them\n       ast::expr_field(_, _, _) | ast::expr_path(_) | ast::expr_cast(_, _) |\n       ast::expr_binary(_, _, _) | ast::expr_unary(_, _) |\n-      ast::expr_assign_op(_, _, _) { e.impl_map.insert(x.id, sc); }\n+      ast::expr_assign_op(_, _, _) | ast::expr_index(_, _) {\n+        e.impl_map.insert(x.id, sc);\n+      }\n       _ {}\n     }\n     visit::visit_expr(x, sc, v);"}, {"sha": "8ab699ea92790db74404343fb547b17f1cb3bdfb", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/888262b337d90a275074a2ad2ac119984b55205a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888262b337d90a275074a2ad2ac119984b55205a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=888262b337d90a275074a2ad2ac119984b55205a", "patch": "@@ -2724,9 +2724,8 @@ fn trans_rec_field(bcx: @block_ctxt, base: @ast::expr,\n     ret {bcx: bcx, val: val, kind: owned};\n }\n \n-fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n-               id: ast::node_id) -> lval_result {\n-    // Is this an interior vector?\n+fn trans_index(cx: @block_ctxt, ex: @ast::expr, base: @ast::expr,\n+               idx: @ast::expr) -> lval_result {\n     let base_ty = ty::expr_ty(bcx_tcx(cx), base);\n     let exp = trans_temp_expr(cx, base);\n     let lv = autoderef(exp.bcx, exp.val, base_ty);\n@@ -2745,7 +2744,7 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n         ix_val = Trunc(bcx, ix.val, ccx.int_type);\n     } else { ix_val = ix.val; }\n \n-    let unit_ty = node_id_type(bcx_ccx(cx), id);\n+    let unit_ty = node_id_type(bcx_ccx(cx), ex.id);\n     let unit_sz = size_of(bcx, unit_ty);\n     bcx = unit_sz.bcx;\n     maybe_name_value(bcx_ccx(cx), unit_sz.val, \"unit_sz\");\n@@ -2760,11 +2759,11 @@ fn trans_index(cx: @block_ctxt, sp: span, base: @ast::expr, idx: @ast::expr,\n     CondBr(bcx, bounds_check, next_cx.llbb, fail_cx.llbb);\n     // fail: bad bounds check.\n \n-    trans_fail(fail_cx, some::<span>(sp), \"bounds check\");\n+    trans_fail(fail_cx, some(ex.span), \"bounds check\");\n     let elt =\n         if check type_has_static_size(ncx, unit_ty) {\n             let elt_1 = GEP(next_cx, body, [ix_val]);\n-            let llunitty = type_of(ncx, sp, unit_ty);\n+            let llunitty = type_of(ncx, ex.span, unit_ty);\n             PointerCast(next_cx, elt_1, T_ptr(llunitty))\n         } else {\n             body = PointerCast(next_cx, body, T_ptr(T_i8()));\n@@ -2812,7 +2811,7 @@ fn trans_lval(cx: @block_ctxt, e: @ast::expr) -> lval_result {\n         ret trans_rec_field(cx, base, ident);\n       }\n       ast::expr_index(base, idx) {\n-        ret trans_index(cx, e.span, base, idx, e.id);\n+        ret trans_index(cx, e, base, idx);\n       }\n       ast::expr_unary(ast::deref, base) {\n         let ccx = bcx_ccx(cx);\n@@ -3560,6 +3559,15 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n       ast::expr_field(_, _, _) {\n         fail \"Taking the value of a method does not work yet (issue #435)\";\n       }\n+      ast::expr_index(base, idx) {\n+        // If it is here, it's not an lval, so this is a user-defined index op\n+        let origin = bcx_ccx(bcx).method_map.get(e.id);\n+        let callee_id = ast_util::op_expr_callee_id(e);\n+        let fty = ty::node_id_to_monotype(tcx, callee_id);\n+        ret trans_call_inner(bcx, fty, {|bcx|\n+            trans_impl::trans_method_callee(bcx, callee_id, base, origin)\n+        }, [idx], e.id, dest);\n+      }\n \n       // These return nothing\n       ast::expr_break {"}, {"sha": "160bb832f13809b3afd9c406a50916daa707112c", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/888262b337d90a275074a2ad2ac119984b55205a/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888262b337d90a275074a2ad2ac119984b55205a/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=888262b337d90a275074a2ad2ac119984b55205a", "patch": "@@ -1607,9 +1607,10 @@ fn expr_has_ty_params(cx: ctxt, expr: @ast::expr) -> bool {\n \n fn expr_is_lval(method_map: typeck::method_map, e: @ast::expr) -> bool {\n     alt e.node {\n-      ast::expr_path(_) | ast::expr_index(_, _) |\n-      ast::expr_unary(ast::deref, _) { true }\n-      ast::expr_field(base, ident, _) { !method_map.contains_key(e.id) }\n+      ast::expr_path(_) | ast::expr_unary(ast::deref, _) { true }\n+      ast::expr_field(_, _, _) | ast::expr_index(_, _) {\n+        !method_map.contains_key(e.id)\n+      }\n       _ { false }\n     }\n }"}, {"sha": "90765710cf7bf2c44bc0a16d97b3b0f13e5a8d1c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 58, "deletions": 45, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/888262b337d90a275074a2ad2ac119984b55205a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888262b337d90a275074a2ad2ac119984b55205a/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=888262b337d90a275074a2ad2ac119984b55205a", "patch": "@@ -1780,6 +1780,22 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n           _ { none }\n         }\n     }\n+    fn lookup_op_method(fcx: @fn_ctxt, op_ex: @ast::expr, self_t: ty::t,\n+                        opname: str,\n+                        args: [option::t<@ast::expr>]) -> option::t<ty::t> {\n+        let isc = fcx.ccx.impl_map.get(op_ex.id);\n+        alt lookup_method(fcx, isc, opname, self_t, op_ex.span) {\n+          some({method_ty, n_tps: 0u, substs, origin}) {\n+            let callee_id = ast_util::op_expr_callee_id(op_ex);\n+            write::ty_fixup(fcx, callee_id, {substs: some(substs),\n+                                             ty: method_ty});\n+            check_call_or_bind(fcx, op_ex.span, method_ty, args);\n+            fcx.ccx.method_map.insert(op_ex.id, origin);\n+            some(ty::ty_fn_ret(fcx.ccx.tcx, method_ty))\n+          }\n+          _ { none }\n+        }\n+    }\n     fn check_binop(fcx: @fn_ctxt, ex: @ast::expr, ty: ty::t,\n                    op: ast::binop, rhs: @ast::expr) -> ty::t {\n         let resolved_t = structurally_resolved_type(fcx, ex.span, ty);\n@@ -1792,22 +1808,14 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n             };\n         }\n \n-        let isc = fcx.ccx.impl_map.get(ex.id);\n         alt binop_method(op) {\n           some(name) {\n-            alt lookup_method(fcx, isc, name, resolved_t, ex.span) {\n-              some({method_ty, n_tps: 0u, substs, origin}) {\n-                let callee_id = ast_util::op_expr_callee_id(ex);\n-                write::ty_fixup(fcx, callee_id, {substs: some(substs),\n-                                                 ty: method_ty});\n-                check_call_or_bind(fcx, ex.span, method_ty, [some(rhs)]);\n-                fcx.ccx.method_map.insert(ex.id, origin);\n-                ret ty::ty_fn_ret(tcx, method_ty);\n-              }\n+            alt lookup_op_method(fcx, ex, resolved_t, name, [some(rhs)]) {\n+              some(ret_ty) { ret ret_ty; }\n               _ {}\n             }\n           }\n-          none {}\n+          _ {}\n         }\n         tcx.sess.span_err(\n             ex.span, \"binary operation \" + ast_util::binop_to_str(op) +\n@@ -1817,23 +1825,15 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n     }\n     fn check_user_unop(fcx: @fn_ctxt, op_str: str, mname: str,\n                        ex: @ast::expr, rhs_t: ty::t) -> ty::t {\n-        let isc = fcx.ccx.impl_map.get(ex.id);\n-        let tcx = fcx.ccx.tcx;\n-        alt lookup_method(fcx, isc, mname, rhs_t, ex.span) {\n-          some({method_ty, n_tps: 0u, substs, origin}) {\n-            let callee_id = ast_util::op_expr_callee_id(ex);\n-            write::ty_fixup(fcx, callee_id, {substs: some(substs),\n-                                             ty: method_ty});\n-            check_call_or_bind(fcx, ex.span, method_ty, []);\n-            fcx.ccx.method_map.insert(ex.id, origin);\n-            ret ty::ty_fn_ret(tcx, method_ty);\n+        alt lookup_op_method(fcx, ex, rhs_t, mname, []) {\n+          some(ret_ty) { ret_ty }\n+          _ {\n+            fcx.ccx.tcx.sess.span_err(\n+                ex.span, #fmt[\"cannot apply unary operator `%s` to type `%s`\",\n+                              op_str, ty_to_str(fcx.ccx.tcx, rhs_t)]);\n+            rhs_t\n           }\n-          _ {}\n         }\n-        tcx.sess.span_err(\n-            ex.span, #fmt[\"can not apply unary operator `%s` to type `%s`\",\n-                          op_str, ty_to_str(tcx, rhs_t)]);\n-        rhs_t\n     }\n \n     let tcx = fcx.ccx.tcx;\n@@ -1888,7 +1888,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n               }\n               ty::ty_ptr(inner) {\n                 oper_t = inner.ty;\n-                require_unsafe(fcx.ccx.tcx.sess, fcx.purity, expr.span);\n+                require_unsafe(tcx.sess, fcx.purity, expr.span);\n               }\n               _ {\n                 tcx.sess.span_fatal(expr.span,\n@@ -1989,7 +1989,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       ast::expr_copy(a) {\n         bot = check_expr_with_unifier(fcx, a, unify, expected);\n         let tpot =\n-            ty::node_id_to_ty_param_substs_opt_and_ty(fcx.ccx.tcx, a.id);\n+            ty::node_id_to_ty_param_substs_opt_and_ty(tcx, a.id);\n         write::ty_fixup(fcx, id, tpot);\n \n       }\n@@ -2073,9 +2073,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         let proto = alt ty::struct(tcx, expected) {\n           ty::ty_fn({proto, _}) { proto }\n           _ {\n-            fcx.ccx.tcx.sess.span_warn(\n-                expr.span,\n-                \"unable to infer kind of closure, defaulting to block\");\n+            tcx.sess.span_warn(expr.span, \"unable to infer kind of closure, \\\n+                                           defaulting to block\");\n             ast::proto_block\n           }\n         };\n@@ -2190,10 +2189,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         vec::reserve(elt_ts, vec::len(elts));\n         for e in elts {\n             check_expr(fcx, e);\n-            let ety = expr_ty(fcx.ccx.tcx, e);\n+            let ety = expr_ty(tcx, e);\n             elt_ts += [ety];\n         }\n-        let typ = ty::mk_tup(fcx.ccx.tcx, elt_ts);\n+        let typ = ty::mk_tup(tcx, elt_ts);\n         write::ty_only_fixup(fcx, id, typ);\n       }\n       ast::expr_rec(fields, base) {\n@@ -2312,26 +2311,39 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n       }\n       ast::expr_index(base, idx) {\n         bot |= check_expr(fcx, base);\n-        let base_t = expr_ty(tcx, base);\n-        base_t = do_autoderef(fcx, expr.span, base_t);\n+        let raw_base_t = expr_ty(tcx, base);\n+        let base_t = do_autoderef(fcx, expr.span, raw_base_t);\n         bot |= check_expr(fcx, idx);\n         let idx_t = expr_ty(tcx, idx);\n-        if !type_is_integral(fcx, idx.span, idx_t) {\n-            tcx.sess.span_err(idx.span,\n-                              \"mismatched types: expected \\\n-                               `integer` but found `\"\n-                                  + ty_to_str(tcx, idx_t) + \"`\");\n+        fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n+            if !type_is_integral(fcx, sp, t) {\n+                fcx.ccx.tcx.sess.span_err(sp, \"mismatched types: expected \\\n+                                               `integer` but found `\"\n+                                  + ty_to_str(fcx.ccx.tcx, t) + \"`\");\n+            }\n         }\n         alt structure_of(fcx, expr.span, base_t) {\n-          ty::ty_vec(mt) { write::ty_only_fixup(fcx, id, mt.ty); }\n+          ty::ty_vec(mt) {\n+            require_integral(fcx, idx.span, idx_t);\n+            write::ty_only_fixup(fcx, id, mt.ty);\n+          }\n           ty::ty_str {\n+            require_integral(fcx, idx.span, idx_t);\n             let typ = ty::mk_mach_uint(tcx, ast::ty_u8);\n             write::ty_only_fixup(fcx, id, typ);\n           }\n           _ {\n-            tcx.sess.span_fatal(expr.span,\n-                                \"vector-indexing bad type: \" +\n-                                    ty_to_str(tcx, base_t));\n+            let resolved = structurally_resolved_type(fcx, expr.span,\n+                                                      raw_base_t);\n+            alt lookup_op_method(fcx, expr, resolved, \"op_index\",\n+                                 [some(idx)]) {\n+              some(ret_ty) { write::ty_only_fixup(fcx, id, ret_ty); }\n+              _ {\n+                tcx.sess.span_fatal(\n+                    expr.span, \"cannot index a value of type `\" +\n+                    ty_to_str(tcx, base_t) + \"`\");\n+              }\n+            }\n           }\n         }\n       }\n@@ -2922,7 +2934,8 @@ mod dict {\n           }\n           // Must resolve bounds on methods with bounded params\n           ast::expr_field(_, _, _) | ast::expr_binary(_, _, _) |\n-          ast::expr_unary(_, _) | ast::expr_assign_op(_, _, _) {\n+          ast::expr_unary(_, _) | ast::expr_assign_op(_, _, _) |\n+          ast::expr_index(_, _) {\n             alt cx.method_map.find(ex.id) {\n               some(method_static(did)) {\n                 let bounds = ty::lookup_item_type(cx.tcx, did).bounds;"}, {"sha": "3d6b76db628c2aa530eb0d47e8144eef636ded3e", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/888262b337d90a275074a2ad2ac119984b55205a/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888262b337d90a275074a2ad2ac119984b55205a/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=888262b337d90a275074a2ad2ac119984b55205a", "patch": "@@ -1008,6 +1008,7 @@ fn parse_dot_or_call_expr_with(p: parser, e0: pexpr) -> pexpr {\n             let ix = parse_expr(p);\n             hi = ix.span.hi;\n             expect(p, token::RBRACKET);\n+            p.get_id(); // see ast_util::op_expr_callee_id\n             e = mk_pexpr(p, lo, hi, ast::expr_index(to_expr(e), ix));\n           }\n "}, {"sha": "27ed51852a4d06614f3801d185e4991f5829c909", "filename": "src/test/compile-fail/minus-string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/888262b337d90a275074a2ad2ac119984b55205a/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888262b337d90a275074a2ad2ac119984b55205a/src%2Ftest%2Fcompile-fail%2Fminus-string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fminus-string.rs?ref=888262b337d90a275074a2ad2ac119984b55205a", "patch": "@@ -1,3 +1,3 @@\n-// error-pattern:can not apply unary operator `-` to type `str`\n+// error-pattern:cannot apply unary operator `-` to type `str`\n \n fn main() { -\"foo\"; }"}, {"sha": "55761548f14742f5dbc79b15c97ccfdd8cd128a8", "filename": "src/test/run-pass/operator-overloading.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/888262b337d90a275074a2ad2ac119984b55205a/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888262b337d90a275074a2ad2ac119984b55205a/src%2Ftest%2Frun-pass%2Foperator-overloading.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Foperator-overloading.rs?ref=888262b337d90a275074a2ad2ac119984b55205a", "patch": "@@ -7,11 +7,16 @@ impl add_point for point {\n     fn op_neg() -> point {\n         {x: -self.x, y: -self.y}\n     }\n+    fn op_index(x: bool) -> int {\n+        x ? self.x : self.y\n+    }\n }\n \n fn main() {\n     let p = {x: 10, y: 20};\n     p += {x: 1, y: 2};\n     assert p + {x: 5, y: 5} == {x: 16, y: 27};\n     assert -p == {x: -11, y: -22};\n+    assert p[true] == 11;\n+    assert p[false] == 22;\n }"}]}