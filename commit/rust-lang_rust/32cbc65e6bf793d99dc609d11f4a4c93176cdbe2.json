{"sha": "32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyY2JjNjVlNmJmNzkzZDk5ZGM2MDlkMTFmNGE0YzkzMTc2Y2RiZTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T06:48:17Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-04T06:48:17Z"}, "message": "Auto merge of #77380 - fusion-engineering-forks:unbox-the-mutex, r=dtolnay\n\nUnbox mutexes and condvars on some platforms\n\nBoth mutexes and condition variables contained a Box containing the actual os-specific object. This was done because moving these objects may cause undefined behaviour on some platforms.\n\nHowever, this is not needed on Windows[1], Wasm[2], cloudabi[2], and 'unsupported'[3], were the box was only needlessly making them less efficient.\n\nThis change gets rid of the box on those platforms.\n\nOn those platforms, `Condvar` can no longer verify it is only used with one `Mutex`, as mutexes no longer have a stable address. This was addressed and considered acceptable in #76932.\n\n[1]\\: https://docs.microsoft.com/en-us/windows/win32/api/synchapi/nf-synchapi-initializesrwlock\n[2]\\: These are just a single atomic integer together with futex wait/wake calls/instructions.\n[3]\\: The `unsupported` platform doesn't support multiple threads at all.", "tree": {"sha": "63c17253897262e610c61eb3c67144edf0da4186", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63c17253897262e610c61eb3c67144edf0da4186"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "html_url": "https://github.com/rust-lang/rust/commit/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2251766944f355a039e67aeb13ab630b2d46bf9b", "url": "https://api.github.com/repos/rust-lang/rust/commits/2251766944f355a039e67aeb13ab630b2d46bf9b", "html_url": "https://github.com/rust-lang/rust/commit/2251766944f355a039e67aeb13ab630b2d46bf9b"}, {"sha": "b1ce7a38a6c03ddff23ef7e59e74cab6452ed9b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1ce7a38a6c03ddff23ef7e59e74cab6452ed9b0", "html_url": "https://github.com/rust-lang/rust/commit/b1ce7a38a6c03ddff23ef7e59e74cab6452ed9b0"}], "stats": {"total": 204, "additions": 121, "deletions": 83}, "files": [{"sha": "ffc1e57f4e03fa539309e54d93e85a28e418d0e0", "filename": "library/std/src/sync/condvar.rs", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -2,10 +2,8 @@\n mod tests;\n \n use crate::fmt;\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n use crate::sync::{mutex, MutexGuard, PoisonError};\n use crate::sys_common::condvar as sys;\n-use crate::sys_common::mutex as sys_mutex;\n use crate::sys_common::poison::{self, LockResult};\n use crate::time::{Duration, Instant};\n \n@@ -109,8 +107,7 @@ impl WaitTimeoutResult {\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Condvar {\n-    inner: Box<sys::Condvar>,\n-    mutex: AtomicUsize,\n+    inner: sys::Condvar,\n }\n \n impl Condvar {\n@@ -126,11 +123,7 @@ impl Condvar {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Condvar {\n-        let mut c = Condvar { inner: box sys::Condvar::new(), mutex: AtomicUsize::new(0) };\n-        unsafe {\n-            c.inner.init();\n-        }\n-        c\n+        Condvar { inner: sys::Condvar::new() }\n     }\n \n     /// Blocks the current thread until this condition variable receives a\n@@ -192,7 +185,6 @@ impl Condvar {\n     pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>) -> LockResult<MutexGuard<'a, T>> {\n         let poisoned = unsafe {\n             let lock = mutex::guard_lock(&guard);\n-            self.verify(lock);\n             self.inner.wait(lock);\n             mutex::guard_poison(&guard).get()\n         };\n@@ -389,7 +381,6 @@ impl Condvar {\n     ) -> LockResult<(MutexGuard<'a, T>, WaitTimeoutResult)> {\n         let (poisoned, result) = unsafe {\n             let lock = mutex::guard_lock(&guard);\n-            self.verify(lock);\n             let success = self.inner.wait_timeout(lock, dur);\n             (mutex::guard_poison(&guard).get(), WaitTimeoutResult(!success))\n         };\n@@ -510,7 +501,7 @@ impl Condvar {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn notify_one(&self) {\n-        unsafe { self.inner.notify_one() }\n+        self.inner.notify_one()\n     }\n \n     /// Wakes up all blocked threads on this condvar.\n@@ -550,27 +541,7 @@ impl Condvar {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn notify_all(&self) {\n-        unsafe { self.inner.notify_all() }\n-    }\n-\n-    fn verify(&self, mutex: &sys_mutex::MovableMutex) {\n-        let addr = mutex.raw() as *const _ as usize;\n-        match self.mutex.compare_and_swap(0, addr, Ordering::SeqCst) {\n-            // If we got out 0, then we have successfully bound the mutex to\n-            // this cvar.\n-            0 => {}\n-\n-            // If we get out a value that's the same as `addr`, then someone\n-            // already beat us to the punch.\n-            n if n == addr => {}\n-\n-            // Anything else and we're using more than one mutex on this cvar,\n-            // which is currently disallowed.\n-            _ => panic!(\n-                \"attempted to use a condition variable with two \\\n-                         mutexes\"\n-            ),\n-        }\n+        self.inner.notify_all()\n     }\n }\n \n@@ -588,10 +559,3 @@ impl Default for Condvar {\n         Condvar::new()\n     }\n }\n-\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl Drop for Condvar {\n-    fn drop(&mut self) {\n-        unsafe { self.inner.destroy() }\n-    }\n-}"}, {"sha": "6757707cd9513e3d842850827df9d5e6d23293fd", "filename": "library/std/src/sync/condvar/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsync%2Fcondvar%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsync%2Fcondvar%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fcondvar%2Ftests.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -191,7 +191,7 @@ fn wait_timeout_wake() {\n \n #[test]\n #[should_panic]\n-#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg_attr(not(unix), ignore)]\n fn two_mutexes() {\n     let m = Arc::new(Mutex::new(()));\n     let m2 = m.clone();"}, {"sha": "82d89b260fafd61210546bcffa10ee9acbc44c28", "filename": "library/std/src/sys/cloudabi/condvar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fcondvar.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -15,6 +15,8 @@ pub struct Condvar {\n     condvar: UnsafeCell<AtomicU32>,\n }\n \n+pub type MovableCondvar = Condvar;\n+\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n "}, {"sha": "66839e05bf076b2bc0a99b927db79c9adaabc792", "filename": "library/std/src/sys/cloudabi/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fcloudabi%2Fmutex.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -15,6 +15,8 @@ extern \"C\" {\n // implemented identically.\n pub struct Mutex(RWLock);\n \n+pub type MovableMutex = Mutex;\n+\n pub unsafe fn raw(m: &Mutex) -> *mut AtomicU32 {\n     rwlock::raw(&m.0)\n }"}, {"sha": "b45e8718f088e211a6ebef0f9473054cb70a3470", "filename": "library/std/src/sys/hermit/condvar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fcondvar.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -14,6 +14,8 @@ pub struct Condvar {\n     sem2: *const c_void,\n }\n \n+pub type MovableCondvar = Box<Condvar>;\n+\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n "}, {"sha": "dfe22e6a1b37591e7ab8d6876ff9186074bb2097", "filename": "library/std/src/sys/sgx/condvar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fcondvar.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -7,6 +7,8 @@ pub struct Condvar {\n     inner: SpinMutex<WaitVariable<()>>,\n }\n \n+pub type MovableCondvar = Box<Condvar>;\n+\n impl Condvar {\n     pub const fn new() -> Condvar {\n         Condvar { inner: SpinMutex::new(WaitVariable::new(())) }"}, {"sha": "8874517dac60cf542b10e0ee8f7f8071c755beeb", "filename": "library/std/src/sys/sgx/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Fmutex.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -8,6 +8,8 @@ pub struct Mutex {\n     inner: SpinMutex<WaitVariable<bool>>,\n }\n \n+pub type MovableMutex = Box<Mutex>;\n+\n // Implementation according to \u201cOperating Systems: Three Easy Pieces\u201d, chapter 28\n impl Mutex {\n     pub const fn new() -> Mutex {"}, {"sha": "e38f91af9f0b9ba6d17543c1a216002092f3e6a6", "filename": "library/std/src/sys/unix/condvar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fcondvar.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -6,6 +6,8 @@ pub struct Condvar {\n     inner: UnsafeCell<libc::pthread_cond_t>,\n }\n \n+pub type MovableCondvar = Box<Condvar>;\n+\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n "}, {"sha": "ebc737b75ae0b701f10bf0df168571dc1499f102", "filename": "library/std/src/sys/unix/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmutex.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -5,6 +5,8 @@ pub struct Mutex {\n     inner: UnsafeCell<libc::pthread_mutex_t>,\n }\n \n+pub type MovableMutex = Box<Mutex>;\n+\n #[inline]\n pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n     m.inner.get()"}, {"sha": "35d12a69c8aa5ab870c0f93059bded91efdbc5f8", "filename": "library/std/src/sys/unsupported/condvar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fcondvar.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -3,6 +3,8 @@ use crate::time::Duration;\n \n pub struct Condvar {}\n \n+pub type MovableCondvar = Condvar;\n+\n impl Condvar {\n     pub const fn new() -> Condvar {\n         Condvar {}"}, {"sha": "06ea9a1e2c109640c5f21ebfb6e697ba5f5a8192", "filename": "library/std/src/sys/unsupported/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Fmutex.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -4,6 +4,8 @@ pub struct Mutex {\n     locked: UnsafeCell<bool>,\n }\n \n+pub type MovableMutex = Mutex;\n+\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {} // no threads on this platform\n "}, {"sha": "b4724be7c7c3b38b31e65fba624978384e98e0d5", "filename": "library/std/src/sys/vxworks/condvar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fcondvar.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -6,6 +6,8 @@ pub struct Condvar {\n     inner: UnsafeCell<libc::pthread_cond_t>,\n }\n \n+pub type MovableCondvar = Box<Condvar>;\n+\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n "}, {"sha": "dd7582c21a72725ae20e6b7c42f8ffbac3ca3377", "filename": "library/std/src/sys/vxworks/mutex.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fvxworks%2Fmutex.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -5,6 +5,8 @@ pub struct Mutex {\n     inner: UnsafeCell<libc::pthread_mutex_t>,\n }\n \n+pub type MovableMutex = Box<Mutex>;\n+\n #[inline]\n pub unsafe fn raw(m: &Mutex) -> *mut libc::pthread_mutex_t {\n     m.inner.get()"}, {"sha": "a96bb18e6ef1a8146bbc6c065258e2d7d90aefc0", "filename": "library/std/src/sys/wasm/condvar_atomics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fcondvar_atomics.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -9,6 +9,8 @@ pub struct Condvar {\n     cnt: AtomicUsize,\n }\n \n+pub type MovableCondvar = Condvar;\n+\n // Condition variables are implemented with a simple counter internally that is\n // likely to cause spurious wakeups. Blocking on a condition variable will first\n // read the value of the internal counter, unlock the given mutex, and then"}, {"sha": "2970fcf806cbfc5fc840ff0d9b4f4a77dc33d15f", "filename": "library/std/src/sys/wasm/mutex_atomics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasm%2Fmutex_atomics.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -8,6 +8,8 @@ pub struct Mutex {\n     locked: AtomicUsize,\n }\n \n+pub type MovableMutex = Mutex;\n+\n // Mutexes have a pretty simple implementation where they contain an `i32`\n // internally that is 0 when unlocked and 1 when the mutex is locked.\n // Acquisition has a fast path where it attempts to cmpxchg the 0 to a 1, and"}, {"sha": "44547a5c51a34f2b02cba6e0decd1a3bdb31e852", "filename": "library/std/src/sys/windows/condvar.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcondvar.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -8,6 +8,8 @@ pub struct Condvar {\n     inner: UnsafeCell<c::CONDITION_VARIABLE>,\n }\n \n+pub type MovableCondvar = Condvar;\n+\n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n "}, {"sha": "fa51b006c346fe10297c8165b593da4a7c5c86c8", "filename": "library/std/src/sys/windows/mutex.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmutex.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -29,6 +29,11 @@ pub struct Mutex {\n     lock: AtomicUsize,\n }\n \n+// Windows SRW Locks are movable (while not borrowed).\n+// ReentrantMutexes (in Inner) are not, but those are stored indirectly through\n+// a Box, so do not move when the Mutex it self is moved.\n+pub type MovableMutex = Mutex;\n+\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n "}, {"sha": "2c02e1cd33c8165209c5b08333bdb0898882bc22", "filename": "library/std/src/sys_common/condvar.rs", "status": "modified", "additions": 29, "deletions": 37, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -1,72 +1,64 @@\n use crate::sys::condvar as imp;\n+use crate::sys::mutex as mutex_imp;\n use crate::sys_common::mutex::MovableMutex;\n use crate::time::Duration;\n \n+mod check;\n+\n+type CondvarCheck = <mutex_imp::MovableMutex as check::CondvarCheck>::Check;\n+\n /// An OS-based condition variable.\n-///\n-/// This structure is the lowest layer possible on top of the OS-provided\n-/// condition variables. It is consequently entirely unsafe to use. It is\n-/// recommended to use the safer types at the top level of this crate instead of\n-/// this type.\n-pub struct Condvar(imp::Condvar);\n+pub struct Condvar {\n+    inner: imp::MovableCondvar,\n+    check: CondvarCheck,\n+}\n \n impl Condvar {\n     /// Creates a new condition variable for use.\n-    ///\n-    /// Behavior is undefined if the condition variable is moved after it is\n-    /// first used with any of the functions below.\n-    pub const fn new() -> Condvar {\n-        Condvar(imp::Condvar::new())\n-    }\n-\n-    /// Prepares the condition variable for use.\n-    ///\n-    /// This should be called once the condition variable is at a stable memory\n-    /// address.\n-    #[inline]\n-    pub unsafe fn init(&mut self) {\n-        self.0.init()\n+    pub fn new() -> Self {\n+        let mut c = imp::MovableCondvar::from(imp::Condvar::new());\n+        unsafe { c.init() };\n+        Self { inner: c, check: CondvarCheck::new() }\n     }\n \n     /// Signals one waiter on this condition variable to wake up.\n     #[inline]\n-    pub unsafe fn notify_one(&self) {\n-        self.0.notify_one()\n+    pub fn notify_one(&self) {\n+        unsafe { self.inner.notify_one() };\n     }\n \n     /// Awakens all current waiters on this condition variable.\n     #[inline]\n-    pub unsafe fn notify_all(&self) {\n-        self.0.notify_all()\n+    pub fn notify_all(&self) {\n+        unsafe { self.inner.notify_all() };\n     }\n \n     /// Waits for a signal on the specified mutex.\n     ///\n     /// Behavior is undefined if the mutex is not locked by the current thread.\n-    /// Behavior is also undefined if more than one mutex is used concurrently\n-    /// on this condition variable.\n+    ///\n+    /// May panic if used with more than one mutex.\n     #[inline]\n     pub unsafe fn wait(&self, mutex: &MovableMutex) {\n-        self.0.wait(mutex.raw())\n+        self.check.verify(mutex);\n+        self.inner.wait(mutex.raw())\n     }\n \n     /// Waits for a signal on the specified mutex with a timeout duration\n     /// specified by `dur` (a relative time into the future).\n     ///\n     /// Behavior is undefined if the mutex is not locked by the current thread.\n-    /// Behavior is also undefined if more than one mutex is used concurrently\n-    /// on this condition variable.\n+    ///\n+    /// May panic if used with more than one mutex.\n     #[inline]\n     pub unsafe fn wait_timeout(&self, mutex: &MovableMutex, dur: Duration) -> bool {\n-        self.0.wait_timeout(mutex.raw(), dur)\n+        self.check.verify(mutex);\n+        self.inner.wait_timeout(mutex.raw(), dur)\n     }\n+}\n \n-    /// Deallocates all resources associated with this condition variable.\n-    ///\n-    /// Behavior is undefined if there are current or will be future users of\n-    /// this condition variable.\n-    #[inline]\n-    pub unsafe fn destroy(&self) {\n-        self.0.destroy()\n+impl Drop for Condvar {\n+    fn drop(&mut self) {\n+        unsafe { self.inner.destroy() };\n     }\n }"}, {"sha": "fecb732b910cedf3d84bc3da98c1a75a409e122a", "filename": "library/std/src/sys_common/condvar/check.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -0,0 +1,48 @@\n+use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::sys::mutex as mutex_imp;\n+use crate::sys_common::mutex::MovableMutex;\n+\n+pub trait CondvarCheck {\n+    type Check;\n+}\n+\n+/// For boxed mutexes, a `Condvar` will check it's only ever used with the same\n+/// mutex, based on its (stable) address.\n+impl CondvarCheck for Box<mutex_imp::Mutex> {\n+    type Check = SameMutexCheck;\n+}\n+\n+pub struct SameMutexCheck {\n+    addr: AtomicUsize,\n+}\n+\n+#[allow(dead_code)]\n+impl SameMutexCheck {\n+    pub const fn new() -> Self {\n+        Self { addr: AtomicUsize::new(0) }\n+    }\n+    pub fn verify(&self, mutex: &MovableMutex) {\n+        let addr = mutex.raw() as *const mutex_imp::Mutex as usize;\n+        match self.addr.compare_and_swap(0, addr, Ordering::SeqCst) {\n+            0 => {}              // Stored the address\n+            n if n == addr => {} // Lost a race to store the same address\n+            _ => panic!(\"attempted to use a condition variable with two mutexes\"),\n+        }\n+    }\n+}\n+\n+/// Unboxed mutexes may move, so `Condvar` can not require its address to stay\n+/// constant.\n+impl CondvarCheck for mutex_imp::Mutex {\n+    type Check = NoCheck;\n+}\n+\n+pub struct NoCheck;\n+\n+#[allow(dead_code)]\n+impl NoCheck {\n+    pub const fn new() -> Self {\n+        Self\n+    }\n+    pub fn verify(&self, _: &MovableMutex) {}\n+}"}, {"sha": "a1e11d24465ea4f94bbb9b2ac771b58ed3576510", "filename": "library/std/src/sys_common/mutex.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cbc65e6bf793d99dc609d11f4a4c93176cdbe2/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fmutex.rs?ref=32cbc65e6bf793d99dc609d11f4a4c93176cdbe2", "patch": "@@ -58,21 +58,22 @@ impl Drop for StaticMutexGuard<'_> {\n ///\n /// This mutex does not implement poisoning.\n ///\n-/// This is a wrapper around `Box<imp::Mutex>`, to allow the object to be moved\n-/// without moving the raw mutex.\n-pub struct MovableMutex(Box<imp::Mutex>);\n+/// This is either a wrapper around `Box<imp::Mutex>` or `imp::Mutex`,\n+/// depending on the platform. It is boxed on platforms where `imp::Mutex` may\n+/// not be moved.\n+pub struct MovableMutex(imp::MovableMutex);\n \n unsafe impl Sync for MovableMutex {}\n \n impl MovableMutex {\n     /// Creates a new mutex.\n     pub fn new() -> Self {\n-        let mut mutex = box imp::Mutex::new();\n+        let mut mutex = imp::MovableMutex::from(imp::Mutex::new());\n         unsafe { mutex.init() };\n         Self(mutex)\n     }\n \n-    pub(crate) fn raw(&self) -> &imp::Mutex {\n+    pub(super) fn raw(&self) -> &imp::Mutex {\n         &self.0\n     }\n "}]}