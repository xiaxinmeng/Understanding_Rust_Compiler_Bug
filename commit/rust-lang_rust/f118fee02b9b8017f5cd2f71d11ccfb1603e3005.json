{"sha": "f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxMThmZWUwMmI5YjgwMTdmNWNkMmY3MWQxMWNjZmIxNjAzZTMwMDU=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-17T02:05:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-17T02:05:20Z"}, "message": "Rollup merge of #70049 - oli-obk:param_env_empty_considered_unimplemented, r=eddyb\n\nFiddle `ParamEnv` through to a place that used to use `ParamEnv::empty` in a buggy manner\n\ncc https://github.com/rust-lang/rust/pull/69981#discussion_r393048924\n\nr? @eddyb", "tree": {"sha": "47150bc86e4d3d8da7a508a1875f500bd41b42b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/47150bc86e4d3d8da7a508a1875f500bd41b42b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJecDBhCRBK7hj4Ov3rIwAAdHIIAEUcDEk0O1syuYJdcIL6vrOf\nMIWe4IHPmJfhZrPwMFTxA1SQ5CblynZQSzGHpOb6jx7NrWh6ekVVMukvUpmmOVZm\nfC1K5u63Irp/zy6YuJlz23YtVgDKjutQuFaPWOxs7ElE1om4AcdPCm20u5tbT7Iz\niXtiSdpPDApVMJAoW3ycL1uyCXCbDEfxO/9YHnTUFjMzQjvHnqDxozXu76ZBKBMe\ngN02aZluRScS4T1ukEUyVVHq6H3sLhtW3AFsNfein6P6Sz8oQ95MywEeBi4P4S2Y\nLLs5bxQT1YmBnKWn+B85ZUMUVGSv03kqwAOUjq7zlF0cCXgMy/nFzqAsFEUrOOU=\n=SJdi\n-----END PGP SIGNATURE-----\n", "payload": "tree 47150bc86e4d3d8da7a508a1875f500bd41b42b4\nparent 4d7ec704ccb7873059522d02b82204d9f775ce32\nparent 7894509b000157185b10cfae64ac1e88acd88f4a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1584410720 +0100\ncommitter GitHub <noreply@github.com> 1584410720 +0100\n\nRollup merge of #70049 - oli-obk:param_env_empty_considered_unimplemented, r=eddyb\n\nFiddle `ParamEnv` through to a place that used to use `ParamEnv::empty` in a buggy manner\n\ncc https://github.com/rust-lang/rust/pull/69981#discussion_r393048924\n\nr? @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "html_url": "https://github.com/rust-lang/rust/commit/f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d7ec704ccb7873059522d02b82204d9f775ce32", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d7ec704ccb7873059522d02b82204d9f775ce32", "html_url": "https://github.com/rust-lang/rust/commit/4d7ec704ccb7873059522d02b82204d9f775ce32"}, {"sha": "7894509b000157185b10cfae64ac1e88acd88f4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/7894509b000157185b10cfae64ac1e88acd88f4a", "html_url": "https://github.com/rust-lang/rust/commit/7894509b000157185b10cfae64ac1e88acd88f4a"}], "stats": {"total": 88, "additions": 64, "deletions": 24}, "files": [{"sha": "b166c4dea0c850f1e50259a2044cbdc3fed74c95", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "patch": "@@ -90,30 +90,46 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// ```\n     /// This code should only compile in modules where the uninhabitedness of Foo is\n     /// visible.\n-    pub fn is_ty_uninhabited_from(self, module: DefId, ty: Ty<'tcx>) -> bool {\n+    pub fn is_ty_uninhabited_from(\n+        self,\n+        module: DefId,\n+        ty: Ty<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> bool {\n         // To check whether this type is uninhabited at all (not just from the\n         // given node), you could check whether the forest is empty.\n         // ```\n         // forest.is_empty()\n         // ```\n-        ty.uninhabited_from(self).contains(self, module)\n+        ty.uninhabited_from(self, param_env).contains(self, module)\n     }\n \n-    pub fn is_ty_uninhabited_from_any_module(self, ty: Ty<'tcx>) -> bool {\n-        !ty.uninhabited_from(self).is_empty()\n+    pub fn is_ty_uninhabited_from_any_module(\n+        self,\n+        ty: Ty<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> bool {\n+        !ty.uninhabited_from(self, param_env).is_empty()\n     }\n }\n \n impl<'tcx> AdtDef {\n     /// Calculates the forest of `DefId`s from which this ADT is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, substs: SubstsRef<'tcx>) -> DefIdForest {\n+    fn uninhabited_from(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> DefIdForest {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n         if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n             DefIdForest::empty()\n         } else {\n             DefIdForest::intersection(\n                 tcx,\n-                self.variants.iter().map(|v| v.uninhabited_from(tcx, substs, self.adt_kind())),\n+                self.variants\n+                    .iter()\n+                    .map(|v| v.uninhabited_from(tcx, substs, self.adt_kind(), param_env)),\n             )\n         }\n     }\n@@ -126,6 +142,7 @@ impl<'tcx> VariantDef {\n         tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n         adt_kind: AdtKind,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> DefIdForest {\n         let is_enum = match adt_kind {\n             // For now, `union`s are never considered uninhabited.\n@@ -140,7 +157,7 @@ impl<'tcx> VariantDef {\n         } else {\n             DefIdForest::union(\n                 tcx,\n-                self.fields.iter().map(|f| f.uninhabited_from(tcx, substs, is_enum)),\n+                self.fields.iter().map(|f| f.uninhabited_from(tcx, substs, is_enum, param_env)),\n             )\n         }\n     }\n@@ -153,8 +170,9 @@ impl<'tcx> FieldDef {\n         tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n         is_enum: bool,\n+        param_env: ty::ParamEnv<'tcx>,\n     ) -> DefIdForest {\n-        let data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(tcx);\n+        let data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(tcx, param_env);\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n         // `Visibility::Invisible` so we need to override `self.vis` if we're\n         // dealing with an enum.\n@@ -176,20 +194,21 @@ impl<'tcx> FieldDef {\n \n impl<'tcx> TyS<'tcx> {\n     /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n-    fn uninhabited_from(&self, tcx: TyCtxt<'tcx>) -> DefIdForest {\n+    fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, param_env: ty::ParamEnv<'tcx>) -> DefIdForest {\n         match self.kind {\n-            Adt(def, substs) => def.uninhabited_from(tcx, substs),\n+            Adt(def, substs) => def.uninhabited_from(tcx, substs, param_env),\n \n             Never => DefIdForest::full(tcx),\n \n-            Tuple(ref tys) => {\n-                DefIdForest::union(tcx, tys.iter().map(|ty| ty.expect_ty().uninhabited_from(tcx)))\n-            }\n+            Tuple(ref tys) => DefIdForest::union(\n+                tcx,\n+                tys.iter().map(|ty| ty.expect_ty().uninhabited_from(tcx, param_env)),\n+            ),\n \n-            Array(ty, len) => match len.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n+            Array(ty, len) => match len.try_eval_usize(tcx, param_env) {\n                 // If the array is definitely non-empty, it's uninhabited if\n                 // the type of its elements is uninhabited.\n-                Some(n) if n != 0 => ty.uninhabited_from(tcx),\n+                Some(n) if n != 0 => ty.uninhabited_from(tcx, param_env),\n                 _ => DefIdForest::empty(),\n             },\n "}, {"sha": "2ac461a0eb264dc6cf323346fd10ceafb5efd56a", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "patch": "@@ -124,7 +124,12 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n             descr_post: &str,\n             plural_len: usize,\n         ) -> bool {\n-            if ty.is_unit() || cx.tcx.is_ty_uninhabited_from(cx.tcx.parent_module(expr.hir_id), ty)\n+            if ty.is_unit()\n+                || cx.tcx.is_ty_uninhabited_from(\n+                    cx.tcx.parent_module(expr.hir_id),\n+                    ty,\n+                    cx.param_env,\n+                )\n             {\n                 return true;\n             }"}, {"sha": "aea4f5f1b3ac90d099332e0a9b4944cbf352d7db", "filename": "src/librustc_mir_build/build/matches/simplify.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmatches%2Fsimplify.rs?ref=f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "patch": "@@ -209,7 +209,12 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     i == variant_index || {\n                         self.hir.tcx().features().exhaustive_patterns\n                             && !v\n-                                .uninhabited_from(self.hir.tcx(), substs, adt_def.adt_kind())\n+                                .uninhabited_from(\n+                                    self.hir.tcx(),\n+                                    substs,\n+                                    adt_def.adt_kind(),\n+                                    self.hir.param_env,\n+                                )\n                                 .is_empty()\n                     }\n                 }) && (adt_def.did.is_local()"}, {"sha": "486dd3579d293d8f3807973874b4d94c076385c5", "filename": "src/librustc_mir_build/hair/pattern/_match.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fhair%2Fpattern%2F_match.rs?ref=f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "patch": "@@ -598,7 +598,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n \n     fn is_uninhabited(&self, ty: Ty<'tcx>) -> bool {\n         if self.tcx.features().exhaustive_patterns {\n-            self.tcx.is_ty_uninhabited_from(self.module, ty)\n+            self.tcx.is_ty_uninhabited_from(self.module, ty, self.param_env)\n         } else {\n             false\n         }\n@@ -1267,7 +1267,7 @@ fn all_constructors<'a, 'tcx>(\n                 def.variants\n                     .iter()\n                     .filter(|v| {\n-                        !v.uninhabited_from(cx.tcx, substs, def.adt_kind())\n+                        !v.uninhabited_from(cx.tcx, substs, def.adt_kind(), cx.param_env)\n                             .contains(cx.tcx, cx.module)\n                     })\n                     .map(|v| Variant(v.def_id))"}, {"sha": "d7208a00e0938e31cfbc883615f28984e0746b1f", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f118fee02b9b8017f5cd2f71d11ccfb1603e3005/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=f118fee02b9b8017f5cd2f71d11ccfb1603e3005", "patch": "@@ -398,7 +398,7 @@ fn visit_fn<'tcx>(\n     intravisit::walk_fn(&mut fn_maps, fk, decl, body_id, sp, id);\n \n     // compute liveness\n-    let mut lsets = Liveness::new(&mut fn_maps, body_id);\n+    let mut lsets = Liveness::new(&mut fn_maps, def_id);\n     let entry_ln = lsets.compute(&body.value);\n \n     // check for various error conditions\n@@ -658,6 +658,7 @@ const ACC_USE: u32 = 4;\n struct Liveness<'a, 'tcx> {\n     ir: &'a mut IrMaps<'tcx>,\n     tables: &'a ty::TypeckTables<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n     s: Specials,\n     successors: Vec<LiveNode>,\n     rwu_table: RWUTable,\n@@ -670,7 +671,7 @@ struct Liveness<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> Liveness<'a, 'tcx> {\n-    fn new(ir: &'a mut IrMaps<'tcx>, body: hir::BodyId) -> Liveness<'a, 'tcx> {\n+    fn new(ir: &'a mut IrMaps<'tcx>, def_id: DefId) -> Liveness<'a, 'tcx> {\n         // Special nodes and variables:\n         // - exit_ln represents the end of the fn, either by return or panic\n         // - implicit_ret_var is a pseudo-variable that represents\n@@ -681,14 +682,16 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             clean_exit_var: ir.add_variable(CleanExit),\n         };\n \n-        let tables = ir.tcx.body_tables(body);\n+        let tables = ir.tcx.typeck_tables_of(def_id);\n+        let param_env = ir.tcx.param_env(def_id);\n \n         let num_live_nodes = ir.num_live_nodes;\n         let num_vars = ir.num_vars;\n \n         Liveness {\n             ir,\n             tables,\n+            param_env,\n             s: specials,\n             successors: vec![invalid_node(); num_live_nodes],\n             rwu_table: RWUTable::new(num_live_nodes * num_vars),\n@@ -1126,7 +1129,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::Call(ref f, ref args) => {\n                 let m = self.ir.tcx.parent_module(expr.hir_id);\n-                let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n+                let succ = if self.ir.tcx.is_ty_uninhabited_from(\n+                    m,\n+                    self.tables.expr_ty(expr),\n+                    self.param_env,\n+                ) {\n                     self.s.exit_ln\n                 } else {\n                     succ\n@@ -1137,7 +1144,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n             hir::ExprKind::MethodCall(.., ref args) => {\n                 let m = self.ir.tcx.parent_module(expr.hir_id);\n-                let succ = if self.ir.tcx.is_ty_uninhabited_from(m, self.tables.expr_ty(expr)) {\n+                let succ = if self.ir.tcx.is_ty_uninhabited_from(\n+                    m,\n+                    self.tables.expr_ty(expr),\n+                    self.param_env,\n+                ) {\n                     self.s.exit_ln\n                 } else {\n                     succ"}]}