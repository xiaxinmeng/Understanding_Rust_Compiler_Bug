{"sha": "85956932872481cf4813c5e7794d981a9edb4623", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1OTU2OTMyODcyNDgxY2Y0ODEzYzVlNzc5NGQ5ODFhOWVkYjQ2MjM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-04-09T09:24:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-09T09:24:19Z"}, "message": "Merge #3909\n\n3909: Generate tokense r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Luca Barbieri <luca@luca-barbieri.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "f915426894d00e918bfb2ad475633370baa6adaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f915426894d00e918bfb2ad475633370baa6adaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85956932872481cf4813c5e7794d981a9edb4623", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJejunDCRBK7hj4Ov3rIwAAdHIIAG5fMKKjL15VsRKoCyCNHAWN\nC5J4dzYHEcjpdBcSMBV4Ak/4UfigDRvfI4TisGKBP2gSFPVkbkB3bBjqIxcnCqIL\nG3cUzG8zy1fUlBRD/K2/bDkw1PV2czcrTxKkpqhG3JRDAAC0zjinG73p5yK+GWLh\n/R4x6Vb0QUn/dicIt6xc1uAo31GSLi4ZaJ9SZ7L43fgl/Z2ikSJAyqxQJxo7P2me\noOENjUykifNW4XfFp2jszB946PZrn6J8nQvcidUByajVPk7jp+Gb0rr2Q5v7TRX6\nvP1Pc8pP3oO0LrUbEZqZ21hw2NRCX65iXOcsCEdrSAyIIT5UogYum5CJsz4CsW0=\n=/7J+\n-----END PGP SIGNATURE-----\n", "payload": "tree f915426894d00e918bfb2ad475633370baa6adaa\nparent 412eda73877c7a897561a70b83f55ee346e18a2c\nparent 8f01e62bb962fbe282344125f6ace54326efcaa3\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1586424259 +0000\ncommitter GitHub <noreply@github.com> 1586424259 +0000\n\nMerge #3909\n\n3909: Generate tokense r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Luca Barbieri <luca@luca-barbieri.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85956932872481cf4813c5e7794d981a9edb4623", "html_url": "https://github.com/rust-lang/rust/commit/85956932872481cf4813c5e7794d981a9edb4623", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85956932872481cf4813c5e7794d981a9edb4623/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "412eda73877c7a897561a70b83f55ee346e18a2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/412eda73877c7a897561a70b83f55ee346e18a2c", "html_url": "https://github.com/rust-lang/rust/commit/412eda73877c7a897561a70b83f55ee346e18a2c"}, {"sha": "8f01e62bb962fbe282344125f6ace54326efcaa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f01e62bb962fbe282344125f6ace54326efcaa3", "html_url": "https://github.com/rust-lang/rust/commit/8f01e62bb962fbe282344125f6ace54326efcaa3"}], "stats": {"total": 3250, "additions": 3176, "deletions": 74}, "files": [{"sha": "ab0f44dd2e0fab4ee4762e12a8bfe76dfd4fdf23", "filename": "crates/ra_syntax/src/ast.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/85956932872481cf4813c5e7794d981a9edb4623/crates%2Fra_syntax%2Fsrc%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85956932872481cf4813c5e7794d981a9edb4623/crates%2Fra_syntax%2Fsrc%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast.rs?ref=85956932872481cf4813c5e7794d981a9edb4623", "patch": "@@ -30,7 +30,7 @@ pub use self::{\n /// conversion itself has zero runtime cost: ast and syntax nodes have exactly\n /// the same representation: a pointer to the tree root and a pointer to the\n /// node itself.\n-pub trait AstNode: std::fmt::Display {\n+pub trait AstNode {\n     fn can_cast(kind: SyntaxKind) -> bool\n     where\n         Self: Sized;\n@@ -49,10 +49,16 @@ fn assert_ast_is_object_safe() {\n \n /// Like `AstNode`, but wraps tokens rather than interior nodes.\n pub trait AstToken {\n-    fn cast(token: SyntaxToken) -> Option<Self>\n+    fn can_cast(token: SyntaxKind) -> bool\n     where\n         Self: Sized;\n+\n+    fn cast(syntax: SyntaxToken) -> Option<Self>\n+    where\n+        Self: Sized;\n+\n     fn syntax(&self) -> &SyntaxToken;\n+\n     fn text(&self) -> &SmolStr {\n         self.syntax().text()\n     }"}, {"sha": "385fddc89ee5694aff974707e7a2f6495082c634", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 3028, "deletions": 2, "changes": 3030, "blob_url": "https://github.com/rust-lang/rust/blob/85956932872481cf4813c5e7794d981a9edb4623/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85956932872481cf4813c5e7794d981a9edb4623/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=85956932872481cf4813c5e7794d981a9edb4623"}, {"sha": "e8320b57ed45376733334806a2ff42eba764937a", "filename": "crates/ra_syntax/src/ast/tokens.rs", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/85956932872481cf4813c5e7794d981a9edb4623/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85956932872481cf4813c5e7794d981a9edb4623/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Ftokens.rs?ref=85956932872481cf4813c5e7794d981a9edb4623", "patch": "@@ -1,26 +1,10 @@\n //! There are many AstNodes, but only a few tokens, so we hand-write them here.\n \n use crate::{\n-    ast::AstToken,\n-    SyntaxKind::{COMMENT, RAW_STRING, STRING, WHITESPACE},\n-    SyntaxToken, TextRange, TextUnit,\n+    ast::{AstToken, Comment, RawString, String, Whitespace},\n+    TextRange, TextUnit,\n };\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct Comment(SyntaxToken);\n-\n-impl AstToken for Comment {\n-    fn cast(token: SyntaxToken) -> Option<Self> {\n-        match token.kind() {\n-            COMMENT => Some(Comment(token)),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        &self.0\n-    }\n-}\n-\n impl Comment {\n     pub fn kind(&self) -> CommentKind {\n         kind_by_prefix(self.text())\n@@ -89,20 +73,6 @@ fn prefix_by_kind(kind: CommentKind) -> &'static str {\n     unreachable!()\n }\n \n-pub struct Whitespace(SyntaxToken);\n-\n-impl AstToken for Whitespace {\n-    fn cast(token: SyntaxToken) -> Option<Self> {\n-        match token.kind() {\n-            WHITESPACE => Some(Whitespace(token)),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        &self.0\n-    }\n-}\n-\n impl Whitespace {\n     pub fn spans_multiple_lines(&self) -> bool {\n         let text = self.text();\n@@ -168,20 +138,6 @@ pub trait HasStringValue: HasQuotes {\n     fn value(&self) -> Option<std::string::String>;\n }\n \n-pub struct String(SyntaxToken);\n-\n-impl AstToken for String {\n-    fn cast(token: SyntaxToken) -> Option<Self> {\n-        match token.kind() {\n-            STRING => Some(String(token)),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        &self.0\n-    }\n-}\n-\n impl HasStringValue for String {\n     fn value(&self) -> Option<std::string::String> {\n         let text = self.text().as_str();\n@@ -201,20 +157,6 @@ impl HasStringValue for String {\n     }\n }\n \n-pub struct RawString(SyntaxToken);\n-\n-impl AstToken for RawString {\n-    fn cast(token: SyntaxToken) -> Option<Self> {\n-        match token.kind() {\n-            RAW_STRING => Some(RawString(token)),\n-            _ => None,\n-        }\n-    }\n-    fn syntax(&self) -> &SyntaxToken {\n-        &self.0\n-    }\n-}\n-\n impl HasStringValue for RawString {\n     fn value(&self) -> Option<std::string::String> {\n         let text = self.text().as_str();"}, {"sha": "2dfb68371876ffe079590780dbe93e8ad4e95baa", "filename": "xtask/src/codegen/gen_syntax.rs", "status": "modified", "additions": 138, "deletions": 10, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/85956932872481cf4813c5e7794d981a9edb4623/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85956932872481cf4813c5e7794d981a9edb4623/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_syntax.rs?ref=85956932872481cf4813c5e7794d981a9edb4623", "patch": "@@ -5,6 +5,8 @@\n \n use proc_macro2::{Punct, Spacing};\n use quote::{format_ident, quote};\n+use std::borrow::Cow;\n+use std::collections::{BTreeSet, HashMap, HashSet};\n \n use crate::{\n     ast_src::{AstSrc, FieldSrc, KindsSrc, AST_SRC, KINDS_SRC},\n@@ -18,13 +20,108 @@ pub fn generate_syntax(mode: Mode) -> Result<()> {\n     update(syntax_kinds_file.as_path(), &syntax_kinds, mode)?;\n \n     let ast_file = project_root().join(codegen::AST);\n-    let ast = generate_ast(AST_SRC)?;\n+    let ast = generate_ast(KINDS_SRC, AST_SRC)?;\n     update(ast_file.as_path(), &ast, mode)?;\n \n     Ok(())\n }\n \n-fn generate_ast(grammar: AstSrc<'_>) -> Result<String> {\n+#[derive(Debug, Default, Clone)]\n+struct ElementKinds {\n+    kinds: BTreeSet<proc_macro2::Ident>,\n+    has_nodes: bool,\n+    has_tokens: bool,\n+}\n+\n+fn generate_ast(kinds: KindsSrc<'_>, grammar: AstSrc<'_>) -> Result<String> {\n+    let all_token_kinds: Vec<_> = kinds\n+        .punct\n+        .into_iter()\n+        .map(|(_, kind)| kind)\n+        .copied()\n+        .map(|x| x.into())\n+        .chain(\n+            kinds\n+                .keywords\n+                .into_iter()\n+                .chain(kinds.contextual_keywords.into_iter())\n+                .map(|name| Cow::Owned(format!(\"{}_KW\", to_upper_snake_case(&name)))),\n+        )\n+        .chain(kinds.literals.into_iter().copied().map(|x| x.into()))\n+        .chain(kinds.tokens.into_iter().copied().map(|x| x.into()))\n+        .collect();\n+\n+    let mut element_kinds_map = HashMap::new();\n+    for kind in &all_token_kinds {\n+        let kind = &**kind;\n+        let name = to_pascal_case(kind);\n+        element_kinds_map.insert(\n+            name,\n+            ElementKinds {\n+                kinds: Some(format_ident!(\"{}\", kind)).into_iter().collect(),\n+                has_nodes: false,\n+                has_tokens: true,\n+            },\n+        );\n+    }\n+\n+    for kind in kinds.nodes {\n+        let name = to_pascal_case(kind);\n+        element_kinds_map.insert(\n+            name,\n+            ElementKinds {\n+                kinds: Some(format_ident!(\"{}\", *kind)).into_iter().collect(),\n+                has_nodes: true,\n+                has_tokens: false,\n+            },\n+        );\n+    }\n+\n+    for en in grammar.enums {\n+        let mut element_kinds: ElementKinds = Default::default();\n+        for variant in en.variants {\n+            if let Some(variant_element_kinds) = element_kinds_map.get(*variant) {\n+                element_kinds.kinds.extend(variant_element_kinds.kinds.iter().cloned());\n+                element_kinds.has_tokens |= variant_element_kinds.has_tokens;\n+                element_kinds.has_nodes |= variant_element_kinds.has_nodes;\n+            } else {\n+                panic!(\"Enum variant has type that does not exist or was not declared before the enum: {}\", *variant);\n+            }\n+        }\n+        element_kinds_map.insert(en.name.to_string(), element_kinds);\n+    }\n+\n+    let tokens = all_token_kinds.iter().map(|kind_str| {\n+        let kind_str = &**kind_str;\n+        let kind = format_ident!(\"{}\", kind_str);\n+        let name = format_ident!(\"{}\", to_pascal_case(kind_str));\n+        quote! {\n+            #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+            pub struct #name {\n+                pub(crate) syntax: SyntaxToken,\n+            }\n+\n+            impl std::fmt::Display for #name {\n+                fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n+                    std::fmt::Display::fmt(&self.syntax, f)\n+                }\n+            }\n+\n+            impl AstToken for #name {\n+                fn can_cast(kind: SyntaxKind) -> bool {\n+                    match kind {\n+                        #kind => true,\n+                        _ => false,\n+                    }\n+                }\n+                fn cast(syntax: SyntaxToken) -> Option<Self> {\n+                    if Self::can_cast(syntax.kind()) { Some(Self { syntax }) } else { None }\n+                }\n+                fn syntax(&self) -> &SyntaxToken { &self.syntax }\n+            }\n+        }\n+    });\n+\n     let nodes = grammar.nodes.iter().map(|node| {\n         let name = format_ident!(\"{}\", node.name);\n         let kind = format_ident!(\"{}\", to_upper_snake_case(&name.to_string()));\n@@ -42,6 +139,7 @@ fn generate_ast(grammar: AstSrc<'_>) -> Result<String> {\n                 FieldSrc::Optional(ty) | FieldSrc::Many(ty) => ty,\n                 FieldSrc::Shorthand => name,\n             };\n+\n             let ty = format_ident!(\"{}\", ty);\n \n             match field {\n@@ -86,6 +184,7 @@ fn generate_ast(grammar: AstSrc<'_>) -> Result<String> {\n                 }\n                 fn syntax(&self) -> &SyntaxNode { &self.syntax }\n             }\n+\n             #(#traits)*\n \n             impl #name {\n@@ -154,12 +253,25 @@ fn generate_ast(grammar: AstSrc<'_>) -> Result<String> {\n         }\n     });\n \n+    let defined_nodes: HashSet<_> = grammar.nodes.iter().map(|node| node.name).collect();\n+\n+    for node in kinds\n+        .nodes\n+        .iter()\n+        .map(|kind| to_pascal_case(*kind))\n+        .filter(|name| !defined_nodes.contains(&**name))\n+    {\n+        eprintln!(\"Warning: node {} not defined in ast source\", node);\n+    }\n+\n     let ast = quote! {\n+        #[allow(unused_imports)]\n         use crate::{\n-            SyntaxNode, SyntaxKind::{self, *},\n-            ast::{self, AstNode, AstChildren},\n+            SyntaxNode, SyntaxToken, SyntaxElement, NodeOrToken, SyntaxKind::{self, *},\n+            ast::{self, AstNode, AstToken, AstChildren},\n         };\n \n+        #(#tokens)*\n         #(#nodes)*\n         #(#enums)*\n     };\n@@ -282,12 +394,12 @@ fn generate_syntax_kinds(grammar: KindsSrc<'_>) -> Result<String> {\n \n fn to_upper_snake_case(s: &str) -> String {\n     let mut buf = String::with_capacity(s.len());\n-    let mut prev_is_upper = None;\n+    let mut prev = false;\n     for c in s.chars() {\n-        if c.is_ascii_uppercase() && prev_is_upper == Some(false) {\n+        if c.is_ascii_uppercase() && prev {\n             buf.push('_')\n         }\n-        prev_is_upper = Some(c.is_ascii_uppercase());\n+        prev = true;\n \n         buf.push(c.to_ascii_uppercase());\n     }\n@@ -296,14 +408,30 @@ fn to_upper_snake_case(s: &str) -> String {\n \n fn to_lower_snake_case(s: &str) -> String {\n     let mut buf = String::with_capacity(s.len());\n-    let mut prev_is_upper = None;\n+    let mut prev = false;\n     for c in s.chars() {\n-        if c.is_ascii_uppercase() && prev_is_upper == Some(false) {\n+        if c.is_ascii_uppercase() && prev {\n             buf.push('_')\n         }\n-        prev_is_upper = Some(c.is_ascii_uppercase());\n+        prev = true;\n \n         buf.push(c.to_ascii_lowercase());\n     }\n     buf\n }\n+\n+fn to_pascal_case(s: &str) -> String {\n+    let mut buf = String::with_capacity(s.len());\n+    let mut prev_is_underscore = true;\n+    for c in s.chars() {\n+        if c == '_' {\n+            prev_is_underscore = true;\n+        } else if prev_is_underscore {\n+            buf.push(c.to_ascii_uppercase());\n+            prev_is_underscore = false;\n+        } else {\n+            buf.push(c.to_ascii_lowercase());\n+        }\n+    }\n+    buf\n+}"}]}