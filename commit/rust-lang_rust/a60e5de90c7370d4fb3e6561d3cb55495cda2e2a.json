{"sha": "a60e5de90c7370d4fb3e6561d3cb55495cda2e2a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MGU1ZGU5MGM3MzcwZDRmYjNlNjU2MWQzY2I1NTQ5NWNkYTJlMmE=", "commit": {"author": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-09-08T00:39:39Z"}, "committer": {"name": "Tim Nielens", "email": "tim.nielens@gmail.com", "date": "2020-09-08T00:41:38Z"}, "message": "needless-lifetime / nested elision sites / PR remarks", "tree": {"sha": "7a910835866972573dedb1d746db45f6ae8f9978", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a910835866972573dedb1d746db45f6ae8f9978"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a", "html_url": "https://github.com/rust-lang/rust/commit/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a/comments", "author": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tnielens", "id": 11885535, "node_id": "MDQ6VXNlcjExODg1NTM1", "avatar_url": "https://avatars.githubusercontent.com/u/11885535?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tnielens", "html_url": "https://github.com/tnielens", "followers_url": "https://api.github.com/users/tnielens/followers", "following_url": "https://api.github.com/users/tnielens/following{/other_user}", "gists_url": "https://api.github.com/users/tnielens/gists{/gist_id}", "starred_url": "https://api.github.com/users/tnielens/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tnielens/subscriptions", "organizations_url": "https://api.github.com/users/tnielens/orgs", "repos_url": "https://api.github.com/users/tnielens/repos", "events_url": "https://api.github.com/users/tnielens/events{/privacy}", "received_events_url": "https://api.github.com/users/tnielens/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "390a13b06c79d4177b829097b06453e38188081f", "url": "https://api.github.com/repos/rust-lang/rust/commits/390a13b06c79d4177b829097b06453e38188081f", "html_url": "https://github.com/rust-lang/rust/commit/390a13b06c79d4177b829097b06453e38188081f"}], "stats": {"total": 254, "additions": 102, "deletions": 152}, "files": [{"sha": "1d17fbd372541bbeb8a1fb99eca01dd2db7035ef", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 71, "deletions": 151, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=a60e5de90c7370d4fb3e6561d3cb55495cda2e2a", "patch": "@@ -1,23 +1,22 @@\n+use crate::utils::paths;\n+use crate::utils::{get_trait_def_id, in_macro, span_lint, trait_ref_of_method};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def::{DefKind, Res};\n use rustc_hir::intravisit::{\n-    walk_fn_decl, walk_generic_param, walk_generics, walk_param_bound, walk_trait_ref, walk_ty, NestedVisitorMap,\n-    Visitor,\n+    walk_fn_decl, walk_generic_param, walk_generics, walk_item, walk_param_bound, walk_poly_trait_ref, walk_ty,\n+    NestedVisitorMap, Visitor,\n };\n use rustc_hir::FnRetTy::Return;\n use rustc_hir::{\n-    BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, ImplItem, ImplItemKind, Item,\n-    ItemKind, Lifetime, LifetimeName, ParamName, QPath, TraitBoundModifier, TraitFn, TraitItem, TraitItemKind,\n-    TraitRef, Ty, TyKind, WhereClause, WherePredicate,\n+    BareFnTy, BodyId, FnDecl, GenericArg, GenericBound, GenericParam, GenericParamKind, Generics, ImplItem,\n+    ImplItemKind, Item, ItemKind, Lifetime, LifetimeName, ParamName, PolyTraitRef, TraitBoundModifier, TraitFn,\n+    TraitItem, TraitItemKind, Ty, TyKind, WhereClause, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use rustc_span::symbol::{kw, Symbol};\n-\n-use crate::utils::paths;\n-use crate::utils::{get_trait_def_id, in_macro, last_path_segment, span_lint, trait_ref_of_method};\n+use std::iter::FromIterator;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for lifetime annotations which can be removed by\n@@ -110,7 +109,7 @@ impl<'tcx> LateLintPass<'tcx> for Lifetimes {\n }\n \n /// The lifetime of a &-reference.\n-#[derive(PartialEq, Eq, Hash, Debug)]\n+#[derive(PartialEq, Eq, Hash, Debug, Clone)]\n enum RefLt {\n     Unnamed,\n     Static,\n@@ -129,15 +128,6 @@ fn check_fn_inner<'tcx>(\n         return;\n     }\n \n-    // fn pointers and closure trait bounds are also lifetime elision sites. This lint does not\n-    // support nested elision sites in a fn item.\n-    if FnPointerOrClosureTraitBoundFinder::find_in_generics(cx, generics)\n-        || FnPointerOrClosureTraitBoundFinder::find_in_fn_decl(cx, decl)\n-    {\n-        return;\n-    }\n-\n-    let mut bounds_lts = Vec::new();\n     let types = generics\n         .params\n         .iter()\n@@ -166,13 +156,12 @@ fn check_fn_inner<'tcx>(\n                         if bound.name != LifetimeName::Static && !bound.is_elided() {\n                             return;\n                         }\n-                        bounds_lts.push(bound);\n                     }\n                 }\n             }\n         }\n     }\n-    if could_use_elision(cx, decl, body, &generics.params, bounds_lts) {\n+    if could_use_elision(cx, decl, body, &generics.params) {\n         span_lint(\n             cx,\n             NEEDLESS_LIFETIMES,\n@@ -191,7 +180,6 @@ fn could_use_elision<'tcx>(\n     func: &'tcx FnDecl<'_>,\n     body: Option<BodyId>,\n     named_generics: &'tcx [GenericParam<'_>],\n-    bounds_lts: Vec<&'tcx Lifetime>,\n ) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n@@ -214,15 +202,31 @@ fn could_use_elision<'tcx>(\n     if let Return(ref ty) = func.output {\n         output_visitor.visit_ty(ty);\n     }\n+    for lt in named_generics {\n+        input_visitor.visit_generic_param(lt)\n+    }\n \n-    let input_lts = match input_visitor.into_vec() {\n-        Some(lts) => lts_from_bounds(lts, bounds_lts.into_iter()),\n-        None => return false,\n-    };\n-    let output_lts = match output_visitor.into_vec() {\n-        Some(val) => val,\n-        None => return false,\n-    };\n+    if input_visitor.abort() || output_visitor.abort() {\n+        return false;\n+    }\n+\n+    if allowed_lts\n+        .intersection(&FxHashSet::from_iter(\n+            input_visitor\n+                .nested_elision_site_lts\n+                .iter()\n+                .chain(output_visitor.nested_elision_site_lts.iter())\n+                .cloned()\n+                .filter(|v| matches!(v, RefLt::Named(_))),\n+        ))\n+        .next()\n+        .is_some()\n+    {\n+        return false;\n+    }\n+\n+    let input_lts = input_visitor.lts;\n+    let output_lts = output_visitor.lts;\n \n     if let Some(body_id) = body {\n         let mut checker = BodyLifetimeChecker {\n@@ -287,35 +291,29 @@ fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n     allowed_lts\n }\n \n-fn lts_from_bounds<'a, T: Iterator<Item = &'a Lifetime>>(mut vec: Vec<RefLt>, bounds_lts: T) -> Vec<RefLt> {\n-    for lt in bounds_lts {\n-        if lt.name != LifetimeName::Static {\n-            vec.push(RefLt::Named(lt.name.ident().name));\n-        }\n-    }\n-\n-    vec\n-}\n-\n /// Number of unique lifetimes in the given vector.\n #[must_use]\n fn unique_lifetimes(lts: &[RefLt]) -> usize {\n     lts.iter().collect::<FxHashSet<_>>().len()\n }\n \n+const CLOSURE_TRAIT_BOUNDS: [&[&str]; 3] = [&paths::FN, &paths::FN_MUT, &paths::FN_ONCE];\n+\n /// A visitor usable for `rustc_front::visit::walk_ty()`.\n struct RefVisitor<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     lts: Vec<RefLt>,\n-    abort: bool,\n+    nested_elision_site_lts: Vec<RefLt>,\n+    unelided_trait_object_lifetime: bool,\n }\n \n impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n     fn new(cx: &'a LateContext<'tcx>) -> Self {\n         Self {\n             cx,\n             lts: Vec::new(),\n-            abort: false,\n+            nested_elision_site_lts: Vec::new(),\n+            unelided_trait_object_lifetime: false,\n         }\n     }\n \n@@ -335,40 +333,16 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn into_vec(self) -> Option<Vec<RefLt>> {\n-        if self.abort {\n-            None\n-        } else {\n-            Some(self.lts)\n-        }\n+    fn all_lts(&self) -> Vec<RefLt> {\n+        self.lts\n+            .iter()\n+            .chain(self.nested_elision_site_lts.iter())\n+            .cloned()\n+            .collect::<Vec<_>>()\n     }\n \n-    fn collect_anonymous_lifetimes(&mut self, qpath: &QPath<'_>, ty: &Ty<'_>) {\n-        if let Some(ref last_path_segment) = last_path_segment(qpath).args {\n-            if !last_path_segment.parenthesized\n-                && !last_path_segment\n-                    .args\n-                    .iter()\n-                    .any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n-            {\n-                let hir_id = ty.hir_id;\n-                match self.cx.qpath_res(qpath, hir_id) {\n-                    Res::Def(DefKind::TyAlias | DefKind::Struct, def_id) => {\n-                        let generics = self.cx.tcx.generics_of(def_id);\n-                        for _ in generics.params.as_slice() {\n-                            self.record(&None);\n-                        }\n-                    },\n-                    Res::Def(DefKind::Trait, def_id) => {\n-                        let trait_def = self.cx.tcx.trait_def(def_id);\n-                        for _ in &self.cx.tcx.generics_of(trait_def.def_id).params {\n-                            self.record(&None);\n-                        }\n-                    },\n-                    _ => (),\n-                }\n-            }\n-        }\n+    fn abort(&self) -> bool {\n+        self.unelided_trait_object_lifetime\n     }\n }\n \n@@ -380,30 +354,36 @@ impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n         self.record(&Some(*lifetime));\n     }\n \n+    fn visit_poly_trait_ref(&mut self, poly_tref: &'tcx PolyTraitRef<'tcx>, tbm: TraitBoundModifier) {\n+        let trait_ref = &poly_tref.trait_ref;\n+        if CLOSURE_TRAIT_BOUNDS\n+            .iter()\n+            .any(|trait_path| trait_ref.trait_def_id() == get_trait_def_id(self.cx, trait_path))\n+        {\n+            let mut sub_visitor = RefVisitor::new(self.cx);\n+            sub_visitor.visit_trait_ref(trait_ref);\n+            self.nested_elision_site_lts.append(&mut sub_visitor.all_lts());\n+        } else {\n+            walk_poly_trait_ref(self, poly_tref, tbm);\n+        }\n+    }\n+\n     fn visit_ty(&mut self, ty: &'tcx Ty<'_>) {\n         match ty.kind {\n-            TyKind::Rptr(ref lt, _) if lt.is_elided() => {\n-                self.record(&None);\n-            },\n-            TyKind::Path(ref path) => {\n-                self.collect_anonymous_lifetimes(path, ty);\n-            },\n             TyKind::OpaqueDef(item, _) => {\n                 let map = self.cx.tcx.hir();\n-                if let ItemKind::OpaqueTy(ref exist_ty) = map.expect_item(item.id).kind {\n-                    for bound in exist_ty.bounds {\n-                        if let GenericBound::Outlives(_) = *bound {\n-                            self.record(&None);\n-                        }\n-                    }\n-                } else {\n-                    unreachable!()\n-                }\n+                let item = map.expect_item(item.id);\n+                walk_item(self, item);\n                 walk_ty(self, ty);\n             },\n+            TyKind::BareFn(&BareFnTy { decl, .. }) => {\n+                let mut sub_visitor = RefVisitor::new(self.cx);\n+                sub_visitor.visit_fn_decl(decl);\n+                self.nested_elision_site_lts.append(&mut sub_visitor.all_lts());\n+            },\n             TyKind::TraitObject(bounds, ref lt) => {\n                 if !lt.is_elided() {\n-                    self.abort = true;\n+                    self.unelided_trait_object_lifetime = true;\n                 }\n                 for bound in bounds {\n                     self.visit_poly_trait_ref(bound, TraitBoundModifier::None);\n@@ -440,16 +420,7 @@ fn has_where_lifetimes<'tcx>(cx: &LateContext<'tcx>, where_clause: &'tcx WhereCl\n                     walk_param_bound(&mut visitor, bound);\n                 }\n                 // and check that all lifetimes are allowed\n-                match visitor.into_vec() {\n-                    None => return false,\n-                    Some(lts) => {\n-                        for lt in lts {\n-                            if !allowed_lts.contains(&lt) {\n-                                return true;\n-                            }\n-                        }\n-                    },\n-                }\n+                return visitor.all_lts().iter().any(|it| !allowed_lts.contains(it));\n             },\n             WherePredicate::EqPredicate(ref pred) => {\n                 let mut visitor = RefVisitor::new(cx);\n@@ -533,54 +504,3 @@ impl<'tcx> Visitor<'tcx> for BodyLifetimeChecker {\n         NestedVisitorMap::None\n     }\n }\n-\n-const CLOSURE_TRAIT_BOUNDS: [&[&str]; 3] = [&paths::FN, &paths::FN_MUT, &paths::FN_ONCE];\n-\n-struct FnPointerOrClosureTraitBoundFinder<'a, 'tcx> {\n-    cx: &'a LateContext<'tcx>,\n-    found: bool,\n-}\n-\n-impl<'a, 'tcx> FnPointerOrClosureTraitBoundFinder<'a, 'tcx> {\n-    fn find_in_generics(cx: &'a LateContext<'tcx>, generics: &'tcx Generics<'tcx>) -> bool {\n-        let mut finder = Self { cx, found: false };\n-        finder.visit_generics(generics);\n-        finder.found\n-    }\n-\n-    fn find_in_fn_decl(cx: &'a LateContext<'tcx>, generics: &'tcx FnDecl<'tcx>) -> bool {\n-        let mut finder = Self { cx, found: false };\n-        finder.visit_fn_decl(generics);\n-        finder.found\n-    }\n-}\n-\n-impl<'a, 'tcx> Visitor<'tcx> for FnPointerOrClosureTraitBoundFinder<'a, 'tcx> {\n-    type Map = Map<'tcx>;\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n-\n-    fn visit_trait_ref(&mut self, tref: &'tcx TraitRef<'tcx>) {\n-        if CLOSURE_TRAIT_BOUNDS\n-            .iter()\n-            .any(|trait_path| tref.trait_def_id() == get_trait_def_id(self.cx, trait_path))\n-        {\n-            self.found = true;\n-        }\n-        walk_trait_ref(self, tref);\n-    }\n-\n-    fn visit_ty(&mut self, ty: &'tcx Ty<'tcx>) {\n-        match ty.kind {\n-            TyKind::BareFn(..) => self.found = true,\n-            TyKind::OpaqueDef(item_id, _) => {\n-                let map = self.cx.tcx.hir();\n-                let item = map.expect_item(item_id.id);\n-                self.visit_item(item);\n-            },\n-            _ => (),\n-        }\n-        walk_ty(self, ty);\n-    }\n-}"}, {"sha": "fd502cba73a77afff4a6188746a4740df0f594e8", "filename": "tests/ui/crashes/ice-2774.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a/tests%2Fui%2Fcrashes%2Fice-2774.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a/tests%2Fui%2Fcrashes%2Fice-2774.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fice-2774.stderr?ref=a60e5de90c7370d4fb3e6561d3cb55495cda2e2a", "patch": "@@ -0,0 +1,10 @@\n+error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+  --> $DIR/ice-2774.rs:17:1\n+   |\n+LL | pub fn add_barfoos_to_foos<'a>(bars: &HashSet<&'a Bar>) {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::needless-lifetimes` implied by `-D warnings`\n+\n+error: aborting due to previous error\n+"}, {"sha": "02b86397ed5e7206ffc5fa3517d2212389b2f660", "filename": "tests/ui/crashes/needless_lifetimes_impl_trait.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a/tests%2Fui%2Fcrashes%2Fneedless_lifetimes_impl_trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a/tests%2Fui%2Fcrashes%2Fneedless_lifetimes_impl_trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcrashes%2Fneedless_lifetimes_impl_trait.stderr?ref=a60e5de90c7370d4fb3e6561d3cb55495cda2e2a", "patch": "@@ -0,0 +1,14 @@\n+error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+  --> $DIR/needless_lifetimes_impl_trait.rs:17:5\n+   |\n+LL |     fn baz<'a>(&'a self) -> impl Foo + 'a {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/needless_lifetimes_impl_trait.rs:3:9\n+   |\n+LL | #![deny(clippy::needless_lifetimes)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "d3a360ed8b576d04bf95e0327c1854f81ad8fb4a", "filename": "tests/ui/needless_lifetimes.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a/tests%2Fui%2Fneedless_lifetimes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a60e5de90c7370d4fb3e6561d3cb55495cda2e2a/tests%2Fui%2Fneedless_lifetimes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_lifetimes.stderr?ref=a60e5de90c7370d4fb3e6561d3cb55495cda2e2a", "patch": "@@ -36,6 +36,12 @@ error: explicit lifetimes given in parameter types where they could be elided (o\n LL | fn lifetime_param_2<'a, 'b>(_x: Ref<'a>, _y: &'b u8) {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n+error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n+  --> $DIR/needless_lifetimes.rs:86:1\n+   |\n+LL | fn fn_bound_2<'a, F, I>(_m: Lt<'a, I>, _f: F) -> Lt<'a, I>\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n error: explicit lifetimes given in parameter types where they could be elided (or replaced with `'_` if needed by type declaration)\n   --> $DIR/needless_lifetimes.rs:120:5\n    |\n@@ -96,5 +102,5 @@ error: explicit lifetimes given in parameter types where they could be elided (o\n LL |         fn needless_lt<'a>(_x: &'a u8) {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 17 previous errors\n "}]}