{"sha": "2c1612c62aa59e40cf1a4bddde943938e0147eec", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjMTYxMmM2MmFhNTllNDBjZjFhNGJkZGRlOTQzOTM4ZTAxNDdlZWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-01T11:47:48Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-01T11:47:48Z"}, "message": "Auto merge of #34743 - badboy:llvm-upgrade, r=eddyb\n\nLLVM upgrade\n\nAs discussed in https://internals.rust-lang.org/t/need-help-with-emscripten-port/3154/46 I'm trying to update the used LLVM checkout in Rust.\n\nI basically took @shepmaster's code and applied it on top (though I did the commits manually, the [original commits have better descriptions](https://github.com/rust-lang/rust/compare/master...avr-rust:avr-support).\n\nWith these changes I was able to build rustc. `make check` throws one last error on `run-pass/issue-28950.rs`. Output: https://gist.github.com/badboy/bcdd3bbde260860b6159aa49070a9052\n\nI took the metadata changes as is and they seem to work, though it now uses the module in another step. I'm not sure if this is the best and correct way.\n\nThings to do:\n\n* [x] ~~Make `run-pass/issue-28950.rs` pass~~ unrelated\n* [x] Find out how the `PositionIndependentExecutable` setting is now used\n* [x] Is the `llvm::legacy` still the right way to do these things?\n\ncc @brson @alexcrichton", "tree": {"sha": "60f9b802b477dfc93aad9a97f9a7d07b83cc4eaa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60f9b802b477dfc93aad9a97f9a7d07b83cc4eaa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c1612c62aa59e40cf1a4bddde943938e0147eec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c1612c62aa59e40cf1a4bddde943938e0147eec", "html_url": "https://github.com/rust-lang/rust/commit/2c1612c62aa59e40cf1a4bddde943938e0147eec", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c1612c62aa59e40cf1a4bddde943938e0147eec/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "html_url": "https://github.com/rust-lang/rust/commit/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e"}, {"sha": "5d1d2475232d06b2a315d87481898819bb547f97", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d1d2475232d06b2a315d87481898819bb547f97", "html_url": "https://github.com/rust-lang/rust/commit/5d1d2475232d06b2a315d87481898819bb547f97"}], "stats": {"total": 633, "additions": 241, "deletions": 392}, "files": [{"sha": "d4bd16167d35cba350c1e042b12e1b189a8a720a", "filename": "configure", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/configure", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -1020,6 +1020,12 @@ then\n             err \"bad LLVM version: $LLVM_VERSION, need >=3.7\"\n             ;;\n     esac\n+\n+    if \"$CFG_LLVM_ROOT/bin/llvm-mc\" -help | grep -- \"-relocation-model\"; then\n+        msg \"found older llvm-mc\"\n+        CFG_LLVM_MC_HAS_RELOCATION_MODEL=1\n+        putvar CFG_LLVM_MC_HAS_RELOCATION_MODEL\n+    fi\n fi\n \n # Even when the user overrides the choice of CC, still try to detect"}, {"sha": "d601cab7221f4f097859c2336bbac41ae96df0c0", "filename": "mk/platform.mk", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/mk%2Fplatform.mk", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/mk%2Fplatform.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fplatform.mk?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -221,12 +221,19 @@ define CFG_MAKE_TOOLCHAIN\n     LLVM_MC_RELOCATION_MODEL=\"default\"\n   endif\n \n+  # LLVM changed this flag in 3.9\n+  ifdef CFG_LLVM_MC_HAS_RELOCATION_MODEL\n+    LLVM_MC_RELOC_FLAG := -relocation-model=$$(LLVM_MC_RELOCATION_MODEL)\n+  else\n+    LLVM_MC_RELOC_FLAG := -position-independent\n+  endif\n+\n   # We're using llvm-mc as our assembler because it supports\n   # .cfi pseudo-ops on mac\n   CFG_ASSEMBLE_$(1)=$$(CPP_$(1)) -E $$(2) | \\\n                     $$(LLVM_MC_$$(CFG_BUILD)) \\\n                     -assemble \\\n-                    -relocation-model=$$(LLVM_MC_RELOCATION_MODEL) \\\n+                    $$(LLVM_MC_RELOC_FLAG) \\\n                     -filetype=obj \\\n                     -triple=$(1) \\\n                     -o=$$(1)"}, {"sha": "8598065bd965d9713bfafb6c1e766d63a7b17b89", "filename": "src/compiler-rt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -1 +1 @@\n-Subproject commit ac3d1cda612edccb6f1da53cbf7716e248405f3b\n+Subproject commit 8598065bd965d9713bfafb6c1e766d63a7b17b89"}, {"sha": "24b007576aa24ad673a6687d246400f0dd16b459", "filename": "src/etc/mklldeps.py", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Fetc%2Fmklldeps.py", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Fetc%2Fmklldeps.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fmklldeps.py?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -77,6 +77,13 @@ def runErr(args):\n         lib = lib.strip()[2:]\n     elif lib[0] == '-':\n         lib = lib.strip()[1:]\n+    # If this actually points at a literal file then we're on MSVC which now\n+    # prints full paths, so get just the name of the library and strip off the\n+    # trailing \".lib\"\n+    elif os.path.exists(lib):\n+        lib = os.path.basename(lib)[:-4]\n+    elif lib[-4:] == '.lib':\n+        lib = lib[:-4]\n     f.write(\"#[link(name = \\\"\" + lib + \"\\\"\")\n     if not llvm_shared and 'LLVM' in lib:\n         f.write(\", kind = \\\"static\\\"\")"}, {"sha": "7f54dab5b5385faa87e0185ab446712dec3cdcbc", "filename": "src/librustc_back/target/aarch64_linux_android.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_linux_android.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -20,7 +20,7 @@ pub fn target() -> TargetResult {\n         llvm_target: \"aarch64-linux-android\".to_string(),\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n-        data_layout: \"e-m:e-i64:64-i128:128-n32:64-S128\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"android\".to_string(),\n         target_env: \"\".to_string(),"}, {"sha": "cca965f9d4ff16c0c52d40f16c781c12171f953b", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -18,7 +18,7 @@ pub fn target() -> TargetResult {\n         target_endian: \"little\".to_string(),\n         target_pointer_width: \"64\".to_string(),\n         target_env: \"gnu\".to_string(),\n-        data_layout: \"e-m:e-i64:64-i128:128-n32:64-S128\".to_string(),\n+        data_layout: \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"linux\".to_string(),\n         target_vendor: \"unknown\".to_string(),"}, {"sha": "085ea240a5055d3b92b99a721e19e01a24d96d4f", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -13,7 +13,7 @@ extern crate build_helper;\n \n use std::process::Command;\n use std::env;\n-use std::path::PathBuf;\n+use std::path::{PathBuf, Path};\n \n use build_helper::output;\n \n@@ -135,8 +135,17 @@ fn main() {\n             &lib[2..]\n         } else if lib.starts_with(\"-\") {\n             &lib[1..]\n+        } else if Path::new(lib).exists() {\n+            // On MSVC llvm-config will print the full name to libraries, but\n+            // we're only interested in the name part\n+            let name = Path::new(lib).file_name().unwrap().to_str().unwrap();\n+            name.trim_right_matches(\".lib\")\n+        } else if lib.ends_with(\".lib\") {\n+            // Some MSVC libraries just come up with `.lib` tacked on, so chop\n+            // that off\n+            lib.trim_right_matches(\".lib\")\n         } else {\n-            continue;\n+            continue\n         };\n \n         // Don't need or want this library, but LLVM's CMake build system\n@@ -145,7 +154,7 @@ fn main() {\n         // library and it otherwise may just pull in extra dependencies on\n         // libedit which we don't want\n         if name == \"LLVMLineEditor\" {\n-            continue;\n+            continue\n         }\n \n         let kind = if name.starts_with(\"LLVM\") {\n@@ -165,7 +174,9 @@ fn main() {\n     let mut cmd = Command::new(&llvm_config);\n     cmd.arg(\"--ldflags\");\n     for lib in output(&mut cmd).split_whitespace() {\n-        if is_crossed {\n+        if lib.starts_with(\"-LIBPATH:\") {\n+                println!(\"cargo:rustc-link-search=native={}\", &lib[9..]);\n+        } else if is_crossed {\n             if lib.starts_with(\"-L\") {\n                 println!(\"cargo:rustc-link-search=native={}\",\n                          lib[2..].replace(&host, &target));"}, {"sha": "6905abc2902400451a6e896700cdea4f1556de3e", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -226,7 +226,7 @@ impl Attributes {\n \n     pub fn apply_callsite(&self, idx: usize, callsite: ValueRef) {\n         unsafe {\n-            LLVMAddCallSiteAttribute(callsite, idx as c_uint, self.regular.bits());\n+            LLVMRustAddCallSiteAttribute(callsite, idx as c_uint, self.regular.bits());\n             if self.dereferenceable_bytes != 0 {\n                 LLVMAddDereferenceableCallSiteAttr(callsite, idx as c_uint,\n                                                    self.dereferenceable_bytes);\n@@ -1056,7 +1056,7 @@ extern {\n     pub fn LLVMSetInstrParamAlignment(Instr: ValueRef,\n                                       index: c_uint,\n                                       align: c_uint);\n-    pub fn LLVMAddCallSiteAttribute(Instr: ValueRef,\n+    pub fn LLVMRustAddCallSiteAttribute(Instr: ValueRef,\n                                     index: c_uint,\n                                     Val: uint64_t);\n     pub fn LLVMAddDereferenceableCallSiteAttr(Instr: ValueRef,\n@@ -1561,7 +1561,7 @@ extern {\n                                 Alignment: c_uint)\n                                 -> ValueRef;\n \n-    pub fn LLVMBuildAtomicCmpXchg(B: BuilderRef,\n+    pub fn LLVMRustBuildAtomicCmpXchg(B: BuilderRef,\n                                   LHS: ValueRef,\n                                   CMP: ValueRef,\n                                   RHS: ValueRef,\n@@ -1591,9 +1591,6 @@ extern {\n \n     /// Creates target data from a target layout string.\n     pub fn LLVMCreateTargetData(StringRep: *const c_char) -> TargetDataRef;\n-    /// Adds the target data to the given pass manager. The pass manager\n-    /// references the target data only weakly.\n-    pub fn LLVMAddTargetData(TD: TargetDataRef, PM: PassManagerRef);\n     /// Number of bytes clobbered when doing a Store to *T.\n     pub fn LLVMStoreSizeOfType(TD: TargetDataRef, Ty: TypeRef)\n                                -> c_ulonglong;\n@@ -2155,6 +2152,7 @@ extern {\n \n     pub fn LLVMRustSetComdat(M: ModuleRef, V: ValueRef, Name: *const c_char);\n     pub fn LLVMRustUnsetComdat(V: ValueRef);\n+    pub fn LLVMRustSetModulePIELevel(M: ModuleRef);\n }\n \n // LLVM requires symbols from this library, but apparently they're not printed"}, {"sha": "87815c63f7992b2b46e6359c0f61693e1f29dd97", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 3, "deletions": 23, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -24,6 +24,7 @@ use util::fs::link_or_copy;\n use errors::{self, Handler, Level, DiagnosticBuilder};\n use errors::emitter::Emitter;\n use syntax_pos::MultiSpan;\n+use context::{is_pie_binary, get_reloc_model};\n \n use std::collections::HashMap;\n use std::ffi::{CStr, CString};\n@@ -154,32 +155,11 @@ fn get_llvm_opt_size(optimize: config::OptLevel) -> llvm::CodeGenOptSize {\n }\n \n pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n-    let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => &s[..],\n-        None => &sess.target.target.options.relocation_model[..],\n-    };\n-    let reloc_model = match reloc_model_arg {\n-        \"pic\" => llvm::RelocPIC,\n-        \"static\" => llvm::RelocStatic,\n-        \"default\" => llvm::RelocDefault,\n-        \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n-        _ => {\n-            sess.err(&format!(\"{:?} is not a valid relocation mode\",\n-                             sess.opts\n-                                 .cg\n-                                 .relocation_model));\n-            sess.abort_if_errors();\n-            bug!();\n-        }\n-    };\n+    let reloc_model = get_reloc_model(sess);\n \n     let opt_level = get_llvm_opt_level(sess.opts.optimize);\n     let use_softfp = sess.opts.cg.soft_float;\n \n-    let any_library = sess.crate_types.borrow().iter().any(|ty| {\n-        *ty != config::CrateTypeExecutable\n-    });\n-\n     let ffunction_sections = sess.target.target.options.function_sections;\n     let fdata_sections = ffunction_sections;\n \n@@ -220,7 +200,7 @@ pub fn create_target_machine(sess: &Session) -> TargetMachineRef {\n             reloc_model,\n             opt_level,\n             use_softfp,\n-            !any_library && reloc_model == llvm::RelocPIC,\n+            is_pie_binary(sess),\n             ffunction_sections,\n             fdata_sections,\n         )"}, {"sha": "7495f2b753b86e711186ccc5ee919c985bb2fcb1", "filename": "src/librustc_trans/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbuilder.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -1083,7 +1083,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                          failure_order: AtomicOrdering,\n                          weak: llvm::Bool) -> ValueRef {\n         unsafe {\n-            llvm::LLVMBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src,\n+            llvm::LLVMRustBuildAtomicCmpXchg(self.llbuilder, dst, cmp, src,\n                                          order, failure_order, weak)\n         }\n     }"}, {"sha": "792169b08a4c677b7918da435af28f975f2cfc15", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -34,6 +34,7 @@ use rustc::ty::subst::{Substs, VecPerParamSpace};\n use rustc::ty::{self, Ty, TyCtxt};\n use session::config::NoDebugInfo;\n use session::Session;\n+use session::config;\n use symbol_map::SymbolMap;\n use util::sha2::Sha256;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, FnvHashMap, FnvHashSet};\n@@ -322,6 +323,38 @@ impl<'a, 'tcx> Iterator for CrateContextMaybeIterator<'a, 'tcx> {\n     }\n }\n \n+pub fn get_reloc_model(sess: &Session) -> llvm::RelocMode {\n+    let reloc_model_arg = match sess.opts.cg.relocation_model {\n+        Some(ref s) => &s[..],\n+        None => &sess.target.target.options.relocation_model[..],\n+    };\n+\n+    match reloc_model_arg {\n+        \"pic\" => llvm::RelocPIC,\n+        \"static\" => llvm::RelocStatic,\n+        \"default\" => llvm::RelocDefault,\n+        \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n+        _ => {\n+            sess.err(&format!(\"{:?} is not a valid relocation mode\",\n+                             sess.opts\n+                                 .cg\n+                                 .relocation_model));\n+            sess.abort_if_errors();\n+            bug!();\n+        }\n+    }\n+}\n+\n+fn is_any_library(sess: &Session) -> bool {\n+    sess.crate_types.borrow().iter().any(|ty| {\n+        *ty != config::CrateTypeExecutable\n+    })\n+}\n+\n+pub fn is_pie_binary(sess: &Session) -> bool {\n+    !is_any_library(sess) && get_reloc_model(sess) == llvm::RelocPIC\n+}\n+\n unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextRef, ModuleRef) {\n     let llcx = llvm::LLVMContextCreate();\n     let mod_name = CString::new(mod_name).unwrap();\n@@ -337,7 +370,25 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n         let data_layout = str::from_utf8(CStr::from_ptr(data_layout).to_bytes())\n             .ok().expect(\"got a non-UTF8 data-layout from LLVM\");\n \n-        if sess.target.target.data_layout != data_layout {\n+        // Unfortunately LLVM target specs change over time, and right now we\n+        // don't have proper support to work with any more than one\n+        // `data_layout` than the one that is in the rust-lang/rust repo. If\n+        // this compiler is configured against a custom LLVM, we may have a\n+        // differing data layout, even though we should update our own to use\n+        // that one.\n+        //\n+        // As an interim hack, if CFG_LLVM_ROOT is not an empty string then we\n+        // disable this check entirely as we may be configured with something\n+        // that has a different target layout.\n+        //\n+        // Unsure if this will actually cause breakage when rustc is configured\n+        // as such.\n+        //\n+        // FIXME(#34960)\n+        let cfg_llvm_root = option_env!(\"CFG_LLVM_ROOT\").unwrap_or(\"\");\n+        let custom_llvm_used = cfg_llvm_root.trim() != \"\";\n+\n+        if !custom_llvm_used && sess.target.target.data_layout != data_layout {\n             bug!(\"data-layout for builtin `{}` target, `{}`, \\\n                   differs from LLVM default, `{}`\",\n                  sess.target.target.llvm_target,\n@@ -352,6 +403,11 @@ unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (ContextR\n     let llvm_target = sess.target.target.llvm_target.as_bytes();\n     let llvm_target = CString::new(llvm_target).unwrap();\n     llvm::LLVMRustSetNormalizedTarget(llmod, llvm_target.as_ptr());\n+\n+    if is_pie_binary(sess) {\n+        llvm::LLVMRustSetModulePIELevel(llmod);\n+    }\n+\n     (llcx, llmod)\n }\n \n@@ -558,7 +614,9 @@ impl<'tcx> LocalCrateContext<'tcx> {\n                                                           &llmod_id[..]);\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n-                Some(debuginfo::CrateDebugContext::new(llmod))\n+                let dctx = debuginfo::CrateDebugContext::new(llmod);\n+                debuginfo::metadata::compile_unit_metadata(shared, &dctx, shared.tcx.sess);\n+                Some(dctx)\n             } else {\n                 None\n             };"}, {"sha": "387f24378ce0b269611d86133296aeb1c313b66b", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -18,7 +18,9 @@ use super::utils::{debug_context, DIB, span_start, bytes_to_bits, size_and_align\n                    fn_should_be_ignored, is_node_local_to_unit};\n use super::namespace::mangled_name_of_item;\n use super::type_names::{compute_debuginfo_type_name, push_debuginfo_type_name};\n-use super::{declare_local, VariableKind, VariableAccess};\n+use super::{declare_local, VariableKind, VariableAccess, CrateDebugContext};\n+use context::SharedCrateContext;\n+use session::Session;\n \n use llvm::{self, ValueRef};\n use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n@@ -48,7 +50,6 @@ use syntax::ast;\n use syntax::parse::token;\n use syntax_pos::{self, Span};\n \n-\n // From DWARF 5.\n // See http://www.dwarfstd.org/ShowIssue.php?issue=140129.1\n const DW_LANG_RUST: c_uint = 0x1c;\n@@ -67,7 +68,6 @@ pub const UNKNOWN_LINE_NUMBER: c_uint = 0;\n pub const UNKNOWN_COLUMN_NUMBER: c_uint = 0;\n \n // ptr::null() doesn't work :(\n-pub const NO_FILE_METADATA: DIFile = (0 as DIFile);\n pub const NO_SCOPE_METADATA: DIScope = (0 as DIScope);\n \n const FLAGS_NONE: c_uint = 0;\n@@ -615,7 +615,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         unsafe {\n             llvm::LLVMDIBuilderCreateSubroutineType(\n                 DIB(cx),\n-                NO_FILE_METADATA,\n+                unknown_file_metadata(cx),\n                 create_DIArray(DIB(cx), &signature_metadata[..]))\n         },\n         false);\n@@ -652,14 +652,15 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (containing_scope, _) = get_namespace_and_span_for_item(cx, def_id);\n \n     let trait_llvm_type = type_of::type_of(cx, trait_object_type);\n+    let file_metadata = unknown_file_metadata(cx);\n \n     composite_type_metadata(cx,\n                             trait_llvm_type,\n                             &trait_type_name[..],\n                             unique_type_id,\n                             &[],\n                             containing_scope,\n-                            NO_FILE_METADATA,\n+                            file_metadata,\n                             syntax_pos::DUMMY_SP)\n }\n \n@@ -981,14 +982,17 @@ fn pointer_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     return ptr_metadata;\n }\n \n-pub fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n-    let work_dir = &cx.sess().working_dir;\n-    let compile_unit_name = match cx.sess().local_crate_source_file {\n-        None => fallback_path(cx),\n+pub fn compile_unit_metadata(scc: &SharedCrateContext,\n+                             debug_context: &CrateDebugContext,\n+                             sess: &Session)\n+                             -> DIDescriptor {\n+    let work_dir = &sess.working_dir;\n+    let compile_unit_name = match sess.local_crate_source_file {\n+        None => fallback_path(scc),\n         Some(ref abs_path) => {\n             if abs_path.is_relative() {\n-                cx.sess().warn(\"debuginfo: Invalid path to crate's local root source file!\");\n-                fallback_path(cx)\n+                sess.warn(\"debuginfo: Invalid path to crate's local root source file!\");\n+                fallback_path(scc)\n             } else {\n                 match abs_path.strip_prefix(work_dir) {\n                     Ok(ref p) if p.is_relative() => {\n@@ -998,7 +1002,7 @@ pub fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n                             path2cstr(&Path::new(\".\").join(p))\n                         }\n                     }\n-                    _ => fallback_path(cx)\n+                    _ => fallback_path(scc)\n                 }\n             }\n         }\n@@ -1015,19 +1019,19 @@ pub fn compile_unit_metadata(cx: &CrateContext) -> DIDescriptor {\n     let split_name = \"\\0\";\n     return unsafe {\n         llvm::LLVMDIBuilderCreateCompileUnit(\n-            debug_context(cx).builder,\n+            debug_context.builder,\n             DW_LANG_RUST,\n             compile_unit_name,\n             work_dir.as_ptr(),\n             producer.as_ptr(),\n-            cx.sess().opts.optimize != config::OptLevel::No,\n+            sess.opts.optimize != config::OptLevel::No,\n             flags.as_ptr() as *const _,\n             0,\n             split_name.as_ptr() as *const _)\n     };\n \n-    fn fallback_path(cx: &CrateContext) -> CString {\n-        CString::new(cx.link_meta().crate_name.clone()).unwrap()\n+    fn fallback_path(scc: &SharedCrateContext) -> CString {\n+        CString::new(scc.link_meta().crate_name.clone()).unwrap()\n     }\n }\n \n@@ -1624,7 +1628,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                         DIB(cx),\n                         containing_scope,\n                         name.as_ptr(),\n-                        NO_FILE_METADATA,\n+                        file_metadata,\n                         UNKNOWN_LINE_NUMBER,\n                         bytes_to_bits(discriminant_size),\n                         bytes_to_bits(discriminant_align),\n@@ -1770,7 +1774,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n                     DIB(cx),\n                     composite_type_metadata,\n                     member_name.as_ptr(),\n-                    NO_FILE_METADATA,\n+                    unknown_file_metadata(cx),\n                     UNKNOWN_LINE_NUMBER,\n                     bytes_to_bits(member_size),\n                     bytes_to_bits(member_align),\n@@ -1813,7 +1817,7 @@ fn create_struct_stub(cx: &CrateContext,\n             DIB(cx),\n             containing_scope,\n             name.as_ptr(),\n-            NO_FILE_METADATA,\n+            unknown_file_metadata(cx),\n             UNKNOWN_LINE_NUMBER,\n             bytes_to_bits(struct_size),\n             bytes_to_bits(struct_align),\n@@ -1853,7 +1857,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n         let loc = span_start(cx, span);\n         (file_metadata(cx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)\n     } else {\n-        (NO_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n+        (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER)\n     };\n \n     let is_local_to_unit = is_node_local_to_unit(cx, node_id);"}, {"sha": "ed20d949d55cce81b1629f9a4f0c54d024c3fdfe", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -18,7 +18,7 @@ use self::utils::{DIB, span_start, create_DIArray, is_node_local_to_unit};\n use self::namespace::mangled_name_of_item;\n use self::type_names::compute_debuginfo_type_name;\n use self::metadata::{type_metadata, diverging_type_metadata};\n-use self::metadata::{file_metadata, scope_metadata, TypeMap, compile_unit_metadata};\n+use self::metadata::{file_metadata, scope_metadata, TypeMap};\n use self::source_loc::InternalDebugLocation::{self, UnknownLocation};\n \n use llvm;\n@@ -50,7 +50,7 @@ pub mod gdb;\n mod utils;\n mod namespace;\n mod type_names;\n-mod metadata;\n+pub mod metadata;\n mod create_scope_map;\n mod source_loc;\n \n@@ -168,7 +168,6 @@ pub fn finalize(cx: &CrateContext) {\n     }\n \n     debug!(\"finalize\");\n-    let _ = compile_unit_metadata(cx);\n \n     if gdb::needs_gdb_debug_scripts_section(cx) {\n         // Add a .debug_gdb_scripts section to this compile-unit. This will"}, {"sha": "736a8c1c7d70c3561a541435cb09920a063837e9", "filename": "src/librustc_trans/debuginfo/namespace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fnamespace.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -10,7 +10,7 @@\n \n // Namespace Handling.\n \n-use super::metadata::{file_metadata, NO_FILE_METADATA, UNKNOWN_LINE_NUMBER};\n+use super::metadata::{file_metadata, unknown_file_metadata, UNKNOWN_LINE_NUMBER};\n use super::utils::{DIB, debug_context, span_start};\n \n use llvm;\n@@ -74,7 +74,7 @@ pub fn item_namespace(ccx: &CrateContext, def_id: DefId) -> DIScope {\n         let loc = span_start(ccx, span);\n         (file_metadata(ccx, &loc.file.name, &loc.file.abs_path), loc.line as c_uint)\n     } else {\n-        (NO_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n+        (unknown_file_metadata(ccx), UNKNOWN_LINE_NUMBER)\n     };\n \n     let scope = unsafe {"}, {"sha": "d1cc48989b13780f21c408fef17dceb104a09c9d", "filename": "src/llvm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -1 +1 @@\n-Subproject commit 7ca76af03bb04659562890d6b4f223fffe0d748f\n+Subproject commit d1cc48989b13780f21c408fef17dceb104a09c9d"}, {"sha": "3d48024c8798573596a9777b2d7932e2ce52593a", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 48, "deletions": 2, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -43,11 +43,19 @@ LLVMRustOpenArchive(char *path) {\n         return nullptr;\n     }\n \n+#if LLVM_VERSION_MINOR <= 8\n     ErrorOr<std::unique_ptr<Archive>> archive_or =\n+#else\n+    Expected<std::unique_ptr<Archive>> archive_or =\n+#endif\n         Archive::create(buf_or.get()->getMemBufferRef());\n \n     if (!archive_or) {\n+#if LLVM_VERSION_MINOR <= 8\n         LLVMRustSetLastError(archive_or.getError().message().c_str());\n+#else\n+        LLVMRustSetLastError(toString(archive_or.takeError()).c_str());\n+#endif\n         return nullptr;\n     }\n \n@@ -65,22 +73,39 @@ LLVMRustDestroyArchive(RustArchive *ar) {\n struct RustArchiveIterator {\n     Archive::child_iterator cur;\n     Archive::child_iterator end;\n+#if LLVM_VERSION_MINOR >= 9\n+    Error err;\n+#endif\n };\n \n extern \"C\" RustArchiveIterator*\n LLVMRustArchiveIteratorNew(RustArchive *ra) {\n     Archive *ar = ra->getBinary();\n     RustArchiveIterator *rai = new RustArchiveIterator();\n+#if LLVM_VERSION_MINOR <= 8\n     rai->cur = ar->child_begin();\n+#else\n+    rai->cur = ar->child_begin(rai->err);\n+    if (rai->err) {\n+        LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+        return NULL;\n+    }\n+#endif\n     rai->end = ar->child_end();\n     return rai;\n }\n \n extern \"C\" const Archive::Child*\n LLVMRustArchiveIteratorNext(RustArchiveIterator *rai) {\n+#if LLVM_VERSION_MINOR >= 9\n+    if (rai->err) {\n+        LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+        return NULL;\n+    }\n+#endif\n     if (rai->cur == rai->end)\n         return NULL;\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_MINOR == 8\n     const ErrorOr<Archive::Child>* cur = rai->cur.operator->();\n     if (!*cur) {\n         LLVMRustSetLastError(cur->getError().message().c_str());\n@@ -150,19 +175,40 @@ LLVMRustWriteArchive(char *Dst,\n                      const LLVMRustArchiveMember **NewMembers,\n                      bool WriteSymbtab,\n                      Archive::Kind Kind) {\n+\n+#if LLVM_VERSION_MINOR <= 8\n   std::vector<NewArchiveIterator> Members;\n+#else\n+  std::vector<NewArchiveMember> Members;\n+#endif\n \n   for (size_t i = 0; i < NumMembers; i++) {\n     auto Member = NewMembers[i];\n     assert(Member->name);\n     if (Member->filename) {\n-#if LLVM_VERSION_MINOR >= 8\n+#if LLVM_VERSION_MINOR >= 9\n+      Expected<NewArchiveMember> MOrErr = NewArchiveMember::getFile(Member->filename, true);\n+      if (!MOrErr) {\n+        LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n+        return -1;\n+      }\n+      Members.push_back(std::move(*MOrErr));\n+#elif LLVM_VERSION_MINOR == 8\n       Members.push_back(NewArchiveIterator(Member->filename));\n #else\n       Members.push_back(NewArchiveIterator(Member->filename, Member->name));\n #endif\n     } else {\n+#if LLVM_VERSION_MINOR <= 8\n       Members.push_back(NewArchiveIterator(Member->child, Member->name));\n+#else\n+      Expected<NewArchiveMember> MOrErr = NewArchiveMember::getOldMember(Member->child, true);\n+      if (!MOrErr) {\n+        LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n+        return -1;\n+      }\n+      Members.push_back(std::move(*MOrErr));\n+#endif\n     }\n   }\n #if LLVM_VERSION_MINOR >= 8"}, {"sha": "a1276060271bbb09f2b409417fd814477a51c206", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 53, "deletions": 5, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -167,12 +167,35 @@ LLVMRustCreateTargetMachine(const char *triple,\n                             const char *cpu,\n                             const char *feature,\n                             CodeModel::Model CM,\n-                            Reloc::Model RM,\n+                            LLVMRelocMode Reloc,\n                             CodeGenOpt::Level OptLevel,\n                             bool UseSoftFloat,\n                             bool PositionIndependentExecutable,\n                             bool FunctionSections,\n                             bool DataSections) {\n+\n+#if LLVM_VERSION_MINOR <= 8\n+    Reloc::Model RM;\n+#else\n+    Optional<Reloc::Model> RM;\n+#endif\n+    switch (Reloc){\n+        case LLVMRelocStatic:\n+            RM = Reloc::Static;\n+            break;\n+        case LLVMRelocPIC:\n+            RM = Reloc::PIC_;\n+            break;\n+        case LLVMRelocDynamicNoPic:\n+            RM = Reloc::DynamicNoPIC;\n+            break;\n+        default:\n+#if LLVM_VERSION_MINOR <= 8\n+            RM = Reloc::Default;\n+#endif\n+            break;\n+    }\n+\n     std::string Error;\n     Triple Trip(Triple::normalize(triple));\n     const llvm::Target *TheTarget = TargetRegistry::lookupTarget(Trip.getTriple(),\n@@ -188,7 +211,10 @@ LLVMRustCreateTargetMachine(const char *triple,\n     }\n \n     TargetOptions Options;\n+#if LLVM_VERSION_MINOR <= 8\n     Options.PositionIndependentExecutable = PositionIndependentExecutable;\n+#endif\n+\n     Options.FloatABIType = FloatABI::Default;\n     if (UseSoftFloat) {\n         Options.FloatABIType = FloatABI::Soft;\n@@ -267,7 +293,7 @@ LLVMRustAddLibraryInfo(LLVMPassManagerRef PMB,\n // similar code in clang's BackendUtil.cpp file.\n extern \"C\" void\n LLVMRustRunFunctionPassManager(LLVMPassManagerRef PM, LLVMModuleRef M) {\n-    FunctionPassManager *P = unwrap<FunctionPassManager>(PM);\n+    llvm::legacy::FunctionPassManager *P = unwrap<llvm::legacy::FunctionPassManager>(PM);\n     P->doInitialization();\n     for (Module::iterator I = unwrap(M)->begin(),\n          E = unwrap(M)->end(); I != E; ++I)\n@@ -294,7 +320,7 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n                         LLVMModuleRef M,\n                         const char *path,\n                         TargetMachine::CodeGenFileType FileType) {\n-  PassManager *PM = unwrap<PassManager>(PMR);\n+  llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n \n   std::string ErrorInfo;\n   std::error_code EC;\n@@ -320,7 +346,7 @@ extern \"C\" void\n LLVMRustPrintModule(LLVMPassManagerRef PMR,\n                     LLVMModuleRef M,\n                     const char* path) {\n-  PassManager *PM = unwrap<PassManager>(PMR);\n+  llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n   std::string ErrorInfo;\n \n   std::error_code EC;\n@@ -358,9 +384,24 @@ LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB, bool AddLifetimes) {\n \n extern \"C\" void\n LLVMRustRunRestrictionPass(LLVMModuleRef M, char **symbols, size_t len) {\n-    PassManager passes;\n+    llvm::legacy::PassManager passes;\n+\n+#if LLVM_VERSION_MINOR <= 8\n     ArrayRef<const char*> ref(symbols, len);\n     passes.add(llvm::createInternalizePass(ref));\n+#else\n+    auto PreserveFunctions = [=](const GlobalValue &GV) {\n+        for (size_t i=0; i<len; i++) {\n+            if (GV.getName() == symbols[i]) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    };\n+\n+    passes.add(llvm::createInternalizePass(PreserveFunctions));\n+#endif\n+\n     passes.run(*unwrap(M));\n }\n \n@@ -396,3 +437,10 @@ extern \"C\" LLVMTargetDataRef\n LLVMRustGetModuleDataLayout(LLVMModuleRef M) {\n     return wrap(&unwrap(M)->getDataLayout());\n }\n+\n+extern \"C\" void\n+LLVMRustSetModulePIELevel(LLVMModuleRef M) {\n+#if LLVM_VERSION_MINOR >= 9\n+    unwrap(M)->setPIELevel(PIELevel::Level::Large);\n+#endif\n+}"}, {"sha": "bc38245d3512761061e367820c2d4cc692b63af2", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -99,7 +99,7 @@ extern \"C\" LLVMTypeRef LLVMMetadataTypeInContext(LLVMContextRef C) {\n   return wrap(Type::getMetadataTy(*unwrap(C)));\n }\n \n-extern \"C\" void LLVMAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, uint64_t Val) {\n+extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, uint64_t Val) {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   AttrBuilder B;\n   B.addRawValue(Val);\n@@ -203,7 +203,7 @@ extern \"C\" LLVMValueRef LLVMBuildAtomicStore(LLVMBuilderRef B,\n     return wrap(unwrap(B)->Insert(si));\n }\n \n-extern \"C\" LLVMValueRef LLVMBuildAtomicCmpXchg(LLVMBuilderRef B,\n+extern \"C\" LLVMValueRef LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B,\n                                                LLVMValueRef target,\n                                                LLVMValueRef old,\n                                                LLVMValueRef source,"}, {"sha": "e871763a48dc3fafb34f81ee2d10ad2c6cb4402c", "filename": "src/rustllvm/llvm-auto-clean-trigger", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Frustllvm%2Fllvm-auto-clean-trigger", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Frustllvm%2Fllvm-auto-clean-trigger", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Fllvm-auto-clean-trigger?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -1,4 +1,4 @@\n # If this file is modified, then llvm will be forcibly cleaned and then rebuilt.\n # The actual contents of this file do not matter, but to trigger a change on the\n # build bots then the contents should be changed so git updates the mtime.\n-2016-06-23\n+2016-07-25b"}, {"sha": "4c818cd99e2d795561535831d6653e323c54f113", "filename": "src/test/run-make/execution-engine/Makefile", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2FMakefile?ref=5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "patch": "@@ -1,21 +0,0 @@\n--include ../tools.mk\n-\n-# FIXME: ignore freebsd\n-# This is a basic test of LLVM ExecutionEngine functionality using compiled\n-# Rust code built using the `rustc` crate.\n-\n-ifeq ($(filter executionengine,$(LLVM_COMPONENTS)),executionengine)\n-\n-ifneq ($(shell uname),FreeBSD)\n-all:\n-\t$(RUSTC) test.rs\n-\t$(call RUN,test $(RUSTC))\n-else\n-all:\n-\n-endif\n-\n-else\n-all:\n-\n-endif"}, {"sha": "b58295d47f21d2633160a79b350e378db8b43d09", "filename": "src/test/run-make/execution-engine/test.rs", "status": "removed", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/rust-lang/rust/blob/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fexecution-engine%2Ftest.rs?ref=5ef1e7e0efe7129edbf06a699abaa6563e8cfc9e", "patch": "@@ -1,282 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(rustc_private)]\n-#![feature(libc)]\n-\n-extern crate libc;\n-extern crate rustc;\n-extern crate rustc_driver;\n-extern crate rustc_lint;\n-extern crate rustc_llvm as llvm;\n-extern crate rustc_metadata;\n-extern crate rustc_resolve;\n-extern crate rustc_errors;\n-extern crate rustc_errors as errors;\n-extern crate rustc_trans;\n-#[macro_use] extern crate syntax;\n-\n-use std::ffi::{CStr, CString};\n-use std::mem::transmute;\n-use std::path::PathBuf;\n-use std::rc::Rc;\n-use std::thread::Builder;\n-\n-use rustc::dep_graph::DepGraph;\n-use rustc::hir::map as ast_map;\n-use rustc::middle::cstore::LinkagePreference;\n-use rustc::ty;\n-use rustc::session::config::{self, basic_options, build_configuration, Input, Options};\n-use rustc::session::build_session;\n-use rustc_driver::{driver, abort_on_err};\n-use rustc_resolve::MakeGlobMap;\n-use rustc_metadata::cstore::CStore;\n-use rustc_trans::ModuleSource;\n-use libc::c_void;\n-\n-use rustc_errors::registry::Registry;\n-\n-fn main() {\n-    // Currently trips an assertion on i686-msvc, presumably because the support\n-    // in LLVM is a little young.\n-    if cfg!(target_env = \"msvc\") && cfg!(target_arch = \"x86\") {\n-        return\n-    }\n-\n-    let program = r#\"\n-    #[no_mangle]\n-    pub static TEST_STATIC: i32 = 42;\n-    \"#;\n-\n-    let program2 = r#\"\n-    #[no_mangle]\n-    pub fn test_add(a: i32, b: i32) -> i32 { a + b }\n-    \"#;\n-\n-    let mut path = match std::env::args().nth(2) {\n-        Some(path) => PathBuf::from(&path),\n-        None => panic!(\"missing rustc path\")\n-    };\n-\n-    // Remove two segments from rustc path to get sysroot.\n-    path.pop();\n-    path.pop();\n-\n-    let mut ee = ExecutionEngine::new(program, path);\n-\n-    let test_static = match ee.get_global(\"TEST_STATIC\") {\n-        Some(g) => g as *const i32,\n-        None => panic!(\"failed to get global\")\n-    };\n-\n-    assert_eq!(unsafe { *test_static }, 42);\n-\n-    ee.add_module(program2);\n-\n-    let test_add: fn(i32, i32) -> i32;\n-\n-    test_add = match ee.get_function(\"test_add\") {\n-        Some(f) => unsafe { transmute(f) },\n-        None => panic!(\"failed to get function\")\n-    };\n-\n-    assert_eq!(test_add(1, 2), 3);\n-}\n-\n-struct ExecutionEngine {\n-    ee: llvm::ExecutionEngineRef,\n-    modules: Vec<llvm::ModuleRef>,\n-    sysroot: PathBuf,\n-}\n-\n-impl ExecutionEngine {\n-    pub fn new(program: &str, sysroot: PathBuf) -> ExecutionEngine {\n-        let (llmod, deps) = compile_program(program, sysroot.clone())\n-            .expect(\"failed to compile program\");\n-\n-        let ee = unsafe { llvm::LLVMBuildExecutionEngine(llmod) };\n-\n-        if ee.is_null() {\n-            panic!(\"Failed to create ExecutionEngine: {}\", llvm_error());\n-        }\n-\n-        let ee = ExecutionEngine{\n-            ee: ee,\n-            modules: vec![llmod],\n-            sysroot: sysroot,\n-        };\n-\n-        ee.load_deps(&deps);\n-        ee\n-    }\n-\n-    pub fn add_module(&mut self, program: &str) {\n-        let (llmod, deps) = compile_program(program, self.sysroot.clone())\n-            .expect(\"failed to compile program in add_module\");\n-\n-        unsafe { llvm::LLVMExecutionEngineAddModule(self.ee, llmod); }\n-\n-        self.modules.push(llmod);\n-        self.load_deps(&deps);\n-    }\n-\n-    /// Returns a raw pointer to the named function.\n-    pub fn get_function(&mut self, name: &str) -> Option<*const c_void> {\n-        let s = CString::new(name.as_bytes()).unwrap();\n-\n-        for &m in &self.modules {\n-            let fv = unsafe { llvm::LLVMGetNamedFunction(m, s.as_ptr()) };\n-\n-            if !fv.is_null() {\n-                let fp = unsafe { llvm::LLVMGetPointerToGlobal(self.ee, fv) };\n-\n-                assert!(!fp.is_null());\n-                return Some(fp);\n-            }\n-        }\n-        None\n-    }\n-\n-    /// Returns a raw pointer to the named global item.\n-    pub fn get_global(&mut self, name: &str) -> Option<*const c_void> {\n-        let s = CString::new(name.as_bytes()).unwrap();\n-\n-        for &m in &self.modules {\n-            let gv = unsafe { llvm::LLVMGetNamedGlobal(m, s.as_ptr()) };\n-\n-            if !gv.is_null() {\n-                let gp = unsafe { llvm::LLVMGetPointerToGlobal(self.ee, gv) };\n-\n-                assert!(!gp.is_null());\n-                return Some(gp);\n-            }\n-        }\n-        None\n-    }\n-\n-    /// Loads all dependencies of compiled code.\n-    /// Expects a series of paths to dynamic library files.\n-    fn load_deps(&self, deps: &[PathBuf]) {\n-        for path in deps {\n-            let s = match path.as_os_str().to_str() {\n-                Some(s) => s,\n-                None => panic!(\n-                    \"Could not convert crate path to UTF-8 string: {:?}\", path)\n-            };\n-            let cs = CString::new(s).unwrap();\n-\n-            let res = unsafe { llvm::LLVMRustLoadDynamicLibrary(cs.as_ptr()) };\n-\n-            if res == 0 {\n-                panic!(\"Failed to load crate {:?}: {}\",\n-                    path.display(), llvm_error());\n-            }\n-        }\n-    }\n-}\n-\n-impl Drop for ExecutionEngine {\n-    fn drop(&mut self) {\n-        unsafe { llvm::LLVMDisposeExecutionEngine(self.ee) };\n-    }\n-}\n-\n-/// Returns last error from LLVM wrapper code.\n-fn llvm_error() -> String {\n-    String::from_utf8_lossy(\n-        unsafe { CStr::from_ptr(llvm::LLVMRustGetLastError()).to_bytes() })\n-        .into_owned()\n-}\n-\n-fn build_exec_options(sysroot: PathBuf) -> Options {\n-    let mut opts = basic_options();\n-\n-    // librustc derives sysroot from the executable name.\n-    // Since we are not rustc, we must specify it.\n-    opts.maybe_sysroot = Some(sysroot);\n-\n-    // Prefer faster build time\n-    opts.optimize = config::OptLevel::No;\n-\n-    // Don't require a `main` function\n-    opts.crate_types = vec![config::CrateTypeDylib];\n-\n-    opts\n-}\n-\n-/// Compiles input up to phase 4, translation to LLVM.\n-///\n-/// Returns the LLVM `ModuleRef` and a series of paths to dynamic libraries\n-/// for crates used in the given input.\n-fn compile_program(input: &str, sysroot: PathBuf)\n-                   -> Option<(llvm::ModuleRef, Vec<PathBuf>)> {\n-    let input = Input::Str {\n-        name: driver::anon_src(),\n-        input: input.to_string(),\n-    };\n-    let thread = Builder::new().name(\"compile_program\".to_string());\n-\n-    let handle = thread.spawn(move || {\n-        let opts = build_exec_options(sysroot);\n-        let dep_graph = DepGraph::new(opts.build_dep_graph());\n-        let cstore = Rc::new(CStore::new(&dep_graph));\n-        let sess = build_session(opts,\n-                                 &dep_graph,\n-                                 None,\n-                                 Registry::new(&rustc::DIAGNOSTICS),\n-                                 cstore.clone());\n-        rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n-\n-        let cfg = build_configuration(&sess);\n-\n-        let id = \"input\".to_string();\n-\n-        let krate = panictry!(driver::phase_1_parse_input(&sess, cfg, &input));\n-\n-        let driver::ExpansionResult { defs, analysis, resolutions, mut hir_forest, .. } = {\n-            driver::phase_2_configure_and_expand(\n-                &sess, &cstore, krate, &id, None, MakeGlobMap::No, |_| Ok(()),\n-            ).expect(\"phase_2 returned `None`\")\n-        };\n-\n-        let arenas = ty::CtxtArenas::new();\n-        let ast_map = ast_map::map_crate(&mut hir_forest, defs);\n-\n-        abort_on_err(driver::phase_3_run_analysis_passes(\n-            &sess, ast_map, analysis, resolutions, &arenas, &id,\n-            |tcx, mir_map, analysis, _| {\n-\n-            let trans = driver::phase_4_translate_to_llvm(tcx, mir_map.unwrap(), analysis);\n-\n-            let crates = tcx.sess.cstore.used_crates(LinkagePreference::RequireDynamic);\n-\n-            // Collect crates used in the session.\n-            // Reverse order finds dependencies first.\n-            let deps = crates.into_iter().rev()\n-                .filter_map(|(_, p)| p).collect();\n-\n-            assert_eq!(trans.modules.len(), 1);\n-            let llmod = match trans.modules[0].source {\n-                ModuleSource::Preexisting(_) => unimplemented!(),\n-                ModuleSource::Translated(llvm) => llvm.llmod,\n-            };\n-\n-            // Workaround because raw pointers do not impl Send\n-            let modp = llmod as usize;\n-\n-            (modp, deps)\n-        }), &sess)\n-    }).unwrap();\n-\n-    match handle.join() {\n-        Ok((llmod, deps)) => Some((llmod as llvm::ModuleRef, deps)),\n-        Err(_) => None\n-    }\n-}"}, {"sha": "f1ce17c0736b687cecb72b6761ff08d89ef7b2bb", "filename": "src/test/run-pass/backtrace.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c1612c62aa59e40cf1a4bddde943938e0147eec/src%2Ftest%2Frun-pass%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbacktrace.rs?ref=2c1612c62aa59e40cf1a4bddde943938e0147eec", "patch": "@@ -46,19 +46,7 @@ fn template(me: &str) -> Command {\n }\n \n fn expected(fn_name: &str) -> String {\n-    // FIXME(#32481)\n-    //\n-    // On windows, we read the function name from debuginfo using some\n-    // system APIs. For whatever reason, these APIs seem to use the\n-    // \"name\" field, which is only the \"relative\" name, not the full\n-    // name with namespace info, so we just see `foo` and not\n-    // `backtrace::foo` as we see on linux (which uses the linkage\n-    // name).\n-    if cfg!(windows) && cfg!(target_env = \"msvc\") {\n-        format!(\" - {}\", fn_name)\n-    } else {\n-        format!(\" - backtrace::{}\", fn_name)\n-    }\n+    format!(\" - backtrace::{}\", fn_name)\n }\n \n fn runtest(me: &str) {"}]}