{"sha": "aac64c47565bab9d87afd1bfa5459e8f485cdbea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhYzY0YzQ3NTY1YmFiOWQ4N2FmZDFiZmE1NDU5ZThmNDg1Y2RiZWE=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-10-03T12:00:38Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-10-03T12:02:25Z"}, "message": "Overlapping borrows can point to different lvalues.\n\nThere's always a basis for the overlap, so instead of removing the\nassert entirely, I instead pass in the prefix that we found and check\nthat it actually is a prefix of both lvalues.\n\nFix #44829", "tree": {"sha": "33c4f2a2ca2979e967d121fc0d5bf5fc3cf6b97b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33c4f2a2ca2979e967d121fc0d5bf5fc3cf6b97b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aac64c47565bab9d87afd1bfa5459e8f485cdbea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aac64c47565bab9d87afd1bfa5459e8f485cdbea", "html_url": "https://github.com/rust-lang/rust/commit/aac64c47565bab9d87afd1bfa5459e8f485cdbea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aac64c47565bab9d87afd1bfa5459e8f485cdbea/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61bad301f136fb6f4cb543014ed02034007e4bd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/61bad301f136fb6f4cb543014ed02034007e4bd2", "html_url": "https://github.com/rust-lang/rust/commit/61bad301f136fb6f4cb543014ed02034007e4bd2"}], "stats": {"total": 48, "additions": 38, "deletions": 10}, "files": [{"sha": "611bc01a0c480b72946fd3fde3f01b6f7f7d957d", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 38, "deletions": 10, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/aac64c47565bab9d87afd1bfa5459e8f485cdbea/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aac64c47565bab9d87afd1bfa5459e8f485cdbea/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=aac64c47565bab9d87afd1bfa5459e8f485cdbea", "patch": "@@ -385,7 +385,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         // borrow of immutable ref, moves through non-`Box`-ref)\n         let (sd, rw) = kind;\n         self.each_borrow_involving_path(\n-            context, (sd, lvalue_span.0), flow_state, |this, _index, borrow| {\n+            context, (sd, lvalue_span.0), flow_state, |this, _index, borrow, common_prefix| {\n                 match (rw, borrow.kind) {\n                     (Read(_), BorrowKind::Shared) => {\n                         Control::Continue\n@@ -399,6 +399,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                             ReadKind::Borrow(bk) =>\n                                 this.report_conflicting_borrow(\n                                     context, lvalue_span,\n+                                    common_prefix,\n                                     (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n                         }\n                         Control::Break\n@@ -408,6 +409,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                             WriteKind::MutableBorrow(bk) =>\n                                 this.report_conflicting_borrow(\n                                     context, lvalue_span,\n+                                    common_prefix,\n                                     (lvalue_span.0, bk), (&borrow.lvalue, borrow.kind)),\n                             WriteKind::StorageDead |\n                             WriteKind::Mutate =>\n@@ -704,7 +706,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                      access_lvalue: (ShallowOrDeep, &Lvalue<'gcx>),\n                                      flow_state: &InProgress<'b, 'gcx>,\n                                      mut op: F)\n-        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>) -> Control\n+        where F: FnMut(&mut Self, BorrowIndex, &BorrowData<'gcx>, &Lvalue) -> Control\n     {\n         let (access, lvalue) = access_lvalue;\n \n@@ -726,9 +728,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             // to #38899. Will probably need back-compat mode flag.\n             for accessed_prefix in self.prefixes(lvalue, PrefixSet::All) {\n                 if *accessed_prefix == borrowed.lvalue {\n-                    // FIXME: pass in prefix here too? And/or enum\n-                    // describing case we are in?\n-                    let ctrl = op(self, i, borrowed);\n+                    // FIXME: pass in enum describing case we are in?\n+                    let ctrl = op(self, i, borrowed, accessed_prefix);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n@@ -753,9 +754,8 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n \n             for borrowed_prefix in self.prefixes(&borrowed.lvalue, prefix_kind) {\n                 if borrowed_prefix == lvalue {\n-                    // FIXME: pass in prefix here too? And/or enum\n-                    // describing case we are in?\n-                    let ctrl = op(self, i, borrowed);\n+                    // FIXME: pass in enum describing case we are in?\n+                    let ctrl = op(self, i, borrowed, borrowed_prefix);\n                     if ctrl == Control::Break { return; }\n                 }\n             }\n@@ -780,6 +780,30 @@ mod prefixes {\n     use rustc::ty::{self, TyCtxt};\n     use rustc::mir::{Lvalue, Mir, ProjectionElem};\n \n+    pub trait IsPrefixOf<'tcx> {\n+        fn is_prefix_of(&self, other: &Lvalue<'tcx>) -> bool;\n+    }\n+\n+    impl<'tcx> IsPrefixOf<'tcx> for Lvalue<'tcx> {\n+        fn is_prefix_of(&self, other: &Lvalue<'tcx>) -> bool {\n+            let mut cursor = other;\n+            loop {\n+                if self == cursor {\n+                    return true;\n+                }\n+\n+                match *cursor {\n+                    Lvalue::Local(_) |\n+                    Lvalue::Static(_) => return false,\n+                    Lvalue::Projection(ref proj) => {\n+                        cursor = &proj.base;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+\n     pub(super) struct Prefixes<'c, 'tcx: 'c> {\n         mir: &'c Mir<'tcx>,\n         tcx: TyCtxt<'c, 'tcx, 'tcx>,\n@@ -946,12 +970,16 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     fn report_conflicting_borrow(&mut self,\n                                  _context: Context,\n                                  (lvalue, span): (&Lvalue, Span),\n+                                 common_prefix: &Lvalue,\n                                  loan1: (&Lvalue, BorrowKind),\n                                  loan2: (&Lvalue, BorrowKind)) {\n+        use self::prefixes::IsPrefixOf;\n+\n         let (loan1_lvalue, loan1_kind) = loan1;\n         let (loan2_lvalue, loan2_kind) = loan2;\n-        // FIXME: obviously falsifiable. Generalize for non-eq lvalues later.\n-        assert_eq!(loan1_lvalue, loan2_lvalue);\n+\n+        assert!(common_prefix.is_prefix_of(loan1_lvalue));\n+        assert!(common_prefix.is_prefix_of(loan2_lvalue));\n \n         // FIXME: supply non-\"\" `opt_via` when appropriate\n         let mut err = match (loan1_kind, \"immutable\", \"mutable\","}]}