{"sha": "86e548747b33023c750c2201e55b065a3f3d275c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg2ZTU0ODc0N2IzMzAyM2M3NTBjMjIwMWU1NWIwNjVhM2YzZDI3NWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-13T04:00:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-10-13T04:00:55Z"}, "message": "Auto merge of #45025 - pnkfelix:mir-borrowck-moves-of-supporting-prefixes-invalidate-uses-too, r=arielb1\n\nMIR-borrowck: moves of prefixes invalidate uses too\n\nI overlooked the fact that when we check if a path is moved, we need to check for interference between the (shallow) prefixes and the use in question.\n\n~~Long term, we may want to revise how this computation is done. For example, it might be better to represent the set of invalidated prefixes in the dataflow computation (the `maybe_uninitialized` dataflow), and thus avoid one of the loops in the code here.~~\n * Update: I was wrong in my original recollection of the dataflow code, which actually does the right thing, in terms of precisely tracking substructure initialization and movement.\n\nFix #44833\n\n----\n\nUpdate: The initial version of this PR's description (and the code as well) erroneously focused on supporting prefixes. ~~But the two main cases of interest are: 1. the *shallow* prefixes, and 2. the deref-free prefix built off a local (if the lvalue is indeed built off a local)~~\n\nUpdate 2: The main cases of interest are in fact: 1. the nearest prefix with a MovePath, and 2. the suffixes.", "tree": {"sha": "032449fd50ab8f856b605b6ccbd7bb9987592829", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/032449fd50ab8f856b605b6ccbd7bb9987592829"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/86e548747b33023c750c2201e55b065a3f3d275c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/86e548747b33023c750c2201e55b065a3f3d275c", "html_url": "https://github.com/rust-lang/rust/commit/86e548747b33023c750c2201e55b065a3f3d275c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/86e548747b33023c750c2201e55b065a3f3d275c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91eb6fe56d6df4a66f11bd3e79f08f74aacbd164", "url": "https://api.github.com/repos/rust-lang/rust/commits/91eb6fe56d6df4a66f11bd3e79f08f74aacbd164", "html_url": "https://github.com/rust-lang/rust/commit/91eb6fe56d6df4a66f11bd3e79f08f74aacbd164"}, {"sha": "d6caf737b30f94f4e734f59cde88e7d5295dc4a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6caf737b30f94f4e734f59cde88e7d5295dc4a1", "html_url": "https://github.com/rust-lang/rust/commit/d6caf737b30f94f4e734f59cde88e7d5295dc4a1"}], "stats": {"total": 293, "additions": 276, "deletions": 17}, "files": [{"sha": "ff923ce259fb45c904a3d94059657bff8f514feb", "filename": "src/librustc_mir/borrow_check.rs", "status": "modified", "additions": 139, "deletions": 12, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/86e548747b33023c750c2201e55b065a3f3d275c/src%2Flibrustc_mir%2Fborrow_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e548747b33023c750c2201e55b065a3f3d275c/src%2Flibrustc_mir%2Fborrow_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check.rs?ref=86e548747b33023c750c2201e55b065a3f3d275c", "patch": "@@ -586,7 +586,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n                                                 context: Context,\n                                                 (lvalue, span): (&Lvalue<'gcx>, Span),\n                                                 flow_state: &InProgress<'b, 'gcx>) {\n-        let move_data = flow_state.inits.base_results.operator().move_data();\n+        let move_data = self.move_data;\n \n         // determine if this path has a non-mut owner (and thus needs checking).\n         let mut l = lvalue;\n@@ -611,7 +611,7 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n             }\n         }\n \n-        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n+        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n             if flow_state.inits.curr_state.contains(&mpi) {\n                 // may already be assigned before reaching this statement;\n                 // report error.\n@@ -642,29 +642,115 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n         let lvalue = self.base_path(lvalue_span.0);\n \n         let maybe_uninits = &flow_state.uninits;\n-        let move_data = maybe_uninits.base_results.operator().move_data();\n-        if let Some(mpi) = self.move_path_for_lvalue(context, move_data, lvalue) {\n-            if maybe_uninits.curr_state.contains(&mpi) {\n-                // find and report move(s) that could cause this to be uninitialized\n+\n+        // Bad scenarios:\n+        //\n+        // 1. Move of `a.b.c`, use of `a.b.c`\n+        // 2. Move of `a.b.c`, use of `a.b.c.d` (without first reinitializing `a.b.c.d`)\n+        // 3. Move of `a.b.c`, use of `a` or `a.b`\n+        // 4. Uninitialized `(a.b.c: &_)`, use of `*a.b.c`; note that with\n+        //    partial initialization support, one might have `a.x`\n+        //    initialized but not `a.b`.\n+        //\n+        // OK scenarios:\n+        //\n+        // 5. Move of `a.b.c`, use of `a.b.d`\n+        // 6. Uninitialized `a.x`, initialized `a.b`, use of `a.b`\n+        // 7. Copied `(a.b: &_)`, use of `*(a.b).c`; note that `a.b`\n+        //    must have been initialized for the use to be sound.\n+        // 8. Move of `a.b.c` then reinit of `a.b.c.d`, use of `a.b.c.d`\n+\n+        // The dataflow tracks shallow prefixes distinctly (that is,\n+        // field-accesses on P distinctly from P itself), in order to\n+        // track substructure initialization separately from the whole\n+        // structure.\n+        //\n+        // E.g., when looking at (*a.b.c).d, if the closest prefix for\n+        // which we have a MovePath is `a.b`, then that means that the\n+        // initialization state of `a.b` is all we need to inspect to\n+        // know if `a.b.c` is valid (and from that we infer that the\n+        // dereference and `.d` access is also valid, since we assume\n+        // `a.b.c` is assigned a reference to a initialized and\n+        // well-formed record structure.)\n+\n+        // Therefore, if we seek out the *closest* prefix for which we\n+        // have a MovePath, that should capture the initialization\n+        // state for the lvalue scenario.\n+        //\n+        // This code covers scenarios 1, 2, and 4.\n+\n+        debug!(\"check_if_path_is_moved part1 lvalue: {:?}\", lvalue);\n+        match self.move_path_closest_to(lvalue) {\n+            Ok(mpi) => {\n+                if maybe_uninits.curr_state.contains(&mpi) {\n+                    self.report_use_of_moved(context, desired_action, lvalue_span);\n+                    return; // don't bother finding other problems.\n+                }\n+            }\n+            Err(NoMovePathFound::ReachedStatic) => {\n+                // Okay: we do not build MoveData for static variables\n+            }\n+\n+            // Only query longest prefix with a MovePath, not further\n+            // ancestors; dataflow recurs on children when parents\n+            // move (to support partial (re)inits).\n+            //\n+            // (I.e. querying parents breaks scenario 8; but may want\n+            // to do such a query based on partial-init feature-gate.)\n+        }\n+\n+        // A move of any shallow suffix of `lvalue` also interferes\n+        // with an attempt to use `lvalue`. This is scenario 3 above.\n+        //\n+        // (Distinct from handling of scenarios 1+2+4 above because\n+        // `lvalue` does not interfere with suffixes of its prefixes,\n+        // e.g. `a.b.c` does not interfere with `a.b.d`)\n+\n+        debug!(\"check_if_path_is_moved part2 lvalue: {:?}\", lvalue);\n+        if let Some(mpi) = self.move_path_for_lvalue(lvalue) {\n+            if let Some(_) = maybe_uninits.has_any_child_of(mpi) {\n                 self.report_use_of_moved(context, desired_action, lvalue_span);\n-            } else {\n-                // sanity check: initialized on *some* path, right?\n-                assert!(flow_state.inits.curr_state.contains(&mpi));\n+                return; // don't bother finding other problems.\n             }\n         }\n     }\n \n+    /// Currently MoveData does not store entries for all lvalues in\n+    /// the input MIR. For example it will currently filter out\n+    /// lvalues that are Copy; thus we do not track lvalues of shared\n+    /// reference type. This routine will walk up an lvalue along its\n+    /// prefixes, searching for a foundational lvalue that *is*\n+    /// tracked in the MoveData.\n+    ///\n+    /// An Err result includes a tag indicated why the search failed.\n+    /// Currenly this can only occur if the lvalue is built off of a\n+    /// static variable, as we do not track those in the MoveData.\n+    fn move_path_closest_to(&mut self, lvalue: &Lvalue<'gcx>)\n+                            -> Result<MovePathIndex, NoMovePathFound>\n+    {\n+        let mut last_prefix = lvalue;\n+        for prefix in self.prefixes(lvalue, PrefixSet::All) {\n+            if let Some(mpi) = self.move_path_for_lvalue(prefix) {\n+                return Ok(mpi);\n+            }\n+            last_prefix = prefix;\n+        }\n+        match *last_prefix {\n+            Lvalue::Local(_) => panic!(\"should have move path for every Local\"),\n+            Lvalue::Projection(_) => panic!(\"PrefixSet::All meant dont stop for Projection\"),\n+            Lvalue::Static(_) => return Err(NoMovePathFound::ReachedStatic),\n+        }\n+    }\n+\n     fn move_path_for_lvalue(&mut self,\n-                            _context: Context,\n-                            move_data: &MoveData<'gcx>,\n                             lvalue: &Lvalue<'gcx>)\n                             -> Option<MovePathIndex>\n     {\n         // If returns None, then there is no move path corresponding\n         // to a direct owner of `lvalue` (which means there is nothing\n         // that borrowck tracks for its analysis).\n \n-        match move_data.rev_lookup.find(lvalue) {\n+        match self.move_data.rev_lookup.find(lvalue) {\n             LookupResult::Parent(_) => None,\n             LookupResult::Exact(mpi) => Some(mpi),\n         }\n@@ -733,6 +819,11 @@ impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx>\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum NoMovePathFound {\n+    ReachedStatic,\n+}\n+\n impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n     fn each_borrow_involving_path<F>(&mut self,\n                                      _context: Context,\n@@ -846,12 +937,19 @@ mod prefixes {\n \n     #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n     pub(super) enum PrefixSet {\n+        /// Doesn't stop until it returns the base case (a Local or\n+        /// Static prefix).\n         All,\n+        /// Stops at any dereference.\n         Shallow,\n+        /// Stops at the deref of a shared reference.\n         Supporting,\n     }\n \n     impl<'c, 'b, 'a: 'b+'c, 'gcx, 'tcx: 'a> MirBorrowckCtxt<'c, 'b, 'a, 'gcx, 'tcx> {\n+        /// Returns an iterator over the prefixes of `lvalue`\n+        /// (inclusive) from longest to smallest, potentially\n+        /// terminating the iteration early based on `kind`.\n         pub(super) fn prefixes<'d>(&self,\n                                    lvalue: &'d Lvalue<'gcx>,\n                                    kind: PrefixSet)\n@@ -1340,6 +1438,35 @@ impl<'b, 'tcx: 'b> InProgress<'b, 'tcx> {\n     }\n }\n \n+impl<'b, 'tcx> FlowInProgress<MaybeUninitializedLvals<'b, 'tcx>> {\n+    fn has_any_child_of(&self, mpi: MovePathIndex) -> Option<MovePathIndex> {\n+        let move_data = self.base_results.operator().move_data();\n+\n+        let mut todo = vec![mpi];\n+        let mut push_siblings = false; // don't look at siblings of original `mpi`.\n+        while let Some(mpi) = todo.pop() {\n+            if self.curr_state.contains(&mpi) {\n+                return Some(mpi);\n+            }\n+            let move_path = &move_data.move_paths[mpi];\n+            if let Some(child) = move_path.first_child {\n+                todo.push(child);\n+            }\n+            if push_siblings {\n+                if let Some(sibling) = move_path.next_sibling {\n+                    todo.push(sibling);\n+                }\n+            } else {\n+                // after we've processed the original `mpi`, we should\n+                // always traverse the siblings of any of its\n+                // children.\n+                push_siblings = true;\n+            }\n+        }\n+        return None;\n+    }\n+}\n+\n impl<BD> FlowInProgress<BD> where BD: BitDenotation {\n     fn each_state_bit<F>(&self, f: F) where F: FnMut(BD::Idx) {\n         self.curr_state.each_bit(self.base_results.operator().bits_per_block(), f)"}, {"sha": "017318b6b217300f75d66d24e7a42ea6cdc108dc", "filename": "src/test/compile-fail/borrowck/borrowck-init-in-fru.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-init-in-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-init-in-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-init-in-fru.rs?ref=86e548747b33023c750c2201e55b065a3f3d275c", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n #[derive(Clone)]\n struct point {\n     x: isize,\n@@ -16,6 +19,9 @@ struct point {\n \n fn main() {\n     let mut origin: point;\n-    origin = point {x: 10,.. origin}; //~ ERROR use of possibly uninitialized variable: `origin.y`\n+    origin = point {x: 10,.. origin};\n+    //[ast]~^ ERROR use of possibly uninitialized variable: `origin.y` [E0381]\n+    //[mir]~^^ ERROR (Ast) [E0381]\n+    //[mir]~|  ERROR (Mir) [E0381]\n     origin.clone();\n }"}, {"sha": "957086f6af13f5d394c82369033b53f89f294c3f", "filename": "src/test/compile-fail/borrowck/borrowck-uninit-field-access.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-field-access.rs?ref=86e548747b33023c750c2201e55b065a3f3d275c", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n+// Check that do not allow access to fields of uninitialized or moved\n+// structs.\n+\n+#[derive(Default)]\n+struct Point {\n+    x: isize,\n+    y: isize,\n+}\n+\n+#[derive(Default)]\n+struct Line {\n+    origin: Point,\n+    middle: Point,\n+    target: Point,\n+}\n+\n+impl Line { fn consume(self) { } }\n+\n+fn main() {\n+    let mut a: Point;\n+    let _ = a.x + 1; //[ast]~ ERROR use of possibly uninitialized variable: `a.x`\n+                     //[mir]~^ ERROR       [E0381]\n+                     //[mir]~| ERROR (Mir) [E0381]\n+\n+    let mut line1 = Line::default();\n+    let _moved = line1.origin;\n+    let _ = line1.origin.x + 1; //[ast]~ ERROR use of collaterally moved value: `line1.origin.x`\n+                                //[mir]~^       [E0382]\n+                                //[mir]~| (Mir) [E0381]\n+\n+    let mut line2 = Line::default();\n+    let _moved = (line2.origin, line2.middle);\n+    line2.consume(); //[ast]~ ERROR use of partially moved value: `line2` [E0382]\n+                     //[mir]~^       [E0382]\n+                     //[mir]~| (Mir) [E0381]\n+}"}, {"sha": "71f8693b2101f5388acf66a6370ab4baf0e17dfe", "filename": "src/test/compile-fail/borrowck/borrowck-uninit-ref-chain.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-ref-chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-ref-chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-uninit-ref-chain.rs?ref=86e548747b33023c750c2201e55b065a3f3d275c", "patch": "@@ -0,0 +1,60 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n+struct S<X, Y> {\n+    x: X,\n+    y: Y,\n+}\n+\n+fn main() {\n+    let x: &&Box<i32>;\n+    let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n+                   //[mir]~^ (Ast) [E0381]\n+                   //[mir]~| (Mir) [E0381]\n+\n+    let x: &&S<i32, i32>;\n+    let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n+                   //[mir]~^ (Ast) [E0381]\n+                   //[mir]~| (Mir) [E0381]\n+\n+    let x: &&i32;\n+    let _y = &**x; //[ast]~ ERROR use of possibly uninitialized variable: `**x` [E0381]\n+                   //[mir]~^ (Ast) [E0381]\n+                   //[mir]~| (Mir) [E0381]\n+\n+\n+    let mut a: S<i32, i32>;\n+    a.x = 0;\n+    let _b = &a.x; //[ast]~ ERROR use of possibly uninitialized variable: `a.x` [E0381]\n+                   //[mir]~^ ERROR (Ast) [E0381]\n+                   // (deliberately *not* an error under MIR-borrowck)\n+\n+    let mut a: S<&&i32, &&i32>;\n+    a.x = &&0;\n+    let _b = &**a.x; //[ast]~ ERROR use of possibly uninitialized variable: `**a.x` [E0381]\n+                     //[mir]~^ ERROR (Ast) [E0381]\n+                     // (deliberately *not* an error under MIR-borrowck)\n+\n+\n+    let mut a: S<i32, i32>;\n+    a.x = 0;\n+    let _b = &a.y; //[ast]~ ERROR use of possibly uninitialized variable: `a.y` [E0381]\n+                   //[mir]~^ ERROR (Ast) [E0381]\n+                   //[mir]~| ERROR (Mir) [E0381]\n+\n+    let mut a: S<&&i32, &&i32>;\n+    a.x = &&0;\n+    let _b = &**a.y; //[ast]~ ERROR use of possibly uninitialized variable: `**a.y` [E0381]\n+                     //[mir]~^ ERROR (Ast) [E0381]\n+                     //[mir]~| ERROR (Mir) [E0381]\n+}"}, {"sha": "2b567ebd2dba5582b6de0aa69eb76d30f39be0f2", "filename": "src/test/compile-fail/borrowck/borrowck-use-in-index-lvalue.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-in-index-lvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-in-index-lvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-in-index-lvalue.rs?ref=86e548747b33023c750c2201e55b065a3f3d275c", "patch": "@@ -8,12 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n fn test() {\n     let w: &mut [isize];\n-    w[5] = 0; //~ ERROR use of possibly uninitialized variable: `*w`\n+    w[5] = 0; //[ast]~ ERROR use of possibly uninitialized variable: `*w` [E0381]\n+              //[mir]~^ ERROR (Ast) [E0381]\n+              //[mir]~| ERROR (Mir) [E0381]\n \n     let mut w: &mut [isize];\n-    w[5] = 0; //~ ERROR use of possibly uninitialized variable: `*w`\n+    w[5] = 0; //[ast]~ ERROR use of possibly uninitialized variable: `*w` [E0381]\n+              //[mir]~^ ERROR (Ast) [E0381]\n+              //[mir]~| ERROR (Mir) [E0381]\n }\n \n fn main() { test(); }"}, {"sha": "a48d09b195a5e89827b5d70352d290b3eaeab5f4", "filename": "src/test/compile-fail/borrowck/borrowck-use-uninitialized-in-cast-trait.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast-trait.rs?ref=86e548747b33023c750c2201e55b065a3f3d275c", "patch": "@@ -8,6 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n // Variation on `borrowck-use-uninitialized-in-cast` in which we do a\n // trait cast from an uninitialized source. Issue #20791.\n \n@@ -16,5 +19,7 @@ impl Foo for i32 { }\n \n fn main() {\n     let x: &i32;\n-    let y = x as *const Foo; //~ ERROR use of possibly uninitialized variable: `*x`\n+    let y = x as *const Foo; //[ast]~ ERROR use of possibly uninitialized variable: `*x`\n+                             //[mir]~^ ERROR (Ast) [E0381]\n+                             //[mir]~| ERROR (Mir) [E0381]\n }"}, {"sha": "bdd90a3ce1ec2394dc7cbcdae50949d434b43c19", "filename": "src/test/compile-fail/borrowck/borrowck-use-uninitialized-in-cast.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/86e548747b33023c750c2201e55b065a3f3d275c/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-use-uninitialized-in-cast.rs?ref=86e548747b33023c750c2201e55b065a3f3d275c", "patch": "@@ -8,11 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// revisions: ast mir\n+//[mir]compile-flags: -Z emit-end-regions -Z borrowck-mir\n+\n // Check that we detect unused values that are cast to other things.\n // The problem was specified to casting to `*`, as creating unsafe\n // pointers was not being fully checked. Issue #20791.\n \n fn main() {\n     let x: &i32;\n-    let y = x as *const i32; //~ ERROR use of possibly uninitialized variable: `*x`\n+    let y = x as *const i32; //[ast]~ ERROR use of possibly uninitialized variable: `*x` [E0381]\n+                             //[mir]~^ ERROR (Ast) [E0381]\n+                             //[mir]~| ERROR (Mir) [E0381]\n }"}]}