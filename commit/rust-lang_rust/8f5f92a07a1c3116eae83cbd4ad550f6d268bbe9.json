{"sha": "8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNWY5MmEwN2ExYzMxMTZlYWU4M2NiZDRhZDU1MGY2ZDI2OGJiZTk=", "commit": {"author": {"name": "Tyler Mandry", "email": "tmandry@gmail.com", "date": "2019-10-02T06:06:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-02T06:06:16Z"}, "message": "Rollup merge of #64840 - michaelwoerister:self-profiling-raii-refactor, r=wesleywiser\n\nSelfProfiler API refactoring and part one of event review\n\nThis PR refactors the `SelfProfiler` a little bit so that most profiling methods are RAII-based. The codegen backend code already had something similar, this refactoring pulls this functionality up into `SelfProfiler` itself, for general use.\n\nThe second commit of this PR is a review and update of the existing events we are already recording. Names have been made more consistent. CGU names have been removed from event names. They will be added back in when function parameter recording is implemented.\n\nThere is still some work to be done for adding new events, especially around trait resolution and the incremental system.\n\nr? @wesleywiser", "tree": {"sha": "6fa5b251a66d0b679f7de1c6530113e960fa4b6b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6fa5b251a66d0b679f7de1c6530113e960fa4b6b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdlD5YCRBK7hj4Ov3rIwAAdHIIAA06scWNfovDJYzWYrwMU6qA\n4OpVMLfkSEBasqzjJ2qS6+++FM2UT1qrQvNFHZP2yRxw4/gfjRVctHXRO4bluxpy\n4T7eS9eB0kVbPgnQ1WtAcb18TLvMFnh8vDTCRyaK872ecYp9kcl4WEV0URJC5DWF\nRqLSPxl9YZWvcv/mJe7pTI31/OrU1Dynn1oHJlLz37Fq8eKdreyQJDXFpBJrDjbB\nViIk7TB/HTe4qjRVLHIgsSZpePm5IlOO+Br2hMVusUTDUverR4KlycLoko6XRjIM\nOMe3y1yncVcq8C+/f1n6OMX2XhpUaMRvIOrmkRD1ltJhVnBKaHRFUvBSoLyobEQ=\n=6jHX\n-----END PGP SIGNATURE-----\n", "payload": "tree 6fa5b251a66d0b679f7de1c6530113e960fa4b6b\nparent 0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a\nparent d94262272bbdc700689a012a2e8a34adbe2a0f18\nauthor Tyler Mandry <tmandry@gmail.com> 1569996376 -0700\ncommitter GitHub <noreply@github.com> 1569996376 -0700\n\nRollup merge of #64840 - michaelwoerister:self-profiling-raii-refactor, r=wesleywiser\n\nSelfProfiler API refactoring and part one of event review\n\nThis PR refactors the `SelfProfiler` a little bit so that most profiling methods are RAII-based. The codegen backend code already had something similar, this refactoring pulls this functionality up into `SelfProfiler` itself, for general use.\n\nThe second commit of this PR is a review and update of the existing events we are already recording. Names have been made more consistent. CGU names have been removed from event names. They will be added back in when function parameter recording is implemented.\n\nThere is still some work to be done for adding new events, especially around trait resolution and the incremental system.\n\nr? @wesleywiser\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "html_url": "https://github.com/rust-lang/rust/commit/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/comments", "author": {"login": "tmandry", "id": 2280544, "node_id": "MDQ6VXNlcjIyODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2280544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmandry", "html_url": "https://github.com/tmandry", "followers_url": "https://api.github.com/users/tmandry/followers", "following_url": "https://api.github.com/users/tmandry/following{/other_user}", "gists_url": "https://api.github.com/users/tmandry/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmandry/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmandry/subscriptions", "organizations_url": "https://api.github.com/users/tmandry/orgs", "repos_url": "https://api.github.com/users/tmandry/repos", "events_url": "https://api.github.com/users/tmandry/events{/privacy}", "received_events_url": "https://api.github.com/users/tmandry/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a", "html_url": "https://github.com/rust-lang/rust/commit/0e88e56a9a535bc0bf3b6c88f08a67ac33589c4a"}, {"sha": "d94262272bbdc700689a012a2e8a34adbe2a0f18", "url": "https://api.github.com/repos/rust-lang/rust/commits/d94262272bbdc700689a012a2e8a34adbe2a0f18", "html_url": "https://github.com/rust-lang/rust/commit/d94262272bbdc700689a012a2e8a34adbe2a0f18"}], "stats": {"total": 634, "additions": 366, "deletions": 268}, "files": [{"sha": "f22445f5d4744765c8f8c705d914edec6e929548", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -32,7 +32,7 @@ use syntax::source_map;\n use syntax::parse::{self, ParseSess};\n use syntax::symbol::Symbol;\n use syntax_pos::{MultiSpan, Span};\n-use crate::util::profiling::SelfProfiler;\n+use crate::util::profiling::{SelfProfiler, SelfProfilerRef};\n \n use rustc_target::spec::{PanicStrategy, RelroLevel, Target, TargetTriple};\n use rustc_data_structures::flock;\n@@ -129,7 +129,7 @@ pub struct Session {\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n     /// Used by `-Z self-profile`.\n-    pub self_profiling: Option<Arc<SelfProfiler>>,\n+    pub prof: SelfProfilerRef,\n \n     /// Some measurements that are being gathered during compilation.\n     pub perf_stats: PerfStats,\n@@ -835,24 +835,6 @@ impl Session {\n         }\n     }\n \n-    #[inline(never)]\n-    #[cold]\n-    fn profiler_active<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n-        match &self.self_profiling {\n-            None => bug!(\"profiler_active() called but there was no profiler active\"),\n-            Some(profiler) => {\n-                f(&profiler);\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub fn profiler<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n-        if unlikely!(self.self_profiling.is_some()) {\n-            self.profiler_active(f)\n-        }\n-    }\n-\n     pub fn print_perf_stats(&self) {\n         println!(\n             \"Total time spent computing symbol hashes:      {}\",\n@@ -1251,7 +1233,7 @@ fn build_session_(\n         imported_macro_spans: OneThread::new(RefCell::new(FxHashMap::default())),\n         incr_comp_session: OneThread::new(RefCell::new(IncrCompSession::NotInitialized)),\n         cgu_reuse_tracker,\n-        self_profiling: self_profiler,\n+        prof: SelfProfilerRef::new(self_profiler),\n         profile_channel: Lock::new(None),\n         perf_stats: PerfStats {\n             symbol_hash_time: Lock::new(Duration::from_secs(0)),"}, {"sha": "5f1a17e4a9521b32422a1e2c4db8f72d0c207d9a", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -45,6 +45,7 @@ use crate::ty::CanonicalPolyFnSig;\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n+use crate::util::profiling::SelfProfilerRef;\n \n use errors::DiagnosticBuilder;\n use arena::SyncDroplessArena;\n@@ -1030,6 +1031,8 @@ pub struct GlobalCtxt<'tcx> {\n \n     pub dep_graph: DepGraph,\n \n+    pub prof: SelfProfilerRef,\n+\n     /// Common objects.\n     pub common: Common<'tcx>,\n \n@@ -1260,6 +1263,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             arena: WorkerLocal::new(|_| Arena::default()),\n             interners,\n             dep_graph,\n+            prof: s.prof.clone(),\n             common,\n             types: common_types,\n             lifetimes: common_lifetimes,"}, {"sha": "955f1447c55b67c3d61aeec068a2860accd35b65", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -112,7 +112,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             let mut lock = cache.get_shard_by_value(key).lock();\n             if let Some(value) = lock.results.get(key) {\n                 profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                tcx.sess.profiler(|p| p.record_query_hit(Q::NAME));\n+                tcx.prof.query_cache_hit(Q::NAME);\n                 let result = (value.value.clone(), value.index);\n                 #[cfg(debug_assertions)]\n                 {\n@@ -128,7 +128,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                             // in another thread has completed. Record how long we wait in the\n                             // self-profiler.\n                             #[cfg(parallel_compiler)]\n-                            tcx.sess.profiler(|p| p.query_blocked_start(Q::NAME));\n+                            tcx.prof.query_blocked_start(Q::NAME);\n \n                             job.clone()\n                         },\n@@ -170,7 +170,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             #[cfg(parallel_compiler)]\n             {\n                 let result = job.r#await(tcx, span);\n-                tcx.sess.profiler(|p| p.query_blocked_end(Q::NAME));\n+                tcx.prof.query_blocked_end(Q::NAME);\n \n                 if let Err(cycle) = result {\n                     return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));\n@@ -382,8 +382,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n \n         if Q::ANON {\n+\n             profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n-            self.sess.profiler(|p| p.start_query(Q::NAME));\n+            let prof_timer = self.prof.query_provider(Q::NAME);\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n                 self.start_query(job.job.clone(), diagnostics, |tcx| {\n@@ -393,7 +394,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 })\n             });\n \n-            self.sess.profiler(|p| p.end_query(Q::NAME));\n+            drop(prof_timer);\n             profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n             self.dep_graph.read_index(dep_node_index);\n@@ -451,9 +452,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         // First we try to load the result from the on-disk cache.\n         let result = if Q::cache_on_disk(self, key.clone(), None) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n-            self.sess.profiler(|p| p.incremental_load_result_start(Q::NAME));\n+            let _prof_timer = self.prof.incr_cache_loading(Q::NAME);\n             let result = Q::try_load_from_disk(self, prev_dep_node_index);\n-            self.sess.profiler(|p| p.incremental_load_result_end(Q::NAME));\n \n             // We always expect to find a cached result for things that\n             // can be forced from `DepNode`.\n@@ -469,21 +469,17 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let result = if let Some(result) = result {\n             profq_msg!(self, ProfileQueriesMsg::CacheHit);\n-            self.sess.profiler(|p| p.record_query_hit(Q::NAME));\n-\n             result\n         } else {\n             // We could not load a result from the on-disk cache, so\n             // recompute.\n-\n-            self.sess.profiler(|p| p.start_query(Q::NAME));\n+            let _prof_timer = self.prof.query_provider(Q::NAME);\n \n             // The dep-graph for this computation is already in-place.\n             let result = self.dep_graph.with_ignore(|| {\n                 Q::compute(self, key)\n             });\n \n-            self.sess.profiler(|p| p.end_query(Q::NAME));\n             result\n         };\n \n@@ -551,7 +547,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 key, dep_node);\n \n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n-        self.sess.profiler(|p| p.start_query(Q::NAME));\n+        let prof_timer = self.prof.query_provider(Q::NAME);\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n             self.start_query(job.job.clone(), diagnostics, |tcx| {\n@@ -571,7 +567,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             })\n         });\n \n-        self.sess.profiler(|p| p.end_query(Q::NAME));\n+        drop(prof_timer);\n         profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n         if unlikely!(self.sess.opts.debugging_opts.query_dep_graph) {\n@@ -619,7 +615,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n         } else {\n             profq_msg!(self, ProfileQueriesMsg::CacheHit);\n-            self.sess.profiler(|p| p.record_query_hit(Q::NAME));\n+            self.prof.query_cache_hit(Q::NAME);\n         }\n     }\n "}, {"sha": "bd02e7f5a14a16507e6b8b9444b83037d9fcb486", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 237, "deletions": 89, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -1,9 +1,9 @@\n-use std::borrow::Cow;\n use std::error::Error;\n use std::fs;\n use std::mem::{self, Discriminant};\n use std::path::Path;\n use std::process;\n+use std::sync::Arc;\n use std::thread::ThreadId;\n use std::u32;\n \n@@ -62,6 +62,206 @@ fn thread_id_to_u64(tid: ThreadId) -> u64 {\n     unsafe { mem::transmute::<ThreadId, u64>(tid) }\n }\n \n+\n+/// A reference to the SelfProfiler. It can be cloned and sent across thread\n+/// boundaries at will.\n+#[derive(Clone)]\n+pub struct SelfProfilerRef {\n+    // This field is `None` if self-profiling is disabled for the current\n+    // compilation session.\n+    profiler: Option<Arc<SelfProfiler>>,\n+\n+    // We store the filter mask directly in the reference because that doesn't\n+    // cost anything and allows for filtering with checking if the profiler is\n+    // actually enabled.\n+    event_filter_mask: EventFilter,\n+}\n+\n+impl SelfProfilerRef {\n+\n+    pub fn new(profiler: Option<Arc<SelfProfiler>>) -> SelfProfilerRef {\n+        // If there is no SelfProfiler then the filter mask is set to NONE,\n+        // ensuring that nothing ever tries to actually access it.\n+        let event_filter_mask = profiler\n+            .as_ref()\n+            .map(|p| p.event_filter_mask)\n+            .unwrap_or(EventFilter::NONE);\n+\n+        SelfProfilerRef {\n+            profiler,\n+            event_filter_mask,\n+        }\n+    }\n+\n+    // This shim makes sure that calls only get executed if the filter mask\n+    // lets them pass. It also contains some trickery to make sure that\n+    // code is optimized for non-profiling compilation sessions, i.e. anything\n+    // past the filter check is never inlined so it doesn't clutter the fast\n+    // path.\n+    #[inline(always)]\n+    fn exec<F>(&self, event_filter: EventFilter, f: F) -> TimingGuard<'_>\n+        where F: for<'a> FnOnce(&'a SelfProfiler) -> TimingGuard<'a>\n+    {\n+        #[inline(never)]\n+        fn cold_call<F>(profiler_ref: &SelfProfilerRef, f: F) -> TimingGuard<'_>\n+            where F: for<'a> FnOnce(&'a SelfProfiler) -> TimingGuard<'a>\n+        {\n+            let profiler = profiler_ref.profiler.as_ref().unwrap();\n+            f(&**profiler)\n+        }\n+\n+        if unlikely!(self.event_filter_mask.contains(event_filter)) {\n+            cold_call(self, f)\n+        } else {\n+            TimingGuard::none()\n+        }\n+    }\n+\n+    /// Start profiling a generic activity. Profiling continues until the\n+    /// TimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn generic_activity(&self, event_id: &str) -> TimingGuard<'_> {\n+        self.exec(EventFilter::GENERIC_ACTIVITIES, |profiler| {\n+            let event_id = profiler.profiler.alloc_string(event_id);\n+            TimingGuard::start(\n+                profiler,\n+                profiler.generic_activity_event_kind,\n+                event_id\n+            )\n+        })\n+    }\n+\n+    /// Start profiling a generic activity. Profiling continues until\n+    /// `generic_activity_end` is called. The RAII-based `generic_activity`\n+    /// usually is the better alternative.\n+    #[inline(always)]\n+    pub fn generic_activity_start(&self, event_id: &str) {\n+        self.non_guard_generic_event(\n+            |profiler| profiler.generic_activity_event_kind,\n+            |profiler| profiler.profiler.alloc_string(event_id),\n+            EventFilter::GENERIC_ACTIVITIES,\n+            TimestampKind::Start,\n+        );\n+    }\n+\n+    /// End profiling a generic activity that was started with\n+    /// `generic_activity_start`. The RAII-based `generic_activity` usually is\n+    /// the better alternative.\n+    #[inline(always)]\n+    pub fn generic_activity_end(&self, event_id: &str) {\n+        self.non_guard_generic_event(\n+            |profiler| profiler.generic_activity_event_kind,\n+            |profiler| profiler.profiler.alloc_string(event_id),\n+            EventFilter::GENERIC_ACTIVITIES,\n+            TimestampKind::End,\n+        );\n+    }\n+\n+    /// Start profiling a query provider. Profiling continues until the\n+    /// TimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn query_provider(&self, query_name: QueryName) -> TimingGuard<'_> {\n+        self.exec(EventFilter::QUERY_PROVIDERS, |profiler| {\n+            let event_id = SelfProfiler::get_query_name_string_id(query_name);\n+            TimingGuard::start(profiler, profiler.query_event_kind, event_id)\n+        })\n+    }\n+\n+    /// Record a query in-memory cache hit.\n+    #[inline(always)]\n+    pub fn query_cache_hit(&self, query_name: QueryName) {\n+        self.non_guard_query_event(\n+            |profiler| profiler.query_cache_hit_event_kind,\n+            query_name,\n+            EventFilter::QUERY_CACHE_HITS,\n+            TimestampKind::Instant,\n+        );\n+    }\n+\n+    /// Start profiling a query being blocked on a concurrent execution.\n+    /// Profiling continues until `query_blocked_end` is called.\n+    #[inline(always)]\n+    pub fn query_blocked_start(&self, query_name: QueryName) {\n+        self.non_guard_query_event(\n+            |profiler| profiler.query_blocked_event_kind,\n+            query_name,\n+            EventFilter::QUERY_BLOCKED,\n+            TimestampKind::Start,\n+        );\n+    }\n+\n+    /// End profiling a query being blocked on a concurrent execution.\n+    #[inline(always)]\n+    pub fn query_blocked_end(&self, query_name: QueryName) {\n+        self.non_guard_query_event(\n+            |profiler| profiler.query_blocked_event_kind,\n+            query_name,\n+            EventFilter::QUERY_BLOCKED,\n+            TimestampKind::End,\n+        );\n+    }\n+\n+    /// Start profiling how long it takes to load a query result from the\n+    /// incremental compilation on-disk cache. Profiling continues until the\n+    /// TimingGuard returned from this call is dropped.\n+    #[inline(always)]\n+    pub fn incr_cache_loading(&self, query_name: QueryName) -> TimingGuard<'_> {\n+        self.exec(EventFilter::INCR_CACHE_LOADS, |profiler| {\n+            let event_id = SelfProfiler::get_query_name_string_id(query_name);\n+            TimingGuard::start(\n+                profiler,\n+                profiler.incremental_load_result_event_kind,\n+                event_id\n+            )\n+        })\n+    }\n+\n+    #[inline(always)]\n+    fn non_guard_query_event(\n+        &self,\n+        event_kind: fn(&SelfProfiler) -> StringId,\n+        query_name: QueryName,\n+        event_filter: EventFilter,\n+        timestamp_kind: TimestampKind\n+    ) {\n+        drop(self.exec(event_filter, |profiler| {\n+            let event_id = SelfProfiler::get_query_name_string_id(query_name);\n+            let thread_id = thread_id_to_u64(std::thread::current().id());\n+\n+            profiler.profiler.record_event(\n+                event_kind(profiler),\n+                event_id,\n+                thread_id,\n+                timestamp_kind,\n+            );\n+\n+            TimingGuard::none()\n+        }));\n+    }\n+\n+    #[inline(always)]\n+    fn non_guard_generic_event<F: FnOnce(&SelfProfiler) -> StringId>(\n+        &self,\n+        event_kind: fn(&SelfProfiler) -> StringId,\n+        event_id: F,\n+        event_filter: EventFilter,\n+        timestamp_kind: TimestampKind\n+    ) {\n+        drop(self.exec(event_filter, |profiler| {\n+            let thread_id = thread_id_to_u64(std::thread::current().id());\n+\n+            profiler.profiler.record_event(\n+                event_kind(profiler),\n+                event_id(profiler),\n+                thread_id,\n+                timestamp_kind,\n+            );\n+\n+            TimingGuard::none()\n+        }));\n+    }\n+}\n+\n pub struct SelfProfiler {\n     profiler: Profiler,\n     event_filter_mask: EventFilter,\n@@ -143,103 +343,51 @@ impl SelfProfiler {\n         let id = SelfProfiler::get_query_name_string_id(query_name);\n         self.profiler.alloc_string_with_reserved_id(id, query_name.as_str());\n     }\n+}\n \n-    #[inline]\n-    pub fn start_activity(\n-        &self,\n-        label: impl Into<Cow<'static, str>>,\n-    ) {\n-        if self.event_filter_mask.contains(EventFilter::GENERIC_ACTIVITIES) {\n-            self.record(&label.into(), self.generic_activity_event_kind, TimestampKind::Start);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn end_activity(\n-        &self,\n-        label: impl Into<Cow<'static, str>>,\n-    ) {\n-        if self.event_filter_mask.contains(EventFilter::GENERIC_ACTIVITIES) {\n-            self.record(&label.into(), self.generic_activity_event_kind, TimestampKind::End);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn record_query_hit(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::QUERY_CACHE_HITS) {\n-            self.record_query(query_name, self.query_cache_hit_event_kind, TimestampKind::Instant);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn start_query(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::QUERY_PROVIDERS) {\n-            self.record_query(query_name, self.query_event_kind, TimestampKind::Start);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn end_query(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::QUERY_PROVIDERS) {\n-            self.record_query(query_name, self.query_event_kind, TimestampKind::End);\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn incremental_load_result_start(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::INCR_CACHE_LOADS) {\n-            self.record_query(\n-                query_name,\n-                self.incremental_load_result_event_kind,\n-                TimestampKind::Start\n-            );\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn incremental_load_result_end(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::INCR_CACHE_LOADS) {\n-            self.record_query(\n-                query_name,\n-                self.incremental_load_result_event_kind,\n-                TimestampKind::End\n-            );\n-        }\n-    }\n+#[must_use]\n+pub struct TimingGuard<'a>(Option<TimingGuardInternal<'a>>);\n \n-    #[inline]\n-    pub fn query_blocked_start(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::QUERY_BLOCKED) {\n-            self.record_query(query_name, self.query_blocked_event_kind, TimestampKind::Start);\n-        }\n-    }\n+struct TimingGuardInternal<'a> {\n+    raw_profiler: &'a Profiler,\n+    event_id: StringId,\n+    event_kind: StringId,\n+    thread_id: u64,\n+}\n \n+impl<'a> TimingGuard<'a> {\n     #[inline]\n-    pub fn query_blocked_end(&self, query_name: QueryName) {\n-        if self.event_filter_mask.contains(EventFilter::QUERY_BLOCKED) {\n-            self.record_query(query_name, self.query_blocked_event_kind, TimestampKind::End);\n-        }\n+    pub fn start(\n+        profiler: &'a SelfProfiler,\n+        event_kind: StringId,\n+        event_id: StringId,\n+    ) -> TimingGuard<'a> {\n+        let thread_id = thread_id_to_u64(std::thread::current().id());\n+        let raw_profiler = &profiler.profiler;\n+        raw_profiler.record_event(event_kind, event_id, thread_id, TimestampKind::Start);\n+\n+        TimingGuard(Some(TimingGuardInternal {\n+            raw_profiler,\n+            event_kind,\n+            event_id,\n+            thread_id,\n+        }))\n     }\n \n     #[inline]\n-    fn record(&self, event_id: &str, event_kind: StringId, timestamp_kind: TimestampKind) {\n-        let thread_id = thread_id_to_u64(std::thread::current().id());\n-\n-        let event_id = self.profiler.alloc_string(event_id);\n-        self.profiler.record_event(event_kind, event_id, thread_id, timestamp_kind);\n+    pub fn none() -> TimingGuard<'a> {\n+        TimingGuard(None)\n     }\n+}\n \n+impl<'a> Drop for TimingGuardInternal<'a> {\n     #[inline]\n-    fn record_query(\n-        &self,\n-        query_name: QueryName,\n-        event_kind: StringId,\n-        timestamp_kind: TimestampKind,\n-    ) {\n-        let dep_node_name = SelfProfiler::get_query_name_string_id(query_name);\n-\n-        let thread_id = thread_id_to_u64(std::thread::current().id());\n-\n-        self.profiler.record_event(event_kind, dep_node_name, thread_id, timestamp_kind);\n+    fn drop(&mut self) {\n+        self.raw_profiler.record_event(\n+            self.event_kind,\n+            self.event_id,\n+            self.thread_id,\n+            TimestampKind::End\n+        );\n     }\n }"}, {"sha": "c4368d2cb8b45df859f68b601512e617ae352702", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -62,11 +62,13 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n     };\n     let exported_symbols = cgcx.exported_symbols\n         .as_ref().expect(\"needs exported symbols for LTO\");\n-    let mut symbol_white_list = exported_symbols[&LOCAL_CRATE]\n-        .iter()\n-        .filter_map(symbol_filter)\n-        .collect::<Vec<CString>>();\n-    let _timer = cgcx.profile_activity(\"generate_symbol_white_list_for_thinlto\");\n+    let mut symbol_white_list = {\n+        let _timer = cgcx.prof.generic_activity(\"LLVM_lto_generate_symbol_white_list\");\n+        exported_symbols[&LOCAL_CRATE]\n+            .iter()\n+            .filter_map(symbol_filter)\n+            .collect::<Vec<CString>>()\n+    };\n     info!(\"{} symbols to preserve in this crate\", symbol_white_list.len());\n \n     // If we're performing LTO for the entire crate graph, then for each of our\n@@ -95,14 +97,17 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         }\n \n         for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n-            let _timer = cgcx.profile_activity(format!(\"load: {}\", path.display()));\n             let exported_symbols = cgcx.exported_symbols\n                 .as_ref().expect(\"needs exported symbols for LTO\");\n-            symbol_white_list.extend(\n-                exported_symbols[&cnum]\n-                    .iter()\n-                    .filter_map(symbol_filter));\n+            {\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_lto_generate_symbol_white_list\");\n+                symbol_white_list.extend(\n+                    exported_symbols[&cnum]\n+                        .iter()\n+                        .filter_map(symbol_filter));\n+            }\n \n+            let _timer = cgcx.prof.generic_activity(\"LLVM_lto_load_upstream_bitcode\");\n             let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n             let bytecodes = archive.iter().filter_map(|child| {\n                 child.ok().and_then(|c| c.name().map(|name| (name, c)))\n@@ -189,6 +194,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n            symbol_white_list: &[*const libc::c_char])\n     -> Result<LtoModuleCodegen<LlvmCodegenBackend>, FatalError>\n {\n+    let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_build_monolithic_module\");\n     info!(\"going for a fat lto\");\n \n     // Sort out all our lists of incoming modules into two lists.\n@@ -287,6 +293,7 @@ fn fat_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         // save and persist everything with the original module.\n         let mut linker = Linker::new(llmod);\n         for (bc_decoded, name) in serialized_modules {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_fat_lto_link_module\");\n             info!(\"linking {:?}\", name);\n             time_ext(cgcx.time_passes, None, &format!(\"ll link {:?}\", name), || {\n                 let data = bc_decoded.data();\n@@ -388,6 +395,7 @@ fn thin_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             symbol_white_list: &[*const libc::c_char])\n     -> Result<(Vec<LtoModuleCodegen<LlvmCodegenBackend>>, Vec<WorkProduct>), FatalError>\n {\n+    let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_global_analysis\");\n     unsafe {\n         info!(\"going for that thin, thin LTO\");\n \n@@ -601,16 +609,6 @@ impl ModuleBuffer {\n             llvm::LLVMRustModuleBufferCreate(m)\n         })\n     }\n-\n-    pub fn parse<'a>(\n-        &self,\n-        name: &str,\n-        cx: &'a llvm::Context,\n-        handler: &Handler,\n-    ) -> Result<&'a llvm::Module, FatalError> {\n-        let name = CString::new(name).unwrap();\n-        parse_module(cx, &name, self.data(), handler)\n-    }\n }\n \n impl ModuleBufferMethods for ModuleBuffer {\n@@ -723,7 +721,7 @@ pub unsafe fn optimize_thin_module(\n         // Like with \"fat\" LTO, get some better optimizations if landing pads\n         // are disabled by removing all landing pads.\n         if cgcx.no_landing_pads {\n-            let _timer = cgcx.profile_activity(\"LLVM_remove_landing_pads\");\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_remove_landing_pads\");\n             llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n             save_temp_bitcode(&cgcx, &module, \"thin-lto-after-nounwind\");\n         }\n@@ -736,26 +734,41 @@ pub unsafe fn optimize_thin_module(\n         //\n         // You can find some more comments about these functions in the LLVM\n         // bindings we've got (currently `PassWrapper.cpp`)\n-        if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\";\n-            return Err(write::llvm_err(&diag_handler, msg))\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_rename\");\n+            if !llvm::LLVMRustPrepareThinLTORename(thin_module.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\";\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-rename\");\n         }\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-rename\");\n-        if !llvm::LLVMRustPrepareThinLTOResolveWeak(thin_module.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\";\n-            return Err(write::llvm_err(&diag_handler, msg))\n+\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_resolve_weak\");\n+            if !llvm::LLVMRustPrepareThinLTOResolveWeak(thin_module.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\";\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-resolve\");\n         }\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-resolve\");\n-        if !llvm::LLVMRustPrepareThinLTOInternalize(thin_module.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\";\n-            return Err(write::llvm_err(&diag_handler, msg))\n+\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_internalize\");\n+            if !llvm::LLVMRustPrepareThinLTOInternalize(thin_module.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\";\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-internalize\");\n         }\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-internalize\");\n-        if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod) {\n-            let msg = \"failed to prepare thin LTO module\";\n-            return Err(write::llvm_err(&diag_handler, msg))\n+\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_import\");\n+            if !llvm::LLVMRustPrepareThinLTOImport(thin_module.shared.data.0, llmod) {\n+                let msg = \"failed to prepare thin LTO module\";\n+                return Err(write::llvm_err(&diag_handler, msg))\n+            }\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-import\");\n         }\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-import\");\n \n         // Ok now this is a bit unfortunate. This is also something you won't\n         // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n@@ -786,18 +799,24 @@ pub unsafe fn optimize_thin_module(\n         // not too much) but for now at least gets LLVM to emit valid DWARF (or\n         // so it appears). Hopefully we can remove this once upstream bugs are\n         // fixed in LLVM.\n-        llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-patch\");\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_patch_debuginfo\");\n+            llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-patch\");\n+        }\n \n         // Alright now that we've done everything related to the ThinLTO\n         // analysis it's time to run some optimizations! Here we use the same\n         // `run_pass_manager` as the \"fat\" LTO above except that we tell it to\n         // populate a thin-specific pass manager, which presumably LLVM treats a\n         // little differently.\n-        info!(\"running thin lto passes over {}\", module.name);\n-        let config = cgcx.config(module.kind);\n-        run_pass_manager(cgcx, &module, config, true);\n-        save_temp_bitcode(cgcx, &module, \"thin-lto-after-pm\");\n+        {\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_thin_lto_optimize\");\n+            info!(\"running thin lto passes over {}\", module.name);\n+            let config = cgcx.config(module.kind);\n+            run_pass_manager(cgcx, &module, config, true);\n+            save_temp_bitcode(cgcx, &module, \"thin-lto-after-pm\");\n+        }\n     }\n     Ok(module)\n }"}, {"sha": "78db90b57b53d4ed968ccd1f5e21d96a775be45c", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -306,6 +306,8 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                    config: &ModuleConfig)\n     -> Result<(), FatalError>\n {\n+    let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize\");\n+\n     let llmod = module.module_llvm.llmod();\n     let llcx = &*module.module_llvm.llcx;\n     let tm = &*module.module_llvm.tm;\n@@ -423,7 +425,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n         // Finally, run the actual optimization passes\n         {\n-            let _timer = cgcx.profile_activity(\"LLVM_function_passes\");\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_function_passes\");\n             time_ext(config.time_passes,\n                         None,\n                         &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n@@ -432,7 +434,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             });\n         }\n         {\n-            let _timer = cgcx.profile_activity(\"LLVM_module_passes\");\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_module_optimize_module_passes\");\n             time_ext(config.time_passes,\n                     None,\n                     &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n@@ -454,7 +456,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                   config: &ModuleConfig)\n     -> Result<CompiledModule, FatalError>\n {\n-    let _timer = cgcx.profile_activity(\"codegen\");\n+    let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen\");\n     {\n         let llmod = module.module_llvm.llmod();\n         let llcx = &*module.module_llvm.llcx;\n@@ -505,25 +507,26 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n \n         if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n-            let _timer = cgcx.profile_activity(\"LLVM_make_bitcode\");\n+            let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_make_bitcode\");\n             let thin = ThinBuffer::new(llmod);\n             let data = thin.data();\n \n             if write_bc {\n-                let _timer = cgcx.profile_activity(\"LLVM_emit_bitcode\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_bitcode\");\n                 if let Err(e) = fs::write(&bc_out, data) {\n                     let msg = format!(\"failed to write bytecode to {}: {}\", bc_out.display(), e);\n                     diag_handler.err(&msg);\n                 }\n             }\n \n             if config.embed_bitcode {\n-                let _timer = cgcx.profile_activity(\"LLVM_embed_bitcode\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_embed_bitcode\");\n                 embed_bitcode(cgcx, llcx, llmod, Some(data));\n             }\n \n             if config.emit_bc_compressed {\n-                let _timer = cgcx.profile_activity(\"LLVM_compress_bitcode\");\n+                let _timer =\n+                    cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_compressed_bitcode\");\n                 let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n                 let data = bytecode::encode(&module.name, data);\n                 if let Err(e) = fs::write(&dst, data) {\n@@ -538,7 +541,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n             || -> Result<(), FatalError> {\n             if config.emit_ir {\n-                let _timer = cgcx.profile_activity(\"LLVM_emit_ir\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_ir\");\n                 let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n                 let out_c = path_to_c_string(&out);\n \n@@ -585,7 +588,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             }\n \n             if config.emit_asm || asm_to_obj {\n-                let _timer = cgcx.profile_activity(\"LLVM_emit_asm\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_asm\");\n                 let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n                 // We can't use the same module for asm and binary output, because that triggers\n@@ -603,13 +606,13 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             }\n \n             if write_obj {\n-                let _timer = cgcx.profile_activity(\"LLVM_emit_obj\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_emit_obj\");\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n                                       llvm::FileType::ObjectFile)\n                 })?;\n             } else if asm_to_obj {\n-                let _timer = cgcx.profile_activity(\"LLVM_asm_to_obj\");\n+                let _timer = cgcx.prof.generic_activity(\"LLVM_module_codegen_asm_to_obj\");\n                 let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n                 run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n "}, {"sha": "bd7d0d4017dce471ca700efef316014b1e5aace6", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -108,6 +108,7 @@ pub fn compile_codegen_unit(\n     cgu_name: InternedString,\n     tx_to_llvm_workers: &std::sync::mpsc::Sender<Box<dyn std::any::Any + Send>>,\n ) {\n+    let prof_timer = tcx.prof.generic_activity(\"codegen_module\");\n     let start_time = Instant::now();\n \n     let dep_node = tcx.codegen_unit(cgu_name).codegen_dep_node(tcx);\n@@ -119,6 +120,7 @@ pub fn compile_codegen_unit(\n         dep_graph::hash_result,\n     );\n     let time_to_codegen = start_time.elapsed();\n+    drop(prof_timer);\n \n     // We assume that the cost to run LLVM on a CGU is proportional to\n     // the time we needed for codegenning it."}, {"sha": "87eab484fafc697bddefc47f6273e59bee5b11b5", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -324,8 +324,9 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        sess.profiler(|p| p.start_activity(\"link_crate\"));\n         time(sess, \"linking\", || {\n+            let _prof_timer = sess.prof.generic_activity(\"link_crate\");\n+\n             use rustc_codegen_ssa::back::link::link_binary;\n             use crate::back::archive::LlvmArchiveBuilder;\n \n@@ -338,7 +339,6 @@ impl CodegenBackend for LlvmCodegenBackend {\n                 target_cpu,\n             );\n         });\n-        sess.profiler(|p| p.end_activity(\"link_crate\"));\n \n         // Now that we won't touch anything in the incremental compilation directory\n         // any more, we can finalize it (which involves renaming it)"}, {"sha": "f1cfac270332223d80d3a766bd22889208a934f2", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 11, "deletions": 67, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -19,7 +19,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n use rustc::util::common::{time_depth, set_time_depth, print_time_passes_entry};\n-use rustc::util::profiling::SelfProfiler;\n+use rustc::util::profiling::SelfProfilerRef;\n use rustc_fs_util::link_or_copy;\n use rustc_data_structures::svh::Svh;\n use rustc_errors::{Handler, Level, FatalError, DiagnosticId};\n@@ -31,7 +31,6 @@ use syntax_pos::symbol::{Symbol, sym};\n use jobserver::{Client, Acquired};\n \n use std::any::Any;\n-use std::borrow::Cow;\n use std::fs;\n use std::io;\n use std::mem;\n@@ -196,42 +195,13 @@ impl<B: WriteBackendMethods> Clone for TargetMachineFactory<B> {\n     }\n }\n \n-pub struct ProfileGenericActivityTimer {\n-    profiler: Option<Arc<SelfProfiler>>,\n-    label: Cow<'static, str>,\n-}\n-\n-impl ProfileGenericActivityTimer {\n-    pub fn start(\n-        profiler: Option<Arc<SelfProfiler>>,\n-        label: Cow<'static, str>,\n-    ) -> ProfileGenericActivityTimer {\n-        if let Some(profiler) = &profiler {\n-            profiler.start_activity(label.clone());\n-        }\n-\n-        ProfileGenericActivityTimer {\n-            profiler,\n-            label,\n-        }\n-    }\n-}\n-\n-impl Drop for ProfileGenericActivityTimer {\n-    fn drop(&mut self) {\n-        if let Some(profiler) = &self.profiler {\n-            profiler.end_activity(self.label.clone());\n-        }\n-    }\n-}\n-\n /// Additional resources used by optimize_and_codegen (not module specific)\n #[derive(Clone)]\n pub struct CodegenContext<B: WriteBackendMethods> {\n     // Resources needed when running LTO\n     pub backend: B,\n     pub time_passes: bool,\n-    pub profiler: Option<Arc<SelfProfiler>>,\n+    pub prof: SelfProfilerRef,\n     pub lto: Lto,\n     pub no_landing_pads: bool,\n     pub save_temps: bool,\n@@ -283,31 +253,6 @@ impl<B: WriteBackendMethods> CodegenContext<B> {\n             ModuleKind::Allocator => &self.allocator_module_config,\n         }\n     }\n-\n-    #[inline(never)]\n-    #[cold]\n-    fn profiler_active<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n-        match &self.profiler {\n-            None => bug!(\"profiler_active() called but there was no profiler active\"),\n-            Some(profiler) => {\n-                f(&*profiler);\n-            }\n-        }\n-    }\n-\n-    #[inline(always)]\n-    pub fn profile<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n-        if unlikely!(self.profiler.is_some()) {\n-            self.profiler_active(f)\n-        }\n-    }\n-\n-    pub fn profile_activity(\n-        &self,\n-        label: impl Into<Cow<'static, str>>,\n-    ) -> ProfileGenericActivityTimer {\n-        ProfileGenericActivityTimer::start(self.profiler.clone(), label.into())\n-    }\n }\n \n fn generate_lto_work<B: ExtraBackendMethods>(\n@@ -316,7 +261,7 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n     needs_thin_lto: Vec<(String, B::ThinBuffer)>,\n     import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n ) -> Vec<(WorkItem<B>, u64)> {\n-    cgcx.profile(|p| p.start_activity(\"codegen_run_lto\"));\n+    let _prof_timer = cgcx.prof.generic_activity(\"codegen_run_lto\");\n \n     let (lto_modules, copy_jobs) = if !needs_fat_lto.is_empty() {\n         assert!(needs_thin_lto.is_empty());\n@@ -343,8 +288,6 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n         }), 0)\n     })).collect();\n \n-    cgcx.profile(|p| p.end_activity(\"codegen_run_lto\"));\n-\n     result\n }\n \n@@ -380,6 +323,9 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n ) -> OngoingCodegen<B> {\n     let (coordinator_send, coordinator_receive) = channel();\n     let sess = tcx.sess;\n+\n+    sess.prof.generic_activity_start(\"codegen_and_optimize_crate\");\n+\n     let crate_name = tcx.crate_name(LOCAL_CRATE);\n     let crate_hash = tcx.crate_hash(LOCAL_CRATE);\n     let no_builtins = attr::contains_name(&tcx.hir().krate().attrs, sym::no_builtins);\n@@ -1088,7 +1034,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         save_temps: sess.opts.cg.save_temps,\n         opts: Arc::new(sess.opts.clone()),\n         time_passes: sess.time_extended(),\n-        profiler: sess.self_profiling.clone(),\n+        prof: sess.prof.clone(),\n         exported_symbols,\n         plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n         remark: sess.opts.cg.remark.clone(),\n@@ -1645,12 +1591,8 @@ fn spawn_work<B: ExtraBackendMethods>(\n         // as a diagnostic was already sent off to the main thread - just\n         // surface that there was an error in this worker.\n         bomb.result = {\n-            let label = work.name();\n-            cgcx.profile(|p| p.start_activity(label.clone()));\n-            let result = execute_work_item(&cgcx, work).ok();\n-            cgcx.profile(|p| p.end_activity(label));\n-\n-            result\n+            let _prof_timer = cgcx.prof.generic_activity(&work.name());\n+            execute_work_item(&cgcx, work).ok()\n         };\n     });\n }\n@@ -1835,6 +1777,8 @@ impl<B: ExtraBackendMethods> OngoingCodegen<B> {\n             self.backend.print_pass_timings()\n         }\n \n+        sess.prof.generic_activity_end(\"codegen_and_optimize_crate\");\n+\n         (CodegenResults {\n             crate_name: self.crate_name,\n             crate_hash: self.crate_hash,"}, {"sha": "935087714a7ebb3b170b13f639cca83bbff43a58", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -559,7 +559,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     if need_metadata_module {\n         // Codegen the encoded metadata.\n-        tcx.sess.profiler(|p| p.start_activity(\"codegen crate metadata\"));\n+        let _prof_timer = tcx.prof.generic_activity(\"codegen_crate_metadata\");\n \n         let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n                                                                 &[\"crate\"],\n@@ -570,7 +570,6 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n             backend.write_compressed_metadata(tcx, &ongoing_codegen.metadata,\n                                               &mut metadata_llvm_module);\n         });\n-        tcx.sess.profiler(|p| p.end_activity(\"codegen crate metadata\"));\n \n         let metadata_module = ModuleCodegen {\n             name: metadata_cgu_name,\n@@ -599,11 +598,9 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n         match cgu_reuse {\n             CguReuse::No => {\n-                tcx.sess.profiler(|p| p.start_activity(format!(\"codegen {}\", cgu.name())));\n                 let start_time = Instant::now();\n                 backend.compile_codegen_unit(tcx, *cgu.name(), &ongoing_codegen.coordinator_send);\n                 total_codegen_time += start_time.elapsed();\n-                tcx.sess.profiler(|p| p.end_activity(format!(\"codegen {}\", cgu.name())));\n                 false\n             }\n             CguReuse::PreLto => {"}, {"sha": "5017a60ca699a2cd83303bc2ac92dec92e85a6f4", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -21,7 +21,6 @@\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate rustc;\n-#[macro_use] extern crate rustc_data_structures;\n #[macro_use] extern crate syntax;\n \n use std::path::PathBuf;"}, {"sha": "6af065513ee0dccf9f6f00343ea1a491bb335bb5", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -28,6 +28,8 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n \n         join(move || {\n             if tcx.sess.opts.debugging_opts.incremental_queries {\n+                let _timer = tcx.prof.generic_activity(\"incr_comp_persist_result_cache\");\n+\n                 time(sess, \"persist query result cache\", || {\n                     save_in(sess,\n                             query_cache_path,\n@@ -36,6 +38,8 @@ pub fn save_dep_graph(tcx: TyCtxt<'_>) {\n             }\n         }, || {\n             time(sess, \"persist dep-graph\", || {\n+                let _timer = tcx.prof.generic_activity(\"incr_comp_persist_dep_graph\");\n+\n                 save_in(sess,\n                         dep_graph_path,\n                         |e| {\n@@ -135,6 +139,7 @@ fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n \n     // Encode the graph data.\n     let serialized_graph = time(tcx.sess, \"getting serialized graph\", || {\n+        let _timer = tcx.prof.generic_activity(\"incr_comp_serialize_dep_graph\");\n         tcx.dep_graph.serialize()\n     });\n \n@@ -214,6 +219,7 @@ fn encode_dep_graph(tcx: TyCtxt<'_>, encoder: &mut Encoder) {\n     }\n \n     time(tcx.sess, \"encoding serialized graph\", || {\n+        let _timer = tcx.prof.generic_activity(\"incr_comp_encode_serialized_dep_graph\");\n         serialized_graph.encode(encoder).unwrap();\n     });\n }"}, {"sha": "0055e0a8b2e880b335b2cb845bf009f6fc2c5e18", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -59,15 +59,17 @@ use std::rc::Rc;\n pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n     sess.diagnostic()\n         .set_continue_after_error(sess.opts.debugging_opts.continue_parse_after_error);\n-    sess.profiler(|p| p.start_activity(\"parsing\"));\n-    let krate = time(sess, \"parsing\", || match *input {\n-        Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n-        Input::Str {\n-            ref input,\n-            ref name,\n-        } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n+    let krate = time(sess, \"parsing\", || {\n+        let _prof_timer = sess.prof.generic_activity(\"parse_crate\");\n+\n+        match *input {\n+            Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n+            Input::Str {\n+                ref input,\n+                ref name,\n+            } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n+        }\n     })?;\n-    sess.profiler(|p| p.end_activity(\"parsing\"));\n \n     sess.diagnostic().set_continue_after_error(true);\n \n@@ -355,8 +357,8 @@ fn configure_and_expand_inner<'a>(\n     );\n \n     // Expand all macros\n-    sess.profiler(|p| p.start_activity(\"macro expansion\"));\n     krate = time(sess, \"expansion\", || {\n+        let _prof_timer = sess.prof.generic_activity(\"macro_expand_crate\");\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n         // dependent dlls. Note that this uses cfg!(windows) as opposed to\n@@ -430,7 +432,6 @@ fn configure_and_expand_inner<'a>(\n         }\n         krate\n     });\n-    sess.profiler(|p| p.end_activity(\"macro expansion\"));\n \n     time(sess, \"maybe building test harness\", || {\n         syntax_ext::test_harness::inject(\n@@ -1071,11 +1072,10 @@ pub fn start_codegen<'tcx>(\n         encode_and_write_metadata(tcx, outputs)\n     });\n \n-    tcx.sess.profiler(|p| p.start_activity(\"codegen crate\"));\n     let codegen = time(tcx.sess, \"codegen\", move || {\n+        let _prof_timer = tcx.prof.generic_activity(\"codegen_crate\");\n         codegen_backend.codegen_crate(tcx, metadata, need_metadata_module)\n     });\n-    tcx.sess.profiler(|p| p.end_activity(\"codegen crate\"));\n \n     if log_enabled!(::log::Level::Info) {\n         println!(\"Post-codegen\");"}, {"sha": "26a8f79b8d8315df83321766d6f8b72b3cadc161", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=8f5f92a07a1c3116eae83cbd4ad550f6d268bbe9", "patch": "@@ -295,7 +295,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n-    tcx.sess.profiler(|p| p.start_activity(\"type-check crate\"));\n+    let _prof_timer = tcx.prof.generic_activity(\"type_check_crate\");\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n@@ -347,8 +347,6 @@ pub fn check_crate(tcx: TyCtxt<'_>) -> Result<(), ErrorReported> {\n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);\n \n-    tcx.sess.profiler(|p| p.end_activity(\"type-check crate\"));\n-\n     if tcx.sess.err_count() == 0 {\n         Ok(())\n     } else {"}]}