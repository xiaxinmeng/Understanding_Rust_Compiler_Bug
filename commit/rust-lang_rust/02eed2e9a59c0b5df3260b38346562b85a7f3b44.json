{"sha": "02eed2e9a59c0b5df3260b38346562b85a7f3b44", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZWVkMmU5YTU5YzBiNWRmMzI2MGIzODM0NjU2MmI4NWE3ZjNiNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-17T10:12:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-11-17T10:12:21Z"}, "message": "Auto merge of #46004 - michaelwoerister:cached-mir-wip-3, r=nikomatsakis\n\nincr.comp.: Implement query result cache and use it to cache type checking tables.\n\nThis is a spike implementation of caching more than LLVM IR and object files when doing incremental compilation. At the moment, only the `typeck_tables_of` query is cached but MIR and borrow-check will follow shortly. The feature is activated by running with `-Zincremental-queries` in addition to `-Zincremental`, it is not yet active by default.\n\nr? @nikomatsakis", "tree": {"sha": "7f31efeb5966330b0428cc0d892bc47cd16a50da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7f31efeb5966330b0428cc0d892bc47cd16a50da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02eed2e9a59c0b5df3260b38346562b85a7f3b44", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02eed2e9a59c0b5df3260b38346562b85a7f3b44", "html_url": "https://github.com/rust-lang/rust/commit/02eed2e9a59c0b5df3260b38346562b85a7f3b44", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02eed2e9a59c0b5df3260b38346562b85a7f3b44/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b32267f2c1344d37c4aa30eccd5a9ab77642b3e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b32267f2c1344d37c4aa30eccd5a9ab77642b3e6", "html_url": "https://github.com/rust-lang/rust/commit/b32267f2c1344d37c4aa30eccd5a9ab77642b3e6"}, {"sha": "0a1f6dd8a8c27caf913a16eb0a1afeaa8183b983", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a1f6dd8a8c27caf913a16eb0a1afeaa8183b983", "html_url": "https://github.com/rust-lang/rust/commit/0a1f6dd8a8c27caf913a16eb0a1afeaa8183b983"}], "stats": {"total": 1531, "additions": 1161, "deletions": 370}, "files": [{"sha": "523a244c8361b1983e217624f05db5336f342c44", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -618,7 +618,7 @@ define_dep_nodes!( <'tcx>\n \n     [input] Freevars(DefId),\n     [input] MaybeUnusedTraitImport(DefId),\n-    [] MaybeUnusedExternCrates,\n+    [input] MaybeUnusedExternCrates,\n     [] StabilityIndex,\n     [input] AllCrateNums,\n     [] ExportedSymbols(CrateNum),"}, {"sha": "c9205f67f661f2b9ccf5f0b2a9b4349960aa5cff", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -327,6 +327,7 @@ impl DepGraph {\n         }\n     }\n \n+    #[inline]\n     pub fn fingerprint_of(&self, dep_node: &DepNode) -> Fingerprint {\n         match self.fingerprints.borrow().get(dep_node) {\n             Some(&fingerprint) => fingerprint,\n@@ -340,6 +341,11 @@ impl DepGraph {\n         self.data.as_ref().unwrap().previous.fingerprint_of(dep_node)\n     }\n \n+    #[inline]\n+    pub fn prev_dep_node_index_of(&self, dep_node: &DepNode) -> SerializedDepNodeIndex {\n+        self.data.as_ref().unwrap().previous.node_to_index(dep_node)\n+    }\n+\n     /// Indicates that a previous work product exists for `v`. This is\n     /// invoked during initial start-up based on what nodes are clean\n     /// (and what files exist in the incr. directory)."}, {"sha": "6c43b5c5ff197acc0c88704fac3ac35a5da2f783", "filename": "src/librustc/dep_graph/prev.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fdep_graph%2Fprev.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fprev.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -44,6 +44,11 @@ impl PreviousDepGraph {\n         self.data.nodes[dep_node_index].0\n     }\n \n+    #[inline]\n+    pub fn node_to_index(&self, dep_node: &DepNode) -> SerializedDepNodeIndex {\n+        self.index[dep_node]\n+    }\n+\n     #[inline]\n     pub fn fingerprint_of(&self, dep_node: &DepNode) -> Option<Fingerprint> {\n         self.index"}, {"sha": "f6fcff37ca53edacb0c24ecfa228b38b57095a29", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -11,8 +11,7 @@\n use ty;\n \n use rustc_data_structures::indexed_vec::Idx;\n-use serialize::{self, Encoder, Decoder};\n-\n+use serialize;\n use std::fmt;\n use std::u32;\n \n@@ -32,6 +31,10 @@ newtype_index!(CrateNum\n \n         /// A CrateNum value that indicates that something is wrong.\n         const INVALID_CRATE = u32::MAX - 1,\n+\n+        /// A special CrateNum that we use for the tcx.rcache when decoding from\n+        /// the incr. comp. cache.\n+        const RESERVED_FOR_INCR_COMP_CACHE = u32::MAX - 2,\n     });\n \n impl CrateNum {\n@@ -61,17 +64,8 @@ impl fmt::Display for CrateNum {\n     }\n }\n \n-impl serialize::UseSpecializedEncodable for CrateNum {\n-    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_u32(self.0)\n-    }\n-}\n-\n-impl serialize::UseSpecializedDecodable for CrateNum {\n-    fn default_decode<D: Decoder>(d: &mut D) -> Result<CrateNum, D::Error> {\n-        d.read_u32().map(CrateNum)\n-    }\n-}\n+impl serialize::UseSpecializedEncodable for CrateNum {}\n+impl serialize::UseSpecializedDecodable for CrateNum {}\n \n /// A DefIndex is an index into the hir-map for a crate, identifying a\n /// particular definition. It should really be considered an interned\n@@ -88,6 +82,7 @@ impl serialize::UseSpecializedDecodable for CrateNum {\n /// don't have to care about these ranges.\n newtype_index!(DefIndex\n     {\n+        ENCODABLE = custom\n         DEBUG_FORMAT = custom,\n \n         /// The start of the \"high\" range of DefIndexes.\n@@ -146,6 +141,9 @@ impl DefIndex {\n     }\n }\n \n+impl serialize::UseSpecializedEncodable for DefIndex {}\n+impl serialize::UseSpecializedDecodable for DefIndex {}\n+\n #[derive(Copy, Clone, Eq, PartialEq, Hash)]\n pub enum DefIndexAddressSpace {\n     Low = 0,\n@@ -166,7 +164,7 @@ impl DefIndexAddressSpace {\n \n /// A DefId identifies a particular *definition*, by combining a crate\n /// index and a def index.\n-#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, RustcEncodable, RustcDecodable, Hash, Copy)]\n+#[derive(Clone, Eq, Ord, PartialOrd, PartialEq, Hash, Copy)]\n pub struct DefId {\n     pub krate: CrateNum,\n     pub index: DefIndex,\n@@ -188,14 +186,58 @@ impl fmt::Debug for DefId {\n     }\n }\n \n-\n impl DefId {\n     /// Make a local `DefId` with the given index.\n+    #[inline]\n     pub fn local(index: DefIndex) -> DefId {\n         DefId { krate: LOCAL_CRATE, index: index }\n     }\n \n-    pub fn is_local(&self) -> bool {\n+    #[inline]\n+    pub fn is_local(self) -> bool {\n         self.krate == LOCAL_CRATE\n     }\n+\n+    #[inline]\n+    pub fn to_local(self) -> LocalDefId {\n+        LocalDefId::from_def_id(self)\n+    }\n }\n+\n+impl serialize::UseSpecializedEncodable for DefId {}\n+impl serialize::UseSpecializedDecodable for DefId {}\n+\n+/// A LocalDefId is equivalent to a DefId with `krate == LOCAL_CRATE`. Since\n+/// we encode this information in the type, we can ensure at compile time that\n+/// no DefIds from upstream crates get thrown into the mix. There are quite a\n+/// few cases where we know that only DefIds from the local crate are expected\n+/// and a DefId from a different crate would signify a bug somewhere. This\n+/// is when LocalDefId comes in handy.\n+#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash)]\n+pub struct LocalDefId(DefIndex);\n+\n+impl LocalDefId {\n+\n+    #[inline]\n+    pub fn from_def_id(def_id: DefId) -> LocalDefId {\n+        assert!(def_id.is_local());\n+        LocalDefId(def_id.index)\n+    }\n+\n+    #[inline]\n+    pub fn to_def_id(self) -> DefId {\n+        DefId {\n+            krate: LOCAL_CRATE,\n+            index: self.0\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for LocalDefId {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.to_def_id().fmt(f)\n+    }\n+}\n+\n+impl serialize::UseSpecializedEncodable for LocalDefId {}\n+impl serialize::UseSpecializedDecodable for LocalDefId {}"}, {"sha": "8b00280b26b56d06f99e4e0a1c5c96402e566115", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -17,7 +17,7 @@ pub use self::definitions::{Definitions, DefKey, DefPath, DefPathData,\n \n use dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n \n-use hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndexAddressSpace};\n+use hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId, DefIndexAddressSpace};\n \n use syntax::abi::Abi;\n use syntax::ast::{self, Name, NodeId, CRATE_NODE_ID};\n@@ -359,6 +359,16 @@ impl<'hir> Map<'hir> {\n         self.definitions.as_local_node_id(DefId::local(def_index)).unwrap()\n     }\n \n+    #[inline]\n+    pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n+        self.definitions.def_index_to_hir_id(def_id.to_def_id().index)\n+    }\n+\n+    #[inline]\n+    pub fn local_def_id_to_node_id(&self, def_id: LocalDefId) -> NodeId {\n+        self.definitions.as_local_node_id(def_id.to_def_id()).unwrap()\n+    }\n+\n     fn entry_count(&self) -> usize {\n         self.map.len()\n     }"}, {"sha": "1346685e02afe021c4b579d7e61e243240de8957", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -45,6 +45,7 @@ use ty::AdtKind;\n \n use rustc_data_structures::indexed_vec;\n \n+use serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::BTreeMap;\n use std::fmt;\n \n@@ -85,13 +86,37 @@ pub mod svh;\n /// the local_id part of the HirId changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n-         RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n pub struct HirId {\n     pub owner: DefIndex,\n     pub local_id: ItemLocalId,\n }\n \n+impl serialize::UseSpecializedEncodable for HirId {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        let HirId {\n+            owner,\n+            local_id,\n+        } = *self;\n+\n+        owner.encode(s)?;\n+        local_id.encode(s)\n+    }\n+}\n+\n+impl serialize::UseSpecializedDecodable for HirId {\n+    fn default_decode<D: Decoder>(d: &mut D) -> Result<HirId, D::Error> {\n+        let owner = DefIndex::decode(d)?;\n+        let local_id = ItemLocalId::decode(d)?;\n+\n+        Ok(HirId {\n+            owner,\n+            local_id\n+        })\n+    }\n+}\n+\n+\n /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n /// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n /// guarantee that the numerical value of a given `ItemLocalId` corresponds to"}, {"sha": "2b5390e6bb90e084f78816fffae0819f3b2a90b2", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -13,7 +13,7 @@\n \n use hir;\n use hir::map::DefPathHash;\n-use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n+use hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n use ich::{StableHashingContext, NodeIdHashingMode};\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n@@ -38,6 +38,24 @@ impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for DefId {\n     }\n }\n \n+impl<'gcx> HashStable<StableHashingContext<'gcx>> for LocalDefId {\n+    #[inline]\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'gcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        hcx.def_path_hash(self.to_def_id()).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'gcx> ToStableHashKey<StableHashingContext<'gcx>> for LocalDefId {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'gcx>) -> DefPathHash {\n+        hcx.def_path_hash(self.to_def_id())\n+    }\n+}\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>> for CrateNum {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,"}, {"sha": "5d7141949e389977d9a781b498d06fceb9a2ece2", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -24,7 +24,7 @@\n \n use hir;\n use hir::def;\n-use hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use hir::map as hir_map;\n use hir::map::definitions::{Definitions, DefKey, DefPathTable};\n use hir::svh::Svh;\n@@ -180,7 +180,7 @@ impl EncodedMetadata {\n /// upstream crate.\n #[derive(Debug, RustcEncodable, RustcDecodable, Copy, Clone)]\n pub struct EncodedMetadataHash {\n-    pub def_index: DefIndex,\n+    pub def_index: u32,\n     pub hash: ich::Fingerprint,\n }\n "}, {"sha": "9018b9fe590b2e8bd53035f488ea937284070f8f", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -20,7 +20,7 @@ use self::TrackMatchMode::*;\n use self::OverloadedCallType::*;\n \n use hir::def::Def;\n-use hir::def_id::{DefId};\n+use hir::def_id::DefId;\n use infer::InferCtxt;\n use middle::mem_categorization as mc;\n use middle::region;\n@@ -915,7 +915,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n                 let closure_def_id = self.tcx().hir.local_def_id(closure_expr.id);\n                 let upvar_id = ty::UpvarId {\n                     var_id: var_hir_id,\n-                    closure_expr_id: closure_def_id.index\n+                    closure_expr_id: closure_def_id.to_local(),\n                 };\n                 let upvar_capture = self.mc.tables.upvar_capture(upvar_id);\n                 let cmt_var = return_if_err!(self.cat_captured_var(closure_expr.id,"}, {"sha": "2c6bcc654a5327cea33496ba5c358250b45aac76", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -70,7 +70,7 @@ pub use self::Note::*;\n use self::Aliasability::*;\n \n use middle::region;\n-use hir::def_id::{DefId, DefIndex};\n+use hir::def_id::{DefId, LocalDefId};\n use hir::map as hir_map;\n use infer::InferCtxt;\n use hir::def::{Def, CtorKind};\n@@ -191,7 +191,7 @@ pub type cmt<'tcx> = Rc<cmt_<'tcx>>;\n \n pub enum ImmutabilityBlame<'tcx> {\n     ImmLocal(ast::NodeId),\n-    ClosureEnv(DefIndex),\n+    ClosureEnv(LocalDefId),\n     LocalDeref(ast::NodeId),\n     AdtFieldDeref(&'tcx ty::AdtDef, &'tcx ty::FieldDef)\n }\n@@ -759,11 +759,11 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             ref t => span_bug!(span, \"unexpected type for fn in mem_categorization: {:?}\", t),\n         };\n \n-        let closure_expr_def_index = self.tcx.hir.local_def_id(fn_node_id).index;\n+        let closure_expr_def_id = self.tcx.hir.local_def_id(fn_node_id);\n         let var_hir_id = self.tcx.hir.node_to_hir_id(var_id);\n         let upvar_id = ty::UpvarId {\n             var_id: var_hir_id,\n-            closure_expr_id: closure_expr_def_index\n+            closure_expr_id: closure_expr_def_id.to_local(),\n         };\n \n         let var_ty = self.node_ty(var_hir_id)?;\n@@ -838,7 +838,7 @@ impl<'a, 'gcx, 'tcx> MemCategorizationContext<'a, 'gcx, 'tcx> {\n             // The environment of a closure is guaranteed to\n             // outlive any bindings introduced in the body of the\n             // closure itself.\n-            scope: DefId::local(upvar_id.closure_expr_id),\n+            scope: upvar_id.closure_expr_id.to_def_id(),\n             bound_region: ty::BrEnv\n         }));\n "}, {"sha": "57fae2200e27679e8b6a68912b3f01c0297fd9e7", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -1042,6 +1042,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"enable incremental compilation (experimental)\"),\n     incremental_cc: bool = (false, parse_bool, [UNTRACKED],\n           \"enable cross-crate incremental compilation (even more experimental)\"),\n+    incremental_queries: bool = (true, parse_bool, [UNTRACKED],\n+          \"enable incremental compilation support for queries (experimental)\"),\n     incremental_info: bool = (false, parse_bool, [UNTRACKED],\n         \"print high-level information about incremental reuse (or the lack thereof)\"),\n     incremental_dump_hash: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "fbb14f39ade34d939edfe82c7af64ca7b4b7365e", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 155, "deletions": 2, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -19,7 +19,7 @@\n use hir::def_id::{DefId, CrateNum};\n use middle::const_val::ByteArray;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_serialize::{Decodable, Decoder, Encoder, Encodable};\n+use rustc_serialize::{Decodable, Decoder, Encoder, Encodable, opaque};\n use std::hash::Hash;\n use std::intrinsics;\n use ty::{self, Ty, TyCtxt};\n@@ -53,6 +53,13 @@ pub trait TyEncoder: Encoder {\n     fn position(&self) -> usize;\n }\n \n+impl<'buf> TyEncoder for opaque::Encoder<'buf> {\n+    #[inline]\n+    fn position(&self) -> usize {\n+        self.position()\n+    }\n+}\n+\n /// Encode the given value or a previously cached shorthand.\n pub fn encode_with_shorthand<E, T, M>(encoder: &mut E,\n                                       value: &T,\n@@ -113,6 +120,8 @@ pub trait TyDecoder<'a, 'tcx: 'a>: Decoder {\n \n     fn peek_byte(&self) -> u8;\n \n+    fn position(&self) -> usize;\n+\n     fn cached_ty_for_shorthand<F>(&mut self,\n                                   shorthand: usize,\n                                   or_insert_with: F)\n@@ -129,6 +138,7 @@ pub trait TyDecoder<'a, 'tcx: 'a>: Decoder {\n     }\n }\n \n+#[inline]\n pub fn decode_cnum<'a, 'tcx, D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n@@ -137,12 +147,12 @@ pub fn decode_cnum<'a, 'tcx, D>(decoder: &mut D) -> Result<CrateNum, D::Error>\n     Ok(decoder.map_encoded_cnum_to_current(cnum))\n }\n \n+#[inline]\n pub fn decode_ty<'a, 'tcx, D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n     // Handle shorthands first, if we have an usize > 0x80.\n-    // if self.opaque.data[self.opaque.position()] & 0x80 != 0 {\n     if decoder.positioned_at_shorthand() {\n         let pos = decoder.read_usize()?;\n         assert!(pos >= SHORTHAND_OFFSET);\n@@ -157,6 +167,7 @@ pub fn decode_ty<'a, 'tcx, D>(decoder: &mut D) -> Result<Ty<'tcx>, D::Error>\n     }\n }\n \n+#[inline]\n pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n                                       -> Result<ty::GenericPredicates<'tcx>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n@@ -180,6 +191,7 @@ pub fn decode_predicates<'a, 'tcx, D>(decoder: &mut D)\n     })\n }\n \n+#[inline]\n pub fn decode_substs<'a, 'tcx, D>(decoder: &mut D) -> Result<&'tcx Substs<'tcx>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n@@ -189,13 +201,15 @@ pub fn decode_substs<'a, 'tcx, D>(decoder: &mut D) -> Result<&'tcx Substs<'tcx>,\n     Ok(tcx.mk_substs((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n+#[inline]\n pub fn decode_region<'a, 'tcx, D>(decoder: &mut D) -> Result<ty::Region<'tcx>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n     Ok(decoder.tcx().mk_region(Decodable::decode(decoder)?))\n }\n \n+#[inline]\n pub fn decode_ty_slice<'a, 'tcx, D>(decoder: &mut D)\n                                     -> Result<&'tcx ty::Slice<Ty<'tcx>>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n@@ -205,6 +219,7 @@ pub fn decode_ty_slice<'a, 'tcx, D>(decoder: &mut D)\n     Ok(decoder.tcx().mk_type_list((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n+#[inline]\n pub fn decode_adt_def<'a, 'tcx, D>(decoder: &mut D)\n                                    -> Result<&'tcx ty::AdtDef, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n@@ -214,6 +229,7 @@ pub fn decode_adt_def<'a, 'tcx, D>(decoder: &mut D)\n     Ok(decoder.tcx().adt_def(def_id))\n }\n \n+#[inline]\n pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n     -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n@@ -224,6 +240,7 @@ pub fn decode_existential_predicate_slice<'a, 'tcx, D>(decoder: &mut D)\n               .mk_existential_predicates((0..len).map(|_| Decodable::decode(decoder)))?)\n }\n \n+#[inline]\n pub fn decode_byte_array<'a, 'tcx, D>(decoder: &mut D)\n                                       -> Result<ByteArray<'tcx>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n@@ -234,10 +251,146 @@ pub fn decode_byte_array<'a, 'tcx, D>(decoder: &mut D)\n     })\n }\n \n+#[inline]\n pub fn decode_const<'a, 'tcx, D>(decoder: &mut D)\n                                  -> Result<&'tcx ty::Const<'tcx>, D::Error>\n     where D: TyDecoder<'a, 'tcx>,\n           'tcx: 'a,\n {\n     Ok(decoder.tcx().mk_const(Decodable::decode(decoder)?))\n }\n+\n+#[macro_export]\n+macro_rules! __impl_decoder_methods {\n+    ($($name:ident -> $ty:ty;)*) => {\n+        $(fn $name(&mut self) -> Result<$ty, Self::Error> {\n+            self.opaque.$name()\n+        })*\n+    }\n+}\n+\n+#[macro_export]\n+macro_rules! implement_ty_decoder {\n+    ($DecoderName:ident <$($typaram:tt),*>) => {\n+        mod __ty_decoder_impl {\n+            use super::$DecoderName;\n+            use $crate::ty;\n+            use $crate::ty::codec::*;\n+            use $crate::ty::subst::Substs;\n+            use $crate::hir::def_id::{CrateNum};\n+            use $crate::middle::const_val::ByteArray;\n+            use rustc_serialize::{Decoder, SpecializedDecoder};\n+            use std::borrow::Cow;\n+\n+            impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {\n+                type Error = String;\n+\n+                __impl_decoder_methods! {\n+                    read_nil -> ();\n+\n+                    read_u128 -> u128;\n+                    read_u64 -> u64;\n+                    read_u32 -> u32;\n+                    read_u16 -> u16;\n+                    read_u8 -> u8;\n+                    read_usize -> usize;\n+\n+                    read_i128 -> i128;\n+                    read_i64 -> i64;\n+                    read_i32 -> i32;\n+                    read_i16 -> i16;\n+                    read_i8 -> i8;\n+                    read_isize -> isize;\n+\n+                    read_bool -> bool;\n+                    read_f64 -> f64;\n+                    read_f32 -> f32;\n+                    read_char -> char;\n+                    read_str -> Cow<str>;\n+                }\n+\n+                fn error(&mut self, err: &str) -> Self::Error {\n+                    self.opaque.error(err)\n+                }\n+            }\n+\n+            // FIXME(#36588) These impls are horribly unsound as they allow\n+            // the caller to pick any lifetime for 'tcx, including 'static,\n+            // by using the unspecialized proxies to them.\n+\n+            impl<$($typaram),*> SpecializedDecoder<CrateNum>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n+                    decode_cnum(self)\n+                }\n+            }\n+\n+            impl<$($typaram),*> SpecializedDecoder<ty::Ty<'tcx>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self) -> Result<ty::Ty<'tcx>, Self::Error> {\n+                    decode_ty(self)\n+                }\n+            }\n+\n+            impl<$($typaram),*> SpecializedDecoder<ty::GenericPredicates<'tcx>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self)\n+                                      -> Result<ty::GenericPredicates<'tcx>, Self::Error> {\n+                    decode_predicates(self)\n+                }\n+            }\n+\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx Substs<'tcx>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n+                    decode_substs(self)\n+                }\n+            }\n+\n+            impl<$($typaram),*> SpecializedDecoder<ty::Region<'tcx>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {\n+                    decode_region(self)\n+                }\n+            }\n+\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::Slice<ty::Ty<'tcx>>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self)\n+                                      -> Result<&'tcx ty::Slice<ty::Ty<'tcx>>, Self::Error> {\n+                    decode_ty_slice(self)\n+                }\n+            }\n+\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::AdtDef>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n+                    decode_adt_def(self)\n+                }\n+            }\n+\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>\n+                for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self)\n+                    -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n+                    decode_existential_predicate_slice(self)\n+                }\n+            }\n+\n+            impl<$($typaram),*> SpecializedDecoder<ByteArray<'tcx>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self) -> Result<ByteArray<'tcx>, Self::Error> {\n+                    decode_byte_array(self)\n+                }\n+            }\n+\n+            impl<$($typaram),*> SpecializedDecoder<&'tcx $crate::ty::Const<'tcx>>\n+            for $DecoderName<$($typaram),*> {\n+                fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+                    decode_const(self)\n+                }\n+            }\n+        }\n+    }\n+}\n+"}, {"sha": "22a3edd200c4fd0e70b5b9265caef334ed73d248", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -768,7 +768,7 @@ impl<'gcx> HashStable<StableHashingContext<'gcx>> for TypeckTables<'gcx> {\n                 };\n                 let closure_def_id = DefId {\n                     krate: local_id_root.krate,\n-                    index: closure_expr_id,\n+                    index: closure_expr_id.to_def_id().index,\n                 };\n                 (hcx.def_path_hash(var_owner_def_id),\n                  var_id.local_id,\n@@ -1306,9 +1306,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn serialize_query_result_cache<E>(self,\n                                            encoder: &mut E)\n                                            -> Result<(), E::Error>\n-        where E: ::rustc_serialize::Encoder\n+        where E: ty::codec::TyEncoder\n     {\n-        self.on_disk_query_result_cache.serialize(encoder)\n+        self.on_disk_query_result_cache.serialize(self.global_tcx(), self.cstore, encoder)\n     }\n \n }"}, {"sha": "066b80cefa4b5073a7d41ee83ee32c056470a228", "filename": "src/librustc/ty/maps/config.rs", "status": "modified", "additions": 111, "deletions": 84, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fconfig.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use dep_graph::SerializedDepNodeIndex;\n use hir::def_id::{CrateNum, DefId, DefIndex};\n use ty::{self, Ty, TyCtxt};\n use ty::maps::queries;\n@@ -23,11 +24,21 @@ pub trait QueryConfig {\n     type Value;\n }\n \n-pub(super) trait QueryDescription: QueryConfig {\n+pub(super) trait QueryDescription<'tcx>: QueryConfig {\n     fn describe(tcx: TyCtxt, key: Self::Key) -> String;\n+\n+    fn cache_on_disk(_: Self::Key) -> bool {\n+        false\n+    }\n+\n+    fn load_from_disk<'a>(_: TyCtxt<'a, 'tcx, 'tcx>,\n+                          _: SerializedDepNodeIndex)\n+                          -> Self::Value {\n+        bug!(\"QueryDescription::load_from_disk() called for unsupport query.\")\n+    }\n }\n \n-impl<M: QueryConfig<Key=DefId>> QueryDescription for M {\n+impl<'tcx, M: QueryConfig<Key=DefId>> QueryDescription<'tcx> for M {\n     default fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         if !tcx.sess.verbose() {\n             format!(\"processing `{}`\", tcx.item_path_str(def_id))\n@@ -38,503 +49,519 @@ impl<M: QueryConfig<Key=DefId>> QueryDescription for M {\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_copy_raw<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_copy_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing whether `{}` is `Copy`\", env.value)\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_sized_raw<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_sized_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing whether `{}` is `Sized`\", env.value)\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_freeze_raw<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_freeze_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing whether `{}` is freeze\", env.value)\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::needs_drop_raw<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::needs_drop_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing whether `{}` needs drop\", env.value)\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::layout_raw<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::layout_raw<'tcx> {\n     fn describe(_tcx: TyCtxt, env: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> String {\n         format!(\"computing layout of `{}`\", env.value)\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::super_predicates_of<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::super_predicates_of<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"computing the supertraits of `{}`\",\n                 tcx.item_path_str(def_id))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::erase_regions_ty<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::erase_regions_ty<'tcx> {\n     fn describe(_tcx: TyCtxt, ty: Ty<'tcx>) -> String {\n         format!(\"erasing regions from `{:?}`\", ty)\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::type_param_predicates<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::type_param_predicates<'tcx> {\n     fn describe(tcx: TyCtxt, (_, def_id): (DefId, DefId)) -> String {\n         let id = tcx.hir.as_local_node_id(def_id).unwrap();\n         format!(\"computing the bounds for type parameter `{}`\",\n                 tcx.hir.ty_param_name(id))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::coherent_trait<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::coherent_trait<'tcx> {\n     fn describe(tcx: TyCtxt, (_, def_id): (CrateNum, DefId)) -> String {\n         format!(\"coherence checking all impls of trait `{}`\",\n                 tcx.item_path_str(def_id))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::crate_inherent_impls<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls<'tcx> {\n     fn describe(_: TyCtxt, k: CrateNum) -> String {\n         format!(\"all inherent impls defined in crate `{:?}`\", k)\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::crate_inherent_impls_overlap_check<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::crate_inherent_impls_overlap_check<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n         format!(\"check for overlap between inherent impls defined in this crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::crate_variances<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::crate_variances<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"computing the variances for items in this crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::mir_shims<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::mir_shims<'tcx> {\n     fn describe(tcx: TyCtxt, def: ty::InstanceDef<'tcx>) -> String {\n         format!(\"generating MIR shim for `{}`\",\n                 tcx.item_path_str(def.def_id()))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::privacy_access_levels<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::privacy_access_levels<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n         format!(\"privacy access levels\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::typeck_item_bodies<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::typeck_item_bodies<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n         format!(\"type-checking all item bodies\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::reachable_set<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::reachable_set<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n         format!(\"reachability\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::const_eval<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::const_eval<'tcx> {\n     fn describe(tcx: TyCtxt, key: ty::ParamEnvAnd<'tcx, (DefId, &'tcx Substs<'tcx>)>) -> String {\n         format!(\"const-evaluating `{}`\", tcx.item_path_str(key.value.0))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::mir_keys<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::mir_keys<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n         format!(\"getting a list of all mir_keys\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::symbol_name<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::symbol_name<'tcx> {\n     fn describe(_tcx: TyCtxt, instance: ty::Instance<'tcx>) -> String {\n         format!(\"computing the symbol for `{}`\", instance)\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::describe_def<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::describe_def<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"describe_def\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::def_span<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::def_span<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"def_span\")\n     }\n }\n \n \n-impl<'tcx> QueryDescription for queries::lookup_stability<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::lookup_stability<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"stability\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::lookup_deprecation_entry<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::lookup_deprecation_entry<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"deprecation\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::item_attrs<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::item_attrs<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"item_attrs\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_exported_symbol<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_exported_symbol<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"is_exported_symbol\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::fn_arg_names<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::fn_arg_names<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"fn_arg_names\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::impl_parent<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::impl_parent<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"impl_parent\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::trait_of_item<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::trait_of_item<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         bug!(\"trait_of_item\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::item_body_nested_bodies<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::item_body_nested_bodies<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"nested item bodies of `{}`\", tcx.item_path_str(def_id))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::const_is_rvalue_promotable_to_static<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::const_is_rvalue_promotable_to_static<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"const checking if rvalue is promotable to static `{}`\",\n             tcx.item_path_str(def_id))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::rvalue_promotable_map<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::rvalue_promotable_map<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"checking which parts of `{}` are promotable to static\",\n                 tcx.item_path_str(def_id))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_mir_available<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"checking if item is mir available: `{}`\",\n             tcx.item_path_str(def_id))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::trans_fulfill_obligation<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::trans_fulfill_obligation<'tcx> {\n     fn describe(tcx: TyCtxt, key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)) -> String {\n         format!(\"checking if `{}` fulfills its obligations\", tcx.item_path_str(key.1.def_id()))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::trait_impls_of<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_object_safe<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_const_fn<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_const_fn<'tcx> {\n     fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n         format!(\"checking if item is const fn: `{}`\", tcx.item_path_str(def_id))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::dylib_dependency_formats<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::dylib_dependency_formats<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"dylib dependency formats of crate\".to_string()\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_panic_runtime<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_panic_runtime<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"checking if the crate is_panic_runtime\".to_string()\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_compiler_builtins<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_compiler_builtins<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"checking if the crate is_compiler_builtins\".to_string()\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::has_global_allocator<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::has_global_allocator<'tcx> {\n     fn describe(_: TyCtxt, _: CrateNum) -> String {\n         \"checking if the crate has_global_allocator\".to_string()\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::extern_crate<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::extern_crate<'tcx> {\n     fn describe(_: TyCtxt, _: DefId) -> String {\n         \"getting crate's ExternCrateData\".to_string()\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::lint_levels<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::lint_levels<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"computing the lint levels for items in this crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::specializes<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::specializes<'tcx> {\n     fn describe(_tcx: TyCtxt, _: (DefId, DefId)) -> String {\n         format!(\"computing whether impls specialize one another\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::in_scope_traits_map<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::in_scope_traits_map<'tcx> {\n     fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n         format!(\"traits in scope at a block\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_no_builtins<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_no_builtins<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"test whether a crate has #![no_builtins]\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::panic_strategy<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::panic_strategy<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"query a crate's configured panic strategy\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_profiler_runtime<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_profiler_runtime<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"query a crate is #![profiler_runtime]\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_sanitizer_runtime<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_sanitizer_runtime<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"query a crate is #![sanitizer_runtime]\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::exported_symbol_ids<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::exported_symbol_ids<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the exported symbols of a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::native_libraries<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::native_libraries<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the native libraries of a linked crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::plugin_registrar_fn<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::plugin_registrar_fn<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the plugin registrar for a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::derive_registrar_fn<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::derive_registrar_fn<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the derive registrar for a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::crate_disambiguator<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::crate_disambiguator<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the disambiguator a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::crate_hash<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::crate_hash<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the hash a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::original_crate_name<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::original_crate_name<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up the original name a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::implementations_of_trait<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::implementations_of_trait<'tcx> {\n     fn describe(_tcx: TyCtxt, _: (CrateNum, DefId)) -> String {\n         format!(\"looking up implementations of a trait in a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::all_trait_implementations<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::all_trait_implementations<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up all (?) trait implementations\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::link_args<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::link_args<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up link arguments for a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::named_region_map<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::named_region_map<'tcx> {\n     fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n         format!(\"looking up a named region\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::is_late_bound_map<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::is_late_bound_map<'tcx> {\n     fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n         format!(\"testing if a region is late boudn\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::object_lifetime_defaults_map<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::object_lifetime_defaults_map<'tcx> {\n     fn describe(_tcx: TyCtxt, _: DefIndex) -> String {\n         format!(\"looking up lifetime defaults for a region\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::dep_kind<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::dep_kind<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"fetching what a dependency looks like\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::crate_name<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::crate_name<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"fetching what a crate is named\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::get_lang_items<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::get_lang_items<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"calculating the lang items map\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::defined_lang_items<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::defined_lang_items<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"calculating the lang items defined in a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::missing_lang_items<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::missing_lang_items<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"calculating the missing lang items in a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::visible_parent_map<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::visible_parent_map<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"calculating the visible parent map\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::missing_extern_crate_item<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::missing_extern_crate_item<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"seeing if we're missing an `extern crate` item for this crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::used_crate_source<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::used_crate_source<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking at the source for a crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::postorder_cnums<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::postorder_cnums<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"generating a postorder list of CrateNums\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::maybe_unused_extern_crates<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::maybe_unused_extern_crates<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"looking up all possibly unused extern crates\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::stability_index<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::stability_index<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"calculating the stability index for the local crate\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::all_crate_nums<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::all_crate_nums<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"fetching all foreign CrateNum instances\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::exported_symbols<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::exported_symbols<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"exported_symbols\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::collect_and_partition_translation_items<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::collect_and_partition_translation_items<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"collect_and_partition_translation_items\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::codegen_unit<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::codegen_unit<'tcx> {\n     fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n         format!(\"codegen_unit\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::compile_codegen_unit<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::compile_codegen_unit<'tcx> {\n     fn describe(_tcx: TyCtxt, _: InternedString) -> String {\n         format!(\"compile_codegen_unit\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::output_filenames<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::output_filenames<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"output_filenames\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::has_clone_closures<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::has_clone_closures<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"seeing if the crate has enabled `Clone` closures\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::vtable_methods<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::vtable_methods<'tcx> {\n     fn describe(tcx: TyCtxt, key: ty::PolyTraitRef<'tcx> ) -> String {\n         format!(\"finding all methods for trait {}\", tcx.item_path_str(key.def_id()))\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::has_copy_closures<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::has_copy_closures<'tcx> {\n     fn describe(_tcx: TyCtxt, _: CrateNum) -> String {\n         format!(\"seeing if the crate has enabled `Copy` closures\")\n     }\n }\n \n-impl<'tcx> QueryDescription for queries::fully_normalize_monormophic_ty<'tcx> {\n+impl<'tcx> QueryDescription<'tcx> for queries::fully_normalize_monormophic_ty<'tcx> {\n     fn describe(_tcx: TyCtxt, _: Ty) -> String {\n         format!(\"normalizing types\")\n     }\n }\n+\n+impl<'tcx> QueryDescription<'tcx> for queries::typeck_tables_of<'tcx> {\n+    #[inline]\n+    fn cache_on_disk(def_id: Self::Key) -> bool {\n+        def_id.is_local()\n+    }\n+\n+    fn load_from_disk<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                          id: SerializedDepNodeIndex)\n+                          -> Self::Value {\n+        let typeck_tables: ty::TypeckTables<'tcx> = tcx.on_disk_query_result_cache\n+                                                       .load_query_result(tcx, id);\n+        tcx.alloc_tables(typeck_tables)\n+    }\n+}\n+"}, {"sha": "53ca9b3851d5e928d66b365f0d8e96655de1c390", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 598, "deletions": 67, "changes": 665, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -9,112 +9,225 @@\n // except according to those terms.\n \n use dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_vec::Idx;\n use errors::Diagnostic;\n+use hir;\n+use hir::def_id::{CrateNum, DefIndex, DefId, LocalDefId,\n+                  RESERVED_FOR_INCR_COMP_CACHE, LOCAL_CRATE};\n+use hir::map::definitions::DefPathHash;\n+use middle::cstore::CrateStore;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n-                      SpecializedDecoder};\n-use session::Session;\n-use std::borrow::Cow;\n+                      SpecializedDecoder, SpecializedEncoder,\n+                      UseSpecializedDecodable, UseSpecializedEncodable};\n+use session::{CrateDisambiguator, Session};\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n use std::mem;\n+use syntax::ast::NodeId;\n use syntax::codemap::{CodeMap, StableFilemapId};\n use syntax_pos::{BytePos, Span, NO_EXPANSION, DUMMY_SP};\n+use ty;\n+use ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n+use ty::context::TyCtxt;\n+\n+// Some magic values used for verifying that encoding and decoding. These are\n+// basically random numbers.\n+const PREV_DIAGNOSTICS_TAG: u64 = 0x1234_5678_A1A1_A1A1;\n+const QUERY_RESULT_INDEX_TAG: u64 = 0x1234_5678_C3C3_C3C3;\n \n /// `OnDiskCache` provides an interface to incr. comp. data cached from the\n /// previous compilation session. This data will eventually include the results\n /// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n /// any diagnostics that have been emitted during a query.\n pub struct OnDiskCache<'sess> {\n+\n+    // The complete cache data in serialized form.\n+    serialized_data: Vec<u8>,\n+\n     // The diagnostics emitted during the previous compilation session.\n     prev_diagnostics: FxHashMap<SerializedDepNodeIndex, Vec<Diagnostic>>,\n \n     // This field collects all Diagnostics emitted during the current\n     // compilation session.\n     current_diagnostics: RefCell<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n \n-    // This will eventually be needed for creating Decoders that can rebase\n-    // spans.\n-    _prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n+    prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n+    cnum_map: RefCell<Option<IndexVec<CrateNum, Option<CrateNum>>>>,\n+\n+    prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n     codemap: &'sess CodeMap,\n+\n+    // A map from dep-node to the position of the cached query result in\n+    // `serialized_data`.\n+    query_result_index: FxHashMap<SerializedDepNodeIndex, usize>,\n }\n \n // This type is used only for (de-)serialization.\n #[derive(RustcEncodable, RustcDecodable)]\n struct Header {\n     prev_filemap_starts: BTreeMap<BytePos, StableFilemapId>,\n+    prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n }\n \n-// This type is used only for (de-)serialization.\n-#[derive(RustcEncodable, RustcDecodable)]\n-struct Body {\n-    diagnostics: Vec<(SerializedDepNodeIndex, Vec<Diagnostic>)>,\n-}\n+type EncodedPrevDiagnostics = Vec<(SerializedDepNodeIndex, Vec<Diagnostic>)>;\n+type EncodedQueryResultIndex = Vec<(SerializedDepNodeIndex, usize)>;\n \n impl<'sess> OnDiskCache<'sess> {\n     /// Create a new OnDiskCache instance from the serialized data in `data`.\n-    /// Note that the current implementation (which only deals with diagnostics\n-    /// so far) will eagerly deserialize the complete cache. Once we are\n-    /// dealing with larger amounts of data (i.e. cached query results),\n-    /// deserialization will need to happen lazily.\n-    pub fn new(sess: &'sess Session, data: &[u8]) -> OnDiskCache<'sess> {\n+    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> OnDiskCache<'sess> {\n         debug_assert!(sess.opts.incremental.is_some());\n \n-        let mut decoder = opaque::Decoder::new(&data[..], 0);\n-        let header = Header::decode(&mut decoder).unwrap();\n+        // Decode the header\n+        let (header, post_header_pos) = {\n+            let mut decoder = opaque::Decoder::new(&data[..], start_pos);\n+            let header = Header::decode(&mut decoder)\n+                .expect(\"Error while trying to decode incr. comp. cache header.\");\n+            (header, decoder.position())\n+        };\n \n-        let prev_diagnostics: FxHashMap<_, _> = {\n+        let (prev_diagnostics, query_result_index) = {\n             let mut decoder = CacheDecoder {\n-                opaque: decoder,\n+                tcx: None,\n+                opaque: opaque::Decoder::new(&data[..], post_header_pos),\n                 codemap: sess.codemap(),\n                 prev_filemap_starts: &header.prev_filemap_starts,\n+                cnum_map: &IndexVec::new(),\n+            };\n+\n+            // Decode Diagnostics\n+            let prev_diagnostics: FxHashMap<_, _> = {\n+                let diagnostics: EncodedPrevDiagnostics =\n+                    decode_tagged(&mut decoder, PREV_DIAGNOSTICS_TAG)\n+                        .expect(\"Error while trying to decode previous session \\\n+                                 diagnostics from incr. comp. cache.\");\n+                diagnostics.into_iter().collect()\n+            };\n+\n+            // Decode the *position* of the query result index\n+            let query_result_index_pos = {\n+                let pos_pos = data.len() - IntEncodedWithFixedSize::ENCODED_SIZE;\n+                decoder.with_position(pos_pos, |decoder| {\n+                    IntEncodedWithFixedSize::decode(decoder)\n+                }).expect(\"Error while trying to decode query result index position.\")\n+                .0 as usize\n             };\n-            let body = Body::decode(&mut decoder).unwrap();\n-            body.diagnostics.into_iter().collect()\n+\n+            // Decode the query result index itself\n+            let query_result_index: EncodedQueryResultIndex =\n+                decoder.with_position(query_result_index_pos, |decoder| {\n+                    decode_tagged(decoder, QUERY_RESULT_INDEX_TAG)\n+                }).expect(\"Error while trying to decode query result index.\");\n+\n+            (prev_diagnostics, query_result_index)\n         };\n \n         OnDiskCache {\n+            serialized_data: data,\n             prev_diagnostics,\n-            _prev_filemap_starts: header.prev_filemap_starts,\n+            prev_filemap_starts: header.prev_filemap_starts,\n+            prev_cnums: header.prev_cnums,\n+            cnum_map: RefCell::new(None),\n             codemap: sess.codemap(),\n             current_diagnostics: RefCell::new(FxHashMap()),\n+            query_result_index: query_result_index.into_iter().collect(),\n         }\n     }\n \n     pub fn new_empty(codemap: &'sess CodeMap) -> OnDiskCache<'sess> {\n         OnDiskCache {\n+            serialized_data: Vec::new(),\n             prev_diagnostics: FxHashMap(),\n-            _prev_filemap_starts: BTreeMap::new(),\n+            prev_filemap_starts: BTreeMap::new(),\n+            prev_cnums: vec![],\n+            cnum_map: RefCell::new(None),\n             codemap,\n             current_diagnostics: RefCell::new(FxHashMap()),\n+            query_result_index: FxHashMap(),\n         }\n     }\n \n     pub fn serialize<'a, 'tcx, E>(&self,\n+                                  tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                  cstore: &CrateStore,\n                                   encoder: &mut E)\n                                   -> Result<(), E::Error>\n-        where E: Encoder\n-    {\n+        where E: ty_codec::TyEncoder\n+     {\n+        // Serializing the DepGraph should not modify it:\n+        let _in_ignore = tcx.dep_graph.in_ignore();\n+\n+        let mut encoder = CacheEncoder {\n+            tcx,\n+            encoder,\n+            type_shorthands: FxHashMap(),\n+            predicate_shorthands: FxHashMap(),\n+        };\n+\n+\n+        // Encode the file header\n         let prev_filemap_starts: BTreeMap<_, _> = self\n             .codemap\n             .files()\n             .iter()\n             .map(|fm| (fm.start_pos, StableFilemapId::new(fm)))\n             .collect();\n \n-        Header { prev_filemap_starts }.encode(encoder)?;\n+        let sorted_cnums = sorted_cnums_including_local_crate(cstore);\n+\n+        let prev_cnums: Vec<_> = sorted_cnums.iter().map(|&cnum| {\n+            let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n+            let crate_disambiguator = tcx.crate_disambiguator(cnum);\n+            (cnum.as_u32(), crate_name, crate_disambiguator)\n+        }).collect();\n+\n+        Header {\n+            prev_filemap_starts,\n+            prev_cnums,\n+        }.encode(&mut encoder)?;\n+\n \n-        let diagnostics: Vec<(SerializedDepNodeIndex, Vec<Diagnostic>)> =\n+        // Encode Diagnostics\n+        let diagnostics: EncodedPrevDiagnostics =\n             self.current_diagnostics\n                 .borrow()\n                 .iter()\n                 .map(|(k, v)| (SerializedDepNodeIndex::new(k.index()), v.clone()))\n                 .collect();\n \n-        Body { diagnostics }.encode(encoder)?;\n+        encoder.encode_tagged(PREV_DIAGNOSTICS_TAG, &diagnostics)?;\n \n-        Ok(())\n+\n+        // Encode query results\n+        let mut query_result_index = EncodedQueryResultIndex::new();\n+\n+        {\n+            use ty::maps::queries::*;\n+            let enc = &mut encoder;\n+            let qri = &mut query_result_index;\n+\n+            // Encode TypeckTables\n+            encode_query_results::<typeck_tables_of, _>(tcx, enc, qri)?;\n+        }\n+\n+        // Encode query result index\n+        let query_result_index_pos = encoder.position() as u64;\n+        encoder.encode_tagged(QUERY_RESULT_INDEX_TAG, &query_result_index)?;\n+\n+        // Encode the position of the query result index as the last 8 bytes of\n+        // file so we know where to look for it.\n+        IntEncodedWithFixedSize(query_result_index_pos).encode(&mut encoder)?;\n+\n+        return Ok(());\n+\n+        fn sorted_cnums_including_local_crate(cstore: &CrateStore) -> Vec<CrateNum> {\n+            let mut cnums = vec![LOCAL_CRATE];\n+            cnums.extend_from_slice(&cstore.crates_untracked()[..]);\n+            cnums.sort_unstable();\n+            // Just to be sure...\n+            cnums.dedup();\n+            cnums\n+        }\n     }\n \n     /// Load a diagnostic emitted during the previous compilation session.\n@@ -135,6 +248,37 @@ impl<'sess> OnDiskCache<'sess> {\n         debug_assert!(prev.is_none());\n     }\n \n+    pub fn load_query_result<'a, 'tcx, T>(&self,\n+                                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                          dep_node_index: SerializedDepNodeIndex)\n+                                          -> T\n+        where T: Decodable\n+    {\n+        let pos = self.query_result_index[&dep_node_index];\n+\n+        let mut cnum_map = self.cnum_map.borrow_mut();\n+        if cnum_map.is_none() {\n+            *cnum_map = Some(Self::compute_cnum_map(tcx, &self.prev_cnums[..]));\n+        }\n+\n+        let mut decoder = CacheDecoder {\n+            tcx: Some(tcx),\n+            opaque: opaque::Decoder::new(&self.serialized_data[..], pos),\n+            codemap: self.codemap,\n+            prev_filemap_starts: &self.prev_filemap_starts,\n+            cnum_map: cnum_map.as_ref().unwrap(),\n+        };\n+\n+        match decode_tagged(&mut decoder, dep_node_index) {\n+            Ok(value) => {\n+                value\n+            }\n+            Err(e) => {\n+                bug!(\"Could not decode cached query result: {}\", e)\n+            }\n+        }\n+    }\n+\n     /// Store a diagnostic emitted during computation of an anonymous query.\n     /// Since many anonymous queries can share the same `DepNode`, we aggregate\n     /// them -- as opposed to regular queries where we assume that there is a\n@@ -150,18 +294,57 @@ impl<'sess> OnDiskCache<'sess> {\n \n         x.extend(diagnostics.into_iter());\n     }\n+\n+    // This function builds mapping from previous-session-CrateNum to\n+    // current-session-CrateNum. There might be CrateNums from the previous\n+    // Session that don't occur in the current one. For these, the mapping\n+    // maps to None.\n+    fn compute_cnum_map(tcx: TyCtxt,\n+                        prev_cnums: &[(u32, String, CrateDisambiguator)])\n+                        -> IndexVec<CrateNum, Option<CrateNum>>\n+    {\n+        let _in_ignore = tcx.dep_graph.in_ignore();\n+\n+        let current_cnums = tcx.all_crate_nums(LOCAL_CRATE).iter().map(|&cnum| {\n+            let crate_name = tcx.original_crate_name(cnum)\n+                                .as_str()\n+                                .to_string();\n+            let crate_disambiguator = tcx.crate_disambiguator(cnum);\n+            ((crate_name, crate_disambiguator), cnum)\n+        }).collect::<FxHashMap<_,_>>();\n+\n+        let map_size = prev_cnums.iter()\n+                                 .map(|&(cnum, ..)| cnum)\n+                                 .max()\n+                                 .unwrap_or(0) + 1;\n+        let mut map = IndexVec::new();\n+        map.resize(map_size as usize, None);\n+\n+        for &(prev_cnum, ref crate_name, crate_disambiguator) in prev_cnums {\n+            let key = (crate_name.clone(), crate_disambiguator);\n+            map[CrateNum::from_u32(prev_cnum)] = current_cnums.get(&key).cloned();\n+        }\n+\n+        map[LOCAL_CRATE] = Some(LOCAL_CRATE);\n+        map\n+    }\n }\n \n+\n+//- DECODING -------------------------------------------------------------------\n+\n /// A decoder that can read the incr. comp. cache. It is similar to the one\n /// we use for crate metadata decoding in that it can rebase spans and\n /// eventually will also handle things that contain `Ty` instances.\n-struct CacheDecoder<'a> {\n-    opaque: opaque::Decoder<'a>,\n-    codemap: &'a CodeMap,\n-    prev_filemap_starts: &'a BTreeMap<BytePos, StableFilemapId>,\n+struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n+    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    opaque: opaque::Decoder<'x>,\n+    codemap: &'x CodeMap,\n+    prev_filemap_starts: &'x BTreeMap<BytePos, StableFilemapId>,\n+    cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n }\n \n-impl<'a> CacheDecoder<'a> {\n+impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n     fn find_filemap_prev_bytepos(&self,\n                                  prev_bytepos: BytePos)\n                                  -> Option<(BytePos, StableFilemapId)> {\n@@ -173,47 +356,91 @@ impl<'a> CacheDecoder<'a> {\n     }\n }\n \n-macro_rules! decoder_methods {\n-    ($($name:ident -> $ty:ty;)*) => {\n-        $(fn $name(&mut self) -> Result<$ty, Self::Error> {\n-            self.opaque.$name()\n-        })*\n-    }\n+// Decode something that was encoded with encode_tagged() and verify that the\n+// tag matches and the correct amount of bytes was read.\n+fn decode_tagged<'a, 'tcx, D, T, V>(decoder: &mut D,\n+                                    expected_tag: T)\n+                                    -> Result<V, D::Error>\n+    where T: Decodable + Eq + ::std::fmt::Debug,\n+          V: Decodable,\n+          D: Decoder + ty_codec::TyDecoder<'a, 'tcx>,\n+          'tcx: 'a,\n+{\n+    let start_pos = decoder.position();\n+\n+    let actual_tag = T::decode(decoder)?;\n+    assert_eq!(actual_tag, expected_tag);\n+    let value = V::decode(decoder)?;\n+    let end_pos = decoder.position();\n+\n+    let expected_len: u64 = Decodable::decode(decoder)?;\n+    assert_eq!((end_pos - start_pos) as u64, expected_len);\n+\n+    Ok(value)\n }\n \n-impl<'sess> Decoder for CacheDecoder<'sess> {\n-    type Error = String;\n \n-    decoder_methods! {\n-        read_nil -> ();\n+impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx, 'x> {\n+\n+    #[inline]\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx.expect(\"missing TyCtxt in CacheDecoder\")\n+    }\n+\n+    #[inline]\n+    fn position(&self) -> usize {\n+        self.opaque.position()\n+    }\n+\n+    #[inline]\n+    fn peek_byte(&self) -> u8 {\n+        self.opaque.data[self.opaque.position()]\n+    }\n+\n+    fn cached_ty_for_shorthand<F>(&mut self,\n+                                  shorthand: usize,\n+                                  or_insert_with: F)\n+                                  -> Result<ty::Ty<'tcx>, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<ty::Ty<'tcx>, Self::Error>\n+    {\n+        let tcx = self.tcx();\n+\n+        let cache_key = ty::CReaderCacheKey {\n+            cnum: RESERVED_FOR_INCR_COMP_CACHE,\n+            pos: shorthand,\n+        };\n+\n+        if let Some(&ty) = tcx.rcache.borrow().get(&cache_key) {\n+            return Ok(ty);\n+        }\n \n-        read_u128 -> u128;\n-        read_u64 -> u64;\n-        read_u32 -> u32;\n-        read_u16 -> u16;\n-        read_u8 -> u8;\n-        read_usize -> usize;\n+        let ty = or_insert_with(self)?;\n+        tcx.rcache.borrow_mut().insert(cache_key, ty);\n+        Ok(ty)\n+    }\n \n-        read_i128 -> i128;\n-        read_i64 -> i64;\n-        read_i32 -> i32;\n-        read_i16 -> i16;\n-        read_i8 -> i8;\n-        read_isize -> isize;\n+    fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n+        where F: FnOnce(&mut Self) -> R\n+    {\n+        debug_assert!(pos < self.opaque.data.len());\n \n-        read_bool -> bool;\n-        read_f64 -> f64;\n-        read_f32 -> f32;\n-        read_char -> char;\n-        read_str -> Cow<str>;\n+        let new_opaque = opaque::Decoder::new(self.opaque.data, pos);\n+        let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n+        let r = f(self);\n+        self.opaque = old_opaque;\n+        r\n     }\n \n-    fn error(&mut self, err: &str) -> Self::Error {\n-        self.opaque.error(err)\n+    fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n+        self.cnum_map[cnum].unwrap_or_else(|| {\n+            bug!(\"Could not find new CrateNum for {:?}\", cnum)\n+        })\n     }\n }\n \n-impl<'a> SpecializedDecoder<Span> for CacheDecoder<'a> {\n+implement_ty_decoder!( CacheDecoder<'a, 'tcx, 'x> );\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n         let lo = BytePos::decode(self)?;\n         let hi = BytePos::decode(self)?;\n@@ -229,3 +456,307 @@ impl<'a> SpecializedDecoder<Span> for CacheDecoder<'a> {\n         Ok(DUMMY_SP)\n     }\n }\n+\n+// This impl makes sure that we get a runtime error when we try decode a\n+// DefIndex that is not contained in a DefId. Such a case would be problematic\n+// because we would not know how to transform the DefIndex to the current\n+// context.\n+impl<'a, 'tcx, 'x> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n+        bug!(\"Trying to decode DefIndex outside the context of a DefId\")\n+    }\n+}\n+\n+// Both the CrateNum and the DefIndex of a DefId can change in between two\n+// compilation sessions. We use the DefPathHash, which is stable across\n+// sessions, to map the old DefId to the new one.\n+impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n+        // Load the DefPathHash which is was we encoded the DefId as.\n+        let def_path_hash = DefPathHash::decode(self)?;\n+\n+        // Using the DefPathHash, we can lookup the new DefId\n+        Ok(self.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<LocalDefId, Self::Error> {\n+        Ok(LocalDefId::from_def_id(DefId::decode(self)?))\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<hir::HirId, Self::Error> {\n+        // Load the DefPathHash which is was we encoded the DefIndex as.\n+        let def_path_hash = DefPathHash::decode(self)?;\n+\n+        // Use the DefPathHash to map to the current DefId.\n+        let def_id = self.tcx()\n+                         .def_path_hash_to_def_id\n+                         .as_ref()\n+                         .unwrap()[&def_path_hash];\n+\n+        debug_assert!(def_id.is_local());\n+\n+        // The ItemLocalId needs no remapping.\n+        let local_id = hir::ItemLocalId::decode(self)?;\n+\n+        // Reconstruct the HirId and look up the corresponding NodeId in the\n+        // context of the current session.\n+        Ok(hir::HirId {\n+            owner: def_id.index,\n+            local_id\n+        })\n+    }\n+}\n+\n+// NodeIds are not stable across compilation sessions, so we store them in their\n+// HirId representation. This allows use to map them to the current NodeId.\n+impl<'a, 'tcx, 'x> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n+        let hir_id = hir::HirId::decode(self)?;\n+        Ok(self.tcx().hir.hir_to_node_id(hir_id))\n+    }\n+}\n+\n+//- ENCODING -------------------------------------------------------------------\n+\n+struct CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder,\n+          'tcx: 'a,\n+{\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    encoder: &'enc mut E,\n+    type_shorthands: FxHashMap<ty::Ty<'tcx>, usize>,\n+    predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n+}\n+\n+impl<'enc, 'a, 'tcx, E> CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    /// Encode something with additional information that allows to do some\n+    /// sanity checks when decoding the data again. This method will first\n+    /// encode the specified tag, then the given value, then the number of\n+    /// bytes taken up by tag and value. On decoding, we can then verify that\n+    /// we get the expected tag and read the expected number of bytes.\n+    fn encode_tagged<T: Encodable, V: Encodable>(&mut self,\n+                                                 tag: T,\n+                                                 value: &V)\n+                                                 -> Result<(), E::Error>\n+    {\n+        use ty::codec::TyEncoder;\n+        let start_pos = self.position();\n+\n+        tag.encode(self)?;\n+        value.encode(self)?;\n+\n+        let end_pos = self.position();\n+        ((end_pos - start_pos) as u64).encode(self)\n+    }\n+}\n+\n+impl<'enc, 'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    #[inline]\n+    fn position(&self) -> usize {\n+        self.encoder.position()\n+    }\n+}\n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    #[inline]\n+    fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n+        self.emit_u32(cnum.as_u32())\n+    }\n+}\n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<ty::Ty<'tcx>> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    #[inline]\n+    fn specialized_encode(&mut self, ty: &ty::Ty<'tcx>) -> Result<(), Self::Error> {\n+        ty_codec::encode_with_shorthand(self, ty,\n+            |encoder| &mut encoder.type_shorthands)\n+    }\n+}\n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n+    for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    #[inline]\n+    fn specialized_encode(&mut self,\n+                          predicates: &ty::GenericPredicates<'tcx>)\n+                          -> Result<(), Self::Error> {\n+        ty_codec::encode_predicates(self, predicates,\n+            |encoder| &mut encoder.predicate_shorthands)\n+    }\n+}\n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    #[inline]\n+    fn specialized_encode(&mut self, id: &hir::HirId) -> Result<(), Self::Error> {\n+        let hir::HirId {\n+            owner,\n+            local_id,\n+        } = *id;\n+\n+        let def_path_hash = self.tcx.hir.definitions().def_path_hash(owner);\n+\n+        def_path_hash.encode(self)?;\n+        local_id.encode(self)\n+    }\n+}\n+\n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    #[inline]\n+    fn specialized_encode(&mut self, id: &DefId) -> Result<(), Self::Error> {\n+        let def_path_hash = self.tcx.def_path_hash(*id);\n+        def_path_hash.encode(self)\n+    }\n+}\n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    #[inline]\n+    fn specialized_encode(&mut self, id: &LocalDefId) -> Result<(), Self::Error> {\n+        id.to_def_id().encode(self)\n+    }\n+}\n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    fn specialized_encode(&mut self, _: &DefIndex) -> Result<(), Self::Error> {\n+        bug!(\"Encoding DefIndex without context.\")\n+    }\n+}\n+\n+// NodeIds are not stable across compilation sessions, so we store them in their\n+// HirId representation. This allows use to map them to the current NodeId.\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    #[inline]\n+    fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n+        let hir_id = self.tcx.hir.node_to_hir_id(*node_id);\n+        hir_id.encode(self)\n+    }\n+}\n+\n+macro_rules! encoder_methods {\n+    ($($name:ident($ty:ty);)*) => {\n+        $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {\n+            self.encoder.$name(value)\n+        })*\n+    }\n+}\n+\n+impl<'enc, 'a, 'tcx, E> Encoder for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    type Error = E::Error;\n+\n+    fn emit_nil(&mut self) -> Result<(), Self::Error> {\n+        Ok(())\n+    }\n+\n+    encoder_methods! {\n+        emit_usize(usize);\n+        emit_u128(u128);\n+        emit_u64(u64);\n+        emit_u32(u32);\n+        emit_u16(u16);\n+        emit_u8(u8);\n+\n+        emit_isize(isize);\n+        emit_i128(i128);\n+        emit_i64(i64);\n+        emit_i32(i32);\n+        emit_i16(i16);\n+        emit_i8(i8);\n+\n+        emit_bool(bool);\n+        emit_f64(f64);\n+        emit_f32(f32);\n+        emit_char(char);\n+        emit_str(&str);\n+    }\n+}\n+\n+// An integer that will always encode to 8 bytes.\n+struct IntEncodedWithFixedSize(u64);\n+\n+impl IntEncodedWithFixedSize {\n+    pub const ENCODED_SIZE: usize = 8;\n+}\n+\n+impl UseSpecializedEncodable for IntEncodedWithFixedSize {}\n+impl UseSpecializedDecodable for IntEncodedWithFixedSize {}\n+\n+impl<'enc, 'a, 'tcx, E> SpecializedEncoder<IntEncodedWithFixedSize>\n+for CacheEncoder<'enc, 'a, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    fn specialized_encode(&mut self, x: &IntEncodedWithFixedSize) -> Result<(), Self::Error> {\n+        let start_pos = self.position();\n+        for i in 0 .. IntEncodedWithFixedSize::ENCODED_SIZE {\n+            ((x.0 >> i * 8) as u8).encode(self)?;\n+        }\n+        let end_pos = self.position();\n+        assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<IntEncodedWithFixedSize>\n+for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<IntEncodedWithFixedSize, Self::Error> {\n+        let mut value: u64 = 0;\n+        let start_pos = self.position();\n+\n+        for i in 0 .. IntEncodedWithFixedSize::ENCODED_SIZE {\n+            let byte: u8 = Decodable::decode(self)?;\n+            value |= (byte as u64) << (i * 8);\n+        }\n+\n+        let end_pos = self.position();\n+        assert_eq!((end_pos - start_pos), IntEncodedWithFixedSize::ENCODED_SIZE);\n+\n+        Ok(IntEncodedWithFixedSize(value))\n+    }\n+}\n+\n+fn encode_query_results<'enc, 'a, 'tcx, Q, E>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                              encoder: &mut CacheEncoder<'enc, 'a, 'tcx, E>,\n+                                              query_result_index: &mut EncodedQueryResultIndex)\n+                                              -> Result<(), E::Error>\n+    where Q: super::plumbing::GetCacheInternal<'tcx>,\n+          E: 'enc + TyEncoder,\n+          Q::Value: Encodable,\n+{\n+    for (key, entry) in Q::get_cache_internal(tcx).map.iter() {\n+        if Q::cache_on_disk(key.clone()) {\n+            let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n+\n+            // Record position of the cache entry\n+            query_result_index.push((dep_node, encoder.position()));\n+\n+            // Encode the type check tables with the SerializedDepNodeIndex\n+            // as tag.\n+            encoder.encode_tagged(dep_node, &entry.value)?;\n+        }\n+    }\n+\n+    Ok(())\n+}"}, {"sha": "1ca8fc6eb480f4706a2f11dd22c7cd0b09feff15", "filename": "src/librustc/ty/maps/plumbing.rs", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fplumbing.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -20,13 +20,13 @@ use ty::maps::config::QueryDescription;\n use ty::item_path;\n \n use rustc_data_structures::fx::{FxHashMap};\n-use std::cell::RefMut;\n+use std::cell::{Ref, RefMut};\n use std::marker::PhantomData;\n use std::mem;\n use syntax_pos::Span;\n \n-pub(super) struct QueryMap<D: QueryDescription> {\n-    phantom: PhantomData<D>,\n+pub(super) struct QueryMap<'tcx, D: QueryDescription<'tcx>> {\n+    phantom: PhantomData<(D, &'tcx ())>,\n     pub(super) map: FxHashMap<D::Key, QueryValue<D::Value>>,\n }\n \n@@ -46,15 +46,20 @@ impl<T> QueryValue<T> {\n     }\n }\n \n-impl<M: QueryDescription> QueryMap<M> {\n-    pub(super) fn new() -> QueryMap<M> {\n+impl<'tcx, M: QueryDescription<'tcx>> QueryMap<'tcx, M> {\n+    pub(super) fn new() -> QueryMap<'tcx, M> {\n         QueryMap {\n             phantom: PhantomData,\n             map: FxHashMap(),\n         }\n     }\n }\n \n+pub(super) trait GetCacheInternal<'tcx>: QueryDescription<'tcx> + Sized {\n+    fn get_cache_internal<'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n+                              -> Ref<'a, QueryMap<'tcx, Self>>;\n+}\n+\n pub(super) struct CycleError<'a, 'tcx: 'a> {\n     span: Span,\n     cycle: RefMut<'a, [(Span, Query<'tcx>)]>,\n@@ -242,6 +247,13 @@ macro_rules! define_maps {\n             type Value = $V;\n         }\n \n+        impl<$tcx> GetCacheInternal<$tcx> for queries::$name<$tcx> {\n+            fn get_cache_internal<'a>(tcx: TyCtxt<'a, $tcx, $tcx>)\n+                                      -> ::std::cell::Ref<'a, QueryMap<$tcx, Self>> {\n+                tcx.maps.$name.borrow()\n+            }\n+        }\n+\n         impl<'a, $tcx, 'lcx> queries::$name<$tcx> {\n \n             #[allow(unused)]\n@@ -379,18 +391,26 @@ macro_rules! define_maps {\n             {\n                 debug_assert!(tcx.dep_graph.is_green(dep_node_index));\n \n-                // We don't do any caching yet, so recompute.\n-                // The diagnostics for this query have already been promoted to\n-                // the current session during try_mark_green(), so we can ignore\n-                // them here.\n-                let (result, _) = tcx.cycle_check(span, Query::$name(key), || {\n-                    tcx.sess.diagnostic().track_diagnostics(|| {\n-                        // The dep-graph for this computation is already in place\n-                        tcx.dep_graph.with_ignore(|| {\n-                            Self::compute_result(tcx, key)\n+                let result = if tcx.sess.opts.debugging_opts.incremental_queries &&\n+                                Self::cache_on_disk(key) {\n+                    let prev_dep_node_index =\n+                        tcx.dep_graph.prev_dep_node_index_of(dep_node);\n+                    Self::load_from_disk(tcx.global_tcx(), prev_dep_node_index)\n+                } else {\n+                    let (result, _ ) = tcx.cycle_check(span, Query::$name(key), || {\n+                        // The diagnostics for this query have already been\n+                        // promoted to the current session during\n+                        // try_mark_green(), so we can ignore them here.\n+                        tcx.sess.diagnostic().track_diagnostics(|| {\n+                            // The dep-graph for this computation is already in\n+                            // place\n+                            tcx.dep_graph.with_ignore(|| {\n+                                Self::compute_result(tcx, key)\n+                            })\n                         })\n-                    })\n-                })?;\n+                    })?;\n+                    result\n+                };\n \n                 // If -Zincremental-verify-ich is specified, re-hash results from\n                 // the cache and make sure that they have the expected fingerprint.\n@@ -547,7 +567,7 @@ macro_rules! define_map_struct {\n         pub struct Maps<$tcx> {\n             providers: IndexVec<CrateNum, Providers<$tcx>>,\n             query_stack: RefCell<Vec<(Span, Query<$tcx>)>>,\n-            $($(#[$attr])*  $name: RefCell<QueryMap<queries::$name<$tcx>>>,)*\n+            $($(#[$attr])*  $name: RefCell<QueryMap<$tcx, queries::$name<$tcx>>>,)*\n         }\n     };\n }"}, {"sha": "a584f2ce1919a2218a70ef7f48d64dfa597327c7", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -17,7 +17,7 @@ pub use self::fold::TypeFoldable;\n \n use hir::{map as hir_map, FreevarMap, TraitMap};\n use hir::def::{Def, CtorKind, ExportMap};\n-use hir::def_id::{CrateNum, DefId, DefIndex, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use hir::map::DefPathData;\n use ich::StableHashingContext;\n use middle::const_val::ConstVal;\n@@ -89,6 +89,7 @@ pub use self::maps::queries;\n pub mod adjustment;\n pub mod binding;\n pub mod cast;\n+#[macro_use]\n pub mod codec;\n pub mod error;\n mod erase_regions;\n@@ -582,7 +583,7 @@ impl<T> Slice<T> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n pub struct UpvarId {\n     pub var_id: hir::HirId,\n-    pub closure_expr_id: DefIndex,\n+    pub closure_expr_id: LocalDefId,\n }\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable, Copy)]"}, {"sha": "7b09e45fe96e32dedd15af7cbbb6caec5c52a46d", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -29,7 +29,7 @@ use rustc::middle::dataflow::BitwiseOperator;\n use rustc::middle::dataflow::DataFlowOperator;\n use rustc::middle::dataflow::KillFrom;\n use rustc::middle::borrowck::BorrowCheckResult;\n-use rustc::hir::def_id::{DefId, DefIndex};\n+use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization as mc;\n use rustc::middle::mem_categorization::Categorization;\n@@ -376,9 +376,9 @@ pub enum LoanPathElem<'tcx> {\n     LpInterior(Option<DefId>, InteriorKind),\n }\n \n-fn closure_to_block(closure_id: DefIndex,\n+fn closure_to_block(closure_id: LocalDefId,\n                     tcx: TyCtxt) -> ast::NodeId {\n-    let closure_id = tcx.hir.def_index_to_node_id(closure_id);\n+    let closure_id = tcx.hir.local_def_id_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n         hir_map::NodeExpr(expr) => match expr.node {\n             hir::ExprClosure(.., body_id, _, _) => {\n@@ -1101,7 +1101,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 } else {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n-                let node_id = self.tcx.hir.def_index_to_node_id(id);\n+                let node_id = self.tcx.hir.local_def_id_to_node_id(id);\n                 let help_span = self.tcx.hir.span(node_id);\n                 self.cannot_act_on_capture_in_sharable_fn(span,\n                                                           prefix,\n@@ -1297,7 +1297,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n                 if kind == ty::ClosureKind::Fn {\n                     let closure_node_id =\n-                        self.tcx.hir.def_index_to_node_id(upvar_id.closure_expr_id);\n+                        self.tcx.hir.local_def_id_to_node_id(upvar_id.closure_expr_id);\n                     db.span_help(self.tcx.hir.span(closure_node_id),\n                                  \"consider changing this closure to take \\\n                                   self by mutable reference\");"}, {"sha": "08f9dba2ba162663afaa2d80957290ac517ebe9b", "filename": "src/librustc_incremental/persist/data.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdata.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -11,7 +11,6 @@\n //! The data that we will serialize and deserialize.\n \n use rustc::dep_graph::{WorkProduct, WorkProductId};\n-use rustc::hir::def_id::DefIndex;\n use rustc::hir::map::DefPathHash;\n use rustc::middle::cstore::EncodedMetadataHash;\n use rustc_data_structures::fx::FxHashMap;\n@@ -58,5 +57,5 @@ pub struct SerializedMetadataHashes {\n     /// is only populated if -Z query-dep-graph is specified. It will be\n     /// empty otherwise. Importing crates are perfectly happy with just having\n     /// the DefIndex.\n-    pub index_map: FxHashMap<DefIndex, DefPathHash>\n+    pub index_map: FxHashMap<u32, DefPathHash>\n }"}, {"sha": "7d27b842a68a7def7bb6ccf626be9180c7cb7618", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -53,19 +53,25 @@ pub fn write_file_header<W: io::Write>(stream: &mut W) -> io::Result<()> {\n \n /// Reads the contents of a file with a file header as defined in this module.\n ///\n-/// - Returns `Ok(Some(data))` if the file existed and was generated by a\n+/// - Returns `Ok(Some(data, pos))` if the file existed and was generated by a\n ///   compatible compiler version. `data` is the entire contents of the file\n-///   *after* the header.\n+///   and `pos` points to the first byte after the header.\n /// - Returns `Ok(None)` if the file did not exist or was generated by an\n ///   incompatible version of the compiler.\n /// - Returns `Err(..)` if some kind of IO error occurred while reading the\n ///   file.\n-pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<Vec<u8>>> {\n+pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<(Vec<u8>, usize)>> {\n     if !path.exists() {\n         return Ok(None);\n     }\n \n     let mut file = File::open(path)?;\n+    let file_size = file.metadata()?.len() as usize;\n+\n+    let mut data = Vec::with_capacity(file_size);\n+    file.read_to_end(&mut data)?;\n+\n+    let mut file = io::Cursor::new(data);\n \n     // Check FILE_MAGIC\n     {\n@@ -107,10 +113,8 @@ pub fn read_file(sess: &Session, path: &Path) -> io::Result<Option<Vec<u8>>> {\n         }\n     }\n \n-    let mut data = vec![];\n-    file.read_to_end(&mut data)?;\n-\n-    Ok(Some(data))\n+    let post_header_start_pos = file.position() as usize;\n+    Ok(Some((file.into_inner(), post_header_start_pos)))\n }\n \n fn report_format_mismatch(sess: &Session, file: &Path, message: &str) {"}, {"sha": "e4bc6b7339efce37efd9ca8c8684e30493290815", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -42,9 +42,9 @@ pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n \n     let work_products_path = work_products_path(tcx.sess);\n-    if let Some(work_products_data) = load_data(tcx.sess, &work_products_path) {\n+    if let Some((work_products_data, start_pos)) = load_data(tcx.sess, &work_products_path) {\n         // Decode the list of work_products\n-        let mut work_product_decoder = Decoder::new(&work_products_data[..], 0);\n+        let mut work_product_decoder = Decoder::new(&work_products_data[..], start_pos);\n         let work_products: Vec<SerializedWorkProduct> =\n             RustcDecodable::decode(&mut work_product_decoder).unwrap_or_else(|e| {\n                 let msg = format!(\"Error decoding `work-products` from incremental \\\n@@ -77,9 +77,9 @@ pub fn dep_graph_tcx_init<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     }\n }\n \n-fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n+fn load_data(sess: &Session, path: &Path) -> Option<(Vec<u8>, usize)> {\n     match file_format::read_file(sess, path) {\n-        Ok(Some(data)) => return Some(data),\n+        Ok(Some(data_and_pos)) => return Some(data_and_pos),\n         Ok(None) => {\n             // The file either didn't exist or was produced by an incompatible\n             // compiler version. Neither is an error.\n@@ -126,8 +126,8 @@ pub fn load_prev_metadata_hashes(tcx: TyCtxt) -> DefIdMap<Fingerprint> {\n \n     debug!(\"load_prev_metadata_hashes() - File: {}\", file_path.display());\n \n-    let data = match file_format::read_file(tcx.sess, &file_path) {\n-        Ok(Some(data)) => data,\n+    let (data, start_pos) = match file_format::read_file(tcx.sess, &file_path) {\n+        Ok(Some(data_and_pos)) => data_and_pos,\n         Ok(None) => {\n             debug!(\"load_prev_metadata_hashes() - File produced by incompatible \\\n                     compiler version: {}\", file_path.display());\n@@ -141,7 +141,7 @@ pub fn load_prev_metadata_hashes(tcx: TyCtxt) -> DefIdMap<Fingerprint> {\n     };\n \n     debug!(\"load_prev_metadata_hashes() - Decoding hashes\");\n-    let mut decoder = Decoder::new(&data, 0);\n+    let mut decoder = Decoder::new(&data, start_pos);\n     let _ = Svh::decode(&mut decoder).unwrap();\n     let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder).unwrap();\n \n@@ -171,8 +171,8 @@ pub fn load_dep_graph(sess: &Session) -> PreviousDepGraph {\n         return empty\n     }\n \n-    if let Some(bytes) = load_data(sess, &dep_graph_path(sess)) {\n-        let mut decoder = Decoder::new(&bytes, 0);\n+    if let Some((bytes, start_pos)) = load_data(sess, &dep_graph_path(sess)) {\n+        let mut decoder = Decoder::new(&bytes, start_pos);\n         let prev_commandline_args_hash = u64::decode(&mut decoder)\n             .expect(\"Error reading commandline arg hash from cached dep-graph\");\n \n@@ -184,6 +184,10 @@ pub fn load_dep_graph(sess: &Session) -> PreviousDepGraph {\n             // We can't reuse the cache, purge it.\n             debug!(\"load_dep_graph_new: differing commandline arg hashes\");\n \n+            delete_all_session_dir_contents(sess)\n+                .expect(\"Failed to delete invalidated incr. comp. session \\\n+                         directory contents.\");\n+\n             // No need to do any further work\n             return empty\n         }\n@@ -198,12 +202,13 @@ pub fn load_dep_graph(sess: &Session) -> PreviousDepGraph {\n }\n \n pub fn load_query_result_cache<'sess>(sess: &'sess Session) -> OnDiskCache<'sess> {\n-    if sess.opts.incremental.is_none() {\n+    if sess.opts.incremental.is_none() ||\n+       !sess.opts.debugging_opts.incremental_queries {\n         return OnDiskCache::new_empty(sess.codemap());\n     }\n \n-    if let Some(bytes) = load_data(sess, &query_cache_path(sess)) {\n-        OnDiskCache::new(sess, &bytes[..])\n+    if let Some((bytes, start_pos)) = load_data(sess, &query_cache_path(sess)) {\n+        OnDiskCache::new(sess, bytes, start_pos)\n     } else {\n         OnDiskCache::new_empty(sess.codemap())\n     }"}, {"sha": "b6dabf99be7d7d7468bcae9d93eac80baf7e152a", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::dep_graph::{DepGraph, DepKind};\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, DefIndex};\n use rustc::hir::svh::Svh;\n use rustc::ich::Fingerprint;\n use rustc::middle::cstore::EncodedMetadataHashes;\n@@ -69,11 +69,13 @@ pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 |e| encode_query_cache(tcx, e));\n     });\n \n-    time(sess.time_passes(), \"persist dep-graph\", || {\n-        save_in(sess,\n-                dep_graph_path(sess),\n-                |e| encode_dep_graph(tcx, e));\n-    });\n+    if tcx.sess.opts.debugging_opts.incremental_queries {\n+        time(sess.time_passes(), \"persist dep-graph\", || {\n+            save_in(sess,\n+                    dep_graph_path(sess),\n+                    |e| encode_dep_graph(tcx, e));\n+        });\n+    }\n \n     dirty_clean::check_dirty_clean_annotations(tcx);\n     dirty_clean::check_dirty_clean_metadata(tcx,\n@@ -268,11 +270,11 @@ fn encode_metadata_hashes(tcx: TyCtxt,\n \n     if tcx.sess.opts.debugging_opts.query_dep_graph {\n         for serialized_hash in &serialized_hashes.entry_hashes {\n-            let def_id = DefId::local(serialized_hash.def_index);\n+            let def_id = DefId::local(DefIndex::from_u32(serialized_hash.def_index));\n \n             // Store entry in the index_map\n             let def_path_hash = tcx.def_path_hash(def_id);\n-            serialized_hashes.index_map.insert(def_id.index, def_path_hash);\n+            serialized_hashes.index_map.insert(def_id.index.as_u32(), def_path_hash);\n \n             // Record hash in current_metadata_hashes\n             current_metadata_hashes.insert(def_id, serialized_hash.hash);"}, {"sha": "0dd1b9e500c084f2e8cd730985f3dbee3ba942c3", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 27, "deletions": 115, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -15,8 +15,6 @@ use schema::*;\n \n use rustc::hir::map::{DefKey, DefPath, DefPathData, DefPathHash};\n use rustc::hir;\n-\n-use rustc::middle::const_val::ByteArray;\n use rustc::middle::cstore::{LinkagePreference, ExternConstBody,\n                             ExternBodyNestedBodies};\n use rustc::hir::def::{self, Def, CtorKind};\n@@ -25,19 +23,15 @@ use rustc::ich::Fingerprint;\n use rustc::middle::lang_items;\n use rustc::session::Session;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::codec::{self as ty_codec, TyDecoder};\n-use rustc::ty::subst::Substs;\n+use rustc::ty::codec::TyDecoder;\n use rustc::util::nodemap::DefIdSet;\n-\n use rustc::mir::Mir;\n \n-use std::borrow::Cow;\n use std::cell::Ref;\n use std::collections::BTreeMap;\n use std::io;\n use std::mem;\n use std::rc::Rc;\n-use std::str;\n use std::u32;\n \n use rustc_serialize::{Decodable, Decoder, SpecializedDecoder, opaque};\n@@ -174,57 +168,23 @@ impl<'a, 'tcx> DecodeContext<'a, 'tcx> {\n     }\n }\n \n-macro_rules! decoder_methods {\n-    ($($name:ident -> $ty:ty;)*) => {\n-        $(fn $name(&mut self) -> Result<$ty, Self::Error> {\n-            self.opaque.$name()\n-        })*\n-    }\n-}\n-\n-impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n-    type Error = <opaque::Decoder<'doc> as Decoder>::Error;\n-\n-    decoder_methods! {\n-        read_nil -> ();\n-\n-        read_u128 -> u128;\n-        read_u64 -> u64;\n-        read_u32 -> u32;\n-        read_u16 -> u16;\n-        read_u8 -> u8;\n-        read_usize -> usize;\n-\n-        read_i128 -> i128;\n-        read_i64 -> i64;\n-        read_i32 -> i32;\n-        read_i16 -> i16;\n-        read_i8 -> i8;\n-        read_isize -> isize;\n-\n-        read_bool -> bool;\n-        read_f64 -> f64;\n-        read_f32 -> f32;\n-        read_char -> char;\n-        read_str -> Cow<str>;\n-    }\n-\n-    fn error(&mut self, err: &str) -> Self::Error {\n-        self.opaque.error(err)\n-    }\n-}\n-\n-\n impl<'a, 'tcx: 'a> TyDecoder<'a, 'tcx> for DecodeContext<'a, 'tcx> {\n \n+    #[inline]\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.tcx.expect(\"missing TyCtxt in DecodeContext\")\n     }\n \n+    #[inline]\n     fn peek_byte(&self) -> u8 {\n         self.opaque.data[self.opaque.position()]\n     }\n \n+    #[inline]\n+    fn position(&self) -> usize {\n+        self.opaque.position()\n+    }\n+\n     fn cached_ty_for_shorthand<F>(&mut self,\n                                   shorthand: usize,\n                                   or_insert_with: F)\n@@ -286,14 +246,24 @@ impl<'a, 'tcx, T> SpecializedDecoder<LazySeq<T>> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<CrateNum> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n-        let cnum = CrateNum::from_u32(u32::decode(self)?);\n-        if cnum == LOCAL_CRATE {\n-            Ok(self.cdata().cnum)\n-        } else {\n-            Ok(self.cdata().cnum_map.borrow()[cnum])\n-        }\n+\n+impl<'a, 'tcx> SpecializedDecoder<DefId> for DecodeContext<'a, 'tcx> {\n+    #[inline]\n+    fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n+        let krate = CrateNum::decode(self)?;\n+        let index = DefIndex::decode(self)?;\n+\n+        Ok(DefId {\n+            krate,\n+            index,\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedDecoder<DefIndex> for DecodeContext<'a, 'tcx> {\n+    #[inline]\n+    fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n+        Ok(DefIndex::from_u32(self.read_u32()?))\n     }\n }\n \n@@ -357,65 +327,7 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for DecodeContext<'a, 'tcx> {\n     }\n }\n \n-// FIXME(#36588) These impls are horribly unsound as they allow\n-// the caller to pick any lifetime for 'tcx, including 'static,\n-// by using the unspecialized proxies to them.\n-\n-impl<'a, 'tcx> SpecializedDecoder<Ty<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<Ty<'tcx>, Self::Error> {\n-        ty_codec::decode_ty(self)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<ty::GenericPredicates<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<ty::GenericPredicates<'tcx>, Self::Error> {\n-        ty_codec::decode_predicates(self)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<&'tcx Substs<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n-        ty_codec::decode_substs(self)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<ty::Region<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {\n-        ty_codec::decode_region(self)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<Ty<'tcx>>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<&'tcx ty::Slice<Ty<'tcx>>, Self::Error> {\n-        ty_codec::decode_ty_slice(self)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::AdtDef> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n-        ty_codec::decode_adt_def(self)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>\n-    for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self)\n-        -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n-        ty_codec::decode_existential_predicate_slice(self)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<ByteArray<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<ByteArray<'tcx>, Self::Error> {\n-        ty_codec::decode_byte_array(self)\n-    }\n-}\n-\n-impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::Const<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n-        ty_codec::decode_const(self)\n-    }\n-}\n+implement_ty_decoder!( DecodeContext<'a, 'tcx> );\n \n impl<'a, 'tcx> MetadataBlob {\n     pub fn is_compatible(&self) -> bool {"}, {"sha": "23e86b2d35a51c858b17616fb9cc69b192fcfa82", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -116,6 +116,33 @@ impl<'a, 'tcx, T> SpecializedEncoder<LazySeq<T>> for EncodeContext<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> SpecializedEncoder<CrateNum> for EncodeContext<'a, 'tcx> {\n+    #[inline]\n+    fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n+        self.emit_u32(cnum.as_u32())\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedEncoder<DefId> for EncodeContext<'a, 'tcx> {\n+    #[inline]\n+    fn specialized_encode(&mut self, def_id: &DefId) -> Result<(), Self::Error> {\n+        let DefId {\n+            krate,\n+            index,\n+        } = *def_id;\n+\n+        krate.encode(self)?;\n+        index.encode(self)\n+    }\n+}\n+\n+impl<'a, 'tcx> SpecializedEncoder<DefIndex> for EncodeContext<'a, 'tcx> {\n+    #[inline]\n+    fn specialized_encode(&mut self, def_index: &DefIndex) -> Result<(), Self::Error> {\n+        self.emit_u32(def_index.as_u32())\n+    }\n+}\n+\n impl<'a, 'tcx> SpecializedEncoder<Ty<'tcx>> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n         ty_codec::encode_with_shorthand(self, ty, |ecx| &mut ecx.type_shorthands)\n@@ -213,7 +240,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         if let Some(fingerprint) = fingerprint {\n             this.metadata_hashes.hashes.push(EncodedMetadataHash {\n-                def_index,\n+                def_index: def_index.as_u32(),\n                 hash: fingerprint,\n             })\n         }\n@@ -395,7 +422,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         let total_bytes = self.position();\n \n         self.metadata_hashes.hashes.push(EncodedMetadataHash {\n-            def_index: global_metadata_def_index(GlobalMetaDataKind::Krate),\n+            def_index: global_metadata_def_index(GlobalMetaDataKind::Krate).as_u32(),\n             hash: Fingerprint::from_smaller_hash(link_meta.crate_hash.as_u64())\n         });\n "}, {"sha": "46706bba96d6d4cb3b7b3e1a1207326a69e6f75b", "filename": "src/librustc_metadata/index_builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_metadata%2Findex_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_metadata%2Findex_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Findex_builder.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n         let (fingerprint, ecx) = entry_builder.finish();\n         if let Some(hash) = fingerprint {\n             ecx.metadata_hashes.hashes.push(EncodedMetadataHash {\n-                def_index: id.index,\n+                def_index: id.index.as_u32(),\n                 hash,\n             });\n         }"}, {"sha": "e722a589b66bf6a36b7427b6efeb5ac7884da312", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -13,7 +13,7 @@ use build;\n use hair::cx::Cx;\n use hair::LintLevel;\n use rustc::hir;\n-use rustc::hir::def_id::DefId;\n+use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::region;\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, TyContext};\n@@ -422,10 +422,10 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n         freevars.iter().map(|fv| {\n             let var_id = fv.var_id();\n             let var_hir_id = tcx.hir.node_to_hir_id(var_id);\n-            let closure_expr_id = tcx.hir.local_def_id(fn_id).index;\n+            let closure_expr_id = tcx.hir.local_def_id(fn_id);\n             let capture = hir.tables().upvar_capture(ty::UpvarId {\n                 var_id: var_hir_id,\n-                closure_expr_id,\n+                closure_expr_id: LocalDefId::from_def_id(closure_expr_id),\n             });\n             let by_ref = match capture {\n                 ty::UpvarCapture::ByValue => false,"}, {"sha": "798928e7ae7a53cafa29f71c00d5da035dce49b1", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -20,6 +20,7 @@ use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n+use rustc::hir::def_id::LocalDefId;\n \n impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n     type Output = Expr<'tcx>;\n@@ -783,7 +784,7 @@ fn convert_var<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n             // point we need an implicit deref\n             let upvar_id = ty::UpvarId {\n                 var_id: var_hir_id,\n-                closure_expr_id: closure_def_id.index,\n+                closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n             };\n             match cx.tables().upvar_capture(upvar_id) {\n                 ty::UpvarCapture::ByValue => field_kind,\n@@ -897,7 +898,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n     let var_hir_id = cx.tcx.hir.node_to_hir_id(freevar.var_id());\n     let upvar_id = ty::UpvarId {\n         var_id: var_hir_id,\n-        closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).index,\n+        closure_expr_id: cx.tcx.hir.local_def_id(closure_expr.id).to_local(),\n     };\n     let upvar_capture = cx.tables().upvar_capture(upvar_id);\n     let temp_lifetime = cx.region_scope_tree.temporary_scope(closure_expr.hir_id.local_id);"}, {"sha": "9a70a8699aa5c9378dc5b9af1c6703e086198619", "filename": "src/librustc_typeck/check/upvar.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fupvar.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -50,7 +50,7 @@ use rustc::infer::UpvarRegion;\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n-use rustc::hir::def_id::DefIndex;\n+use rustc::hir::def_id::LocalDefId;\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::util::nodemap::FxHashMap;\n \n@@ -128,7 +128,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             for freevar in freevars {\n                 let upvar_id = ty::UpvarId {\n                     var_id: self.tcx.hir.node_to_hir_id(freevar.var_id()),\n-                    closure_expr_id: closure_def_id.index,\n+                    closure_expr_id: LocalDefId::from_def_id(closure_def_id),\n                 };\n                 debug!(\"seed upvar_id {:?}\", upvar_id);\n \n@@ -167,7 +167,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // Write the adjusted values back into the main tables.\n             if infer_kind {\n                 if let Some(kind) = delegate.adjust_closure_kinds\n-                                            .remove(&closure_def_id.index) {\n+                                            .remove(&closure_def_id.to_local()) {\n                     self.tables\n                         .borrow_mut()\n                         .closure_kinds_mut()\n@@ -231,7 +231,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // This may change if abstract return types of some sort are\n         // implemented.\n         let tcx = self.tcx;\n-        let closure_def_index = tcx.hir.local_def_id(closure_id).index;\n+        let closure_def_index = tcx.hir.local_def_id(closure_id);\n \n         tcx.with_freevars(closure_id, |freevars| {\n             freevars.iter().map(|freevar| {\n@@ -240,7 +240,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 let freevar_ty = self.node_ty(var_hir_id);\n                 let upvar_id = ty::UpvarId {\n                     var_id: var_hir_id,\n-                    closure_expr_id: closure_def_index,\n+                    closure_expr_id: LocalDefId::from_def_id(closure_def_index),\n                 };\n                 let capture = self.tables.borrow().upvar_capture(upvar_id);\n \n@@ -263,7 +263,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n struct InferBorrowKind<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n-    adjust_closure_kinds: FxHashMap<DefIndex, (ty::ClosureKind, Option<(Span, ast::Name)>)>,\n+    adjust_closure_kinds: FxHashMap<LocalDefId, (ty::ClosureKind, Option<(Span, ast::Name)>)>,\n     adjust_upvar_captures: ty::UpvarCaptureMap<'tcx>,\n }\n \n@@ -485,7 +485,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n     }\n \n     fn adjust_closure_kind(&mut self,\n-                           closure_id: DefIndex,\n+                           closure_id: LocalDefId,\n                            new_kind: ty::ClosureKind,\n                            upvar_span: Span,\n                            var_name: ast::Name) {\n@@ -494,7 +494,7 @@ impl<'a, 'gcx, 'tcx> InferBorrowKind<'a, 'gcx, 'tcx> {\n \n         let closure_kind = self.adjust_closure_kinds.get(&closure_id).cloned()\n             .or_else(|| {\n-                let closure_id = self.fcx.tcx.hir.def_index_to_hir_id(closure_id);\n+                let closure_id = self.fcx.tcx.hir.local_def_id_to_hir_id(closure_id);\n                 self.fcx.tables.borrow().closure_kinds().get(closure_id).cloned()\n             });\n "}, {"sha": "b5a8a15b1a8fa925d6ef9ea49e4ee1bb98d44086", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02eed2e9a59c0b5df3260b38346562b85a7f3b44/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=02eed2e9a59c0b5df3260b38346562b85a7f3b44", "patch": "@@ -1388,6 +1388,7 @@ actual:\\n\\\n         if let Some(ref incremental_dir) = self.props.incremental_dir {\n             rustc.args(&[\"-Z\", &format!(\"incremental={}\", incremental_dir.display())]);\n             rustc.args(&[\"-Z\", \"incremental-verify-ich\"]);\n+            rustc.args(&[\"-Z\", \"incremental-queries\"]);\n         }\n \n         match self.config.mode {"}]}