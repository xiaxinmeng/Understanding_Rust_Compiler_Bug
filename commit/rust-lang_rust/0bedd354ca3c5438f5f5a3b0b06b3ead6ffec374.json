{"sha": "0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374", "node_id": "C_kwDOAAsO6NoAKDBiZWRkMzU0Y2EzYzU0MzhmNWY1YTNiMGIwNmIzZWFkNmZmZWMzNzQ", "commit": {"author": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-08-12T01:36:13Z"}, "committer": {"name": "Joshua Nelson", "email": "jnelson@cloudflare.com", "date": "2022-08-24T02:52:29Z"}, "message": "Move most of `make_query` into a generic function, away from the macro\n\nThis should both make the code easier to read and also greatly reduce the amount of codegen\nthe compiler has to do, since it only needs to monomorphize `create_query_frame` for each\nnew key and not for each query.", "tree": {"sha": "7cc42e5af187e2b9a4ea0cfec50faac0e92117a1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cc42e5af187e2b9a4ea0cfec50faac0e92117a1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374", "html_url": "https://github.com/rust-lang/rust/commit/0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1de08b19d1ee7ae337b93b11fb971d37ffbb6968", "url": "https://api.github.com/repos/rust-lang/rust/commits/1de08b19d1ee7ae337b93b11fb971d37ffbb6968", "html_url": "https://github.com/rust-lang/rust/commit/1de08b19d1ee7ae337b93b11fb971d37ffbb6968"}], "stats": {"total": 98, "additions": 56, "deletions": 42}, "files": [{"sha": "946bc34fea101878eb41931ee40e8c36624e9c7a", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374", "patch": "@@ -15,7 +15,6 @@ extern crate rustc_macros;\n #[macro_use]\n extern crate rustc_middle;\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n use rustc_middle::dep_graph::{self, DepKindStruct, SerializedDepNodeIndex};"}, {"sha": "7b4ff850df67df933682ad957079f232bb000378", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 56, "deletions": 41, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=0bedd354ca3c5438f5f5a3b0b06b3ead6ffec374", "patch": "@@ -2,13 +2,18 @@\n //! generate the actual methods on tcx which find and execute the provider,\n //! manage the caches, and so forth.\n \n+use crate::keys::Key;\n use crate::{on_disk_cache, Queries};\n-use rustc_middle::dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n+use rustc_middle::dep_graph::{self, DepKind, DepNodeIndex, SerializedDepNodeIndex};\n use rustc_middle::ty::tls::{self, ImplicitCtxt};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{self, TyCtxt};\n use rustc_query_system::dep_graph::HasDepContext;\n-use rustc_query_system::query::{QueryContext, QueryJobId, QueryMap, QuerySideEffects};\n+use rustc_query_system::ich::StableHashingContext;\n+use rustc_query_system::query::{\n+    QueryContext, QueryJobId, QueryMap, QuerySideEffects, QueryStackFrame,\n+};\n \n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lock;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_errors::{Diagnostic, Handler};\n@@ -233,6 +238,53 @@ macro_rules! get_provider {\n     };\n }\n \n+pub(crate) fn create_query_frame<\n+    'tcx,\n+    K: Copy + Key + for<'a> HashStable<StableHashingContext<'a>>,\n+>(\n+    tcx: QueryCtxt<'tcx>,\n+    do_describe: fn(QueryCtxt<'tcx>, K) -> String,\n+    key: K,\n+    kind: DepKind,\n+    name: &'static str,\n+) -> QueryStackFrame {\n+    // Disable visible paths printing for performance reasons.\n+    // Showing visible path instead of any path is not that important in production.\n+    let description = ty::print::with_no_visible_paths!(\n+        // Force filename-line mode to avoid invoking `type_of` query.\n+        ty::print::with_forced_impl_filename_line!(do_describe(tcx, key))\n+    );\n+    let description =\n+        if tcx.sess.verbose() { format!(\"{} [{}]\", description, name) } else { description };\n+    let span = if kind == dep_graph::DepKind::def_span {\n+        // The `def_span` query is used to calculate `default_span`,\n+        // so exit to avoid infinite recursion.\n+        None\n+    } else {\n+        Some(key.default_span(*tcx))\n+    };\n+    let def_kind = if kind == dep_graph::DepKind::opt_def_kind {\n+        // Try to avoid infinite recursion.\n+        None\n+    } else {\n+        key.key_as_def_id()\n+            .and_then(|def_id| def_id.as_local())\n+            .and_then(|def_id| tcx.opt_def_kind(def_id))\n+    };\n+    let hash = || {\n+        tcx.with_stable_hashing_context(|mut hcx| {\n+            let mut hasher = StableHasher::new();\n+            std::mem::discriminant(&kind).hash_stable(&mut hcx, &mut hasher);\n+            key.hash_stable(&mut hcx, &mut hasher);\n+            hasher.finish::<u64>()\n+        })\n+    };\n+\n+    QueryStackFrame::new(name, description, span, def_kind, hash)\n+}\n+\n+// NOTE: `$V` isn't used here, but we still need to match on it so it can be passed to other macros\n+// invoked by `rustc_query_append`.\n macro_rules! define_queries {\n     (\n      $($(#[$attr:meta])*\n@@ -249,44 +301,7 @@ macro_rules! define_queries {\n             pub fn $name<'tcx>(tcx: QueryCtxt<'tcx>, key: <queries::$name<'tcx> as QueryConfig>::Key) -> QueryStackFrame {\n                 let kind = dep_graph::DepKind::$name;\n                 let name = stringify!($name);\n-                // Disable visible paths printing for performance reasons.\n-                // Showing visible path instead of any path is not that important in production.\n-                let description = ty::print::with_no_visible_paths!(\n-                    // Force filename-line mode to avoid invoking `type_of` query.\n-                    ty::print::with_forced_impl_filename_line!(\n-                        queries::$name::describe(tcx, key)\n-                    )\n-                );\n-                let description = if tcx.sess.verbose() {\n-                    format!(\"{} [{}]\", description, name)\n-                } else {\n-                    description\n-                };\n-                let span = if kind == dep_graph::DepKind::def_span {\n-                    // The `def_span` query is used to calculate `default_span`,\n-                    // so exit to avoid infinite recursion.\n-                    None\n-                } else {\n-                    Some(key.default_span(*tcx))\n-                };\n-                let def_kind = if kind == dep_graph::DepKind::opt_def_kind {\n-                    // Try to avoid infinite recursion.\n-                    None\n-                } else {\n-                    key.key_as_def_id()\n-                        .and_then(|def_id| def_id.as_local())\n-                        .and_then(|def_id| tcx.opt_def_kind(def_id))\n-                };\n-                let hash = || {\n-                    tcx.with_stable_hashing_context(|mut hcx|{\n-                        let mut hasher = StableHasher::new();\n-                        std::mem::discriminant(&kind).hash_stable(&mut hcx, &mut hasher);\n-                        key.hash_stable(&mut hcx, &mut hasher);\n-                        hasher.finish::<u64>()\n-                    })\n-                };\n-\n-                QueryStackFrame::new(name, description, span, def_kind, hash)\n+                $crate::plumbing::create_query_frame(tcx, queries::$name::describe, key, kind, name)\n             })*\n         }\n "}]}