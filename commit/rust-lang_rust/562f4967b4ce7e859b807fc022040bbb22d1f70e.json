{"sha": "562f4967b4ce7e859b807fc022040bbb22d1f70e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU2MmY0OTY3YjRjZTdlODU5YjgwN2ZjMDIyMDQwYmJiMjJkMWY3MGU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-09T20:57:33Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2020-06-19T20:40:51Z"}, "message": "Account for multiple impl/dyn Trait in return type when suggesting `'_`", "tree": {"sha": "07c99b66a3982a652e3e5f11f2ebe5a86d7f4f0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/07c99b66a3982a652e3e5f11f2ebe5a86d7f4f0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/562f4967b4ce7e859b807fc022040bbb22d1f70e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/562f4967b4ce7e859b807fc022040bbb22d1f70e", "html_url": "https://github.com/rust-lang/rust/commit/562f4967b4ce7e859b807fc022040bbb22d1f70e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/562f4967b4ce7e859b807fc022040bbb22d1f70e/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a39c7787ba246353178e099373b9240be0d9e603", "url": "https://api.github.com/repos/rust-lang/rust/commits/a39c7787ba246353178e099373b9240be0d9e603", "html_url": "https://github.com/rust-lang/rust/commit/a39c7787ba246353178e099373b9240be0d9e603"}], "stats": {"total": 440, "additions": 363, "deletions": 77}, "files": [{"sha": "6677c0e59f63a9e5cd6a0554ed0f212078e6fcde", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -26,7 +26,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         &self,\n         region: Region<'tcx>,\n         br: &ty::BoundRegion,\n-    ) -> Option<(&hir::Ty<'_>, &hir::FnDecl<'_>)> {\n+    ) -> Option<(&hir::Ty<'tcx>, &hir::FnDecl<'tcx>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n             let def_id = anon_reg.def_id;\n             if let Some(def_id) = def_id.as_local() {"}, {"sha": "7c8ba834dcdcba9b631119f8e486860a22b82303", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -2,7 +2,8 @@\n //! where one region is named and the other is anonymous.\n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n-use rustc_hir::{FnRetTy, TyKind};\n+use rustc_hir::intravisit::Visitor;\n+use rustc_hir::FnRetTy;\n use rustc_middle::ty;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n@@ -80,12 +81,16 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n \n             if let FnRetTy::Return(ty) = &fndecl.output {\n-                let mut v = ty::TraitObjectVisitor(vec![]);\n-                rustc_hir::intravisit::walk_ty(&mut v, ty);\n+                let mut v = ty::TraitObjectVisitor(vec![], self.tcx().hir());\n+                v.visit_ty(ty);\n \n                 debug!(\"try_report_named_anon_conflict: ret ty {:?}\", ty);\n                 if sub == &ty::ReStatic\n-                    && (matches!(ty.kind, TyKind::OpaqueDef(_, _)) || v.0.len() == 1)\n+                    && v.0\n+                        .into_iter()\n+                        .filter(|t| t.span.desugaring_kind().is_none())\n+                        .next()\n+                        .is_some()\n                 {\n                     debug!(\"try_report_named_anon_conflict: impl Trait + 'static\");\n                     // This is an `impl Trait` or `dyn Trait` return that evaluates de need of"}, {"sha": "20b275ea34af0694286f306fffc59b15b2c93a79", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 49, "deletions": 27, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -26,8 +26,11 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 );\n                 let anon_reg_sup = self.tcx().is_suitable_region(sup_r)?;\n                 debug!(\"try_report_static_impl_trait: anon_reg_sup={:?}\", anon_reg_sup);\n-                let fn_return = self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id)?;\n-                debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_return);\n+                let fn_returns = self.tcx().return_type_impl_or_dyn_trait(anon_reg_sup.def_id);\n+                if fn_returns.is_empty() {\n+                    return None;\n+                }\n+                debug!(\"try_report_static_impl_trait: fn_return={:?}\", fn_returns);\n                 if **sub_r == RegionKind::ReStatic {\n                     let sp = var_origin.span();\n                     let return_sp = sub_origin.span();\n@@ -98,25 +101,26 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                         );\n                     }\n \n-                    // only apply this suggestion onto functions with\n-                    // explicit non-desugar'able return.\n-                    if fn_return.span.desugaring_kind().is_none() {\n-                        // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n-\n-                        let consider = \"consider changing the\";\n-                        let declare = \"to declare that the\";\n-                        let arg = match param_info.param.pat.simple_ident() {\n-                            Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n-                            None => \"the argument\".to_string(),\n-                        };\n-                        let explicit =\n-                            format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n-                        let explicit_static =\n-                            format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n-                        let captures = format!(\"captures data from {}\", arg);\n-                        let add_static_bound =\n-                            \"alternatively, add an explicit `'static` bound to this reference\";\n-                        let plus_lt = format!(\" + {}\", lifetime_name);\n+                    // FIXME: account for the need of parens in `&(dyn Trait + '_)`\n+                    let consider = \"consider changing the\";\n+                    let declare = \"to declare that the\";\n+                    let arg = match param_info.param.pat.simple_ident() {\n+                        Some(simple_ident) => format!(\"argument `{}`\", simple_ident),\n+                        None => \"the argument\".to_string(),\n+                    };\n+                    let explicit =\n+                        format!(\"you can add an explicit `{}` lifetime bound\", lifetime_name);\n+                    let explicit_static =\n+                        format!(\"explicit `'static` bound to the lifetime of {}\", arg);\n+                    let captures = format!(\"captures data from {}\", arg);\n+                    let add_static_bound =\n+                        \"alternatively, add an explicit `'static` bound to this reference\";\n+                    let plus_lt = format!(\" + {}\", lifetime_name);\n+                    for fn_return in fn_returns {\n+                        if fn_return.span.desugaring_kind().is_some() {\n+                            // Skip `async` desugaring `impl Future`.\n+                            continue;\n+                        }\n                         match fn_return.kind {\n                             TyKind::OpaqueDef(item_id, _) => {\n                                 let item = self.tcx().hir().item(item_id.id);\n@@ -143,7 +147,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                     err.span_suggestion_verbose(\n                                         span,\n                                         &format!(\"{} `impl Trait`'s {}\", consider, explicit_static),\n-                                        lifetime_name,\n+                                        lifetime_name.clone(),\n                                         Applicability::MaybeIncorrect,\n                                     );\n                                     err.span_suggestion_verbose(\n@@ -152,6 +156,19 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                         param_info.param_ty.to_string(),\n                                         Applicability::MaybeIncorrect,\n                                     );\n+                                } else if let Some(_) = opaque\n+                                    .bounds\n+                                    .iter()\n+                                    .filter_map(|arg| match arg {\n+                                        GenericBound::Outlives(Lifetime { name, span, .. })\n+                                            if name.ident().to_string() == lifetime_name =>\n+                                        {\n+                                            Some(*span)\n+                                        }\n+                                        _ => None,\n+                                    })\n+                                    .next()\n+                                {\n                                 } else {\n                                     err.span_suggestion_verbose(\n                                         fn_return.span.shrink_to_hi(),\n@@ -161,10 +178,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                             captures = captures,\n                                             explicit = explicit,\n                                         ),\n-                                        plus_lt,\n+                                        plus_lt.clone(),\n                                         Applicability::MaybeIncorrect,\n                                     );\n-                                };\n+                                }\n                             }\n                             TyKind::TraitObject(_, lt) => match lt.name {\n                                 LifetimeName::ImplicitObjectLifetimeDefault => {\n@@ -176,15 +193,19 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                             captures = captures,\n                                             explicit = explicit,\n                                         ),\n-                                        plus_lt,\n+                                        plus_lt.clone(),\n                                         Applicability::MaybeIncorrect,\n                                     );\n                                 }\n-                                _ => {\n+                                name if name.ident().to_string() != lifetime_name => {\n+                                    // With this check we avoid suggesting redundant bounds. This\n+                                    // would happen if there are nested impl/dyn traits and only\n+                                    // one of them has the bound we'd suggest already there, like\n+                                    // in `impl Foo<X = dyn Bar> + '_`.\n                                     err.span_suggestion_verbose(\n                                         lt.span,\n                                         &format!(\"{} trait object's {}\", consider, explicit_static),\n-                                        lifetime_name,\n+                                        lifetime_name.clone(),\n                                         Applicability::MaybeIncorrect,\n                                     );\n                                     err.span_suggestion_verbose(\n@@ -194,6 +215,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                         Applicability::MaybeIncorrect,\n                                     );\n                                 }\n+                                _ => {}\n                             },\n                             _ => {}\n                         }"}, {"sha": "73374bb1e844316318d6b7b6ca61b48d105e8762", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -37,6 +37,7 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefPathHash, Definitions};\n+use rustc_hir::intravisit::Visitor;\n use rustc_hir::lang_items::{self, PanicLocationLangItem};\n use rustc_hir::{HirId, ItemKind, ItemLocalId, ItemLocalMap, ItemLocalSet, Node, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n@@ -1405,10 +1406,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn return_type_impl_or_dyn_trait(\n-        &self,\n-        scope_def_id: DefId,\n-    ) -> Option<&'tcx hir::Ty<'tcx>> {\n+    pub fn return_type_impl_or_dyn_trait(&self, scope_def_id: DefId) -> Vec<&'tcx hir::Ty<'tcx>> {\n         let hir_id = self.hir().as_local_hir_id(scope_def_id.expect_local());\n         let hir_output = match self.hir().get(hir_id) {\n             Node::Item(hir::Item {\n@@ -1444,30 +1442,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                     ),\n                 ..\n             }) => ty,\n-            _ => return None,\n+            _ => return vec![],\n         };\n \n-        let ret_ty = self.type_of(scope_def_id);\n-        match ret_ty.kind {\n-            ty::FnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(*self);\n-                let output = self.erase_late_bound_regions(&sig.output());\n-                if output.is_impl_trait() {\n-                    let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n-                    if let hir::FnRetTy::Return(ty) = fn_decl.output {\n-                        return Some(ty);\n-                    }\n-                } else {\n-                    let mut v = TraitObjectVisitor(vec![]);\n-                    rustc_hir::intravisit::walk_ty(&mut v, hir_output);\n-                    if v.0.len() == 1 {\n-                        return Some(v.0[0]);\n-                    }\n-                }\n-                None\n-            }\n-            _ => None,\n-        }\n+        let mut v = TraitObjectVisitor(vec![], self.hir());\n+        v.visit_ty(hir_output);\n+        v.0\n     }\n \n     pub fn return_type_impl_trait(&self, scope_def_id: DefId) -> Option<(Ty<'tcx>, Span)> {"}, {"sha": "b22727bdd7587b71848ce692971577f2cf1cdc3c", "filename": "src/librustc_middle/ty/diagnostics.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fdiagnostics.rs?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -236,7 +236,9 @@ pub fn suggest_constraining_type_param(\n     }\n }\n \n-pub struct TraitObjectVisitor<'tcx>(pub Vec<&'tcx hir::Ty<'tcx>>);\n+/// Collect al types that have an implicit `'static` obligation that we could suggest `'_` for.\n+pub struct TraitObjectVisitor<'tcx>(pub Vec<&'tcx hir::Ty<'tcx>>, pub crate::hir::map::Map<'tcx>);\n+\n impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor<'v> {\n     type Map = rustc_hir::intravisit::ErasedMap<'v>;\n \n@@ -245,15 +247,24 @@ impl<'v> hir::intravisit::Visitor<'v> for TraitObjectVisitor<'v> {\n     }\n \n     fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n-        if let hir::TyKind::TraitObject(\n-            _,\n-            hir::Lifetime {\n-                name: hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Static,\n-                ..\n-            },\n-        ) = ty.kind\n-        {\n-            self.0.push(ty);\n+        match ty.kind {\n+            hir::TyKind::TraitObject(\n+                _,\n+                hir::Lifetime {\n+                    name:\n+                        hir::LifetimeName::ImplicitObjectLifetimeDefault | hir::LifetimeName::Static,\n+                    ..\n+                },\n+            ) => {\n+                self.0.push(ty);\n+            }\n+            hir::TyKind::OpaqueDef(item_id, _) => {\n+                self.0.push(ty);\n+                let item = self.1.expect_item(item_id.id);\n+                hir::intravisit::walk_item(self, item);\n+            }\n+            _ => {}\n         }\n+        hir::intravisit::walk_ty(self, ty);\n     }\n }"}, {"sha": "3b339c5c3d7fc69a75c6a1f00338b8b8a748f2f2", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.nll.stderr", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.nll.stderr?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -53,7 +53,15 @@ LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:30:24\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n+   |               -        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n+   |               |\n+   |               let's call the lifetime of this reference `'1`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/must_outlive_least_region_or_bound.rs:37:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |               -- lifetime `'a` defined here                         ^ returning this value requires that `'a` must outlive `'static`\n@@ -62,7 +70,7 @@ LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    = help: consider replacing `'a` with `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:38:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:42:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                          --  -- lifetime `'b` defined here  ^^^^^^^^^^^^^^^^ opaque type requires that `'b` must outlive `'a`\n@@ -72,14 +80,14 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    = help: consider adding the following bound: `'b: 'a`\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:43:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:47:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                                   ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider adding an explicit lifetime bound `T: 'static`...\n \n-error: aborting due to 8 previous errors\n+error: aborting due to 9 previous errors\n \n Some errors have detailed explanations: E0310, E0621.\n For more information about an error, try `rustc --explain E0310`."}, {"sha": "9bf86fa66cdeda4c7ccd2cd6a55d18a2fbdc570a", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.rs?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -27,6 +27,10 @@ fn elided4(x: &i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n fn explicit4<'a>(x: &'a i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n //~^ ERROR cannot infer an appropriate lifetime\n \n+fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n+//~^ ERROR cannot infer an appropriate lifetime\n+//~| ERROR cannot infer an appropriate lifetime\n+\n trait LifetimeTrait<'a> {}\n impl<'a> LifetimeTrait<'a> for &'a i32 {}\n "}, {"sha": "ffadcaae08e05ed165636b369249098c140a5f37", "filename": "src/test/ui/impl-trait/must_outlive_least_region_or_bound.stderr", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fmust_outlive_least_region_or_bound.stderr?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -87,13 +87,48 @@ LL | fn foo<'a>(x: &i32) -> impl Copy + 'a { x }\n    |               help: add explicit lifetime `'a` to the type of `x`: `&'a i32`\n \n error[E0759]: cannot infer an appropriate lifetime\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:69\n+  --> $DIR/must_outlive_least_region_or_bound.rs:30:65\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n+   |               ---- this data with an anonymous lifetime `'_`... ^ ...is captured here, requiring it to live as long as `'static`\n+   |\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug + '_>, impl Debug) { (Box::new(x), x) }\n+   |                                       ^^^^\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n+   |                                                    ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:30:69\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n+   |               ---- this data with an anonymous lifetime `'_`...     ^ ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/must_outlive_least_region_or_bound.rs:30:41\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug) { (Box::new(x), x) }\n+   |                                         ^^^^^^^^^^\n+help: to declare that the trait object captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug + '_>, impl Debug) { (Box::new(x), x) }\n+   |                                       ^^^^\n+help: to declare that the `impl Trait` captures data from argument `x`, you can add an explicit `'_` lifetime bound\n+   |\n+LL | fn elided5(x: &i32) -> (Box<dyn Debug>, impl Debug + '_) { (Box::new(x), x) }\n+   |                                                    ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/must_outlive_least_region_or_bound.rs:37:69\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                      ------- this data with lifetime `'a`...        ^ ...is captured here...\n    |\n note: ...and is required to live as long as `'static` here\n-  --> $DIR/must_outlive_least_region_or_bound.rs:33:34\n+  --> $DIR/must_outlive_least_region_or_bound.rs:37:34\n    |\n LL | fn with_bound<'a>(x: &'a i32) -> impl LifetimeTrait<'a> + 'static { x }\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -107,7 +142,7 @@ LL | fn with_bound<'a>(x: &'static i32) -> impl LifetimeTrait<'a> + 'static { x\n    |                      ^^^^^^^^^^^^\n \n error[E0623]: lifetime mismatch\n-  --> $DIR/must_outlive_least_region_or_bound.rs:38:61\n+  --> $DIR/must_outlive_least_region_or_bound.rs:42:61\n    |\n LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32) {\n    |                                                 -------     ^^^^^^^^^^^^^^^^\n@@ -116,7 +151,7 @@ LL | fn move_lifetime_into_fn<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Fn(&'a u32\n    |                                                 this parameter and the return type are declared with different lifetimes...\n \n error[E0310]: the parameter type `T` may not live long enough\n-  --> $DIR/must_outlive_least_region_or_bound.rs:43:51\n+  --> $DIR/must_outlive_least_region_or_bound.rs:47:51\n    |\n LL | fn ty_param_wont_outlive_static<T:Debug>(x: T) -> impl Debug + 'static {\n    |                                 --                ^^^^^^^^^^^^^^^^^^^^ ...so that the type `T` will meet its required lifetime bounds\n@@ -181,7 +216,7 @@ help: alternatively, add an explicit `'static` bound to this reference\n LL | fn explicit4<'a>(x: &'static i32) -> Box<dyn Debug + 'static> { Box::new(x) }\n    |                     ^^^^^^^^^^^^\n \n-error: aborting due to 12 previous errors\n+error: aborting due to 14 previous errors\n \n Some errors have detailed explanations: E0310, E0621, E0623, E0759.\n For more information about an error, try `rustc --explain E0310`."}, {"sha": "f2fbb0ba7d7556738dd6951afe48ea920e2553d7", "filename": "src/test/ui/self/arbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fself%2Farbitrary_self_types_pin_lifetime_impl_trait-async.stderr?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -6,6 +6,11 @@ LL |     async fn f(self: Pin<&Self>) -> impl Clone { self }\n    |                |     |\n    |                |     this data with an anonymous lifetime `'_`...\n    |                ...is captured here...\n+   |\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     async fn f(self: Pin<&Self>) -> impl Clone + '_ { self }\n+   |                                                ^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2407d13714a2ad555938006713e07684149f71c7", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.nll.stderr", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.nll.stderr?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -0,0 +1,53 @@\n+error: lifetime may not live long enough\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:27:23\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |             -         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'1` must outlive `'static`\n+   |             |\n+   |             let's call the lifetime of this reference `'1`\n+   |\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'1`, add `'_` as a bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: lifetime may not live long enough\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:39:9\n+   |\n+LL |       fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |               - let's call the lifetime of this reference `'1`\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________^ returning this value requires that `'1` must outlive `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:50:9\n+   |\n+LL |       fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |               -- lifetime `'a` defined here\n+LL | /         Iter {\n+LL | |             current: None,\n+LL | |             remaining: self.0.iter(),\n+LL | |         }\n+   | |_________^ returning this value requires that `'a` must outlive `'static`\n+   |\n+   = help: consider replacing `'a` with `'static`\n+\n+error: lifetime may not live long enough\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:60:30\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |             --               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ opaque type requires that `'a` must outlive `'static`\n+   |             |\n+   |             lifetime `'a` defined here\n+   |\n+   = help: consider replacing `'a` with `'static`\n+help: to allow this `impl Trait` to capture borrowed data with lifetime `'a`, add `'a` as a bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "f78edb1c83a4c97e549713f99975b073b9b30144", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.rs", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.rs?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -0,0 +1,68 @@\n+trait Foo {}\n+impl<'a, T: Foo> Foo for &'a T {}\n+impl<T: Foo + ?Sized> Foo for Box<T> {}\n+\n+struct Iter<'a, T> {\n+    current: Option<Box<dyn Foo + 'a>>,\n+    remaining: T,\n+}\n+\n+impl<'a, T> Iterator for Iter<'a, T>\n+where\n+    T: Iterator,\n+    T::Item: Foo + 'a,\n+{\n+    type Item = Box<dyn Foo + 'a>;\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let result = self.current.take();\n+        self.current = Box::new(self.remaining.next()).map(|f| Box::new(f) as _);\n+        result\n+    }\n+}\n+\n+struct Bar(Vec<Box<dyn Foo>>);\n+\n+impl Bar {\n+    fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+        Iter {\n+            current: None,\n+            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+        }\n+    }\n+}\n+\n+struct Baz(Vec<Box<dyn Foo>>);\n+\n+impl Baz {\n+    fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+        Iter {\n+            current: None,\n+            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+        }\n+    }\n+}\n+\n+struct Bat(Vec<Box<dyn Foo>>);\n+\n+impl Bat {\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+        Iter {\n+            current: None,\n+            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+        }\n+    }\n+}\n+\n+struct Ban(Vec<Box<dyn Foo>>);\n+\n+impl Ban {\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+        Iter {\n+            current: None,\n+            remaining: self.0.iter(), //~ ERROR cannot infer an appropriate lifetime\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "1257e9b172cf71ac9e4458f81fe212e6eb0d2744", "filename": "src/test/ui/suggestions/lifetimes/trait-object-nested-in-impl-trait.stderr", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/562f4967b4ce7e859b807fc022040bbb22d1f70e/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Flifetimes%2Ftrait-object-nested-in-impl-trait.stderr?ref=562f4967b4ce7e859b807fc022040bbb22d1f70e", "patch": "@@ -0,0 +1,95 @@\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:30:31\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |             ----- this data with an anonymous lifetime `'_`...\n+...\n+LL |             remaining: self.0.iter(),\n+   |                        ------ ^^^^\n+   |                        |\n+   |                        ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:27:23\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |                                                          ^^^^\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> {\n+   |                                                        ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:41:31\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |             ----- this data with an anonymous lifetime `'_`...\n+...\n+LL |             remaining: self.0.iter(),\n+   |                        ------ ^^^^\n+   |                        |\n+   |                        ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:38:23\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo>> + '_ {\n+   |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'_` lifetime bound\n+   |\n+LL |     fn iter(&self) -> impl Iterator<Item = Box<dyn Foo + '_>> + '_ {\n+   |                                                        ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:52:31\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                 -------- this data with lifetime `'a`...\n+...\n+LL |             remaining: self.0.iter(),\n+   |                        ------ ^^^^\n+   |                        |\n+   |                        ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:49:30\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> + 'a {\n+   |                                                               ^^^^\n+\n+error[E0759]: cannot infer an appropriate lifetime\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:63:31\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                 -------- this data with lifetime `'a`...\n+...\n+LL |             remaining: self.0.iter(),\n+   |                        ------ ^^^^\n+   |                        |\n+   |                        ...is captured here...\n+   |\n+note: ...and is required to live as long as `'static` here\n+  --> $DIR/trait-object-nested-in-impl-trait.rs:60:30\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> {\n+   |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+help: to declare that the `impl Trait` captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo>> + 'a {\n+   |                                                                 ^^^^\n+help: to declare that the trait object captures data from argument `self`, you can add an explicit `'a` lifetime bound\n+   |\n+LL |     fn iter<'a>(&'a self) -> impl Iterator<Item = Box<dyn Foo + 'a>> {\n+   |                                                               ^^^^\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0759`."}]}