{"sha": "5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYzY3MDliOTViYjBjY2U0Y2ZmYTliZDg3ZDI0MTkyOGJjN2YzZjY=", "commit": {"author": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-05T01:04:06Z"}, "committer": {"name": "C", "email": "DeveloperC@protonmail.com", "date": "2020-12-29T14:03:30Z"}, "message": "refactor: moving SourceIterMarker into source_iter_marker.rs", "tree": {"sha": "791cac8c7924b2a0738e2bffeb9e43ceba9b2d03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/791cac8c7924b2a0738e2bffeb9e43ceba9b2d03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6", "html_url": "https://github.com/rust-lang/rust/commit/5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6/comments", "author": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DeveloperC286", "id": 65925405, "node_id": "MDQ6VXNlcjY1OTI1NDA1", "avatar_url": "https://avatars.githubusercontent.com/u/65925405?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DeveloperC286", "html_url": "https://github.com/DeveloperC286", "followers_url": "https://api.github.com/users/DeveloperC286/followers", "following_url": "https://api.github.com/users/DeveloperC286/following{/other_user}", "gists_url": "https://api.github.com/users/DeveloperC286/gists{/gist_id}", "starred_url": "https://api.github.com/users/DeveloperC286/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DeveloperC286/subscriptions", "organizations_url": "https://api.github.com/users/DeveloperC286/orgs", "repos_url": "https://api.github.com/users/DeveloperC286/repos", "events_url": "https://api.github.com/users/DeveloperC286/events{/privacy}", "received_events_url": "https://api.github.com/users/DeveloperC286/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "840c4e2873476a7d6101f71e4f63b3024245ccd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/840c4e2873476a7d6101f71e4f63b3024245ccd1", "html_url": "https://github.com/rust-lang/rust/commit/840c4e2873476a7d6101f71e4f63b3024245ccd1"}], "stats": {"total": 217, "additions": 113, "deletions": 104}, "files": [{"sha": "bd71d7004b993d1560d113f6de4b57b232d1aa41", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 3, "deletions": 104, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6", "patch": "@@ -60,7 +60,7 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::{arith_offset, assume};\n use core::iter::{\n-    FromIterator, InPlaceIterable, SourceIter, TrustedLen,\n+    FromIterator, TrustedLen,\n };\n use core::marker::PhantomData;\n use core::mem::{self, ManuallyDrop, MaybeUninit};\n@@ -101,6 +101,8 @@ use self::is_zero::IsZero;\n \n mod is_zero;\n \n+mod source_iter_marker;\n+\n /// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n@@ -2356,109 +2358,6 @@ impl<T> SpecFromIter<T, IntoIter<T>> for Vec<T> {\n     }\n }\n \n-fn write_in_place_with_drop<T>(\n-    src_end: *const T,\n-) -> impl FnMut(InPlaceDrop<T>, T) -> Result<InPlaceDrop<T>, !> {\n-    move |mut sink, item| {\n-        unsafe {\n-            // the InPlaceIterable contract cannot be verified precisely here since\n-            // try_fold has an exclusive reference to the source pointer\n-            // all we can do is check if it's still in range\n-            debug_assert!(sink.dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n-            ptr::write(sink.dst, item);\n-            sink.dst = sink.dst.add(1);\n-        }\n-        Ok(sink)\n-    }\n-}\n-\n-/// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n-/// source allocation, i.e. executing the pipeline in place.\n-///\n-/// The SourceIter parent trait is necessary for the specializing function to access the allocation\n-/// which is to be reused. But it is not sufficient for the specialization to be valid. See\n-/// additional bounds on the impl.\n-#[rustc_unsafe_specialization_marker]\n-trait SourceIterMarker: SourceIter<Source: AsIntoIter> {}\n-\n-// The std-internal SourceIter/InPlaceIterable traits are only implemented by chains of\n-// Adapter<Adapter<Adapter<IntoIter>>> (all owned by core/std). Additional bounds\n-// on the adapter implementations (beyond `impl<I: Trait> Trait for Adapter<I>`) only depend on other\n-// traits already marked as specialization traits (Copy, TrustedRandomAccess, FusedIterator).\n-// I.e. the marker does not depend on lifetimes of user-supplied types. Modulo the Copy hole, which\n-// several other specializations already depend on.\n-impl<T> SourceIterMarker for T where T: SourceIter<Source: AsIntoIter> + InPlaceIterable {}\n-\n-impl<T, I> SpecFromIter<T, I> for Vec<T>\n-where\n-    I: Iterator<Item = T> + SourceIterMarker,\n-{\n-    default fn from_iter(mut iterator: I) -> Self {\n-        // Additional requirements which cannot expressed via trait bounds. We rely on const eval\n-        // instead:\n-        // a) no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic\n-        // b) size match as required by Alloc contract\n-        // c) alignments match as required by Alloc contract\n-        if mem::size_of::<T>() == 0\n-            || mem::size_of::<T>()\n-                != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n-            || mem::align_of::<T>()\n-                != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n-        {\n-            // fallback to more generic implementations\n-            return SpecFromIterNested::from_iter(iterator);\n-        }\n-\n-        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n-            let inner = iterator.as_inner().as_into_iter();\n-            (\n-                inner.buf.as_ptr(),\n-                inner.ptr,\n-                inner.buf.as_ptr() as *mut T,\n-                inner.end as *const T,\n-                inner.cap,\n-            )\n-        };\n-\n-        // use try-fold since\n-        // - it vectorizes better for some iterator adapters\n-        // - unlike most internal iteration methods, it only takes a &mut self\n-        // - it lets us thread the write pointer through its innards and get it back in the end\n-        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n-        let sink = iterator\n-            .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n-            .unwrap();\n-        // iteration succeeded, don't drop head\n-        let dst = ManuallyDrop::new(sink).dst;\n-\n-        let src = unsafe { iterator.as_inner().as_into_iter() };\n-        // check if SourceIter contract was upheld\n-        // caveat: if they weren't we may not even make it to this point\n-        debug_assert_eq!(src_buf, src.buf.as_ptr());\n-        // check InPlaceIterable contract. This is only possible if the iterator advanced the\n-        // source pointer at all. If it uses unchecked access via TrustedRandomAccess\n-        // then the source pointer will stay in its initial position and we can't use it as reference\n-        if src.ptr != src_ptr {\n-            debug_assert!(\n-                dst as *const _ <= src.ptr,\n-                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n-            );\n-        }\n-\n-        // drop any remaining values at the tail of the source\n-        src.drop_remaining();\n-        // but prevent drop of the allocation itself once IntoIter goes out of scope\n-        src.forget_allocation();\n-\n-        let vec = unsafe {\n-            let len = dst.offset_from(dst_buf) as usize;\n-            Vec::from_raw_parts(dst_buf, len, cap)\n-        };\n-\n-        vec\n-    }\n-}\n-\n impl<'a, T: 'a, I> SpecFromIter<&'a T, I> for Vec<T>\n where\n     I: Iterator<Item = &'a T>,"}, {"sha": "eb3ae01a47e9ba1e06ebd0f866d215fad36f098a", "filename": "library/alloc/src/vec/source_iter_marker.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs?ref=5ac6709b95bb0cce4cffa9bd87d241928bc7f3f6", "patch": "@@ -0,0 +1,110 @@\n+use core::iter::{\n+    InPlaceIterable, SourceIter,\n+};\n+use core::mem::{self, ManuallyDrop};\n+use core::ptr::{self};\n+\n+use super::{Vec, InPlaceDrop, AsIntoIter, SpecFromIter, SpecFromIterNested};\n+\n+/// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n+/// source allocation, i.e. executing the pipeline in place.\n+///\n+/// The SourceIter parent trait is necessary for the specializing function to access the allocation\n+/// which is to be reused. But it is not sufficient for the specialization to be valid. See\n+/// additional bounds on the impl.\n+#[rustc_unsafe_specialization_marker]\n+pub (super) trait SourceIterMarker: SourceIter<Source: AsIntoIter> {}\n+\n+// The std-internal SourceIter/InPlaceIterable traits are only implemented by chains of\n+// Adapter<Adapter<Adapter<IntoIter>>> (all owned by core/std). Additional bounds\n+// on the adapter implementations (beyond `impl<I: Trait> Trait for Adapter<I>`) only depend on other\n+// traits already marked as specialization traits (Copy, TrustedRandomAccess, FusedIterator).\n+// I.e. the marker does not depend on lifetimes of user-supplied types. Modulo the Copy hole, which\n+// several other specializations already depend on.\n+impl<T> SourceIterMarker for T where T: SourceIter<Source: AsIntoIter> + InPlaceIterable {}\n+\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n+    where\n+        I: Iterator<Item = T> + SourceIterMarker,\n+{\n+    default fn from_iter(mut iterator: I) -> Self {\n+        // Additional requirements which cannot expressed via trait bounds. We rely on const eval\n+        // instead:\n+        // a) no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic\n+        // b) size match as required by Alloc contract\n+        // c) alignments match as required by Alloc contract\n+        if mem::size_of::<T>() == 0\n+            || mem::size_of::<T>()\n+            != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n+            || mem::align_of::<T>()\n+            != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n+        {\n+            // fallback to more generic implementations\n+            return SpecFromIterNested::from_iter(iterator);\n+        }\n+\n+        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n+            let inner = iterator.as_inner().as_into_iter();\n+            (\n+                inner.buf.as_ptr(),\n+                inner.ptr,\n+                inner.buf.as_ptr() as *mut T,\n+                inner.end as *const T,\n+                inner.cap,\n+            )\n+        };\n+\n+        // use try-fold since\n+        // - it vectorizes better for some iterator adapters\n+        // - unlike most internal iteration methods, it only takes a &mut self\n+        // - it lets us thread the write pointer through its innards and get it back in the end\n+        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n+        let sink = iterator\n+            .try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(dst_end))\n+            .unwrap();\n+        // iteration succeeded, don't drop head\n+        let dst = ManuallyDrop::new(sink).dst;\n+\n+        let src = unsafe { iterator.as_inner().as_into_iter() };\n+        // check if SourceIter contract was upheld\n+        // caveat: if they weren't we may not even make it to this point\n+        debug_assert_eq!(src_buf, src.buf.as_ptr());\n+        // check InPlaceIterable contract. This is only possible if the iterator advanced the\n+        // source pointer at all. If it uses unchecked access via TrustedRandomAccess\n+        // then the source pointer will stay in its initial position and we can't use it as reference\n+        if src.ptr != src_ptr {\n+            debug_assert!(\n+                dst as *const _ <= src.ptr,\n+                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n+            );\n+        }\n+\n+        // drop any remaining values at the tail of the source\n+        src.drop_remaining();\n+        // but prevent drop of the allocation itself once IntoIter goes out of scope\n+        src.forget_allocation();\n+\n+        let vec = unsafe {\n+            let len = dst.offset_from(dst_buf) as usize;\n+            Vec::from_raw_parts(dst_buf, len, cap)\n+        };\n+\n+        vec\n+    }\n+}\n+\n+fn write_in_place_with_drop<T>(\n+    src_end: *const T,\n+) -> impl FnMut(InPlaceDrop<T>, T) -> Result<InPlaceDrop<T>, !> {\n+    move |mut sink, item| {\n+        unsafe {\n+            // the InPlaceIterable contract cannot be verified precisely here since\n+            // try_fold has an exclusive reference to the source pointer\n+            // all we can do is check if it's still in range\n+            debug_assert!(sink.dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n+            ptr::write(sink.dst, item);\n+            sink.dst = sink.dst.add(1);\n+        }\n+        Ok(sink)\n+    }\n+}"}]}