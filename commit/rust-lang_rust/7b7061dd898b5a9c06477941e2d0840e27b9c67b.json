{"sha": "7b7061dd898b5a9c06477941e2d0840e27b9c67b", "node_id": "C_kwDOAAsO6NoAKDdiNzA2MWRkODk4YjVhOWMwNjQ3Nzk0MWUyZDA4NDBlMjdiOWM2N2I", "commit": {"author": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-05-07T05:02:11Z"}, "committer": {"name": "David Wood", "email": "david.wood@huawei.com", "date": "2022-05-12T06:21:51Z"}, "message": "macros: spanless subdiagnostics from `()` fields\n\nType attributes could previously be used to support spanless\nsubdiagnostics but these couldn't easily be made optional in the same\nway that spanned subdiagnostics could by using a field attribute on a\nfield with an `Option<Span>` type. Spanless subdiagnostics can now be\nspecified on fields with `()` type or `Option<()>` type.\n\nSigned-off-by: David Wood <david.wood@huawei.com>", "tree": {"sha": "9a1134b917032ed2345f64f1ba21daf59266d223", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a1134b917032ed2345f64f1ba21daf59266d223"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b7061dd898b5a9c06477941e2d0840e27b9c67b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b7061dd898b5a9c06477941e2d0840e27b9c67b", "html_url": "https://github.com/rust-lang/rust/commit/7b7061dd898b5a9c06477941e2d0840e27b9c67b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b7061dd898b5a9c06477941e2d0840e27b9c67b/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d2ea98cff1fde1d8b9e83a0eb639b8ec2cb82d8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d2ea98cff1fde1d8b9e83a0eb639b8ec2cb82d8", "html_url": "https://github.com/rust-lang/rust/commit/1d2ea98cff1fde1d8b9e83a0eb639b8ec2cb82d8"}], "stats": {"total": 130, "additions": 97, "deletions": 33}, "files": [{"sha": "6788ce37eae37d93a088c85d0e3234dfbc7ff436", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/7b7061dd898b5a9c06477941e2d0840e27b9c67b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7061dd898b5a9c06477941e2d0840e27b9c67b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=7b7061dd898b5a9c06477941e2d0840e27b9c67b", "patch": "@@ -5,10 +5,10 @@ use crate::diagnostics::error::{\n     SessionDiagnosticDeriveError,\n };\n use crate::diagnostics::utils::{\n-    report_error_if_not_applied_to_span, type_matches_path, Applicability, FieldInfo, FieldInnerTy,\n-    HasFieldMap, SetOnce,\n+    report_error_if_not_applied_to_span, report_type_error, type_is_unit, type_matches_path,\n+    Applicability, FieldInfo, FieldInnerTy, HasFieldMap, SetOnce,\n };\n-use proc_macro2::TokenStream;\n+use proc_macro2::{Ident, TokenStream};\n use quote::{format_ident, quote};\n use std::collections::HashMap;\n use std::str::FromStr;\n@@ -388,7 +388,8 @@ impl SessionDiagnosticDeriveBuilder {\n     ) -> Result<TokenStream, SessionDiagnosticDeriveError> {\n         let diag = &self.diag;\n \n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n+        let ident = &attr.path.segments.last().unwrap().ident;\n+        let name = ident.to_string();\n         let name = name.as_str();\n \n         let meta = attr.parse_meta()?;\n@@ -405,9 +406,18 @@ impl SessionDiagnosticDeriveBuilder {\n                         #diag.set_span(#binding);\n                     })\n                 }\n-                \"label\" | \"note\" | \"help\" => {\n+                \"label\" => {\n                     report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_subdiagnostic(binding, name, name))\n+                    Ok(self.add_spanned_subdiagnostic(binding, ident, name))\n+                }\n+                \"note\" | \"help\" => {\n+                    if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                        Ok(self.add_spanned_subdiagnostic(binding, ident, name))\n+                    } else if type_is_unit(&info.ty) {\n+                        Ok(self.add_subdiagnostic(ident, name))\n+                    } else {\n+                        report_type_error(attr, \"`Span` or `()`\")?;\n+                    }\n                 }\n                 \"subdiagnostic\" => Ok(quote! { #diag.subdiagnostic(#binding); }),\n                 _ => throw_invalid_attr!(attr, &meta, |diag| {\n@@ -416,9 +426,18 @@ impl SessionDiagnosticDeriveBuilder {\n                 }),\n             },\n             Meta::NameValue(MetaNameValue { lit: syn::Lit::Str(ref s), .. }) => match name {\n-                \"label\" | \"note\" | \"help\" => {\n+                \"label\" => {\n                     report_error_if_not_applied_to_span(attr, &info)?;\n-                    Ok(self.add_subdiagnostic(binding, name, &s.value()))\n+                    Ok(self.add_spanned_subdiagnostic(binding, ident, &s.value()))\n+                }\n+                \"note\" | \"help\" => {\n+                    if type_matches_path(&info.ty, &[\"rustc_span\", \"Span\"]) {\n+                        Ok(self.add_spanned_subdiagnostic(binding, ident, &s.value()))\n+                    } else if type_is_unit(&info.ty) {\n+                        Ok(self.add_subdiagnostic(ident, &s.value()))\n+                    } else {\n+                        report_type_error(attr, \"`Span` or `()`\")?;\n+                    }\n                 }\n                 _ => throw_invalid_attr!(attr, &meta, |diag| {\n                     diag.help(\"only `label`, `note` and `help` are valid field attributes\")\n@@ -510,12 +529,12 @@ impl SessionDiagnosticDeriveBuilder {\n         }\n     }\n \n-    /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug and\n-    /// `fluent_attr_identifier`.\n-    fn add_subdiagnostic(\n+    /// Adds a spanned subdiagnostic by generating a `diag.span_$kind` call with the current slug\n+    /// and `fluent_attr_identifier`.\n+    fn add_spanned_subdiagnostic(\n         &self,\n         field_binding: TokenStream,\n-        kind: &str,\n+        kind: &Ident,\n         fluent_attr_identifier: &str,\n     ) -> TokenStream {\n         let diag = &self.diag;\n@@ -531,6 +550,16 @@ impl SessionDiagnosticDeriveBuilder {\n         }\n     }\n \n+    /// Adds a subdiagnostic by generating a `diag.span_$kind` call with the current slug\n+    /// and `fluent_attr_identifier`.\n+    fn add_subdiagnostic(&self, kind: &Ident, fluent_attr_identifier: &str) -> TokenStream {\n+        let diag = &self.diag;\n+        let slug = self.slug.as_ref().map(|(slug, _)| slug.as_str()).unwrap_or(\"missing-slug\");\n+        quote! {\n+            #diag.#kind(rustc_errors::DiagnosticMessage::fluent_attr(#slug, #fluent_attr_identifier));\n+        }\n+    }\n+\n     fn span_and_applicability_of_ty(\n         &self,\n         info: FieldInfo<'_>,"}, {"sha": "af5a30880e05f2fdce5c5eaa4f19cf97d85d3c0c", "filename": "compiler/rustc_macros/src/diagnostics/utils.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/7b7061dd898b5a9c06477941e2d0840e27b9c67b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7061dd898b5a9c06477941e2d0840e27b9c67b/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Futils.rs?ref=7b7061dd898b5a9c06477941e2d0840e27b9c67b", "patch": "@@ -4,7 +4,7 @@ use proc_macro2::TokenStream;\n use quote::{format_ident, quote, ToTokens};\n use std::collections::BTreeSet;\n use std::str::FromStr;\n-use syn::{spanned::Spanned, Attribute, Meta, Type, Visibility};\n+use syn::{spanned::Spanned, Attribute, Meta, Type, TypeTuple, Visibility};\n use synstructure::BindingInfo;\n \n /// Checks whether the type name of `ty` matches `name`.\n@@ -25,31 +25,43 @@ pub(crate) fn type_matches_path(ty: &Type, name: &[&str]) -> bool {\n     }\n }\n \n-/// Reports an error if the field's type is not `Applicability`.\n+/// Checks whether the type `ty` is `()`.\n+pub(crate) fn type_is_unit(ty: &Type) -> bool {\n+    if let Type::Tuple(TypeTuple { elems, .. }) = ty { elems.is_empty() } else { false }\n+}\n+\n+/// Reports a type error for field with `attr`.\n+pub(crate) fn report_type_error(\n+    attr: &Attribute,\n+    ty_name: &str,\n+) -> Result<!, SessionDiagnosticDeriveError> {\n+    let name = attr.path.segments.last().unwrap().ident.to_string();\n+    let meta = attr.parse_meta()?;\n+\n+    throw_span_err!(\n+        attr.span().unwrap(),\n+        &format!(\n+            \"the `#[{}{}]` attribute can only be applied to fields of type {}\",\n+            name,\n+            match meta {\n+                Meta::Path(_) => \"\",\n+                Meta::NameValue(_) => \" = ...\",\n+                Meta::List(_) => \"(...)\",\n+            },\n+            ty_name\n+        )\n+    );\n+}\n+\n+/// Reports an error if the field's type does not match `path`.\n fn report_error_if_not_applied_to_ty(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n     path: &[&str],\n     ty_name: &str,\n ) -> Result<(), SessionDiagnosticDeriveError> {\n     if !type_matches_path(&info.ty, path) {\n-        let name = attr.path.segments.last().unwrap().ident.to_string();\n-        let name = name.as_str();\n-        let meta = attr.parse_meta()?;\n-\n-        throw_span_err!(\n-            attr.span().unwrap(),\n-            &format!(\n-                \"the `#[{}{}]` attribute can only be applied to fields of type `{}`\",\n-                name,\n-                match meta {\n-                    Meta::Path(_) => \"\",\n-                    Meta::NameValue(_) => \" = ...\",\n-                    Meta::List(_) => \"(...)\",\n-                },\n-                ty_name\n-            )\n-        );\n+        report_type_error(attr, ty_name)?;\n     }\n \n     Ok(())\n@@ -64,7 +76,7 @@ pub(crate) fn report_error_if_not_applied_to_applicability(\n         attr,\n         info,\n         &[\"rustc_errors\", \"Applicability\"],\n-        \"Applicability\",\n+        \"`Applicability`\",\n     )\n }\n \n@@ -73,7 +85,7 @@ pub(crate) fn report_error_if_not_applied_to_span(\n     attr: &Attribute,\n     info: &FieldInfo<'_>,\n ) -> Result<(), SessionDiagnosticDeriveError> {\n-    report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"Span\")\n+    report_error_if_not_applied_to_ty(attr, info, &[\"rustc_span\", \"Span\"], \"`Span`\")\n }\n \n /// Inner type of a field and type of wrapper."}, {"sha": "0baebdb713062eba1c1ada8c8cdd8f16ee0aaddb", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b7061dd898b5a9c06477941e2d0840e27b9c67b/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7061dd898b5a9c06477941e2d0840e27b9c67b/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=7b7061dd898b5a9c06477941e2d0840e27b9c67b", "patch": "@@ -1,5 +1,6 @@\n #![feature(allow_internal_unstable)]\n #![feature(let_else)]\n+#![feature(never_type)]\n #![feature(proc_macro_diagnostic)]\n #![allow(rustc::default_hash_types)]\n #![recursion_limit = \"128\"]"}, {"sha": "1bc7475eca79496614b863b7947ad4351cb85b52", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7b7061dd898b5a9c06477941e2d0840e27b9c67b/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b7061dd898b5a9c06477941e2d0840e27b9c67b/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=7b7061dd898b5a9c06477941e2d0840e27b9c67b", "patch": "@@ -482,3 +482,25 @@ struct VecField {\n     #[label]\n     spans: Vec<Span>,\n }\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct UnitField {\n+    #[primary_span]\n+    spans: Span,\n+    #[help]\n+    foo: (),\n+    #[help = \"a\"]\n+    bar: (),\n+}\n+\n+#[derive(SessionDiagnostic)]\n+#[error(code = \"E0123\", slug = \"foo\")]\n+struct OptUnitField {\n+    #[primary_span]\n+    spans: Span,\n+    #[help]\n+    foo: Option<()>,\n+    #[help = \"a\"]\n+    bar: Option<()>,\n+}"}]}