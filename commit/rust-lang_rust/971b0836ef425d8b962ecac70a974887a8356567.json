{"sha": "971b0836ef425d8b962ecac70a974887a8356567", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3MWIwODM2ZWY0MjVkOGI5NjJlY2FjNzBhOTc0ODg3YTgzNTY1Njc=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-31T12:13:09Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-05-31T12:15:15Z"}, "message": "Use `Name`s instead of Strings in the completion rendering api", "tree": {"sha": "8649259da32910831c45aee3ba9b68abce8f5b37", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8649259da32910831c45aee3ba9b68abce8f5b37"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/971b0836ef425d8b962ecac70a974887a8356567", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/971b0836ef425d8b962ecac70a974887a8356567", "html_url": "https://github.com/rust-lang/rust/commit/971b0836ef425d8b962ecac70a974887a8356567", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/971b0836ef425d8b962ecac70a974887a8356567/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cb3f1d17b54a7e144db495e073551049c9c482c", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cb3f1d17b54a7e144db495e073551049c9c482c", "html_url": "https://github.com/rust-lang/rust/commit/3cb3f1d17b54a7e144db495e073551049c9c482c"}], "stats": {"total": 307, "additions": 165, "deletions": 142}, "files": [{"sha": "151bf378390d5977382a571df15190a1355addf8", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=971b0836ef425d8b962ecac70a974887a8356567", "patch": "@@ -18,7 +18,7 @@ pub(crate) mod unqualified_path;\n \n use std::iter;\n \n-use hir::{known, ModPath, ScopeDef, Type};\n+use hir::known;\n use ide_db::SymbolKind;\n \n use crate::{\n@@ -69,12 +69,17 @@ impl Completions {\n         items.into_iter().for_each(|item| self.add(item.into()))\n     }\n \n-    pub(crate) fn add_field(&mut self, ctx: &CompletionContext, field: hir::Field, ty: &Type) {\n+    pub(crate) fn add_field(&mut self, ctx: &CompletionContext, field: hir::Field, ty: &hir::Type) {\n         let item = render_field(RenderContext::new(ctx), field, ty);\n         self.add(item);\n     }\n \n-    pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &Type) {\n+    pub(crate) fn add_tuple_field(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        field: usize,\n+        ty: &hir::Type,\n+    ) {\n         let item = render_tuple_field(RenderContext::new(ctx), field, ty);\n         self.add(item);\n     }\n@@ -89,8 +94,8 @@ impl Completions {\n     pub(crate) fn add_resolution(\n         &mut self,\n         ctx: &CompletionContext,\n-        local_name: String,\n-        resolution: &ScopeDef,\n+        local_name: hir::Name,\n+        resolution: &hir::ScopeDef,\n     ) {\n         if let Some(item) = render_resolution(RenderContext::new(ctx), local_name, resolution) {\n             self.add(item);\n@@ -100,7 +105,7 @@ impl Completions {\n     pub(crate) fn add_macro(\n         &mut self,\n         ctx: &CompletionContext,\n-        name: Option<String>,\n+        name: Option<hir::Name>,\n         macro_: hir::MacroDef,\n     ) {\n         let name = match name {\n@@ -116,7 +121,7 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext,\n         func: hir::Function,\n-        local_name: Option<String>,\n+        local_name: Option<hir::Name>,\n     ) {\n         if let Some(item) = render_fn(RenderContext::new(ctx), None, local_name, func) {\n             self.add(item)\n@@ -127,7 +132,7 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext,\n         func: hir::Function,\n-        local_name: Option<String>,\n+        local_name: Option<hir::Name>,\n     ) {\n         if let Some(item) = render_method(RenderContext::new(ctx), None, local_name, func) {\n             self.add(item)\n@@ -149,7 +154,7 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext,\n         variant: hir::Variant,\n-        path: ModPath,\n+        path: hir::ModPath,\n     ) {\n         if let Some(item) = render_variant_pat(RenderContext::new(ctx), variant, None, Some(path)) {\n             self.add(item);\n@@ -183,7 +188,7 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext,\n         variant: hir::Variant,\n-        path: ModPath,\n+        path: hir::ModPath,\n     ) {\n         let item = render_variant(RenderContext::new(ctx), None, None, variant, Some(path));\n         self.add(item);\n@@ -193,7 +198,7 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext,\n         variant: hir::Variant,\n-        local_name: Option<String>,\n+        local_name: Option<hir::Name>,\n     ) {\n         let item = render_variant(RenderContext::new(ctx), None, local_name, variant, None);\n         self.add(item);"}, {"sha": "8ccccb64606f2b5074f8bdf3b707b236ef5e7d6c", "filename": "crates/ide_completion/src/completions/lifetime.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Flifetime.rs?ref=971b0836ef425d8b962ecac70a974887a8356567", "patch": "@@ -16,15 +16,14 @@ pub(crate) fn complete_lifetime(acc: &mut Completions, ctx: &CompletionContext)\n         (Some(lt), Some(lp)) if lp == lt.clone() => return,\n         (Some(_), Some(lp)) => {\n             lp_string = lp.to_string();\n-            Some(&lp_string)\n+            Some(&*lp_string)\n         }\n         _ => None,\n     };\n \n     ctx.scope.process_all_names(&mut |name, res| {\n         if let ScopeDef::GenericParam(hir::GenericParam::LifetimeParam(_)) = res {\n-            let name = name.to_string();\n-            if param_lifetime != Some(&name) {\n+            if param_lifetime != Some(&*name.to_string()) {\n                 acc.add_resolution(ctx, name, &res);\n             }\n         }\n@@ -41,7 +40,7 @@ pub(crate) fn complete_label(acc: &mut Completions, ctx: &CompletionContext) {\n     }\n     ctx.scope.process_all_names(&mut |name, res| {\n         if let ScopeDef::Label(_) = res {\n-            acc.add_resolution(ctx, name.to_string(), &res);\n+            acc.add_resolution(ctx, name, &res);\n         }\n     });\n }"}, {"sha": "202e71215a460f6d0570adf3c81616f3923eb307", "filename": "crates/ide_completion/src/completions/macro_in_item_position.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmacro_in_item_position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmacro_in_item_position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fmacro_in_item_position.rs?ref=971b0836ef425d8b962ecac70a974887a8356567", "patch": "@@ -11,11 +11,11 @@ pub(crate) fn complete_macro_in_item_position(acc: &mut Completions, ctx: &Compl\n \n     ctx.scope.process_all_names(&mut |name, res| {\n         if let hir::ScopeDef::MacroDef(mac) = res {\n-            acc.add_macro(ctx, Some(name.to_string()), mac);\n+            acc.add_macro(ctx, Some(name.clone()), mac);\n         }\n         // FIXME: This should be done in qualified_path/unqualified_path instead?\n         if let hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = res {\n-            acc.add_resolution(ctx, name.to_string(), &res);\n+            acc.add_resolution(ctx, name, &res);\n         }\n     })\n }"}, {"sha": "8a728c67effb047402c11c222c9decb34b1abb61", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=971b0836ef425d8b962ecac70a974887a8356567", "patch": "@@ -51,7 +51,7 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n             _ => false,\n         };\n         if add_resolution {\n-            acc.add_resolution(ctx, name.to_string(), &res);\n+            acc.add_resolution(ctx, name, &res);\n         }\n     });\n }"}, {"sha": "de58ce1cd95c1744237311e726f242c5a27b96f0", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=971b0836ef425d8b962ecac70a974887a8356567", "patch": "@@ -1,6 +1,6 @@\n //! Completion of paths, i.e. `some::prefix::$0`.\n \n-use hir::{Adt, HasVisibility, PathResolution, ScopeDef};\n+use hir::HasVisibility;\n use rustc_hash::FxHashSet;\n use syntax::AstNode;\n \n@@ -21,14 +21,14 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     };\n     let context_module = ctx.scope.module();\n     if ctx.expects_assoc_item() {\n-        if let PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n+        if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n             let module_scope = module.scope(ctx.db, context_module);\n             for (name, def) in module_scope {\n-                if let ScopeDef::MacroDef(macro_def) = def {\n-                    acc.add_macro(ctx, Some(name.to_string()), macro_def);\n+                if let hir::ScopeDef::MacroDef(macro_def) = def {\n+                    acc.add_macro(ctx, Some(name.clone()), macro_def);\n                 }\n-                if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = def {\n-                    acc.add_resolution(ctx, name.to_string(), &def);\n+                if let hir::ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = def {\n+                    acc.add_resolution(ctx, name, &def);\n                 }\n             }\n         }\n@@ -42,11 +42,11 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     });\n \n     match resolution {\n-        PathResolution::Def(hir::ModuleDef::Module(module)) => {\n+        hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n             let module_scope = module.scope(ctx.db, context_module);\n             for (name, def) in module_scope {\n                 if ctx.use_item_syntax.is_some() {\n-                    if let ScopeDef::Unknown = def {\n+                    if let hir::ScopeDef::Unknown = def {\n                         if let Some(name_ref) = ctx.name_ref_syntax.as_ref() {\n                             if name_ref.syntax().text() == name.to_string().as_str() {\n                                 // for `use self::foo$0`, don't suggest `foo` as a completion\n@@ -57,20 +57,20 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     }\n                 }\n \n-                acc.add_resolution(ctx, name.to_string(), &def);\n+                acc.add_resolution(ctx, name, &def);\n             }\n         }\n-        PathResolution::Def(def @ hir::ModuleDef::Adt(_))\n-        | PathResolution::Def(def @ hir::ModuleDef::TypeAlias(_))\n-        | PathResolution::Def(def @ hir::ModuleDef::BuiltinType(_)) => {\n-            if let hir::ModuleDef::Adt(Adt::Enum(e)) = def {\n+        hir::PathResolution::Def(def @ hir::ModuleDef::Adt(_))\n+        | hir::PathResolution::Def(def @ hir::ModuleDef::TypeAlias(_))\n+        | hir::PathResolution::Def(def @ hir::ModuleDef::BuiltinType(_)) => {\n+            if let hir::ModuleDef::Adt(hir::Adt::Enum(e)) = def {\n                 add_enum_variants(ctx, acc, e);\n             }\n             let ty = match def {\n                 hir::ModuleDef::Adt(adt) => adt.ty(ctx.db),\n                 hir::ModuleDef::TypeAlias(a) => {\n                     let ty = a.ty(ctx.db);\n-                    if let Some(Adt::Enum(e)) = ty.as_adt() {\n+                    if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n                         cov_mark::hit!(completes_variant_through_alias);\n                         add_enum_variants(ctx, acc, e);\n                     }\n@@ -117,7 +117,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 });\n             }\n         }\n-        PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n+        hir::PathResolution::Def(hir::ModuleDef::Trait(t)) => {\n             // Handles `Trait::assoc` as well as `<Ty as Trait>::assoc`.\n             for item in t.items(ctx.db) {\n                 if context_module.map_or(false, |m| !item.is_visible_from(ctx.db, m)) {\n@@ -130,15 +130,15 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                 }\n             }\n         }\n-        PathResolution::TypeParam(_) | PathResolution::SelfType(_) => {\n+        hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_) => {\n             if let Some(krate) = ctx.krate {\n                 let ty = match resolution {\n-                    PathResolution::TypeParam(param) => param.ty(ctx.db),\n-                    PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n+                    hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n+                    hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n                     _ => return,\n                 };\n \n-                if let Some(Adt::Enum(e)) = ty.as_adt() {\n+                if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n                     add_enum_variants(ctx, acc, e);\n                 }\n "}, {"sha": "9db8516d053d20a8a031db27e7be41603d1d849c", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=971b0836ef425d8b962ecac70a974887a8356567", "patch": "@@ -14,10 +14,10 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n     if ctx.expects_assoc_item() {\n         ctx.scope.process_all_names(&mut |name, def| {\n             if let ScopeDef::MacroDef(macro_def) = def {\n-                acc.add_macro(ctx, Some(name.to_string()), macro_def);\n+                acc.add_macro(ctx, Some(name.clone()), macro_def);\n             }\n             if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = def {\n-                acc.add_resolution(ctx, name.to_string(), &def);\n+                acc.add_resolution(ctx, name, &def);\n             }\n         });\n         return;\n@@ -27,7 +27,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n         cov_mark::hit!(only_completes_modules_in_import);\n         ctx.scope.process_all_names(&mut |name, res| {\n             if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = res {\n-                acc.add_resolution(ctx, name.to_string(), &res);\n+                acc.add_resolution(ctx, name, &res);\n             }\n         });\n         return;\n@@ -45,7 +45,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n             cov_mark::hit!(skip_lifetime_completion);\n             return;\n         }\n-        acc.add_resolution(ctx, name.to_string(), &res);\n+        acc.add_resolution(ctx, name, &res);\n     });\n }\n "}, {"sha": "425dd0247c84d27b585708bfb6d62bb04f20ff00", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 76, "deletions": 67, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=971b0836ef425d8b962ecac70a974887a8356567", "patch": "@@ -10,9 +10,7 @@ pub(crate) mod type_alias;\n \n mod builder_ext;\n \n-use hir::{\n-    AsAssocItem, Documentation, HasAttrs, HirDisplay, ModuleDef, Mutability, ScopeDef, Type,\n-};\n+use hir::{AsAssocItem, HasAttrs, HirDisplay};\n use ide_db::{\n     helpers::{item_name, SnippetCap},\n     RootDatabase, SymbolKind,\n@@ -21,31 +19,30 @@ use syntax::TextRange;\n \n use crate::{\n     item::{CompletionRelevanceTypeMatch, ImportEdit},\n+    render::{enum_variant::render_variant, function::render_fn, macro_::render_macro},\n     CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, CompletionRelevance,\n };\n \n-use crate::render::{enum_variant::render_variant, function::render_fn, macro_::render_macro};\n-\n pub(crate) fn render_field<'a>(\n     ctx: RenderContext<'a>,\n     field: hir::Field,\n-    ty: &Type,\n+    ty: &hir::Type,\n ) -> CompletionItem {\n-    Render::new(ctx).add_field(field, ty)\n+    Render::new(ctx).render_field(field, ty)\n }\n \n pub(crate) fn render_tuple_field<'a>(\n     ctx: RenderContext<'a>,\n     field: usize,\n-    ty: &Type,\n+    ty: &hir::Type,\n ) -> CompletionItem {\n-    Render::new(ctx).add_tuple_field(field, ty)\n+    Render::new(ctx).render_tuple_field(field, ty)\n }\n \n pub(crate) fn render_resolution<'a>(\n     ctx: RenderContext<'a>,\n-    local_name: String,\n-    resolution: &ScopeDef,\n+    local_name: hir::Name,\n+    resolution: &hir::ScopeDef,\n ) -> Option<CompletionItem> {\n     Render::new(ctx).render_resolution(local_name, None, resolution)\n }\n@@ -54,12 +51,12 @@ pub(crate) fn render_resolution_with_import<'a>(\n     ctx: RenderContext<'a>,\n     import_edit: ImportEdit,\n ) -> Option<CompletionItem> {\n-    let resolution = ScopeDef::from(import_edit.import.original_item);\n+    let resolution = hir::ScopeDef::from(import_edit.import.original_item);\n     let local_name = match resolution {\n-        ScopeDef::ModuleDef(ModuleDef::Function(f)) => f.name(ctx.completion.db).to_string(),\n-        ScopeDef::ModuleDef(ModuleDef::Const(c)) => c.name(ctx.completion.db)?.to_string(),\n-        ScopeDef::ModuleDef(ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db).to_string(),\n-        _ => item_name(ctx.db(), import_edit.import.original_item)?.to_string(),\n+        hir::ScopeDef::ModuleDef(hir::ModuleDef::Function(f)) => f.name(ctx.completion.db),\n+        hir::ScopeDef::ModuleDef(hir::ModuleDef::Const(c)) => c.name(ctx.completion.db)?,\n+        hir::ScopeDef::ModuleDef(hir::ModuleDef::TypeAlias(t)) => t.name(ctx.completion.db),\n+        _ => item_name(ctx.db(), import_edit.import.original_item)?,\n     };\n     Render::new(ctx).render_resolution(local_name, Some(import_edit), &resolution).map(\n         |mut item| {\n@@ -113,7 +110,7 @@ impl<'a> RenderContext<'a> {\n             || assoc.containing_trait(db).map(|trait_| self.is_deprecated(trait_)).unwrap_or(false)\n     }\n \n-    fn docs(&self, node: impl HasAttrs) -> Option<Documentation> {\n+    fn docs(&self, node: impl HasAttrs) -> Option<hir::Documentation> {\n         node.docs(self.db())\n     }\n }\n@@ -129,22 +126,19 @@ impl<'a> Render<'a> {\n         Render { ctx }\n     }\n \n-    fn add_field(&mut self, field: hir::Field, ty: &Type) -> CompletionItem {\n+    fn render_field(&self, field: hir::Field, ty: &hir::Type) -> CompletionItem {\n         let is_deprecated = self.ctx.is_deprecated(field);\n-        let name = field.name(self.ctx.db());\n-        let mut item = CompletionItem::new(\n-            CompletionKind::Reference,\n-            self.ctx.source_range(),\n-            name.to_string(),\n-        );\n+        let name = field.name(self.ctx.db()).to_string();\n+        let mut item =\n+            CompletionItem::new(CompletionKind::Reference, self.ctx.source_range(), name.clone());\n         item.kind(SymbolKind::Field)\n             .detail(ty.display(self.ctx.db()).to_string())\n             .set_documentation(field.docs(self.ctx.db()))\n             .set_deprecated(is_deprecated);\n \n         item.set_relevance(CompletionRelevance {\n             type_match: compute_type_match(self.ctx.completion, ty),\n-            exact_name_match: compute_exact_name_match(self.ctx.completion, name.to_string()),\n+            exact_name_match: compute_exact_name_match(self.ctx.completion, &name),\n             ..CompletionRelevance::default()\n         });\n \n@@ -157,7 +151,7 @@ impl<'a> Render<'a> {\n         item.build()\n     }\n \n-    fn add_tuple_field(&mut self, field: usize, ty: &Type) -> CompletionItem {\n+    fn render_tuple_field(&self, field: usize, ty: &hir::Type) -> CompletionItem {\n         let mut item = CompletionItem::new(\n             CompletionKind::Reference,\n             self.ctx.source_range(),\n@@ -171,71 +165,82 @@ impl<'a> Render<'a> {\n \n     fn render_resolution(\n         self,\n-        local_name: String,\n+        local_name: hir::Name,\n         import_to_add: Option<ImportEdit>,\n-        resolution: &ScopeDef,\n+        resolution: &hir::ScopeDef,\n     ) -> Option<CompletionItem> {\n         let _p = profile::span(\"render_resolution\");\n         use hir::ModuleDef::*;\n \n         let completion_kind = match resolution {\n-            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n+            hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionKind::BuiltinType,\n             _ => CompletionKind::Reference,\n         };\n \n         let kind = match resolution {\n-            ScopeDef::ModuleDef(Function(func)) => {\n+            hir::ScopeDef::ModuleDef(Function(func)) => {\n                 return render_fn(self.ctx, import_to_add, Some(local_name), *func);\n             }\n-            ScopeDef::ModuleDef(Variant(_)) if self.ctx.completion.is_pat_or_const.is_some() => {\n+            hir::ScopeDef::ModuleDef(Variant(_))\n+                if self.ctx.completion.is_pat_or_const.is_some() =>\n+            {\n                 CompletionItemKind::SymbolKind(SymbolKind::Variant)\n             }\n-            ScopeDef::ModuleDef(Variant(var)) => {\n+            hir::ScopeDef::ModuleDef(Variant(var)) => {\n                 let item = render_variant(self.ctx, import_to_add, Some(local_name), *var, None);\n                 return Some(item);\n             }\n-            ScopeDef::MacroDef(mac) => {\n+            hir::ScopeDef::MacroDef(mac) => {\n                 let item = render_macro(self.ctx, import_to_add, local_name, *mac);\n                 return item;\n             }\n \n-            ScopeDef::ModuleDef(Module(..)) => CompletionItemKind::SymbolKind(SymbolKind::Module),\n-            ScopeDef::ModuleDef(Adt(adt)) => CompletionItemKind::SymbolKind(match adt {\n+            hir::ScopeDef::ModuleDef(Module(..)) => {\n+                CompletionItemKind::SymbolKind(SymbolKind::Module)\n+            }\n+            hir::ScopeDef::ModuleDef(Adt(adt)) => CompletionItemKind::SymbolKind(match adt {\n                 hir::Adt::Struct(_) => SymbolKind::Struct,\n                 hir::Adt::Union(_) => SymbolKind::Union,\n                 hir::Adt::Enum(_) => SymbolKind::Enum,\n             }),\n-            ScopeDef::ModuleDef(Const(..)) => CompletionItemKind::SymbolKind(SymbolKind::Const),\n-            ScopeDef::ModuleDef(Static(..)) => CompletionItemKind::SymbolKind(SymbolKind::Static),\n-            ScopeDef::ModuleDef(Trait(..)) => CompletionItemKind::SymbolKind(SymbolKind::Trait),\n-            ScopeDef::ModuleDef(TypeAlias(..)) => {\n+            hir::ScopeDef::ModuleDef(Const(..)) => {\n+                CompletionItemKind::SymbolKind(SymbolKind::Const)\n+            }\n+            hir::ScopeDef::ModuleDef(Static(..)) => {\n+                CompletionItemKind::SymbolKind(SymbolKind::Static)\n+            }\n+            hir::ScopeDef::ModuleDef(Trait(..)) => {\n+                CompletionItemKind::SymbolKind(SymbolKind::Trait)\n+            }\n+            hir::ScopeDef::ModuleDef(TypeAlias(..)) => {\n                 CompletionItemKind::SymbolKind(SymbolKind::TypeAlias)\n             }\n-            ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n-            ScopeDef::GenericParam(param) => CompletionItemKind::SymbolKind(match param {\n+            hir::ScopeDef::ModuleDef(BuiltinType(..)) => CompletionItemKind::BuiltinType,\n+            hir::ScopeDef::GenericParam(param) => CompletionItemKind::SymbolKind(match param {\n                 hir::GenericParam::TypeParam(_) => SymbolKind::TypeParam,\n                 hir::GenericParam::LifetimeParam(_) => SymbolKind::LifetimeParam,\n                 hir::GenericParam::ConstParam(_) => SymbolKind::ConstParam,\n             }),\n-            ScopeDef::Local(..) => CompletionItemKind::SymbolKind(SymbolKind::Local),\n-            ScopeDef::Label(..) => CompletionItemKind::SymbolKind(SymbolKind::Label),\n-            ScopeDef::AdtSelfType(..) | ScopeDef::ImplSelfType(..) => {\n+            hir::ScopeDef::Local(..) => CompletionItemKind::SymbolKind(SymbolKind::Local),\n+            hir::ScopeDef::Label(..) => CompletionItemKind::SymbolKind(SymbolKind::Label),\n+            hir::ScopeDef::AdtSelfType(..) | hir::ScopeDef::ImplSelfType(..) => {\n                 CompletionItemKind::SymbolKind(SymbolKind::SelfParam)\n             }\n-            ScopeDef::Unknown => {\n+            hir::ScopeDef::Unknown => {\n                 let mut item = CompletionItem::new(\n                     CompletionKind::Reference,\n                     self.ctx.source_range(),\n-                    local_name,\n+                    local_name.to_string(),\n                 );\n                 item.kind(CompletionItemKind::UnresolvedReference).add_import(import_to_add);\n                 return Some(item.build());\n             }\n         };\n \n+        let local_name = local_name.to_string();\n         let mut item =\n             CompletionItem::new(completion_kind, self.ctx.source_range(), local_name.clone());\n-        if let ScopeDef::Local(local) = resolution {\n+        if let hir::ScopeDef::Local(local) = resolution {\n             let ty = local.ty(self.ctx.db());\n             if !ty.is_unknown() {\n                 item.detail(ty.display(self.ctx.db()).to_string());\n@@ -260,8 +265,10 @@ impl<'a> Render<'a> {\n         {\n             if let Some(cap) = self.ctx.snippet_cap() {\n                 let has_non_default_type_params = match resolution {\n-                    ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(self.ctx.db()),\n-                    ScopeDef::ModuleDef(TypeAlias(it)) => {\n+                    hir::ScopeDef::ModuleDef(Adt(it)) => {\n+                        it.has_non_default_type_params(self.ctx.db())\n+                    }\n+                    hir::ScopeDef::ModuleDef(TypeAlias(it)) => {\n                         it.has_non_default_type_params(self.ctx.db())\n                     }\n                     _ => false,\n@@ -281,26 +288,26 @@ impl<'a> Render<'a> {\n         Some(item.build())\n     }\n \n-    fn docs(&self, resolution: &ScopeDef) -> Option<Documentation> {\n+    fn docs(&self, resolution: &hir::ScopeDef) -> Option<hir::Documentation> {\n         use hir::ModuleDef::*;\n         match resolution {\n-            ScopeDef::ModuleDef(Module(it)) => it.docs(self.ctx.db()),\n-            ScopeDef::ModuleDef(Adt(it)) => it.docs(self.ctx.db()),\n-            ScopeDef::ModuleDef(Variant(it)) => it.docs(self.ctx.db()),\n-            ScopeDef::ModuleDef(Const(it)) => it.docs(self.ctx.db()),\n-            ScopeDef::ModuleDef(Static(it)) => it.docs(self.ctx.db()),\n-            ScopeDef::ModuleDef(Trait(it)) => it.docs(self.ctx.db()),\n-            ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(self.ctx.db()),\n+            hir::ScopeDef::ModuleDef(Module(it)) => it.docs(self.ctx.db()),\n+            hir::ScopeDef::ModuleDef(Adt(it)) => it.docs(self.ctx.db()),\n+            hir::ScopeDef::ModuleDef(Variant(it)) => it.docs(self.ctx.db()),\n+            hir::ScopeDef::ModuleDef(Const(it)) => it.docs(self.ctx.db()),\n+            hir::ScopeDef::ModuleDef(Static(it)) => it.docs(self.ctx.db()),\n+            hir::ScopeDef::ModuleDef(Trait(it)) => it.docs(self.ctx.db()),\n+            hir::ScopeDef::ModuleDef(TypeAlias(it)) => it.docs(self.ctx.db()),\n             _ => None,\n         }\n     }\n \n-    fn is_deprecated(&self, resolution: &ScopeDef) -> bool {\n+    fn is_deprecated(&self, resolution: &hir::ScopeDef) -> bool {\n         match resolution {\n-            ScopeDef::ModuleDef(it) => self.ctx.is_deprecated_assoc_item(*it),\n-            ScopeDef::MacroDef(it) => self.ctx.is_deprecated(*it),\n-            ScopeDef::GenericParam(it) => self.ctx.is_deprecated(*it),\n-            ScopeDef::AdtSelfType(it) => self.ctx.is_deprecated(*it),\n+            hir::ScopeDef::ModuleDef(it) => self.ctx.is_deprecated_assoc_item(*it),\n+            hir::ScopeDef::MacroDef(it) => self.ctx.is_deprecated(*it),\n+            hir::ScopeDef::GenericParam(it) => self.ctx.is_deprecated(*it),\n+            hir::ScopeDef::AdtSelfType(it) => self.ctx.is_deprecated(*it),\n             _ => false,\n         }\n     }\n@@ -327,21 +334,23 @@ fn compute_type_match(\n     }\n }\n \n-fn compute_exact_name_match(ctx: &CompletionContext, completion_name: impl Into<String>) -> bool {\n-    let completion_name = completion_name.into();\n+fn compute_exact_name_match(ctx: &CompletionContext, completion_name: &str) -> bool {\n     ctx.expected_name.as_ref().map_or(false, |name| name.text() == completion_name)\n }\n \n-fn compute_ref_match(ctx: &CompletionContext, completion_ty: &hir::Type) -> Option<Mutability> {\n+fn compute_ref_match(\n+    ctx: &CompletionContext,\n+    completion_ty: &hir::Type,\n+) -> Option<hir::Mutability> {\n     let expected_type = ctx.expected_type.as_ref()?;\n     if completion_ty != expected_type {\n         let expected_type_without_ref = expected_type.remove_ref()?;\n         if completion_ty.autoderef(ctx.db).any(|deref_ty| deref_ty == expected_type_without_ref) {\n             cov_mark::hit!(suggest_ref);\n             let mutability = if expected_type.is_mutable_reference() {\n-                Mutability::Mut\n+                hir::Mutability::Mut\n             } else {\n-                Mutability::Shared\n+                hir::Mutability::Shared\n             };\n             return Some(mutability);\n         };"}, {"sha": "28f056e775881575a0b9964fa3080fe14b5e5442", "filename": "crates/ide_completion/src/render/enum_variant.rs", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs?ref=971b0836ef425d8b962ecac70a974887a8356567", "patch": "@@ -1,6 +1,8 @@\n //! Renderer for `enum` variants.\n \n-use hir::{HasAttrs, HirDisplay, ModPath, StructKind};\n+use std::iter;\n+\n+use hir::{HasAttrs, HirDisplay};\n use ide_db::SymbolKind;\n use itertools::Itertools;\n \n@@ -13,9 +15,9 @@ use crate::{\n pub(crate) fn render_variant<'a>(\n     ctx: RenderContext<'a>,\n     import_to_add: Option<ImportEdit>,\n-    local_name: Option<String>,\n+    local_name: Option<hir::Name>,\n     variant: hir::Variant,\n-    path: Option<ModPath>,\n+    path: Option<hir::ModPath>,\n ) -> CompletionItem {\n     let _p = profile::span(\"render_enum_variant\");\n     EnumRender::new(ctx, local_name, variant, path).render(import_to_add)\n@@ -24,55 +26,62 @@ pub(crate) fn render_variant<'a>(\n #[derive(Debug)]\n struct EnumRender<'a> {\n     ctx: RenderContext<'a>,\n-    name: String,\n+    name: hir::Name,\n     variant: hir::Variant,\n-    path: Option<ModPath>,\n-    qualified_name: String,\n-    short_qualified_name: String,\n-    variant_kind: StructKind,\n+    path: Option<hir::ModPath>,\n+    qualified_name: hir::ModPath,\n+    short_qualified_name: hir::ModPath,\n+    variant_kind: hir::StructKind,\n }\n \n impl<'a> EnumRender<'a> {\n     fn new(\n         ctx: RenderContext<'a>,\n-        local_name: Option<String>,\n+        local_name: Option<hir::Name>,\n         variant: hir::Variant,\n-        path: Option<ModPath>,\n+        path: Option<hir::ModPath>,\n     ) -> EnumRender<'a> {\n-        let name = local_name.unwrap_or_else(|| variant.name(ctx.db()).to_string());\n+        let name = local_name.unwrap_or_else(|| variant.name(ctx.db()));\n         let variant_kind = variant.kind(ctx.db());\n \n         let (qualified_name, short_qualified_name) = match &path {\n             Some(path) => {\n-                let full = path.to_string();\n-                let segments = path.segments();\n-                let short = segments[segments.len().saturating_sub(2)..].iter().join(\"::\");\n-                (full, short)\n+                let short = hir::ModPath::from_segments(\n+                    hir::PathKind::Plain,\n+                    path.segments().iter().skip(path.segments().len().saturating_sub(2)).cloned(),\n+                );\n+                (path.clone(), short)\n             }\n-            None => (name.to_string(), name.to_string()),\n+            None => (\n+                hir::ModPath::from_segments(hir::PathKind::Plain, iter::once(name.clone())),\n+                hir::ModPath::from_segments(hir::PathKind::Plain, iter::once(name.clone())),\n+            ),\n         };\n \n         EnumRender { ctx, name, variant, path, qualified_name, short_qualified_name, variant_kind }\n     }\n-\n     fn render(self, import_to_add: Option<ImportEdit>) -> CompletionItem {\n         let mut item = CompletionItem::new(\n             CompletionKind::Reference,\n             self.ctx.source_range(),\n-            self.qualified_name.clone(),\n+            self.qualified_name.to_string(),\n         );\n         item.kind(SymbolKind::Variant)\n             .set_documentation(self.variant.docs(self.ctx.db()))\n             .set_deprecated(self.ctx.is_deprecated(self.variant))\n             .add_import(import_to_add)\n             .detail(self.detail());\n \n-        if self.variant_kind == StructKind::Tuple {\n+        if self.variant_kind == hir::StructKind::Tuple {\n             cov_mark::hit!(inserts_parens_for_tuple_enums);\n             let params = Params::Anonymous(self.variant.fields(self.ctx.db()).len());\n-            item.add_call_parens(self.ctx.completion, self.short_qualified_name, params);\n+            item.add_call_parens(\n+                self.ctx.completion,\n+                self.short_qualified_name.to_string(),\n+                params,\n+            );\n         } else if self.path.is_some() {\n-            item.lookup_by(self.short_qualified_name);\n+            item.lookup_by(self.short_qualified_name.to_string());\n         }\n \n         let ty = self.variant.parent_enum(self.ctx.completion.db).ty(self.ctx.completion.db);\n@@ -96,11 +105,11 @@ impl<'a> EnumRender<'a> {\n             .map(|field| (field.name(self.ctx.db()), field.ty(self.ctx.db())));\n \n         match self.variant_kind {\n-            StructKind::Tuple | StructKind::Unit => format!(\n+            hir::StructKind::Tuple | hir::StructKind::Unit => format!(\n                 \"({})\",\n                 detail_types.map(|(_, t)| t.display(self.ctx.db()).to_string()).format(\", \")\n             ),\n-            StructKind::Record => format!(\n+            hir::StructKind::Record => format!(\n                 \"{{ {} }}\",\n                 detail_types\n                     .map(|(n, t)| format!(\"{}: {}\", n, t.display(self.ctx.db()).to_string()))"}, {"sha": "63bd669260199ffb8db4ae1e8da15ee7b7fb6772", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=971b0836ef425d8b962ecac70a974887a8356567", "patch": "@@ -1,6 +1,6 @@\n //! Renderer for function calls.\n \n-use hir::{HasSource, HirDisplay, Type};\n+use hir::{HasSource, HirDisplay};\n use ide_db::SymbolKind;\n use itertools::Itertools;\n use syntax::ast::Fn;\n@@ -16,7 +16,7 @@ use crate::{\n pub(crate) fn render_fn<'a>(\n     ctx: RenderContext<'a>,\n     import_to_add: Option<ImportEdit>,\n-    local_name: Option<String>,\n+    local_name: Option<hir::Name>,\n     fn_: hir::Function,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_fn\");\n@@ -26,7 +26,7 @@ pub(crate) fn render_fn<'a>(\n pub(crate) fn render_method<'a>(\n     ctx: RenderContext<'a>,\n     import_to_add: Option<ImportEdit>,\n-    local_name: Option<String>,\n+    local_name: Option<hir::Name>,\n     fn_: hir::Function,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_method\");\n@@ -45,11 +45,11 @@ struct FunctionRender<'a> {\n impl<'a> FunctionRender<'a> {\n     fn new(\n         ctx: RenderContext<'a>,\n-        local_name: Option<String>,\n+        local_name: Option<hir::Name>,\n         fn_: hir::Function,\n         is_method: bool,\n     ) -> Option<FunctionRender<'a>> {\n-        let name = local_name.unwrap_or_else(|| fn_.name(ctx.db()).to_string());\n+        let name = local_name.unwrap_or_else(|| fn_.name(ctx.db())).to_string();\n         let ast_node = fn_.source(ctx.db())?.value;\n \n         Some(FunctionRender { ctx, name, func: fn_, ast_node, is_method })\n@@ -74,7 +74,7 @@ impl<'a> FunctionRender<'a> {\n         let ret_type = self.func.ret_type(self.ctx.db());\n         item.set_relevance(CompletionRelevance {\n             type_match: compute_type_match(self.ctx.completion, &ret_type),\n-            exact_name_match: compute_exact_name_match(self.ctx.completion, self.name.clone()),\n+            exact_name_match: compute_exact_name_match(self.ctx.completion, &self.name),\n             ..CompletionRelevance::default()\n         });\n \n@@ -129,7 +129,7 @@ impl<'a> FunctionRender<'a> {\n         format!(\"-> {}\", ret_ty.display(self.ctx.db()))\n     }\n \n-    fn add_arg(&self, arg: &str, ty: &Type) -> String {\n+    fn add_arg(&self, arg: &str, ty: &hir::Type) -> String {\n         if let Some(derefed_ty) = ty.remove_ref() {\n             for (name, local) in self.ctx.completion.locals.iter() {\n                 if name == arg && local.ty(self.ctx.db()) == derefed_ty {"}, {"sha": "0dfba8acc9b9f8bfaa5e4a73b49b9cf55eb06603", "filename": "crates/ide_completion/src/render/macro_.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/971b0836ef425d8b962ecac70a974887a8356567/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fmacro_.rs?ref=971b0836ef425d8b962ecac70a974887a8356567", "patch": "@@ -1,6 +1,6 @@\n //! Renderer for macro invocations.\n \n-use hir::{Documentation, HasSource};\n+use hir::HasSource;\n use ide_db::SymbolKind;\n use syntax::display::macro_label;\n \n@@ -12,7 +12,7 @@ use crate::{\n pub(crate) fn render_macro<'a>(\n     ctx: RenderContext<'a>,\n     import_to_add: Option<ImportEdit>,\n-    name: String,\n+    name: hir::Name,\n     macro_: hir::MacroDef,\n ) -> Option<CompletionItem> {\n     let _p = profile::span(\"render_macro\");\n@@ -24,13 +24,14 @@ struct MacroRender<'a> {\n     ctx: RenderContext<'a>,\n     name: String,\n     macro_: hir::MacroDef,\n-    docs: Option<Documentation>,\n+    docs: Option<hir::Documentation>,\n     bra: &'static str,\n     ket: &'static str,\n }\n \n impl<'a> MacroRender<'a> {\n-    fn new(ctx: RenderContext<'a>, name: String, macro_: hir::MacroDef) -> MacroRender<'a> {\n+    fn new(ctx: RenderContext<'a>, name: hir::Name, macro_: hir::MacroDef) -> MacroRender<'a> {\n+        let name = name.to_string();\n         let docs = ctx.docs(macro_);\n         let docs_str = docs.as_ref().map_or(\"\", |s| s.as_str());\n         let (bra, ket) = guess_macro_braces(&name, docs_str);"}]}