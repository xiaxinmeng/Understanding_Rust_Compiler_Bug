{"sha": "d84ad59710728c936edd7396e287d42f1e319cf1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ4NGFkNTk3MTA3MjhjOTM2ZWRkNzM5NmUyODdkNDJmMWUzMTljZjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-28T09:16:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-28T09:16:10Z"}, "message": "Auto merge of #51492 - petrochenkov:hirident, r=eddyb\n\nUse `Ident`s in HIR and remove emulation of hygiene with gensyms\n\ncontinuation of https://github.com/rust-lang/rust/pull/51072, part of https://github.com/rust-lang/rust/issues/49300\n\nNot all `Name`s in HIR are replaced with `Ident`s, only those needed for hygiene or already having attached spans.", "tree": {"sha": "3d1d4884e8f468d106dc742d6fc855fcd7532ac6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3d1d4884e8f468d106dc742d6fc855fcd7532ac6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d84ad59710728c936edd7396e287d42f1e319cf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d84ad59710728c936edd7396e287d42f1e319cf1", "html_url": "https://github.com/rust-lang/rust/commit/d84ad59710728c936edd7396e287d42f1e319cf1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d84ad59710728c936edd7396e287d42f1e319cf1/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ba196bdcb10736da5d14c961bd8962d80e300913", "url": "https://api.github.com/repos/rust-lang/rust/commits/ba196bdcb10736da5d14c961bd8962d80e300913", "html_url": "https://github.com/rust-lang/rust/commit/ba196bdcb10736da5d14c961bd8962d80e300913"}, {"sha": "d7072b5bb42eb005ab3adac2605f175d8719e1f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7072b5bb42eb005ab3adac2605f175d8719e1f1", "html_url": "https://github.com/rust-lang/rust/commit/d7072b5bb42eb005ab3adac2605f175d8719e1f1"}], "stats": {"total": 1540, "additions": 673, "deletions": 867}, "files": [{"sha": "f792a24503a3e054f536ab86f46ebf6c16eb75f0", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -57,7 +57,7 @@ pub enum FnKind<'a> {\n     ItemFn(Name, &'a Generics, FnHeader, &'a Visibility, &'a [Attribute]),\n \n     /// fn foo(&self)\n-    Method(Name, &'a MethodSig, Option<&'a Visibility>, &'a [Attribute]),\n+    Method(Ident, &'a MethodSig, Option<&'a Visibility>, &'a [Attribute]),\n \n     /// |x, y| {}\n     Closure(&'a [Attribute]),\n@@ -426,14 +426,14 @@ pub fn walk_ident<'v, V: Visitor<'v>>(visitor: &mut V, ident: Ident) {\n }\n \n pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n-    visitor.visit_name(label.span, label.name);\n+    visitor.visit_ident(label.ident);\n }\n \n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n     visitor.visit_id(lifetime.id);\n     match lifetime.name {\n-        LifetimeName::Param(ParamName::Plain(name)) => {\n-            visitor.visit_name(lifetime.span, name);\n+        LifetimeName::Param(ParamName::Plain(ident)) => {\n+            visitor.visit_ident(ident);\n         }\n         LifetimeName::Param(ParamName::Fresh(_)) |\n         LifetimeName::Static |\n@@ -644,7 +644,7 @@ pub fn walk_path<'v, V: Visitor<'v>>(visitor: &mut V, path: &'v Path) {\n pub fn walk_path_segment<'v, V: Visitor<'v>>(visitor: &mut V,\n                                              path_span: Span,\n                                              segment: &'v PathSegment) {\n-    visitor.visit_name(path_span, segment.name);\n+    visitor.visit_ident(segment.ident);\n     if let Some(ref args) = segment.args {\n         visitor.visit_generic_args(path_span, args);\n     }\n@@ -660,7 +660,7 @@ pub fn walk_generic_args<'v, V: Visitor<'v>>(visitor: &mut V,\n pub fn walk_assoc_type_binding<'v, V: Visitor<'v>>(visitor: &mut V,\n                                                    type_binding: &'v TypeBinding) {\n     visitor.visit_id(type_binding.id);\n-    visitor.visit_name(type_binding.span, type_binding.name);\n+    visitor.visit_ident(type_binding.ident);\n     visitor.visit_ty(&type_binding.ty);\n }\n \n@@ -689,9 +689,9 @@ pub fn walk_pat<'v, V: Visitor<'v>>(visitor: &mut V, pattern: &'v Pat) {\n         PatKind::Ref(ref subpattern, _) => {\n             visitor.visit_pat(subpattern)\n         }\n-        PatKind::Binding(_, canonical_id, ref pth1, ref optional_subpattern) => {\n+        PatKind::Binding(_, canonical_id, ident, ref optional_subpattern) => {\n             visitor.visit_def_mention(Def::Local(canonical_id));\n-            visitor.visit_name(pth1.span, pth1.node);\n+            visitor.visit_ident(ident);\n             walk_list!(visitor, visit_pat, optional_subpattern);\n         }\n         PatKind::Lit(ref expression) => visitor.visit_expr(expression),\n@@ -714,11 +714,11 @@ pub fn walk_foreign_item<'v, V: Visitor<'v>>(visitor: &mut V, foreign_item: &'v\n     visitor.visit_name(foreign_item.span, foreign_item.name);\n \n     match foreign_item.node {\n-        ForeignItemFn(ref function_declaration, ref names, ref generics) => {\n+        ForeignItemFn(ref function_declaration, ref param_names, ref generics) => {\n             visitor.visit_generics(generics);\n             visitor.visit_fn_decl(function_declaration);\n-            for name in names {\n-                visitor.visit_name(name.span, name.node);\n+            for &param_name in param_names {\n+                visitor.visit_ident(param_name);\n             }\n         }\n         ForeignItemStatic(ref typ, _) => visitor.visit_ty(typ),\n@@ -741,7 +741,7 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n     visitor.visit_id(param.id);\n     walk_list!(visitor, visit_attribute, &param.attrs);\n     match param.name {\n-        ParamName::Plain(name) => visitor.visit_name(param.span, name),\n+        ParamName::Plain(ident) => visitor.visit_ident(ident),\n         ParamName::Fresh(_) => {}\n     }\n     match param.kind {\n@@ -823,7 +823,7 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n-    visitor.visit_name(trait_item.span, trait_item.name);\n+    visitor.visit_ident(trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     visitor.visit_generics(&trait_item.generics);\n     match trait_item.node {\n@@ -832,15 +832,15 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             visitor.visit_ty(ty);\n             walk_list!(visitor, visit_nested_body, default);\n         }\n-        TraitItemKind::Method(ref sig, TraitMethod::Required(ref names)) => {\n+        TraitItemKind::Method(ref sig, TraitMethod::Required(ref param_names)) => {\n             visitor.visit_id(trait_item.id);\n             visitor.visit_fn_decl(&sig.decl);\n-            for name in names {\n-                visitor.visit_name(name.span, name.node);\n+            for &param_name in param_names {\n+                visitor.visit_ident(param_name);\n             }\n         }\n         TraitItemKind::Method(ref sig, TraitMethod::Provided(body_id)) => {\n-            visitor.visit_fn(FnKind::Method(trait_item.name,\n+            visitor.visit_fn(FnKind::Method(trait_item.ident,\n                                             sig,\n                                             None,\n                                             &trait_item.attrs),\n@@ -859,9 +859,9 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n \n pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref: &'v TraitItemRef) {\n     // NB: Deliberately force a compilation error if/when new fields are added.\n-    let TraitItemRef { id, name, ref kind, span, ref defaultness } = *trait_item_ref;\n+    let TraitItemRef { id, ident, ref kind, span: _, ref defaultness } = *trait_item_ref;\n     visitor.visit_nested_trait_item(id);\n-    visitor.visit_name(span, name);\n+    visitor.visit_ident(ident);\n     visitor.visit_associated_item_kind(kind);\n     visitor.visit_defaultness(defaultness);\n }\n@@ -871,16 +871,16 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     let ImplItem {\n         id: _,\n         hir_id: _,\n-        name,\n+        ident,\n         ref vis,\n         ref defaultness,\n         ref attrs,\n         ref generics,\n         ref node,\n-        span\n+        span: _,\n     } = *impl_item;\n \n-    visitor.visit_name(span, name);\n+    visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n     visitor.visit_defaultness(defaultness);\n     walk_list!(visitor, visit_attribute, attrs);\n@@ -892,7 +892,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_nested_body(body);\n         }\n         ImplItemKind::Method(ref sig, body_id) => {\n-            visitor.visit_fn(FnKind::Method(impl_item.name,\n+            visitor.visit_fn(FnKind::Method(impl_item.ident,\n                                             sig,\n                                             Some(&impl_item.vis),\n                                             &impl_item.attrs),\n@@ -910,9 +910,9 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n \n pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n     // NB: Deliberately force a compilation error if/when new fields are added.\n-    let ImplItemRef { id, name, ref kind, span, ref vis, ref defaultness } = *impl_item_ref;\n+    let ImplItemRef { id, ident, ref kind, span: _, ref vis, ref defaultness } = *impl_item_ref;\n     visitor.visit_nested_impl_item(id);\n-    visitor.visit_name(span, name);\n+    visitor.visit_ident(ident);\n     visitor.visit_associated_item_kind(kind);\n     visitor.visit_vis(vis);\n     visitor.visit_defaultness(defaultness);"}, {"sha": "260ad00328344210dab0d6ca555640647571036c", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 72, "deletions": 82, "changes": 154, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -52,7 +52,7 @@ use middle::cstore::CrateStore;\n use rustc_data_structures::indexed_vec::IndexVec;\n use session::Session;\n use util::common::FN_OUTPUT_NAME;\n-use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n+use util::nodemap::{DefIdMap, NodeMap};\n \n use std::collections::{BTreeMap, HashSet};\n use std::fmt::Debug;\n@@ -85,7 +85,6 @@ pub struct LoweringContext<'a> {\n     cstore: &'a CrateStore,\n \n     resolver: &'a mut Resolver,\n-    name_map: FxHashMap<Ident, Name>,\n \n     /// The items being lowered are collected here.\n     items: BTreeMap<NodeId, hir::Item>,\n@@ -138,7 +137,7 @@ pub struct LoweringContext<'a> {\n     // When `is_collectin_in_band_lifetimes` is true, each lifetime is checked\n     // against this list to see if it is already in-scope, or if a definition\n     // needs to be created for it.\n-    in_scope_lifetimes: Vec<Name>,\n+    in_scope_lifetimes: Vec<Ident>,\n \n     type_def_lifetime_params: DefIdMap<usize>,\n \n@@ -210,7 +209,6 @@ pub fn lower_crate(\n         sess,\n         cstore,\n         resolver,\n-        name_map: FxHashMap(),\n         items: BTreeMap::new(),\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n@@ -604,8 +602,8 @@ impl<'a> LoweringContext<'a> {\n         self.sess.diagnostic()\n     }\n \n-    fn str_to_ident(&self, s: &'static str) -> Name {\n-        Symbol::gensym(s)\n+    fn str_to_ident(&self, s: &'static str) -> Ident {\n+        Ident::with_empty_ctxt(Symbol::gensym(s))\n     }\n \n     fn allow_internal_unstable(&self, reason: CompilerDesugaringKind, span: Span) -> Span {\n@@ -678,15 +676,15 @@ impl<'a> LoweringContext<'a> {\n                 // that collisions are ok here and this shouldn't\n                 // really show up for end-user.\n                 let str_name = match hir_name {\n-                    ParamName::Plain(name) => name.as_str(),\n-                    ParamName::Fresh(_) => keywords::UnderscoreLifetime.name().as_str(),\n+                    ParamName::Plain(ident) => ident.as_interned_str(),\n+                    ParamName::Fresh(_) => keywords::UnderscoreLifetime.name().as_interned_str(),\n                 };\n \n                 // Add a definition for the in-band lifetime def\n                 self.resolver.definitions().create_def_with_parent(\n                     parent_id.index,\n                     def_node_id,\n-                    DefPathData::LifetimeParam(str_name.as_interned_str()),\n+                    DefPathData::LifetimeParam(str_name),\n                     DefIndexAddressSpace::High,\n                     Mark::root(),\n                     span,\n@@ -712,22 +710,23 @@ impl<'a> LoweringContext<'a> {\n     /// lifetimes are enabled, then we want to push that lifetime into\n     /// the vector of names to define later. In that case, it will get\n     /// added to the appropriate generics.\n-    fn maybe_collect_in_band_lifetime(&mut self, span: Span, name: Name) {\n+    fn maybe_collect_in_band_lifetime(&mut self, ident: Ident) {\n         if !self.is_collecting_in_band_lifetimes {\n             return;\n         }\n \n-        if self.in_scope_lifetimes.contains(&name) {\n+        if self.in_scope_lifetimes.contains(&ident.modern()) {\n             return;\n         }\n \n-        let hir_name = ParamName::Plain(name);\n+        let hir_name = ParamName::Plain(ident);\n \n-        if self.lifetimes_to_define.iter().any(|(_, lt_name)| *lt_name == hir_name) {\n+        if self.lifetimes_to_define.iter()\n+                                   .any(|(_, lt_name)| lt_name.modern() == hir_name.modern()) {\n             return;\n         }\n \n-        self.lifetimes_to_define.push((span, hir_name));\n+        self.lifetimes_to_define.push((ident.span, hir_name));\n     }\n \n     /// When we have either an elided or `'_` lifetime in an impl\n@@ -750,7 +749,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => Some(param.ident.name),\n+            GenericParamKind::Lifetime { .. } => Some(param.ident.modern()),\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);\n@@ -774,7 +773,7 @@ impl<'a> LoweringContext<'a> {\n     {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => Some(param.name.name()),\n+            hir::GenericParamKind::Lifetime { .. } => Some(param.name.ident().modern()),\n             _ => None,\n         });\n         self.in_scope_lifetimes.extend(lt_def_names);\n@@ -956,20 +955,9 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ident(&mut self, ident: Ident) -> Name {\n-        let ident = ident.modern();\n-        if ident.span.ctxt() == SyntaxContext::empty() {\n-            return ident.name;\n-        }\n-        *self.name_map\n-            .entry(ident)\n-            .or_insert_with(|| Symbol::from_ident(ident))\n-    }\n-\n     fn lower_label(&mut self, label: Option<Label>) -> Option<hir::Label> {\n         label.map(|label| hir::Label {\n-            name: label.ident.name,\n-            span: label.ident.span,\n+            ident: label.ident,\n         })\n     }\n \n@@ -1063,7 +1051,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_ty_binding(&mut self, b: &TypeBinding, itctx: ImplTraitContext) -> hir::TypeBinding {\n         hir::TypeBinding {\n             id: self.lower_node_id(b.id).node_id,\n-            name: self.lower_ident(b.ident),\n+            ident: b.ident,\n             ty: self.lower_ty(&b.ty, itctx),\n             span: b.span,\n         }\n@@ -1138,7 +1126,7 @@ impl<'a> LoweringContext<'a> {\n                 None,\n                 P(hir::Path {\n                     def: self.expect_full_def(t.id),\n-                    segments: hir_vec![hir::PathSegment::from_name(keywords::SelfType.name())],\n+                    segments: hir_vec![hir::PathSegment::from_ident(keywords::SelfType.ident())],\n                     span: t.span,\n                 }),\n             )),\n@@ -1194,14 +1182,14 @@ impl<'a> LoweringContext<'a> {\n \n                         let hir_bounds = self.lower_param_bounds(bounds, itctx);\n                         // Set the name to `impl Bound1 + Bound2`\n-                        let name = Symbol::intern(&pprust::ty_to_string(t));\n+                        let ident = Ident::from_str(&pprust::ty_to_string(t)).with_span_pos(span);\n                         self.in_band_ty_params.push(hir::GenericParam {\n                             id: def_node_id,\n-                            name: ParamName::Plain(name),\n-                            span,\n+                            name: ParamName::Plain(ident),\n                             pure_wrt_drop: false,\n                             attrs: hir_vec![],\n                             bounds: hir_bounds,\n+                            span,\n                             kind: hir::GenericParamKind::Type {\n                                 default: None,\n                                 synthetic: Some(hir::SyntheticTyParamKind::ImplTrait),\n@@ -1213,7 +1201,7 @@ impl<'a> LoweringContext<'a> {\n                             P(hir::Path {\n                                 span,\n                                 def: Def::TyParam(DefId::local(def_index)),\n-                                segments: hir_vec![hir::PathSegment::from_name(name)],\n+                                segments: hir_vec![hir::PathSegment::from_ident(ident)],\n                             }),\n                         ))\n                     }\n@@ -1443,15 +1431,15 @@ impl<'a> LoweringContext<'a> {\n                     self.context.resolver.definitions().create_def_with_parent(\n                         self.parent,\n                         def_node_id,\n-                        DefPathData::LifetimeParam(name.name().as_interned_str()),\n+                        DefPathData::LifetimeParam(name.ident().as_interned_str()),\n                         DefIndexAddressSpace::High,\n                         Mark::root(),\n                         lifetime.span,\n                     );\n \n                     let name = match name {\n                         hir::LifetimeName::Underscore => {\n-                            hir::ParamName::Plain(keywords::UnderscoreLifetime.name())\n+                            hir::ParamName::Plain(keywords::UnderscoreLifetime.ident())\n                         }\n                         hir::LifetimeName::Param(param_name) => param_name,\n                         _ => bug!(\"expected LifetimeName::Param or ParamName::Plain\"),\n@@ -1688,7 +1676,7 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         def: Def,\n         p: &Path,\n-        name: Option<Name>,\n+        ident: Option<Ident>,\n         param_mode: ParamMode,\n     ) -> hir::Path {\n         hir::Path {\n@@ -1705,7 +1693,7 @@ impl<'a> LoweringContext<'a> {\n                         ImplTraitContext::Disallowed,\n                     )\n                 })\n-                .chain(name.map(|name| hir::PathSegment::from_name(name)))\n+                .chain(ident.map(|ident| hir::PathSegment::from_ident(ident)))\n                 .collect(),\n             span: p.span,\n         }\n@@ -1768,7 +1756,7 @@ impl<'a> LoweringContext<'a> {\n         }\n \n         hir::PathSegment::new(\n-            self.lower_ident(segment.ident),\n+            segment.ident,\n             generic_args,\n             infer_types,\n         )\n@@ -1819,7 +1807,7 @@ impl<'a> LoweringContext<'a> {\n                         bindings: hir_vec![\n                             hir::TypeBinding {\n                                 id: this.next_id().node_id,\n-                                name: Symbol::intern(FN_OUTPUT_NAME),\n+                                ident: Ident::from_str(FN_OUTPUT_NAME),\n                                 ty: output\n                                     .as_ref()\n                                     .map(|ty| this.lower_ty(&ty, DISALLOWED))\n@@ -1867,12 +1855,12 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_fn_args_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Spanned<Name>> {\n+    fn lower_fn_args_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n         decl.inputs\n             .iter()\n             .map(|arg| match arg.pat.node {\n-                PatKind::Ident(_, ident, None) => respan(ident.span, ident.name),\n-                _ => respan(arg.pat.span, keywords::Invalid.name()),\n+                PatKind::Ident(_, ident, _) => ident,\n+                _ => Ident::new(keywords::Invalid.name(), arg.pat.span),\n             })\n             .collect()\n     }\n@@ -2114,7 +2102,7 @@ impl<'a> LoweringContext<'a> {\n             let future_params = P(hir::GenericArgs {\n                 args: hir_vec![],\n                 bindings: hir_vec![hir::TypeBinding {\n-                    name: Symbol::intern(FN_OUTPUT_NAME),\n+                    ident: Ident::from_str(FN_OUTPUT_NAME),\n                     ty: output_ty,\n                     id: this.next_id().node_id,\n                     span,\n@@ -2176,21 +2164,23 @@ impl<'a> LoweringContext<'a> {\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         let span = l.ident.span;\n-        match self.lower_ident(l.ident) {\n-            x if x == \"'static\" => self.new_named_lifetime(l.id, span, hir::LifetimeName::Static),\n-            x if x == \"'_\" => match self.anonymous_lifetime_mode {\n-                AnonymousLifetimeMode::CreateParameter => {\n-                    let fresh_name = self.collect_fresh_in_band_lifetime(span);\n-                    self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(fresh_name))\n-                }\n+        match l.ident {\n+            ident if ident.name == keywords::StaticLifetime.name() =>\n+                self.new_named_lifetime(l.id, span, hir::LifetimeName::Static),\n+            ident if ident.name == keywords::UnderscoreLifetime.name() =>\n+                match self.anonymous_lifetime_mode {\n+                    AnonymousLifetimeMode::CreateParameter => {\n+                        let fresh_name = self.collect_fresh_in_band_lifetime(span);\n+                        self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(fresh_name))\n+                    }\n \n-                AnonymousLifetimeMode::PassThrough => {\n-                    self.new_named_lifetime(l.id, span, hir::LifetimeName::Underscore)\n-                }\n-            },\n-            name => {\n-                self.maybe_collect_in_band_lifetime(span, name);\n-                let param_name = ParamName::Plain(name);\n+                    AnonymousLifetimeMode::PassThrough => {\n+                        self.new_named_lifetime(l.id, span, hir::LifetimeName::Underscore)\n+                    }\n+                },\n+            ident => {\n+                self.maybe_collect_in_band_lifetime(ident);\n+                let param_name = ParamName::Plain(ident);\n                 self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(param_name))\n             }\n         }\n@@ -2232,7 +2222,7 @@ impl<'a> LoweringContext<'a> {\n                 let lt = self.lower_lifetime(&Lifetime { id: param.id, ident: param.ident });\n                 let param_name = match lt.name {\n                     hir::LifetimeName::Param(param_name) => param_name,\n-                    _ => hir::ParamName::Plain(lt.name.name()),\n+                    _ => hir::ParamName::Plain(lt.name.ident()),\n                 };\n                 let param = hir::GenericParam {\n                     id: lt.id,\n@@ -2249,14 +2239,14 @@ impl<'a> LoweringContext<'a> {\n                 param\n             }\n             GenericParamKind::Type { ref default, .. } => {\n-                let mut name = self.lower_ident(param.ident);\n-\n                 // Don't expose `Self` (recovered \"keyword used as ident\" parse error).\n                 // `rustc::ty` expects `Self` to be only used for a trait's `Self`.\n                 // Instead, use gensym(\"Self\") to create a distinct name that looks the same.\n-                if name == keywords::SelfType.name() {\n-                    name = Symbol::gensym(\"Self\");\n-                }\n+                let ident = if param.ident.name == keywords::SelfType.name() {\n+                    param.ident.gensym()\n+                } else {\n+                    param.ident\n+                };\n \n                 let add_bounds = add_bounds.get(&param.id).map_or(&[][..], |x| &x);\n                 if !add_bounds.is_empty() {\n@@ -2267,11 +2257,11 @@ impl<'a> LoweringContext<'a> {\n \n                 hir::GenericParam {\n                     id: self.lower_node_id(param.id).node_id,\n-                    name: hir::ParamName::Plain(name),\n-                    span: param.ident.span,\n+                    name: hir::ParamName::Plain(ident),\n                     pure_wrt_drop: attr::contains_name(&param.attrs, \"may_dangle\"),\n                     attrs: self.lower_attrs(&param.attrs),\n                     bounds,\n+                    span: ident.span,\n                     kind: hir::GenericParamKind::Type {\n                         default: default.as_ref().map(|x| {\n                             self.lower_ty(x, ImplTraitContext::Disallowed)\n@@ -2961,7 +2951,7 @@ impl<'a> LoweringContext<'a> {\n         hir::TraitItem {\n             id: node_id,\n             hir_id,\n-            name: self.lower_ident(i.ident),\n+            ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             generics,\n             node,\n@@ -2987,7 +2977,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         hir::TraitItemRef {\n             id: hir::TraitItemId { node_id: i.id },\n-            name: self.lower_ident(i.ident),\n+            ident: i.ident,\n             span: i.span,\n             defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n             kind,\n@@ -3053,7 +3043,7 @@ impl<'a> LoweringContext<'a> {\n         hir::ImplItem {\n             id: node_id,\n             hir_id,\n-            name: self.lower_ident(i.ident),\n+            ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             generics,\n             vis: self.lower_visibility(&i.vis, None),\n@@ -3068,7 +3058,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n             id: hir::ImplItemId { node_id: i.id },\n-            name: self.lower_ident(i.ident),\n+            ident: i.ident,\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),\n@@ -3295,7 +3285,7 @@ impl<'a> LoweringContext<'a> {\n                         hir::PatKind::Binding(\n                             self.lower_binding_mode(binding_mode),\n                             canonical_id,\n-                            respan(ident.span, ident.name),\n+                            ident,\n                             sub.as_ref().map(|x| self.lower_pat(x)),\n                         )\n                     }\n@@ -3304,7 +3294,7 @@ impl<'a> LoweringContext<'a> {\n                         P(hir::Path {\n                             span: ident.span,\n                             def,\n-                            segments: hir_vec![hir::PathSegment::from_name(ident.name)],\n+                            segments: hir_vec![hir::PathSegment::from_ident(ident)],\n                         }),\n                     )),\n                 }\n@@ -3667,7 +3657,7 @@ impl<'a> LoweringContext<'a> {\n                 let e2 = self.lower_expr(e2);\n                 let ty_path = P(self.std_path(span, &[\"ops\", \"RangeInclusive\"], None, false));\n                 let ty = P(self.ty_path(id, span, hir::QPath::Resolved(None, ty_path)));\n-                let new_seg = P(hir::PathSegment::from_name(Symbol::intern(\"new\")));\n+                let new_seg = P(hir::PathSegment::from_ident(Ident::from_str(\"new\")));\n                 let new_path = hir::QPath::TypeRelative(ty, new_seg);\n                 let new = P(self.expr(span, hir::ExprPath(new_path), ThinVec::new()));\n                 hir::ExprCall(new, hir_vec![e1, e2])\n@@ -4337,14 +4327,14 @@ impl<'a> LoweringContext<'a> {\n         self.expr(span, hir::ExprCall(e, args), ThinVec::new())\n     }\n \n-    fn expr_ident(&mut self, span: Span, id: Name, binding: NodeId) -> hir::Expr {\n-        self.expr_ident_with_attrs(span, id, binding, ThinVec::new())\n+    fn expr_ident(&mut self, span: Span, ident: Ident, binding: NodeId) -> hir::Expr {\n+        self.expr_ident_with_attrs(span, ident, binding, ThinVec::new())\n     }\n \n     fn expr_ident_with_attrs(\n         &mut self,\n         span: Span,\n-        id: Name,\n+        ident: Ident,\n         binding: NodeId,\n         attrs: ThinVec<Attribute>,\n     ) -> hir::Expr {\n@@ -4353,7 +4343,7 @@ impl<'a> LoweringContext<'a> {\n             P(hir::Path {\n                 span,\n                 def: Def::Local(binding),\n-                segments: hir_vec![hir::PathSegment::from_name(id)],\n+                segments: hir_vec![hir::PathSegment::from_ident(ident)],\n             }),\n         ));\n \n@@ -4435,7 +4425,7 @@ impl<'a> LoweringContext<'a> {\n         &mut self,\n         sp: Span,\n         mutbl: bool,\n-        ident: Name,\n+        ident: Ident,\n         ex: P<hir::Expr>,\n     ) -> (hir::Stmt, NodeId) {\n         let pat = if mutbl {\n@@ -4506,22 +4496,22 @@ impl<'a> LoweringContext<'a> {\n         self.pat(span, pt)\n     }\n \n-    fn pat_ident(&mut self, span: Span, name: Name) -> P<hir::Pat> {\n-        self.pat_ident_binding_mode(span, name, hir::BindingAnnotation::Unannotated)\n+    fn pat_ident(&mut self, span: Span, ident: Ident) -> P<hir::Pat> {\n+        self.pat_ident_binding_mode(span, ident, hir::BindingAnnotation::Unannotated)\n     }\n \n     fn pat_ident_binding_mode(\n         &mut self,\n         span: Span,\n-        name: Name,\n+        ident: Ident,\n         bm: hir::BindingAnnotation,\n     ) -> P<hir::Pat> {\n         let LoweredNodeId { node_id, hir_id } = self.next_id();\n \n         P(hir::Pat {\n             id: node_id,\n             hir_id,\n-            node: hir::PatKind::Binding(bm, node_id, Spanned { span, node: name }, None),\n+            node: hir::PatKind::Binding(bm, node_id, ident.with_span_pos(span), None),\n             span,\n         })\n     }"}, {"sha": "930db8b0ccc3f06bc0eec13c146562a069d665ce", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -25,7 +25,7 @@ use hir as ast;\n use hir::map::{self, Node};\n use hir::{Expr, FnDecl};\n use hir::intravisit::FnKind;\n-use syntax::ast::{Attribute, Name, NodeId};\n+use syntax::ast::{Attribute, Ident, Name, NodeId};\n use syntax_pos::Span;\n \n /// An FnLikeNode is a Node that is like a fn, in that it has a decl\n@@ -209,16 +209,16 @@ impl<'a> FnLikeNode<'a> {\n         let closure = |c: ClosureParts<'a>| {\n             FnKind::Closure(c.attrs)\n         };\n-        let method = |_, name: Name, sig: &'a ast::MethodSig, vis, _, _, attrs| {\n-            FnKind::Method(name, sig, vis, attrs)\n+        let method = |_, ident: Ident, sig: &'a ast::MethodSig, vis, _, _, attrs| {\n+            FnKind::Method(ident, sig, vis, attrs)\n         };\n         self.handle(item, method, closure)\n     }\n \n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n         M: FnOnce(NodeId,\n-                  Name,\n+                  Ident,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n                   ast::BodyId,\n@@ -245,14 +245,14 @@ impl<'a> FnLikeNode<'a> {\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n                 ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n-                    method(ti.id, ti.name, sig, None, body, ti.span, &ti.attrs)\n+                    method(ti.id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, body) => {\n-                        method(ii.id, ii.name, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n+                        method(ii.id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => {\n                         bug!(\"impl method FnLikeNode that is not fn-like\")"}, {"sha": "2d3e9804835efa0c94c63a3ad101a43d2a854ec4", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         // map the actual nodes, not the duplicate ones in the *Ref.\n         let TraitItemRef {\n             id,\n-            name: _,\n+            ident: _,\n             kind: _,\n             span: _,\n             defaultness: _,\n@@ -509,7 +509,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         // map the actual nodes, not the duplicate ones in the *Ref.\n         let ImplItemRef {\n             id,\n-            name: _,\n+            ident: _,\n             kind: _,\n             span: _,\n             vis: _,"}, {"sha": "261b5d313eff0660037300c86bf4f260f3916066", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -112,11 +112,11 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         // information we encapsulate into, the better\n         let def_data = match i.node {\n             ItemKind::Impl(..) => DefPathData::Impl,\n-            ItemKind::Trait(..) => DefPathData::Trait(i.ident.name.as_interned_str()),\n+            ItemKind::Trait(..) => DefPathData::Trait(i.ident.as_interned_str()),\n             ItemKind::Enum(..) | ItemKind::Struct(..) | ItemKind::Union(..) |\n             ItemKind::TraitAlias(..) |\n             ItemKind::ExternCrate(..) | ItemKind::ForeignMod(..) | ItemKind::Ty(..) =>\n-                DefPathData::TypeNs(i.ident.name.as_interned_str()),\n+                DefPathData::TypeNs(i.ident.as_interned_str()),\n             ItemKind::Mod(..) if i.ident == keywords::Invalid.ident() => {\n                 return visit::walk_item(self, i);\n             }\n@@ -129,10 +129,10 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                     |this| visit::walk_item(this, i)\n                 )\n             }\n-            ItemKind::Mod(..) => DefPathData::Module(i.ident.name.as_interned_str()),\n+            ItemKind::Mod(..) => DefPathData::Module(i.ident.as_interned_str()),\n             ItemKind::Static(..) | ItemKind::Const(..) | ItemKind::Fn(..) =>\n-                DefPathData::ValueNs(i.ident.name.as_interned_str()),\n-            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.name.as_interned_str()),\n+                DefPathData::ValueNs(i.ident.as_interned_str()),\n+            ItemKind::MacroDef(..) => DefPathData::MacroDef(i.ident.as_interned_str()),\n             ItemKind::Mac(..) => return self.visit_macro_invoc(i.id),\n             ItemKind::GlobalAsm(..) => DefPathData::Misc,\n             ItemKind::Use(..) => {\n@@ -169,7 +169,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         }\n \n         let def = self.create_def(foreign_item.id,\n-                                  DefPathData::ValueNs(foreign_item.ident.name.as_interned_str()),\n+                                  DefPathData::ValueNs(foreign_item.ident.as_interned_str()),\n                                   REGULAR_SPACE,\n                                   foreign_item.span);\n \n@@ -180,8 +180,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n \n     fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n         let def = self.create_def(v.node.data.id(),\n-                                  DefPathData::EnumVariant(v.node.ident\n-                                                            .name.as_interned_str()),\n+                                  DefPathData::EnumVariant(v.node.ident.as_interned_str()),\n                                   REGULAR_SPACE,\n                                   v.span);\n         self.with_parent(def, |this| visit::walk_variant(this, v, g, item_id));\n@@ -201,7 +200,7 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n-        let name = param.ident.name.as_interned_str();\n+        let name = param.ident.as_interned_str();\n         let def_path_data = match param.kind {\n             GenericParamKind::Lifetime { .. } => DefPathData::LifetimeParam(name),\n             GenericParamKind::Type { .. } => DefPathData::TypeParam(name),\n@@ -214,9 +213,9 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     fn visit_trait_item(&mut self, ti: &'a TraitItem) {\n         let def_data = match ti.node {\n             TraitItemKind::Method(..) | TraitItemKind::Const(..) =>\n-                DefPathData::ValueNs(ti.ident.name.as_interned_str()),\n+                DefPathData::ValueNs(ti.ident.as_interned_str()),\n             TraitItemKind::Type(..) => {\n-                DefPathData::AssocTypeInTrait(ti.ident.name.as_interned_str())\n+                DefPathData::AssocTypeInTrait(ti.ident.as_interned_str())\n             },\n             TraitItemKind::Macro(..) => return self.visit_macro_invoc(ti.id),\n         };\n@@ -239,8 +238,8 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n                 )\n             }\n             ImplItemKind::Method(..) | ImplItemKind::Const(..) =>\n-                DefPathData::ValueNs(ii.ident.name.as_interned_str()),\n-            ImplItemKind::Type(..) => DefPathData::AssocTypeInImpl(ii.ident.name.as_interned_str()),\n+                DefPathData::ValueNs(ii.ident.as_interned_str()),\n+            ImplItemKind::Type(..) => DefPathData::AssocTypeInImpl(ii.ident.as_interned_str()),\n             ImplItemKind::Macro(..) => return self.visit_macro_invoc(ii.id),\n         };\n "}, {"sha": "b7071970a04b9e0bc01f6c25168718ce3cc603e8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -616,7 +616,7 @@ impl<'hir> Map<'hir> {\n             NodeItem(&Item { node: ItemTrait(..), .. }) => {\n                 keywords::SelfType.name()\n             }\n-            NodeGenericParam(param) => param.name.name(),\n+            NodeGenericParam(param) => param.name.ident().name,\n             _ => bug!(\"ty_param_name: {} not a type parameter\", self.node_to_string(id)),\n         }\n     }\n@@ -949,13 +949,13 @@ impl<'hir> Map<'hir> {\n         match self.get(id) {\n             NodeItem(i) => i.name,\n             NodeForeignItem(i) => i.name,\n-            NodeImplItem(ii) => ii.name,\n-            NodeTraitItem(ti) => ti.name,\n+            NodeImplItem(ii) => ii.ident.name,\n+            NodeTraitItem(ti) => ti.ident.name,\n             NodeVariant(v) => v.node.name,\n             NodeField(f) => f.ident.name,\n-            NodeLifetime(lt) => lt.name.name(),\n-            NodeGenericParam(param) => param.name.name(),\n-            NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.node,\n+            NodeLifetime(lt) => lt.name.ident().name,\n+            NodeGenericParam(param) => param.name.ident().name,\n+            NodeBinding(&Pat { node: PatKind::Binding(_,_,l,_), .. }) => l.name,\n             NodeStructCtor(_) => self.name(self.get_parent(id)),\n             _ => bug!(\"no name for {}\", self.node_to_string(id))\n         }\n@@ -1149,8 +1149,8 @@ impl Named for Item { fn name(&self) -> Name { self.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.name } }\n impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n-impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n-impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n+impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n \n \n pub fn map_crate<'hir>(sess: &::session::Session,\n@@ -1309,13 +1309,13 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeImplItem(ii)) => {\n             match ii.node {\n                 ImplItemKind::Const(..) => {\n-                    format!(\"assoc const {} in {}{}\", ii.name, path_str(), id_str)\n+                    format!(\"assoc const {} in {}{}\", ii.ident, path_str(), id_str)\n                 }\n                 ImplItemKind::Method(..) => {\n-                    format!(\"method {} in {}{}\", ii.name, path_str(), id_str)\n+                    format!(\"method {} in {}{}\", ii.ident, path_str(), id_str)\n                 }\n                 ImplItemKind::Type(_) => {\n-                    format!(\"assoc type {} in {}{}\", ii.name, path_str(), id_str)\n+                    format!(\"assoc type {} in {}{}\", ii.ident, path_str(), id_str)\n                 }\n             }\n         }\n@@ -1326,7 +1326,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 TraitItemKind::Type(..) => \"assoc type\",\n             };\n \n-            format!(\"{} {} in {}{}\", kind, ti.name, path_str(), id_str)\n+            format!(\"{} {} in {}{}\", kind, ti.ident, path_str(), id_str)\n         }\n         Some(NodeVariant(ref variant)) => {\n             format!(\"variant {} in {}{}\","}, {"sha": "5416474721045acbe022baad0abae5e39e060b01", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 48, "deletions": 31, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -175,13 +175,12 @@ pub const DUMMY_ITEM_LOCAL_ID: ItemLocalId = ItemLocalId(!0);\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub struct Label {\n-    pub name: Name,\n-    pub span: Span,\n+    pub ident: Ident,\n }\n \n impl fmt::Debug for Label {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"label({:?})\", self.name)\n+        write!(f, \"label({:?})\", self.ident)\n     }\n }\n \n@@ -202,7 +201,7 @@ pub struct Lifetime {\n #[derive(Debug, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Copy)]\n pub enum ParamName {\n     /// Some user-given name like `T` or `'x`.\n-    Plain(Name),\n+    Plain(Ident),\n \n     /// Synthetic name generated when user elided a lifetime in an impl header,\n     /// e.g. the lifetimes in cases like these:\n@@ -221,10 +220,17 @@ pub enum ParamName {\n }\n \n impl ParamName {\n-    pub fn name(&self) -> Name {\n+    pub fn ident(&self) -> Ident {\n+        match *self {\n+            ParamName::Plain(ident) => ident,\n+            ParamName::Fresh(_) => keywords::UnderscoreLifetime.ident(),\n+        }\n+    }\n+\n+    pub fn modern(&self) -> ParamName {\n         match *self {\n-            ParamName::Plain(name) => name,\n-            ParamName::Fresh(_) => keywords::UnderscoreLifetime.name(),\n+            ParamName::Plain(ident) => ParamName::Plain(ident.modern()),\n+            param_name => param_name,\n         }\n     }\n }\n@@ -245,33 +251,44 @@ pub enum LifetimeName {\n }\n \n impl LifetimeName {\n-    pub fn name(&self) -> Name {\n-        use self::LifetimeName::*;\n+    pub fn ident(&self) -> Ident {\n         match *self {\n-            Implicit => keywords::Invalid.name(),\n-            Underscore => keywords::UnderscoreLifetime.name(),\n-            Static => keywords::StaticLifetime.name(),\n-            Param(param_name) => param_name.name(),\n+            LifetimeName::Implicit => keywords::Invalid.ident(),\n+            LifetimeName::Underscore => keywords::UnderscoreLifetime.ident(),\n+            LifetimeName::Static => keywords::StaticLifetime.ident(),\n+            LifetimeName::Param(param_name) => param_name.ident(),\n         }\n     }\n \n     pub fn is_elided(&self) -> bool {\n-        use self::LifetimeName::*;\n         match self {\n-            Implicit | Underscore => true,\n+            LifetimeName::Implicit | LifetimeName::Underscore => true,\n \n             // It might seem surprising that `Fresh(_)` counts as\n             // *not* elided -- but this is because, as far as the code\n             // in the compiler is concerned -- `Fresh(_)` variants act\n             // equivalently to \"some fresh name\". They correspond to\n             // early-bound regions on an impl, in other words.\n-            Param(_) | Static => false,\n+            LifetimeName::Param(_) | LifetimeName::Static => false,\n         }\n     }\n \n     fn is_static(&self) -> bool {\n         self == &LifetimeName::Static\n     }\n+\n+    pub fn modern(&self) -> LifetimeName {\n+        match *self {\n+            LifetimeName::Param(param_name) => LifetimeName::Param(param_name.modern()),\n+            lifetime_name => lifetime_name,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Lifetime {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.name.ident().fmt(f)\n+    }\n }\n \n impl fmt::Debug for Lifetime {\n@@ -307,7 +324,7 @@ pub struct Path {\n \n impl Path {\n     pub fn is_global(&self) -> bool {\n-        !self.segments.is_empty() && self.segments[0].name == keywords::CrateRoot.name()\n+        !self.segments.is_empty() && self.segments[0].ident.name == keywords::CrateRoot.name()\n     }\n }\n \n@@ -328,7 +345,7 @@ impl fmt::Display for Path {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n-    pub name: Name,\n+    pub ident: Ident,\n \n     /// Type/lifetime parameters attached to this path. They come in\n     /// two flavors: `Path<A,B,C>` and `Path(A,B) -> C`. Note that\n@@ -346,17 +363,17 @@ pub struct PathSegment {\n \n impl PathSegment {\n     /// Convert an identifier to the corresponding segment.\n-    pub fn from_name(name: Name) -> PathSegment {\n+    pub fn from_ident(ident: Ident) -> PathSegment {\n         PathSegment {\n-            name,\n+            ident,\n             infer_types: true,\n             args: None,\n         }\n     }\n \n-    pub fn new(name: Name, args: GenericArgs, infer_types: bool) -> Self {\n+    pub fn new(ident: Ident, args: GenericArgs, infer_types: bool) -> Self {\n         PathSegment {\n-            name,\n+            ident,\n             infer_types,\n             args: if args.is_empty() {\n                 None\n@@ -859,7 +876,7 @@ pub enum PatKind {\n     /// The `NodeId` is the canonical ID for the variable being bound,\n     /// e.g. in `Ok(x) | Err(x)`, both `x` use the same canonical ID,\n     /// which is the pattern ID of the first `x`.\n-    Binding(BindingAnnotation, NodeId, Spanned<Name>, Option<P<Pat>>),\n+    Binding(BindingAnnotation, NodeId, Ident, Option<P<Pat>>),\n \n     /// A struct or struct variant pattern, e.g. `Variant {x, y, ..}`.\n     /// The `bool` is `true` in the presence of a `..`.\n@@ -1525,7 +1542,7 @@ pub struct TraitItemId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItem {\n     pub id: NodeId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n     pub generics: Generics,\n@@ -1537,7 +1554,7 @@ pub struct TraitItem {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum TraitMethod {\n     /// No default body in the trait, just a signature.\n-    Required(HirVec<Spanned<Name>>),\n+    Required(HirVec<Ident>),\n \n     /// Both signature and body are provided in the trait.\n     Provided(BodyId),\n@@ -1568,7 +1585,7 @@ pub struct ImplItemId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItem {\n     pub id: NodeId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub hir_id: HirId,\n     pub vis: Visibility,\n     pub defaultness: Defaultness,\n@@ -1594,7 +1611,7 @@ pub enum ImplItemKind {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TypeBinding {\n     pub id: NodeId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub ty: P<Ty>,\n     pub span: Span,\n }\n@@ -1632,7 +1649,7 @@ pub struct BareFnTy {\n     pub abi: Abi,\n     pub generic_params: HirVec<GenericParam>,\n     pub decl: P<FnDecl>,\n-    pub arg_names: HirVec<Spanned<Name>>,\n+    pub arg_names: HirVec<Ident>,\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n@@ -2129,7 +2146,7 @@ impl Item_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub kind: AssociatedItemKind,\n     pub span: Span,\n     pub defaultness: Defaultness,\n@@ -2144,7 +2161,7 @@ pub struct TraitItemRef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItemRef {\n     pub id: ImplItemId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub kind: AssociatedItemKind,\n     pub span: Span,\n     pub vis: Visibility,\n@@ -2172,7 +2189,7 @@ pub struct ForeignItem {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum ForeignItem_ {\n     /// A foreign function\n-    ForeignItemFn(P<FnDecl>, HirVec<Spanned<Name>>, Generics),\n+    ForeignItemFn(P<FnDecl>, HirVec<Ident>, Generics),\n     /// A foreign static item (`static ext: u8`), with optional mutability\n     /// (the boolean is true when mutable)\n     ForeignItemStatic(P<Ty>, bool),"}, {"sha": "14989f1ff7d8aa3e5a29e457a575d6feee764f33", "filename": "src/librustc/hir/pat_util.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fpat_util.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -12,7 +12,6 @@ use hir::def::Def;\n use hir::def_id::DefId;\n use hir::{self, HirId, PatKind};\n use syntax::ast;\n-use syntax::codemap::Spanned;\n use syntax_pos::Span;\n \n use std::iter::{Enumerate, ExactSizeIterator};\n@@ -91,11 +90,11 @@ impl hir::Pat {\n     /// Call `f` on every \"binding\" in a pattern, e.g., on `a` in\n     /// `match foo() { Some(a) => (), None => () }`\n     pub fn each_binding<F>(&self, mut f: F)\n-        where F: FnMut(hir::BindingAnnotation, HirId, Span, &Spanned<ast::Name>),\n+        where F: FnMut(hir::BindingAnnotation, HirId, Span, ast::Ident),\n     {\n         self.walk(|p| {\n-            if let PatKind::Binding(binding_mode, _, ref pth, _) = p.node {\n-                f(binding_mode, p.hir_id, p.span, pth);\n+            if let PatKind::Binding(binding_mode, _, ident, _) = p.node {\n+                f(binding_mode, p.hir_id, p.span, ident);\n             }\n             true\n         });\n@@ -132,20 +131,10 @@ impl hir::Pat {\n         contains_bindings\n     }\n \n-    pub fn simple_name(&self) -> Option<ast::Name> {\n+    pub fn simple_ident(&self) -> Option<ast::Ident> {\n         match self.node {\n-            PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ref path1, None) |\n-            PatKind::Binding(hir::BindingAnnotation::Mutable, _, ref path1, None) =>\n-                Some(path1.node),\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn simple_span(&self) -> Option<Span> {\n-        match self.node {\n-            PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ref path1, None) |\n-            PatKind::Binding(hir::BindingAnnotation::Mutable, _, ref path1, None) =>\n-                Some(path1.span),\n+            PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, None) |\n+            PatKind::Binding(hir::BindingAnnotation::Mutable, _, ident, None) => Some(ident),\n             _ => None,\n         }\n     }"}, {"sha": "c6f69a84d034d73f0657ee829189913ea8f29239", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 43, "deletions": 42, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -12,7 +12,7 @@ pub use self::AnnNode::*;\n \n use rustc_target::spec::abi::Abi;\n use syntax::ast;\n-use syntax::codemap::{CodeMap, Spanned};\n+use syntax::codemap::CodeMap;\n use syntax::parse::ParseSess;\n use syntax::parse::lexer::comments;\n use syntax::print::pp::{self, Breaks};\n@@ -497,14 +497,14 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_const(&mut self,\n-                              name: ast::Name,\n+                              ident: ast::Ident,\n                               ty: &hir::Ty,\n                               default: Option<hir::BodyId>,\n                               vis: &hir::Visibility)\n                               -> io::Result<()> {\n         self.s.word(&visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n-        self.print_name(name)?;\n+        self.print_ident(ident)?;\n         self.word_space(\":\")?;\n         self.print_type(ty)?;\n         if let Some(expr) = default {\n@@ -516,12 +516,12 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_type(&mut self,\n-                             name: ast::Name,\n+                             ident: ast::Ident,\n                              bounds: Option<&hir::GenericBounds>,\n                              ty: Option<&hir::Ty>)\n                              -> io::Result<()> {\n         self.word_space(\"type\")?;\n-        self.print_name(name)?;\n+        self.print_ident(ident)?;\n         if let Some(bounds) = bounds {\n             self.print_bounds(\":\", bounds)?;\n         }\n@@ -559,7 +559,7 @@ impl<'a> State<'a> {\n \n                 match kind {\n                     hir::UseKind::Single => {\n-                        if path.segments.last().unwrap().name != item.name {\n+                        if path.segments.last().unwrap().ident.name != item.name {\n                             self.s.space()?;\n                             self.word_space(\"as\")?;\n                             self.print_name(item.name)?;\n@@ -845,7 +845,8 @@ impl<'a> State<'a> {\n             hir::Visibility::Crate(ast::CrateSugar::PubCrate) => self.word_nbsp(\"pub(crate)\")?,\n             hir::Visibility::Restricted { ref path, .. } => {\n                 self.s.word(\"pub(\")?;\n-                if path.segments.len() == 1 && path.segments[0].name == keywords::Super.name() {\n+                if path.segments.len() == 1 &&\n+                   path.segments[0].ident.name == keywords::Super.name() {\n                     // Special case: `super` can print like `pub(super)`.\n                     self.s.word(\"super\")?;\n                 } else {\n@@ -928,16 +929,16 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n     pub fn print_method_sig(&mut self,\n-                            name: ast::Name,\n+                            ident: ast::Ident,\n                             m: &hir::MethodSig,\n                             generics: &hir::Generics,\n                             vis: &hir::Visibility,\n-                            arg_names: &[Spanned<ast::Name>],\n+                            arg_names: &[ast::Ident],\n                             body_id: Option<hir::BodyId>)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.header,\n-                      Some(name),\n+                      Some(ident.name),\n                       generics,\n                       vis,\n                       arg_names,\n@@ -951,24 +952,24 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n             hir::TraitItemKind::Const(ref ty, default) => {\n-                self.print_associated_const(ti.name, &ty, default, &hir::Inherited)?;\n+                self.print_associated_const(ti.ident, &ty, default, &hir::Inherited)?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref arg_names)) => {\n-                self.print_method_sig(ti.name, sig, &ti.generics, &hir::Inherited, arg_names,\n+                self.print_method_sig(ti.ident, sig, &ti.generics, &hir::Inherited, arg_names,\n                     None)?;\n                 self.s.word(\";\")?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ti.name, sig, &ti.generics, &hir::Inherited, &[],\n+                self.print_method_sig(ti.ident, sig, &ti.generics, &hir::Inherited, &[],\n                     Some(body))?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n                 self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n-                self.print_associated_type(ti.name,\n+                self.print_associated_type(ti.ident,\n                                            Some(bounds),\n                                            default.as_ref().map(|ty| &**ty))?;\n             }\n@@ -985,18 +986,18 @@ impl<'a> State<'a> {\n \n         match ii.node {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n-                self.print_associated_const(ii.name, &ty, Some(expr), &ii.vis)?;\n+                self.print_associated_const(ii.ident, &ty, Some(expr), &ii.vis)?;\n             }\n             hir::ImplItemKind::Method(ref sig, body) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ii.name, sig, &ii.generics, &ii.vis, &[], Some(body))?;\n+                self.print_method_sig(ii.ident, sig, &ii.generics, &ii.vis, &[], Some(body))?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n                 self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n-                self.print_associated_type(ii.name, None, Some(ty))?;\n+                self.print_associated_type(ii.ident, None, Some(ty))?;\n             }\n         }\n         self.ann.post(self, NodeSubItem(ii.id))\n@@ -1266,7 +1267,7 @@ impl<'a> State<'a> {\n         let base_args = &args[1..];\n         self.print_expr_maybe_paren(&args[0], parser::PREC_POSTFIX)?;\n         self.s.word(\".\")?;\n-        self.print_name(segment.name)?;\n+        self.print_ident(segment.ident)?;\n \n         segment.with_generic_args(|generic_args| {\n             if !generic_args.args.is_empty() || !generic_args.bindings.is_empty() {\n@@ -1379,7 +1380,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprWhile(ref test, ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n-                    self.print_name(label.name)?;\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"while\")?;\n@@ -1389,7 +1390,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprLoop(ref blk, opt_label, _) => {\n                 if let Some(label) = opt_label {\n-                    self.print_name(label.name)?;\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 self.head(\"loop\")?;\n@@ -1425,7 +1426,7 @@ impl<'a> State<'a> {\n             }\n             hir::ExprBlock(ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n-                    self.print_name(label.name)?;\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 // containing cbox, will be closed by print-block at }\n@@ -1467,7 +1468,7 @@ impl<'a> State<'a> {\n                 self.s.word(\"break\")?;\n                 self.s.space()?;\n                 if let Some(label) = destination.label {\n-                    self.print_name(label.name)?;\n+                    self.print_ident(label.ident)?;\n                     self.s.space()?;\n                 }\n                 if let Some(ref expr) = *opt_expr {\n@@ -1479,7 +1480,7 @@ impl<'a> State<'a> {\n                 self.s.word(\"continue\")?;\n                 self.s.space()?;\n                 if let Some(label) = destination.label {\n-                    self.print_name(label.name)?;\n+                    self.print_ident(label.ident)?;\n                     self.s.space()?\n                 }\n             }\n@@ -1614,7 +1615,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        self.print_ident(name.to_ident())\n+        self.print_ident(ast::Ident::with_empty_ctxt(name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) -> io::Result<()> {\n@@ -1634,9 +1635,9 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 self.s.word(\"::\")?\n             }\n-            if segment.name != keywords::CrateRoot.name() &&\n-               segment.name != keywords::DollarCrate.name() {\n-               self.print_name(segment.name)?;\n+            if segment.ident.name != keywords::CrateRoot.name() &&\n+               segment.ident.name != keywords::DollarCrate.name() {\n+               self.print_ident(segment.ident)?;\n                segment.with_generic_args(|generic_args| {\n                    self.print_generic_args(generic_args, segment.infer_types,\n                                            colons_before_params)\n@@ -1665,9 +1666,9 @@ impl<'a> State<'a> {\n                     if i > 0 {\n                         self.s.word(\"::\")?\n                     }\n-                    if segment.name != keywords::CrateRoot.name() &&\n-                       segment.name != keywords::DollarCrate.name() {\n-                        self.print_name(segment.name)?;\n+                    if segment.ident.name != keywords::CrateRoot.name() &&\n+                       segment.ident.name != keywords::DollarCrate.name() {\n+                        self.print_ident(segment.ident)?;\n                         segment.with_generic_args(|generic_args| {\n                             self.print_generic_args(generic_args,\n                                                     segment.infer_types,\n@@ -1679,7 +1680,7 @@ impl<'a> State<'a> {\n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n                 let item_segment = path.segments.last().unwrap();\n-                self.print_name(item_segment.name)?;\n+                self.print_ident(item_segment.ident)?;\n                 item_segment.with_generic_args(|generic_args| {\n                     self.print_generic_args(generic_args,\n                                             item_segment.infer_types,\n@@ -1691,7 +1692,7 @@ impl<'a> State<'a> {\n                 self.print_type(qself)?;\n                 self.s.word(\">\")?;\n                 self.s.word(\"::\")?;\n-                self.print_name(item_segment.name)?;\n+                self.print_ident(item_segment.ident)?;\n                 item_segment.with_generic_args(|generic_args| {\n                     self.print_generic_args(generic_args,\n                                             item_segment.infer_types,\n@@ -1762,7 +1763,7 @@ impl<'a> State<'a> {\n \n             for binding in generic_args.bindings.iter() {\n                 start_or_comma(self)?;\n-                self.print_name(binding.name)?;\n+                self.print_ident(binding.ident)?;\n                 self.s.space()?;\n                 self.word_space(\"=\")?;\n                 self.print_type(&binding.ty)?;\n@@ -1783,7 +1784,7 @@ impl<'a> State<'a> {\n         // is that it doesn't matter\n         match pat.node {\n             PatKind::Wild => self.s.word(\"_\")?,\n-            PatKind::Binding(binding_mode, _, ref path1, ref sub) => {\n+            PatKind::Binding(binding_mode, _, ident, ref sub) => {\n                 match binding_mode {\n                     hir::BindingAnnotation::Ref => {\n                         self.word_nbsp(\"ref\")?;\n@@ -1798,7 +1799,7 @@ impl<'a> State<'a> {\n                         self.word_nbsp(\"mut\")?;\n                     }\n                 }\n-                self.print_name(path1.node)?;\n+                self.print_ident(ident)?;\n                 if let Some(ref p) = *sub {\n                     self.s.word(\"@\")?;\n                     self.print_pat(&p)?;\n@@ -1963,7 +1964,7 @@ impl<'a> State<'a> {\n         match arm.body.node {\n             hir::ExprBlock(ref blk, opt_label) => {\n                 if let Some(label) = opt_label {\n-                    self.print_name(label.name)?;\n+                    self.print_ident(label.ident)?;\n                     self.word_space(\":\")?;\n                 }\n                 // the block will close the pattern's ibox\n@@ -1989,7 +1990,7 @@ impl<'a> State<'a> {\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n                     vis: &hir::Visibility,\n-                    arg_names: &[Spanned<ast::Name>],\n+                    arg_names: &[ast::Ident],\n                     body_id: Option<hir::BodyId>)\n                     -> io::Result<()> {\n         self.print_fn_header_info(header, vis)?;\n@@ -2006,8 +2007,8 @@ impl<'a> State<'a> {\n         assert!(arg_names.is_empty() || body_id.is_none());\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(indent_unit)?;\n-            if let Some(name) = arg_names.get(i) {\n-                s.s.word(&name.node.as_str())?;\n+            if let Some(arg_name) = arg_names.get(i) {\n+                s.s.word(&arg_name.as_str())?;\n                 s.s.word(\":\")?;\n                 s.s.space()?;\n             } else if let Some(body_id) = body_id {\n@@ -2112,7 +2113,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_generic_param(&mut self, param: &GenericParam) -> io::Result<()> {\n-        self.print_name(param.name.name())?;\n+        self.print_ident(param.name.ident())?;\n         match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n                 let mut sep = \":\";\n@@ -2143,7 +2144,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_lifetime(&mut self, lifetime: &hir::Lifetime) -> io::Result<()> {\n-        self.print_name(lifetime.name.name())\n+        self.print_ident(lifetime.name.ident())\n     }\n \n     pub fn print_where_clause(&mut self, where_clause: &hir::WhereClause) -> io::Result<()> {\n@@ -2241,7 +2242,7 @@ impl<'a> State<'a> {\n                        decl: &hir::FnDecl,\n                        name: Option<ast::Name>,\n                        generic_params: &[hir::GenericParam],\n-                       arg_names: &[Spanned<ast::Name>])\n+                       arg_names: &[ast::Ident])\n                        -> io::Result<()> {\n         self.ibox(indent_unit)?;\n         if !generic_params.is_empty() {"}, {"sha": "d59a20c652250d12b9ee511ecc9a5ec5c599aa9e", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 82, "deletions": 194, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -155,8 +155,7 @@ impl_stable_hash_for!(enum hir::LifetimeName {\n });\n \n impl_stable_hash_for!(struct hir::Label {\n-    span,\n-    name\n+    ident\n });\n \n impl_stable_hash_for!(struct hir::Lifetime {\n@@ -172,7 +171,7 @@ impl_stable_hash_for!(struct hir::Path {\n });\n \n impl_stable_hash_for!(struct hir::PathSegment {\n-    name,\n+    ident -> (ident.name),\n     infer_types,\n     args\n });\n@@ -201,10 +200,10 @@ impl_stable_hash_for!(enum hir::TraitBoundModifier {\n impl_stable_hash_for!(struct hir::GenericParam {\n     id,\n     name,\n-    span,\n     pure_wrt_drop,\n     attrs,\n     bounds,\n+    span,\n     kind\n });\n \n@@ -278,7 +277,7 @@ impl_stable_hash_for!(struct hir::MethodSig {\n \n impl_stable_hash_for!(struct hir::TypeBinding {\n     id,\n-    name,\n+    ident -> (ident.name),\n     ty,\n     span\n });\n@@ -359,20 +358,11 @@ impl_stable_hash_for!(enum hir::FunctionRetTy {\n     Return(t)\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitRef {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::TraitRef {\n-            ref path,\n-            // Don't hash the ref_id. It is tracked via the thing it is used to access\n-            ref_id: _,\n-        } = *self;\n-\n-        path.hash_stable(hcx, hasher);\n-    }\n-}\n-\n+impl_stable_hash_for!(struct hir::TraitRef {\n+    // Don't hash the ref_id. It is tracked via the thing it is used to access\n+    ref_id -> _,\n+    path,\n+});\n \n impl_stable_hash_for!(struct hir::PolyTraitRef {\n     bound_generic_params,\n@@ -395,66 +385,32 @@ impl_stable_hash_for!(struct hir::MacroDef {\n     body\n });\n \n+impl_stable_hash_for!(struct hir::Block {\n+    stmts,\n+    expr,\n+    id -> _,\n+    hir_id -> _,\n+    rules,\n+    span,\n+    targeted_by_break,\n+    recovered,\n+});\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Block {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::Block {\n-            ref stmts,\n-            ref expr,\n-            id: _,\n-            hir_id: _,\n-            rules,\n-            span,\n-            targeted_by_break,\n-            recovered,\n-        } = *self;\n-\n-        stmts.hash_stable(hcx, hasher);\n-        expr.hash_stable(hcx, hasher);\n-        rules.hash_stable(hcx, hasher);\n-        span.hash_stable(hcx, hasher);\n-        recovered.hash_stable(hcx, hasher);\n-        targeted_by_break.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Pat {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::Pat {\n-            id: _,\n-            hir_id: _,\n-            ref node,\n-            ref span\n-        } = *self;\n-\n-\n-        node.hash_stable(hcx, hasher);\n-        span.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::Pat {\n+    id -> _,\n+    hir_id -> _,\n+    node,\n+    span,\n+});\n \n impl_stable_hash_for_spanned!(hir::FieldPat);\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::FieldPat {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::FieldPat {\n-            id: _,\n-            ident,\n-            ref pat,\n-            is_shorthand,\n-        } = *self;\n-\n-        ident.hash_stable(hcx, hasher);\n-        pat.hash_stable(hcx, hasher);\n-        is_shorthand.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::FieldPat {\n+    id -> _,\n+    ident -> (ident.name),\n+    pat,\n+    is_shorthand,\n+});\n \n impl_stable_hash_for!(enum hir::BindingAnnotation {\n     Unannotated,\n@@ -537,24 +493,13 @@ impl_stable_hash_for!(struct hir::Arm {\n     body\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Field {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::Field {\n-            id: _,\n-            ident,\n-            ref expr,\n-            span,\n-            is_shorthand,\n-        } = *self;\n-\n-        ident.hash_stable(hcx, hasher);\n-        expr.hash_stable(hcx, hasher);\n-        span.hash_stable(hcx, hasher);\n-        is_shorthand.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::Field {\n+    id -> _,\n+    ident,\n+    expr,\n+    span,\n+    is_shorthand,\n+});\n \n impl_stable_hash_for_spanned!(ast::Name);\n \n@@ -686,19 +631,10 @@ impl_stable_hash_for!(enum hir::LoopIdError {\n     UnresolvedLabel\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ast::Ident {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ast::Ident {\n-            name,\n-            span,\n-        } = *self;\n-\n-        name.hash_stable(hcx, hasher);\n-        span.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct ast::Ident {\n+    name,\n+    span,\n+});\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -707,15 +643,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n         let hir::TraitItem {\n             id: _,\n             hir_id: _,\n-            name,\n+            ident,\n             ref attrs,\n             ref generics,\n             ref node,\n             span\n         } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n-            name.hash_stable(hcx, hasher);\n+            ident.name.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n             generics.hash_stable(hcx, hasher);\n             node.hash_stable(hcx, hasher);\n@@ -742,7 +678,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n         let hir::ImplItem {\n             id: _,\n             hir_id: _,\n-            name,\n+            ident,\n             ref vis,\n             defaultness,\n             ref attrs,\n@@ -752,7 +688,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n         } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n-            name.hash_stable(hcx, hasher);\n+            ident.name.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             defaultness.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n@@ -818,21 +754,13 @@ impl_stable_hash_for!(enum hir::ImplPolarity {\n     Negative\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::Mod {\n-            inner,\n-            // We are not hashing the IDs of the items contained in the module.\n-            // This is harmless and matches the current behavior but it's not\n-            // actually correct. See issue #40876.\n-            item_ids: _,\n-        } = *self;\n-\n-        inner.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::Mod {\n+    inner,\n+    // We are not hashing the IDs of the items contained in the module.\n+    // This is harmless and matches the current behavior but it's not\n+    // actually correct. See issue #40876.\n+    item_ids -> _,\n+});\n \n impl_stable_hash_for!(struct hir::ForeignMod {\n     abi,\n@@ -860,7 +788,7 @@ impl_stable_hash_for!(enum hir::UseKind {\n \n impl_stable_hash_for!(struct hir::StructField {\n     span,\n-    ident,\n+    ident -> (ident.name),\n     vis,\n     id,\n     ty,\n@@ -918,23 +846,22 @@ impl_stable_hash_for!(enum hir::Item_ {\n \n impl_stable_hash_for!(struct hir::TraitItemRef {\n     id,\n-    name,\n+    ident -> (ident.name),\n     kind,\n     span,\n     defaultness\n });\n \n impl_stable_hash_for!(struct hir::ImplItemRef {\n     id,\n-    name,\n+    ident -> (ident.name),\n     kind,\n     span,\n     vis,\n     defaultness\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for hir::AssociatedItemKind {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::AssociatedItemKind {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -1014,45 +941,22 @@ impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     is_indirect\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for hir::GlobalAsm {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::GlobalAsm {\n-            asm,\n-            ctxt: _\n-        } = *self;\n-\n-        asm.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for hir::InlineAsm {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::InlineAsm {\n-            asm,\n-            asm_str_style,\n-            ref outputs,\n-            ref inputs,\n-            ref clobbers,\n-            volatile,\n-            alignstack,\n-            dialect,\n-            ctxt: _, // This is used for error reporting\n-        } = *self;\n+impl_stable_hash_for!(struct hir::GlobalAsm {\n+    asm,\n+    ctxt -> _, // This is used for error reporting\n+});\n \n-        asm.hash_stable(hcx, hasher);\n-        asm_str_style.hash_stable(hcx, hasher);\n-        outputs.hash_stable(hcx, hasher);\n-        inputs.hash_stable(hcx, hasher);\n-        clobbers.hash_stable(hcx, hasher);\n-        volatile.hash_stable(hcx, hasher);\n-        alignstack.hash_stable(hcx, hasher);\n-        dialect.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::InlineAsm {\n+    asm,\n+    asm_str_style,\n+    outputs,\n+    inputs,\n+    clobbers,\n+    volatile,\n+    alignstack,\n+    dialect,\n+    ctxt -> _, // This is used for error reporting\n+});\n \n impl_stable_hash_for!(enum hir::def::CtorKind {\n     Fn,\n@@ -1115,8 +1019,7 @@ impl_stable_hash_for!(enum hir::Constness {\n     NotConst\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for hir::def_id::DefIndex {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::def_id::DefIndex {\n \n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n@@ -1142,8 +1045,7 @@ impl_stable_hash_for!(struct hir::def::Export {\n     span\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for ::middle::lang_items::LangItem {\n+impl<'a> HashStable<StableHashingContext<'a>> for ::middle::lang_items::LangItem {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -1156,8 +1058,7 @@ impl_stable_hash_for!(struct ::middle::lang_items::LanguageItems {\n     missing\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>>\n-for hir::TraitCandidate {\n+impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitCandidate {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -1191,26 +1092,13 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::TraitCandidate {\n     }\n }\n \n-impl<'hir> HashStable<StableHashingContext<'hir>> for hir::CodegenFnAttrs\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'hir>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let hir::CodegenFnAttrs {\n-            flags,\n-            inline,\n-            export_name,\n-            ref target_features,\n-            linkage,\n-        } = *self;\n-\n-        flags.hash_stable(hcx, hasher);\n-        inline.hash_stable(hcx, hasher);\n-        export_name.hash_stable(hcx, hasher);\n-        target_features.hash_stable(hcx, hasher);\n-        linkage.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct hir::CodegenFnAttrs {\n+    flags,\n+    inline,\n+    export_name,\n+    target_features,\n+    linkage,\n+});\n \n impl<'hir> HashStable<StableHashingContext<'hir>> for hir::CodegenFnAttrFlags\n {"}, {"sha": "55bcaad1a4ea25cff5ce6e28e98cc41ecd959386", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 34, "deletions": 88, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -357,17 +357,11 @@ impl_stable_hash_for!(enum ty::VariantDiscr {\n     Relative(distance)\n });\n \n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::FieldDef {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::FieldDef { did, ident, vis } = *self;\n-\n-        did.hash_stable(hcx, hasher);\n-        ident.name.hash_stable(hcx, hasher);\n-        vis.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct ty::FieldDef {\n+    did,\n+    ident -> (ident.name),\n+    vis,\n+});\n \n impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n for ::middle::const_val::ConstVal<'gcx> {\n@@ -545,15 +539,7 @@ impl_stable_hash_for!(struct ty::GenericPredicates<'tcx> {\n     predicates\n });\n \n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>>\n-for ::mir::interpret::EvalError<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        self.kind.hash_stable(hcx, hasher)\n-    }\n-}\n+impl_stable_hash_for!(struct ::mir::interpret::EvalError<'tcx> { kind });\n \n impl<'a, 'gcx, O: HashStable<StableHashingContext<'a>>> HashStable<StableHashingContext<'a>>\n for ::mir::interpret::EvalErrorKind<'gcx, O> {\n@@ -726,28 +712,15 @@ impl_stable_hash_for!(enum ty::adjustment::CustomCoerceUnsized {\n     Struct(index)\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ty::Generics {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::Generics {\n-            parent,\n-            ref parent_count,\n-            ref params,\n-\n-            // Reverse map to each param's `index` field, from its `def_id`.\n-            param_def_id_to_index: _, // Don't hash this\n-            has_self,\n-            has_late_bound_regions,\n-        } = *self;\n-\n-        parent.hash_stable(hcx, hasher);\n-        parent_count.hash_stable(hcx, hasher);\n-        params.hash_stable(hcx, hasher);\n-        has_self.hash_stable(hcx, hasher);\n-        has_late_bound_regions.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct ty::Generics {\n+    parent,\n+    parent_count,\n+    params,\n+    // Reverse map to each param's `index` field, from its `def_id`.\n+    param_def_id_to_index -> _, // Don't hash this\n+    has_self,\n+    has_late_bound_regions,\n+});\n \n impl_stable_hash_for!(struct ty::GenericParamDef {\n     name,\n@@ -1079,61 +1052,34 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::InstanceDef<'gcx> {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ty::TraitDef {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::TraitDef {\n-            // We already have the def_path_hash below, no need to hash it twice\n-            def_id: _,\n-            unsafety,\n-            paren_sugar,\n-            has_auto_impl,\n-            def_path_hash,\n-        } = *self;\n-\n-        unsafety.hash_stable(hcx, hasher);\n-        paren_sugar.hash_stable(hcx, hasher);\n-        has_auto_impl.hash_stable(hcx, hasher);\n-        def_path_hash.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct ty::TraitDef {\n+    // We already have the def_path_hash below, no need to hash it twice\n+    def_id -> _,\n+    unsafety,\n+    paren_sugar,\n+    has_auto_impl,\n+    def_path_hash,\n+});\n \n impl_stable_hash_for!(struct ty::Destructor {\n     did\n });\n \n-impl<'a> HashStable<StableHashingContext<'a>> for ty::CrateVariancesMap {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::CrateVariancesMap {\n-            ref variances,\n-            // This is just an irrelevant helper value.\n-            empty_variance: _,\n-        } = *self;\n-\n-        variances.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::CratePredicatesMap<'gcx> {\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let ty::CratePredicatesMap {\n-            ref predicates,\n-            // This is just an irrelevant helper value.\n-            empty_predicate: _,\n-        } = *self;\n+impl_stable_hash_for!(struct ty::CrateVariancesMap {\n+    variances,\n+    // This is just an irrelevant helper value.\n+    empty_variance -> _,\n+});\n \n-        predicates.hash_stable(hcx, hasher);\n-    }\n-}\n+impl_stable_hash_for!(struct ty::CratePredicatesMap<'tcx> {\n+    predicates,\n+    // This is just an irrelevant helper value.\n+    empty_predicate -> _,\n+});\n \n impl_stable_hash_for!(struct ty::AssociatedItem {\n     def_id,\n-    name,\n+    ident -> (ident.name),\n     kind,\n     vis,\n     defaultness,"}, {"sha": "482af9c005f32e42f39759d166b081daf5d65e4a", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -1255,7 +1255,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => format!(\n                 \" for lifetime parameter {}in trait containing associated type `{}`\",\n                 br_string(br),\n-                self.tcx.associated_item(def_id).name\n+                self.tcx.associated_item(def_id).ident\n             ),\n             infer::EarlyBoundRegion(_, name) => format!(\" for lifetime parameter `{}`\", name),\n             infer::BoundRegionInCoherence(name) => {"}, {"sha": "773de8912ce9b54d22fcf903da17685500225c16", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -131,8 +131,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             labels.clear();\n             labels.push((pattern.span, format!(\"consider giving this closure parameter a type\")));\n         } else if let Some(pattern) = local_visitor.found_local_pattern {\n-            if let Some(simple_name) = pattern.simple_name() {\n-                labels.push((pattern.span, format!(\"consider giving `{}` a type\", simple_name)));\n+            if let Some(simple_ident) = pattern.simple_ident() {\n+                labels.push((pattern.span, format!(\"consider giving `{}` a type\", simple_ident)));\n             } else {\n                 labels.push((pattern.span, format!(\"consider giving the pattern a type\")));\n             }"}, {"sha": "a2b8947521021ff03b810766bbdb0da8f6b1047b", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -96,14 +96,14 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = if let Some(simple_name) = anon_arg_sup.pat.simple_name() {\n-            format!(\" from `{}`\", simple_name)\n+        let span_label_var1 = if let Some(simple_ident) = anon_arg_sup.pat.simple_ident() {\n+            format!(\" from `{}`\", simple_ident)\n         } else {\n             format!(\"\")\n         };\n \n-        let span_label_var2 = if let Some(simple_name) = anon_arg_sub.pat.simple_name() {\n-            format!(\" into `{}`\", simple_name)\n+        let span_label_var2 = if let Some(simple_ident) = anon_arg_sub.pat.simple_ident() {\n+            format!(\" into `{}`\", simple_ident)\n         } else {\n             format!(\"\")\n         };"}, {"sha": "51abfa2505ab5cf49943000072e1493d6f50faad", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -95,10 +95,10 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             }\n         }\n \n-        let (error_var, span_label_var) = if let Some(simple_name) = arg.pat.simple_name() {\n+        let (error_var, span_label_var) = if let Some(simple_ident) = arg.pat.simple_ident() {\n             (\n-                format!(\"the type of `{}`\", simple_name),\n-                format!(\"the type of `{}`\", simple_name),\n+                format!(\"the type of `{}`\", simple_ident),\n+                format!(\"the type of `{}`\", simple_ident),\n             )\n         } else {\n             (\"parameter type\".to_owned(), \"type\".to_owned())"}, {"sha": "ccd9024f4aaabb412af30c066cbf7b9e27f88ad5", "filename": "src/librustc/macros.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmacros.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -64,15 +64,14 @@ macro_rules! span_bug {\n \n #[macro_export]\n macro_rules! __impl_stable_hash_field {\n-    (DECL IGNORED) => (_);\n-    (DECL $name:ident) => (ref $name);\n-    (USE IGNORED $ctx:expr, $hasher:expr) => ({});\n-    (USE $name:ident, $ctx:expr, $hasher:expr) => ($name.hash_stable($ctx, $hasher));\n+    ($field:ident, $ctx:expr, $hasher:expr) => ($field.hash_stable($ctx, $hasher));\n+    ($field:ident, $ctx:expr, $hasher:expr, _) => ({ let _ = $field; });\n+    ($field:ident, $ctx:expr, $hasher:expr, $delegate:expr) => ($delegate.hash_stable($ctx, $hasher));\n }\n \n #[macro_export]\n macro_rules! impl_stable_hash_for {\n-    (enum $enum_name:path { $( $variant:ident $( ( $($arg:ident),* ) )* ),* $(,)* }) => {\n+    (enum $enum_name:path { $( $variant:ident $( ( $($field:ident $(-> $delegate:tt)?),* ) )* ),* $(,)? }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $enum_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -83,15 +82,15 @@ macro_rules! impl_stable_hash_for {\n \n                 match *self {\n                     $(\n-                        $variant $( ( $( __impl_stable_hash_field!(DECL $arg) ),* ) )* => {\n-                            $($( __impl_stable_hash_field!(USE $arg, __ctx, __hasher) );*)*\n+                        $variant $( ( $(ref $field),* ) )* => {\n+                            $($( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*)*\n                         }\n                     )*\n                 }\n             }\n         }\n     };\n-    (struct $struct_name:path { $($field:ident),* }) => {\n+    (struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -101,11 +100,11 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 } = *self;\n \n-                $( $field.hash_stable(__ctx, __hasher));*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };\n-    (tuple_struct $struct_name:path { $($field:ident),* }) => {\n+    (tuple_struct $struct_name:path { $($field:ident $(-> $delegate:tt)?),*  $(,)? }) => {\n         impl<'a, 'tcx> ::rustc_data_structures::stable_hasher::HashStable<$crate::ich::StableHashingContext<'a>> for $struct_name {\n             #[inline]\n             fn hash_stable<W: ::rustc_data_structures::stable_hasher::StableHasherResult>(&self,\n@@ -115,7 +114,7 @@ macro_rules! impl_stable_hash_for {\n                     $(ref $field),*\n                 ) = *self;\n \n-                $( $field.hash_stable(__ctx, __hasher));*\n+                $( __impl_stable_hash_field!($field, __ctx, __hasher $(, $delegate)?) );*\n             }\n         }\n     };"}, {"sha": "caf73096ebf5e88e506091eff7779fcb72732ef1", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -599,7 +599,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id,\n                                         impl_item.span,\n-                                        impl_item.name,\n+                                        impl_item.ident.name,\n                                         \"associated const\",\n                                         \"used\");\n                 }\n@@ -608,7 +608,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n             hir::ImplItemKind::Method(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     let span = self.tcx.sess.codemap().def_span(impl_item.span);\n-                    self.warn_dead_code(impl_item.id, span, impl_item.name, \"method\", \"used\");\n+                    self.warn_dead_code(impl_item.id, span, impl_item.ident.name, \"method\", \"used\");\n                 }\n                 self.visit_nested_body(body_id)\n             }"}, {"sha": "07a9dd75d4ca4ae1229449666c4a1cc72a37887f", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -374,10 +374,9 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     let body = ir.tcx.hir.body(body_id);\n \n     for arg in &body.arguments {\n-        arg.pat.each_binding(|_bm, hir_id, _x, path1| {\n+        arg.pat.each_binding(|_bm, hir_id, _x, ident| {\n             debug!(\"adding argument {:?}\", hir_id);\n-            let name = path1.node;\n-            fn_maps.add_variable(Arg(hir_id, name));\n+            fn_maps.add_variable(Arg(hir_id, ident.name));\n         })\n     };\n \n@@ -430,12 +429,11 @@ fn add_from_pat<'a, 'tcx>(ir: &mut IrMaps<'a, 'tcx>, pat: &P<hir::Pat>) {\n         }\n     }\n \n-    pat.each_binding(|_bm, hir_id, _sp, path1| {\n-        let name = path1.node;\n-        ir.add_live_node_for_node(hir_id, VarDefNode(path1.span));\n+    pat.each_binding(|_bm, hir_id, _sp, ident| {\n+        ir.add_live_node_for_node(hir_id, VarDefNode(ident.span));\n         ir.add_variable(Local(LocalInfo {\n             id: hir_id,\n-            name,\n+            name: ident.name,\n             is_shorthand: shorthand_field_ids.contains(&hir_id)\n         }));\n     });\n@@ -1374,7 +1372,7 @@ fn check_local<'a, 'tcx>(this: &mut Liveness<'a, 'tcx>, local: &'tcx hir::Local)\n         },\n         None => {\n             this.pat_bindings(&local.pat, |this, ln, var, sp, id| {\n-                let span = local.pat.simple_span().unwrap_or(sp);\n+                let span = local.pat.simple_ident().map_or(sp, |ident| ident.span);\n                 this.warn_about_unused(span, id, ln, var);\n             })\n         }\n@@ -1475,12 +1473,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n \n     fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n         for arg in &body.arguments {\n-            arg.pat.each_binding(|_bm, hir_id, _, path1| {\n-                let sp = path1.span;\n+            arg.pat.each_binding(|_bm, hir_id, _, ident| {\n+                let sp = ident.span;\n                 let var = self.variable(hir_id, sp);\n                 // Ignore unused self.\n-                let name = path1.node;\n-                if name != keywords::SelfValue.name() {\n+                if ident.name != keywords::SelfValue.name() {\n                     if !self.warn_about_unused(sp, hir_id, entry_ln, var) {\n                         if self.live_on_entry(entry_ln, var).is_none() {\n                             self.report_dead_assign(hir_id, sp, var, true);"}, {"sha": "ed2b9c5068929c49a720f2b78be98730423e2acc", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -94,7 +94,7 @@ impl Region {\n         let def_id = hir_map.local_def_id(param.id);\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (param.name, Region::EarlyBound(i, def_id, origin))\n+        (param.name.modern(), Region::EarlyBound(i, def_id, origin))\n     }\n \n     fn late(hir_map: &Map, param: &GenericParam) -> (ParamName, Region) {\n@@ -108,7 +108,7 @@ impl Region {\n             def_id,\n             origin,\n         );\n-        (param.name, Region::LateBound(depth, def_id, origin))\n+        (param.name.modern(), Region::LateBound(depth, def_id, origin))\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -254,7 +254,7 @@ struct LifetimeContext<'a, 'tcx: 'a> {\n     is_in_fn_syntax: bool,\n \n     /// List of labels in the function/method currently under analysis.\n-    labels_in_fn: Vec<(ast::Name, Span)>,\n+    labels_in_fn: Vec<ast::Ident>,\n \n     /// Cache for cross-crate per-definition object lifetime defaults.\n     xcrate_object_lifetime_defaults: DefIdMap<Vec<ObjectLifetimeDefault>>,\n@@ -689,7 +689,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         GenericParamKind::Lifetime { .. } => {\n                             let (name, reg) = Region::early(&self.tcx.hir, &mut index, &param);\n                             if let hir::ParamName::Plain(param_name) = name {\n-                                if param_name == keywords::UnderscoreLifetime.name() {\n+                                if param_name.name == keywords::UnderscoreLifetime.name() {\n                                     // Pick the elided lifetime \"definition\" if one exists\n                                     // and use it to make an elision scope.\n                                     elision = Some(reg);\n@@ -1109,7 +1109,7 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n     struct GatherLabels<'a, 'tcx: 'a> {\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         scope: ScopeRef<'a>,\n-        labels_in_fn: &'a mut Vec<(ast::Name, Span)>,\n+        labels_in_fn: &'a mut Vec<ast::Ident>,\n     }\n \n     let mut gather = GatherLabels {\n@@ -1125,41 +1125,39 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n         }\n \n         fn visit_expr(&mut self, ex: &hir::Expr) {\n-            if let Some((label, label_span)) = expression_label(ex) {\n-                for &(prior, prior_span) in &self.labels_in_fn[..] {\n+            if let Some(label) = expression_label(ex) {\n+                for prior_label in &self.labels_in_fn[..] {\n                     // FIXME (#24278): non-hygienic comparison\n-                    if label == prior {\n+                    if label.name == prior_label.name {\n                         signal_shadowing_problem(\n                             self.tcx,\n-                            label,\n-                            original_label(prior_span),\n-                            shadower_label(label_span),\n+                            label.name,\n+                            original_label(prior_label.span),\n+                            shadower_label(label.span),\n                         );\n                     }\n                 }\n \n-                check_if_label_shadows_lifetime(self.tcx, self.scope, label, label_span);\n+                check_if_label_shadows_lifetime(self.tcx, self.scope, label);\n \n-                self.labels_in_fn.push((label, label_span));\n+                self.labels_in_fn.push(label);\n             }\n             intravisit::walk_expr(self, ex)\n         }\n     }\n \n-    fn expression_label(ex: &hir::Expr) -> Option<(ast::Name, Span)> {\n+    fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n         match ex.node {\n-            hir::ExprWhile(.., Some(label)) | hir::ExprLoop(_, Some(label), _) => {\n-                Some((label.name, label.span))\n-            }\n+            hir::ExprWhile(.., Some(label)) |\n+            hir::ExprLoop(_, Some(label), _) => Some(label.ident),\n             _ => None,\n         }\n     }\n \n     fn check_if_label_shadows_lifetime(\n         tcx: TyCtxt<'_, '_, '_>,\n         mut scope: ScopeRef<'_>,\n-        label: ast::Name,\n-        label_span: Span,\n+        label: ast::Ident,\n     ) {\n         loop {\n             match *scope {\n@@ -1177,15 +1175,14 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n                     ref lifetimes, s, ..\n                 } => {\n                     // FIXME (#24278): non-hygienic comparison\n-                    let param_name = hir::ParamName::Plain(label);\n-                    if let Some(def) = lifetimes.get(&param_name) {\n+                    if let Some(def) = lifetimes.get(&hir::ParamName::Plain(label.modern())) {\n                         let node_id = tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             tcx,\n-                            label,\n+                            label.name,\n                             original_lifetime(tcx.hir.span(node_id)),\n-                            shadower_label(label_span),\n+                            shadower_label(label.span),\n                         );\n                         return;\n                     }\n@@ -1220,7 +1217,7 @@ fn compute_object_lifetime_defaults(\n                                 generics.params.iter().find_map(|param| match param.kind {\n                                         GenericParamKind::Lifetime { .. } => {\n                                             if i == 0 {\n-                                                return Some(param.name.name().to_string());\n+                                                return Some(param.name.ident().to_string());\n                                             }\n                                             i -= 1;\n                                             None\n@@ -1254,7 +1251,7 @@ fn object_lifetime_defaults_for_item(\n     fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound]) {\n         for bound in bounds {\n             if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n-                set.insert(lifetime.name);\n+                set.insert(lifetime.name.modern());\n             }\n         }\n     }\n@@ -1400,10 +1397,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"node id first={:?}\", node_id);\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n                         hir::map::NodeLifetime(hir_lifetime) => {\n-                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.name()))\n+                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n                         hir::map::NodeGenericParam(param) => {\n-                            Some((param.id, param.span, param.name.name()))\n+                            Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n                     } {\n@@ -1426,10 +1423,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n                         hir::map::NodeLifetime(hir_lifetime) => {\n-                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.name()))\n+                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n                         hir::map::NodeGenericParam(param) => {\n-                            Some((param.id, param.span, param.name.name()))\n+                            Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n                     } {\n@@ -1582,7 +1579,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         LifetimeName::Param(param_name) => param_name,\n                         _ => bug!(\"expected LifetimeName::Param\"),\n                     };\n-                    if let Some(&def) = lifetimes.get(&name) {\n+                    if let Some(&def) = lifetimes.get(&name.modern()) {\n                         break Some(def.shifted(late_depth));\n                     } else {\n                         late_depth += 1;\n@@ -1651,7 +1648,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 lifetime_ref.span,\n                 E0261,\n                 \"use of undeclared lifetime name `{}`\",\n-                lifetime_ref.name.name()\n+                lifetime_ref\n             ).span_label(lifetime_ref.span, \"undeclared lifetime\")\n                 .emit();\n         }\n@@ -2246,15 +2243,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }).collect();\n         for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n             if let hir::ParamName::Plain(_) = lifetime_i_name {\n-                let name = lifetime_i_name.name();\n+                let name = lifetime_i_name.ident().name;\n                 if name == keywords::UnderscoreLifetime.name() ||\n                    name == keywords::StaticLifetime.name() {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n                         lifetime_i.span,\n                         E0262,\n                         \"invalid lifetime parameter name: `{}`\",\n-                        name\n+                        lifetime_i.name.ident(),\n                     );\n                     err.span_label(\n                         lifetime_i.span,\n@@ -2272,7 +2269,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         lifetime_j.span,\n                         E0263,\n                         \"lifetime name `{}` declared twice in the same scope\",\n-                        lifetime_j.name.name()\n+                        lifetime_j.name.ident()\n                     ).span_label(lifetime_j.span, \"declared twice\")\n                      .span_label(lifetime_i.span, \"previous declaration here\")\n                      .emit();\n@@ -2301,12 +2298,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                 lifetime_i.span.to(lt.span),\n                                 &format!(\n                                     \"unnecessary lifetime parameter `{}`\",\n-                                    lifetime_i.name.name(),\n+                                    lifetime_i.name.ident(),\n                                 ),\n                             ).help(&format!(\n                                 \"you can use the `'static` lifetime directly, in place \\\n                                     of `{}`\",\n-                                lifetime_i.name.name(),\n+                                lifetime_i.name.ident(),\n                             )).emit();\n                         }\n                         hir::LifetimeName::Param(_)\n@@ -2325,13 +2322,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         mut old_scope: ScopeRef,\n         param: &'tcx hir::GenericParam,\n     ) {\n-        for &(label, label_span) in &self.labels_in_fn {\n+        for label in &self.labels_in_fn {\n             // FIXME (#24278): non-hygienic comparison\n-            if param.name.name() == label {\n+            if param.name.ident().name == label.name {\n                 signal_shadowing_problem(\n                     self.tcx,\n-                    label,\n-                    original_label(label_span),\n+                    label.name,\n+                    original_label(label.span),\n                     shadower_lifetime(&param),\n                 );\n                 return;\n@@ -2353,12 +2350,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder {\n                     ref lifetimes, s, ..\n                 } => {\n-                    if let Some(&def) = lifetimes.get(&param.name) {\n+                    if let Some(&def) = lifetimes.get(&param.name.modern()) {\n                         let node_id = self.tcx.hir.as_local_node_id(def.id().unwrap()).unwrap();\n \n                         signal_shadowing_problem(\n                             self.tcx,\n-                            param.name.name(),\n+                            param.name.ident().name,\n                             original_lifetime(self.tcx.hir.span(node_id)),\n                             shadower_lifetime(&param),\n                         );\n@@ -2520,7 +2517,8 @@ fn insert_late_bound_lifetimes(\n             hir::GenericParamKind::Lifetime { .. } => {\n                 if !param.bounds.is_empty() {\n                     // `'a: 'b` means both `'a` and `'b` are referenced\n-                    appears_in_where_clause.regions.insert(hir::LifetimeName::Param(param.name));\n+                    appears_in_where_clause\n+                        .regions.insert(hir::LifetimeName::Param(param.name.modern()));\n                 }\n             }\n             hir::GenericParamKind::Type { .. } => {}\n@@ -2537,7 +2535,7 @@ fn insert_late_bound_lifetimes(\n     // - do not appear in the where-clauses\n     // - are not implicitly captured by `impl Trait`\n     for param in &generics.params {\n-        let lt_name = hir::LifetimeName::Param(param.name);\n+        let lt_name = hir::LifetimeName::Param(param.name.modern());\n         // appears in the where clauses? early-bound.\n         if appears_in_where_clause.regions.contains(&lt_name) {\n             continue;\n@@ -2551,7 +2549,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         debug!(\"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n-               param.name.name(),\n+               param.name.ident(),\n                param.id);\n \n         let inserted = map.late_bound.insert(param.id);\n@@ -2596,7 +2594,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name);\n+            self.regions.insert(lifetime_ref.name.modern());\n         }\n     }\n \n@@ -2610,7 +2608,7 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name);\n+            self.regions.insert(lifetime_ref.name.modern());\n         }\n     }\n }"}, {"sha": "a289a2c21ce7f421c3d2876a8284e118c46adf68", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -744,7 +744,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     for impl_item_ref in impl_item_refs {\n                         let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n                         let trait_item_def_id = self.tcx.associated_items(trait_did)\n-                            .find(|item| item.name == impl_item.name).map(|item| item.def_id);\n+                            .find(|item| item.ident.name == impl_item.ident.name)\n+                            .map(|item| item.def_id);\n                         if let Some(def_id) = trait_item_def_id {\n                             // Pass `None` to skip deprecation warnings.\n                             self.tcx.check_stability(def_id, None, impl_item.span);"}, {"sha": "fe2965146cb7f80be1762f2657dedfa2aae4f4a1", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             .filter(|item| item.kind == ty::AssociatedKind::Method)\n             .filter_map(|item| {\n                 self.object_safety_violation_for_method(trait_def_id, &item)\n-                    .map(|code| ObjectSafetyViolation::Method(item.name, code))\n+                    .map(|code| ObjectSafetyViolation::Method(item.ident.name, code))\n             }).filter(|violation| {\n                 if let ObjectSafetyViolation::Method(_,\n                                 MethodViolationCode::WhereClauseReferencesSelf(span)) = violation {\n@@ -159,7 +159,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         violations.extend(self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssociatedKind::Const)\n-            .map(|item| ObjectSafetyViolation::AssociatedConst(item.name)));\n+            .map(|item| ObjectSafetyViolation::AssociatedConst(item.ident.name)));\n \n         debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n                trait_def_id,"}, {"sha": "97b15048b48f6a2db8eed5fbdfec91d8c7f5aa38", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -31,7 +31,7 @@ use infer::type_variable::TypeVariableOrigin;\n use middle::const_val::ConstVal;\n use mir::interpret::{GlobalId};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n-use syntax::symbol::Symbol;\n+use syntax::ast::Ident;\n use ty::subst::{Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -1349,10 +1349,10 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n                                             obligation.predicate.self_ty(),\n                                             gen_sig)\n         .map_bound(|(trait_ref, yield_ty, return_ty)| {\n-            let name = tcx.associated_item(obligation.predicate.item_def_id).name;\n-            let ty = if name == Symbol::intern(\"Return\") {\n+            let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n+            let ty = if name == \"Return\" {\n                 return_ty\n-            } else if name == Symbol::intern(\"Yield\") {\n+            } else if name == \"Yield\" {\n                 yield_ty\n             } else {\n                 bug!()\n@@ -1452,7 +1452,7 @@ fn confirm_callable_candidate<'cx, 'gcx, 'tcx>(\n                 projection_ty: ty::ProjectionTy::from_ref_and_name(\n                     tcx,\n                     trait_ref,\n-                    Symbol::intern(FN_OUTPUT_NAME),\n+                    Ident::from_str(FN_OUTPUT_NAME),\n                 ),\n                 ty: ret_type\n             }\n@@ -1508,7 +1508,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n         // checker method `check_impl_items_against_trait`, so here we\n         // just return TyError.\n         debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n-               assoc_ty.item.name,\n+               assoc_ty.item.ident,\n                obligation.predicate);\n         tcx.types.err\n     } else {\n@@ -1533,7 +1533,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     -> specialization_graph::NodeItem<ty::AssociatedItem>\n {\n     let tcx = selcx.tcx();\n-    let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).name;\n+    let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n     let trait_def = tcx.trait_def(trait_def_id);\n \n@@ -1546,7 +1546,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     let impl_node = specialization_graph::Node::Impl(impl_def_id);\n     for item in impl_node.items(tcx) {\n         if item.kind == ty::AssociatedKind::Type &&\n-                tcx.hygienic_eq(item.name, assoc_ty_name, trait_def_id) {\n+                tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id) {\n             return specialization_graph::NodeItem {\n                 node: specialization_graph::Node::Impl(impl_def_id),\n                 item,"}, {"sha": "f151f3b2531a682a65c6ea42a15d6b19de77cdf1", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -129,7 +129,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     let trait_def = tcx.trait_def(trait_def_id);\n \n     let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n-    match ancestors.defs(tcx, item.name, item.kind, trait_def_id).next() {\n+    match ancestors.defs(tcx, item.ident, item.kind, trait_def_id).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = ty::ParamEnv::reveal_all();"}, {"sha": "b64e4228be9d21abae26c245aca4e7ff23bd30fc", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -18,7 +18,7 @@ use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use rustc_data_structures::sync::Lrc;\n-use syntax::ast::Name;\n+use syntax::ast::Ident;\n use util::captures::Captures;\n use util::nodemap::{DefIdMap, FxHashMap};\n \n@@ -372,14 +372,14 @@ impl<'a, 'gcx, 'tcx> Ancestors {\n     pub fn defs(\n         self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        trait_item_name: Name,\n+        trait_item_name: Ident,\n         trait_item_kind: ty::AssociatedKind,\n         trait_def_id: DefId,\n     ) -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + Captures<'gcx> + Captures<'tcx> + 'a {\n         self.flat_map(move |node| {\n             node.items(tcx).filter(move |impl_item| {\n                 impl_item.kind == trait_item_kind &&\n-                tcx.hygienic_eq(impl_item.name, trait_item_name, trait_def_id)\n+                tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id)\n             }).map(move |item| NodeItem { node: node, item: item })\n         })\n     }"}, {"sha": "d8fa978a6a07c89f4e9e46043bd0f4adec9ee2b5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -177,7 +177,7 @@ pub struct ImplHeader<'tcx> {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct AssociatedItem {\n     pub def_id: DefId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub kind: AssociatedKind,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n@@ -224,9 +224,9 @@ impl AssociatedItem {\n                 // regions just fine, showing `fn(&MyType)`.\n                 format!(\"{}\", tcx.fn_sig(self.def_id).skip_binder())\n             }\n-            ty::AssociatedKind::Type => format!(\"type {};\", self.name.to_string()),\n+            ty::AssociatedKind::Type => format!(\"type {};\", self.ident),\n             ty::AssociatedKind::Const => {\n-                format!(\"const {}: {:?};\", self.name.to_string(), tcx.type_of(self.def_id))\n+                format!(\"const {}: {:?};\", self.ident, tcx.type_of(self.def_id))\n             }\n         }\n     }\n@@ -2494,7 +2494,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         AssociatedItem {\n-            name: trait_item_ref.name,\n+            ident: trait_item_ref.ident,\n             kind,\n             // Visibility of trait items is inherited from their traits.\n             vis: Visibility::from_hir(parent_vis, trait_item_ref.id.node_id, self),\n@@ -2518,8 +2518,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             hir::AssociatedItemKind::Type => (ty::AssociatedKind::Type, false),\n         };\n \n-        ty::AssociatedItem {\n-            name: impl_item_ref.name,\n+        AssociatedItem {\n+            ident: impl_item_ref.ident,\n             kind,\n             // Visibility of trait impl items doesn't matter.\n             vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.node_id, self),\n@@ -2544,10 +2544,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn associated_items(\n         self,\n         def_id: DefId,\n-    ) -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+    ) -> impl Iterator<Item = AssociatedItem> + 'a {\n         let def_ids = self.associated_item_def_ids(def_id);\n         Box::new((0..def_ids.len()).map(move |i| self.associated_item(def_ids[i])))\n-            as Box<dyn Iterator<Item = ty::AssociatedItem> + 'a>\n+            as Box<dyn Iterator<Item = AssociatedItem> + 'a>\n     }\n \n     /// Returns true if the impls are the same polarity and are implementing\n@@ -2717,9 +2717,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     // Hygienically compare a use-site name (`use_name`) for a field or an associated item with its\n     // supposed definition name (`def_name`). The method also needs `DefId` of the supposed\n     // definition's parent/scope to perform comparison.\n-    pub fn hygienic_eq(self, use_name: Name, def_name: Name, def_parent_def_id: DefId) -> bool {\n-        let (use_ident, def_ident) = (use_name.to_ident(), def_name.to_ident());\n-        self.adjust_ident(use_ident, def_parent_def_id, DUMMY_NODE_ID).0 == def_ident\n+    pub fn hygienic_eq(self, use_name: Ident, def_name: Ident, def_parent_def_id: DefId) -> bool {\n+        self.adjust_ident(use_name, def_parent_def_id, DUMMY_NODE_ID).0 == def_name.modern()\n     }\n \n     pub fn adjust_ident(self, mut ident: Ident, scope: DefId, block: NodeId) -> (Ident, DefId) {"}, {"sha": "186ebd73b4cc5acdae44f9f0a98b4560a8b199d5", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -25,7 +25,7 @@ use mir::interpret::{Scalar, Pointer, Value, ConstValue};\n use std::iter;\n use std::cmp::Ordering;\n use rustc_target::spec::abi;\n-use syntax::ast::{self, Name};\n+use syntax::ast::{self, Ident};\n use syntax::symbol::{keywords, InternedString};\n \n use serialize;\n@@ -853,11 +853,11 @@ impl<'a, 'tcx> ProjectionTy<'tcx> {\n     /// Construct a ProjectionTy by searching the trait from trait_ref for the\n     /// associated item named item_name.\n     pub fn from_ref_and_name(\n-        tcx: TyCtxt, trait_ref: ty::TraitRef<'tcx>, item_name: Name\n+        tcx: TyCtxt, trait_ref: ty::TraitRef<'tcx>, item_name: Ident\n     ) -> ProjectionTy<'tcx> {\n         let item_def_id = tcx.associated_items(trait_ref.def_id).find(|item| {\n             item.kind == ty::AssociatedKind::Type &&\n-            tcx.hygienic_eq(item_name, item.name, trait_ref.def_id)\n+            tcx.hygienic_eq(item_name, item.ident, trait_ref.def_id)\n         }).unwrap().def_id;\n \n         ProjectionTy {"}, {"sha": "ff6d711cef0c8a08ea2db8f5002ae71e8ff78863", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -429,7 +429,7 @@ impl PrintContext {\n             ty::tls::with(|tcx|\n                 print!(f, self,\n                        write(\"{}=\",\n-                             tcx.associated_item(projection.projection_ty.item_def_id).name),\n+                             tcx.associated_item(projection.projection_ty.item_def_id).ident),\n                        print_display(projection.ty))\n             )?;\n         }\n@@ -1286,7 +1286,7 @@ define_print! {\n             //   parameterized(f, self.substs, self.item_def_id, &[])\n             // (which currently ICEs).\n             let (trait_ref, item_name) = ty::tls::with(|tcx|\n-                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n+                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).ident)\n             );\n             print!(f, cx, print_debug(trait_ref), write(\"::{}\", item_name))\n         }"}, {"sha": "241950fb6bff069b7e2d5d0a8489e440ec96c31b", "filename": "src/librustc_borrowck/borrowck/gather_loans/gather_moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fgather_moves.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -109,10 +109,10 @@ pub fn gather_move_from_pat<'a, 'c, 'tcx: 'c>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                                               cmt: &'c mc::cmt_<'tcx>) {\n     let source = get_pattern_source(bccx.tcx,move_pat);\n     let pat_span_path_opt = match move_pat.node {\n-        PatKind::Binding(_, _, ref path1, _) => {\n+        PatKind::Binding(_, _, ident, _) => {\n             Some(MovePlace {\n                      span: move_pat.span,\n-                     name: path1.node,\n+                     name: ident.name,\n                      pat_source: source,\n                  })\n         }"}, {"sha": "294ae1e63a9ee6f922b836ee6d2d46faa18c4d4e", "filename": "src/librustc_borrowck/borrowck/unused.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Funused.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -46,11 +46,9 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n         let tcx = self.bccx.tcx;\n         let mut mutables = FxHashMap();\n         for p in pats {\n-            p.each_binding(|_, hir_id, span, path1| {\n-                let name = path1.node;\n-\n+            p.each_binding(|_, hir_id, span, ident| {\n                 // Skip anything that looks like `_foo`\n-                if name.as_str().starts_with(\"_\") {\n+                if ident.as_str().starts_with(\"_\") {\n                     return;\n                 }\n \n@@ -65,7 +63,7 @@ impl<'a, 'tcx> UnusedMutCx<'a, 'tcx> {\n                     _ => return,\n                 }\n \n-                mutables.entry(name).or_insert(Vec::new()).push((hir_id, span));\n+                mutables.entry(ident.name).or_insert(Vec::new()).push((hir_id, span));\n             });\n         }\n "}, {"sha": "84f7b35d21f33c542ba2d01dd37d44bebb7c2557", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -1075,7 +1075,7 @@ impl RustcDefaultCalls {\n                     let mut cfgs = Vec::new();\n                     for &(name, ref value) in sess.parse_sess.config.iter() {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            ident: ast::Path::from_ident(name.to_ident()),\n+                            ident: ast::Path::from_ident(ast::Ident::with_empty_ctxt(name)),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });"}, {"sha": "6bc364b72618f9b5be97986c08baace2f534f599", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -151,7 +151,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCamelCaseTypes {\n             GenericParamKind::Lifetime { .. } => {}\n             GenericParamKind::Type { synthetic, .. } => {\n                 if synthetic.is_none() {\n-                    self.check_case(cx, \"type parameter\", param.name.name(), param.span);\n+                    self.check_case(cx, \"type parameter\", param.name.ident().name, param.span);\n                 }\n             }\n         }\n@@ -258,7 +258,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     fn check_generic_param(&mut self, cx: &LateContext, param: &hir::GenericParam) {\n         match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n-                let name = param.name.name().as_str();\n+                let name = param.name.ident().as_str();\n                 self.check_snake_case(cx, \"lifetime\", &name, Some(param.span));\n             }\n             GenericParamKind::Type { .. } => {}\n@@ -302,20 +302,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n-        if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(ref names)) = item.node {\n+        if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(ref pnames)) = item.node {\n             self.check_snake_case(cx,\n                                   \"trait method\",\n-                                  &item.name.as_str(),\n+                                  &item.ident.as_str(),\n                                   Some(item.span));\n-            for name in names {\n-                self.check_snake_case(cx, \"variable\", &name.node.as_str(), Some(name.span));\n+            for param_name in pnames {\n+                self.check_snake_case(cx, \"variable\", &param_name.as_str(), Some(param_name.span));\n             }\n         }\n     }\n \n     fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n-        if let &PatKind::Binding(_, _, ref path1, _) = &p.node {\n-            self.check_snake_case(cx, \"variable\", &path1.node.as_str(), Some(p.span));\n+        if let &PatKind::Binding(_, _, ref ident, _) = &p.node {\n+            self.check_snake_case(cx, \"variable\", &ident.as_str(), Some(p.span));\n         }\n     }\n \n@@ -385,7 +385,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n         match ti.node {\n             hir::TraitItemKind::Const(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ti.name, ti.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ti.ident.name, ti.span);\n             }\n             _ => {}\n         }\n@@ -394,7 +395,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Const(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ii.name, ii.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ii.ident.name, ii.span);\n             }\n             _ => {}\n         }\n@@ -407,7 +409,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n                 if path.segments.len() == 1 {\n                     NonUpperCaseGlobals::check_upper_case(cx,\n                                                           \"constant in pattern\",\n-                                                          path.segments[0].name,\n+                                                          path.segments[0].ident.name,\n                                                           path.span);\n                 }\n             }"}, {"sha": "b4dc5f9c85b0b78f6bd760daf8c7fe1b1c9973f9", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -182,18 +182,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n                     // (Issue #49588)\n                     continue;\n                 }\n-                if let PatKind::Binding(_, _, name, None) = fieldpat.node.pat.node {\n-                    let binding_ident = ast::Ident::new(name.node, name.span);\n-                    if cx.tcx.find_field_index(binding_ident, &variant) ==\n+                if let PatKind::Binding(_, _, ident, None) = fieldpat.node.pat.node {\n+                    if cx.tcx.find_field_index(ident, &variant) ==\n                        Some(cx.tcx.field_index(fieldpat.node.id, cx.tables)) {\n                         let mut err = cx.struct_span_lint(NON_SHORTHAND_FIELD_PATTERNS,\n                                      fieldpat.span,\n-                                     &format!(\"the `{}:` in this pattern is redundant\",\n-                                              name.node));\n+                                     &format!(\"the `{}:` in this pattern is redundant\", ident));\n                         let subspan = cx.tcx.sess.codemap().span_through_char(fieldpat.span, ':');\n-                        err.span_suggestion_short(subspan,\n-                                                  \"remove this\",\n-                                                  format!(\"{}\", name.node));\n+                        err.span_suggestion_short(subspan, \"remove this\", format!(\"{}\", ident));\n                         err.emit();\n                     }\n                 }\n@@ -1082,7 +1078,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                                 let container = ty::ImplContainer(vtable_impl.impl_def_id);\n                                 // It matches if it comes from the same impl,\n                                 // and has the same method name.\n-                                container == method.container && callee_item.name == method.name\n+                                container == method.container &&\n+                                callee_item.ident.name == method.ident.name\n                             }\n \n                             // There's no way to know if this call is"}, {"sha": "6eea4b2617cc282bc12f64bf8723c24557f1a8c2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -817,7 +817,7 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         ty::AssociatedItem {\n-            name: name.as_symbol(),\n+            ident: Ident::from_interned_str(name),\n             kind,\n             vis: item.visibility.decode(self),\n             defaultness: container.defaultness(),"}, {"sha": "d8a224d3badd8692390396d37d31e30bcc501e76", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -39,9 +39,8 @@ use std::path::Path;\n use rustc_data_structures::sync::Lrc;\n use std::u32;\n use syntax::ast::{self, CRATE_NODE_ID};\n-use syntax::codemap::Spanned;\n use syntax::attr;\n-use syntax::symbol::Symbol;\n+use syntax::symbol::keywords;\n use syntax_pos::{self, hygiene, FileName, FileMap, Span, DUMMY_SP};\n \n use rustc::hir::{self, PatKind};\n@@ -975,16 +974,15 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n             let body = self.tcx.hir.body(body_id);\n             self.lazy_seq(body.arguments.iter().map(|arg| {\n                 match arg.pat.node {\n-                    PatKind::Binding(_, _, name, _) => name.node,\n-                    _ => Symbol::intern(\"\")\n+                    PatKind::Binding(_, _, ident, _) => ident.name,\n+                    _ => keywords::Invalid.name(),\n                 }\n             }))\n         })\n     }\n \n-    fn encode_fn_arg_names(&mut self, names: &[Spanned<ast::Name>])\n-                           -> LazySeq<ast::Name> {\n-        self.lazy_seq(names.iter().map(|name| name.node))\n+    fn encode_fn_arg_names(&mut self, param_names: &[ast::Ident]) -> LazySeq<ast::Name> {\n+        self.lazy_seq(param_names.iter().map(|ident| ident.name))\n     }\n \n     fn encode_optimized_mir(&mut self, def_id: DefId) -> Option<Lazy<mir::Mir<'tcx>>> {"}, {"sha": "0fbedcaff6ee89df79564eaeb6bc9e4211d2dcec", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -15,6 +15,7 @@\n #![feature(box_patterns)]\n #![feature(fs_read_write)]\n #![feature(libc)]\n+#![feature(macro_at_most_once_rep)]\n #![cfg_attr(stage0, feature(macro_lifetime_matcher))]\n #![feature(proc_macro_internals)]\n #![feature(quote)]"}, {"sha": "ab20b7bfea2b9490f599e4b62a33034d08e82a26", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -538,8 +538,8 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 mutability: Mutability::Not,\n             };\n             if let Some(hir::map::NodeBinding(pat)) = tcx.hir.find(var_id) {\n-                if let hir::PatKind::Binding(_, _, ref name, _) = pat.node {\n-                    decl.debug_name = name.node;\n+                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                    decl.debug_name = ident.name;\n \n                     let bm = *hir.tables.pat_binding_modes()\n                                         .get(pat.hir_id)\n@@ -675,8 +675,8 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             // If this is a simple binding pattern, give the local a nice name for debuginfo.\n             let mut name = None;\n             if let Some(pat) = pattern {\n-                if let hir::PatKind::Binding(_, _, ref ident, _) = pat.node {\n-                    name = Some(ident.node);\n+                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                    name = Some(ident.name);\n                 }\n             }\n "}, {"sha": "167e031fbeec1dd633ff82357f5c9a1c1c4622d9", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let method_name = Symbol::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n-            if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n+            if item.kind == ty::AssociatedKind::Method && item.ident.name == method_name {\n                 let method_ty = self.tcx.type_of(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty,"}, {"sha": "19b3654d2c7dc123756d2e825e037219b4245dae", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -308,7 +308,7 @@ impl<'a, 'tcx> MatchVisitor<'a, 'tcx> {\n \n fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n     pat.walk(|p| {\n-        if let PatKind::Binding(_, _, name, None) = p.node {\n+        if let PatKind::Binding(_, _, ident, None) = p.node {\n             let bm = *cx.tables\n                         .pat_binding_modes()\n                         .get(p.hir_id)\n@@ -321,17 +321,17 @@ fn check_for_bindings_named_the_same_as_variants(cx: &MatchVisitor, pat: &Pat) {\n             let pat_ty = cx.tables.pat_ty(p);\n             if let ty::TyAdt(edef, _) = pat_ty.sty {\n                 if edef.is_enum() && edef.variants.iter().any(|variant| {\n-                    variant.name == name.node && variant.ctor_kind == CtorKind::Const\n+                    variant.name == ident.name && variant.ctor_kind == CtorKind::Const\n                 }) {\n                     let ty_path = cx.tcx.item_path_str(edef.did);\n                     let mut err = struct_span_warn!(cx.tcx.sess, p.span, E0170,\n                         \"pattern binding `{}` is named the same as one \\\n                          of the variants of the type `{}`\",\n-                        name.node, ty_path);\n+                        ident, ty_path);\n                     err.span_suggestion_with_applicability(\n                         p.span,\n                         \"to match on the variant, qualify the path\",\n-                        format!(\"{}::{}\", ty_path, name.node),\n+                        format!(\"{}::{}\", ty_path, ident),\n                         Applicability::MachineApplicable\n                     );\n                     err.emit();"}, {"sha": "3f3e29a808a4f725d9a6634ed40716cd3ce27277", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -461,7 +461,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                 }\n             }\n \n-            PatKind::Binding(_, id, ref name, ref sub) => {\n+            PatKind::Binding(_, id, ident, ref sub) => {\n                 let var_ty = self.tables.node_id_to_type(pat.hir_id);\n                 let region = match var_ty.sty {\n                     ty::TyRef(r, _, _) => Some(r),\n@@ -491,14 +491,14 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     if let ty::TyRef(_, rty, _) = ty.sty {\n                         ty = rty;\n                     } else {\n-                        bug!(\"`ref {}` has wrong type {}\", name.node, ty);\n+                        bug!(\"`ref {}` has wrong type {}\", ident, ty);\n                     }\n                 }\n \n                 PatternKind::Binding {\n                     mutability,\n                     mode,\n-                    name: name.node,\n+                    name: ident.name,\n                     var: id,\n                     ty: var_ty,\n                     subpattern: self.lower_opt_pattern(sub),"}, {"sha": "c079b9d3dc4404f5b7dcb0fbc7049a528da973e1", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -1115,10 +1115,10 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let overridden_methods: FxHashSet<_> =\n                     impl_item_refs.iter()\n-                                  .map(|iiref| iiref.name)\n+                                  .map(|iiref| iiref.ident.modern())\n                                   .collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n-                    if overridden_methods.contains(&method.name) {\n+                    if overridden_methods.contains(&method.ident.modern()) {\n                         continue;\n                     }\n "}, {"sha": "0428489fd8d78b06c831d1559a2b17740a8042be", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -441,7 +441,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n         for projection in projections {\n             let projection = projection.skip_binder();\n-            let name = &self.tcx.associated_item(projection.item_def_id).name.as_str();\n+            let name = &self.tcx.associated_item(projection.item_def_id).ident.as_str();\n             output.push_str(name);\n             output.push_str(\"=\");\n             self.push_type_name(projection.ty, output);"}, {"sha": "2aecbf32ec5a1e81fc53f166cee4cb5853187fa0", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -830,8 +830,8 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             let is_local_static = if let Def::Static(..) = def { def_id.is_local() } else { false };\n             if !self.item_is_accessible(def_id) && !is_local_static {\n                 let name = match *qpath {\n-                    hir::QPath::Resolved(_, ref path) => format!(\"{}\", path),\n-                    hir::QPath::TypeRelative(_, ref segment) => segment.name.to_string(),\n+                    hir::QPath::Resolved(_, ref path) => path.to_string(),\n+                    hir::QPath::TypeRelative(_, ref segment) => segment.ident.to_string(),\n                 };\n                 let msg = format!(\"{} `{}` is private\", def.kind_name(), name);\n                 self.tcx.sess.span_err(span, &msg);"}, {"sha": "464356eb5d242206d57395cf70be46516bc230ec", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -1497,17 +1497,17 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n         args: Option<P<hir::GenericArgs>>,\n         is_value: bool\n     ) -> hir::Path {\n-        let mut segments = iter::once(keywords::CrateRoot.name())\n+        let mut segments = iter::once(keywords::CrateRoot.ident())\n             .chain(\n                 crate_root.into_iter()\n                     .chain(components.iter().cloned())\n-                    .map(Symbol::intern)\n-            ).map(hir::PathSegment::from_name).collect::<Vec<_>>();\n+                    .map(Ident::from_str)\n+            ).map(hir::PathSegment::from_ident).collect::<Vec<_>>();\n \n         if let Some(args) = args {\n-            let name = segments.last().unwrap().name;\n+            let ident = segments.last().unwrap().ident;\n             *segments.last_mut().unwrap() = hir::PathSegment {\n-                name,\n+                ident,\n                 args: Some(args),\n                 infer_types: true,\n             };\n@@ -1550,16 +1550,16 @@ impl<'a> Resolver<'a> {\n             hir::Path {\n                 span,\n                 def: Def::Err,\n-                segments: iter::once(keywords::CrateRoot.name()).chain({\n-                    path_str.split(\"::\").skip(1).map(Symbol::intern)\n-                }).map(hir::PathSegment::from_name).collect(),\n+                segments: iter::once(keywords::CrateRoot.ident()).chain({\n+                    path_str.split(\"::\").skip(1).map(Ident::from_str)\n+                }).map(hir::PathSegment::from_ident).collect(),\n             }\n         } else {\n             hir::Path {\n                 span,\n                 def: Def::Err,\n-                segments: path_str.split(\"::\").map(Symbol::intern)\n-                                  .map(hir::PathSegment::from_name).collect(),\n+                segments: path_str.split(\"::\").map(Ident::from_str)\n+                                  .map(hir::PathSegment::from_ident).collect(),\n             }\n         };\n         self.resolve_hir_path_cb(&mut path, is_value, |_, _, _| errored = true);\n@@ -1572,13 +1572,11 @@ impl<'a> Resolver<'a> {\n \n     /// resolve_hir_path, but takes a callback in case there was an error\n     fn resolve_hir_path_cb<F>(&mut self, path: &mut hir::Path, is_value: bool, error_callback: F)\n-            where F: for<'c, 'b> FnOnce(&'c mut Resolver, Span, ResolutionError<'b>)\n-        {\n+        where F: for<'c, 'b> FnOnce(&'c mut Resolver, Span, ResolutionError<'b>)\n+    {\n         let namespace = if is_value { ValueNS } else { TypeNS };\n         let hir::Path { ref segments, span, ref mut def } = *path;\n-        let path: Vec<Ident> = segments.iter()\n-            .map(|seg| Ident::new(seg.name, span))\n-            .collect();\n+        let path: Vec<_> = segments.iter().map(|seg| seg.ident).collect();\n         // FIXME (Manishearth): Intra doc links won't get warned of epoch changes\n         match self.resolve_path(&path, Some(namespace), true, span, CrateLint::No) {\n             PathResult::Module(module) => *def = module.def().unwrap(),\n@@ -3507,7 +3505,7 @@ impl<'a> Resolver<'a> {\n \n         match path.get(1) {\n             // If this import looks like `crate::...` it's already good\n-            Some(name) if name.name == keywords::Crate.name() => return,\n+            Some(ident) if ident.name == keywords::Crate.name() => return,\n             // Otherwise go below to see if it's an extern crate\n             Some(_) => {}\n             // If the path has length one (and it's `CrateRoot` most likely)"}, {"sha": "311978ec248091709a905f9aecf82b49b920dc88", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -316,14 +316,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         sig: &'l ast::MethodSig,\n         body: Option<&'l ast::Block>,\n         id: ast::NodeId,\n-        name: ast::Ident,\n+        ident: ast::Ident,\n         generics: &'l ast::Generics,\n         vis: ast::Visibility,\n         span: Span,\n     ) {\n-        debug!(\"process_method: {}:{}\", id, name);\n+        debug!(\"process_method: {}:{}\", id, ident);\n \n-        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, name.name, span) {\n+        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, ident.name, span) {\n             let sig_str = ::make_signature(&sig.decl, &generics);\n             if body.is_some() {\n                 self.nest_tables(\n@@ -335,7 +335,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             self.process_generic_params(&generics, span, &method_data.qualname, id);\n \n             method_data.value = sig_str;\n-            method_data.sig = sig::method_signature(id, name, generics, sig, &self.save_ctxt);\n+            method_data.sig = sig::method_signature(id, ident, generics, sig, &self.save_ctxt);\n             self.dumper.dump_def(&access_from!(self.save_ctxt, vis, id), method_data);\n         }\n "}, {"sha": "89d30fd666a883d88d67c80b9ff4c046cc68ff23", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -438,7 +438,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 qualname.push_str(&self.tcx.item_path_str(def_id));\n                                 self.tcx\n                                     .associated_items(def_id)\n-                                    .find(|item| item.name == name)\n+                                    .find(|item| item.ident.name == name)\n                                     .map(|item| decl_id = Some(item.def_id));\n                             }\n                             qualname.push_str(\">\");\n@@ -775,7 +775,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     let ti = self.tcx.associated_item(decl_id);\n                     self.tcx\n                         .associated_items(ti.container.id())\n-                        .find(|item| item.name == ti.name && item.defaultness.has_value())\n+                        .find(|item| item.ident.name == ti.ident.name &&\n+                                     item.defaultness.has_value())\n                         .map(|item| item.def_id)\n                 } else {\n                     None"}, {"sha": "214376b2e532b14a406e1d8854c23c4cb6d64241", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -417,7 +417,7 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n     let hypotheses = vec![trait_implemented];\n \n     // `<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm>`\n-    let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.name);\n+    let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.ident);\n \n     // `Normalize(<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm> -> T)`\n     let normalize_goal = DomainGoal::Normalize(ty::ProjectionPredicate { projection_ty, ty });"}, {"sha": "762dc5d26f5a4f3a02972740a0b3b8580f763c21", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -83,7 +83,7 @@ pub trait AstConv<'gcx, 'tcx> {\n }\n \n struct ConvertedBinding<'tcx> {\n-    item_name: ast::Name,\n+    item_name: ast::Ident,\n     ty: Ty<'tcx>,\n     span: Span,\n }\n@@ -342,7 +342,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n         let assoc_bindings = generic_args.bindings.iter().map(|binding| {\n             ConvertedBinding {\n-                item_name: binding.name,\n+                item_name: binding.ident,\n                 ty: self.ast_ty_to_ty(&binding.ty),\n                 span: binding.span,\n             }\n@@ -485,12 +485,12 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n     fn trait_defines_associated_type_named(&self,\n                                            trait_def_id: DefId,\n-                                           assoc_name: ast::Name)\n+                                           assoc_name: ast::Ident)\n                                            -> bool\n     {\n         self.tcx().associated_items(trait_def_id).any(|item| {\n             item.kind == ty::AssociatedKind::Type &&\n-            self.tcx().hygienic_eq(assoc_name, item.name, trait_def_id)\n+            self.tcx().hygienic_eq(assoc_name, item.ident, trait_def_id)\n         })\n     }\n \n@@ -569,9 +569,9 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         }?;\n \n         let (assoc_ident, def_scope) =\n-            tcx.adjust_ident(binding.item_name.to_ident(), candidate.def_id(), ref_id);\n+            tcx.adjust_ident(binding.item_name, candidate.def_id(), ref_id);\n         let assoc_ty = tcx.associated_items(candidate.def_id()).find(|i| {\n-            i.kind == ty::AssociatedKind::Type && i.name.to_ident() == assoc_ident\n+            i.kind == ty::AssociatedKind::Type && i.ident.modern() == assoc_ident\n         }).expect(\"missing associated type\");\n \n         if !assoc_ty.vis.is_accessible_from(def_scope, tcx) {\n@@ -711,10 +711,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             let trait_def_id = assoc_item.container.id();\n             struct_span_err!(tcx.sess, span, E0191,\n                 \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                        assoc_item.name,\n+                        assoc_item.ident,\n                         tcx.item_path_str(trait_def_id))\n                         .span_label(span, format!(\n-                            \"missing associated type `{}` value\", assoc_item.name))\n+                            \"missing associated type `{}` value\", assoc_item.ident))\n                         .emit();\n         }\n \n@@ -778,7 +778,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     // any ambiguity.\n     fn find_bound_for_assoc_item(&self,\n                                  ty_param_def_id: DefId,\n-                                 assoc_name: ast::Name,\n+                                 assoc_name: ast::Ident,\n                                  span: Span)\n                                  -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n     {\n@@ -807,7 +807,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     fn one_bound_for_assoc_type<I>(&self,\n                                 mut bounds: I,\n                                 ty_param_name: &str,\n-                                assoc_name: ast::Name,\n+                                assoc_name: ast::Ident,\n                                 span: Span)\n         -> Result<ty::PolyTraitRef<'tcx>, ErrorReported>\n         where I: Iterator<Item=ty::PolyTraitRef<'tcx>>\n@@ -837,7 +837,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             for bound in bounds {\n                 let bound_span = self.tcx().associated_items(bound.def_id()).find(|item| {\n                     item.kind == ty::AssociatedKind::Type &&\n-                    self.tcx().hygienic_eq(assoc_name, item.name, bound.def_id())\n+                    self.tcx().hygienic_eq(assoc_name, item.ident, bound.def_id())\n                 })\n                 .and_then(|item| self.tcx().hir.span_if_local(item.def_id));\n \n@@ -873,7 +873,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                                      -> (Ty<'tcx>, Def)\n     {\n         let tcx = self.tcx();\n-        let assoc_name = item_segment.name;\n+        let assoc_name = item_segment.ident;\n \n         debug!(\"associated_path_def_to_ty: {:?}::{}\", ty, assoc_name);\n \n@@ -895,8 +895,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n \n                 let candidates =\n                     traits::supertraits(tcx, ty::Binder::bind(trait_ref))\n-                    .filter(|r| self.trait_defines_associated_type_named(r.def_id(),\n-                                                                         assoc_name));\n+                    .filter(|r| self.trait_defines_associated_type_named(r.def_id(), assoc_name));\n \n                 match self.one_bound_for_assoc_type(candidates, \"Self\", assoc_name, span) {\n                     Ok(bound) => bound,\n@@ -923,10 +922,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         };\n \n         let trait_did = bound.def_id();\n-        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_name.to_ident(), trait_did, ref_id);\n+        let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_name, trait_did, ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n-            i.name.to_ident() == assoc_ident\n+            i.ident.modern() == assoc_ident\n         })\n         .expect(\"missing associated type\");\n \n@@ -963,7 +962,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             self.report_ambiguous_associated_type(span,\n                                                   \"Type\",\n                                                   &path_str,\n-                                                  &item_segment.name.as_str());\n+                                                  &item_segment.ident.as_str());\n             return tcx.types.err;\n         };\n "}, {"sha": "09562614982b81eda5c9878a210310c2a1dd8b51", "filename": "src/librustc_typeck/check/autoderef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fautoderef.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -21,7 +21,7 @@ use rustc::ty::{ToPredicate, TypeFoldable};\n use rustc::ty::adjustment::{Adjustment, Adjust, OverloadedDeref};\n \n use syntax_pos::Span;\n-use syntax::symbol::Symbol;\n+use syntax::ast::Ident;\n \n use std::iter;\n \n@@ -134,7 +134,7 @@ impl<'a, 'gcx, 'tcx> Autoderef<'a, 'gcx, 'tcx> {\n                                                               ty::ProjectionTy::from_ref_and_name(\n                                                                   tcx,\n                                                                   trait_ref,\n-                                                                  Symbol::intern(\"Target\"),\n+                                                                  Ident::from_str(\"Target\"),\n                                                               ),\n                                                               cause,\n                                                               0,"}, {"sha": "383820a62bffe4e849b62c6c21efe64c517fb1f9", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -18,7 +18,7 @@ use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, TypeFoldable, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_target::spec::abi;\n-use syntax::symbol::Symbol;\n+use syntax::ast::Ident;\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -157,9 +157,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name, borrow) in\n-            &[(self.tcx.lang_items().fn_trait(), Symbol::intern(\"call\"), true),\n-              (self.tcx.lang_items().fn_mut_trait(), Symbol::intern(\"call_mut\"), true),\n-              (self.tcx.lang_items().fn_once_trait(), Symbol::intern(\"call_once\"), false)] {\n+            &[(self.tcx.lang_items().fn_trait(), Ident::from_str(\"call\"), true),\n+              (self.tcx.lang_items().fn_mut_trait(), Ident::from_str(\"call_mut\"), true),\n+              (self.tcx.lang_items().fn_once_trait(), Ident::from_str(\"call_once\"), false)] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,"}, {"sha": "04c11d30d26791b10f81f88f64746953156a49ff", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -100,7 +100,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         span: impl_m_span,\n         body_id: impl_m_node_id,\n         code: ObligationCauseCode::CompareImplMethodObligation {\n-            item_name: impl_m.name,\n+            item_name: impl_m.ident.name,\n             impl_item_def_id: impl_m.def_id,\n             trait_item_def_id: trait_m.def_id,\n         },\n@@ -318,7 +318,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             cause.span(&tcx),\n                                             E0053,\n                                             \"method `{}` has an incompatible type for trait\",\n-                                            trait_m.name);\n+                                            trait_m.ident);\n \n             infcx.note_type_err(&mut diag,\n                                 &cause,\n@@ -383,7 +383,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        E0195,\n                                        \"lifetime parameters or bounds on method `{}` do not match \\\n                                         the trait declaration\",\n-                                       impl_m.name);\n+                                       impl_m.ident);\n         err.span_label(span, \"lifetimes do not match method in trait\");\n         if let Some(sp) = tcx.hir.span_if_local(trait_m.def_id) {\n             err.span_label(tcx.sess.codemap().def_span(sp),\n@@ -529,13 +529,13 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            E0185,\n                                            \"method `{}` has a `{}` declaration in the impl, but \\\n                                             not in the trait\",\n-                                           trait_m.name,\n+                                           trait_m.ident,\n                                            self_descr);\n             err.span_label(impl_m_span, format!(\"`{}` used in impl\", self_descr));\n             if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n                 err.span_label(span, format!(\"trait method declared without `{}`\", self_descr));\n             } else {\n-                err.note_trait_signature(trait_m.name.to_string(),\n+                err.note_trait_signature(trait_m.ident.to_string(),\n                                          trait_m.signature(&tcx));\n             }\n             err.emit();\n@@ -549,13 +549,13 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            E0186,\n                                            \"method `{}` has a `{}` declaration in the trait, but \\\n                                             not in the impl\",\n-                                           trait_m.name,\n+                                           trait_m.ident,\n                                            self_descr);\n             err.span_label(impl_m_span, format!(\"expected `{}` in impl\", self_descr));\n             if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n                 err.span_label(span, format!(\"`{}` used in trait\", self_descr));\n             } else {\n-                err.note_trait_signature(trait_m.name.to_string(),\n+                err.note_trait_signature(trait_m.ident.to_string(),\n                                          trait_m.signature(&tcx));\n             }\n             err.emit();\n@@ -590,7 +590,7 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        E0049,\n                                        \"method `{}` has {} type parameter{} but its trait \\\n                                         declaration has {} type parameter{}\",\n-                                       trait_m.name,\n+                                       trait_m.ident,\n                                        num_impl_m_type_params,\n                                        if num_impl_m_type_params == 1 { \"\" } else { \"s\" },\n                                        num_trait_m_type_params,\n@@ -681,7 +681,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        E0050,\n                                        \"method `{}` has {} parameter{} but the declaration in \\\n                                         trait `{}` has {}\",\n-                                       trait_m.name,\n+                                       trait_m.ident,\n                                        impl_number_args,\n                                        if impl_number_args == 1 { \"\" } else { \"s\" },\n                                        tcx.item_path_str(trait_m.def_id),\n@@ -695,7 +695,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         format!(\"{} parameter\", trait_number_args)\n                                     }));\n         } else {\n-            err.note_trait_signature(trait_m.name.to_string(),\n+            err.note_trait_signature(trait_m.ident.to_string(),\n                                      trait_m.signature(&tcx));\n         }\n         err.span_label(impl_span,\n@@ -748,7 +748,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            impl_span,\n                                            E0643,\n                                            \"method `{}` has incompatible signature for trait\",\n-                                           trait_m.name);\n+                                           trait_m.ident);\n             err.span_label(trait_span, \"declaration in trait here\");\n             match (impl_synthetic, trait_synthetic) {\n                 // The case where the impl method uses `impl Trait` but the trait method uses\n@@ -948,7 +948,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             E0326,\n                                             \"implemented const `{}` has an incompatible type for \\\n                                              trait\",\n-                                            trait_c.name);\n+                                            trait_c.ident);\n \n             let trait_c_node_id = tcx.hir.as_local_node_id(trait_c.def_id);\n             let trait_c_span = trait_c_node_id.map(|trait_c_node_id| {"}, {"sha": "8582eb3fbd87cf2fb230bd96b3c078ad4ea4918f", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let methods = self.get_conversion_methods(expr.span, expected, checked_ty);\n             if let Ok(expr_text) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n                 let suggestions = iter::repeat(expr_text).zip(methods.iter())\n-                    .map(|(receiver, method)| format!(\"{}.{}()\", receiver, method.name))\n+                    .map(|(receiver, method)| format!(\"{}.{}()\", receiver, method.ident))\n                     .collect::<Vec<_>>();\n                 if !suggestions.is_empty() {\n                     err.span_suggestions(expr.span,\n@@ -226,7 +226,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                     })), 1) = (self.tcx.hir.find(parent), decl.inputs.len()) {\n                         let self_ty = self.tables.borrow().node_id_to_type(expr[0].hir_id);\n                         let self_ty = format!(\"{:?}\", self_ty);\n-                        let name = path.name.as_str();\n+                        let name = path.ident.as_str();\n                         let is_as_ref_able = (\n                             self_ty.starts_with(\"&std::option::Option\") ||\n                             self_ty.starts_with(\"&std::result::Result\") ||"}, {"sha": "04c32fa88271ad24c7a4c45bafeac4c63c222951", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -120,7 +120,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          allow_private: bool)\n                          -> bool {\n         let mode = probe::Mode::MethodCall;\n-        match self.probe_for_name(method_name.span, mode, method_name.name,\n+        match self.probe_for_name(method_name.span, mode, method_name,\n                                   IsSuggestion(false), self_ty, call_expr_id,\n                                   ProbeScope::TraitsInScope) {\n             Ok(..) => true,\n@@ -157,14 +157,14 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                          self_expr: &'gcx hir::Expr)\n                          -> Result<MethodCallee<'tcx>, MethodError<'tcx>> {\n         debug!(\"lookup(method_name={}, self_ty={:?}, call_expr={:?}, self_expr={:?})\",\n-               segment.name,\n+               segment.ident,\n                self_ty,\n                call_expr,\n                self_expr);\n \n         let pick = self.lookup_probe(\n             span,\n-            segment.name,\n+            segment.ident,\n             self_ty,\n             call_expr,\n             ProbeScope::TraitsInScope\n@@ -192,7 +192,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // We probe again, taking all traits into account (not only those in scope).\n             let candidates =\n                 match self.lookup_probe(span,\n-                                        segment.name,\n+                                        segment.ident,\n                                         self_ty,\n                                         call_expr,\n                                         ProbeScope::AllTraits) {\n@@ -222,7 +222,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn lookup_probe(&self,\n                     span: Span,\n-                    method_name: ast::Name,\n+                    method_name: ast::Ident,\n                     self_ty: Ty<'tcx>,\n                     call_expr: &'gcx hir::Expr,\n                     scope: ProbeScope)\n@@ -244,7 +244,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// of this method is basically the same as confirmation.\n     pub fn lookup_method_in_trait(&self,\n                                   span: Span,\n-                                  m_name: ast::Name,\n+                                  m_name: ast::Ident,\n                                   trait_def_id: DefId,\n                                   self_ty: Ty<'tcx>,\n                                   opt_input_types: Option<&[Ty<'tcx>]>)\n@@ -289,7 +289,8 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // Trait must have a method named `m_name` and it should not have\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n-        let method_item = self.associated_item(trait_def_id, m_name, Namespace::Value).unwrap();\n+        let method_item =\n+            self.associated_item(trait_def_id, m_name, Namespace::Value).unwrap();\n         let def_id = method_item.def_id;\n         let generics = tcx.generics_of(def_id);\n         assert_eq!(generics.params.len(), 0);\n@@ -362,7 +363,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn resolve_ufcs(&self,\n                         span: Span,\n-                        method_name: ast::Name,\n+                        method_name: ast::Ident,\n                         self_ty: Ty<'tcx>,\n                         expr_id: ast::NodeId)\n                         -> Result<Def, MethodError<'tcx>> {\n@@ -385,10 +386,11 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     /// Find item with name `item_name` defined in impl/trait `def_id`\n     /// and return it, or `None`, if no such item was defined there.\n-    pub fn associated_item(&self, def_id: DefId, item_name: ast::Name, ns: Namespace)\n+    pub fn associated_item(&self, def_id: DefId, item_name: ast::Ident, ns: Namespace)\n                            -> Option<ty::AssociatedItem> {\n-        self.tcx.associated_items(def_id)\n-                .find(|item| Namespace::from(item.kind) == ns &&\n-                             self.tcx.hygienic_eq(item_name, item.name, def_id))\n+        self.tcx.associated_items(def_id).find(|item| {\n+            Namespace::from(item.kind) == ns &&\n+            self.tcx.hygienic_eq(item_name, item.ident, def_id)\n+        })\n     }\n }"}, {"sha": "0aff322a29a6debf58dbfeea5b82b86f0d1e80fa", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -47,7 +47,7 @@ struct ProbeContext<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n     span: Span,\n     mode: Mode,\n-    method_name: Option<ast::Name>,\n+    method_name: Option<ast::Ident>,\n     return_type: Option<Ty<'tcx>>,\n     steps: Rc<Vec<CandidateStep<'tcx>>>,\n     inherent_candidates: Vec<Candidate<'tcx>>,\n@@ -213,7 +213,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn probe_for_name(&self,\n                           span: Span,\n                           mode: Mode,\n-                          item_name: ast::Name,\n+                          item_name: ast::Ident,\n                           is_suggestion: IsSuggestion,\n                           self_ty: Ty<'tcx>,\n                           scope_expr_id: ast::NodeId,\n@@ -237,7 +237,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     fn probe_op<OP,R>(&'a self,\n                       span: Span,\n                       mode: Mode,\n-                      method_name: Option<ast::Name>,\n+                      method_name: Option<ast::Ident>,\n                       return_type: Option<Ty<'tcx>>,\n                       is_suggestion: IsSuggestion,\n                       self_ty: Ty<'tcx>,\n@@ -382,7 +382,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     fn new(fcx: &'a FnCtxt<'a, 'gcx, 'tcx>,\n            span: Span,\n            mode: Mode,\n-           method_name: Option<ast::Name>,\n+           method_name: Option<ast::Ident>,\n            return_type: Option<Ty<'tcx>>,\n            steps: Rc<Vec<CandidateStep<'tcx>>>,\n            is_suggestion: IsSuggestion)\n@@ -422,8 +422,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     {\n         let is_accessible = if let Some(name) = self.method_name {\n             let item = candidate.item;\n-            let def_scope =\n-                self.tcx.adjust_ident(name.to_ident(), item.container.id(), self.body_id).1;\n+            let def_scope = self.tcx.adjust_ident(name, item.container.id(), self.body_id).1;\n             item.vis.is_accessible_from(def_scope, self.tcx)\n         } else {\n             true\n@@ -799,7 +798,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    fn candidate_method_names(&self) -> Vec<ast::Name> {\n+    fn candidate_method_names(&self) -> Vec<ast::Ident> {\n         let mut set = FxHashSet();\n         let mut names: Vec<_> = self.inherent_candidates\n             .iter()\n@@ -811,7 +810,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     true\n                 }\n             })\n-            .map(|candidate| candidate.item.name)\n+            .map(|candidate| candidate.item.ident)\n             .filter(|&name| set.insert(name))\n             .collect();\n \n@@ -1310,14 +1309,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 Ok(None)\n             } else {\n                 let best_name = {\n-                    let names = applicable_close_candidates.iter().map(|cand| &cand.name);\n+                    let names = applicable_close_candidates.iter().map(|cand| &cand.ident.name);\n                     find_best_match_for_name(names,\n                                              &self.method_name.unwrap().as_str(),\n                                              None)\n                 }.unwrap();\n                 Ok(applicable_close_candidates\n                    .into_iter()\n-                   .find(|method| method.name == best_name))\n+                   .find(|method| method.ident.name == best_name))\n             }\n         })\n     }\n@@ -1457,7 +1456,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let max_dist = max(name.as_str().len(), 3) / 3;\n                 self.tcx.associated_items(def_id)\n                     .filter(|x| {\n-                        let dist = lev_distance(&*name.as_str(), &x.name.as_str());\n+                        let dist = lev_distance(&*name.as_str(), &x.ident.as_str());\n                         Namespace::from(x.kind) == Namespace::Value && dist > 0\n                         && dist <= max_dist\n                     })"}, {"sha": "35d237d94de8251a12a5a3295d31f43ab507a019", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -77,7 +77,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn report_method_error(&self,\n                                span: Span,\n                                rcvr_ty: Ty<'tcx>,\n-                               item_name: ast::Name,\n+                               item_name: ast::Ident,\n                                rcvr_expr: Option<&hir::Expr>,\n                                error: MethodError<'tcx>,\n                                args: Option<&'gcx [hir::Expr]>) {\n@@ -340,8 +340,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         match ty.sty {\n                             ty::TyAdt(def, substs) if !def.is_enum() => {\n                                 let variant = &def.non_enum_variant();\n-                                if let Some(index) =\n-                                        self.tcx.find_field_index(item_name.to_ident(), variant) {\n+                                if let Some(index) = self.tcx.find_field_index(item_name, variant) {\n                                     let field = &variant.fields[index];\n                                     let snippet = tcx.sess.codemap().span_to_snippet(expr.span);\n                                     let expr_string = match snippet {\n@@ -393,7 +392,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                             report_function!(expr.span, expr_string);\n                         } else if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = expr.node {\n                             if let Some(segment) = path.segments.last() {\n-                                report_function!(expr.span, segment.name);\n+                                report_function!(expr.span, segment.ident);\n                             }\n                         }\n                     }\n@@ -445,7 +444,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(lev_candidate) = lev_candidate {\n-                    err.help(&format!(\"did you mean `{}`?\", lev_candidate.name));\n+                    err.help(&format!(\"did you mean `{}`?\", lev_candidate.ident));\n                 }\n                 err.emit();\n             }\n@@ -565,7 +564,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 err: &mut DiagnosticBuilder,\n                                 span: Span,\n                                 rcvr_ty: Ty<'tcx>,\n-                                item_name: ast::Name,\n+                                item_name: ast::Ident,\n                                 rcvr_expr: Option<&hir::Expr>,\n                                 valid_out_of_scope_traits: Vec<DefId>) {\n         if self.suggest_valid_traits(err, valid_out_of_scope_traits) {"}, {"sha": "f8c4bfc9ad723ab3f88d72abbe9a677b0a74b1b8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -960,14 +960,14 @@ impl<'a, 'gcx, 'tcx> Visitor<'gcx> for GatherLocalsVisitor<'a, 'gcx, 'tcx> {\n \n     // Add pattern bindings.\n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n-        if let PatKind::Binding(_, _, ref path1, _) = p.node {\n+        if let PatKind::Binding(_, _, ident, _) = p.node {\n             let var_ty = self.assign(p.span, p.id, None);\n \n             self.fcx.require_type_is_sized(var_ty, p.span,\n                                            traits::VariableType(p.id));\n \n             debug!(\"Pattern binding {} is assigned to {} with type {:?}\",\n-                   path1.node,\n+                   ident,\n                    self.fcx.ty_to_string(\n                        self.fcx.locals.borrow().get(&p.id).unwrap().clone()),\n                    var_ty);\n@@ -1050,7 +1050,7 @@ fn check_fn<'a, 'gcx, 'tcx>(inherited: &'a Inherited<'a, 'gcx, 'tcx>,\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n         // for simple cases like `fn foo(x: Trait)`,\n         // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if arg.pat.simple_name().is_none() {\n+        if arg.pat.simple_ident().is_none() {\n             fcx.require_type_is_sized(arg_ty, decl.output.span(), traits::MiscObligation);\n         }\n \n@@ -1333,15 +1333,15 @@ fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.sess, impl_item.span, E0520,\n         \"`{}` specializes an item from a parent `impl`, but \\\n          that item is not marked `default`\",\n-        impl_item.name);\n+        impl_item.ident);\n     err.span_label(impl_item.span, format!(\"cannot specialize default item `{}`\",\n-                                            impl_item.name));\n+                                            impl_item.ident));\n \n     match tcx.span_of_impl(parent_impl) {\n         Ok(span) => {\n             err.span_label(span, \"parent `impl` is here\");\n             err.note(&format!(\"to specialize, `{}` in the parent `impl` must be marked `default`\",\n-                              impl_item.name));\n+                              impl_item.ident));\n         }\n         Err(cname) => {\n             err.note(&format!(\"parent implementation is in crate `{}`\", cname));\n@@ -1365,7 +1365,7 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         hir::ImplItemKind::Type(_) => ty::AssociatedKind::Type\n     };\n \n-    let parent = ancestors.defs(tcx, trait_item.name, kind, trait_def.def_id).skip(1).next()\n+    let parent = ancestors.defs(tcx, trait_item.ident, kind, trait_def.def_id).skip(1).next()\n         .map(|node_item| node_item.map(|parent| parent.defaultness));\n \n     if let Some(parent) = parent {\n@@ -1400,11 +1400,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let ty_impl_item = tcx.associated_item(tcx.hir.local_def_id(impl_item.id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n             .find(|ac| Namespace::from(&impl_item.node) == Namespace::from(ac.kind) &&\n-                         tcx.hygienic_eq(ty_impl_item.name, ac.name, impl_trait_ref.def_id))\n+                       tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id))\n             .or_else(|| {\n                 // Not compatible, but needed for the error message\n                 tcx.associated_items(impl_trait_ref.def_id)\n-                   .find(|ac| tcx.hygienic_eq(ty_impl_item.name, ac.name, impl_trait_ref.def_id))\n+                   .find(|ac| tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id))\n             });\n \n         // Check that impl definition matches trait definition\n@@ -1422,7 +1422,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          let mut err = struct_span_err!(tcx.sess, impl_item.span, E0323,\n                                   \"item `{}` is an associated const, \\\n                                   which doesn't match its trait `{}`\",\n-                                  ty_impl_item.name,\n+                                  ty_impl_item.ident,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          // We can only get the spans from local trait definition\n@@ -1446,7 +1446,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                                   \"item `{}` is an associated method, \\\n                                   which doesn't match its trait `{}`\",\n-                                  ty_impl_item.name,\n+                                  ty_impl_item.ident,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n@@ -1464,7 +1464,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0325,\n                                   \"item `{}` is an associated type, \\\n                                   which doesn't match its trait `{}`\",\n-                                  ty_impl_item.name,\n+                                  ty_impl_item.ident,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n@@ -1485,7 +1485,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let associated_type_overridden = overridden_associated_type.is_some();\n     for trait_item in tcx.associated_items(impl_trait_ref.def_id) {\n         let is_implemented = trait_def.ancestors(tcx, impl_id)\n-            .defs(tcx, trait_item.name, trait_item.kind, impl_trait_ref.def_id)\n+            .defs(tcx, trait_item.ident, trait_item.kind, impl_trait_ref.def_id)\n             .next()\n             .map(|node_item| !node_item.node.is_from_trait())\n             .unwrap_or(false);\n@@ -1494,7 +1494,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if !trait_item.defaultness.has_value() {\n                 missing_items.push(trait_item);\n             } else if associated_type_overridden {\n-                invalidated_items.push(trait_item.name);\n+                invalidated_items.push(trait_item.ident);\n             }\n         }\n     }\n@@ -1503,17 +1503,17 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut err = struct_span_err!(tcx.sess, impl_span, E0046,\n             \"not all trait items implemented, missing: `{}`\",\n             missing_items.iter()\n-                  .map(|trait_item| trait_item.name.to_string())\n+                  .map(|trait_item| trait_item.ident.to_string())\n                   .collect::<Vec<_>>().join(\"`, `\"));\n         err.span_label(impl_span, format!(\"missing `{}` in implementation\",\n                 missing_items.iter()\n-                    .map(|trait_item| trait_item.name.to_string())\n+                    .map(|trait_item| trait_item.ident.to_string())\n                     .collect::<Vec<_>>().join(\"`, `\")));\n         for trait_item in missing_items {\n             if let Some(span) = tcx.hir.span_if_local(trait_item.def_id) {\n-                err.span_label(span, format!(\"`{}` from trait\", trait_item.name));\n+                err.span_label(span, format!(\"`{}` from trait\", trait_item.ident));\n             } else {\n-                err.note_trait_signature(trait_item.name.to_string(),\n+                err.note_trait_signature(trait_item.ident.to_string(),\n                                          trait_item.signature(&tcx));\n             }\n         }\n@@ -1525,7 +1525,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         span_err!(tcx.sess, invalidator.span, E0399,\n                   \"the following trait items need to be reimplemented \\\n                    as `{}` was overridden: `{}`\",\n-                  invalidator.name,\n+                  invalidator.ident,\n                   invalidated_items.iter()\n                                    .map(|name| name.to_string())\n                                    .collect::<Vec<_>>().join(\"`, `\"))\n@@ -2468,7 +2468,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n+    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, ast::Ident) {\n         let (tr, name) = match (op, is_mut) {\n             (PlaceOp::Deref, false) =>\n                 (self.tcx.lang_items().deref_trait(), \"deref\"),\n@@ -2479,7 +2479,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (PlaceOp::Index, true) =>\n                 (self.tcx.lang_items().index_mut_trait(), \"index_mut\"),\n         };\n-        (tr, Symbol::intern(name))\n+        (tr, ast::Ident::from_str(name))\n     }\n \n     fn try_overloaded_place_op(&self,\n@@ -3004,10 +3004,10 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 Ok(method)\n             }\n             Err(error) => {\n-                if segment.name != keywords::Invalid.name() {\n+                if segment.ident.name != keywords::Invalid.name() {\n                     self.report_method_error(span,\n                                              rcvr_t,\n-                                             segment.name,\n+                                             segment.ident,\n                                              Some(rcvr),\n                                              error,\n                                              Some(args));\n@@ -3836,7 +3836,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         // ... except when we try to 'break rust;'.\n                         // ICE this expression in particular (see #43162).\n                         if let hir::ExprPath(hir::QPath::Resolved(_, ref path)) = e.node {\n-                            if path.segments.len() == 1 && path.segments[0].name == \"rust\" {\n+                            if path.segments.len() == 1 && path.segments[0].ident.name == \"rust\" {\n                                 fatally_break_rust(self.tcx.sess);\n                             }\n                         }\n@@ -4252,15 +4252,15 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             // errors with default match binding modes. See #44614.\n             return (*cached_def, Some(ty), slice::from_ref(&**item_segment))\n         }\n-        let item_name = item_segment.name;\n+        let item_name = item_segment.ident;\n         let def = match self.resolve_ufcs(span, item_name, ty, node_id) {\n             Ok(def) => def,\n             Err(error) => {\n                 let def = match error {\n                     method::MethodError::PrivateMatch(def, _) => def,\n                     _ => Def::Err,\n                 };\n-                if item_name != keywords::Invalid.name() {\n+                if item_name.name != keywords::Invalid.name() {\n                     self.report_method_error(span, ty, item_name, None, error, None);\n                 }\n                 def"}, {"sha": "0a33252d4cd01b27f727dee3217b3c34099b022e", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoB\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n use syntax_pos::Span;\n-use syntax::symbol::Symbol;\n+use syntax::ast::Ident;\n use rustc::hir;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -564,7 +564,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                trait_did);\n \n         let method = trait_did.and_then(|trait_did| {\n-            let opname = Symbol::intern(opname);\n+            let opname = Ident::from_str(opname);\n             self.lookup_method_in_trait(span, opname, trait_did, lhs_ty, Some(other_tys))\n         });\n "}, {"sha": "be42549df74a32ba816217ec314930619b7fe6d2", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -632,7 +632,7 @@ fn check_variances_for_type_defn<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         }\n \n         let param = &hir_generics.params[index];\n-        report_bivariance(tcx, param.span, param.name.name());\n+        report_bivariance(tcx, param.span, param.name.ident().name);\n     }\n }\n "}, {"sha": "6a346b02b7943f4596a0521b06d5bf4452dec3da", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         let name_and_namespace = |def_id| {\n             let item = self.tcx.associated_item(def_id);\n-            (item.name, Namespace::from(item.kind))\n+            (item.ident, Namespace::from(item.kind))\n         };\n \n         let impl_items1 = self.tcx.associated_item_def_ids(impl1);"}, {"sha": "852603ac51c35deb24fa8b580a0227c4a91844cb", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -898,7 +898,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n     params.extend(early_lifetimes.enumerate().map(|(i, param)| {\n         ty::GenericParamDef {\n-            name: param.name.name().as_interned_str(),\n+            name: param.name.ident().as_interned_str(),\n             index: own_start + i as u32,\n             def_id: tcx.hir.local_def_id(param.id),\n             pure_wrt_drop: param.pure_wrt_drop,\n@@ -914,7 +914,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut i = 0;\n     params.extend(ast_generics.params.iter().filter_map(|param| match param.kind {\n         GenericParamKind::Type { ref default, synthetic, .. } => {\n-            if param.name.name() == keywords::SelfType.name() {\n+            if param.name.ident().name == keywords::SelfType.name() {\n                 span_bug!(param.span,  \"`Self` should not be the name of a regular parameter\");\n             }\n \n@@ -931,7 +931,7 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             let ty_param = ty::GenericParamDef {\n                 index: type_start + i as u32,\n-                name: param.name.name().as_interned_str(),\n+                name: param.name.ident().as_interned_str(),\n                 def_id: tcx.hir.local_def_id(param.id),\n                 pure_wrt_drop: param.pure_wrt_drop,\n                 kind: ty::GenericParamDefKind::Type {\n@@ -1437,7 +1437,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n             def_id: tcx.hir.local_def_id(param.id),\n             index,\n-            name: param.name.name().as_interned_str(),\n+            name: param.name.ident().as_interned_str(),\n         }));\n         index += 1;\n \n@@ -1461,7 +1461,7 @@ pub fn explicit_predicates_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for param in &ast_generics.params {\n         match param.kind {\n             GenericParamKind::Type { .. } => {\n-                let name = param.name.name().as_interned_str();\n+                let name = param.name.ident().as_interned_str();\n                 let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n                 index += 1;\n "}, {"sha": "b57bb1fccfb5781f6f0ef90b518ea276cef98a78", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -184,14 +184,14 @@ fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             hir::ImplItemKind::Type(_) => &mut seen_type_items,\n             _                    => &mut seen_value_items,\n         };\n-        match seen_items.entry(impl_item.name) {\n+        match seen_items.entry(impl_item.ident.modern()) {\n             Occupied(entry) => {\n                 let mut err = struct_span_err!(tcx.sess, impl_item.span, E0201,\n                                                \"duplicate definitions with name `{}`:\",\n-                                               impl_item.name);\n+                                               impl_item.ident);\n                 err.span_label(*entry.get(),\n                                format!(\"previous definition of `{}` here\",\n-                                        impl_item.name));\n+                                        impl_item.ident));\n                 err.span_label(impl_item.span, \"duplicate definition\");\n                 err.emit();\n             }"}, {"sha": "527aef80a8d9dcf26e736323fbc62e55a9eff146", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -200,10 +200,10 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             let mut segments = path.segments.into_vec();\n             let last = segments.pop().unwrap();\n \n-            let real_name = name.map(|name| Symbol::intern(&name));\n+            let real_name = name.map(|name| Ident::from_str(&name));\n \n             segments.push(hir::PathSegment::new(\n-                real_name.unwrap_or(last.name),\n+                real_name.unwrap_or(last.ident),\n                 self.generics_to_path_params(generics.clone()),\n                 false,\n             ));\n@@ -251,9 +251,9 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n             match param.kind {\n                 ty::GenericParamDefKind::Lifetime => {\n                     let name = if param.name == \"\" {\n-                        hir::ParamName::Plain(keywords::StaticLifetime.name())\n+                        hir::ParamName::Plain(keywords::StaticLifetime.ident())\n                     } else {\n-                        hir::ParamName::Plain(param.name.as_symbol())\n+                        hir::ParamName::Plain(ast::Ident::from_interned_str(param.name))\n                     };\n \n                     args.push(hir::GenericArg::Lifetime(hir::Lifetime {\n@@ -285,7 +285,7 @@ impl<'a, 'tcx, 'rcx> AutoTraitFinder<'a, 'tcx, 'rcx> {\n                     span: DUMMY_SP,\n                     def: Def::TyParam(param.def_id),\n                     segments: HirVec::from_vec(vec![\n-                        hir::PathSegment::from_name(param.name.as_symbol())\n+                        hir::PathSegment::from_ident(Ident::from_interned_str(param.name))\n                     ]),\n                 }),\n             )),"}, {"sha": "7677ccf8bf40c4ffd2007e71c69ef0d38a10a483", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -391,7 +391,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n     let provided = trait_.def_id().map(|did| {\n         tcx.provided_trait_methods(did)\n            .into_iter()\n-           .map(|meth| meth.name.to_string())\n+           .map(|meth| meth.ident.to_string())\n            .collect()\n     }).unwrap_or(FxHashSet());\n "}, {"sha": "e9f8aeb9ec8c53b8bf98fd56722a550ed06bb3bb", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -1146,7 +1146,7 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n             Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n                 let item = cx.tcx.inherent_impls(did).iter()\n                                  .flat_map(|imp| cx.tcx.associated_items(*imp))\n-                                 .find(|item| item.name == item_name);\n+                                 .find(|item| item.ident.name == item_name);\n                 if let Some(item) = item {\n                     let out = match item.kind {\n                         ty::AssociatedKind::Method if is_val => \"method\",\n@@ -1181,7 +1181,7 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n             Def::Trait(did) => {\n                 let item = cx.tcx.associated_item_def_ids(did).iter()\n                              .map(|item| cx.tcx.associated_item(*item))\n-                             .find(|item| item.name == item_name);\n+                             .find(|item| item.ident.name == item_name);\n                 if let Some(item) = item {\n                     let kind = match item.kind {\n                         ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n@@ -1664,7 +1664,7 @@ impl Clean<Lifetime> for hir::Lifetime {\n                 _ => {}\n             }\n         }\n-        Lifetime(self.name.name().to_string())\n+        Lifetime(self.name.ident().to_string())\n     }\n }\n \n@@ -1677,14 +1677,14 @@ impl Clean<Lifetime> for hir::GenericParam {\n                         hir::GenericBound::Outlives(lt) => lt,\n                         _ => panic!(),\n                     });\n-                    let name = bounds.next().unwrap().name.name();\n-                    let mut s = format!(\"{}: {}\", self.name.name(), name);\n+                    let name = bounds.next().unwrap().name.ident();\n+                    let mut s = format!(\"{}: {}\", self.name.ident(), name);\n                     for bound in bounds {\n-                        s.push_str(&format!(\" + {}\", bound.name.name()));\n+                        s.push_str(&format!(\" + {}\", bound.name.ident()));\n                     }\n                     Lifetime(s)\n                 } else {\n-                    Lifetime(self.name.name().to_string())\n+                    Lifetime(self.name.ident().to_string())\n                 }\n             }\n             _ => panic!(),\n@@ -1823,7 +1823,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n             GenericBound::Outlives(_) => panic!(\"cleaning a trait got a lifetime\"),\n         };\n         Type::QPath {\n-            name: cx.tcx.associated_item(self.item_def_id).name.clean(cx),\n+            name: cx.tcx.associated_item(self.item_def_id).ident.name.clean(cx),\n             self_type: box self.self_ty().clean(cx),\n             trait_: box trait_\n         }\n@@ -1896,19 +1896,19 @@ impl Clean<GenericParamDef> for hir::GenericParam {\n                         hir::GenericBound::Outlives(lt) => lt,\n                         _ => panic!(),\n                     });\n-                    let name = bounds.next().unwrap().name.name();\n-                    let mut s = format!(\"{}: {}\", self.name.name(), name);\n+                    let name = bounds.next().unwrap().name.ident();\n+                    let mut s = format!(\"{}: {}\", self.name.ident(), name);\n                     for bound in bounds {\n-                        s.push_str(&format!(\" + {}\", bound.name.name()));\n+                        s.push_str(&format!(\" + {}\", bound.name.ident()));\n                     }\n                     s\n                 } else {\n-                    self.name.name().to_string()\n+                    self.name.ident().to_string()\n                 };\n                 (name, GenericParamDefKind::Lifetime)\n             }\n             hir::GenericParamKind::Type { ref default, synthetic, .. } => {\n-                (self.name.name().clean(cx), GenericParamDefKind::Type {\n+                (self.name.ident().name.clean(cx), GenericParamDefKind::Type {\n                     did: cx.tcx.hir.local_def_id(self.id),\n                     bounds: self.bounds.clean(cx),\n                     default: default.clean(cx),\n@@ -2150,11 +2150,11 @@ pub struct Arguments {\n     pub values: Vec<Argument>,\n }\n \n-impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [Spanned<ast::Name>]) {\n+impl<'a> Clean<Arguments> for (&'a [hir::Ty], &'a [ast::Ident]) {\n     fn clean(&self, cx: &DocContext) -> Arguments {\n         Arguments {\n             values: self.0.iter().enumerate().map(|(i, ty)| {\n-                let mut name = self.1.get(i).map(|n| n.node.to_string())\n+                let mut name = self.1.get(i).map(|ident| ident.to_string())\n                                             .unwrap_or(String::new());\n                 if name.is_empty() {\n                     name = \"_\".to_string();\n@@ -2360,7 +2360,7 @@ impl Clean<Item> for hir::TraitItem {\n             }\n         };\n         Item {\n-            name: Some(self.name.clean(cx)),\n+            name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir.local_def_id(self.id),\n@@ -2388,7 +2388,7 @@ impl Clean<Item> for hir::ImplItem {\n             }, true),\n         };\n         Item {\n-            name: Some(self.name.clean(cx)),\n+            name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n             def_id: cx.tcx.hir.local_def_id(self.id),\n@@ -2474,7 +2474,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 }\n             }\n             ty::AssociatedKind::Type => {\n-                let my_name = self.name.clean(cx);\n+                let my_name = self.ident.name.clean(cx);\n \n                 if let ty::TraitContainer(did) = self.container {\n                     // When loading a cross-crate associated type, the bounds for this type\n@@ -2537,7 +2537,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n         };\n \n         Item {\n-            name: Some(self.name.clean(cx)),\n+            name: Some(self.ident.name.clean(cx)),\n             visibility,\n             stability: get_stability(cx, self.def_id),\n             deprecation: get_deprecation(cx, self.def_id),\n@@ -2949,7 +2949,7 @@ impl Clean<Type> for hir::Ty {\n                     segments: segments.into(),\n                 };\n                 Type::QPath {\n-                    name: p.segments.last().unwrap().name.clean(cx),\n+                    name: p.segments.last().unwrap().ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n@@ -2966,7 +2966,7 @@ impl Clean<Type> for hir::Ty {\n                     segments: vec![].into(),\n                 };\n                 Type::QPath {\n-                    name: segment.name.clean(cx),\n+                    name: segment.ident.name.clean(cx),\n                     self_type: box qself.clean(cx),\n                     trait_: box resolve_type(cx, trait_path.clean(cx), self.id)\n                 }\n@@ -3099,7 +3099,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     let mut bindings = vec![];\n                     for pb in obj.projection_bounds() {\n                         bindings.push(TypeBinding {\n-                            name: cx.tcx.associated_item(pb.item_def_id()).name.clean(cx),\n+                            name: cx.tcx.associated_item(pb.item_def_id()).ident.name.clean(cx),\n                             ty: pb.skip_binder().ty.clean(cx)\n                         });\n                     }\n@@ -3156,7 +3156,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             if proj.projection_ty.trait_ref(cx.tcx) == *trait_ref.skip_binder() {\n                                 Some(TypeBinding {\n                                     name: cx.tcx.associated_item(proj.projection_ty.item_def_id)\n-                                                .name.clean(cx),\n+                                                .ident.name.clean(cx),\n                                     ty: proj.ty.clean(cx),\n                                 })\n                             } else {\n@@ -3575,7 +3575,7 @@ pub struct PathSegment {\n impl Clean<PathSegment> for hir::PathSegment {\n     fn clean(&self, cx: &DocContext) -> PathSegment {\n         PathSegment {\n-            name: self.name.clean(cx),\n+            name: self.ident.name.clean(cx),\n             args: self.with_generic_args(|generic_args| generic_args.clean(cx))\n         }\n     }\n@@ -3628,16 +3628,16 @@ fn strip_path(path: &Path) -> Path {\n fn qpath_to_string(p: &hir::QPath) -> String {\n     let segments = match *p {\n         hir::QPath::Resolved(_, ref path) => &path.segments,\n-        hir::QPath::TypeRelative(_, ref segment) => return segment.name.to_string(),\n+        hir::QPath::TypeRelative(_, ref segment) => return segment.ident.to_string(),\n     };\n \n     let mut s = String::new();\n     for (i, seg) in segments.iter().enumerate() {\n         if i > 0 {\n             s.push_str(\"::\");\n         }\n-        if seg.name != keywords::CrateRoot.name() {\n-            s.push_str(&*seg.name.as_str());\n+        if seg.ident.name != keywords::CrateRoot.name() {\n+            s.push_str(&*seg.ident.as_str());\n         }\n     }\n     s\n@@ -3823,7 +3823,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n         let provided = trait_.def_id().map(|did| {\n             cx.tcx.provided_trait_methods(did)\n                   .into_iter()\n-                  .map(|meth| meth.name.to_string())\n+                  .map(|meth| meth.ident.to_string())\n                   .collect()\n         }).unwrap_or(FxHashSet());\n \n@@ -4064,7 +4064,7 @@ fn name_from_pat(p: &hir::Pat) -> String {\n \n     match p.node {\n         PatKind::Wild => \"_\".to_string(),\n-        PatKind::Binding(_, _, ref p, _) => p.node.to_string(),\n+        PatKind::Binding(_, _, ident, _) => ident.to_string(),\n         PatKind::TupleStruct(ref p, ..) | PatKind::Path(ref p) => qpath_to_string(p),\n         PatKind::Struct(ref name, ref fields, etc) => {\n             format!(\"{} {{ {}{} }}\", qpath_to_string(name),\n@@ -4293,7 +4293,7 @@ pub struct TypeBinding {\n impl Clean<TypeBinding> for hir::TypeBinding {\n     fn clean(&self, cx: &DocContext) -> TypeBinding {\n         TypeBinding {\n-            name: self.name.clean(cx),\n+            name: self.ident.name.clean(cx),\n             ty: self.ty.clean(cx)\n         }\n     }\n@@ -4427,7 +4427,7 @@ where F: Fn(DefId) -> Def {\n         span: DUMMY_SP,\n         def: def_ctor(def_id),\n         segments: hir::HirVec::from_vec(apb.names.iter().map(|s| hir::PathSegment {\n-            name: ast::Name::intern(&s),\n+            ident: ast::Ident::from_str(&s),\n             args: None,\n             infer_types: false,\n         }).collect())"}, {"sha": "53032b9b98c5d79fa7305720637c76025a310071", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -718,13 +718,13 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     }\n \n     fn visit_trait_item(&mut self, item: &'hir hir::TraitItem) {\n-        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n             intravisit::walk_trait_item(this, item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, item: &'hir hir::ImplItem) {\n-        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n             intravisit::walk_impl_item(this, item);\n         });\n     }"}, {"sha": "faf2cf64e1d9f05aa374e6ed8b9e7b0ea90864be", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -7325,7 +7325,7 @@ impl<'a> Parser<'a> {\n             match self.token {\n                 token::Ident(ident, false) if ident.name == keywords::Underscore.name() => {\n                     self.bump(); // `_`\n-                    Ok(Some(Ident::new(ident.name.gensymed(), ident.span)))\n+                    Ok(Some(ident.gensym()))\n                 }\n                 _ => self.parse_ident().map(Some),\n             }"}, {"sha": "99d8b1b172d24505aaa6cc54c29a0d0c6774b306", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -18,7 +18,7 @@\n use GLOBALS;\n use Span;\n use edition::Edition;\n-use symbol::{Ident, Symbol};\n+use symbol::Symbol;\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::collections::HashMap;\n@@ -190,7 +190,6 @@ pub struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n     markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n-    gensym_to_ctxt: HashMap<Symbol, Span>,\n     default_edition: Edition,\n }\n \n@@ -211,7 +210,6 @@ impl HygieneData {\n                 modern: SyntaxContext(0),\n             }],\n             markings: HashMap::new(),\n-            gensym_to_ctxt: HashMap::new(),\n             default_edition: Edition::Edition2015,\n         }\n     }\n@@ -559,22 +557,3 @@ impl Decodable for SyntaxContext {\n         Ok(SyntaxContext::empty()) // FIXME(jseyfried) intercrate hygiene\n     }\n }\n-\n-impl Symbol {\n-    pub fn from_ident(ident: Ident) -> Symbol {\n-        HygieneData::with(|data| {\n-            let gensym = ident.name.gensymed();\n-            data.gensym_to_ctxt.insert(gensym, ident.span);\n-            gensym\n-        })\n-    }\n-\n-    pub fn to_ident(self) -> Ident {\n-        HygieneData::with(|data| {\n-            match data.gensym_to_ctxt.get(&self) {\n-                Some(&span) => Ident::new(self.interned(), span),\n-                None => Ident::with_empty_ctxt(self),\n-            }\n-        })\n-    }\n-}"}, {"sha": "bb64dad12085dfaa0e18e8674efef1a10c7c060d", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d84ad59710728c936edd7396e287d42f1e319cf1/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=d84ad59710728c936edd7396e287d42f1e319cf1", "patch": "@@ -59,6 +59,11 @@ impl Ident {\n         Ident::new(Symbol::intern(self.as_str().trim_left_matches('\\'')), self.span)\n     }\n \n+    /// \"Normalize\" ident for use in comparisons using \"item hygiene\".\n+    /// Identifiers with same string value become same if they came from the same \"modern\" macro\n+    /// (e.g. `macro` item, but not `macro_rules` item) and stay different if they came from\n+    /// different \"modern\" macros.\n+    /// Technically, this operation strips all non-opaque marks from ident's syntactic context.\n     pub fn modern(self) -> Ident {\n         Ident::new(self.name, self.span.modern())\n     }\n@@ -70,6 +75,10 @@ impl Ident {\n     pub fn as_str(self) -> LocalInternedString {\n         self.name.as_str()\n     }\n+\n+    pub fn as_interned_str(self) -> InternedString {\n+        self.name.as_interned_str()\n+    }\n }\n \n impl PartialEq for Ident {"}]}