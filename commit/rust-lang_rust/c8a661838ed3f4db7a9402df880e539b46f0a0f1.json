{"sha": "c8a661838ed3f4db7a9402df880e539b46f0a0f1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4YTY2MTgzOGVkM2Y0ZGI3YTk0MDJkZjg4MGU1MzliNDZmMGEwZjE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-09-05T09:46:50Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-09-06T20:48:57Z"}, "message": "enable slice patterns and enable building rustdoc", "tree": {"sha": "14de0503ef8d35e19ac153671c9d885ab3d7a103", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14de0503ef8d35e19ac153671c9d885ab3d7a103"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c8a661838ed3f4db7a9402df880e539b46f0a0f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c8a661838ed3f4db7a9402df880e539b46f0a0f1", "html_url": "https://github.com/rust-lang/rust/commit/c8a661838ed3f4db7a9402df880e539b46f0a0f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c8a661838ed3f4db7a9402df880e539b46f0a0f1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99f3bfc20c737a2d602cf396829d78c797c0fe0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/99f3bfc20c737a2d602cf396829d78c797c0fe0d", "html_url": "https://github.com/rust-lang/rust/commit/99f3bfc20c737a2d602cf396829d78c797c0fe0d"}], "stats": {"total": 316, "additions": 208, "deletions": 108}, "files": [{"sha": "9ede86937e8af5a47061465c2f69e3a512f2a95c", "filename": "mk/main.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c8a661838ed3f4db7a9402df880e539b46f0a0f1/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/c8a661838ed3f4db7a9402df880e539b46f0a0f1/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=c8a661838ed3f4db7a9402df880e539b46f0a0f1", "patch": "@@ -182,7 +182,7 @@ RUSTFLAGS2_$(1) += -Z always-build-mir\n endef\n $(foreach crate,$(TARGET_CRATES),$(eval $(call ADD_MIR_FLAG,$(crate))))\n $(foreach crate,$(RUSTC_CRATES),$(eval $(call ADD_MIR_FLAG,$(crate))))\n-$(foreach crate,syntax,$(eval $(call ADD_MIR_FLAG,$(crate))))\n+$(foreach crate,$(HOST_CRATES),$(eval $(call ADD_MIR_FLAG,$(crate))))\n \n # platform-specific auto-configuration\n include $(CFG_SRC_DIR)mk/platform.mk"}, {"sha": "7f0b3ee3b316bb13a13e4cd1d57cb0f83a2cae6f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/c8a661838ed3f4db7a9402df880e539b46f0a0f1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a661838ed3f4db7a9402df880e539b46f0a0f1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=c8a661838ed3f4db7a9402df880e539b46f0a0f1", "patch": "@@ -116,7 +116,7 @@ impl<H:Hair> Builder<H> {\n     }\n \n     pub fn lvalue_into_pattern(&mut self,\n-                               block: BasicBlock,\n+                               mut block: BasicBlock,\n                                var_extent: H::CodeExtent,\n                                irrefutable_pat: PatternRef<H>,\n                                initializer: &Lvalue<H>)\n@@ -132,7 +132,7 @@ impl<H:Hair> Builder<H> {\n \n         // Simplify the candidate. Since the pattern is irrefutable, this should\n         // always convert all match-pairs into bindings.\n-        self.simplify_candidate(&mut candidate);\n+        unpack!(block = self.simplify_candidate(block, &mut candidate));\n \n         if !candidate.match_pairs.is_empty() {\n             self.hir.span_bug(\n@@ -233,15 +233,7 @@ enum TestKind<H:Hair> {\n #[derive(Debug)]\n struct Test<H:Hair> {\n     span: H::Span,\n-\n-    // the kind of test to be performed,\n     kind: TestKind<H>,\n-\n-    // the outcome we expect,\n-    outcome: usize,\n-\n-    // and the match pairs that will result\n-    match_pairs: Vec<MatchPair<H>>\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -261,7 +253,7 @@ impl<H:Hair> Builder<H> {\n         // complete, all the match pairs which remain require some\n         // form of test, whether it be a switch or pattern comparison.\n         for candidate in &mut candidates {\n-            self.simplify_candidate(candidate);\n+            unpack!(block = self.simplify_candidate(block, candidate));\n         }\n \n         // The candidates are inversely sorted by priority. Check to\n@@ -293,14 +285,16 @@ impl<H:Hair> Builder<H> {\n         debug!(\"match_candidates: test={:?} match_pair={:?}\", test, match_pair);\n         let target_blocks = self.perform_test(block, &match_pair.lvalue, &test);\n \n-        for (outcome, target_block) in target_blocks.into_iter().enumerate() {\n+        for (outcome, mut target_block) in target_blocks.into_iter().enumerate() {\n             let applicable_candidates: Vec<Candidate<H>> =\n                 candidates.iter()\n                           .filter_map(|candidate| {\n-                              self.candidate_under_assumption(&match_pair.lvalue,\n-                                                              &test.kind,\n-                                                              outcome,\n-                                                              candidate)\n+                              unpack!(target_block =\n+                                      self.candidate_under_assumption(target_block,\n+                                                                      &match_pair.lvalue,\n+                                                                      &test.kind,\n+                                                                      outcome,\n+                                                                      candidate))\n                           })\n                           .collect();\n             self.match_candidates(span, var_extent, applicable_candidates, target_block);"}, {"sha": "f15b2ed5d4e59a57c423179fb28d577a549aada2", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c8a661838ed3f4db7a9402df880e539b46f0a0f1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a661838ed3f4db7a9402df880e539b46f0a0f1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=c8a661838ed3f4db7a9402df880e539b46f0a0f1", "patch": "@@ -22,7 +22,7 @@\n //! sort of test: for example, testing which variant an enum is, or\n //! testing a value against a constant.\n \n-use build::Builder;\n+use build::{BlockAnd, Builder};\n use build::matches::{Binding, MatchPair, Candidate};\n use hair::*;\n use repr::*;\n@@ -31,20 +31,25 @@ use std::mem;\n \n impl<H:Hair> Builder<H> {\n     pub fn simplify_candidate(&mut self,\n+                              mut block: BasicBlock,\n                               candidate: &mut Candidate<H>)\n+                              -> BlockAnd<()>\n     {\n         // repeatedly simplify match pairs until fixed point is reached\n         loop {\n             let match_pairs = mem::replace(&mut candidate.match_pairs, vec![]);\n             let mut progress = match_pairs.len(); // count how many were simplified\n             for match_pair in match_pairs {\n-                if let Err(match_pair) = self.simplify_match_pair(match_pair, candidate) {\n-                    candidate.match_pairs.push(match_pair);\n-                    progress -= 1; // this one was not simplified\n+                match self.simplify_match_pair(block, match_pair, candidate) {\n+                    Ok(b) => { block = b; }\n+                    Err(match_pair) => {\n+                        candidate.match_pairs.push(match_pair);\n+                        progress -= 1; // this one was not simplified\n+                    }\n                 }\n             }\n             if progress == 0 {\n-                return; // if we were not able to simplify any, done.\n+                return block.unit(); // if we were not able to simplify any, done.\n             }\n         }\n     }\n@@ -54,14 +59,15 @@ impl<H:Hair> Builder<H> {\n     /// have been pushed into the candidate. On failure (if false is\n     /// returned), no changes are made to candidate.\n     fn simplify_match_pair(&mut self,\n+                           mut block: BasicBlock,\n                            match_pair: MatchPair<H>,\n                            candidate: &mut Candidate<H>)\n-                           -> Result<(), MatchPair<H>> // returns Err() if cannot simplify\n+                           -> Result<BasicBlock, MatchPair<H>> // returns Err() if cannot simplify\n     {\n         match match_pair.pattern.kind {\n             PatternKind::Wild(..) => {\n                 // nothing left to do\n-                Ok(())\n+                Ok(block)\n             }\n \n             PatternKind::Binding { name, mutability, mode, var, ty, subpattern } => {\n@@ -81,24 +87,22 @@ impl<H:Hair> Builder<H> {\n                     candidate.match_pairs.push(MatchPair::new(match_pair.lvalue, subpattern));\n                 }\n \n-                Ok(())\n+                Ok(block)\n             }\n \n             PatternKind::Constant { .. } => {\n                 // FIXME normalize patterns when possible\n                 Err(match_pair)\n             }\n \n-            PatternKind::Array { prefix, slice: None, suffix } => {\n-                self.append_prefix_suffix_pairs(\n-                    &mut candidate.match_pairs, match_pair.lvalue.clone(), prefix, suffix);\n-                Ok(())\n-            }\n-\n-            PatternKind::Array { prefix: _, slice: Some(_), suffix: _ } => {\n-                self.hir.span_bug(\n-                    match_pair.pattern.span,\n-                    &format!(\"slice patterns not implemented in MIR\"));\n+            PatternKind::Array { prefix, slice, suffix } => {\n+                unpack!(block = self.prefix_suffix_slice(&mut candidate.match_pairs,\n+                                                         block,\n+                                                         match_pair.lvalue.clone(),\n+                                                         prefix,\n+                                                         slice,\n+                                                         suffix));\n+                Ok(block)\n             }\n \n             PatternKind::Slice { .. } |\n@@ -112,14 +116,14 @@ impl<H:Hair> Builder<H> {\n                 // tuple struct, match subpats (if any)\n                 candidate.match_pairs.extend(\n                     self.field_match_pairs(match_pair.lvalue, subpatterns));\n-                Ok(())\n+                Ok(block)\n             }\n \n             PatternKind::Deref { subpattern } => {\n                 let lvalue = match_pair.lvalue.deref();\n                 let subpattern = self.hir.mirror(subpattern);\n                 candidate.match_pairs.push(MatchPair::new(lvalue, subpattern));\n-                Ok(())\n+                Ok(block)\n             }\n         }\n     }"}, {"sha": "2d0a6e61beb2819954f8aa1e5f572611cce7633b", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 109, "deletions": 63, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/c8a661838ed3f4db7a9402df880e539b46f0a0f1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a661838ed3f4db7a9402df880e539b46f0a0f1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=c8a661838ed3f4db7a9402df880e539b46f0a0f1", "patch": "@@ -15,7 +15,7 @@\n // identify what tests are needed, perform the tests, and then filter\n // the candidates based on the result.\n \n-use build::Builder;\n+use build::{BlockAnd, Builder};\n use build::matches::{Candidate, MatchPair, Test, TestKind};\n use hair::*;\n use repr::*;\n@@ -25,72 +25,40 @@ impl<H:Hair> Builder<H> {\n     ///\n     /// It is a bug to call this with a simplifyable pattern.\n     pub fn test(&mut self, match_pair: &MatchPair<H>) -> Test<H> {\n-        match match_pair.pattern.kind.clone() {\n-            PatternKind::Variant { adt_def, variant_index, subpatterns } => {\n-                let elem = ProjectionElem::Downcast(adt_def, variant_index);\n-                let downcast_lvalue = match_pair.lvalue.clone().elem(elem);\n-\n-                let consequent_match_pairs =\n-                    subpatterns.into_iter()\n-                               .map(|subpattern| {\n-                                   let lvalue =\n-                                       downcast_lvalue.clone().field(\n-                                           subpattern.field);\n-                                   self.match_pair(lvalue, subpattern.pattern)\n-                               })\n-                               .collect();\n-\n+        match match_pair.pattern.kind {\n+            PatternKind::Variant { ref adt_def, variant_index: _, subpatterns: _ } => {\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Switch { adt_def: adt_def },\n-                    outcome: variant_index,\n-                    match_pairs: consequent_match_pairs,\n+                    kind: TestKind::Switch { adt_def: adt_def.clone() },\n                 }\n             }\n \n-            PatternKind::Constant { expr } => {\n-                let expr = self.as_constant(expr);\n+            PatternKind::Constant { ref expr } => {\n+                let expr = self.as_constant(expr.clone());\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Eq { value: expr,\n-                                         ty: match_pair.pattern.ty.clone() },\n-                    outcome: 0, // 0 == true, of course. :)\n-                    match_pairs: vec![]\n+                    kind: TestKind::Eq { value: expr, ty: match_pair.pattern.ty.clone() },\n                 }\n             }\n \n-            PatternKind::Range { lo, hi } => {\n-                let lo = self.as_constant(lo);\n-                let hi = self.as_constant(hi);\n+            PatternKind::Range { ref lo, ref hi } => {\n+                let lo = self.as_constant(lo.clone());\n+                let hi = self.as_constant(hi.clone());\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Range { lo: lo,\n-                                            hi: hi,\n-                                            ty: match_pair.pattern.ty.clone() },\n-                    outcome: 0, // 0 == true, of course. :)\n-                    match_pairs: vec![]\n+                    kind: TestKind::Range { lo: lo, hi: hi, ty: match_pair.pattern.ty.clone() },\n                 }\n             }\n \n-            PatternKind::Slice { prefix, slice: None, suffix } => {\n+            PatternKind::Slice { ref prefix, ref slice, ref suffix } => {\n                 let len = prefix.len() + suffix.len();\n-                let mut consequent_match_pairs = vec![];\n-                self.append_prefix_suffix_pairs(\n-                    &mut consequent_match_pairs, match_pair.lvalue.clone(), prefix, suffix);\n+                let op = if slice.is_some() {BinOp::Ge} else {BinOp::Eq};\n                 Test {\n                     span: match_pair.pattern.span,\n-                    kind: TestKind::Len { len: len, op: BinOp::Eq },\n-                    outcome: 0, // 0 == true, of course. :)\n-                    match_pairs: consequent_match_pairs\n+                    kind: TestKind::Len { len: len, op: op },\n                 }\n             }\n \n-            PatternKind::Slice { prefix: _, slice: Some(_), suffix: _ } => {\n-                self.hir.span_bug(\n-                    match_pair.pattern.span,\n-                    &format!(\"slice patterns not implemented in MIR\"));\n-            }\n-\n             PatternKind::Array { .. } |\n             PatternKind::Wild |\n             PatternKind::Binding { .. } |\n@@ -225,28 +193,36 @@ impl<H:Hair> Builder<H> {\n     /// were `Ok`, we would return `Some([x.0.downcast<Ok>.0 @ P1, x.1\n     /// @ 22])`.\n     pub fn candidate_under_assumption(&mut self,\n+                                      mut block: BasicBlock,\n                                       test_lvalue: &Lvalue<H>,\n                                       test_kind: &TestKind<H>,\n                                       test_outcome: usize,\n                                       candidate: &Candidate<H>)\n-                                      -> Option<Candidate<H>> {\n+                                      -> BlockAnd<Option<Candidate<H>>> {\n         let candidate = candidate.clone();\n         let match_pairs = candidate.match_pairs;\n-        match self.match_pairs_under_assumption(test_lvalue, test_kind, test_outcome, match_pairs) {\n+        let result = unpack!(block = self.match_pairs_under_assumption(block,\n+                                                                       test_lvalue,\n+                                                                       test_kind,\n+                                                                       test_outcome,\n+                                                                       match_pairs));\n+        block.and(match result {\n             Some(match_pairs) => Some(Candidate { match_pairs: match_pairs, ..candidate }),\n             None => None\n-        }\n+        })\n     }\n \n     /// Helper for candidate_under_assumption that does the actual\n     /// work of transforming the list of match pairs.\n     fn match_pairs_under_assumption(&mut self,\n+                                    mut block: BasicBlock,\n                                     test_lvalue: &Lvalue<H>,\n                                     test_kind: &TestKind<H>,\n                                     test_outcome: usize,\n                                     match_pairs: Vec<MatchPair<H>>)\n-                                    -> Option<Vec<MatchPair<H>>> {\n+                                    -> BlockAnd<Option<Vec<MatchPair<H>>>> {\n         let mut result = vec![];\n+\n         for match_pair in match_pairs {\n             // if the match pair is testing a different lvalue, it\n             // is unaffected by this test.\n@@ -275,22 +251,92 @@ impl<H:Hair> Builder<H> {\n                 continue;\n             }\n \n-            if test_outcome != desired_test.outcome {\n-                // if we did the right kind of test, but it had the\n-                // wrong outcome, then this *entire candidate* can no\n-                // longer apply, huzzah! Therefore, we can stop this\n-                // iteration and just return `None` to our caller.\n-                return None;\n+            let opt_consequent_match_pairs =\n+                unpack!(block = self.consequent_match_pairs_under_assumption(block,\n+                                                                             match_pair,\n+                                                                             test_outcome));\n+            match opt_consequent_match_pairs {\n+                None => {\n+                    // Right kind of test, but wrong outcome. That\n+                    // means this **entire candidate** is\n+                    // inapplicable, since the candidate is only\n+                    // applicable if all of its match-pairs apply (and\n+                    // this one doesn't).\n+                    return block.and(None);\n+                }\n+\n+                Some(consequent_match_pairs) => {\n+                    // Test passed; add any new patterns we have to test to the final result.\n+                    result.extend(consequent_match_pairs)\n+                }\n+            }\n+        }\n+        block.and(Some(result))\n+    }\n+\n+    /// Identifies what test is needed to decide if `match_pair` is applicable.\n+    ///\n+    /// It is a bug to call this with a simplifyable pattern.\n+    pub fn consequent_match_pairs_under_assumption(&mut self,\n+                                                   mut block: BasicBlock,\n+                                                   match_pair: MatchPair<H>,\n+                                                   test_outcome: usize)\n+                                                   -> BlockAnd<Option<Vec<MatchPair<H>>>> {\n+        match match_pair.pattern.kind {\n+            PatternKind::Variant { adt_def, variant_index, subpatterns } => {\n+                if test_outcome != variant_index {\n+                    return block.and(None);\n+                }\n+\n+                let elem = ProjectionElem::Downcast(adt_def, variant_index);\n+                let downcast_lvalue = match_pair.lvalue.clone().elem(elem);\n+                let consequent_match_pairs =\n+                    subpatterns.into_iter()\n+                               .map(|subpattern| {\n+                                   let lvalue =\n+                                       downcast_lvalue.clone().field(\n+                                           subpattern.field);\n+                                   self.match_pair(lvalue, subpattern.pattern)\n+                               })\n+                               .collect();\n+                block.and(Some(consequent_match_pairs))\n+            }\n+\n+            PatternKind::Constant { .. } |\n+            PatternKind::Range { .. } => {\n+                // these are boolean tests: if we are on the 0th\n+                // successor, then they passed, and otherwise they\n+                // failed, but there are never any more tests to come.\n+                if test_outcome == 0 {\n+                    block.and(Some(vec![]))\n+                } else {\n+                    block.and(None)\n+                }\n+            }\n+\n+            PatternKind::Slice { prefix, slice, suffix } => {\n+                if test_outcome == 0 {\n+                    let mut consequent_match_pairs = vec![];\n+                    unpack!(block = self.prefix_suffix_slice(&mut consequent_match_pairs,\n+                                                             block,\n+                                                             match_pair.lvalue,\n+                                                             prefix,\n+                                                             slice,\n+                                                             suffix));\n+                    block.and(Some(consequent_match_pairs))\n+                } else {\n+                    block.and(None)\n+                }\n             }\n \n-            // otherwise, the test passed, so we now have to include the\n-            // \"unlocked\" set of match pairs. For example, if we had `x @\n-            // Some(P1)`, and here we `test_kind==Switch` and\n-            // `outcome=Some`, then we would return `x.downcast<Some>.0 @\n-            // P1`.\n-            result.extend(desired_test.match_pairs);\n+            PatternKind::Array { .. } |\n+            PatternKind::Wild |\n+            PatternKind::Binding { .. } |\n+            PatternKind::Leaf { .. } |\n+            PatternKind::Deref { .. } => {\n+                self.error_simplifyable(&match_pair)\n+            }\n         }\n-        Some(result)\n     }\n \n     fn error_simplifyable(&mut self, match_pair: &MatchPair<H>) -> ! {"}, {"sha": "65a08868666352ad48ee5bfc1fc4380d973575e0", "filename": "src/librustc_mir/build/matches/util.rs", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c8a661838ed3f4db7a9402df880e539b46f0a0f1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a661838ed3f4db7a9402df880e539b46f0a0f1/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Futil.rs?ref=c8a661838ed3f4db7a9402df880e539b46f0a0f1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use build::Builder;\n+use build::{BlockAnd, Builder};\n use build::matches::MatchPair;\n use hair::*;\n use repr::*;\n@@ -32,11 +32,54 @@ impl<H:Hair> Builder<H> {\n         MatchPair::new(lvalue, pattern)\n     }\n \n-    pub fn append_prefix_suffix_pairs(&mut self,\n-                                      match_pairs: &mut Vec<MatchPair<H>>,\n-                                      lvalue: Lvalue<H>,\n-                                      prefix: Vec<PatternRef<H>>,\n-                                      suffix: Vec<PatternRef<H>>)\n+    /// When processing an array/slice pattern like `lv @ [x, y, ..s, z]`,\n+    /// this function converts the prefix (`x`, `y`) and suffix (`z`) into\n+    /// distinct match pairs:\n+    ///\n+    ///     lv[0 of 3] @ x  // see ProjectionElem::ConstantIndex (and its Debug impl)\n+    ///     lv[1 of 3] @ y  // to explain the `[x of y]` notation\n+    ///     lv[-1 of 3] @ z\n+    ///\n+    /// If a slice like `s` is present, then the function also creates\n+    /// a temporary like:\n+    ///\n+    ///     tmp0 = lv[2..-1] // using the special Rvalue::Slice\n+    ///\n+    /// and creates a match pair `tmp0 @ s`\n+    pub fn prefix_suffix_slice(&mut self,\n+                               match_pairs: &mut Vec<MatchPair<H>>,\n+                               block: BasicBlock,\n+                               lvalue: Lvalue<H>,\n+                               prefix: Vec<PatternRef<H>>,\n+                               opt_slice: Option<PatternRef<H>>,\n+                               suffix: Vec<PatternRef<H>>)\n+                               -> BlockAnd<()>\n+    {\n+        // If there is a `..P` pattern, create a temporary `t0` for\n+        // the slice and then a match pair `t0 @ P`:\n+        if let Some(slice) = opt_slice {\n+            let slice = self.hir.mirror(slice);\n+            let prefix_len = prefix.len();\n+            let suffix_len = suffix.len();\n+            let rvalue = Rvalue::Slice { input: lvalue.clone(),\n+                                         from_start: prefix_len,\n+                                         from_end: suffix_len };\n+            let temp = self.temp(slice.ty.clone()); // no need to schedule drop, temp is always copy\n+            self.cfg.push_assign(block, slice.span, &temp, rvalue);\n+            match_pairs.push(MatchPair::new(temp, slice));\n+        }\n+\n+        self.prefix_suffix(match_pairs, lvalue, prefix, suffix);\n+\n+        block.unit()\n+    }\n+\n+    /// Helper for `prefix_suffix_slice` which just processes the prefix and suffix.\n+    fn prefix_suffix(&mut self,\n+                     match_pairs: &mut Vec<MatchPair<H>>,\n+                     lvalue: Lvalue<H>,\n+                     prefix: Vec<PatternRef<H>>,\n+                     suffix: Vec<PatternRef<H>>)\n     {\n         let min_length = prefix.len() + suffix.len();\n         assert!(min_length < u32::MAX as usize);"}, {"sha": "a54942144c5ec8494dc18b23eb0f0169a1e31241", "filename": "src/librustc_mir/repr.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/c8a661838ed3f4db7a9402df880e539b46f0a0f1/src%2Flibrustc_mir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c8a661838ed3f4db7a9402df880e539b46f0a0f1/src%2Flibrustc_mir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Frepr.rs?ref=c8a661838ed3f4db7a9402df880e539b46f0a0f1", "patch": "@@ -471,9 +471,9 @@ impl<H:Hair> Debug for Lvalue<H> {\n                     ProjectionElem::Index(ref index) =>\n                         write!(fmt,\"{:?}[{:?}]\", data.base, index),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: false } =>\n-                        write!(fmt,\"{:?}[{:?}; {:?}]\", data.base, offset, min_length),\n+                        write!(fmt,\"{:?}[{:?} of {:?}]\", data.base, offset, min_length),\n                     ProjectionElem::ConstantIndex { offset, min_length, from_end: true } =>\n-                        write!(fmt,\"{:?}[-{:?}; {:?}]\", data.base, offset, min_length),\n+                        write!(fmt,\"{:?}[-{:?} of {:?}]\", data.base, offset, min_length),\n                 },\n         }\n     }\n@@ -535,6 +535,17 @@ pub enum Rvalue<H:Hair> {\n     // away after type-checking and before lowering.\n     Aggregate(AggregateKind<H>, Vec<Operand<H>>),\n \n+    // Generates a slice of the form `&input[from_start..L-from_end]`\n+    // where `L` is the length of the slice. This is only created by\n+    // slice pattern matching, so e.g. a pattern of the form `[x, y,\n+    // .., z]` might create a slice with `from_start=2` and\n+    // `from_end=1`.\n+    Slice {\n+        input: Lvalue<H>,\n+        from_start: usize,\n+        from_end: usize,\n+    },\n+\n     InlineAsm(H::InlineAsm),\n }\n \n@@ -623,6 +634,8 @@ impl<H:Hair> Debug for Rvalue<H> {\n             Box(ref t) => write!(fmt, \"Box {:?}\", t),\n             Aggregate(ref kind, ref lvs) => write!(fmt, \"Aggregate<{:?}>({:?})\", kind, lvs),\n             InlineAsm(ref asm) => write!(fmt, \"InlineAsm({:?})\", asm),\n+            Slice { ref input, from_start, from_end } => write!(fmt, \"{:?}[{:?}..-{:?}]\",\n+                                                                input, from_start, from_end),\n         }\n     }\n }"}]}