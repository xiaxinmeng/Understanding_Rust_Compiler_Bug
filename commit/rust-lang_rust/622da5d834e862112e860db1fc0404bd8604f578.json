{"sha": "622da5d834e862112e860db1fc0404bd8604f578", "node_id": "C_kwDOAAsO6NoAKDYyMmRhNWQ4MzRlODYyMTEyZTg2MGRiMWZjMDQwNGJkODYwNGY1Nzg", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-06-20T15:50:27Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2022-08-12T08:53:07Z"}, "message": "debuginfo: Change C++-like encoding for enums.\n\nThe updated encoding should be able to handle niche layouts where\nmore than one variant has fields.", "tree": {"sha": "20807735359dc09b37b710845a8b9ed7d9bbd04e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/20807735359dc09b37b710845a8b9ed7d9bbd04e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/622da5d834e862112e860db1fc0404bd8604f578", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/622da5d834e862112e860db1fc0404bd8604f578", "html_url": "https://github.com/rust-lang/rust/commit/622da5d834e862112e860db1fc0404bd8604f578", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/622da5d834e862112e860db1fc0404bd8604f578/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2b52ff73edc8b0b7c74bc28760d618187731fe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2b52ff73edc8b0b7c74bc28760d618187731fe8", "html_url": "https://github.com/rust-lang/rust/commit/e2b52ff73edc8b0b7c74bc28760d618187731fe8"}], "stats": {"total": 1214, "additions": 846, "deletions": 368}, "files": [{"sha": "25a989bdf05253b6ec91aed5ee615b24a71bbca9", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -114,6 +114,7 @@ macro_rules! return_if_di_node_created_in_meantime {\n }\n \n /// Extract size and alignment from a TyAndLayout.\n+#[inline]\n fn size_and_align_of<'tcx>(ty_and_layout: TyAndLayout<'tcx>) -> (Size, Align) {\n     (ty_and_layout.size, ty_and_layout.align.abi)\n }"}, {"sha": "55bdd29d67cdec3e9fdbfd2e418b6afa83725d92", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs", "status": "modified", "additions": 493, "deletions": 167, "changes": 660, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fcpp_like.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -1,29 +1,30 @@\n use std::borrow::Cow;\n \n use libc::c_uint;\n-use rustc_codegen_ssa::debuginfo::{\n-    type_names::compute_debuginfo_type_name, wants_c_like_enum_debuginfo,\n+use rustc_codegen_ssa::{\n+    debuginfo::{type_names::compute_debuginfo_type_name, wants_c_like_enum_debuginfo},\n+    traits::ConstMethods,\n };\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_middle::{\n     bug,\n     ty::{\n         self,\n         layout::{LayoutOf, TyAndLayout},\n-        util::Discr,\n-        AdtDef, GeneratorSubsts,\n+        AdtDef, GeneratorSubsts, Ty,\n     },\n };\n-use rustc_target::abi::{Size, TagEncoding, VariantIdx, Variants};\n+use rustc_target::abi::{Align, Endian, Size, TagEncoding, VariantIdx, Variants};\n use smallvec::smallvec;\n \n use crate::{\n     common::CodegenCx,\n     debuginfo::{\n         metadata::{\n             build_field_di_node, closure_saved_names_of_captured_variables,\n-            enums::tag_base_type,\n-            file_metadata, generator_layout_and_saved_local_names, size_and_align_of,\n-            type_map::{self, UniqueTypeId},\n+            enums::{tag_base_type, DiscrResult},\n+            file_metadata, generator_layout_and_saved_local_names, size_and_align_of, type_di_node,\n+            type_map::{self, Stub, UniqueTypeId},\n             unknown_file_metadata, DINodeCreationResult, SmallVec, NO_GENERICS, NO_SCOPE_METADATA,\n             UNKNOWN_LINE_NUMBER,\n         },\n@@ -35,59 +36,78 @@ use crate::{\n     },\n };\n \n-/// In CPP-like mode, we generate a union of structs for each variant and an\n-/// explicit discriminant field roughly equivalent to the following C/C++ code:\n+// The names of the associated constants in each variant wrapper struct.\n+// These have to match up with the names being used in `intrinsic.natvis`.\n+const ASSOC_CONST_DISCR_NAME: &str = \"NAME\";\n+const ASSOC_CONST_DISCR_EXACT: &str = \"DISCR_EXACT\";\n+const ASSOC_CONST_DISCR_BEGIN: &str = \"DISCR_BEGIN\";\n+const ASSOC_CONST_DISCR_END: &str = \"DISCR_END\";\n+\n+const ASSOC_CONST_DISCR128_EXACT_LO: &str = \"DISCR128_EXACT_LO\";\n+const ASSOC_CONST_DISCR128_EXACT_HI: &str = \"DISCR128_EXACT_HI\";\n+const ASSOC_CONST_DISCR128_BEGIN_LO: &str = \"DISCR128_BEGIN_LO\";\n+const ASSOC_CONST_DISCR128_BEGIN_HI: &str = \"DISCR128_BEGIN_HI\";\n+const ASSOC_CONST_DISCR128_END_LO: &str = \"DISCR128_END_LO\";\n+const ASSOC_CONST_DISCR128_END_HI: &str = \"DISCR128_END_HI\";\n+\n+// The name of the tag field in the top-level union\n+const TAG_FIELD_NAME: &str = \"tag\";\n+const TAG_FIELD_NAME_128_LO: &str = \"tag128_lo\";\n+const TAG_FIELD_NAME_128_HI: &str = \"tag128_hi\";\n+\n+// We assign a \"virtual\" discriminant value to the sole variant of\n+// a single-variant enum.\n+const SINGLE_VARIANT_VIRTUAL_DISR: u64 = 0;\n+\n+/// In CPP-like mode, we generate a union with a field for each variant and an\n+/// explicit tag field. The field of each variant has a struct type\n+/// that encodes the discrimiant of the variant and it's data layout.\n+/// The union also has a nested enumeration type that is only used for encoding\n+/// variant names in an efficient way. Its enumerator values do _not_ correspond\n+/// to the enum's discriminant values.\n+/// It's roughly equivalent to the following C/C++ code:\n ///\n /// ```c\n /// union enum$<{fully-qualified-name}> {\n-///   struct {variant 0 name} {\n-///     <variant 0 fields>\n+///   struct Variant0 {\n+///     struct {name-of-variant-0} {\n+///        <variant 0 fields>\n+///     } value;\n+///\n+///     static VariantNames NAME = {name-of-variant-0};\n+///     static int_type DISCR_EXACT = {discriminant-of-variant-0};\n ///   } variant0;\n+///\n ///   <other variant structs>\n-///   {name} discriminant;\n+///\n+///   int_type tag;\n+///\n+///   enum VariantNames {\n+///      <name-of-variant-0> = 0, // The numeric values are variant index,\n+///      <name-of-variant-1> = 1, // not discriminant values.\n+///      <name-of-variant-2> = 2,\n+///      ...\n+///   }\n /// }\n /// ```\n ///\n /// As you can see, the type name is wrapped `enum$`. This way we can have a\n /// single NatVis rule for handling all enums.\n ///\n-/// At the LLVM IR level this looks like\n-///\n-/// ```txt\n-///       DW_TAG_union_type              (top-level type for enum)\n-///         DW_TAG_member                    (member for variant 1)\n-///         DW_TAG_member                    (member for variant 2)\n-///         DW_TAG_member                    (member for variant 3)\n-///         DW_TAG_structure_type            (type of variant 1)\n-///         DW_TAG_structure_type            (type of variant 2)\n-///         DW_TAG_structure_type            (type of variant 3)\n-///         DW_TAG_enumeration_type          (type of tag)\n-/// ```\n+/// For niche-tag enums, a variant might correspond to a range of tag values.\n+/// In that case the variant struct has a `DISCR_BEGIN` and `DISCR_END` field\n+/// instead of DISCR_EXACT.\n ///\n-/// The above encoding applies for enums with a direct tag. For niche-tag we have to do things\n-/// differently in order to allow a NatVis visualizer to extract all the information needed:\n-/// We generate a union of two fields, one for the dataful variant\n-/// and one that just points to the discriminant (which is some field within the dataful variant).\n-/// We also create a DW_TAG_enumeration_type DIE that contains tag values for the non-dataful\n-/// variants and make the discriminant field that type. We then use NatVis to render the enum type\n-/// correctly in Windbg/VS. This will generate debuginfo roughly equivalent to the following C:\n+/// Single-variant enums don't actually have a tag field. In this case we\n+/// emit a static tag field (that always has the value 0) so we can use the\n+/// same representation (and NatVis).\n ///\n-/// ```c\n-/// union enum$<{name}, {min niche}, {max niche}, {dataful variant name}> {\n-///   struct <dataful variant name> {\n-///     <fields in dataful variant>\n-///   } dataful_variant;\n-///   enum Discriminant$ {\n-///     <non-dataful variants>\n-///   } discriminant;\n-/// }\n-/// ```\n-///\n-/// The NatVis in `intrinsic.natvis` matches on the type name `enum$<*, *, *, *>`\n-/// and evaluates `this.discriminant`. If the value is between the min niche and max\n-/// niche, then the enum is in the dataful variant and `this.dataful_variant` is\n-/// rendered. Otherwise, the enum is in one of the non-dataful variants. In that\n-/// case, we just need to render the name of the `this.discriminant` enum.\n+/// For niche-layout enums it's possible to have a 128-bit tag. NatVis, VS, and\n+/// WinDbg (the main targets for CPP-like debuginfo at the moment) don't support\n+/// 128-bit integers, so all values involved get split into two 64-bit fields.\n+/// Instead of the `tag` field, we generate two fields `tag128_lo` and `tag128_hi`,\n+/// Instead of `DISCR_EXACT`, we generate `DISCR128_EXACT_LO` and `DISCR128_EXACT_HI`,\n+/// and so on.\n pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     unique_type_id: UniqueTypeId<'tcx>,\n@@ -135,27 +155,28 @@ pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n                     ref variants,\n                     tag_field,\n                     ..\n-                } => build_union_fields_for_direct_tag_enum(\n+                } => build_union_fields_for_enum(\n                     cx,\n                     enum_adt_def,\n                     enum_type_and_layout,\n                     enum_type_di_node,\n-                    &mut variants.indices(),\n+                    variants.indices(),\n                     tag_field,\n+                    None,\n                 ),\n                 Variants::Multiple {\n                     tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n                     ref variants,\n                     tag_field,\n                     ..\n-                } => build_union_fields_for_niche_tag_enum(\n+                } => build_union_fields_for_enum(\n                     cx,\n                     enum_adt_def,\n                     enum_type_and_layout,\n                     enum_type_di_node,\n-                    dataful_variant,\n-                    &mut variants.indices(),\n+                    variants.indices(),\n                     tag_field,\n+                    Some(dataful_variant),\n                 ),\n             }\n         },\n@@ -217,137 +238,344 @@ fn build_single_variant_union_fields<'ll, 'tcx>(\n     let variant_layout = enum_type_and_layout.for_variant(cx, variant_index);\n     let variant_struct_type_di_node = super::build_enum_variant_struct_type_di_node(\n         cx,\n-        enum_type_and_layout.ty,\n+        enum_type_and_layout,\n         enum_type_di_node,\n         variant_index,\n         enum_adt_def.variant(variant_index),\n         variant_layout,\n     );\n \n-    // NOTE: The field name of the union is the same as the variant name, not \"variant0\".\n-    let variant_name = enum_adt_def.variant(variant_index).name.as_str();\n+    let tag_base_type = cx.tcx.types.u32;\n+    let tag_base_type_di_node = type_di_node(cx, tag_base_type);\n+    let tag_base_type_align = cx.align_of(tag_base_type);\n \n-    smallvec![build_field_di_node(\n+    let variant_names_type_di_node = build_variant_names_type_di_node(\n         cx,\n         enum_type_di_node,\n-        variant_name,\n-        // NOTE: We use the size and align of the entire type, not from variant_layout\n-        //       since the later is sometimes smaller (if it has fewer fields).\n-        size_and_align_of(enum_type_and_layout),\n-        Size::ZERO,\n-        DIFlags::FlagZero,\n+        std::iter::once((\n+            variant_index,\n+            Cow::from(enum_adt_def.variant(variant_index).name.as_str()),\n+        )),\n+    );\n+\n+    let variant_struct_type_wrapper_di_node = build_variant_struct_wrapper_type_di_node(\n+        cx,\n+        enum_type_and_layout,\n+        enum_type_di_node,\n+        variant_index,\n+        None,\n         variant_struct_type_di_node,\n-    )]\n+        variant_names_type_di_node,\n+        tag_base_type_di_node,\n+        tag_base_type,\n+        DiscrResult::NoDiscriminant,\n+    );\n+\n+    smallvec![\n+        build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            &variant_union_field_name(variant_index, None),\n+            // NOTE: We use the size and align of the entire type, not from variant_layout\n+            //       since the later is sometimes smaller (if it has fewer fields).\n+            size_and_align_of(enum_type_and_layout),\n+            Size::ZERO,\n+            DIFlags::FlagZero,\n+            variant_struct_type_wrapper_di_node,\n+        ),\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateStaticMemberType(\n+                DIB(cx),\n+                enum_type_di_node,\n+                TAG_FIELD_NAME.as_ptr().cast(),\n+                TAG_FIELD_NAME.len(),\n+                unknown_file_metadata(cx),\n+                UNKNOWN_LINE_NUMBER,\n+                variant_names_type_di_node,\n+                DIFlags::FlagArtificial,\n+                Some(cx.const_u64(SINGLE_VARIANT_VIRTUAL_DISR)),\n+                tag_base_type_align.bits() as u32,\n+            )\n+        }\n+    ]\n }\n \n-fn build_union_fields_for_direct_tag_enum<'ll, 'tcx>(\n+fn build_union_fields_for_enum<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     enum_adt_def: AdtDef<'tcx>,\n     enum_type_and_layout: TyAndLayout<'tcx>,\n     enum_type_di_node: &'ll DIType,\n-    variant_indices: &mut dyn Iterator<Item = VariantIdx>,\n+    variant_indices: impl Iterator<Item = VariantIdx> + Clone,\n     tag_field: usize,\n+    dataful_variant_index: Option<VariantIdx>,\n ) -> SmallVec<&'ll DIType> {\n+    let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n+\n+    let variant_names_type_di_node = build_variant_names_type_di_node(\n+        cx,\n+        enum_type_di_node,\n+        variant_indices.clone().map(|variant_index| {\n+            let variant_name = Cow::from(enum_adt_def.variant(variant_index).name.as_str());\n+            (variant_index, variant_name)\n+        }),\n+    );\n+\n     let variant_field_infos: SmallVec<VariantFieldInfo<'ll>> = variant_indices\n         .map(|variant_index| {\n             let variant_layout = enum_type_and_layout.for_variant(cx, variant_index);\n \n+            let variant_def = enum_adt_def.variant(variant_index);\n+\n+            let variant_struct_type_di_node = super::build_enum_variant_struct_type_di_node(\n+                cx,\n+                enum_type_and_layout,\n+                enum_type_di_node,\n+                variant_index,\n+                variant_def,\n+                variant_layout,\n+            );\n+\n             VariantFieldInfo {\n                 variant_index,\n-                variant_struct_type_di_node: super::build_enum_variant_struct_type_di_node(\n-                    cx,\n-                    enum_type_and_layout.ty,\n-                    enum_type_di_node,\n-                    variant_index,\n-                    enum_adt_def.variant(variant_index),\n-                    variant_layout,\n-                ),\n+                variant_struct_type_di_node,\n                 source_info: None,\n+                discr: super::compute_discriminant_value(cx, enum_type_and_layout, variant_index),\n             }\n         })\n         .collect();\n \n-    let discr_type_name = cx.tcx.item_name(enum_adt_def.did());\n-    let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n-    let discr_type_di_node = super::build_enumeration_type_di_node(\n-        cx,\n-        discr_type_name.as_str(),\n-        tag_base_type,\n-        &mut enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n-            (discr, Cow::from(enum_adt_def.variant(variant_index).name.as_str()))\n-        }),\n-        enum_type_di_node,\n-    );\n-\n     build_union_fields_for_direct_tag_enum_or_generator(\n         cx,\n         enum_type_and_layout,\n         enum_type_di_node,\n         &variant_field_infos,\n-        discr_type_di_node,\n+        variant_names_type_di_node,\n+        tag_base_type,\n         tag_field,\n+        dataful_variant_index,\n     )\n }\n \n-fn build_union_fields_for_niche_tag_enum<'ll, 'tcx>(\n+// The base type of the VariantNames DW_AT_enumeration_type is always the same.\n+// It has nothing to do with the tag of the enum and just has to be big enough\n+// to hold all variant names.\n+fn variant_names_enum_base_type<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) -> Ty<'tcx> {\n+    cx.tcx.types.u32\n+}\n+\n+/// This function builds a DW_AT_enumeration_type that contains an entry for\n+/// each variant. Note that this has nothing to do with the discriminant. The\n+/// numeric value of each enumerator corresponds to the variant index. The\n+/// type is only used for efficiently encoding the name of each variant in\n+/// debuginfo.\n+fn build_variant_names_type_di_node<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    enum_adt_def: AdtDef<'tcx>,\n-    enum_type_and_layout: TyAndLayout<'tcx>,\n-    enum_type_di_node: &'ll DIType,\n-    dataful_variant_index: VariantIdx,\n-    variant_indices: &mut dyn Iterator<Item = VariantIdx>,\n-    tag_field: usize,\n-) -> SmallVec<&'ll DIType> {\n-    let dataful_variant_struct_type_di_node = super::build_enum_variant_struct_type_di_node(\n+    containing_scope: &'ll DIType,\n+    variants: impl Iterator<Item = (VariantIdx, Cow<'tcx, str>)>,\n+) -> &'ll DIType {\n+    // Create an enumerator for each variant.\n+    super::build_enumeration_type_di_node(\n         cx,\n-        enum_type_and_layout.ty,\n-        enum_type_di_node,\n-        dataful_variant_index,\n-        &enum_adt_def.variant(dataful_variant_index),\n-        enum_type_and_layout.for_variant(cx, dataful_variant_index),\n-    );\n+        \"VariantNames\",\n+        variant_names_enum_base_type(cx),\n+        variants.map(|(variant_index, variant_name)| (variant_name, variant_index.as_u32() as u64)),\n+        containing_scope,\n+    )\n+}\n \n-    let tag_base_type = super::tag_base_type(cx, enum_type_and_layout);\n-    // Create an DW_TAG_enumerator for each variant except the dataful one.\n-    let discr_type_di_node = super::build_enumeration_type_di_node(\n+fn build_variant_struct_wrapper_type_di_node<'ll, 'tcx>(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    enum_or_generator_type_and_layout: TyAndLayout<'tcx>,\n+    enum_or_generator_type_di_node: &'ll DIType,\n+    variant_index: VariantIdx,\n+    dataful_variant_index: Option<VariantIdx>,\n+    variant_struct_type_di_node: &'ll DIType,\n+    variant_names_type_di_node: &'ll DIType,\n+    tag_base_type_di_node: &'ll DIType,\n+    tag_base_type: Ty<'tcx>,\n+    discr: DiscrResult,\n+) -> &'ll DIType {\n+    type_map::build_type_with_children(\n         cx,\n-        \"Discriminant$\",\n-        tag_base_type,\n-        &mut variant_indices.filter_map(|variant_index| {\n-            if let Some(discr_val) =\n-                super::compute_discriminant_value(cx, enum_type_and_layout, variant_index)\n-            {\n-                let discr = Discr { val: discr_val as u128, ty: tag_base_type };\n-                let variant_name = Cow::from(enum_adt_def.variant(variant_index).name.as_str());\n-                Some((discr, variant_name))\n-            } else {\n-                debug_assert_eq!(variant_index, dataful_variant_index);\n-                None\n-            }\n-        }),\n-        enum_type_di_node,\n-    );\n-\n-    smallvec![\n-        build_field_di_node(\n-            cx,\n-            enum_type_di_node,\n-            \"dataful_variant\",\n-            size_and_align_of(enum_type_and_layout),\n-            Size::ZERO,\n-            DIFlags::FlagZero,\n-            dataful_variant_struct_type_di_node,\n-        ),\n-        build_field_di_node(\n+        type_map::stub(\n             cx,\n-            enum_type_di_node,\n-            \"discriminant\",\n-            cx.size_and_align_of(tag_base_type),\n-            enum_type_and_layout.fields.offset(tag_field),\n-            DIFlags::FlagZero,\n-            discr_type_di_node,\n+            Stub::Struct,\n+            UniqueTypeId::for_enum_variant_struct_type_wrapper(\n+                cx.tcx,\n+                enum_or_generator_type_and_layout.ty,\n+                variant_index,\n+            ),\n+            &variant_struct_wrapper_type_name(variant_index),\n+            // NOTE: We use size and align of enum_type, not from variant_layout:\n+            size_and_align_of(enum_or_generator_type_and_layout),\n+            Some(enum_or_generator_type_di_node),\n+            DIFlags::FlagArtificial,\n         ),\n-    ]\n+        |cx, wrapper_struct_type_di_node| {\n+            enum DiscrKind {\n+                Exact(u64),\n+                Exact128(u128),\n+                Range(u64, u64),\n+                Range128(u128, u128),\n+            }\n+\n+            let (tag_base_type_size, tag_base_type_align) = cx.size_and_align_of(tag_base_type);\n+            let is_128_bits = tag_base_type_size.bits() > 64;\n+\n+            let discr = match discr {\n+                DiscrResult::NoDiscriminant => DiscrKind::Exact(SINGLE_VARIANT_VIRTUAL_DISR),\n+                DiscrResult::Value(discr_val) => {\n+                    if is_128_bits {\n+                        DiscrKind::Exact128(discr_val)\n+                    } else {\n+                        debug_assert_eq!(discr_val, discr_val as u64 as u128);\n+                        DiscrKind::Exact(discr_val as u64)\n+                    }\n+                }\n+                DiscrResult::Range(min, max) => {\n+                    assert_eq!(Some(variant_index), dataful_variant_index);\n+                    if is_128_bits {\n+                        DiscrKind::Range128(min, max)\n+                    } else {\n+                        debug_assert_eq!(min, min as u64 as u128);\n+                        debug_assert_eq!(max, max as u64 as u128);\n+                        DiscrKind::Range(min as u64, max as u64)\n+                    }\n+                }\n+            };\n+\n+            let mut fields = SmallVec::new();\n+\n+            // We always have a field for the value\n+            fields.push(build_field_di_node(\n+                cx,\n+                wrapper_struct_type_di_node,\n+                \"value\",\n+                size_and_align_of(enum_or_generator_type_and_layout),\n+                Size::ZERO,\n+                DIFlags::FlagArtificial,\n+                variant_struct_type_di_node,\n+            ));\n+\n+            let build_assoc_const =\n+                |name: &str, type_di_node: &'ll DIType, value: u64, align: Align| unsafe {\n+                    llvm::LLVMRustDIBuilderCreateStaticMemberType(\n+                        DIB(cx),\n+                        wrapper_struct_type_di_node,\n+                        name.as_ptr().cast(),\n+                        name.len(),\n+                        unknown_file_metadata(cx),\n+                        UNKNOWN_LINE_NUMBER,\n+                        type_di_node,\n+                        DIFlags::FlagArtificial,\n+                        Some(cx.const_u64(value)),\n+                        align.bits() as u32,\n+                    )\n+                };\n+\n+            // We also always have an associated constant for the discriminant value\n+            // of the variant.\n+            fields.push(build_assoc_const(\n+                ASSOC_CONST_DISCR_NAME,\n+                variant_names_type_di_node,\n+                variant_index.as_u32() as u64,\n+                cx.align_of(variant_names_enum_base_type(cx)),\n+            ));\n+\n+            // Emit the discriminant value (or range) corresponding to the variant.\n+            match discr {\n+                DiscrKind::Exact(discr_val) => {\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR_EXACT,\n+                        tag_base_type_di_node,\n+                        discr_val,\n+                        tag_base_type_align,\n+                    ));\n+                }\n+                DiscrKind::Exact128(discr_val) => {\n+                    let align = cx.align_of(cx.tcx.types.u64);\n+                    let type_di_node = type_di_node(cx, cx.tcx.types.u64);\n+                    let Split128 { hi, lo } = split_128(discr_val);\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_EXACT_LO,\n+                        type_di_node,\n+                        lo,\n+                        align,\n+                    ));\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_EXACT_HI,\n+                        type_di_node,\n+                        hi,\n+                        align,\n+                    ));\n+                }\n+                DiscrKind::Range(begin, end) => {\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR_BEGIN,\n+                        tag_base_type_di_node,\n+                        begin,\n+                        tag_base_type_align,\n+                    ));\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR_END,\n+                        tag_base_type_di_node,\n+                        end,\n+                        tag_base_type_align,\n+                    ));\n+                }\n+                DiscrKind::Range128(begin, end) => {\n+                    let align = cx.align_of(cx.tcx.types.u64);\n+                    let type_di_node = type_di_node(cx, cx.tcx.types.u64);\n+                    let Split128 { hi: begin_hi, lo: begin_lo } = split_128(begin);\n+                    let Split128 { hi: end_hi, lo: end_lo } = split_128(end);\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_BEGIN_HI,\n+                        type_di_node,\n+                        begin_hi,\n+                        align,\n+                    ));\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_BEGIN_LO,\n+                        type_di_node,\n+                        begin_lo,\n+                        align,\n+                    ));\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_END_HI,\n+                        type_di_node,\n+                        end_hi,\n+                        align,\n+                    ));\n+\n+                    fields.push(build_assoc_const(\n+                        ASSOC_CONST_DISCR128_END_LO,\n+                        type_di_node,\n+                        end_lo,\n+                        align,\n+                    ));\n+                }\n+            }\n+\n+            fields\n+        },\n+        NO_GENERICS,\n+    )\n+    .di_node\n+}\n+\n+struct Split128 {\n+    hi: u64,\n+    lo: u64,\n+}\n+\n+fn split_128(value: u128) -> Split128 {\n+    Split128 { hi: (value >> 64) as u64, lo: value as u64 }\n }\n \n fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n@@ -370,6 +598,21 @@ fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n     let common_upvar_names = closure_saved_names_of_captured_variables(cx.tcx, generator_def_id);\n     let variant_range = generator_substs.variant_range(generator_def_id, cx.tcx);\n \n+    let tag_base_type = tag_base_type(cx, generator_type_and_layout);\n+\n+    let variant_names_type_di_node = build_variant_names_type_di_node(\n+        cx,\n+        generator_type_di_node,\n+        variant_range\n+            .clone()\n+            .map(|variant_index| (variant_index, GeneratorSubsts::variant_name(variant_index))),\n+    );\n+\n+    let discriminants: FxHashMap<VariantIdx, DiscrResult> = generator_substs\n+        .discriminants(generator_def_id, cx.tcx)\n+        .map(|(variant_index, discr)| (variant_index, DiscrResult::Value(discr.val)))\n+        .collect();\n+\n     // Build the type node for each field.\n     let variant_field_infos: SmallVec<VariantFieldInfo<'ll>> = variant_range\n         .map(|variant_index| {\n@@ -391,29 +634,24 @@ fn build_union_fields_for_direct_tag_generator<'ll, 'tcx>(\n                 None\n             };\n \n-            VariantFieldInfo { variant_index, variant_struct_type_di_node, source_info }\n+            VariantFieldInfo {\n+                variant_index,\n+                variant_struct_type_di_node,\n+                source_info,\n+                discr: discriminants[&variant_index],\n+            }\n         })\n         .collect();\n \n-    let tag_base_type = tag_base_type(cx, generator_type_and_layout);\n-    let discr_type_name = \"Discriminant$\";\n-    let discr_type_di_node = super::build_enumeration_type_di_node(\n-        cx,\n-        discr_type_name,\n-        tag_base_type,\n-        &mut generator_substs\n-            .discriminants(generator_def_id, cx.tcx)\n-            .map(|(variant_index, discr)| (discr, GeneratorSubsts::variant_name(variant_index))),\n-        generator_type_di_node,\n-    );\n-\n     build_union_fields_for_direct_tag_enum_or_generator(\n         cx,\n         generator_type_and_layout,\n         generator_type_di_node,\n         &variant_field_infos[..],\n-        discr_type_di_node,\n+        variant_names_type_di_node,\n+        tag_base_type,\n         tag_field,\n+        None,\n     )\n }\n \n@@ -425,8 +663,11 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n     enum_type_di_node: &'ll DIType,\n     variant_field_infos: &[VariantFieldInfo<'ll>],\n     discr_type_di_node: &'ll DIType,\n+    tag_base_type: Ty<'tcx>,\n     tag_field: usize,\n+    dataful_variant_index: Option<VariantIdx>,\n ) -> SmallVec<&'ll DIType> {\n+    let tag_base_type_di_node = type_di_node(cx, tag_base_type);\n     let mut unions_fields = SmallVec::with_capacity(variant_field_infos.len() + 1);\n \n     // We create a field in the union for each variant ...\n@@ -435,9 +676,23 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n             .source_info\n             .unwrap_or_else(|| (unknown_file_metadata(cx), UNKNOWN_LINE_NUMBER));\n \n-        let field_name = variant_union_field_name(variant_member_info.variant_index);\n+        let field_name =\n+            variant_union_field_name(variant_member_info.variant_index, dataful_variant_index);\n         let (size, align) = size_and_align_of(enum_type_and_layout);\n \n+        let variant_struct_type_wrapper = build_variant_struct_wrapper_type_di_node(\n+            cx,\n+            enum_type_and_layout,\n+            enum_type_di_node,\n+            variant_member_info.variant_index,\n+            dataful_variant_index,\n+            variant_member_info.variant_struct_type_di_node,\n+            discr_type_di_node,\n+            tag_base_type_di_node,\n+            tag_base_type,\n+            variant_member_info.discr,\n+        );\n+\n         // We use LLVMRustDIBuilderCreateMemberType() member type directly because\n         // the build_field_di_node() function does not support specifying a source location,\n         // which is something that we don't do anywhere else.\n@@ -456,7 +711,7 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n                 // Union fields are always at offset zero\n                 Size::ZERO.bits(),\n                 DIFlags::FlagZero,\n-                variant_member_info.variant_struct_type_di_node,\n+                variant_struct_type_wrapper,\n             )\n         }\n     }));\n@@ -466,16 +721,53 @@ fn build_union_fields_for_direct_tag_enum_or_generator<'ll, 'tcx>(\n         cx.size_and_align_of(super::tag_base_type(cx, enum_type_and_layout))\n     );\n \n-    // ... and a field for the discriminant.\n-    unions_fields.push(build_field_di_node(\n-        cx,\n-        enum_type_di_node,\n-        \"discriminant\",\n-        cx.size_and_align_of(enum_type_and_layout.field(cx, tag_field).ty),\n-        enum_type_and_layout.fields.offset(tag_field),\n-        DIFlags::FlagZero,\n-        discr_type_di_node,\n-    ));\n+    // ... and a field for the tag. If the tag is 128 bits wide, this will actually\n+    // be two 64-bit fields.\n+    let is_128_bits = cx.size_of(tag_base_type).bits() > 64;\n+\n+    if is_128_bits {\n+        let type_di_node = type_di_node(cx, cx.tcx.types.u64);\n+        let size_and_align = cx.size_and_align_of(cx.tcx.types.u64);\n+\n+        let (lo_offset, hi_offset) = match cx.tcx.data_layout.endian {\n+            Endian::Little => (0, 8),\n+            Endian::Big => (8, 0),\n+        };\n+\n+        let tag_field_offset = enum_type_and_layout.fields.offset(tag_field).bytes();\n+        let lo_offset = Size::from_bytes(tag_field_offset + lo_offset);\n+        let hi_offset = Size::from_bytes(tag_field_offset + hi_offset);\n+\n+        unions_fields.push(build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            TAG_FIELD_NAME_128_LO,\n+            size_and_align,\n+            lo_offset,\n+            DIFlags::FlagZero,\n+            type_di_node,\n+        ));\n+\n+        unions_fields.push(build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            TAG_FIELD_NAME_128_HI,\n+            size_and_align,\n+            hi_offset,\n+            DIFlags::FlagZero,\n+            type_di_node,\n+        ));\n+    } else {\n+        unions_fields.push(build_field_di_node(\n+            cx,\n+            enum_type_di_node,\n+            TAG_FIELD_NAME,\n+            cx.size_and_align_of(enum_type_and_layout.field(cx, tag_field).ty),\n+            enum_type_and_layout.fields.offset(tag_field),\n+            DIFlags::FlagZero,\n+            tag_base_type_di_node,\n+        ));\n+    }\n \n     unions_fields\n }\n@@ -485,9 +777,13 @@ struct VariantFieldInfo<'ll> {\n     variant_index: VariantIdx,\n     variant_struct_type_di_node: &'ll DIType,\n     source_info: Option<(&'ll DIFile, c_uint)>,\n+    discr: DiscrResult,\n }\n \n-fn variant_union_field_name(variant_index: VariantIdx) -> Cow<'static, str> {\n+fn variant_union_field_name(\n+    variant_index: VariantIdx,\n+    dataful_variant_index: Option<VariantIdx>,\n+) -> Cow<'static, str> {\n     const PRE_ALLOCATED: [&str; 16] = [\n         \"variant0\",\n         \"variant1\",\n@@ -507,8 +803,38 @@ fn variant_union_field_name(variant_index: VariantIdx) -> Cow<'static, str> {\n         \"variant15\",\n     ];\n \n+    if Some(variant_index) == dataful_variant_index {\n+        return Cow::from(\"variant_fallback\");\n+    }\n+\n     PRE_ALLOCATED\n         .get(variant_index.as_usize())\n         .map(|&s| Cow::from(s))\n         .unwrap_or_else(|| format!(\"variant{}\", variant_index.as_usize()).into())\n }\n+\n+fn variant_struct_wrapper_type_name(variant_index: VariantIdx) -> Cow<'static, str> {\n+    const PRE_ALLOCATED: [&str; 16] = [\n+        \"Variant0\",\n+        \"Variant1\",\n+        \"Variant2\",\n+        \"Variant3\",\n+        \"Variant4\",\n+        \"Variant5\",\n+        \"Variant6\",\n+        \"Variant7\",\n+        \"Variant8\",\n+        \"Variant9\",\n+        \"Variant10\",\n+        \"Variant11\",\n+        \"Variant12\",\n+        \"Variant13\",\n+        \"Variant14\",\n+        \"Variant15\",\n+    ];\n+\n+    PRE_ALLOCATED\n+        .get(variant_index.as_usize())\n+        .map(|&s| Cow::from(s))\n+        .unwrap_or_else(|| format!(\"Variant{}\", variant_index.as_usize()).into())\n+}"}, {"sha": "9b3d080bfd6aa3f8dbb7b1f76de5c70ba62e9fe9", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/mod.rs", "status": "modified", "additions": 57, "deletions": 33, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fmod.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -10,7 +10,6 @@ use rustc_middle::{\n     ty::{\n         self,\n         layout::{IntegerExt, LayoutOf, PrimitiveExt, TyAndLayout},\n-        util::Discr,\n         AdtDef, GeneratorSubsts, Ty, VariantDef,\n     },\n };\n@@ -90,8 +89,11 @@ fn build_c_style_enum_di_node<'ll, 'tcx>(\n             cx,\n             &compute_debuginfo_type_name(cx.tcx, enum_type_and_layout.ty, false),\n             tag_base_type(cx, enum_type_and_layout),\n-            &mut enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n-                (discr, Cow::from(enum_adt_def.variant(variant_index).name.as_str()))\n+            enum_adt_def.discriminants(cx.tcx).map(|(variant_index, discr)| {\n+                let name = Cow::from(enum_adt_def.variant(variant_index).name.as_str());\n+                // Is there anything we can do to support 128-bit C-Style enums?\n+                let value = discr.val as u64;\n+                (name, value)\n             }),\n             containing_scope,\n         ),\n@@ -152,7 +154,7 @@ fn build_enumeration_type_di_node<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     type_name: &str,\n     base_type: Ty<'tcx>,\n-    variants: &mut dyn Iterator<Item = (Discr<'tcx>, Cow<'tcx, str>)>,\n+    enumerators: impl Iterator<Item = (Cow<'tcx, str>, u64)>,\n     containing_scope: &'ll DIType,\n ) -> &'ll DIType {\n     let is_unsigned = match base_type.kind() {\n@@ -161,18 +163,15 @@ fn build_enumeration_type_di_node<'ll, 'tcx>(\n         _ => bug!(\"build_enumeration_type_di_node() called with non-integer tag type.\"),\n     };\n \n-    let enumerator_di_nodes: SmallVec<Option<&'ll DIType>> = variants\n-        .map(|(discr, variant_name)| {\n-            unsafe {\n-                Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n-                    DIB(cx),\n-                    variant_name.as_ptr().cast(),\n-                    variant_name.len(),\n-                    // FIXME: what if enumeration has i128 discriminant?\n-                    discr.val as i64,\n-                    is_unsigned,\n-                ))\n-            }\n+    let enumerator_di_nodes: SmallVec<Option<&'ll DIType>> = enumerators\n+        .map(|(name, value)| unsafe {\n+            Some(llvm::LLVMRustDIBuilderCreateEnumerator(\n+                DIB(cx),\n+                name.as_ptr().cast(),\n+                name.len(),\n+                value as i64,\n+                is_unsigned,\n+            ))\n         })\n         .collect();\n \n@@ -247,23 +246,27 @@ fn build_enumeration_type_di_node<'ll, 'tcx>(\n /// and a DW_TAG_member for each field (but not the discriminant).\n fn build_enum_variant_struct_type_di_node<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n-    enum_type: Ty<'tcx>,\n+    enum_type_and_layout: TyAndLayout<'tcx>,\n     enum_type_di_node: &'ll DIType,\n     variant_index: VariantIdx,\n     variant_def: &VariantDef,\n     variant_layout: TyAndLayout<'tcx>,\n ) -> &'ll DIType {\n-    debug_assert_eq!(variant_layout.ty, enum_type);\n+    debug_assert_eq!(variant_layout.ty, enum_type_and_layout.ty);\n \n     type_map::build_type_with_children(\n         cx,\n         type_map::stub(\n             cx,\n             Stub::Struct,\n-            UniqueTypeId::for_enum_variant_struct_type(cx.tcx, enum_type, variant_index),\n+            UniqueTypeId::for_enum_variant_struct_type(\n+                cx.tcx,\n+                enum_type_and_layout.ty,\n+                variant_index,\n+            ),\n             variant_def.name.as_str(),\n             // NOTE: We use size and align of enum_type, not from variant_layout:\n-            cx.size_and_align_of(enum_type),\n+            size_and_align_of(enum_type_and_layout),\n             Some(enum_type_di_node),\n             DIFlags::FlagZero,\n         ),\n@@ -290,9 +293,9 @@ fn build_enum_variant_struct_type_di_node<'ll, 'tcx>(\n                         type_di_node(cx, field_layout.ty),\n                     )\n                 })\n-                .collect()\n+                .collect::<SmallVec<_>>()\n         },\n-        |cx| build_generic_type_param_di_nodes(cx, enum_type),\n+        |cx| build_generic_type_param_di_nodes(cx, enum_type_and_layout.ty),\n     )\n     .di_node\n }\n@@ -398,6 +401,19 @@ pub fn build_generator_variant_struct_type_di_node<'ll, 'tcx>(\n     .di_node\n }\n \n+#[derive(Copy, Clone)]\n+enum DiscrResult {\n+    NoDiscriminant,\n+    Value(u128),\n+    Range(u128, u128),\n+}\n+\n+impl DiscrResult {\n+    fn opt_single_val(&self) -> Option<u128> {\n+        if let Self::Value(d) = *self { Some(d) } else { None }\n+    }\n+}\n+\n /// Returns the discriminant value corresponding to the variant index.\n ///\n /// Will return `None` if there is less than two variants (because then the enum won't have)\n@@ -407,30 +423,38 @@ fn compute_discriminant_value<'ll, 'tcx>(\n     cx: &CodegenCx<'ll, 'tcx>,\n     enum_type_and_layout: TyAndLayout<'tcx>,\n     variant_index: VariantIdx,\n-) -> Option<u64> {\n+) -> DiscrResult {\n     match enum_type_and_layout.layout.variants() {\n-        &Variants::Single { .. } => None,\n-        &Variants::Multiple { tag_encoding: TagEncoding::Direct, .. } => Some(\n-            enum_type_and_layout.ty.discriminant_for_variant(cx.tcx, variant_index).unwrap().val\n-                as u64,\n+        &Variants::Single { .. } => DiscrResult::NoDiscriminant,\n+        &Variants::Multiple { tag_encoding: TagEncoding::Direct, .. } => DiscrResult::Value(\n+            enum_type_and_layout.ty.discriminant_for_variant(cx.tcx, variant_index).unwrap().val,\n         ),\n         &Variants::Multiple {\n             tag_encoding: TagEncoding::Niche { ref niche_variants, niche_start, dataful_variant },\n             tag,\n             ..\n         } => {\n             if variant_index == dataful_variant {\n-                None\n+                let valid_range = enum_type_and_layout\n+                    .for_variant(cx, variant_index)\n+                    .largest_niche\n+                    .as_ref()\n+                    .unwrap()\n+                    .valid_range;\n+\n+                let min = valid_range.start.min(valid_range.end);\n+                let min = tag.size(cx).truncate(min);\n+\n+                let max = valid_range.start.max(valid_range.end);\n+                let max = tag.size(cx).truncate(max);\n+\n+                DiscrResult::Range(min, max)\n             } else {\n                 let value = (variant_index.as_u32() as u128)\n                     .wrapping_sub(niche_variants.start().as_u32() as u128)\n                     .wrapping_add(niche_start);\n                 let value = tag.size(cx).truncate(value);\n-                // NOTE(eddyb) do *NOT* remove this assert, until\n-                // we pass the full 128-bit value to LLVM, otherwise\n-                // truncation will be silent and remain undetected.\n-                assert_eq!(value as u64 as u128, value);\n-                Some(value as u64)\n+                DiscrResult::Value(value)\n             }\n         }\n     }"}, {"sha": "dae90a43f2659c32ab5277b6a09d4071dc074bff", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/enums/native.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Fenums%2Fnative.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -88,7 +88,7 @@ pub(super) fn build_enum_type_di_node<'ll, 'tcx>(\n                     variant_name: Cow::from(enum_adt_def.variant(variant_index).name.as_str()),\n                     variant_struct_type_di_node: super::build_enum_variant_struct_type_di_node(\n                         cx,\n-                        enum_type,\n+                        enum_type_and_layout,\n                         enum_type_di_node,\n                         variant_index,\n                         enum_adt_def.variant(variant_index),\n@@ -413,7 +413,13 @@ fn build_enum_variant_member_di_node<'ll, 'tcx>(\n             enum_type_and_layout.size.bits(),\n             enum_type_and_layout.align.abi.bits() as u32,\n             Size::ZERO.bits(),\n-            discr_value.map(|v| cx.const_u64(v)),\n+            discr_value.opt_single_val().map(|value| {\n+                // NOTE(eddyb) do *NOT* remove this assert, until\n+                // we pass the full 128-bit value to LLVM, otherwise\n+                // truncation will be silent and remain undetected.\n+                assert_eq!(value as u64 as u128, value);\n+                cx.const_u64(value as u64)\n+            }),\n             DIFlags::FlagZero,\n             variant_member_info.variant_struct_type_di_node,\n         )"}, {"sha": "e30622cbdced69260cb2107ba6459898fbcd8235", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/metadata/type_map.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmetadata%2Ftype_map.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -47,6 +47,8 @@ pub(super) enum UniqueTypeId<'tcx> {\n     VariantPart(Ty<'tcx>, private::HiddenZst),\n     /// The ID for the artificial struct type describing a single enum variant.\n     VariantStructType(Ty<'tcx>, VariantIdx, private::HiddenZst),\n+    /// The ID for the additional wrapper struct type describing an enum variant in CPP-like mode.\n+    VariantStructTypeCppLikeWrapper(Ty<'tcx>, VariantIdx, private::HiddenZst),\n     /// The ID of the artificial type we create for VTables.\n     VTableTy(Ty<'tcx>, Option<PolyExistentialTraitRef<'tcx>>, private::HiddenZst),\n }\n@@ -71,6 +73,15 @@ impl<'tcx> UniqueTypeId<'tcx> {\n         UniqueTypeId::VariantStructType(enum_ty, variant_idx, private::HiddenZst)\n     }\n \n+    pub fn for_enum_variant_struct_type_wrapper(\n+        tcx: TyCtxt<'tcx>,\n+        enum_ty: Ty<'tcx>,\n+        variant_idx: VariantIdx,\n+    ) -> Self {\n+        debug_assert_eq!(enum_ty, tcx.normalize_erasing_regions(ParamEnv::reveal_all(), enum_ty));\n+        UniqueTypeId::VariantStructTypeCppLikeWrapper(enum_ty, variant_idx, private::HiddenZst)\n+    }\n+\n     pub fn for_vtable_ty(\n         tcx: TyCtxt<'tcx>,\n         self_type: Ty<'tcx>,"}, {"sha": "89611fc0dee1b2d9cc8a73d0d125e9b20c1766aa", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -2079,6 +2079,19 @@ extern \"C\" {\n         Ty: &'a DIType,\n     ) -> &'a DIType;\n \n+    pub fn LLVMRustDIBuilderCreateStaticMemberType<'a>(\n+        Builder: &DIBuilder<'a>,\n+        Scope: &'a DIDescriptor,\n+        Name: *const c_char,\n+        NameLen: size_t,\n+        File: &'a DIFile,\n+        LineNo: c_uint,\n+        Ty: &'a DIType,\n+        Flags: DIFlags,\n+        val: Option<&'a Value>,\n+        AlignInBits: u32,\n+    ) -> &'a DIDerivedType;\n+\n     pub fn LLVMRustDIBuilderCreateLexicalBlock<'a>(\n         Builder: &DIBuilder<'a>,\n         Scope: &'a DIScope,"}, {"sha": "1dde6ae8edf1254036eb8dfcd6e78097be7e2467", "filename": "compiler/rustc_codegen_ssa/src/debuginfo/type_names.rs", "status": "modified", "additions": 4, "deletions": 48, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fdebuginfo%2Ftype_names.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -18,11 +18,10 @@ use rustc_hir::definitions::{DefPathData, DefPathDataName, DisambiguatedDefPathD\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, Mutability};\n use rustc_middle::ty::layout::{IntegerExt, TyAndLayout};\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::ty::{self, ExistentialProjection, GeneratorSubsts, ParamEnv, Ty, TyCtxt};\n-use rustc_target::abi::{Integer, TagEncoding, Variants};\n+use rustc_middle::ty::{self, ExistentialProjection, ParamEnv, Ty, TyCtxt};\n+use rustc_target::abi::Integer;\n use smallvec::SmallVec;\n \n-use std::borrow::Cow;\n use std::fmt::Write;\n \n use crate::debuginfo::wants_c_like_enum_debuginfo;\n@@ -98,7 +97,6 @@ fn push_debuginfo_type_name<'tcx>(\n \n             if let Some(ty_and_layout) = layout_for_cpp_like_fallback {\n                 msvc_enum_fallback(\n-                    tcx,\n                     ty_and_layout,\n                     &|output, visited| {\n                         push_item_name(tcx, def.did(), true, output);\n@@ -395,7 +393,6 @@ fn push_debuginfo_type_name<'tcx>(\n             if cpp_like_debuginfo && t.is_generator() {\n                 let ty_and_layout = tcx.layout_of(ParamEnv::reveal_all().and(t)).unwrap();\n                 msvc_enum_fallback(\n-                    tcx,\n                     ty_and_layout,\n                     &|output, visited| {\n                         push_closure_or_generator_name(tcx, def_id, substs, true, output, visited);\n@@ -428,58 +425,17 @@ fn push_debuginfo_type_name<'tcx>(\n \n     /// MSVC names enums differently than other platforms so that the debugging visualization\n     // format (natvis) is able to understand enums and render the active variant correctly in the\n-    // debugger. For more information, look in `src/etc/natvis/intrinsic.natvis` and\n-    // `EnumMemberDescriptionFactor::create_member_descriptions`.\n+    // debugger. For more information, look in\n+    // rustc_codegen_llvm/src/debuginfo/metadata/enums/cpp_like.rs.\n     fn msvc_enum_fallback<'tcx>(\n-        tcx: TyCtxt<'tcx>,\n         ty_and_layout: TyAndLayout<'tcx>,\n         push_inner: &dyn Fn(/*output*/ &mut String, /*visited*/ &mut FxHashSet<Ty<'tcx>>),\n         output: &mut String,\n         visited: &mut FxHashSet<Ty<'tcx>>,\n     ) {\n         debug_assert!(!wants_c_like_enum_debuginfo(ty_and_layout));\n-        let ty = ty_and_layout.ty;\n-\n         output.push_str(\"enum$<\");\n         push_inner(output, visited);\n-\n-        let variant_name = |variant_index| match ty.kind() {\n-            ty::Adt(adt_def, _) => {\n-                debug_assert!(adt_def.is_enum());\n-                Cow::from(adt_def.variant(variant_index).name.as_str())\n-            }\n-            ty::Generator(..) => GeneratorSubsts::variant_name(variant_index),\n-            _ => unreachable!(),\n-        };\n-\n-        if let Variants::Multiple {\n-            tag_encoding: TagEncoding::Niche { dataful_variant, .. },\n-            tag,\n-            variants,\n-            ..\n-        } = &ty_and_layout.variants\n-        {\n-            let dataful_variant_layout = &variants[*dataful_variant];\n-\n-            // calculate the range of values for the dataful variant\n-            let dataful_discriminant_range =\n-                dataful_variant_layout.largest_niche().unwrap().valid_range;\n-\n-            let min = dataful_discriminant_range.start;\n-            let min = tag.size(&tcx).truncate(min);\n-\n-            let max = dataful_discriminant_range.end;\n-            let max = tag.size(&tcx).truncate(max);\n-\n-            let dataful_variant_name = variant_name(*dataful_variant);\n-            write!(output, \", {}, {}, {}\", min, max, dataful_variant_name).unwrap();\n-        } else if let Variants::Single { index: variant_idx } = &ty_and_layout.variants {\n-            // Uninhabited enums can't be constructed and should never need to be visualized so\n-            // skip this step for them.\n-            if !ty_and_layout.abi.is_uninhabited() {\n-                write!(output, \", {}\", variant_name(*variant_idx)).unwrap();\n-            }\n-        }\n         push_close_angle_bracket(true, output);\n     }\n "}, {"sha": "4172ce3bb306a22add12777d422cf05834e58ef4", "filename": "compiler/rustc_index/src/vec.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_index%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fvec.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -172,7 +172,9 @@ impl<I: Idx, T> IndexVec<I, T> {\n     }\n \n     #[inline]\n-    pub fn indices(&self) -> impl DoubleEndedIterator<Item = I> + ExactSizeIterator + 'static {\n+    pub fn indices(\n+        &self,\n+    ) -> impl DoubleEndedIterator<Item = I> + ExactSizeIterator + Clone + 'static {\n         (0..self.len()).map(|n| I::new(n))\n     }\n "}, {"sha": "f9bffe6d8239230f1d571e47b0660f89d6274d42", "filename": "compiler/rustc_llvm/llvm-wrapper/RustWrapper.cpp", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FRustWrapper.cpp?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -924,6 +924,30 @@ extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateVariantMemberType(\n                                                fromRust(Flags), unwrapDI<DIType>(Ty)));\n }\n \n+extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateStaticMemberType(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMMetadataRef Scope,\n+    const char *Name,\n+    size_t NameLen,\n+    LLVMMetadataRef File,\n+    unsigned LineNo,\n+    LLVMMetadataRef Ty,\n+    LLVMRustDIFlags Flags,\n+    LLVMValueRef val,\n+    uint32_t AlignInBits\n+) {\n+  return wrap(Builder->createStaticMemberType(\n+    unwrapDI<DIDescriptor>(Scope),\n+    StringRef(Name, NameLen),\n+    unwrapDI<DIFile>(File),\n+    LineNo,\n+    unwrapDI<DIType>(Ty),\n+    fromRust(Flags),\n+    unwrap<llvm::ConstantInt>(val),\n+    AlignInBits\n+  ));\n+}\n+\n extern \"C\" LLVMMetadataRef LLVMRustDIBuilderCreateLexicalBlock(\n     LLVMRustDIBuilderRef Builder, LLVMMetadataRef Scope,\n     LLVMMetadataRef File, unsigned Line, unsigned Col) {"}, {"sha": "9f1aa525d1f552a54fdff1265d7e95f854d3c820", "filename": "src/etc/natvis/intrinsic.natvis", "status": "modified", "additions": 113, "deletions": 67, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/src%2Fetc%2Fnatvis%2Fintrinsic.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fintrinsic.natvis?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -1,4 +1,4 @@\n-<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n   <Type Name=\"str\">\n     <DisplayString>{(char*)data_ptr,[length]s8}</DisplayString>\n@@ -150,76 +150,122 @@\n     </Expand>\n   </Type>\n \n-  <!-- Directly tagged enums. $T1 is the type name -->\n+  <!--\n+    This is the visualizer for all enums. It takes care of selecting the active variant.\n+    See `compiler\\rustc_codegen_llvm\\src\\debuginfo\\metadata\\enums\\cpp_like.rs` for more information.\n+  -->\n   <Type Name=\"enum$&lt;*&gt;\">\n-    <Intrinsic Name=\"tag\" Expression=\"discriminant\" />\n-    <DisplayString Condition=\"tag() == 0\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 1\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 2\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 3\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 4\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 5\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 6\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 7\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 8\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 9\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 10\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 11\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 12\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 13\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 14\" Optional=\"true\">{tag(),en}</DisplayString>\n-    <DisplayString Condition=\"tag() == 15\" Optional=\"true\">{tag(),en}</DisplayString>\n+    <Intrinsic Name=\"in_range\" Expression=\"(start &lt;= end) ? ((tag &gt;= start) &amp;&amp; (tag &lt;= end)) : ((tag &gt;= start) || (tag &lt;= end))\">\n+      <Parameter Name=\"start\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"end\" Type=\"unsigned __int64\" />\n+    </Intrinsic>\n \n-    <Expand>\n-      <Synthetic Name=\"[variant]\">\n-        <DisplayString>{tag(),en}</DisplayString>\n-      </Synthetic>\n-      <ExpandedItem Condition=\"tag() == 0\">variant0</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 1\" Optional=\"true\">variant1</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 2\" Optional=\"true\">variant2</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 3\" Optional=\"true\">variant3</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 4\" Optional=\"true\">variant4</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 5\" Optional=\"true\">variant5</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 6\" Optional=\"true\">variant6</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 7\" Optional=\"true\">variant7</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 8\" Optional=\"true\">variant8</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 9\" Optional=\"true\">variant9</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 10\" Optional=\"true\">variant10</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 11\" Optional=\"true\">variant11</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 12\" Optional=\"true\">variant12</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 13\" Optional=\"true\">variant13</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 14\" Optional=\"true\">variant14</ExpandedItem>\n-      <ExpandedItem Condition=\"tag() == 15\" Optional=\"true\">variant15</ExpandedItem>\n-    </Expand>\n-  </Type>\n+    <Intrinsic Name=\"exact_match128\" Expression=\"(tag128_hi == discr_hi) &amp;&amp; (tag128_lo == discr_lo)\">\n+      <Parameter Name=\"discr_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"discr_lo\" Type=\"unsigned __int64\" />\n+    </Intrinsic>\n \n-  <!-- Single variant enums. $T1 is the name of the enum, $T2 is the name of the variant -->\n-  <Type Name=\"enum$&lt;*, *&gt;\">\n-    <DisplayString>{\"$T2\",sb}</DisplayString>\n-    <Expand>\n-      <Synthetic Name=\"[variant]\">\n-        <DisplayString>{\"$T2\",sb}</DisplayString>\n-      </Synthetic>\n-      <ExpandedItem>$T2</ExpandedItem>\n-    </Expand>\n-  </Type>\n+    <Intrinsic Name=\"lt128\" Expression=\"(x_hi &lt; y_hi) || ((x_hi == y_hi) &amp;&amp; (x_lo &lt; y_lo))\">\n+      <Parameter Name=\"x_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"x_lo\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"y_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"y_lo\" Type=\"unsigned __int64\" />\n+    </Intrinsic>\n \n-  <!-- Niche-layout enums. $T1 is the name of the enum, $T2 is the low value of the dataful\n-       variant tag, $T3 is the high value of the dataful variant tag, $T4 is the name of\n-       the dataful variant -->\n-  <Type Name=\"enum$&lt;*, *, *, *&gt;\">\n-    <Intrinsic Name=\"tag\" Expression=\"discriminant\" />\n-    <Intrinsic Name=\"is_dataful\" Expression=\"tag() &gt;= $T2 &amp;&amp; tag() &lt;= $T3\" />\n-    <DisplayString Condition=\"is_dataful()\">{\"$T4\",sb}({dataful_variant})</DisplayString>\n-    <DisplayString Condition=\"!is_dataful()\">{discriminant,en}</DisplayString>\n-    <Expand>\n-      <ExpandedItem Condition=\"is_dataful()\">dataful_variant</ExpandedItem>\n-      <Synthetic Condition=\"is_dataful()\" Name=\"[variant]\">\n-        <DisplayString>{\"$T4\",sb}</DisplayString>\n-      </Synthetic>\n-      <Synthetic Condition=\"!is_dataful()\" Name=\"[variant]\">\n-        <DisplayString>{discriminant,en}</DisplayString>\n-      </Synthetic>\n+    <Intrinsic Name=\"lt_or_eq128\" Expression=\"((x_hi == y_hi) &amp;&amp; (x_lo == y_lo)) || lt128(x_hi, x_lo, y_hi, y_lo)\">\n+      <Parameter Name=\"x_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"x_lo\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"y_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"y_lo\" Type=\"unsigned __int64\" />\n+    </Intrinsic>\n+\n+    <Intrinsic Name=\"in_range128\" Expression=\"lt_or_eq128(begin_hi, begin_lo, tag128_hi, tag128_lo) &amp;&amp; lt_or_eq128(tag128_hi, tag128_lo, end_hi, end_lo)\">\n+      <Parameter Name=\"begin_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"begin_lo\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"end_hi\" Type=\"unsigned __int64\" />\n+      <Parameter Name=\"end_lo\" Type=\"unsigned __int64\" />\n+    </Intrinsic>\n+\n+    <DisplayString Condition=\"tag == variant0.DISCR_EXACT\" Optional=\"true\">{variant0.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant1.DISCR_EXACT\" Optional=\"true\">{variant1.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant2.DISCR_EXACT\" Optional=\"true\">{variant2.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant3.DISCR_EXACT\" Optional=\"true\">{variant3.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant4.DISCR_EXACT\" Optional=\"true\">{variant4.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant5.DISCR_EXACT\" Optional=\"true\">{variant5.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant6.DISCR_EXACT\" Optional=\"true\">{variant6.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant7.DISCR_EXACT\" Optional=\"true\">{variant7.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant8.DISCR_EXACT\" Optional=\"true\">{variant8.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant9.DISCR_EXACT\" Optional=\"true\">{variant9.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant10.DISCR_EXACT\" Optional=\"true\">{variant10.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant11.DISCR_EXACT\" Optional=\"true\">{variant11.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant12.DISCR_EXACT\" Optional=\"true\">{variant12.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant13.DISCR_EXACT\" Optional=\"true\">{variant13.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant14.DISCR_EXACT\" Optional=\"true\">{variant14.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"tag == variant15.DISCR_EXACT\" Optional=\"true\">{variant15.NAME,en}</DisplayString>\n+\n+    <DisplayString Condition=\"in_range(variant_fallback.DISCR_BEGIN, variant_fallback.DISCR_END)\" Optional=\"true\">{variant_fallback.NAME,en}</DisplayString>\n+\n+    <DisplayString Condition=\"exact_match128(variant0.DISCR128_EXACT_HI, variant0.DISCR128_EXACT_LO)\" Optional=\"true\">{variant0.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant1.DISCR128_EXACT_HI, variant1.DISCR128_EXACT_LO)\" Optional=\"true\">{variant1.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant2.DISCR128_EXACT_HI, variant2.DISCR128_EXACT_LO)\" Optional=\"true\">{variant2.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant3.DISCR128_EXACT_HI, variant3.DISCR128_EXACT_LO)\" Optional=\"true\">{variant3.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant4.DISCR128_EXACT_HI, variant4.DISCR128_EXACT_LO)\" Optional=\"true\">{variant4.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant5.DISCR128_EXACT_HI, variant5.DISCR128_EXACT_LO)\" Optional=\"true\">{variant5.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant6.DISCR128_EXACT_HI, variant6.DISCR128_EXACT_LO)\" Optional=\"true\">{variant6.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant7.DISCR128_EXACT_HI, variant7.DISCR128_EXACT_LO)\" Optional=\"true\">{variant7.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant8.DISCR128_EXACT_HI, variant8.DISCR128_EXACT_LO)\" Optional=\"true\">{variant8.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant9.DISCR128_EXACT_HI, variant9.DISCR128_EXACT_LO)\" Optional=\"true\">{variant9.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant10.DISCR128_EXACT_HI, variant10.DISCR128_EXACT_LO)\" Optional=\"true\">{variant10.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant11.DISCR128_EXACT_HI, variant11.DISCR128_EXACT_LO)\" Optional=\"true\">{variant11.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant12.DISCR128_EXACT_HI, variant12.DISCR128_EXACT_LO)\" Optional=\"true\">{variant12.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant13.DISCR128_EXACT_HI, variant13.DISCR128_EXACT_LO)\" Optional=\"true\">{variant13.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant14.DISCR128_EXACT_HI, variant14.DISCR128_EXACT_LO)\" Optional=\"true\">{variant14.NAME,en}</DisplayString>\n+    <DisplayString Condition=\"exact_match128(variant15.DISCR128_EXACT_HI, variant15.DISCR128_EXACT_LO)\" Optional=\"true\">{variant15.NAME,en}</DisplayString>\n+\n+    <DisplayString\n+      Condition=\"in_range128(variant_fallback.DISCR128_BEGIN_HI, variant_fallback.DISCR128_BEGIN_LO, variant_fallback.DISCR128_END_HI, variant_fallback.DISCR128_END_LO)\"\n+      Optional=\"true\">{variant_fallback.NAME,en}</DisplayString>\n+\n+    <Expand HideRawView=\"true\">\n+      <ExpandedItem Condition=\"tag == variant0.DISCR_EXACT\" Optional=\"true\">variant0.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant1.DISCR_EXACT\" Optional=\"true\">variant1.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant2.DISCR_EXACT\" Optional=\"true\">variant2.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant3.DISCR_EXACT\" Optional=\"true\">variant3.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant4.DISCR_EXACT\" Optional=\"true\">variant4.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant5.DISCR_EXACT\" Optional=\"true\">variant5.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant6.DISCR_EXACT\" Optional=\"true\">variant6.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant7.DISCR_EXACT\" Optional=\"true\">variant7.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant8.DISCR_EXACT\" Optional=\"true\">variant8.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant9.DISCR_EXACT\" Optional=\"true\">variant9.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant10.DISCR_EXACT\" Optional=\"true\">variant10.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant11.DISCR_EXACT\" Optional=\"true\">variant11.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant12.DISCR_EXACT\" Optional=\"true\">variant12.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant13.DISCR_EXACT\" Optional=\"true\">variant13.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant14.DISCR_EXACT\" Optional=\"true\">variant14.value</ExpandedItem>\n+      <ExpandedItem Condition=\"tag == variant15.DISCR_EXACT\" Optional=\"true\">variant15.value</ExpandedItem>\n+\n+      <ExpandedItem Condition=\"in_range(variant_fallback.DISCR_BEGIN, variant_fallback.DISCR_END)\" Optional=\"true\">variant_fallback.value</ExpandedItem>\n+\n+      <ExpandedItem Condition=\"exact_match128(variant0.DISCR128_EXACT_HI, variant0.DISCR128_EXACT_LO)\" Optional=\"true\">variant0.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant1.DISCR128_EXACT_HI, variant1.DISCR128_EXACT_LO)\" Optional=\"true\">variant1.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant2.DISCR128_EXACT_HI, variant2.DISCR128_EXACT_LO)\" Optional=\"true\">variant2.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant3.DISCR128_EXACT_HI, variant3.DISCR128_EXACT_LO)\" Optional=\"true\">variant3.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant4.DISCR128_EXACT_HI, variant4.DISCR128_EXACT_LO)\" Optional=\"true\">variant4.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant5.DISCR128_EXACT_HI, variant5.DISCR128_EXACT_LO)\" Optional=\"true\">variant5.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant6.DISCR128_EXACT_HI, variant6.DISCR128_EXACT_LO)\" Optional=\"true\">variant6.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant7.DISCR128_EXACT_HI, variant7.DISCR128_EXACT_LO)\" Optional=\"true\">variant7.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant8.DISCR128_EXACT_HI, variant8.DISCR128_EXACT_LO)\" Optional=\"true\">variant8.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant9.DISCR128_EXACT_HI, variant9.DISCR128_EXACT_LO)\" Optional=\"true\">variant9.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant10.DISCR128_EXACT_HI, variant10.DISCR128_EXACT_LO)\" Optional=\"true\">variant10.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant11.DISCR128_EXACT_HI, variant11.DISCR128_EXACT_LO)\" Optional=\"true\">variant11.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant12.DISCR128_EXACT_HI, variant12.DISCR128_EXACT_LO)\" Optional=\"true\">variant12.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant13.DISCR128_EXACT_HI, variant13.DISCR128_EXACT_LO)\" Optional=\"true\">variant13.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant14.DISCR128_EXACT_HI, variant14.DISCR128_EXACT_LO)\" Optional=\"true\">variant14.value</ExpandedItem>\n+      <ExpandedItem Condition=\"exact_match128(variant15.DISCR128_EXACT_HI, variant15.DISCR128_EXACT_LO)\" Optional=\"true\">variant15.value</ExpandedItem>\n+\n+      <ExpandedItem\n+        Condition=\"in_range128(variant_fallback.DISCR128_BEGIN_HI, variant_fallback.DISCR128_BEGIN_LO, variant_fallback.DISCR128_END_HI, variant_fallback.DISCR128_END_LO)\"\n+        Optional=\"true\">variant_fallback.value</ExpandedItem>\n     </Expand>\n   </Type>\n </AutoVisualizer>"}, {"sha": "95b0819cc38ba3551069609a0de7c40855b3c7a2", "filename": "src/test/debuginfo/generator-objects.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgenerator-objects.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -42,30 +42,25 @@\n // cdb-command: g\n // cdb-command: dx b\n // cdb-check: b                : Unresumed [Type: enum$<generator_objects::main::generator_env$0>]\n-// cdb-check:    [variant]        : Unresumed\n // cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 5 [Type: int *]\n \n // cdb-command: g\n // cdb-command: dx b\n // cdb-check: b                : Suspend0 [Type: enum$<generator_objects::main::generator_env$0>]\n-// cdb-check:    [variant]        : Suspend0\n // cdb-check:    [+0x[...]] c                : 6 [Type: int]\n // cdb-check:    [+0x[...]] d                : 7 [Type: int]\n // cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 5 [Type: int *]\n \n // cdb-command: g\n // cdb-command: dx b\n // cdb-check: b                : Suspend1 [Type: enum$<generator_objects::main::generator_env$0>]\n-// cdb-check:    [variant]        : Suspend1\n // cdb-check:    [+0x[...]] c                : 7 [Type: int]\n // cdb-check:    [+0x[...]] d                : 8 [Type: int]\n // cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 6 [Type: int *]\n \n // cdb-command: g\n // cdb-command: dx b\n // cdb-check: b                : Returned [Type: enum$<generator_objects::main::generator_env$0>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<generator_objects::main::generator_env$0>]\n-// cdb-check:    [variant]        : Returned\n // cdb-check:    [+0x[...]] _ref__a          : 0x[...] : 6 [Type: int *]\n \n #![feature(omit_gdb_pretty_printer_section, generators, generator_trait)]"}, {"sha": "b1ca5dfa1c77ca029c51067b55ddbe67760cb0d2", "filename": "src/test/debuginfo/msvc-pretty-enums.rs", "status": "modified", "additions": 111, "deletions": 31, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmsvc-pretty-enums.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -4,69 +4,110 @@\n // cdb-command: g\n \n // cdb-command: dx a\n-// cdb-check:a                :  Some({...}) [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n-// cdb-check:    [variant]        :  Some\n+// cdb-check:a                : Some [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum> >]\n // cdb-check:    [+0x000] __0              : Low (0x2) [Type: msvc_pretty_enums::CStyleEnum]\n \n // cdb-command: dx b\n-// cdb-check:b                : None [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum>, 2, 16, Some>]\n-// cdb-check:    [variant]        : None\n+// cdb-check:b                : None [Type: enum$<core::option::Option<msvc_pretty_enums::CStyleEnum> >]\n \n // cdb-command: dx c\n-// cdb-check:c                : Tag1 [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [variant]        : Tag1\n+// cdb-check:c                : Tag1 [Type: enum$<msvc_pretty_enums::NicheLayoutEnum>]\n \n // cdb-command: dx d\n-// cdb-check:d                :  Data({...}) [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [variant]        :  Data\n+// cdb-check:d                : Data [Type: enum$<msvc_pretty_enums::NicheLayoutEnum>]\n // cdb-check:    [+0x000] my_data          : High (0x10) [Type: msvc_pretty_enums::CStyleEnum]\n \n // cdb-command: dx e\n-// cdb-check:e                : Tag2 [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<msvc_pretty_enums::NicheLayoutEnum, 2, 16, Data>]\n-// cdb-check:    [variant]        : Tag2\n+// cdb-check:e                : Tag2 [Type: enum$<msvc_pretty_enums::NicheLayoutEnum>]\n \n // cdb-command: dx f\n-// cdb-check:f                :  Some({...}) [Type: enum$<core::option::Option<ref$<u32> >, 1, [...], Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<ref$<u32> >, 1, [...], Some>]\n-// cdb-check:    [variant]        :  Some\n+// cdb-check:f                : Some [Type: enum$<core::option::Option<ref$<u32> > >]\n // cdb-check:    [+0x000] __0              : 0x[...] : 0x1 [Type: unsigned int *]\n \n // cdb-command: dx g\n-// cdb-check:g                : None [Type: enum$<core::option::Option<ref$<u32> >, 1, [...], Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<ref$<u32> >, 1, [...], Some>]\n-// cdb-check:    [variant]        : None\n+// cdb-check:g                : None [Type: enum$<core::option::Option<ref$<u32> > >]\n \n // cdb-command: dx h\n // cdb-check:h                : Some [Type: enum$<core::option::Option<u32> >]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<u32> >]\n-// cdb-check:    [variant]        : Some\n // cdb-check:    [+0x004] __0              : 0xc [Type: unsigned int]\n \n // cdb-command: dx i\n // cdb-check:i                : None [Type: enum$<core::option::Option<u32> >]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<u32> >]\n-// cdb-check:    [variant]        : None\n \n // cdb-command: dx j\n // cdb-check:j                : High (0x10) [Type: msvc_pretty_enums::CStyleEnum]\n \n // cdb-command: dx k\n-// cdb-check:k                :  Some({...}) [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>]\n-// cdb-check:    [variant]        :  Some\n+// cdb-check:k                : Some [Type: enum$<core::option::Option<alloc::string::String> >]\n // cdb-check:    [+0x000] __0              : \"IAMA optional string!\" [Type: alloc::string::String]\n \n // cdb-command: dx l\n-// cdb-check:l                :  Ok [Type: enum$<core::result::Result<u32,enum$<msvc_pretty_enums::Empty> >, Ok>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::result::Result<u32,enum$<msvc_pretty_enums::Empty> >, Ok>]\n-// cdb-check:    [variant]        :  Ok\n+// cdb-check:l                : Ok [Type: enum$<core::result::Result<u32,enum$<msvc_pretty_enums::Empty> > >]\n // cdb-check:    [+0x000] __0              : 0x2a [Type: unsigned int]\n \n+// cdb-command: dx niche128_some\n+// cdb-check:niche128_some    : Some [Type: enum$<core::option::Option<core::num::nonzero::NonZeroI128> >]\n+// Note: we can't actually read the value of the field because CDB cannot handle 128 bit integers.\n+// cdb-check:    [+0x000] __0 [...] [Type: core::num::nonzero::NonZeroI128]\n+\n+// cdb-command: dx niche128_none\n+// cdb-check: niche128_none    : None [Type: enum$<core::option::Option<core::num::nonzero::NonZeroI128> >]\n+\n+// cdb-command: dx niche_w_fields_1_some,d\n+// cdb-check: niche_w_fields_1_some,d : A [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields1>]\n+// cdb-check:     [+0x[...]] __0              : 0x[...] : 77 [Type: unsigned char *]\n+// cdb-check:     [+0x[...]] __1              : 7 [Type: unsigned int]\n+\n+// cdb-command: dx niche_w_fields_1_none,d\n+// cdb-check: niche_w_fields_1_none,d : B [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields1>]\n+// cdb-check:     [+0x[...]] __0              : 99 [Type: unsigned int]\n+\n+// cdb-command: dx niche_w_fields_2_some,d\n+// cdb-check: niche_w_fields_2_some,d : A [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields2>]\n+// cdb-check:     [<Raw View>]     [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields2>]\n+// cdb-check:     [+0x[...]] __0              : 800 [Type: core::num::nonzero::NonZeroU32]\n+// cdb-check:     [+0x[...]] __1              : 900 [Type: unsigned __int64]\n+\n+// cdb-command: dx niche_w_fields_2_none,d\n+// cdb-check: niche_w_fields_2_none,d : B [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields2>]\n+// cdb-check:     [+0x[...]] __0              : 1000 [Type: unsigned __int64]\n+\n+// cdb-command: dx niche_w_fields_3_some,d\n+// cdb-check: niche_w_fields_3_some,d : A [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+// cdb-check:     [+0x[...]] __0              : 137 [Type: unsigned char]\n+// cdb-check:     [+0x[...]] __1              : true [Type: bool]\n+\n+// cdb-command: dx niche_w_fields_3_niche1,d\n+// cdb-check: niche_w_fields_3_niche1,d : B [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+// cdb-check:     [+0x[...]] __0              : 12 [Type: unsigned char]\n+\n+// cdb-command: dx niche_w_fields_3_niche2,d\n+// cdb-check: niche_w_fields_3_niche2,d : C [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+// cdb-check:     [+0x[...]] __0              : false [Type: bool]\n+\n+// cdb-command: dx niche_w_fields_3_niche3,d\n+// cdb-check: niche_w_fields_3_niche3,d : D [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+// cdb-check:     [+0x[...]] __0              : 34 [Type: unsigned char]\n+\n+// cdb-command: dx niche_w_fields_3_niche4,d\n+// cdb-check: niche_w_fields_3_niche4,d : E [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+// cdb-check:     [+0x[...]] __0              : 56 [Type: unsigned char]\n+\n+// cdb-command: dx niche_w_fields_3_niche5,d\n+// cdb-check: niche_w_fields_3_niche5,d : F [Type: enum$<msvc_pretty_enums::NicheLayoutWithFields3>]\n+\n+// cdb-command: dx -r3 niche_w_fields_std_result_ok,d\n+// cdb-check: niche_w_fields_std_result_ok,d : Ok [Type: enum$<core::result::Result<alloc::boxed::Box<slice$<u8>,alloc::alloc::Global>,u64> >]\n+// cdb-check:    [+0x[...]] __0              [Type: alloc::boxed::Box<slice$<u8>,alloc::alloc::Global>]\n+// cdb-check:        [+0x[...]] data_ptr         : [...]\n+// cdb-check:        [+0x[...]] length           : 3 [...]\n+\n+// cdb-command: dx -r3 niche_w_fields_std_result_err,d\n+// cdb-check: niche_w_fields_std_result_err,d : Err [Type: enum$<core::result::Result<alloc::boxed::Box<slice$<u8>,alloc::alloc::Global>,u64> >]\n+// cdb-check:    [+0x[...]] __0              : 789 [Type: unsigned __int64]\n+\n+use std::num::{NonZeroI128, NonZeroU32};\n+\n pub enum CStyleEnum {\n     Low = 2,\n     High = 16,\n@@ -80,6 +121,27 @@ pub enum NicheLayoutEnum {\n \n pub enum Empty {}\n \n+// The following three types will use a niche layout once\n+// https://github.com/rust-lang/rust/pull/94075 is merged:\n+enum NicheLayoutWithFields1<'a> {\n+    A(&'a u8, u32),\n+    B(u32),\n+}\n+\n+enum NicheLayoutWithFields2 {\n+    A(NonZeroU32, usize),\n+    B(usize),\n+}\n+\n+enum NicheLayoutWithFields3 {\n+    A(u8, bool),\n+    B(u8),\n+    C(bool),\n+    D(u8),\n+    E(u8),\n+    F,\n+}\n+\n fn main() {\n     let a = Some(CStyleEnum::Low);\n     let b = Option::<CStyleEnum>::None;\n@@ -93,6 +155,24 @@ fn main() {\n     let j = CStyleEnum::High;\n     let k = Some(\"IAMA optional string!\".to_string());\n     let l = Result::<u32, Empty>::Ok(42);\n+    let niche128_some = Some(NonZeroI128::new(123456).unwrap());\n+    let niche128_none: Option<NonZeroI128> = None;\n+\n+    let niche_w_fields_1_some = NicheLayoutWithFields1::A(&77, 7);\n+    let niche_w_fields_1_none = NicheLayoutWithFields1::B(99);\n+\n+    let niche_w_fields_2_some = NicheLayoutWithFields2::A(NonZeroU32::new(800).unwrap(), 900);\n+    let niche_w_fields_2_none = NicheLayoutWithFields2::B(1000);\n+\n+    let niche_w_fields_3_some = NicheLayoutWithFields3::A(137, true);\n+    let niche_w_fields_3_niche1 = NicheLayoutWithFields3::B(12);\n+    let niche_w_fields_3_niche2 = NicheLayoutWithFields3::C(false);\n+    let niche_w_fields_3_niche3 = NicheLayoutWithFields3::D(34);\n+    let niche_w_fields_3_niche4 = NicheLayoutWithFields3::E(56);\n+    let niche_w_fields_3_niche5 = NicheLayoutWithFields3::F;\n+\n+    let niche_w_fields_std_result_ok: Result<Box<[u8]>, u64> = Ok(vec![1, 2, 3].into());\n+    let niche_w_fields_std_result_err: Result<Box<[u8]>, u64> = Err(789);\n \n     zzz(); // #break\n }"}, {"sha": "38a9633c9bfce556654e428b7af0b85acdb0e9e5", "filename": "src/test/debuginfo/msvc-scalarpair-params.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/src%2Ftest%2Fdebuginfo%2Fmsvc-scalarpair-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/src%2Ftest%2Fdebuginfo%2Fmsvc-scalarpair-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmsvc-scalarpair-params.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -19,11 +19,9 @@\n \n // cdb-command: dx o1\n // cdb-check:o1               : Some [Type: enum$<core::option::Option<u32> >]\n-// cdb-check:    [variant]        : Some\n // cdb-check:    [+0x004] __0              : 0x4d2 [Type: [...]]\n // cdb-command: dx o2\n // cdb-check:o2               : Some [Type: enum$<core::option::Option<u64> >]\n-// cdb-check:    [variant]        : Some\n // cdb-check:    [+0x008] __0              : 0x162e [Type: unsigned __int64]\n \n // cdb-command: g\n@@ -89,7 +87,7 @@ fn slice(s: &[u8]) {\n     zzz(); // #break\n }\n \n-fn zzz() { }\n+fn zzz() {}\n \n fn main() {\n     range(10..12, 20..30);"}, {"sha": "fe44c42aa5312d4ecc4990f16657bfd006ca4d31", "filename": "src/test/debuginfo/pretty-std.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fpretty-std.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -39,7 +39,6 @@\n // gdb-command: print some_string\n // gdb-check:$8 = Some = {\"IAMA \"...}\n \n-\n // === LLDB TESTS ==================================================================================\n \n // lldb-command: run\n@@ -65,7 +64,6 @@\n // lldb-command: print os_string\n // lldb-check:[...]$6 = \"IAMA OS string \ud83d\ude03\"[...]\n \n-\n // === CDB TESTS ==================================================================================\n \n // cdb-command: g\n@@ -120,18 +118,15 @@\n // cdb-command: dx some\n // cdb-check:some             : Some [Type: enum$<core::option::Option<i16> >]\n // cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<i16> >]\n-// cdb-check:    [variant]        : Some\n // cdb-check:    [+0x002] __0              : 8 [Type: short]\n \n // cdb-command: dx none\n // cdb-check:none             : None [Type: enum$<core::option::Option<i64> >]\n // cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<i64> >]\n-// cdb-check:    [variant]        : None\n \n // cdb-command: dx some_string\n-// cdb-check:some_string      :  Some({...}) [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>]\n-// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<alloc::string::String>, 1, [...], Some>]\n-// cdb-check:    [variant]        :  Some\n+// cdb-check:some_string      : Some [Type: enum$<core::option::Option<alloc::string::String> >]\n+// cdb-check:    [<Raw View>]     [Type: enum$<core::option::Option<alloc::string::String> >]\n // cdb-check:    [+0x000] __0              : \"IAMA optional string!\" [Type: alloc::string::String]\n \n // cdb-command: dx linkedlist\n@@ -153,7 +148,6 @@ use std::collections::{LinkedList, VecDeque};\n use std::ffi::OsString;\n \n fn main() {\n-\n     // &[]\n     let slice: &[i32] = &[0, 1, 2, 3];\n \n@@ -188,4 +182,6 @@ fn main() {\n     zzz(); // #break\n }\n \n-fn zzz() { () }\n+fn zzz() {\n+    ()\n+}"}, {"sha": "426d9ddf2517bd5312babf82d5f2b81da5863470", "filename": "src/test/debuginfo/type-names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/622da5d834e862112e860db1fc0404bd8604f578/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/622da5d834e862112e860db1fc0404bd8604f578/src%2Ftest%2Fdebuginfo%2Ftype-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftype-names.rs?ref=622da5d834e862112e860db1fc0404bd8604f578", "patch": "@@ -240,14 +240,14 @@\n // cdb-check:struct tuple$<usize (*)(f64),usize> rust_fn_with_return_value = [...]\n // cdb-check:struct tuple$<void (*)(enum$<core::result::Result<char,f64> >),usize> unsafe_fn = [...]\n // cdb-check:struct tuple$<void (*)(isize),usize> extern_c_fn = [...]\n-// cdb-check:struct tuple$<void (*)(enum$<core::option::Option<isize> >,enum$<core::option::Option<ref$<type_names::mod1::Struct2> >, 1, [...], Some>),usize> rust_fn = [...]\n+// cdb-check:struct tuple$<void (*)(enum$<core::option::Option<isize> >,enum$<core::option::Option<ref$<type_names::mod1::Struct2> > >),usize> rust_fn = [...]\n // cdb-command:dv /t *_function*\n // cdb-check:struct tuple$<isize (*)(ptr_const$<u8>, ...),usize> variadic_function = [...]\n // cdb-check:struct tuple$<type_names::mod1::mod2::Struct3 (*)(type_names::mod1::mod2::Struct3),usize> generic_function_struct3 = [...]\n // cdb-check:struct tuple$<isize (*)(isize),usize> generic_function_int = [...]\n // cdb-command:dx Debugger.State.Scripts.@\"type-names.cdb\".Contents.getFunctionDetails(\"rust_fn\")\n // cdb-check:Return Type: void\n-// cdb-check:Parameter Types: enum$<core::option::Option<isize> >,enum$<core::option::Option<ref$<type_names::mod1::Struct2> >, 1, [...], Some>\n+// cdb-check:Parameter Types: enum$<core::option::Option<isize> >,enum$<core::option::Option<ref$<type_names::mod1::Struct2> > >\n // cdb-command:dx Debugger.State.Scripts.@\"type-names.cdb\".Contents.getFunctionDetails(\"rust_fn_with_return_value\")\n // cdb-check:Return Type: usize\n // cdb-check:Parameter Types: f64"}]}