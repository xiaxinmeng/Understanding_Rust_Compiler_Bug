{"sha": "ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "node_id": "C_kwDOAAsO6NoAKGFkOGUxZGMyODYzZjYzYzM1ZWYzY2VlZjMwNjRkMDg1MWExZDI1ODI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-01T01:15:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-01T01:15:02Z"}, "message": "Auto merge of #107536 - GuillaumeGomez:rollup-xv7dx2h, r=GuillaumeGomez\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #106898 (Include both md and yaml ICE ticket templates)\n - #107331 (Clean up eslint annotations and remove unused JS function)\n - #107348 (small refactor to new projection code)\n - #107354 (rustdoc: update Source Serif 4 from 4.004 to 4.005)\n - #107412 (avoid needless checks)\n - #107467 (Improve enum checks)\n - #107486 (Track bound types like bound regions)\n - #107491 (rustdoc: remove unused CSS from `.setting-check`)\n - #107508 (`Edition` micro refactor)\n - #107525 (PointeeInfo is advisory only)\n - #107527 (rustdoc: stop making unstable items transparent)\n - #107535 (Replace unwrap with ? in TcpListener doc)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "64d8db18dc8c8e118fd859c74061a34efbcae9d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64d8db18dc8c8e118fd859c74061a34efbcae9d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "html_url": "https://github.com/rust-lang/rust/commit/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5b6ed253c42a69b93e7447fb0874a89ab6bc1cfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5b6ed253c42a69b93e7447fb0874a89ab6bc1cfb", "html_url": "https://github.com/rust-lang/rust/commit/5b6ed253c42a69b93e7447fb0874a89ab6bc1cfb"}, {"sha": "adc3f8a44b943463577a5f8870da8fd18b749351", "url": "https://api.github.com/repos/rust-lang/rust/commits/adc3f8a44b943463577a5f8870da8fd18b749351", "html_url": "https://github.com/rust-lang/rust/commit/adc3f8a44b943463577a5f8870da8fd18b749351"}], "stats": {"total": 929, "additions": 522, "deletions": 407}, "files": [{"sha": "2afcd210a6eb7ca5c12fbb2cdc7f912f7183829a", "filename": ".github/ISSUE_TEMPLATE/ice.md", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/.github%2FISSUE_TEMPLATE%2Fice.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/.github%2FISSUE_TEMPLATE%2Fice.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.md?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -0,0 +1,49 @@\n+---\n+name: Internal Compiler Error\n+about: Create a report for an internal compiler error in rustc.\n+labels: C-bug, I-ICE, T-compiler\n+---\n+<!--\n+Thank you for finding an Internal Compiler Error! \ud83e\uddca  If possible, try to provide\n+a minimal verifiable example. You can read \"Rust Bug Minimization Patterns\" for\n+how to create smaller examples.\n+http://blog.pnkfx.org/blog/2019/11/18/rust-bug-minimization-patterns/\n+-->\n+\n+### Code\n+\n+```Rust\n+<code>\n+```\n+\n+\n+### Meta\n+<!--\n+If you're using the stable version of the compiler, you should also check if the\n+bug also exists in the beta or nightly versions.\n+-->\n+\n+`rustc --version --verbose`:\n+```\n+<version>\n+```\n+\n+### Error output\n+\n+```\n+<output>\n+```\n+\n+<!--\n+Include a backtrace in the code block by setting `RUST_BACKTRACE=1` in your\n+environment. E.g. `RUST_BACKTRACE=1 cargo build`.\n+-->\n+<details><summary><strong>Backtrace</strong></summary>\n+<p>\n+\n+```\n+<backtrace>\n+```\n+\n+</p>\n+</details>"}, {"sha": "8d25bb41c08066fcf5d2d99cc18d9393c2377093", "filename": ".github/ISSUE_TEMPLATE/ice.yaml", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/.github%2FISSUE_TEMPLATE%2Fice.yaml", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/.github%2FISSUE_TEMPLATE%2Fice.yaml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.github%2FISSUE_TEMPLATE%2Fice.yaml?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -1,5 +1,5 @@\n-name: Internal Compiler Error\n-description: Create a report for an internal compiler error in `rustc`\n+name: Internal Compiler Error (Structured form)\n+description: For now, you'll want to use the other ICE template, as GitHub forms have strict limits on the size of fields so backtraces cannot be pasted directly.\n labels: [\"C-bug\", \"I-ICE\", \"T-compiler\"]\n title: \"[ICE]: \"\n body:\n@@ -79,4 +79,4 @@ body:\n       label: Anything else?\n       description: If you have more details you want to give us to reproduce this issue, please add it here\n     validations:\n-      required: false\n\\ No newline at end of file\n+      required: false"}, {"sha": "5af6206c0bb80dcabec6169f2ec00aabfd3ca146", "filename": "compiler/rustc_abi/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_abi%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_abi%2Fsrc%2Flib.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -1456,6 +1456,8 @@ pub enum PointerKind {\n     UniqueOwned,\n }\n \n+/// Note that this information is advisory only, and backends are free to ignore it.\n+/// It can only be used to encode potential optimizations, but no critical information.\n #[derive(Copy, Clone, Debug)]\n pub struct PointeeInfo {\n     pub size: Size,"}, {"sha": "eece99a3eef0358c29f2792a6762955e1e9a03c6", "filename": "compiler/rustc_ast/src/util/comments.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fcomments.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -58,23 +58,24 @@ pub fn beautify_doc_string(data: Symbol, kind: CommentKind) -> Symbol {\n         // In case we have doc comments like `/**` or `/*!`, we want to remove stars if they are\n         // present. However, we first need to strip the empty lines so they don't get in the middle\n         // when we try to compute the \"horizontal trim\".\n-        let lines = if kind == CommentKind::Block {\n-            // Whatever happens, we skip the first line.\n-            let mut i = lines\n-                .get(0)\n-                .map(|l| if l.trim_start().starts_with('*') { 0 } else { 1 })\n-                .unwrap_or(0);\n-            let mut j = lines.len();\n-\n-            while i < j && lines[i].trim().is_empty() {\n-                i += 1;\n-            }\n-            while j > i && lines[j - 1].trim().is_empty() {\n-                j -= 1;\n+        let lines = match kind {\n+            CommentKind::Block => {\n+                // Whatever happens, we skip the first line.\n+                let mut i = lines\n+                    .get(0)\n+                    .map(|l| if l.trim_start().starts_with('*') { 0 } else { 1 })\n+                    .unwrap_or(0);\n+                let mut j = lines.len();\n+\n+                while i < j && lines[i].trim().is_empty() {\n+                    i += 1;\n+                }\n+                while j > i && lines[j - 1].trim().is_empty() {\n+                    j -= 1;\n+                }\n+                &lines[i..j]\n             }\n-            &lines[i..j]\n-        } else {\n-            lines\n+            CommentKind::Line => lines,\n         };\n \n         for line in lines {"}, {"sha": "fa8567eac609074925d82b465c6bae7feaf21ea9", "filename": "compiler/rustc_ast_pretty/src/pprust/state.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_pretty%2Fsrc%2Fpprust%2Fstate.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -131,7 +131,7 @@ pub fn print_crate<'a>(\n \n         // Currently, in Rust 2018 we don't have `extern crate std;` at the crate\n         // root, so this is not needed, and actually breaks things.\n-        if edition == Edition::Edition2015 {\n+        if edition.rust_2015() {\n             // `#![no_std]`\n             let fake_attr = attr::mk_attr_word(g, ast::AttrStyle::Inner, sym::no_std, DUMMY_SP);\n             s.print_attribute(&fake_attr);"}, {"sha": "40f518b33cfb66dbcf4b485a2d32ab3a71b2aa1a", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -344,7 +344,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     } else {\n                         err.span_help(source_info.span, \"try removing `&mut` here\");\n                     }\n-                } else if decl.mutability == Mutability::Not {\n+                } else if decl.mutability.is_not() {\n                     if matches!(\n                         decl.local_info,\n                         Some(box LocalInfo::User(ClearCrossCrate::Set(BindingForm::ImplicitSelf("}, {"sha": "2605a1491fb35427609d13dd00475820eb2fdfc1", "filename": "compiler/rustc_borrowck/src/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fmod.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -2028,7 +2028,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                             }\n                         };\n \n-                        if ty_to_mut == Mutability::Mut && ty_mut == Mutability::Not {\n+                        if ty_to_mut.is_mut() && ty_mut.is_not() {\n                             span_mirbug!(\n                                 self,\n                                 rvalue,"}, {"sha": "c0b23585d3a774c6871655808a1968e48e9f0d23", "filename": "compiler/rustc_codegen_llvm/src/context.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcontext.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -150,17 +150,14 @@ pub unsafe fn create_module<'ll>(\n             target_data_layout =\n                 \"e-m:x-p:32:32-p270:32:32-p271:32:32-p272:64:64-i64:64-f80:32-n8:16:32-a:0:32-S32\"\n                     .to_string();\n-        }\n-        if sess.target.arch == \"wasm32\" {\n+        } else if sess.target.arch == \"wasm32\" {\n             target_data_layout = target_data_layout.replace(\"-p10:8:8-p20:8:8\", \"\");\n         }\n     }\n     if llvm_version < (16, 0, 0) {\n         if sess.target.arch == \"s390x\" {\n             target_data_layout = target_data_layout.replace(\"-v128:64\", \"\");\n-        }\n-\n-        if sess.target.arch == \"riscv64\" {\n+        } else if sess.target.arch == \"riscv64\" {\n             target_data_layout = target_data_layout.replace(\"-n32:64-\", \"-n64-\");\n         }\n     }"}, {"sha": "d865d5bc974e069f27714768bb9812ad999134cf", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -622,10 +622,9 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         let alloc = alloc.inner();\n         if is_write {\n             // Write access. These are never allowed, but we give a targeted error message.\n-            if alloc.mutability == Mutability::Not {\n-                Err(err_ub!(WriteToReadOnly(alloc_id)).into())\n-            } else {\n-                Err(ConstEvalErrKind::ModifiedGlobal.into())\n+            match alloc.mutability {\n+                Mutability::Not => Err(err_ub!(WriteToReadOnly(alloc_id)).into()),\n+                Mutability::Mut => Err(ConstEvalErrKind::ModifiedGlobal.into()),\n             }\n         } else {\n             // Read access. These are usually allowed, with some exceptions."}, {"sha": "a87ce0053e8a038932d7f71b711ce741094de771", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -304,7 +304,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .into());\n         };\n \n-        if alloc.mutability == Mutability::Not {\n+        if alloc.mutability.is_not() {\n             throw_ub_format!(\"deallocating immutable allocation {alloc_id:?}\");\n         }\n         if alloc_kind != kind {\n@@ -631,7 +631,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         }\n \n         let (_kind, alloc) = self.memory.alloc_map.get_mut(id).unwrap();\n-        if alloc.mutability == Mutability::Not {\n+        if alloc.mutability.is_not() {\n             throw_ub!(WriteToReadOnly(id))\n         }\n         Ok((alloc, &mut self.machine))"}, {"sha": "72f456138ef56c63e38652be3bf18a4d105b53f5", "filename": "compiler/rustc_const_eval/src/transform/validate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fvalidate.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -754,7 +754,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 // FIXME(JakobDegen) The validator should check that `self.mir_phase <\n                 // DropsLowered`. However, this causes ICEs with generation of drop shims, which\n                 // seem to fail to set their `MirPhase` correctly.\n-                if *kind == RetagKind::Raw || *kind == RetagKind::TwoPhase {\n+                if matches!(kind, RetagKind::Raw | RetagKind::TwoPhase) {\n                     self.fail(location, format!(\"explicit `{:?}` is forbidden\", kind));\n                 }\n             }"}, {"sha": "faeaa548619708f5c2c0621f27ac25073b68b715", "filename": "compiler/rustc_errors/src/emitter.rs", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_errors%2Fsrc%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Femitter.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -2113,30 +2113,38 @@ impl EmitterWriter {\n                         }\n                     }\n                     for sugg in suggestions {\n-                        if sugg.style == SuggestionStyle::CompletelyHidden {\n-                            // do not display this suggestion, it is meant only for tools\n-                        } else if sugg.style == SuggestionStyle::HideCodeAlways {\n-                            if let Err(e) = self.emit_message_default(\n-                                &MultiSpan::new(),\n-                                &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n-                                args,\n-                                &None,\n-                                &Level::Help,\n-                                max_line_num_len,\n-                                true,\n-                                None,\n-                            ) {\n-                                panic!(\"failed to emit error: {}\", e);\n+                        match sugg.style {\n+                            SuggestionStyle::CompletelyHidden => {\n+                                // do not display this suggestion, it is meant only for tools\n                             }\n-                        } else if let Err(e) = self.emit_suggestion_default(\n-                            span,\n-                            sugg,\n-                            args,\n-                            &Level::Help,\n-                            max_line_num_len,\n-                        ) {\n-                            panic!(\"failed to emit error: {}\", e);\n-                        };\n+                            SuggestionStyle::HideCodeAlways => {\n+                                if let Err(e) = self.emit_message_default(\n+                                    &MultiSpan::new(),\n+                                    &[(sugg.msg.to_owned(), Style::HeaderMsg)],\n+                                    args,\n+                                    &None,\n+                                    &Level::Help,\n+                                    max_line_num_len,\n+                                    true,\n+                                    None,\n+                                ) {\n+                                    panic!(\"failed to emit error: {}\", e);\n+                                }\n+                            }\n+                            SuggestionStyle::HideCodeInline\n+                            | SuggestionStyle::ShowCode\n+                            | SuggestionStyle::ShowAlways => {\n+                                if let Err(e) = self.emit_suggestion_default(\n+                                    span,\n+                                    sugg,\n+                                    args,\n+                                    &Level::Help,\n+                                    max_line_num_len,\n+                                ) {\n+                                    panic!(\"failed to emit error: {}\", e);\n+                                }\n+                            }\n+                        }\n                     }\n                 }\n             }"}, {"sha": "9aa14e1f214851668893591b480f058ec987153f", "filename": "compiler/rustc_errors/src/styled_buffer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fstyled_buffer.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -142,7 +142,7 @@ impl StyledBuffer {\n     pub fn set_style(&mut self, line: usize, col: usize, style: Style, overwrite: bool) {\n         if let Some(ref mut line) = self.lines.get_mut(line) {\n             if let Some(StyledChar { style: s, .. }) = line.get_mut(col) {\n-                if overwrite || *s == Style::NoStyle || *s == Style::Quotation {\n+                if overwrite || matches!(s, Style::NoStyle | Style::Quotation) {\n                     *s = style;\n                 }\n             }"}, {"sha": "283e68a68b5df5b135e303639cd598672dc29fe8", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -503,7 +503,7 @@ impl TtParser {\n                         mp.push_match(metavar_idx, seq_depth, MatchedSeq(vec![]));\n                     }\n \n-                    if op == KleeneOp::ZeroOrMore || op == KleeneOp::ZeroOrOne {\n+                    if matches!(op, KleeneOp::ZeroOrMore | KleeneOp::ZeroOrOne) {\n                         // Try zero matches of this sequence, by skipping over it.\n                         self.cur_mps.push(MatcherPos {\n                             idx: idx_first_after,"}, {"sha": "5e8f727df69dade8cc2016d81e5cfc1cac2c75f4", "filename": "compiler/rustc_hir_analysis/src/astconv/generics.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fgenerics.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -385,10 +385,9 @@ pub fn check_generic_arg_count_for_call(\n ) -> GenericArgCountResult {\n     let empty_args = hir::GenericArgs::none();\n     let gen_args = seg.args.unwrap_or(&empty_args);\n-    let gen_pos = if is_method_call == IsMethodCall::Yes {\n-        GenericArgPosition::MethodCall\n-    } else {\n-        GenericArgPosition::Value\n+    let gen_pos = match is_method_call {\n+        IsMethodCall::Yes => GenericArgPosition::MethodCall,\n+        IsMethodCall::No => GenericArgPosition::Value,\n     };\n     let has_self = generics.parent.is_none() && generics.has_self;\n "}, {"sha": "47eace961be55393eee2b53b0c6e5539aebb97c4", "filename": "compiler/rustc_hir_analysis/src/check/check.rs", "status": "modified", "additions": 55, "deletions": 48, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcheck.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -606,59 +606,66 @@ fn check_item_type(tcx: TyCtxt<'_>, id: hir::ItemId) {\n             };\n             check_abi(tcx, it.hir_id(), it.span, abi);\n \n-            if abi == Abi::RustIntrinsic {\n-                for item in items {\n-                    let item = tcx.hir().foreign_item(item.id);\n-                    intrinsic::check_intrinsic_type(tcx, item);\n-                }\n-            } else if abi == Abi::PlatformIntrinsic {\n-                for item in items {\n-                    let item = tcx.hir().foreign_item(item.id);\n-                    intrinsic::check_platform_intrinsic_type(tcx, item);\n+            match abi {\n+                Abi::RustIntrinsic => {\n+                    for item in items {\n+                        let item = tcx.hir().foreign_item(item.id);\n+                        intrinsic::check_intrinsic_type(tcx, item);\n+                    }\n                 }\n-            } else {\n-                for item in items {\n-                    let def_id = item.id.owner_id.def_id;\n-                    let generics = tcx.generics_of(def_id);\n-                    let own_counts = generics.own_counts();\n-                    if generics.params.len() - own_counts.lifetimes != 0 {\n-                        let (kinds, kinds_pl, egs) = match (own_counts.types, own_counts.consts) {\n-                            (_, 0) => (\"type\", \"types\", Some(\"u32\")),\n-                            // We don't specify an example value, because we can't generate\n-                            // a valid value for any type.\n-                            (0, _) => (\"const\", \"consts\", None),\n-                            _ => (\"type or const\", \"types or consts\", None),\n-                        };\n-                        struct_span_err!(\n-                            tcx.sess,\n-                            item.span,\n-                            E0044,\n-                            \"foreign items may not have {kinds} parameters\",\n-                        )\n-                        .span_label(item.span, &format!(\"can't have {kinds} parameters\"))\n-                        .help(\n-                            // FIXME: once we start storing spans for type arguments, turn this\n-                            // into a suggestion.\n-                            &format!(\n-                                \"replace the {} parameters with concrete {}{}\",\n-                                kinds,\n-                                kinds_pl,\n-                                egs.map(|egs| format!(\" like `{}`\", egs)).unwrap_or_default(),\n-                            ),\n-                        )\n-                        .emit();\n+\n+                Abi::PlatformIntrinsic => {\n+                    for item in items {\n+                        let item = tcx.hir().foreign_item(item.id);\n+                        intrinsic::check_platform_intrinsic_type(tcx, item);\n                     }\n+                }\n \n-                    let item = tcx.hir().foreign_item(item.id);\n-                    match &item.kind {\n-                        hir::ForeignItemKind::Fn(fn_decl, _, _) => {\n-                            require_c_abi_if_c_variadic(tcx, fn_decl, abi, item.span);\n+                _ => {\n+                    for item in items {\n+                        let def_id = item.id.owner_id.def_id;\n+                        let generics = tcx.generics_of(def_id);\n+                        let own_counts = generics.own_counts();\n+                        if generics.params.len() - own_counts.lifetimes != 0 {\n+                            let (kinds, kinds_pl, egs) = match (own_counts.types, own_counts.consts)\n+                            {\n+                                (_, 0) => (\"type\", \"types\", Some(\"u32\")),\n+                                // We don't specify an example value, because we can't generate\n+                                // a valid value for any type.\n+                                (0, _) => (\"const\", \"consts\", None),\n+                                _ => (\"type or const\", \"types or consts\", None),\n+                            };\n+                            struct_span_err!(\n+                                tcx.sess,\n+                                item.span,\n+                                E0044,\n+                                \"foreign items may not have {kinds} parameters\",\n+                            )\n+                            .span_label(item.span, &format!(\"can't have {kinds} parameters\"))\n+                            .help(\n+                                // FIXME: once we start storing spans for type arguments, turn this\n+                                // into a suggestion.\n+                                &format!(\n+                                    \"replace the {} parameters with concrete {}{}\",\n+                                    kinds,\n+                                    kinds_pl,\n+                                    egs.map(|egs| format!(\" like `{}`\", egs)).unwrap_or_default(),\n+                                ),\n+                            )\n+                            .emit();\n                         }\n-                        hir::ForeignItemKind::Static(..) => {\n-                            check_static_inhabited(tcx, def_id);\n-                            check_static_linkage(tcx, def_id);\n+\n+                        let item = tcx.hir().foreign_item(item.id);\n+                        match &item.kind {\n+                            hir::ForeignItemKind::Fn(fn_decl, _, _) => {\n+                                require_c_abi_if_c_variadic(tcx, fn_decl, abi, item.span);\n+                            }\n+                            hir::ForeignItemKind::Static(..) => {\n+                                check_static_inhabited(tcx, def_id);\n+                                check_static_linkage(tcx, def_id);\n+                            }\n+                            _ => {}\n                         }\n-                        _ => {}\n                     }\n                 }\n             }"}, {"sha": "21e700418105047a8a52540a41a85c7b26e140b1", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -1930,7 +1930,7 @@ pub(super) fn check_type_bounds<'tcx>(\n         smallvec::SmallVec::with_capacity(defs.count());\n     InternalSubsts::fill_single(&mut substs, defs, &mut |param, _| match param.kind {\n         GenericParamDefKind::Type { .. } => {\n-            let kind = ty::BoundTyKind::Param(param.name);\n+            let kind = ty::BoundTyKind::Param(param.def_id, param.name);\n             let bound_var = ty::BoundVariableKind::Ty(kind);\n             bound_vars.push(bound_var);\n             tcx.mk_ty(ty::Bound("}, {"sha": "7dcf9d8299f142d85315a9be60dc996bc6f32e05", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -9,9 +9,7 @@ use rustc_ast_pretty::pp::{self, Breaks};\n use rustc_ast_pretty::pprust::{Comments, PrintState};\n use rustc_hir as hir;\n use rustc_hir::LifetimeParamKind;\n-use rustc_hir::{\n-    BindingAnnotation, ByRef, GenericArg, GenericParam, GenericParamKind, Mutability, Node, Term,\n-};\n+use rustc_hir::{BindingAnnotation, ByRef, GenericArg, GenericParam, GenericParamKind, Node, Term};\n use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n use rustc_span::source_map::SourceMap;\n use rustc_span::symbol::{kw, Ident, IdentPrinter, Symbol};\n@@ -1746,7 +1744,7 @@ impl<'a> State<'a> {\n                 if by_ref == ByRef::Yes {\n                     self.word_nbsp(\"ref\");\n                 }\n-                if mutbl == Mutability::Mut {\n+                if mutbl.is_mut() {\n                     self.word_nbsp(\"mut\");\n                 }\n                 self.print_ident(ident);"}, {"sha": "0b30bf957a3d3dba303edeb2da613d44411c84e6", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -1354,13 +1354,12 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             return Some(Err(MethodError::Ambiguity(sources)));\n         }\n \n-        applicable_candidates.pop().map(|(probe, status)| {\n-            if status == ProbeResult::Match {\n+        applicable_candidates.pop().map(|(probe, status)| match status {\n+            ProbeResult::Match => {\n                 Ok(probe\n                     .to_unadjusted_pick(self_ty, unstable_candidates.cloned().unwrap_or_default()))\n-            } else {\n-                Err(MethodError::BadReturnType)\n             }\n+            ProbeResult::NoMatch | ProbeResult::BadReturnType => Err(MethodError::BadReturnType),\n         })\n     }\n }"}, {"sha": "31be107b35472a44dd373d95a7cc17df856b9a94", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             types: &mut |bound_ty: ty::BoundTy| {\n                 self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: next_universe,\n-                    name: bound_ty.var,\n+                    name: bound_ty.kind,\n                 }))\n             },\n             consts: &mut |bound_var: ty::BoundVar, ty| {"}, {"sha": "f39170bb2916de0802b05016d86ef28b90429659", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -2044,7 +2044,7 @@ fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n ) -> SubstsRef<'tcx> {\n     struct ReplaceParamAndInferWithPlaceholder<'tcx> {\n         tcx: TyCtxt<'tcx>,\n-        idx: usize,\n+        idx: u32,\n     }\n \n     impl<'tcx> TypeFolder<'tcx> for ReplaceParamAndInferWithPlaceholder<'tcx> {\n@@ -2056,7 +2056,7 @@ fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n             if let ty::Infer(_) = t.kind() {\n                 self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::ROOT,\n-                    name: ty::BoundVar::from_usize({\n+                    name: ty::BoundTyKind::Anon({\n                         let idx = self.idx;\n                         self.idx += 1;\n                         idx\n@@ -2077,7 +2077,7 @@ fn replace_param_and_infer_substs_with_placeholder<'tcx>(\n                 self.tcx.mk_const(\n                     ty::PlaceholderConst {\n                         universe: ty::UniverseIndex::ROOT,\n-                        name: ty::BoundVar::from_usize({\n+                        name: ty::BoundVar::from_u32({\n                             let idx = self.idx;\n                             self.idx += 1;\n                             idx"}, {"sha": "5d85cfe330acdd6075954690acc2a30c6fe7de21", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -580,27 +580,28 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'_>, impl_item: &hir::ImplItem<'_>) {\n-        // If the method is an impl for a trait, don't doc.\n         let context = method_context(cx, impl_item.owner_id.def_id);\n-        if context == MethodLateContext::TraitImpl {\n-            return;\n-        }\n \n-        // If the method is an impl for an item with docs_hidden, don't doc.\n-        if context == MethodLateContext::PlainImpl {\n-            let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n-            let impl_ty = cx.tcx.type_of(parent);\n-            let outerdef = match impl_ty.kind() {\n-                ty::Adt(def, _) => Some(def.did()),\n-                ty::Foreign(def_id) => Some(*def_id),\n-                _ => None,\n-            };\n-            let is_hidden = match outerdef {\n-                Some(id) => cx.tcx.is_doc_hidden(id),\n-                None => false,\n-            };\n-            if is_hidden {\n-                return;\n+        match context {\n+            // If the method is an impl for a trait, don't doc.\n+            MethodLateContext::TraitImpl => return,\n+            MethodLateContext::TraitAutoImpl => {}\n+            // If the method is an impl for an item with docs_hidden, don't doc.\n+            MethodLateContext::PlainImpl => {\n+                let parent = cx.tcx.hir().get_parent_item(impl_item.hir_id());\n+                let impl_ty = cx.tcx.type_of(parent);\n+                let outerdef = match impl_ty.kind() {\n+                    ty::Adt(def, _) => Some(def.did()),\n+                    ty::Foreign(def_id) => Some(*def_id),\n+                    _ => None,\n+                };\n+                let is_hidden = match outerdef {\n+                    Some(id) => cx.tcx.is_doc_hidden(id),\n+                    None => false,\n+                };\n+                if is_hidden {\n+                    return;\n+                }\n             }\n         }\n "}, {"sha": "39ef4276faf10360b96efa1eda9a5f504cee1b6b", "filename": "compiler/rustc_metadata/src/dependency_format.rs", "status": "modified", "additions": 29, "deletions": 32, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fdependency_format.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -113,37 +113,37 @@ fn calculate_type(tcx: TyCtxt<'_>, ty: CrateType) -> DependencyList {\n         CrateType::Staticlib => Linkage::Static,\n     };\n \n-    if preferred_linkage == Linkage::NotLinked {\n+    match preferred_linkage {\n         // If the crate is not linked, there are no link-time dependencies.\n-        return Vec::new();\n-    }\n-\n-    if preferred_linkage == Linkage::Static {\n-        // Attempt static linkage first. For dylibs and executables, we may be\n-        // able to retry below with dynamic linkage.\n-        if let Some(v) = attempt_static(tcx) {\n-            return v;\n-        }\n+        Linkage::NotLinked => return Vec::new(),\n+        Linkage::Static => {\n+            // Attempt static linkage first. For dylibs and executables, we may be\n+            // able to retry below with dynamic linkage.\n+            if let Some(v) = attempt_static(tcx) {\n+                return v;\n+            }\n \n-        // Staticlibs and static executables must have all static dependencies.\n-        // If any are not found, generate some nice pretty errors.\n-        if ty == CrateType::Staticlib\n-            || (ty == CrateType::Executable\n-                && sess.crt_static(Some(ty))\n-                && !sess.target.crt_static_allows_dylibs)\n-        {\n-            for &cnum in tcx.crates(()).iter() {\n-                if tcx.dep_kind(cnum).macros_only() {\n-                    continue;\n+            // Staticlibs and static executables must have all static dependencies.\n+            // If any are not found, generate some nice pretty errors.\n+            if ty == CrateType::Staticlib\n+                || (ty == CrateType::Executable\n+                    && sess.crt_static(Some(ty))\n+                    && !sess.target.crt_static_allows_dylibs)\n+            {\n+                for &cnum in tcx.crates(()).iter() {\n+                    if tcx.dep_kind(cnum).macros_only() {\n+                        continue;\n+                    }\n+                    let src = tcx.used_crate_source(cnum);\n+                    if src.rlib.is_some() {\n+                        continue;\n+                    }\n+                    sess.emit_err(RlibRequired { crate_name: tcx.crate_name(cnum) });\n                 }\n-                let src = tcx.used_crate_source(cnum);\n-                if src.rlib.is_some() {\n-                    continue;\n-                }\n-                sess.emit_err(RlibRequired { crate_name: tcx.crate_name(cnum) });\n+                return Vec::new();\n             }\n-            return Vec::new();\n         }\n+        Linkage::Dynamic | Linkage::IncludedFromDylib => {}\n     }\n \n     let mut formats = FxHashMap::default();\n@@ -283,12 +283,9 @@ fn attempt_static(tcx: TyCtxt<'_>) -> Option<DependencyList> {\n     let mut ret = tcx\n         .crates(())\n         .iter()\n-        .map(|&cnum| {\n-            if tcx.dep_kind(cnum) == CrateDepKind::Explicit {\n-                Linkage::Static\n-            } else {\n-                Linkage::NotLinked\n-            }\n+        .map(|&cnum| match tcx.dep_kind(cnum) {\n+            CrateDepKind::Explicit => Linkage::Static,\n+            CrateDepKind::MacrosOnly | CrateDepKind::Implicit => Linkage::NotLinked,\n         })\n         .collect::<Vec<_>>();\n "}, {"sha": "a5910100786ec71904c01b8348e026f7f556b8e9", "filename": "compiler/rustc_metadata/src/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Fnative_libs.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -107,7 +107,7 @@ impl<'tcx> Collector<'tcx> {\n             return;\n         };\n \n-        if abi == Abi::Rust || abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n+        if matches!(abi, Abi::Rust | Abi::RustIntrinsic | Abi::PlatformIntrinsic) {\n             return;\n         }\n "}, {"sha": "db24dae11304f6ec0d84ccba748f05e6e730ddc0", "filename": "compiler/rustc_middle/src/mir/coverage.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fcoverage.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -135,7 +135,10 @@ impl Debug for CoverageKind {\n                 \"Expression({:?}) = {} {} {}\",\n                 id.index(),\n                 lhs.index(),\n-                if *op == Op::Add { \"+\" } else { \"-\" },\n+                match op {\n+                    Op::Add => \"+\",\n+                    Op::Subtract => \"-\",\n+                },\n                 rhs.index(),\n             ),\n             Unreachable => write!(fmt, \"Unreachable\"),"}, {"sha": "cf6d46e1e2c8acfd07b8263ab43329c6196a1833", "filename": "compiler/rustc_middle/src/mir/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fgraphviz.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -110,7 +110,7 @@ fn write_graph_label<'tcx, W: std::fmt::Write>(\n         let decl = &body.local_decls[local];\n \n         write!(w, \"let \")?;\n-        if decl.mutability == Mutability::Mut {\n+        if decl.mutability.is_mut() {\n             write!(w, \"mut \")?;\n         }\n "}, {"sha": "05a9ec5e6d04a5bca66b64c4795984223ebcd2d7", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -416,11 +416,7 @@ impl<'tcx> Body<'tcx> {\n         (self.arg_count + 1..self.local_decls.len()).filter_map(move |index| {\n             let local = Local::new(index);\n             let decl = &self.local_decls[local];\n-            if decl.is_user_variable() && decl.mutability == Mutability::Mut {\n-                Some(local)\n-            } else {\n-                None\n-            }\n+            (decl.is_user_variable() && decl.mutability.is_mut()).then(|| local)\n         })\n     }\n "}, {"sha": "16daf63b82d9f2f68e88acd85c54ce6f2f3d8422", "filename": "compiler/rustc_middle/src/mir/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fpretty.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -580,7 +580,7 @@ fn write_scope_tree(\n             continue;\n         }\n \n-        let mut_str = if local_decl.mutability == Mutability::Mut { \"mut \" } else { \"\" };\n+        let mut_str = local_decl.mutability.prefix_str();\n \n         let mut indented_decl =\n             format!(\"{0:1$}let {2}{3:?}: {4:?}\", INDENT, indent, mut_str, local, local_decl.ty);"}, {"sha": "1445bc1ed32e60c604e275f948ce30722390a2b2", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -610,7 +610,9 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let index = entry.index();\n                 let var = ty::BoundVar::from_usize(index);\n                 let kind = entry\n-                    .or_insert_with(|| ty::BoundVariableKind::Ty(ty::BoundTyKind::Anon))\n+                    .or_insert_with(|| {\n+                        ty::BoundVariableKind::Ty(ty::BoundTyKind::Anon(index as u32))\n+                    })\n                     .expect_ty();\n                 self.tcx.mk_ty(ty::Bound(ty::INNERMOST, BoundTy { var, kind }))\n             }"}, {"sha": "09c3d5b736cf18832270bf4b4e141cbdb5d083a8", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -1369,7 +1369,7 @@ pub struct Placeholder<T> {\n \n pub type PlaceholderRegion = Placeholder<BoundRegionKind>;\n \n-pub type PlaceholderType = Placeholder<BoundVar>;\n+pub type PlaceholderType = Placeholder<BoundTyKind>;\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, HashStable)]\n #[derive(TyEncodable, TyDecodable, PartialOrd, Ord)]"}, {"sha": "e8e00d5feb873110e3df1a5d49d59c34e8bd79f9", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -698,8 +698,10 @@ pub trait PrettyPrinter<'tcx>:\n             ty::Error(_) => p!(\"[type error]\"),\n             ty::Param(ref param_ty) => p!(print(param_ty)),\n             ty::Bound(debruijn, bound_ty) => match bound_ty.kind {\n-                ty::BoundTyKind::Anon => self.pretty_print_bound_var(debruijn, bound_ty.var)?,\n-                ty::BoundTyKind::Param(p) => p!(write(\"{}\", p)),\n+                ty::BoundTyKind::Anon(bv) => {\n+                    self.pretty_print_bound_var(debruijn, ty::BoundVar::from_u32(bv))?\n+                }\n+                ty::BoundTyKind::Param(_, s) => p!(write(\"{}\", s)),\n             },\n             ty::Adt(def, substs) => {\n                 p!(print_def_path(def.did(), substs));"}, {"sha": "8df639750c7010931366dec18638924bf10597b8", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -240,6 +240,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::AssocKind,\n     crate::ty::AliasKind,\n     crate::ty::Placeholder<crate::ty::BoundRegionKind>,\n+    crate::ty::Placeholder<crate::ty::BoundTyKind>,\n     crate::ty::ClosureKind,\n     crate::ty::FreeRegion,\n     crate::ty::InferTy,"}, {"sha": "060d864389cb0f4ffa3f3c84b9f9ab5bcb353705", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -1504,13 +1504,22 @@ pub struct BoundTy {\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n #[derive(HashStable)]\n pub enum BoundTyKind {\n-    Anon,\n-    Param(Symbol),\n+    Anon(u32),\n+    Param(DefId, Symbol),\n+}\n+\n+impl BoundTyKind {\n+    pub fn expect_anon(self) -> u32 {\n+        match self {\n+            BoundTyKind::Anon(i) => i,\n+            _ => bug!(),\n+        }\n+    }\n }\n \n impl From<BoundVar> for BoundTy {\n     fn from(var: BoundVar) -> Self {\n-        BoundTy { var, kind: BoundTyKind::Anon }\n+        BoundTy { var, kind: BoundTyKind::Anon(var.as_u32()) }\n     }\n }\n "}, {"sha": "3d3cf75559e303089ccbaa320f9dff9a7e3fe964", "filename": "compiler/rustc_mir_build/src/build/expr/as_temp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_temp.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let expr_ty = expr.ty;\n         let temp = {\n             let mut local_decl = LocalDecl::new(expr_ty, expr_span);\n-            if mutability == Mutability::Not {\n+            if mutability.is_not() {\n                 local_decl = local_decl.immutable();\n             }\n "}, {"sha": "feb054392bc2d4e8e044961ca30c0e7ea78b2657", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -5,7 +5,6 @@ use std::cell::Cell;\n \n use either::Right;\n \n-use rustc_ast::Mutability;\n use rustc_const_eval::const_eval::CheckAlignment;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir::def::DefKind;\n@@ -289,7 +288,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n         }\n         // If the static allocation is mutable, then we can't const prop it as its content\n         // might be different at runtime.\n-        if alloc.inner().mutability == Mutability::Mut {\n+        if alloc.inner().mutability.is_mut() {\n             throw_machine_stop_str!(\"can't access mutable globals in ConstProp\");\n         }\n \n@@ -528,7 +527,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         let r = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(right, None)?));\n         let l = self.use_ecx(|this| this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?));\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n-        if op == BinOp::Shr || op == BinOp::Shl {\n+        if matches!(op, BinOp::Shr | BinOp::Shl) {\n             let r = r.clone()?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!"}, {"sha": "c4b10218c237b2fa0cd19df96a75b3bbbb8f4b50", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -368,7 +368,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             this.ecx.read_immediate(&this.ecx.eval_operand(left, None)?)\n         });\n         // Check for exceeding shifts *even if* we cannot evaluate the LHS.\n-        if op == BinOp::Shr || op == BinOp::Shl {\n+        if matches!(op, BinOp::Shr | BinOp::Shl) {\n             let r = r.clone()?;\n             // We need the type of the LHS. We cannot use `place_layout` as that is the type\n             // of the result, which for checked binops is not the same!"}, {"sha": "22ea8710e6a96204efe13ead400e7442b9311a5e", "filename": "compiler/rustc_mir_transform/src/coverage/debug.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fdebug.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -323,7 +323,10 @@ impl DebugCounters {\n                         String::new()\n                     },\n                     self.format_operand(lhs),\n-                    if op == Op::Add { \"+\" } else { \"-\" },\n+                    match op {\n+                        Op::Add => \"+\",\n+                        Op::Subtract => \"-\",\n+                    },\n                     self.format_operand(rhs),\n                 );\n             }"}, {"sha": "e9ca6f7c93c446b569f72aa608087182c874b734", "filename": "compiler/rustc_mir_transform/src/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fshim.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -427,7 +427,7 @@ impl<'tcx> CloneShimBuilder<'tcx> {\n     fn make_place(&mut self, mutability: Mutability, ty: Ty<'tcx>) -> Place<'tcx> {\n         let span = self.span;\n         let mut local = LocalDecl::new(ty, span);\n-        if mutability == Mutability::Not {\n+        if mutability.is_not() {\n             local = local.immutable();\n         }\n         Place::from(self.local_decls.push(local))"}, {"sha": "58c7a398f14252e3e2ac7cd4bcf79c16b9049ab6", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -93,11 +93,12 @@ impl<'a> Parser<'a> {\n             // or `auto trait` items. We aim to parse an arbitrary path `a::b` but not something\n             // that starts like a path (1 token), but it fact not a path.\n             // Also, we avoid stealing syntax from `parse_item_`.\n-            if force_collect == ForceCollect::Yes {\n-                self.collect_tokens_no_attrs(|this| this.parse_stmt_path_start(lo, attrs))\n-            } else {\n-                self.parse_stmt_path_start(lo, attrs)\n-            }?\n+            match force_collect {\n+                ForceCollect::Yes => {\n+                    self.collect_tokens_no_attrs(|this| this.parse_stmt_path_start(lo, attrs))?\n+                }\n+                ForceCollect::No => self.parse_stmt_path_start(lo, attrs)?,\n+            }\n         } else if let Some(item) = self.parse_item_common(\n             attrs.clone(),\n             false,\n@@ -113,13 +114,12 @@ impl<'a> Parser<'a> {\n             self.mk_stmt(lo, StmtKind::Empty)\n         } else if self.token != token::CloseDelim(Delimiter::Brace) {\n             // Remainder are line-expr stmts.\n-            let e = if force_collect == ForceCollect::Yes {\n-                self.collect_tokens_no_attrs(|this| {\n+            let e = match force_collect {\n+                ForceCollect::Yes => self.collect_tokens_no_attrs(|this| {\n                     this.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))\n-                })\n-            } else {\n-                self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))\n-            }?;\n+                })?,\n+                ForceCollect::No => self.parse_expr_res(Restrictions::STMT_EXPR, Some(attrs))?,\n+            };\n             if matches!(e.kind, ExprKind::Assign(..)) && self.eat_keyword(kw::Else) {\n                 let bl = self.parse_block()?;\n                 // Destructuring assignment ... else."}, {"sha": "8b4f0ab8feb848a0008a9a212aae65bbc0f332ec", "filename": "compiler/rustc_parse/src/parser/ty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fty.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -323,13 +323,14 @@ impl<'a> Parser<'a> {\n         } else if self.can_begin_bound() {\n             self.parse_bare_trait_object(lo, allow_plus)?\n         } else if self.eat(&token::DotDotDot) {\n-            if allow_c_variadic == AllowCVariadic::Yes {\n-                TyKind::CVarArgs\n-            } else {\n-                // FIXME(Centril): Should we just allow `...` syntactically\n-                // anywhere in a type and use semantic restrictions instead?\n-                self.error_illegal_c_varadic_ty(lo);\n-                TyKind::Err\n+            match allow_c_variadic {\n+                AllowCVariadic::Yes => TyKind::CVarArgs,\n+                AllowCVariadic::No => {\n+                    // FIXME(Centril): Should we just allow `...` syntactically\n+                    // anywhere in a type and use semantic restrictions instead?\n+                    self.error_illegal_c_varadic_ty(lo);\n+                    TyKind::Err\n+                }\n             }\n         } else {\n             let msg = format!(\"expected type, found {}\", super::token_descr(&self.token));\n@@ -343,10 +344,9 @@ impl<'a> Parser<'a> {\n         let mut ty = self.mk_ty(span, kind);\n \n         // Try to recover from use of `+` with incorrect priority.\n-        if allow_plus == AllowPlus::Yes {\n-            self.maybe_recover_from_bad_type_plus(&ty)?;\n-        } else {\n-            self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty);\n+        match allow_plus {\n+            AllowPlus::Yes => self.maybe_recover_from_bad_type_plus(&ty)?,\n+            AllowPlus::No => self.maybe_report_ambiguous_plus(impl_dyn_multi, &ty),\n         }\n         if RecoverQuestionMark::Yes == recover_question_mark {\n             ty = self.maybe_recover_from_question_mark(ty);"}, {"sha": "d67d52da497468b5d2f484aa896fd94d6ef21167", "filename": "compiler/rustc_passes/src/check_attr.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fcheck_attr.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -864,33 +864,39 @@ impl CheckAttrVisitor<'_> {\n         target: Target,\n         specified_inline: &mut Option<(bool, Span)>,\n     ) -> bool {\n-        if target == Target::Use || target == Target::ExternCrate {\n-            let do_inline = meta.name_or_empty() == sym::inline;\n-            if let Some((prev_inline, prev_span)) = *specified_inline {\n-                if do_inline != prev_inline {\n-                    let mut spans = MultiSpan::from_spans(vec![prev_span, meta.span()]);\n-                    spans.push_span_label(prev_span, fluent::passes_doc_inline_conflict_first);\n-                    spans.push_span_label(meta.span(), fluent::passes_doc_inline_conflict_second);\n-                    self.tcx.sess.emit_err(errors::DocKeywordConflict { spans });\n-                    return false;\n+        match target {\n+            Target::Use | Target::ExternCrate => {\n+                let do_inline = meta.name_or_empty() == sym::inline;\n+                if let Some((prev_inline, prev_span)) = *specified_inline {\n+                    if do_inline != prev_inline {\n+                        let mut spans = MultiSpan::from_spans(vec![prev_span, meta.span()]);\n+                        spans.push_span_label(prev_span, fluent::passes_doc_inline_conflict_first);\n+                        spans.push_span_label(\n+                            meta.span(),\n+                            fluent::passes_doc_inline_conflict_second,\n+                        );\n+                        self.tcx.sess.emit_err(errors::DocKeywordConflict { spans });\n+                        return false;\n+                    }\n+                    true\n+                } else {\n+                    *specified_inline = Some((do_inline, meta.span()));\n+                    true\n                 }\n-                true\n-            } else {\n-                *specified_inline = Some((do_inline, meta.span()));\n-                true\n             }\n-        } else {\n-            self.tcx.emit_spanned_lint(\n-                INVALID_DOC_ATTRIBUTES,\n-                hir_id,\n-                meta.span(),\n-                errors::DocInlineOnlyUse {\n-                    attr_span: meta.span(),\n-                    item_span: (attr.style == AttrStyle::Outer)\n-                        .then(|| self.tcx.hir().span(hir_id)),\n-                },\n-            );\n-            false\n+            _ => {\n+                self.tcx.emit_spanned_lint(\n+                    INVALID_DOC_ATTRIBUTES,\n+                    hir_id,\n+                    meta.span(),\n+                    errors::DocInlineOnlyUse {\n+                        attr_span: meta.span(),\n+                        item_span: (attr.style == AttrStyle::Outer)\n+                            .then(|| self.tcx.hir().span(hir_id)),\n+                    },\n+                );\n+                false\n+            }\n         }\n     }\n \n@@ -1137,7 +1143,7 @@ impl CheckAttrVisitor<'_> {\n                                     errors::DocTestUnknownInclude {\n                                         path,\n                                         value: value.to_string(),\n-                                        inner: if attr.style == AttrStyle::Inner { \"!\" } else { \"\" },\n+                                        inner: match attr.style { AttrStyle::Inner=>  \"!\" , AttrStyle::Outer => \"\" },\n                                         sugg: (attr.meta().unwrap().span, applicability),\n                                     }\n                                 );"}, {"sha": "47911aef25d4fe1f240e1dc432d688e96338490e", "filename": "compiler/rustc_passes/src/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_passes%2Fsrc%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fstability.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -125,7 +125,7 @@ impl<'a, 'tcx> Annotator<'a, 'tcx> {\n         if let Some((depr, span)) = &depr {\n             is_deprecated = true;\n \n-            if kind == AnnotationKind::Prohibited || kind == AnnotationKind::DeprecationProhibited {\n+            if matches!(kind, AnnotationKind::Prohibited | AnnotationKind::DeprecationProhibited) {\n                 let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                 self.tcx.emit_spanned_lint(\n                     USELESS_DEPRECATED,"}, {"sha": "84421dc1f62253354794e3b8079c190213e7d66b", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -298,14 +298,15 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                             self.r.record_partial_res(id, PartialRes::new(res));\n                         }\n                         if module.is_normal() {\n-                            if res == Res::Err {\n-                                Ok(ty::Visibility::Public)\n-                            } else {\n-                                let vis = ty::Visibility::Restricted(res.def_id());\n-                                if self.r.is_accessible_from(vis, parent_scope.module) {\n-                                    Ok(vis.expect_local())\n-                                } else {\n-                                    Err(VisResolutionError::AncestorOnly(path.span))\n+                            match res {\n+                                Res::Err => Ok(ty::Visibility::Public),\n+                                _ => {\n+                                    let vis = ty::Visibility::Restricted(res.def_id());\n+                                    if self.r.is_accessible_from(vis, parent_scope.module) {\n+                                        Ok(vis.expect_local())\n+                                    } else {\n+                                        Err(VisResolutionError::AncestorOnly(path.span))\n+                                    }\n                                 }\n                             }\n                         } else {"}, {"sha": "3bf041cebcb88a6996b704dce8f2ce409a304cd9", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -1552,12 +1552,12 @@ impl<'a> Resolver<'a> {\n             if b.is_extern_crate() && ident.span.rust_2018() {\n                 help_msgs.push(format!(\"use `::{ident}` to refer to this {thing} unambiguously\"))\n             }\n-            if misc == AmbiguityErrorMisc::SuggestCrate {\n-                help_msgs\n-                    .push(format!(\"use `crate::{ident}` to refer to this {thing} unambiguously\"))\n-            } else if misc == AmbiguityErrorMisc::SuggestSelf {\n-                help_msgs\n-                    .push(format!(\"use `self::{ident}` to refer to this {thing} unambiguously\"))\n+            match misc {\n+                AmbiguityErrorMisc::SuggestCrate => help_msgs\n+                    .push(format!(\"use `crate::{ident}` to refer to this {thing} unambiguously\")),\n+                AmbiguityErrorMisc::SuggestSelf => help_msgs\n+                    .push(format!(\"use `self::{ident}` to refer to this {thing} unambiguously\")),\n+                AmbiguityErrorMisc::FromPrelude | AmbiguityErrorMisc::None => {}\n             }\n \n             err.span_note(b.span, &note_msg);\n@@ -1717,7 +1717,7 @@ impl<'a> Resolver<'a> {\n                         Applicability::MaybeIncorrect,\n                     )),\n                 )\n-            } else if self.session.edition() == Edition::Edition2015 {\n+            } else if self.session.rust_2015() {\n                 (\n                     format!(\"maybe a missing crate `{ident}`?\"),\n                     Some(("}, {"sha": "1c985d43658ae25f1b66acfedfc1ccde9a75cdfa", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -7,7 +7,6 @@ use rustc_middle::ty;\n use rustc_session::lint::builtin::PROC_MACRO_DERIVE_RESOLUTION_FALLBACK;\n use rustc_session::lint::BuiltinLintDiagnostics;\n use rustc_span::def_id::LocalDefId;\n-use rustc_span::edition::Edition;\n use rustc_span::hygiene::{ExpnId, ExpnKind, LocalExpnId, MacroKind, SyntaxContext};\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{Span, DUMMY_SP};\n@@ -86,7 +85,7 @@ impl<'a> Resolver<'a> {\n         // 4c. Standard library prelude (de-facto closed, controlled).\n         // 6. Language prelude: builtin attributes (closed, controlled).\n \n-        let rust_2015 = ctxt.edition() == Edition::Edition2015;\n+        let rust_2015 = ctxt.edition().rust_2015();\n         let (ns, macro_kind, is_absolute_path) = match scope_set {\n             ScopeSet::All(ns, _) => (ns, None, false),\n             ScopeSet::AbsolutePath(ns) => (ns, None, true),"}, {"sha": "a50a8178de38bb3af51f44380575ee81c39b3887", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -29,7 +29,6 @@ use crate::{id_from_def_id, SaveContext};\n \n use rls_data::{SigElement, Signature};\n \n-use rustc_ast::Mutability;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir_pretty::id_to_string;\n@@ -769,9 +768,8 @@ impl<'hir> Sig for hir::ForeignItem<'hir> {\n             }\n             hir::ForeignItemKind::Static(ref ty, m) => {\n                 let mut text = \"static \".to_owned();\n-                if m == Mutability::Mut {\n-                    text.push_str(\"mut \");\n-                }\n+                text.push_str(m.prefix_str());\n+\n                 let name = self.ident.to_string();\n                 let defs = vec![SigElement {\n                     id: id_from_def_id(self.owner_id.to_def_id()),"}, {"sha": "3b2cd1864c518e1e3dcebba102cf9aa8095412ad", "filename": "compiler/rustc_session/src/session.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_session%2Fsrc%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fsession.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -918,23 +918,24 @@ impl Session {\n         ret\n     }\n \n+    /// Is this edition 2015?\n     pub fn rust_2015(&self) -> bool {\n-        self.edition() == Edition::Edition2015\n+        self.edition().rust_2015()\n     }\n \n     /// Are we allowed to use features from the Rust 2018 edition?\n     pub fn rust_2018(&self) -> bool {\n-        self.edition() >= Edition::Edition2018\n+        self.edition().rust_2018()\n     }\n \n     /// Are we allowed to use features from the Rust 2021 edition?\n     pub fn rust_2021(&self) -> bool {\n-        self.edition() >= Edition::Edition2021\n+        self.edition().rust_2021()\n     }\n \n     /// Are we allowed to use features from the Rust 2024 edition?\n     pub fn rust_2024(&self) -> bool {\n-        self.edition() >= Edition::Edition2024\n+        self.edition().rust_2024()\n     }\n \n     /// Returns `true` if we cannot skip the PLT for shared library calls."}, {"sha": "e66ec07904341b8585d529f82c2d87adc829bbc7", "filename": "compiler/rustc_span/src/edition.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_span%2Fsrc%2Fedition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_span%2Fsrc%2Fedition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fedition.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -49,50 +49,51 @@ impl fmt::Display for Edition {\n }\n \n impl Edition {\n-    pub fn lint_name(&self) -> &'static str {\n-        match *self {\n+    pub fn lint_name(self) -> &'static str {\n+        match self {\n             Edition::Edition2015 => \"rust_2015_compatibility\",\n             Edition::Edition2018 => \"rust_2018_compatibility\",\n             Edition::Edition2021 => \"rust_2021_compatibility\",\n             Edition::Edition2024 => \"rust_2024_compatibility\",\n         }\n     }\n \n-    pub fn feature_name(&self) -> Symbol {\n-        match *self {\n+    pub fn feature_name(self) -> Symbol {\n+        match self {\n             Edition::Edition2015 => sym::rust_2015_preview,\n             Edition::Edition2018 => sym::rust_2018_preview,\n             Edition::Edition2021 => sym::rust_2021_preview,\n             Edition::Edition2024 => sym::rust_2024_preview,\n         }\n     }\n \n-    pub fn is_stable(&self) -> bool {\n-        match *self {\n+    pub fn is_stable(self) -> bool {\n+        match self {\n             Edition::Edition2015 => true,\n             Edition::Edition2018 => true,\n             Edition::Edition2021 => true,\n             Edition::Edition2024 => false,\n         }\n     }\n \n-    pub fn rust_2015(&self) -> bool {\n-        *self == Edition::Edition2015\n+    /// Is this edition 2015?\n+    pub fn rust_2015(self) -> bool {\n+        self == Edition::Edition2015\n     }\n \n     /// Are we allowed to use features from the Rust 2018 edition?\n-    pub fn rust_2018(&self) -> bool {\n-        *self >= Edition::Edition2018\n+    pub fn rust_2018(self) -> bool {\n+        self >= Edition::Edition2018\n     }\n \n     /// Are we allowed to use features from the Rust 2021 edition?\n-    pub fn rust_2021(&self) -> bool {\n-        *self >= Edition::Edition2021\n+    pub fn rust_2021(self) -> bool {\n+        self >= Edition::Edition2021\n     }\n \n     /// Are we allowed to use features from the Rust 2024 edition?\n-    pub fn rust_2024(&self) -> bool {\n-        *self >= Edition::Edition2024\n+    pub fn rust_2024(self) -> bool {\n+        self >= Edition::Edition2024\n     }\n }\n "}, {"sha": "006102a5f2fcfc471abf0c1523bd1d1f22c029fc", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -706,22 +706,22 @@ impl Span {\n \n     #[inline]\n     pub fn rust_2015(self) -> bool {\n-        self.edition() == edition::Edition::Edition2015\n+        self.edition().rust_2015()\n     }\n \n     #[inline]\n     pub fn rust_2018(self) -> bool {\n-        self.edition() >= edition::Edition::Edition2018\n+        self.edition().rust_2018()\n     }\n \n     #[inline]\n     pub fn rust_2021(self) -> bool {\n-        self.edition() >= edition::Edition::Edition2021\n+        self.edition().rust_2021()\n     }\n \n     #[inline]\n     pub fn rust_2024(self) -> bool {\n-        self.edition() >= edition::Edition::Edition2024\n+        self.edition().rust_2024()\n     }\n \n     /// Returns the source callee."}, {"sha": "36170b3788a7a7b0cc5d1cf21badbbf48ae0f261", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 29, "deletions": 5, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -161,6 +161,7 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n             search_graph: &mut search_graph,\n             infcx: self,\n             var_values: CanonicalVarValues::dummy(),\n+            in_projection_eq_hack: false,\n         }\n         .evaluate_goal(goal);\n \n@@ -174,6 +175,10 @@ struct EvalCtxt<'a, 'tcx> {\n     var_values: CanonicalVarValues<'tcx>,\n \n     search_graph: &'a mut search_graph::SearchGraph<'tcx>,\n+\n+    /// This field is used by a debug assertion in [`EvalCtxt::evaluate_goal`],\n+    /// see the comment in that method for more details.\n+    in_projection_eq_hack: bool,\n }\n \n impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n@@ -209,7 +214,8 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         loop {\n             let (ref infcx, goal, var_values) =\n                 tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let mut ecx = EvalCtxt { infcx, var_values, search_graph };\n+            let mut ecx =\n+                EvalCtxt { infcx, var_values, search_graph, in_projection_eq_hack: false };\n             let result = ecx.compute_goal(goal);\n \n             // FIXME: `Response` should be `Copy`\n@@ -239,10 +245,28 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-        Ok((\n-            !canonical_response.value.var_values.is_identity(),\n-            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response),\n-        ))\n+\n+        let has_changed = !canonical_response.value.var_values.is_identity();\n+        let certainty =\n+            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response);\n+\n+        // Check that rerunning this query with its inference constraints applied\n+        // doesn't result in new inference constraints and has the same result.\n+        //\n+        // If we have projection goals like `<T as Trait>::Assoc == u32` we recursively\n+        // call `exists<U> <T as Trait>::Assoc == U` to enable better caching. This goal\n+        // could constrain `U` to `u32` which would cause this check to result in a\n+        // solver cycle.\n+        if cfg!(debug_assertions) && has_changed && !self.in_projection_eq_hack {\n+            let mut orig_values = OriginalQueryValues::default();\n+            let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let canonical_response =\n+                EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n+            assert!(canonical_response.value.var_values.is_identity());\n+            assert_eq!(certainty, canonical_response.value.certainty);\n+        }\n+\n+        Ok((has_changed, certainty))\n     }\n \n     fn compute_goal(&mut self, goal: Goal<'tcx, ty::Predicate<'tcx>>) -> QueryResult<'tcx> {"}, {"sha": "a23fdd24b4e42338032bb8bd919a6faec10f5a6a", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 52, "deletions": 39, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -45,8 +45,9 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n                 projection_ty: goal.predicate.projection_ty,\n                 term: unconstrained_rhs,\n             });\n-            let (_has_changed, normalize_certainty) =\n-                self.evaluate_goal(goal.with(self.tcx(), unconstrained_predicate))?;\n+            let (_has_changed, normalize_certainty) = self.in_projection_eq_hack(|this| {\n+                this.evaluate_goal(goal.with(this.tcx(), unconstrained_predicate))\n+            })?;\n \n             let nested_eq_goals =\n                 self.infcx.eq(goal.param_env, unconstrained_rhs, predicate.term)?;\n@@ -55,6 +56,15 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// This sets a flag used by a debug assert in [`EvalCtxt::evaluate_goal`],\n+    /// see the comment in that method for more details.\n+    fn in_projection_eq_hack<T>(&mut self, f: impl FnOnce(&mut Self) -> T) -> T {\n+        self.in_projection_eq_hack = true;\n+        let result = f(self);\n+        self.in_projection_eq_hack = false;\n+        result\n+    }\n+\n     /// Is the projection predicate is of the form `exists<T> <Ty as Trait>::Assoc = T`.\n     ///\n     /// This is the case if the `term` is an inference variable in the innermost universe\n@@ -122,6 +132,28 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             && goal.param_env.visit_with(&mut visitor).is_continue()\n     }\n \n+    /// After normalizing the projection to `normalized_alias` with the given\n+    /// `normalization_certainty`, constrain the inference variable `term` to it\n+    /// and return a query response.\n+    fn eq_term_and_make_canonical_response(\n+        &mut self,\n+        goal: Goal<'tcx, ProjectionPredicate<'tcx>>,\n+        normalization_certainty: Certainty,\n+        normalized_alias: impl Into<ty::Term<'tcx>>,\n+    ) -> QueryResult<'tcx> {\n+        // The term of our goal should be fully unconstrained, so this should never fail.\n+        //\n+        // It can however be ambiguous when the `normalized_alias` contains a projection.\n+        let nested_goals = self\n+            .infcx\n+            .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n+            .expect(\"failed to unify with unconstrained term\");\n+        let rhs_certainty =\n+            self.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n+\n+        self.make_canonical_response(normalization_certainty.unify_and(rhs_certainty))\n+    }\n+\n     fn merge_project_candidates(\n         &mut self,\n         mut candidates: Vec<Candidate<'tcx>>,\n@@ -218,7 +250,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 .map(|pred| goal.with(tcx, pred));\n \n             nested_goals.extend(where_clause_bounds);\n-            let trait_ref_certainty = ecx.evaluate_all(nested_goals)?;\n+            let match_impl_certainty = ecx.evaluate_all(nested_goals)?;\n \n             // In case the associated item is hidden due to specialization, we have to\n             // return ambiguity this would otherwise be incomplete, resulting in\n@@ -230,7 +262,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 goal.predicate.def_id(),\n                 impl_def_id\n             )? else {\n-                return ecx.make_canonical_response(trait_ref_certainty.unify_and(Certainty::AMBIGUOUS));\n+                return ecx.make_canonical_response(match_impl_certainty.unify_and(Certainty::AMBIGUOUS));\n             };\n \n             if !assoc_def.item.defaultness(tcx).has_value() {\n@@ -277,17 +309,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ty.map_bound(|ty| ty.into())\n             };\n \n-            // The term of our goal should be fully unconstrained, so this should never fail.\n-            //\n-            // It can however be ambiguous when the resolved type is a projection.\n-            let nested_goals = ecx\n-                .infcx\n-                .eq(goal.param_env, goal.predicate.term, term.subst(tcx, substs))\n-                .expect(\"failed to unify with unconstrained term\");\n-            let rhs_certainty =\n-                ecx.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n-\n-            ecx.make_canonical_response(trait_ref_certainty.unify_and(rhs_certainty))\n+            ecx.eq_term_and_make_canonical_response(goal, match_impl_certainty, term.subst(tcx, substs))\n         })\n     }\n \n@@ -309,18 +331,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 )?;\n                 let subst_certainty = ecx.evaluate_all(nested_goals)?;\n \n-                // The term of our goal should be fully unconstrained, so this should never fail.\n-                //\n-                // It can however be ambiguous when the resolved type is a projection.\n-                let nested_goals = ecx\n-                    .infcx\n-                    .eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n-                    .expect(\"failed to unify with unconstrained term\");\n-                let rhs_certainty = ecx\n-                    .evaluate_all(nested_goals)\n-                    .expect(\"failed to unify with unconstrained term\");\n-\n-                ecx.make_canonical_response(subst_certainty.unify_and(rhs_certainty))\n+                ecx.eq_term_and_make_canonical_response(\n+                    goal,\n+                    subst_certainty,\n+                    assumption_projection_pred.term,\n+                )\n             })\n         } else {\n             Err(NoSolution)\n@@ -437,14 +452,12 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                         [ty::GenericArg::from(goal.predicate.self_ty())],\n                     ));\n \n-                    let mut nested_goals = ecx.infcx.eq(\n-                        goal.param_env,\n-                        goal.predicate.term.ty().unwrap(),\n+                    let is_sized_certainty = ecx.evaluate_goal(goal.with(tcx, sized_predicate))?.1;\n+                    return ecx.eq_term_and_make_canonical_response(\n+                        goal,\n+                        is_sized_certainty,\n                         tcx.types.unit,\n-                    )?;\n-                    nested_goals.push(goal.with(tcx, sized_predicate));\n-\n-                    return ecx.evaluate_all_and_make_canonical_response(nested_goals);\n+                    );\n                 }\n \n                 ty::Adt(def, substs) if def.is_struct() => {\n@@ -456,7 +469,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                                 tcx,\n                                 ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n                             );\n-                            return ecx.evaluate_all_and_make_canonical_response(vec![new_goal]);\n+                            let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n+                            return ecx.make_canonical_response(certainty);\n                         }\n                     }\n                 }\n@@ -469,7 +483,8 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                             tcx,\n                             ty::Binder::dummy(goal.predicate.with_self_ty(tcx, self_ty)),\n                         );\n-                        return ecx.evaluate_all_and_make_canonical_response(vec![new_goal]);\n+                        let (_, certainty) = ecx.evaluate_goal(new_goal)?;\n+                        return ecx.make_canonical_response(certainty);\n                     }\n                 },\n \n@@ -482,9 +497,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 ),\n             };\n \n-            let nested_goals =\n-                ecx.infcx.eq(goal.param_env, goal.predicate.term.ty().unwrap(), metadata_ty)?;\n-            ecx.evaluate_all_and_make_canonical_response(nested_goals)\n+            ecx.eq_term_and_make_canonical_response(goal, Certainty::Yes, metadata_ty)\n         })\n     }\n "}, {"sha": "7514c7ee55170482df63a66136f376b39492629f", "filename": "compiler/rustc_trait_selection/src/solve/search_graph/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fsearch_graph%2Fmod.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -45,6 +45,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// Tries putting the new goal on the stack, returning an error if it is already cached.\n     ///\n     /// This correctly updates the provisional cache if there is a cycle.\n+    #[instrument(level = \"debug\", skip(self, tcx), ret)]\n     pub(super) fn try_push_stack(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n@@ -79,8 +80,10 @@ impl<'tcx> SearchGraph<'tcx> {\n             Entry::Occupied(entry_index) => {\n                 let entry_index = *entry_index.get();\n \n-                cache.add_dependency_of_leaf_on(entry_index);\n                 let stack_depth = cache.depth(entry_index);\n+                debug!(\"encountered cycle with depth {stack_depth:?}\");\n+\n+                cache.add_dependency_of_leaf_on(entry_index);\n \n                 self.stack[stack_depth].has_been_used = true;\n                 // NOTE: The goals on the stack aren't the only goals involved in this cycle.\n@@ -117,6 +120,7 @@ impl<'tcx> SearchGraph<'tcx> {\n     /// updated the provisional cache and we have to recompute the current goal.\n     ///\n     /// FIXME: Refer to the rustc-dev-guide entry once it exists.\n+    #[instrument(level = \"debug\", skip(self, tcx, actual_goal), ret)]\n     pub(super) fn try_finalize_goal(\n         &mut self,\n         tcx: TyCtxt<'tcx>,"}, {"sha": "f6d0b9713f0d0ca1d03da77d4e798516beee410e", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -1230,20 +1230,23 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                     }\n \n                     ty::PredicateKind::WellFormed(ty) => {\n-                        if self.tcx.sess.opts.unstable_opts.trait_solver == TraitSolver::Classic {\n-                            // WF predicates cannot themselves make\n-                            // errors. They can only block due to\n-                            // ambiguity; otherwise, they always\n-                            // degenerate into other obligations\n-                            // (which may fail).\n-                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                        } else {\n-                            // FIXME: we'll need a better message which takes into account\n-                            // which bounds actually failed to hold.\n-                            self.tcx.sess.struct_span_err(\n-                                span,\n-                                &format!(\"the type `{}` is not well-formed\", ty),\n-                            )\n+                        match self.tcx.sess.opts.unstable_opts.trait_solver {\n+                            TraitSolver::Classic => {\n+                                // WF predicates cannot themselves make\n+                                // errors. They can only block due to\n+                                // ambiguity; otherwise, they always\n+                                // degenerate into other obligations\n+                                // (which may fail).\n+                                span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n+                            }\n+                            TraitSolver::Chalk | TraitSolver::Next => {\n+                                // FIXME: we'll need a better message which takes into account\n+                                // which bounds actually failed to hold.\n+                                self.tcx.sess.struct_span_err(\n+                                    span,\n+                                    &format!(\"the type `{}` is not well-formed\", ty),\n+                                )\n+                            }\n                         }\n                     }\n "}, {"sha": "53cae3e720c5ae6e2ac1fd70a634c53202223d03", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -783,7 +783,7 @@ impl<'tcx> TypeFolder<'tcx> for BoundVarReplacer<'_, 'tcx> {\n             }\n             ty::Bound(debruijn, bound_ty) if debruijn >= self.current_index => {\n                 let universe = self.universe_for(debruijn);\n-                let p = ty::PlaceholderType { universe, name: bound_ty.var };\n+                let p = ty::PlaceholderType { universe, name: bound_ty.kind };\n                 self.mapped_types.insert(p, bound_ty);\n                 self.infcx.tcx.mk_ty(ty::Placeholder(p))\n             }"}, {"sha": "0a4136dc1cfe5f508c252874cf7be7fe43cbd259", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -524,7 +524,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             .kind\n                         {\n                             GenericParamDefKind::Type { .. } => {\n-                                let kind = ty::BoundTyKind::Param(param.name);\n+                                let kind = ty::BoundTyKind::Param(param.def_id, param.name);\n                                 let bound_var = ty::BoundVariableKind::Ty(kind);\n                                 bound_vars.push(bound_var);\n                                 tcx.mk_ty(ty::Bound("}, {"sha": "dbd5f13fe4e8b20462c2c40c009a0b78a4a5a518", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -725,7 +725,7 @@ fn bound_vars_for_item(tcx: TyCtxt<'_>, def_id: DefId) -> SubstsRef<'_> {\n                 ty::INNERMOST,\n                 ty::BoundTy {\n                     var: ty::BoundVar::from(param.index),\n-                    kind: ty::BoundTyKind::Param(param.name),\n+                    kind: ty::BoundTyKind::Param(param.def_id, param.name),\n                 },\n             ))\n             .into(),"}, {"sha": "9c5db3314c5cd6e547a3e94bd44d75ed62d521cd", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -370,7 +370,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Ty<RustInterner<'tcx>>> for Ty<'tcx> {\n             ty::Placeholder(_placeholder) => {\n                 chalk_ir::TyKind::Placeholder(chalk_ir::PlaceholderIndex {\n                     ui: chalk_ir::UniverseIndex { counter: _placeholder.universe.as_usize() },\n-                    idx: _placeholder.name.as_usize(),\n+                    idx: _placeholder.name.expect_anon() as usize,\n                 })\n             }\n             ty::Infer(_infer) => unimplemented!(),\n@@ -452,10 +452,6 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n             ),\n             TyKind::Foreign(def_id) => ty::Foreign(def_id.0),\n             TyKind::Error => return interner.tcx.ty_error(),\n-            TyKind::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n-                universe: ty::UniverseIndex::from_usize(placeholder.ui.counter),\n-                name: ty::BoundVar::from_usize(placeholder.idx),\n-            }),\n             TyKind::Alias(alias_ty) => match alias_ty {\n                 chalk_ir::AliasTy::Projection(projection) => ty::Alias(\n                     ty::Projection,\n@@ -473,13 +469,17 @@ impl<'tcx> LowerInto<'tcx, Ty<'tcx>> for &chalk_ir::Ty<RustInterner<'tcx>> {\n                 ),\n             },\n             TyKind::Function(_quantified_ty) => unimplemented!(),\n-            TyKind::BoundVar(_bound) => ty::Bound(\n-                ty::DebruijnIndex::from_usize(_bound.debruijn.depth() as usize),\n+            TyKind::BoundVar(bound) => ty::Bound(\n+                ty::DebruijnIndex::from_usize(bound.debruijn.depth() as usize),\n                 ty::BoundTy {\n-                    var: ty::BoundVar::from_usize(_bound.index),\n-                    kind: ty::BoundTyKind::Anon,\n+                    var: ty::BoundVar::from_usize(bound.index),\n+                    kind: ty::BoundTyKind::Anon(bound.index as u32),\n                 },\n             ),\n+            TyKind::Placeholder(placeholder) => ty::Placeholder(ty::Placeholder {\n+                universe: ty::UniverseIndex::from_usize(placeholder.ui.counter),\n+                name: ty::BoundTyKind::Anon(placeholder.idx as u32),\n+            }),\n             TyKind::InferenceVar(_, _) => unimplemented!(),\n             TyKind::Dyn(_) => unimplemented!(),\n         };\n@@ -504,7 +504,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n             ty::RePlaceholder(placeholder_region) => {\n                 chalk_ir::LifetimeData::Placeholder(chalk_ir::PlaceholderIndex {\n                     ui: chalk_ir::UniverseIndex { counter: placeholder_region.universe.index() },\n-                    idx: 0,\n+                    idx: 0, // FIXME: This `idx: 0` is sus.\n                 })\n                 .intern(interner)\n             }\n@@ -674,7 +674,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Binders<chalk_ir::QuantifiedWhereClauses<Ru\n         let self_ty = interner.tcx.mk_ty(ty::Bound(\n             // This is going to be wrapped in a binder\n             ty::DebruijnIndex::from_usize(1),\n-            ty::BoundTy { var: ty::BoundVar::from_usize(0), kind: ty::BoundTyKind::Anon },\n+            ty::BoundTy { var: ty::BoundVar::from_usize(0), kind: ty::BoundTyKind::Anon(0) },\n         ));\n         let where_clauses = predicates.into_iter().map(|predicate| {\n             let (predicate, binders, _named_regions) =\n@@ -1038,7 +1038,7 @@ pub(crate) struct ParamsSubstitutor<'tcx> {\n     binder_index: ty::DebruijnIndex,\n     list: Vec<rustc_middle::ty::ParamTy>,\n     next_ty_placeholder: usize,\n-    pub(crate) params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n+    pub(crate) params: rustc_data_structures::fx::FxHashMap<u32, rustc_middle::ty::ParamTy>,\n     pub(crate) named_regions: BTreeMap<DefId, u32>,\n }\n \n@@ -1072,15 +1072,15 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n             ty::Param(param) => match self.list.iter().position(|r| r == &param) {\n                 Some(idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::from_usize(0),\n-                    name: ty::BoundVar::from_usize(idx),\n+                    name: ty::BoundTyKind::Anon(idx as u32),\n                 })),\n                 None => {\n                     self.list.push(param);\n                     let idx = self.list.len() - 1 + self.next_ty_placeholder;\n-                    self.params.insert(idx, param);\n+                    self.params.insert(idx as u32, param);\n                     self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                         universe: ty::UniverseIndex::from_usize(0),\n-                        name: ty::BoundVar::from_usize(idx),\n+                        name: ty::BoundTyKind::Anon(idx as u32),\n                     }))\n                 }\n             },\n@@ -1119,13 +1119,13 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n \n pub(crate) struct ReverseParamsSubstitutor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n+    params: rustc_data_structures::fx::FxHashMap<u32, rustc_middle::ty::ParamTy>,\n }\n \n impl<'tcx> ReverseParamsSubstitutor<'tcx> {\n     pub(crate) fn new(\n         tcx: TyCtxt<'tcx>,\n-        params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n+        params: rustc_data_structures::fx::FxHashMap<u32, rustc_middle::ty::ParamTy>,\n     ) -> Self {\n         Self { tcx, params }\n     }\n@@ -1139,7 +1139,7 @@ impl<'tcx> TypeFolder<'tcx> for ReverseParamsSubstitutor<'tcx> {\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n             ty::Placeholder(ty::PlaceholderType { universe: ty::UniverseIndex::ROOT, name }) => {\n-                match self.params.get(&name.as_usize()) {\n+                match self.params.get(&name.expect_anon()) {\n                     Some(param) => self.tcx.mk_ty(ty::Param(*param)),\n                     None => t,\n                 }\n@@ -1171,7 +1171,8 @@ impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n             ty::Placeholder(p) if p.universe == self.universe_index => {\n-                self.next_ty_placeholder = self.next_ty_placeholder.max(p.name.as_usize() + 1);\n+                self.next_ty_placeholder =\n+                    self.next_ty_placeholder.max(p.name.expect_anon() as usize + 1);\n             }\n \n             _ => (),\n@@ -1186,6 +1187,7 @@ impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n                 if let ty::BoundRegionKind::BrAnon(anon, _) = p.name {\n                     self.next_anon_region_placeholder = self.next_anon_region_placeholder.max(anon);\n                 }\n+                // FIXME: This doesn't seem to handle BrNamed at all?\n             }\n \n             _ => (),"}, {"sha": "5855a8e28dd1d0e0efd8de964215de1046e5353d", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -6,12 +6,10 @@\n pub(crate) mod db;\n pub(crate) mod lowering;\n \n-use rustc_data_structures::fx::FxHashMap;\n-\n use rustc_middle::infer::canonical::{CanonicalTyVarKind, CanonicalVarKind};\n use rustc_middle::traits::ChalkRustInterner;\n use rustc_middle::ty::query::Providers;\n-use rustc_middle::ty::{self, ParamTy, TyCtxt, TypeFoldable, TypeVisitable};\n+use rustc_middle::ty::{self, TyCtxt, TypeFoldable, TypeVisitable};\n \n use rustc_infer::infer::canonical::{\n     Canonical, CanonicalVarValues, Certainty, QueryRegionConstraints, QueryResponse,\n@@ -41,7 +39,7 @@ pub(crate) fn evaluate_goal<'tcx>(\n     let mut params_substitutor =\n         ParamsSubstitutor::new(tcx, placeholders_collector.next_ty_placeholder);\n     let obligation = obligation.fold_with(&mut params_substitutor);\n-    let params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n+    let params = params_substitutor.params;\n \n     let max_universe = obligation.max_universe.index();\n "}, {"sha": "ac09a805975efc1521e63a9a482493ab5724ec3d", "filename": "library/std/src/net/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fnet%2Ftcp.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -829,7 +829,7 @@ impl TcpListener {\n     /// }\n     ///\n     /// fn main() -> std::io::Result<()> {\n-    ///     let listener = TcpListener::bind(\"127.0.0.1:80\").unwrap();\n+    ///     let listener = TcpListener::bind(\"127.0.0.1:80\")?;\n     ///\n     ///     for stream in listener.incoming() {\n     ///         match stream {"}, {"sha": "bd7548003ad3b0cb1cd25a26dd8895d6f49cf3b8", "filename": "src/librustdoc/html/render/print_item.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fprint_item.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -355,7 +355,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n             }\n \n             clean::ImportItem(ref import) => {\n-                let (stab, stab_tags) = if let Some(import_def_id) = import.source.did {\n+                let stab_tags = if let Some(import_def_id) = import.source.did {\n                     let ast_attrs = cx.tcx().get_attrs_unchecked(import_def_id);\n                     let import_attrs = Box::new(clean::Attributes::from_ast(ast_attrs));\n \n@@ -367,15 +367,12 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                         ..myitem.clone()\n                     };\n \n-                    let stab = import_item.stability_class(cx.tcx());\n                     let stab_tags = Some(extra_info_tags(&import_item, item, cx.tcx()));\n-                    (stab, stab_tags)\n+                    stab_tags\n                 } else {\n-                    (None, None)\n+                    None\n                 };\n \n-                let add = if stab.is_some() { \" \" } else { \"\" };\n-\n                 w.write_str(ITEM_TABLE_ROW_OPEN);\n                 let id = match import.kind {\n                     clean::ImportKind::Simple(s) => {\n@@ -391,11 +388,10 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                 };\n                 write!(\n                     w,\n-                    \"<div class=\\\"item-left{add}{stab}\\\"{id}>\\\n+                    \"<div class=\\\"item-left\\\"{id}>\\\n                          <code>{vis}{imp}</code>\\\n                      </div>\\\n                      {stab_tags_before}{stab_tags}{stab_tags_after}\",\n-                    stab = stab.unwrap_or_default(),\n                     vis = visibility_print_with_space(myitem.visibility(tcx), myitem.item_id, cx),\n                     imp = import.print(cx),\n                 );\n@@ -417,9 +413,6 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                     _ => \"\",\n                 };\n \n-                let stab = myitem.stability_class(cx.tcx());\n-                let add = if stab.is_some() { \" \" } else { \"\" };\n-\n                 let visibility_emoji = match myitem.visibility(tcx) {\n                     Some(ty::Visibility::Restricted(_)) => {\n                         \"<span title=\\\"Restricted Visibility\\\">&nbsp;\ud83d\udd12</span> \"\n@@ -437,7 +430,7 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                 };\n                 write!(\n                     w,\n-                    \"<div class=\\\"item-left{add}{stab}\\\">\\\n+                    \"<div class=\\\"item-left\\\">\\\n                         <a class=\\\"{class}\\\" href=\\\"{href}\\\" title=\\\"{title}\\\">{name}</a>\\\n                         {visibility_emoji}\\\n                         {unsafety_flag}\\\n@@ -448,8 +441,6 @@ fn item_module(w: &mut Buffer, cx: &mut Context<'_>, item: &clean::Item, items:\n                     visibility_emoji = visibility_emoji,\n                     stab_tags = extra_info_tags(myitem, item, cx.tcx()),\n                     class = myitem.type_(),\n-                    add = add,\n-                    stab = stab.unwrap_or_default(),\n                     unsafety_flag = unsafety_flag,\n                     href = item_path(myitem.type_(), myitem.name.unwrap().as_str()),\n                     title = [myitem.type_().to_string(), full_path(cx, myitem)]"}, {"sha": "dad27c66a3de59f586cf5a7ad1ad67f9ebb323f7", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -1,3 +1,11 @@\n+/* When static files are updated, their suffixes need to be updated.\n+\t1. In the top directory run:\n+\t\t./x.py doc --stage 1 library/core\n+\t2. Find the directory containing files named with updated suffixes:\n+\t\tfind build -path '*'/stage1-std/'*'/static.files\n+\t3. Copy the filenames with updated suffixes from the directory.\n+*/\n+\n /* See FiraSans-LICENSE.txt for the Fira Sans license. */\n @font-face {\n \tfont-family: 'Fira Sans';\n@@ -22,23 +30,23 @@\n \tfont-style: normal;\n \tfont-weight: 400;\n \tsrc: local('Source Serif 4'),\n-\t\turl(\"SourceSerif4-Regular-1f7d512b176f0f72.ttf.woff2\") format(\"woff2\");\n+\t\turl(\"SourceSerif4-Regular-46f98efaafac5295.ttf.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n @font-face {\n \tfont-family: 'Source Serif 4';\n \tfont-style: italic;\n \tfont-weight: 400;\n \tsrc: local('Source Serif 4 Italic'),\n-\t\turl(\"SourceSerif4-It-d034fe4ef9d0fa00.ttf.woff2\") format(\"woff2\");\n+\t\turl(\"SourceSerif4-It-acdfaf1a8af734b1.ttf.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n @font-face {\n \tfont-family: 'Source Serif 4';\n \tfont-style: normal;\n \tfont-weight: 700;\n \tsrc: local('Source Serif 4 Bold'),\n-\t\turl(\"SourceSerif4-Bold-124a1ca42af929b6.ttf.woff2\") format(\"woff2\");\n+\t\turl(\"SourceSerif4-Bold-a2c9cd1067f8b328.ttf.woff2\") format(\"woff2\");\n \tfont-display: swap;\n }\n \n@@ -977,10 +985,6 @@ so that we can apply CSS-filters to change the arrow color in themes */\n \t\t0 -1px 0 black;\n }\n \n-.item-left.unstable {\n-\topacity: 0.65;\n-}\n-\n .since {\n \tfont-weight: normal;\n \tfont-size: initial;"}, {"sha": "920f45c4bbadb68b4c8eebbc3c61dfb36bcbf206", "filename": "src/librustdoc/html/static/css/settings.css", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Fsettings.css?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -40,8 +40,6 @@\n }\n \n .setting-check {\n-\tposition: relative;\n-\twidth: 100%;\n \tmargin-right: 20px;\n \tdisplay: flex;\n \talign-items: center;"}, {"sha": "181a07f63bef8f18e42a5a57463e0e60cf8e8035", "filename": "src/librustdoc/html/static/fonts/SourceSerif4-Bold.ttf.woff2", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-Bold.ttf.woff2", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-Bold.ttf.woff2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-Bold.ttf.woff2?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582"}, {"sha": "2ae08a7bedfed08cdfea76039c1bb1fa1d6cdf67", "filename": "src/librustdoc/html/static/fonts/SourceSerif4-It.ttf.woff2", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-It.ttf.woff2", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-It.ttf.woff2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-It.ttf.woff2?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582"}, {"sha": "5871e1f3d1b3362453b3a1f6c493fbefdbd3dcf3", "filename": "src/librustdoc/html/static/fonts/SourceSerif4-LICENSE.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-LICENSE.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-LICENSE.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-LICENSE.md?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -1,4 +1,4 @@\n-Copyright 2014-2021 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.\n+Copyright 2014 - 2023 Adobe (http://www.adobe.com/), with Reserved Font Name \u2018Source\u2019. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.\n \n This Font Software is licensed under the SIL Open Font License, Version 1.1.\n "}, {"sha": "0263fc304226d90e224e53053855ad138303b70b", "filename": "src/librustdoc/html/static/fonts/SourceSerif4-Regular.ttf.woff2", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-Regular.ttf.woff2", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-Regular.ttf.woff2", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Ffonts%2FSourceSerif4-Regular.ttf.woff2?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582"}, {"sha": "c66f500f42333df8432907e758b771fee142cc5a", "filename": "src/librustdoc/html/static/js/main.js", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fmain.js?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -180,7 +180,6 @@ function browserSupportsHistoryApi() {\n     return window.history && typeof window.history.pushState === \"function\";\n }\n \n-// eslint-disable-next-line no-unused-vars\n function loadCss(cssUrl) {\n     const link = document.createElement(\"link\");\n     link.href = cssUrl;"}, {"sha": "c72ac254fc08cff75f512a4842f6d30cf43eae02", "filename": "src/librustdoc/html/static/js/storage.js", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fstorage.js?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -51,7 +51,6 @@ function hasClass(elem, className) {\n     return elem && elem.classList && elem.classList.contains(className);\n }\n \n-// eslint-disable-next-line no-unused-vars\n function addClass(elem, className) {\n     if (!elem || !elem.classList) {\n         return;"}, {"sha": "b11d5b6c4fa2e820235f074d0554fc8bac1425b8", "filename": "tests/rustdoc/inline_cross/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/tests%2Frustdoc%2Finline_cross%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/tests%2Frustdoc%2Finline_cross%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Finline_cross%2Fmacros.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -6,9 +6,9 @@\n \n extern crate macros;\n \n-// @has foo/index.html '//*[@class=\"item-left unstable deprecated\"]/span[@class=\"stab deprecated\"]' \\\n+// @has foo/index.html '//*[@class=\"item-left\"]/span[@class=\"stab deprecated\"]' \\\n //         Deprecated\n-// @has - '//*[@class=\"item-left unstable deprecated\"]/span[@class=\"stab unstable\"]' \\\n+// @has - '//*[@class=\"item-left\"]/span[@class=\"stab unstable\"]' \\\n //         Experimental\n \n // @has foo/macro.my_macro.html"}, {"sha": "1153a745b0bfecfaf6c9667655346943d2711f5e", "filename": "tests/rustdoc/issue-32374.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/tests%2Frustdoc%2Fissue-32374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/tests%2Frustdoc%2Fissue-32374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fissue-32374.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -2,9 +2,9 @@\n #![doc(issue_tracker_base_url = \"https://issue_url/\")]\n #![unstable(feature = \"test\", issue = \"32374\")]\n \n-// @matches issue_32374/index.html '//*[@class=\"item-left unstable deprecated\"]/span[@class=\"stab deprecated\"]' \\\n+// @matches issue_32374/index.html '//*[@class=\"item-left\"]/span[@class=\"stab deprecated\"]' \\\n //      'Deprecated'\n-// @matches issue_32374/index.html '//*[@class=\"item-left unstable deprecated\"]/span[@class=\"stab unstable\"]' \\\n+// @matches issue_32374/index.html '//*[@class=\"item-left\"]/span[@class=\"stab unstable\"]' \\\n //      'Experimental'\n // @matches issue_32374/index.html '//*[@class=\"item-right docblock-short\"]/text()' 'Docs'\n "}, {"sha": "94fa03385322adad68321606eb5eef43814cbd0a", "filename": "tests/rustdoc/reexport-check.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/tests%2Frustdoc%2Freexport-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad8e1dc2863f63c35ef3ceef3064d0851a1d2582/tests%2Frustdoc%2Freexport-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Freexport-check.rs?ref=ad8e1dc2863f63c35ef3ceef3064d0851a1d2582", "patch": "@@ -4,14 +4,16 @@\n extern crate reexport_check;\n \n // @!has 'foo/index.html' '//code' 'pub use self::i32;'\n-// @has 'foo/index.html' '//div[@class=\"item-left deprecated\"]' 'i32'\n // @has 'foo/i32/index.html'\n #[allow(deprecated, deprecated_in_future)]\n pub use std::i32;\n // @!has 'foo/index.html' '//code' 'pub use self::string::String;'\n // @has 'foo/index.html' '//div[@class=\"item-left\"]' 'String'\n pub use std::string::String;\n \n+// i32 is deprecated, String is not\n+// @count 'foo/index.html' '//span[@class=\"stab deprecated\"]' 1\n+\n // @has 'foo/index.html' '//div[@class=\"item-right docblock-short\"]' 'Docs in original'\n // this is a no-op, but shows what happens if there's an attribute that isn't a doc-comment\n #[doc(inline)]"}]}