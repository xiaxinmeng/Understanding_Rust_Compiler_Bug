{"sha": "a35c53d65ba7d5fe6caed4bd9c94fbf01df2211d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzNWM1M2Q2NWJhN2Q1ZmU2Y2FlZDRiZDljOTRmYmYwMWRmMjIxMWQ=", "commit": {"author": {"name": "rjz", "email": "rj@rjzaworski.com", "date": "2014-10-11T19:55:36Z"}, "committer": {"name": "rjz", "email": "rj@rjzaworski.com", "date": "2014-10-11T20:00:01Z"}, "message": "Tweak copy and formatting of Tasks guide", "tree": {"sha": "54a586992745d5285b928db3f294a16b99d6b0f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54a586992745d5285b928db3f294a16b99d6b0f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a35c53d65ba7d5fe6caed4bd9c94fbf01df2211d", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a35c53d65ba7d5fe6caed4bd9c94fbf01df2211d", "html_url": "https://github.com/rust-lang/rust/commit/a35c53d65ba7d5fe6caed4bd9c94fbf01df2211d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a35c53d65ba7d5fe6caed4bd9c94fbf01df2211d/comments", "author": {"login": "rjz", "id": 499260, "node_id": "MDQ6VXNlcjQ5OTI2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/499260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rjz", "html_url": "https://github.com/rjz", "followers_url": "https://api.github.com/users/rjz/followers", "following_url": "https://api.github.com/users/rjz/following{/other_user}", "gists_url": "https://api.github.com/users/rjz/gists{/gist_id}", "starred_url": "https://api.github.com/users/rjz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rjz/subscriptions", "organizations_url": "https://api.github.com/users/rjz/orgs", "repos_url": "https://api.github.com/users/rjz/repos", "events_url": "https://api.github.com/users/rjz/events{/privacy}", "received_events_url": "https://api.github.com/users/rjz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rjz", "id": 499260, "node_id": "MDQ6VXNlcjQ5OTI2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/499260?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rjz", "html_url": "https://github.com/rjz", "followers_url": "https://api.github.com/users/rjz/followers", "following_url": "https://api.github.com/users/rjz/following{/other_user}", "gists_url": "https://api.github.com/users/rjz/gists{/gist_id}", "starred_url": "https://api.github.com/users/rjz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rjz/subscriptions", "organizations_url": "https://api.github.com/users/rjz/orgs", "repos_url": "https://api.github.com/users/rjz/repos", "events_url": "https://api.github.com/users/rjz/events{/privacy}", "received_events_url": "https://api.github.com/users/rjz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d031d7f86a66270d3cfc28a2ecf75706a67054b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d031d7f86a66270d3cfc28a2ecf75706a67054b", "html_url": "https://github.com/rust-lang/rust/commit/4d031d7f86a66270d3cfc28a2ecf75706a67054b"}], "stats": {"total": 26, "additions": 13, "deletions": 13}, "files": [{"sha": "1d1e9171b8f500ccd577082d4bcd20891809e316", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a35c53d65ba7d5fe6caed4bd9c94fbf01df2211d/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/a35c53d65ba7d5fe6caed4bd9c94fbf01df2211d/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=a35c53d65ba7d5fe6caed4bd9c94fbf01df2211d", "patch": "@@ -41,7 +41,7 @@ concurrency: particularly, ownership. The language leaves the implementation\n details to the standard library.\n \n The `spawn` function has a very simple type signature: `fn spawn(f: proc():\n-Send)`.  Because it accepts only procs, and procs contain only owned data,\n+Send)`. Because it accepts only procs, and procs contain only owned data,\n `spawn` can safely move the entire proc and all its associated state into an\n entirely different task for execution. Like any closure, the function passed to\n `spawn` may capture an environment that it carries across tasks.\n@@ -213,7 +213,7 @@ println!(\"fib(50) = {}\", delayed_fib.get())\n # }\n ```\n \n-The call to `future::spawn` returns immediately a `future` object regardless of\n+The call to `future::spawn` immediately returns a `future` object regardless of\n how long it takes to run `fib(50)`. You can then make yourself a sandwich while\n the computation of `fib` is running. The result of the execution of the method\n is obtained by calling `get` on the future. This call will block until the\n@@ -297,7 +297,7 @@ let numbers_arc = Arc::new(numbers);\n ```\n \n and a clone is captured for each task via a procedure. This only copies\n-the wrapper and not it's contents. Within the task's procedure, the captured\n+the wrapper and not its contents. Within the task's procedure, the captured\n Arc reference can be used as a shared reference to the underlying vector as\n if it were local.\n \n@@ -323,20 +323,20 @@ Rust has a built-in mechanism for raising exceptions. The `fail!()` macro\n (which can also be written with an error string as an argument: `fail!(\n ~reason)`) and the `assert!` construct (which effectively calls `fail!()` if a\n boolean expression is false) are both ways to raise exceptions. When a task\n-raises an exception the task unwinds its stack---running destructors and\n-freeing memory along the way---and then exits. Unlike exceptions in C++,\n+raises an exception, the task unwinds its stack\u2014running destructors and\n+freeing memory along the way\u2014and then exits. Unlike exceptions in C++,\n exceptions in Rust are unrecoverable within a single task: once a task fails,\n there is no way to \"catch\" the exception.\n \n While it isn't possible for a task to recover from failure, tasks may notify\n each other of failure. The simplest way of handling task failure is with the\n-`try` function, which is similar to `spawn`, but immediately blocks waiting for\n-the child task to finish. `try` returns a value of type `Result<T, Box<Any +\n-Send>>`.  `Result` is an `enum` type with two variants: `Ok` and `Err`. In this\n-case, because the type arguments to `Result` are `int` and `()`, callers can\n-pattern-match on a result to check whether it's an `Ok` result with an `int`\n-field (representing a successful result) or an `Err` result (representing\n-termination with an error).\n+`try` function, which is similar to `spawn`, but immediately blocks and waits\n+for the child task to finish. `try` returns a value of type\n+`Result<T, Box<Any + Send>>`. `Result` is an `enum` type with two variants:\n+`Ok` and `Err`. In this case, because the type arguments to `Result` are `int`\n+and `()`, callers can pattern-match on a result to check whether it's an `Ok`\n+result with an `int` field (representing a successful result) or an `Err` result\n+(representing termination with an error).\n \n ```{rust}\n # use std::task;\n@@ -369,4 +369,4 @@ the entire program (perhaps you're writing an assert which, if it trips,\n indicates an unrecoverable logic error); in other cases you might want to\n contain the failure at a certain boundary (perhaps a small piece of input from\n the outside world, which you happen to be processing in parallel, is malformed\n-and its processing task can't proceed).\n+such that the processing task cannot proceed)."}]}