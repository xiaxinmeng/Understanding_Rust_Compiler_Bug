{"sha": "4a2a6bcfb1b014587daa543a9aa618502750e489", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMmE2YmNmYjFiMDE0NTg3ZGFhNTQzYTlhYTYxODUwMjc1MGU0ODk=", "commit": {"author": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-04-28T18:46:02Z"}, "committer": {"name": "Markus Westerlind", "email": "markus.westerlind@distilnetworks.com", "date": "2020-05-05T09:25:12Z"}, "message": "refactor: Move probe_fudge into fudge.rs", "tree": {"sha": "5b4b86f7827fcbaba11d9b912e12d8fbc8b52013", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b4b86f7827fcbaba11d9b912e12d8fbc8b52013"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a2a6bcfb1b014587daa543a9aa618502750e489", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a2a6bcfb1b014587daa543a9aa618502750e489", "html_url": "https://github.com/rust-lang/rust/commit/4a2a6bcfb1b014587daa543a9aa618502750e489", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a2a6bcfb1b014587daa543a9aa618502750e489/comments", "author": null, "committer": null, "parents": [{"sha": "6f495f3466f510ac3db45fc3057b96efed971b7f", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f495f3466f510ac3db45fc3057b96efed971b7f", "html_url": "https://github.com/rust-lang/rust/commit/6f495f3466f510ac3db45fc3057b96efed971b7f"}], "stats": {"total": 83, "additions": 41, "deletions": 42}, "files": [{"sha": "abe952d60f12942d2e9996d73f9c2d7929455c4a", "filename": "src/librustc_infer/infer/fudge.rs", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4a2a6bcfb1b014587daa543a9aa618502750e489/src%2Flibrustc_infer%2Finfer%2Ffudge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a2a6bcfb1b014587daa543a9aa618502750e489/src%2Flibrustc_infer%2Finfer%2Ffudge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ffudge.rs?ref=4a2a6bcfb1b014587daa543a9aa618502750e489", "patch": "@@ -1,9 +1,10 @@\n use rustc_middle::ty::fold::{TypeFoldable, TypeFolder};\n use rustc_middle::ty::{self, ConstVid, FloatVid, IntVid, RegionVid, Ty, TyCtxt, TyVid};\n \n-use super::type_variable::TypeVariableOrigin;\n+use super::region_constraints::RegionSnapshot;\n+use super::type_variable::{self, TypeVariableOrigin};\n use super::InferCtxt;\n-use super::{ConstVariableOrigin, RegionVariableOrigin, UnificationTable};\n+use super::{CombinedSnapshot, ConstVariableOrigin, RegionVariableOrigin, UnificationTable};\n \n use rustc_data_structures::snapshot_vec as sv;\n use rustc_data_structures::unify as ut;\n@@ -35,7 +36,44 @@ fn const_vars_since_snapshot<'tcx>(\n     )\n }\n \n+/// Extends `CombinedSnapshot` by tracking which variables were added in the snapshot\n+#[must_use = \"once you start a snapshot, you should always consume it\"]\n+struct FudgeSnapshot<'a, 'tcx> {\n+    snapshot: CombinedSnapshot<'a, 'tcx>,\n+    region_constraints_snapshot: RegionSnapshot,\n+    type_snapshot: type_variable::Snapshot<'tcx>,\n+    const_var_len: usize,\n+    int_var_len: usize,\n+    float_var_len: usize,\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n+    /// Like `probe` but provides information about which variables were created in the snapshot,\n+    /// allowing for inference fudging\n+    fn probe_fudge<R, F>(&self, f: F) -> R\n+    where\n+        F: FnOnce(&FudgeSnapshot<'a, 'tcx>) -> R,\n+    {\n+        debug!(\"probe()\");\n+        let snapshot = self.start_fudge_snapshot();\n+        let r = f(&snapshot);\n+        self.rollback_to(\"probe\", snapshot.snapshot);\n+        r\n+    }\n+\n+    fn start_fudge_snapshot(&self) -> FudgeSnapshot<'a, 'tcx> {\n+        let snapshot = self.start_snapshot();\n+        let mut inner = self.inner.borrow_mut();\n+        FudgeSnapshot {\n+            snapshot,\n+            type_snapshot: inner.type_variables().snapshot(),\n+            const_var_len: inner.const_unification_table().len(),\n+            int_var_len: inner.int_unification_table().len(),\n+            float_var_len: inner.float_unification_table().len(),\n+            region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n+        }\n+    }\n+\n     /// This rather funky routine is used while processing expected\n     /// types. What happens here is that we want to propagate a\n     /// coercion through the return type of a fn to its"}, {"sha": "679118d7698ef9b2fe0b3efb436ae43ca9aad99b", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4a2a6bcfb1b014587daa543a9aa618502750e489/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a2a6bcfb1b014587daa543a9aa618502750e489/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=4a2a6bcfb1b014587daa543a9aa618502750e489", "patch": "@@ -45,9 +45,7 @@ use self::free_regions::RegionRelations;\n use self::lexical_region_resolve::LexicalRegionResolutions;\n use self::outlives::env::OutlivesEnvironment;\n use self::region_constraints::{GenericKind, RegionConstraintData, VarInfos, VerifyBound};\n-use self::region_constraints::{\n-    RegionConstraintCollector, RegionConstraintStorage, RegionSnapshot,\n-};\n+use self::region_constraints::{RegionConstraintCollector, RegionConstraintStorage};\n use self::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n \n pub mod at;\n@@ -705,17 +703,6 @@ impl<'tcx> InferOk<'tcx, ()> {\n     }\n }\n \n-/// Extends `CombinedSnapshot` by tracking which variables were added in the snapshot\n-#[must_use = \"once you start a snapshot, you should always consume it\"]\n-pub struct FudgeSnapshot<'a, 'tcx> {\n-    snapshot: CombinedSnapshot<'a, 'tcx>,\n-    region_constraints_snapshot: RegionSnapshot,\n-    type_snapshot: type_variable::Snapshot<'tcx>,\n-    const_var_len: usize,\n-    int_var_len: usize,\n-    float_var_len: usize,\n-}\n-\n #[must_use = \"once you start a snapshot, you should always consume it\"]\n pub struct CombinedSnapshot<'a, 'tcx> {\n     undo_snapshot: Snapshot<'tcx>,\n@@ -831,19 +818,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         result\n     }\n \n-    fn start_fudge_snapshot(&self) -> FudgeSnapshot<'a, 'tcx> {\n-        let snapshot = self.start_snapshot();\n-        let mut inner = self.inner.borrow_mut();\n-        FudgeSnapshot {\n-            snapshot,\n-            type_snapshot: inner.type_variables().snapshot(),\n-            const_var_len: inner.const_unification_table().len(),\n-            int_var_len: inner.int_unification_table().len(),\n-            float_var_len: inner.float_unification_table().len(),\n-            region_constraints_snapshot: inner.unwrap_region_constraints().start_snapshot(),\n-        }\n-    }\n-\n     fn start_snapshot(&self) -> CombinedSnapshot<'a, 'tcx> {\n         debug!(\"start_snapshot()\");\n \n@@ -926,19 +900,6 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         r\n     }\n \n-    /// Like `probe` but provides information about which variables were created in the snapshot,\n-    /// allowing for inference fudging\n-    pub fn probe_fudge<R, F>(&self, f: F) -> R\n-    where\n-        F: FnOnce(&FudgeSnapshot<'a, 'tcx>) -> R,\n-    {\n-        debug!(\"probe()\");\n-        let snapshot = self.start_fudge_snapshot();\n-        let r = f(&snapshot);\n-        self.rollback_to(\"probe\", snapshot.snapshot);\n-        r\n-    }\n-\n     /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.\n     pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n     where"}]}