{"sha": "310649bb8e528c8cc91a6467569ba474f22b2271", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMDY0OWJiOGU1MjhjOGNjOTFhNjQ2NzU2OWJhNDc0ZjIyYjIyNzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-24T08:26:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-24T08:26:02Z"}, "message": "Auto merge of #851 - RalfJung:intrptrcast-by-default, r=oli-obk\n\nenable Intrptrcast by default\n\nAs laid out in https://github.com/rust-lang/miri/issues/785: we change Miri to always have an RNG, seeded per default with 0. Then we adjust everything to remove dead code and dead tests.\n\nr? @oli-obk\nCc @christianpoveda", "tree": {"sha": "55954e01f69bd3266a34149185c1dd8d9cc01758", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55954e01f69bd3266a34149185c1dd8d9cc01758"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/310649bb8e528c8cc91a6467569ba474f22b2271", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/310649bb8e528c8cc91a6467569ba474f22b2271", "html_url": "https://github.com/rust-lang/rust/commit/310649bb8e528c8cc91a6467569ba474f22b2271", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/310649bb8e528c8cc91a6467569ba474f22b2271/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b269bb07078446c9c153e0f2acaf83bf8f19b935", "url": "https://api.github.com/repos/rust-lang/rust/commits/b269bb07078446c9c153e0f2acaf83bf8f19b935", "html_url": "https://github.com/rust-lang/rust/commit/b269bb07078446c9c153e0f2acaf83bf8f19b935"}, {"sha": "758d88bbf96c726ca8c620068bb20f552b8bd35a", "url": "https://api.github.com/repos/rust-lang/rust/commits/758d88bbf96c726ca8c620068bb20f552b8bd35a", "html_url": "https://github.com/rust-lang/rust/commit/758d88bbf96c726ca8c620068bb20f552b8bd35a"}], "stats": {"total": 432, "additions": 135, "deletions": 297}, "files": [{"sha": "fbd1f51c9e697972e7ebae7435a9ef25bd2b157d", "filename": "README.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -262,10 +262,10 @@ With this, you should now have a working development setup!  See\n \n Several `-Z` flags are relevant for Miri:\n \n-* `-Zmiri-seed=<hex>` is a custom `-Z` flag added by Miri.  It enables the\n-  interpreted program to seed an RNG with system entropy.  Miri will keep an RNG\n-  on its own that is seeded with the given seed, and use that to generate the\n-  \"system entropy\" that seeds the RNG(s) in the interpreted program.\n+* `-Zmiri-seed=<hex>` is a custom `-Z` flag added by Miri.  It configures the\n+  seed of the RNG that Miri uses to resolve non-determinism.  This RNG is used\n+  to pick base addresses for allocations, and when the interpreted program\n+  requests system entropy.  The default seed is 0.\n   **NOTE**: This entropy is not good enough for cryptographic use!  Do not\n   generate secret keys in Miri or perform other kinds of cryptographic\n   operations that rely on proper random numbers."}, {"sha": "83307c99f9c59bb7a166aebddc1a449b1a893e17", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -34,7 +34,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n         Evaluator::new(),\n-        MemoryExtra::new(config.seed.map(StdRng::seed_from_u64), config.validate),\n+        MemoryExtra::new(StdRng::seed_from_u64(config.seed.unwrap_or(0)), config.validate),\n     );\n \n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);"}, {"sha": "3857020a71f81fd52828a1853c6dbd1b22803baf", "filename": "src/helpers.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -88,25 +88,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             None => return Ok(()), // zero-sized access\n         };\n \n-        let data = match &mut this.memory_mut().extra.rng {\n-            Some(rng) => {\n-                let mut rng = rng.borrow_mut();\n-                let mut data = vec![0; len];\n-                rng.fill_bytes(&mut data);\n-                data\n-            }\n-            None => {\n-                return err!(Unimplemented(\n-                    \"miri does not support gathering system entropy in deterministic mode!\n-                    Use '-Zmiri-seed=<seed>' to enable random number generation.\n-                    WARNING: Miri does *not* generate cryptographically secure entropy -\n-                    do not use Miri to run any program that needs secure random number generation\".to_owned(),\n-                ));\n-            }\n-        };\n+        let rng = this.memory_mut().extra.rng.get_mut();\n+        let mut data = vec![0; len];\n+        rng.fill_bytes(&mut data);\n+\n         let tcx = &{this.tcx.tcx};\n-        this.memory_mut().get_mut(ptr.alloc_id)?\n-            .write_bytes(tcx, ptr, &data)\n+        this.memory_mut().get_mut(ptr.alloc_id)?.write_bytes(tcx, ptr, &data)\n     }\n \n     /// Visits the memory covered by `place`, sensitive to freezing: the 3rd parameter"}, {"sha": "1247150cc1199c1b20f75cfbc979ba57b618449d", "filename": "src/intptrcast.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -42,6 +42,10 @@ impl<'mir, 'tcx> GlobalState {\n         int: u64,\n         memory: &Memory<'mir, 'tcx, Evaluator<'tcx>>,\n     ) -> InterpResult<'tcx, Pointer<Tag>> {\n+        if int == 0 {\n+            return err!(InvalidNullPointerUsage);\n+        }\n+\n         let global_state = memory.extra.intptrcast.borrow();\n         \n         match global_state.int_to_ptr_map.binary_search_by_key(&int, |(addr, _)| *addr) {\n@@ -86,12 +90,13 @@ impl<'mir, 'tcx> GlobalState {\n                 // This allocation does not have a base address yet, pick one.\n                 // Leave some space to the previous allocation, to give it some chance to be less aligned.\n                 let slack = {\n-                    let mut rng = memory.extra.rng.as_ref().unwrap().borrow_mut();\n+                    let mut rng = memory.extra.rng.borrow_mut();\n                     // This means that `(global_state.next_base_addr + slack) % 16` is uniformly distributed.\n                     rng.gen_range(0, 16)\n                 };\n                 // From next_base_addr + slack, round up to adjust for alignment.\n-                let base_addr = Self::align_addr(global_state.next_base_addr + slack, align.bytes());\n+                let base_addr = global_state.next_base_addr.checked_add(slack).unwrap();\n+                let base_addr = Self::align_addr(base_addr, align.bytes());\n                 entry.insert(base_addr);\n                 trace!(\n                     \"Assigning base address {:#x} to allocation {:?} (slack: {}, align: {})\",\n@@ -100,7 +105,7 @@ impl<'mir, 'tcx> GlobalState {\n \n                 // Remember next base address.  If this allocation is zero-sized, leave a gap\n                 // of at least 1 to avoid two allocations having the same base address.\n-                global_state.next_base_addr = base_addr + max(size.bytes(), 1);\n+                global_state.next_base_addr = base_addr.checked_add(max(size.bytes(), 1)).unwrap();\n                 // Given that `next_base_addr` increases in each allocation, pushing the\n                 // corresponding tuple keeps `int_to_ptr_map` sorted\n                 global_state.int_to_ptr_map.push((base_addr, ptr.alloc_id)); \n@@ -120,7 +125,7 @@ impl<'mir, 'tcx> GlobalState {\n     fn align_addr(addr: u64, align: u64) -> u64 {\n         match addr % align {\n             0 => addr,\n-            rem => addr + align - rem\n+            rem => addr.checked_add(align).unwrap() - rem\n         }\n     }\n }"}, {"sha": "d50afec253e80af009606533c4802195a02e7dd0", "filename": "src/machine.rs", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -57,20 +57,19 @@ pub struct MemoryExtra {\n     pub stacked_borrows: stacked_borrows::MemoryExtra,\n     pub intptrcast: intptrcast::MemoryExtra,\n \n-    /// The random number generator to use if Miri is running in non-deterministic mode and to\n-    /// enable intptrcast\n-    pub(crate) rng: Option<RefCell<StdRng>>,\n+    /// The random number generator used for resolving non-determinism.\n+    pub(crate) rng: RefCell<StdRng>,\n \n     /// Whether to enforce the validity invariant.\n     pub(crate) validate: bool,\n }\n \n impl MemoryExtra {\n-    pub fn new(rng: Option<StdRng>, validate: bool) -> Self {\n+    pub fn new(rng: StdRng, validate: bool) -> Self {\n         MemoryExtra {\n             stacked_borrows: Default::default(),\n             intptrcast: Default::default(),\n-            rng: rng.map(RefCell::new),\n+            rng: RefCell::new(rng),\n             validate,\n         }\n     }\n@@ -353,28 +352,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n     }\n \n+    #[inline(always)]\n     fn int_to_ptr(\n         memory: &Memory<'mir, 'tcx, Self>,\n         int: u64,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n-        if int == 0 {\n-            err!(InvalidNullPointerUsage)\n-        } else if memory.extra.rng.is_none() {\n-            err!(ReadBytesAsPointer)\n-        } else {\n-           intptrcast::GlobalState::int_to_ptr(int, memory)\n-        }\n+        intptrcast::GlobalState::int_to_ptr(int, memory)\n     }\n \n+    #[inline(always)]\n     fn ptr_to_int(\n         memory: &Memory<'mir, 'tcx, Self>,\n         ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n-        if memory.extra.rng.is_none() {\n-            err!(ReadPointerAsBytes)\n-        } else {\n-            intptrcast::GlobalState::ptr_to_int(ptr, memory)\n-        }\n+        intptrcast::GlobalState::ptr_to_int(ptr, memory)\n     }\n }\n "}, {"sha": "5eeed5eac635d14e75cd6833bc883466d8271fa3", "filename": "src/operator.rs", "status": "modified", "additions": 7, "deletions": 100, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -56,8 +56,8 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n \n-        // If intptrcast is enabled, treat everything of integer *type* at integer *value*.\n-        if self.memory().extra.rng.is_some() && left.layout.ty.is_integral() {\n+        // Treat everything of integer *type* at integer *value*.\n+        if left.layout.ty.is_integral() {\n             // This is actually an integer operation, so dispatch back to the core engine.\n             // TODO: Once intptrcast is the default, librustc_mir should never even call us\n             // for integer types.\n@@ -188,104 +188,11 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         right: Scalar<Tag>,\n     ) -> InterpResult<'tcx, bool> {\n         let size = self.pointer_size();\n-        if self.memory().extra.rng.is_some() {\n-            // Just compare the integers.\n-            // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?\n-            let left = self.force_bits(left, size)?;\n-            let right = self.force_bits(right, size)?;\n-            return Ok(left == right);\n-        }\n-        Ok(match (left, right) {\n-            (Scalar::Raw { .. }, Scalar::Raw { .. }) =>\n-                left.to_bits(size)? == right.to_bits(size)?,\n-            (Scalar::Ptr(left), Scalar::Ptr(right)) => {\n-                // Comparison illegal if one of them is out-of-bounds, *unless* they\n-                // are in the same allocation.\n-                if left.alloc_id == right.alloc_id {\n-                    left.offset == right.offset\n-                } else {\n-                    // Make sure both pointers are in-bounds.\n-                    // This accepts one-past-the end. Thus, there is still technically\n-                    // some non-determinism that we do not fully rule out when two\n-                    // allocations sit right next to each other. The C/C++ standards are\n-                    // somewhat fuzzy about this case, so pragmatically speaking I think\n-                    // for now this check is \"good enough\".\n-                    // FIXME: Once we support intptrcast, we could try to fix these holes.\n-                    // Dead allocations in miri cannot overlap with live allocations, but\n-                    // on read hardware this can easily happen. Thus for comparisons we require\n-                    // both pointers to be live.\n-                    if self.pointer_inbounds(left).is_ok() && self.pointer_inbounds(right).is_ok() {\n-                        // Two in-bounds (and hence live) pointers in different allocations are different.\n-                        false\n-                    } else {\n-                        return err!(InvalidPointerMath);\n-                    }\n-                }\n-            }\n-            // Comparing ptr and integer.\n-            (Scalar::Ptr(ptr), Scalar::Raw { data, size }) |\n-            (Scalar::Raw { data, size }, Scalar::Ptr(ptr)) => {\n-                assert_eq!(size as u64, self.pointer_size().bytes());\n-                let bits = data as u64;\n-\n-                // Case I: Comparing real pointers with \"small\" integers.\n-                // Really we should only do this for NULL, but pragmatically speaking on non-bare-metal systems,\n-                // an allocation will never be at the very bottom of the address space.\n-                // Such comparisons can arise when comparing empty slices, which sometimes are \"fake\"\n-                // integer pointers (okay because the slice is empty) and sometimes point into a\n-                // real allocation.\n-                // The most common source of such integer pointers is `NonNull::dangling()`, which\n-                // equals the type's alignment. i128 might have an alignment of 16 bytes, but few types have\n-                // alignment 32 or higher, hence the limit of 32.\n-                // FIXME: Once we support intptrcast, we could try to fix these holes.\n-                if bits < 32 {\n-                    // Test if the pointer can be different from NULL or not.\n-                    // We assume that pointers that are not NULL are also not \"small\".\n-                    if !self.memory().ptr_may_be_null(ptr) {\n-                        return Ok(false);\n-                    }\n-                }\n-\n-                let (alloc_size, alloc_align) = self.memory()\n-                    .get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n-                    .expect(\"alloc info with MaybeDead cannot fail\");\n-\n-                // Case II: Alignment gives it away\n-                if ptr.offset.bytes() % alloc_align.bytes() == 0 {\n-                    // The offset maintains the allocation alignment, so we know `base+offset`\n-                    // is aligned by `alloc_align`.\n-                    // FIXME: We could be even more general, e.g., offset 2 into a 4-aligned\n-                    // allocation cannot equal 3.\n-                    if bits % alloc_align.bytes() != 0 {\n-                        // The integer is *not* aligned. So they cannot be equal.\n-                        return Ok(false);\n-                    }\n-                }\n-                // Case III: The integer is too big, and the allocation goes on a bit\n-                // without wrapping around the address space.\n-                {\n-                    // Compute the highest address at which this allocation could live.\n-                    // Substract one more, because it must be possible to add the size\n-                    // to the base address without overflowing; that is, the very last address\n-                    // of the address space is never dereferencable (but it can be in-bounds, i.e.,\n-                    // one-past-the-end).\n-                    let max_base_addr =\n-                        ((1u128 << self.pointer_size().bits())\n-                         - u128::from(alloc_size.bytes())\n-                         - 1\n-                        ) as u64;\n-                    if let Some(max_addr) = max_base_addr.checked_add(ptr.offset.bytes()) {\n-                        if bits > max_addr {\n-                            // The integer is too big, this cannot possibly be equal.\n-                            return Ok(false)\n-                        }\n-                    }\n-                }\n-\n-                // None of the supported cases.\n-                return err!(InvalidPointerMath);\n-            }\n-        })\n+        // Just compare the integers.\n+        // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?\n+        let left = self.force_bits(left, size)?;\n+        let right = self.force_bits(right, size)?;\n+        Ok(left == right)\n     }\n \n     fn ptr_int_arithmetic("}, {"sha": "6dad2a4727306f2bdf33e4e7e5b8719ac72240cc", "filename": "tests/compile-fail/cast_box_int_to_fn_ptr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_box_int_to_fn_ptr.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -4,8 +4,8 @@\n fn main() {\n     let b = Box::new(42);\n     let g = unsafe {\n-        std::mem::transmute::<&usize, &fn(i32)>(&b)\n+        std::mem::transmute::<&Box<usize>, &fn(i32)>(&b)\n     };\n \n-    (*g)(42) //~ ERROR a memory access tried to interpret some bytes as a pointer\n+    (*g)(42) //~ ERROR tried to treat a memory pointer as a function pointer\n }"}, {"sha": "4fd14751a279a38921665409efdf033f6041a4b4", "filename": "tests/compile-fail/cast_int_to_fn_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast_int_to_fn_ptr.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -6,5 +6,5 @@ fn main() {\n         std::mem::transmute::<usize, fn(i32)>(42)\n     };\n \n-    g(42) //~ ERROR a memory access tried to interpret some bytes as a pointer\n+    g(42) //~ ERROR dangling pointer was dereferenced\n }"}, {"sha": "246893a5c640f2e30132abeba8431e7a991ed79c", "filename": "tests/compile-fail/getrandom.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fgetrandom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fgetrandom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fgetrandom.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,13 +0,0 @@\n-// ignore-macos: Uses Linux-only APIs\n-// ignore-windows: Uses Linux-only APIs\n-\n-#![feature(rustc_private)]\n-extern crate libc;\n-\n-fn main() {\n-    let mut buf = [0u8; 5];\n-    unsafe {\n-        libc::syscall(libc::SYS_getrandom, buf.as_mut_ptr() as *mut libc::c_void, 5 as libc::size_t, 0 as libc::c_uint);\n-        //~^ ERROR miri does not support gathering system entropy in deterministic mode!\n-    }\n-}"}, {"sha": "4e12a8a9e25e18ee872c5bd9c99aaf7609069ac8", "filename": "tests/compile-fail/intptrcast_alignment_check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fintptrcast_alignment_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fintptrcast_alignment_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintptrcast_alignment_check.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -1,5 +1,5 @@\n // Validation makes this fail in the wrong place\n-// compile-flags: -Zmiri-disable-validation -Zmiri-seed=0000000000000000\n+// compile-flags: -Zmiri-disable-validation\n \n // Even with intptrcast and without validation, we want to be *sure* to catch bugs\n // that arise from pointers being insufficiently aligned. The only way to achieve"}, {"sha": "f4064cf92e2ca47f89214a821e86bb54ec51817d", "filename": "tests/compile-fail/intptrcast_cast_int_to_fn_ptr.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fintptrcast_cast_int_to_fn_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fintptrcast_cast_int_to_fn_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintptrcast_cast_int_to_fn_ptr.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,10 +0,0 @@\n-// Validation makes this fail in the wrong place\n-// compile-flags: -Zmiri-disable-validation -Zmiri-seed=0000000000000000\n-\n-fn main() {\n-    let g = unsafe {\n-        std::mem::transmute::<usize, fn(i32)>(42)\n-    };\n-\n-    g(42) //~ ERROR dangling pointer was dereferenced\n-}"}, {"sha": "0c5d46609cf83ac71ac4277a5365b3d82ab87e99", "filename": "tests/compile-fail/intptrcast_null_pointer_deref.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fintptrcast_null_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fintptrcast_null_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintptrcast_null_pointer_deref.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,6 +0,0 @@\n-// compile-flags: -Zmiri-seed=0000000000000000\n-\n-fn main() {\n-    let x: i32 = unsafe { *std::ptr::null() }; //~ ERROR invalid use of NULL pointer\n-    panic!(\"this should never print: {}\", x);\n-}"}, {"sha": "2ee664eb68bd3da356da1fbecce54d0bdb94b15f", "filename": "tests/compile-fail/intptrcast_wild_pointer_deref.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fintptrcast_wild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fintptrcast_wild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fintptrcast_wild_pointer_deref.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,7 +0,0 @@\n-// compile-flags: -Zmiri-seed=0000000000000000\n-\n-fn main() {\n-    let p = 44 as *const i32;\n-    let x = unsafe { *p }; //~ ERROR dangling pointer was dereferenced\n-    panic!(\"this should never print: {}\", x);\n-}"}, {"sha": "ddb9bc1f995f28448c6ca1b7dccc05a09225bbc6", "filename": "tests/compile-fail/pointer_byte_read.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fpointer_byte_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fpointer_byte_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "previous_filename": "tests/compile-fail/pointer_byte_read_2.rs"}, {"sha": "a584863654cef267071ce6724fae3a0a0a074141", "filename": "tests/compile-fail/pointer_byte_read_1.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpointer_byte_read_1.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let x = 13;\n-    let y = &x;\n-    let z = &y as *const &i32 as *const usize;\n-    let ptr_bytes = unsafe { *z }; // the actual deref is fine, because we read the entire pointer at once\n-    let _val = ptr_bytes / 432; //~ ERROR invalid arithmetic on pointers that would leak base addresses\n-}"}, {"sha": "2706b0970d7d586212d8c1e6d1e97212ec61332f", "filename": "tests/compile-fail/ptr_bitops1.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_bitops1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_bitops1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_bitops1.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,7 +0,0 @@\n-fn main() {\n-    let bytes = [0i8, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n-    let one = bytes.as_ptr().wrapping_offset(1);\n-    let three = bytes.as_ptr().wrapping_offset(3);\n-    let res = (one as usize) | (three as usize); //~ ERROR invalid arithmetic on pointers that would leak base addresses\n-    println!(\"{}\", res);\n-}"}, {"sha": "5d5eab155083b4f6e34ca4f69e2f62a751e13c79", "filename": "tests/compile-fail/ptr_bitops2.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_bitops2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_bitops2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_bitops2.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    let val = 13usize;\n-    let addr = &val as *const _ as usize;\n-    let _val = addr & 13; //~ ERROR access part of a pointer value as raw bytes\n-}"}, {"sha": "5badf099e4391ae5b939aa4f23abbdd2b5826224", "filename": "tests/compile-fail/ptr_eq_dangling.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_eq_dangling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_eq_dangling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_eq_dangling.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,10 +0,0 @@\n-fn main() {\n-    let b = Box::new(0);\n-    let x = &*b as *const i32; // soon-to-be dangling\n-    drop(b);\n-    let b = Box::new(0);\n-    let y = &*b as *const i32; // different allocation\n-    // We cannot compare these even though both are inbounds -- they *could* be\n-    // equal if memory was reused.\n-    assert!(x != y); //~ ERROR invalid arithmetic on pointers\n-}"}, {"sha": "396abaf4493b13c961e5c82c38c0db5758c98548", "filename": "tests/compile-fail/ptr_eq_integer.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_eq_integer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_eq_integer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_eq_integer.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,6 +0,0 @@\n-fn main() {\n-    let b = Box::new(0);\n-    let x = &*b as *const i32;\n-    // We cannot compare this with a non-NULL integer. After all, these *could* be equal (with the right base address).\n-    assert!(x != 64 as *const i32); //~ ERROR invalid arithmetic on pointers\n-}"}, {"sha": "7efa446d7fca489f97254dd90bb0bdd9b428d979", "filename": "tests/compile-fail/ptr_eq_out_of_bounds.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,9 +0,0 @@\n-fn main() {\n-    let b = Box::new(0);\n-    let x = (&*b as *const i32).wrapping_sub(0x800); // out-of-bounds\n-    let b = Box::new(0);\n-    let y = &*b as *const i32; // different allocation\n-    // We cannot compare these even though both allocations are live -- they *could* be\n-    // equal (with the right base addresses).\n-    assert!(x != y); //~ ERROR invalid arithmetic on pointers\n-}"}, {"sha": "3b7b51fc19954f50394f787b587b6b01836b88bb", "filename": "tests/compile-fail/ptr_eq_out_of_bounds_null.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_eq_out_of_bounds_null.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,6 +0,0 @@\n-fn main() {\n-    let b = Box::new(0);\n-    let x = (&*b as *const i32).wrapping_sub(0x800); // out-of-bounds\n-    // We cannot compare this with NULL. After all, this *could* be NULL (with the right base address).\n-    assert!(x != std::ptr::null()); //~ ERROR invalid arithmetic on pointers\n-}"}, {"sha": "a823a0f49b630fe8454ccf99700f077e653558a0", "filename": "tests/compile-fail/ptr_int_cast.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_int_cast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_int_cast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_int_cast.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,8 +0,0 @@\n-fn main() {\n-    let x = &1;\n-    // Casting down to u8 and back up to a pointer loses too much precision; this must not work.\n-    let x = x as *const i32;\n-    let x = x as u8; //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n-    let x = x as *const i32;\n-    let _val = unsafe { *x };\n-}"}, {"sha": "051874696b11629fa8678adeb791f5fba13406cb", "filename": "tests/compile-fail/ptr_offset_int_plus_int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fptr_offset_int_plus_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fptr_offset_int_plus_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_offset_int_plus_int.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: tried to interpret some bytes as a pointer\n+// error-pattern: dangling pointer was dereferenced\n \n fn main() {\n     // Can't offset an integer pointer by non-zero offset."}, {"sha": "bd90d06909177a3aabf19fe4083c796c9e71bebb", "filename": "tests/compile-fail/ptr_offset_int_plus_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fptr_offset_int_plus_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fptr_offset_int_plus_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_offset_int_plus_ptr.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: pointer value as raw bytes\n+// error-pattern: dangling pointer was dereferenced\n \n fn main() {\n     let ptr = Box::into_raw(Box::new(0u32));"}, {"sha": "dfc91e9dc1b12eba0805296eab816917dec8b9f2", "filename": "tests/compile-fail/ptr_rem.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_rem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_rem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_rem.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,5 +0,0 @@\n-fn main() {\n-    let val = 13usize;\n-    let addr = &val as *const _ as usize;\n-    let _val = addr % 16; //~ ERROR access part of a pointer value as raw bytes\n-}"}, {"sha": "eacb9f07fffd79be6663c124841bd785bcca0859", "filename": "tests/compile-fail/ptr_wrapping_offset_int_plus_ptr.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_wrapping_offset_int_plus_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Fcompile-fail%2Fptr_wrapping_offset_int_plus_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_wrapping_offset_int_plus_ptr.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,8 +0,0 @@\n-// error-pattern: pointer value as raw bytes\n-\n-fn main() {\n-    let ptr = Box::into_raw(Box::new(0u32));\n-    // Can't start with an integer pointer and get to something usable\n-    let ptr = (1 as *mut u8).wrapping_offset(ptr as isize);\n-    let _val = unsafe { *ptr };\n-}"}, {"sha": "194445b1ad7e1758a0be54b0ee42ed98b1f53b1e", "filename": "tests/compile-fail/validity/dangling_ref1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fvalidity%2Fdangling_ref1.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -1,5 +1,5 @@\n use std::mem;\n \n fn main() {\n-    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR dangling reference (created from integer)\n+    let _x: &i32 = unsafe { mem::transmute(16usize) }; //~ ERROR dangling reference (not entirely in bounds)\n }"}, {"sha": "ae32f7d5562bde9bb890b3ce18ae94a89baaf067", "filename": "tests/compile-fail/wild_pointer_deref.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompile-fail%2Fwild_pointer_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fwild_pointer_deref.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -1,5 +1,5 @@\n fn main() {\n     let p = 44 as *const i32;\n-    let x = unsafe { *p }; //~ ERROR a memory access tried to interpret some bytes as a pointer\n+    let x = unsafe { *p }; //~ ERROR dangling pointer was dereferenced\n     panic!(\"this should never print: {}\", x);\n }"}, {"sha": "9394084ad34dcdd11e508b0c43d58df4dbae9ac3", "filename": "tests/compiletest.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -68,7 +68,7 @@ fn compile_fail(path: &str, target: &str, opt: bool) {\n     run_tests(\"compile-fail\", path, target, flags);\n }\n \n-fn miri_pass(path: &str, target: &str, opt: bool, noseed: bool) {\n+fn miri_pass(path: &str, target: &str, opt: bool) {\n     let opt_str = if opt { \" with optimizations\" } else { \"\" };\n     eprintln!(\"{}\", format!(\n         \"## Running run-pass tests in {} against miri for target {}{}\",\n@@ -80,9 +80,6 @@ fn miri_pass(path: &str, target: &str, opt: bool, noseed: bool) {\n     let mut flags = Vec::new();\n     if opt {\n         flags.push(\"-Zmir-opt-level=3\".to_owned());\n-    } else if !noseed {\n-        // Run with intptrcast.  Avoid test matrix explosion by doing either this or opt-level=3.\n-        flags.push(\"-Zmiri-seed=\".to_owned());\n     }\n \n     run_tests(\"ui\", path, target, flags);\n@@ -106,8 +103,7 @@ fn get_target() -> String {\n }\n \n fn run_pass_miri(opt: bool) {\n-    miri_pass(\"tests/run-pass\", &get_target(), opt, false);\n-    miri_pass(\"tests/run-pass-noseed\", &get_target(), opt, true);\n+    miri_pass(\"tests/run-pass\", &get_target(), opt);\n }\n \n fn compile_fail_miri(opt: bool) {"}, {"sha": "1b5251c91119a074e5d3286837ea5e16e4575bcf", "filename": "tests/run-pass-noseed/intptrcast.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Frun-pass-noseed%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b269bb07078446c9c153e0f2acaf83bf8f19b935/tests%2Frun-pass-noseed%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fintptrcast.rs?ref=b269bb07078446c9c153e0f2acaf83bf8f19b935", "patch": "@@ -1,26 +0,0 @@\n-// compile-flags: -Zmiri-seed=0000000000000000\n-\n-// This returns a miri pointer at type usize, if the argument is a proper pointer\n-fn transmute_ptr_to_int<T>(x: *const T) -> usize {\n-    unsafe { std::mem::transmute(x) }\n-}\n-\n-fn main() {\n-    // Some casting-to-int with arithmetic.\n-    let x = &42 as *const i32 as usize;\n-    let y = x * 2;\n-    assert_eq!(y, x + x);\n-    let z = y as u8 as usize;\n-    assert_eq!(z, y % 256);\n-\n-    // Pointer string formatting! We can't check the output as it changes when libstd changes,\n-    // but we can make sure Miri does not error.\n-    format!(\"{:?}\", &mut 13 as *mut _);\n-\n-    // Check that intptrcast is triggered for explicit casts and that it is consistent with\n-    // transmuting.\n-    let a: *const i32 = &42;\n-    let b = transmute_ptr_to_int(a) as u8;\n-    let c = a as usize as u8;\n-    assert_eq!(b, c);\n-}"}, {"sha": "a30f0fb61314a9eec937056a624da5047c33ed3e", "filename": "tests/run-pass/bitop-beyond-alignment.rs", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Frun-pass%2Fbitop-beyond-alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Frun-pass%2Fbitop-beyond-alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbitop-beyond-alignment.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -28,10 +28,10 @@ fn mk_rec() -> Rec {\n fn is_u64_aligned(u: &Tag<u64>) -> bool {\n     let p: usize = unsafe { mem::transmute(u) };\n     let u64_align = std::mem::align_of::<u64>();\n-    return (p & (u64_align + 1)) == 0; //~ ERROR a raw memory access tried to access part of a pointer value as raw bytes\n+    return (p & (u64_align + 1)) == 0;\n }\n \n pub fn main() {\n     let x = mk_rec();\n-    assert!(is_u64_aligned(&x.t));\n+    is_u64_aligned(&x.t); // the result of this is non-deterministic (even with a fixed seed, results vary between platforms)\n }", "previous_filename": "tests/compile-fail/bitop-beyond-alignment.rs"}, {"sha": "1ff9c26ba18c789e0359e4e7483fdd0495ee0d73", "filename": "tests/run-pass/hashmap.rs", "status": "renamed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Frun-pass%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Frun-pass%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fhashmap.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -1,5 +1,3 @@\n-// compile-flags: -Zmiri-seed=0000000000000000\n-\n use std::collections::{self, HashMap};\n use std::hash::{BuildHasherDefault, BuildHasher};\n ", "previous_filename": "tests/run-pass-noseed/hashmap.rs"}, {"sha": "7bcb08058c36aa31aad50465429d9b695e8b6970", "filename": "tests/run-pass/heap_allocator.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Frun-pass%2Fheap_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Frun-pass%2Fheap_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fheap_allocator.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -1,4 +1,3 @@\n-// compile-flags: -Zmiri-seed=\n #![feature(allocator_api)]\n \n use std::ptr::NonNull;", "previous_filename": "tests/run-pass-noseed/heap_allocator.rs"}, {"sha": "c2711f9845d0f4bb2e30f5cdd48bd5ebcbd283b9", "filename": "tests/run-pass/intptrcast.rs", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Frun-pass%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Frun-pass%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintptrcast.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -0,0 +1,89 @@\n+// This returns a miri pointer at type usize, if the argument is a proper pointer\n+fn transmute_ptr_to_int<T>(x: *const T) -> usize {\n+    unsafe { std::mem::transmute(x) }\n+}\n+\n+fn cast() {\n+    // Some casting-to-int with arithmetic.\n+    let x = &42 as *const i32 as usize;\n+    let y = x * 2;\n+    assert_eq!(y, x + x);\n+    let z = y as u8 as usize;\n+    assert_eq!(z, y % 256);\n+}\n+\n+fn format() {\n+    // Pointer string formatting! We can't check the output as it changes when libstd changes,\n+    // but we can make sure Miri does not error.\n+    format!(\"{:?}\", &mut 13 as *mut _);\n+}\n+\n+fn transmute() {\n+    // Check that intptrcast is triggered for explicit casts and that it is consistent with\n+    // transmuting.\n+    let a: *const i32 = &42;\n+    let b = transmute_ptr_to_int(a) as u8;\n+    let c = a as usize as u8;\n+    assert_eq!(b, c);\n+}\n+\n+fn ptr_bitops1() {\n+    let bytes = [0i8, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n+    let one = bytes.as_ptr().wrapping_offset(1);\n+    let three = bytes.as_ptr().wrapping_offset(3);\n+    let res = (one as usize) | (three as usize);\n+    format!(\"{}\", res);\n+}\n+\n+fn ptr_bitops2() {\n+    let val = 13usize;\n+    let addr = &val as *const _ as usize;\n+    let _val = addr & 13;\n+}\n+\n+fn ptr_eq_dangling() {\n+    let b = Box::new(0);\n+    let x = &*b as *const i32; // soon-to-be dangling\n+    drop(b);\n+    let b = Box::new(0);\n+    let y = &*b as *const i32; // different allocation\n+    // We cannot compare these even though both are inbounds -- they *could* be\n+    // equal if memory was reused.\n+    assert!(x != y);\n+}\n+\n+fn ptr_eq_out_of_bounds() {\n+    let b = Box::new(0);\n+    let x = (&*b as *const i32).wrapping_sub(0x800); // out-of-bounds\n+    let b = Box::new(0);\n+    let y = &*b as *const i32; // different allocation\n+    // We cannot compare these even though both allocations are live -- they *could* be\n+    // equal (with the right base addresses).\n+    assert!(x != y);\n+}\n+\n+fn ptr_eq_out_of_bounds_null() {\n+    let b = Box::new(0);\n+    let x = (&*b as *const i32).wrapping_sub(0x800); // out-of-bounds\n+    // We cannot compare this with NULL. After all, this *could* be NULL (with the right base address).\n+    assert!(x != std::ptr::null());\n+}\n+\n+fn ptr_eq_integer() {\n+    let b = Box::new(0);\n+    let x = &*b as *const i32;\n+    // We cannot compare this with a non-NULL integer. After all, these *could* be equal (with the right base address).\n+    assert!(x != 64 as *const i32);\n+}\n+\n+fn main() {\n+    cast();\n+    format();\n+    transmute();\n+    ptr_bitops1();\n+    ptr_bitops2();\n+    ptr_eq_dangling();\n+    ptr_eq_out_of_bounds();\n+    ptr_eq_out_of_bounds_null();\n+    ptr_eq_integer();\n+}"}, {"sha": "f66263425ee867a2f9d43d46bacd411813330920", "filename": "tests/run-pass/malloc.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Frun-pass%2Fmalloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/310649bb8e528c8cc91a6467569ba474f22b2271/tests%2Frun-pass%2Fmalloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fmalloc.rs?ref=310649bb8e528c8cc91a6467569ba474f22b2271", "patch": "@@ -1,5 +1,4 @@\n //ignore-windows: Uses POSIX APIs\n-//compile-flags: -Zmiri-seed=\n \n #![feature(rustc_private)]\n ", "previous_filename": "tests/run-pass-noseed/malloc.rs"}]}