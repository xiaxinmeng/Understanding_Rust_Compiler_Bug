{"sha": "9f800457dda7ee9b8579394d1c07761f3008e573", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmODAwNDU3ZGRhN2VlOWI4NTc5Mzk0ZDFjMDc3NjFmMzAwOGU1NzM=", "commit": {"author": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-03-26T17:34:32Z"}, "committer": {"name": "Alexander Regueiro", "email": "alexreg@me.com", "date": "2019-05-20T15:12:49Z"}, "message": "Ban multi-trait objects via trait aliases.", "tree": {"sha": "bb254d502d1f96b1cf06800da9321fdfd87cb9dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bb254d502d1f96b1cf06800da9321fdfd87cb9dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f800457dda7ee9b8579394d1c07761f3008e573", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f800457dda7ee9b8579394d1c07761f3008e573", "html_url": "https://github.com/rust-lang/rust/commit/9f800457dda7ee9b8579394d1c07761f3008e573", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f800457dda7ee9b8579394d1c07761f3008e573/comments", "author": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexreg", "id": 67036, "node_id": "MDQ6VXNlcjY3MDM2", "avatar_url": "https://avatars.githubusercontent.com/u/67036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexreg", "html_url": "https://github.com/alexreg", "followers_url": "https://api.github.com/users/alexreg/followers", "following_url": "https://api.github.com/users/alexreg/following{/other_user}", "gists_url": "https://api.github.com/users/alexreg/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexreg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexreg/subscriptions", "organizations_url": "https://api.github.com/users/alexreg/orgs", "repos_url": "https://api.github.com/users/alexreg/repos", "events_url": "https://api.github.com/users/alexreg/events{/privacy}", "received_events_url": "https://api.github.com/users/alexreg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16ef2957705392abd6a7d9ac46619863ac339ef1", "url": "https://api.github.com/repos/rust-lang/rust/commits/16ef2957705392abd6a7d9ac46619863ac339ef1", "html_url": "https://github.com/rust-lang/rust/commit/16ef2957705392abd6a7d9ac46619863ac339ef1"}], "stats": {"total": 348, "additions": 215, "deletions": 133}, "files": [{"sha": "8768f1ff081c1f1fadfc7a291867dfd06db8bee4", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -123,12 +123,12 @@ pub use core::slice::{RChunks, RChunksMut, RChunksExact, RChunksExactMut};\n ////////////////////////////////////////////////////////////////////////////////\n \n // HACK(japaric) needed for the implementation of `vec!` macro during testing\n-// NB see the hack module in this file for more details\n+// N.B., see the `hack` module in this file for more details.\n #[cfg(test)]\n pub use hack::into_vec;\n \n // HACK(japaric) needed for the implementation of `Vec::clone` during testing\n-// NB see the hack module in this file for more details\n+// N.B., see the `hack` module in this file for more details.\n #[cfg(test)]\n pub use hack::to_vec;\n \n@@ -376,7 +376,7 @@ impl<T> [T] {\n     pub fn to_vec(&self) -> Vec<T>\n         where T: Clone\n     {\n-        // NB see hack module in this file\n+        // N.B., see the `hack` module in this file for more details.\n         hack::to_vec(self)\n     }\n \n@@ -397,7 +397,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn into_vec(self: Box<Self>) -> Vec<T> {\n-        // NB see hack module in this file\n+        // N.B., see the `hack` module in this file for more details.\n         hack::into_vec(self)\n     }\n "}, {"sha": "23f4d20857135f62036a61d111b126d239ccedc6", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -957,7 +957,7 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    /// Returns the name associated with the given NodeId's AST.\n+    /// Returns the name associated with the given `NodeId`'s AST.\n     pub fn name(&self, id: NodeId) -> Name {\n         let hir_id = self.node_to_hir_id(id);\n         self.name_by_hir_id(hir_id)"}, {"sha": "fafe1cf85a3e9a08bedeb6e234c24c1153dd7ebc", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -2143,11 +2143,11 @@ pub enum UseKind {\n     ListStem,\n }\n \n-/// TraitRef's appear in impls.\n+/// `TraitRef` are references to traits in impls.\n ///\n-/// resolve maps each TraitRef's ref_id to its defining trait; that's all\n-/// that the ref_id is for. Note that ref_id's value is not the NodeId of the\n-/// trait being referred to but just a unique NodeId that serves as a key\n+/// `resolve` maps each `TraitRef`'s `ref_id` to its defining trait; that's all\n+/// that the `ref_id` is for. Note that `ref_id`'s value is not the `NodeId` of the\n+/// trait being referred to but just a unique `NodeId` that serves as a key\n /// within the resolution map.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct TraitRef {"}, {"sha": "5b8d89c865a594069e8c7600b6688f8c9ca53618", "filename": "src/librustc/infer/outlives/verify.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fverify.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -141,9 +141,9 @@ impl<'cx, 'gcx, 'tcx> VerifyBoundCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn recursive_type_bound(&self, ty: Ty<'tcx>) -> VerifyBound<'tcx> {\n-        let mut bounds = ty.walk_shallow()\n+        let mut bounds: Vec<_> = ty.walk_shallow()\n             .map(|subty| self.type_bound(subty))\n-            .collect::<Vec<_>>();\n+            .collect();\n \n         let mut regions = smallvec![];\n         ty.push_regions(&mut regions);"}, {"sha": "627f923399b55621e9c0101ee741ad0c2382b527", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -62,6 +62,7 @@ pub use self::engine::{TraitEngine, TraitEngineExt};\n pub use self::util::{elaborate_predicates, elaborate_trait_ref, elaborate_trait_refs};\n pub use self::util::{supertraits, supertrait_def_ids, transitive_bounds,\n                      Supertraits, SupertraitDefIds};\n+pub use self::util::{expand_trait_refs, TraitRefExpander};\n \n pub use self::chalk_fulfill::{\n     CanonicalGoal as ChalkCanonicalGoal,\n@@ -1043,7 +1044,7 @@ fn vtable_methods<'a, 'tcx>(\n     )\n }\n \n-impl<'tcx,O> Obligation<'tcx,O> {\n+impl<'tcx, O> Obligation<'tcx,O> {\n     pub fn new(cause: ObligationCause<'tcx>,\n                param_env: ty::ParamEnv<'tcx>,\n                predicate: O)"}, {"sha": "ec5e127a5ec4b0b4e326a628ef970cea839d2e7b", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -1772,7 +1772,8 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             bounds\n         );\n \n-        let matching_bound = util::elaborate_predicates(self.tcx(), bounds.predicates)\n+        let elaborated_predicates = util::elaborate_predicates(self.tcx(), bounds.predicates);\n+        let matching_bound = elaborated_predicates\n             .filter_to_traits()\n             .find(|bound| {\n                 self.infcx.probe(|_| {"}, {"sha": "897681e538e3c6857c1df99fec1d839eac3fd539", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 155, "deletions": 60, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -1,3 +1,5 @@\n+use syntax_pos::Span;\n+\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::traits::specialize::specialization_graph::NodeItem;\n@@ -41,7 +43,6 @@ fn anonymize_predicate<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     }\n }\n \n-\n struct PredicateSet<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     set: FxHashSet<ty::Predicate<'tcx>>,\n@@ -73,12 +74,11 @@ impl<'a, 'gcx, 'tcx> PredicateSet<'a, 'gcx, 'tcx> {\n \n /// \"Elaboration\" is the process of identifying all the predicates that\n /// are implied by a source predicate. Currently this basically means\n-/// walking the \"supertraits\" and other similar assumptions. For\n-/// example, if we know that `T : Ord`, the elaborator would deduce\n-/// that `T : PartialOrd` holds as well. Similarly, if we have `trait\n-/// Foo : 'static`, and we know that `T : Foo`, then we know that `T :\n-/// 'static`.\n-pub struct Elaborator<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+/// walking the \"supertraits\" and other similar assumptions. For example,\n+/// if we know that `T: Ord`, the elaborator would deduce that `T: PartialOrd`\n+/// holds as well. Similarly, if we have `trait Foo: 'static`, and we know that\n+/// `T: Foo`, then we know that `T: 'static`.\n+pub struct Elaborator<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     stack: Vec<ty::Predicate<'tcx>>,\n     visited: PredicateSet<'a, 'gcx, 'tcx>,\n }\n@@ -96,8 +96,7 @@ pub fn elaborate_trait_refs<'cx, 'gcx, 'tcx>(\n     trait_refs: impl Iterator<Item = ty::PolyTraitRef<'tcx>>)\n     -> Elaborator<'cx, 'gcx, 'tcx>\n {\n-    let predicates = trait_refs.map(|trait_ref| trait_ref.to_predicate())\n-                               .collect();\n+    let predicates = trait_refs.map(|trait_ref| trait_ref.to_predicate()).collect();\n     elaborate_predicates(tcx, predicates)\n }\n \n@@ -120,7 +119,7 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n         let tcx = self.visited.tcx;\n         match *predicate {\n             ty::Predicate::Trait(ref data) => {\n-                // Predicates declared on the trait.\n+                // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n                 let mut predicates: Vec<_> = predicates.predicates\n@@ -130,12 +129,11 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 debug!(\"super_predicates: data={:?} predicates={:?}\",\n                        data, predicates);\n \n-                // Only keep those bounds that we haven't already\n-                // seen.  This is necessary to prevent infinite\n-                // recursion in some cases.  One common case is when\n-                // people define `trait Sized: Sized { }` rather than `trait\n-                // Sized { }`.\n-                predicates.retain(|r| self.visited.insert(r));\n+                // Only keep those bounds that we haven't already seen.\n+                // This is necessary to prevent infinite recursion in some\n+                // cases. One common case is when people define\n+                // `trait Sized: Sized { }` rather than `trait Sized { }`.\n+                predicates.retain(|p| self.visited.insert(p));\n \n                 self.stack.extend(predicates);\n             }\n@@ -161,11 +159,9 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 // Currently, we do not elaborate const-evaluatable\n                 // predicates.\n             }\n-\n             ty::Predicate::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }\n-\n             ty::Predicate::TypeOutlives(ref data) => {\n                 // We know that `T: 'a` for some type `T`. We can\n                 // often elaborate this. For example, if we know that\n@@ -192,34 +188,35 @@ impl<'cx, 'gcx, 'tcx> Elaborator<'cx, 'gcx, 'tcx> {\n                 tcx.push_outlives_components(ty_max, &mut components);\n                 self.stack.extend(\n                     components\n-                       .into_iter()\n-                       .filter_map(|component| match component {\n-                           Component::Region(r) => if r.is_late_bound() {\n-                               None\n-                           } else {\n-                               Some(ty::Predicate::RegionOutlives(\n-                                   ty::Binder::dummy(ty::OutlivesPredicate(r, r_min))))\n-                           },\n-\n-                           Component::Param(p) => {\n-                               let ty = tcx.mk_ty_param(p.index, p.name);\n-                               Some(ty::Predicate::TypeOutlives(\n-                                   ty::Binder::dummy(ty::OutlivesPredicate(ty, r_min))))\n-                           },\n-\n-                           Component::UnresolvedInferenceVariable(_) => {\n-                               None\n-                           },\n-\n-                           Component::Projection(_) |\n-                           Component::EscapingProjection(_) => {\n-                               // We can probably do more here. This\n-                               // corresponds to a case like `<T as\n-                               // Foo<'a>>::U: 'b`.\n-                               None\n-                           },\n-                       })\n-                       .filter(|p| visited.insert(p)));\n+                        .into_iter()\n+                        .filter_map(|component| match component {\n+                            Component::Region(r) => if r.is_late_bound() {\n+                                None\n+                            } else {\n+                                Some(ty::Predicate::RegionOutlives(\n+                                    ty::Binder::dummy(ty::OutlivesPredicate(r, r_min))))\n+                            }\n+\n+                            Component::Param(p) => {\n+                                let ty = tcx.mk_ty_param(p.index, p.name);\n+                                Some(ty::Predicate::TypeOutlives(\n+                                    ty::Binder::dummy(ty::OutlivesPredicate(ty, r_min))))\n+                            }\n+\n+                            Component::UnresolvedInferenceVariable(_) => {\n+                                None\n+                            }\n+\n+                            Component::Projection(_) |\n+                            Component::EscapingProjection(_) => {\n+                                // We can probably do more here. This\n+                                // corresponds to a case like `<T as\n+                                // Foo<'a>>::U: 'b`.\n+                                None\n+                            }\n+                        })\n+                        .filter(|p| visited.insert(p))\n+                );\n             }\n         }\n     }\n@@ -233,16 +230,10 @@ impl<'cx, 'gcx, 'tcx> Iterator for Elaborator<'cx, 'gcx, 'tcx> {\n     }\n \n     fn next(&mut self) -> Option<ty::Predicate<'tcx>> {\n-        // Extract next item from top-most stack frame, if any.\n-        let next_predicate = match self.stack.pop() {\n-            Some(predicate) => predicate,\n-            None => {\n-                // No more stack frames. Done.\n-                return None;\n-            }\n-        };\n-        self.push(&next_predicate);\n-        return Some(next_predicate);\n+        self.stack.pop().map(|item| {\n+            self.push(&item);\n+            item\n+        })\n     }\n }\n \n@@ -254,20 +245,124 @@ pub type Supertraits<'cx, 'gcx, 'tcx> = FilterToTraits<Elaborator<'cx, 'gcx, 'tc\n \n pub fn supertraits<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n                                     trait_ref: ty::PolyTraitRef<'tcx>)\n-                                    -> Supertraits<'cx, 'gcx, 'tcx>\n-{\n+                                    -> Supertraits<'cx, 'gcx, 'tcx> {\n     elaborate_trait_ref(tcx, trait_ref).filter_to_traits()\n }\n \n pub fn transitive_bounds<'cx, 'gcx, 'tcx>(tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n                                           bounds: impl Iterator<Item = ty::PolyTraitRef<'tcx>>)\n-                                          -> Supertraits<'cx, 'gcx, 'tcx>\n-{\n+                                          -> Supertraits<'cx, 'gcx, 'tcx> {\n     elaborate_trait_refs(tcx, bounds).filter_to_traits()\n }\n \n+///////////////////////////////////////////////////////////////////////////\n+// `TraitRefExpander` iterator\n+///////////////////////////////////////////////////////////////////////////\n+\n+/// \"Trait reference expansion\" is the process of expanding a sequence of trait\n+/// references into another sequence by transitively following all trait\n+/// aliases. e.g. If you have bounds like `Foo + Send`, a trait alias\n+/// `trait Foo = Bar + Sync;`, and another trait alias\n+/// `trait Bar = Read + Write`, then the bounds would expand to\n+/// `Read + Write + Sync + Send`.\n+pub struct TraitRefExpander<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    stack: Vec<TraitRefExpansionInfo<'tcx>>,\n+    visited: PredicateSet<'a, 'gcx, 'tcx>,\n+}\n+\n+#[derive(Debug, Clone)]\n+pub struct TraitRefExpansionInfo<'tcx> {\n+    pub top_level_trait_ref: ty::PolyTraitRef<'tcx>,\n+    pub top_level_span: Span,\n+    pub trait_ref: ty::PolyTraitRef<'tcx>,\n+    pub span: Span,\n+}\n+\n+pub fn expand_trait_refs<'cx, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n+    trait_refs: impl IntoIterator<Item = (ty::PolyTraitRef<'tcx>, Span)>\n+) -> TraitRefExpander<'cx, 'gcx, 'tcx> {\n+    let mut visited = PredicateSet::new(tcx);\n+    let mut items: Vec<_> =\n+        trait_refs\n+            .into_iter()\n+            .map(|(tr, sp)| TraitRefExpansionInfo {\n+                top_level_trait_ref: tr.clone(),\n+                top_level_span: sp,\n+                trait_ref: tr,\n+                span: sp,\n+            })\n+            .collect();\n+    items.retain(|item| visited.insert(&item.trait_ref.to_predicate()));\n+    TraitRefExpander { stack: items, visited: visited, }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> TraitRefExpander<'cx, 'gcx, 'tcx> {\n+    // Returns `true` if `item` refers to a trait.\n+    fn push(&mut self, item: &TraitRefExpansionInfo<'tcx>) -> bool {\n+        let tcx = self.visited.tcx;\n+\n+        if !tcx.is_trait_alias(item.trait_ref.def_id()) {\n+            return true;\n+        }\n+\n+        // Get predicates declared on the trait.\n+        let predicates = tcx.super_predicates_of(item.trait_ref.def_id());\n+\n+        let mut items: Vec<_> = predicates.predicates\n+            .iter()\n+            .rev()\n+            .filter_map(|(pred, sp)| {\n+                pred.subst_supertrait(tcx, &item.trait_ref)\n+                    .to_opt_poly_trait_ref()\n+                    .map(|trait_ref|\n+                        TraitRefExpansionInfo {\n+                            trait_ref,\n+                            span: *sp,\n+                            ..*item\n+                        }\n+                    )\n+            })\n+            .collect();\n+\n+        debug!(\"expand_trait_refs: trait_ref={:?} items={:?}\",\n+                item.trait_ref, items);\n+\n+        // Only keep those items that we haven't already seen.\n+        items.retain(|i| self.visited.insert(&i.trait_ref.to_predicate()));\n+\n+        self.stack.extend(items);\n+        false\n+    }\n+}\n+\n+impl<'cx, 'gcx, 'tcx> Iterator for TraitRefExpander<'cx, 'gcx, 'tcx> {\n+    type Item = TraitRefExpansionInfo<'tcx>;\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.stack.len(), None)\n+    }\n+\n+    fn next(&mut self) -> Option<TraitRefExpansionInfo<'tcx>> {\n+        loop {\n+            let item = self.stack.pop();\n+            match item {\n+                Some(item) => {\n+                    if self.push(&item) {\n+                        return Some(item);\n+                    }\n+                }\n+                None => {\n+                    return None;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Iterator over def-ids of supertraits\n+///////////////////////////////////////////////////////////////////////////\n \n pub struct SupertraitDefIds<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'gcx, 'tcx>,"}, {"sha": "6020a737853e40a66f9ba88404a3f72b983efc51", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -1234,7 +1234,7 @@ impl<'tcx> TraitPredicate<'tcx> {\n         self.trait_ref.def_id\n     }\n \n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item = Ty<'tcx>> + 'a {\n         self.trait_ref.input_types()\n     }\n \n@@ -2400,7 +2400,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n     pub fn discriminants(\n         &'a self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-    ) -> impl Iterator<Item=(VariantIdx, Discr<'tcx>)> + Captures<'gcx> + 'a {\n+    ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'gcx> + 'a {\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx.global_tcx());\n         let mut prev_discr = None::<Discr<'tcx>>;"}, {"sha": "5f184bf4a7d4c6715db5c63c3396f51592bf8a11", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -1177,13 +1177,13 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n                 );\n             }\n             ast::ImplItemKind::Type(ref ty) => {\n-                // FIXME uses of the assoc type should ideally point to this\n+                // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n                 // trait.\n                 self.visit_ty(ty)\n             }\n             ast::ImplItemKind::Existential(ref bounds) => {\n-                // FIXME uses of the assoc type should ideally point to this\n+                // FIXME: uses of the assoc type should ideally point to this\n                 // 'def' and the name here should be a ref to the def in the\n                 // trait.\n                 for bound in bounds.iter() {\n@@ -1216,7 +1216,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         let hir_id = self.tcx.hir().node_to_hir_id(id);\n         let access = access_from!(self.save_ctxt, root_item, hir_id);\n \n-        // The parent def id of a given use tree is always the enclosing item.\n+        // The parent def-ID of a given use tree is always the enclosing item.\n         let parent = self.save_ctxt.tcx.hir().opt_local_def_id(id)\n             .and_then(|id| self.save_ctxt.tcx.parent(id))\n             .map(id_from_def_id);"}, {"sha": "fc6edc2627bc96f4a0508740c95b971d13856dc1", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 36, "deletions": 51, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -975,35 +975,43 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n \n         if trait_bounds.is_empty() {\n             span_err!(tcx.sess, span, E0224,\n-                      \"at least one non-builtin trait is required for an object type\");\n+                \"at least one non-builtin trait is required for an object type\");\n             return tcx.types.err;\n         }\n \n         let mut projection_bounds = Vec::new();\n         let dummy_self = self.tcx().types.trait_object_dummy_self;\n+        let mut bound_trait_refs = Vec::with_capacity(trait_bounds.len());\n         let (principal, potential_assoc_types) = self.instantiate_poly_trait_ref(\n             &trait_bounds[0],\n             dummy_self,\n             &mut projection_bounds,\n         );\n         debug!(\"principal: {:?}\", principal);\n \n-        for trait_bound in trait_bounds[1..].iter() {\n-            // sanity check for non-principal trait bounds\n-            self.instantiate_poly_trait_ref(trait_bound,\n-                                            dummy_self,\n-                                            &mut vec![]);\n+        for trait_bound in trait_bounds[1..].iter().rev() {\n+            // Sanity check for non-principal trait bounds.\n+            let (tr, _) = self.instantiate_poly_trait_ref(\n+                trait_bound,\n+                dummy_self,\n+                &mut Vec::new()\n+            );\n+            bound_trait_refs.push((tr, trait_bound.span));\n         }\n-\n-        let (mut auto_traits, trait_bounds) = split_auto_traits(tcx, &trait_bounds[1..]);\n-\n-        if !trait_bounds.is_empty() {\n-            let b = &trait_bounds[0];\n-            let span = b.trait_ref.path.span;\n-            struct_span_err!(self.tcx().sess, span, E0225,\n-                \"only auto traits can be used as additional traits in a trait object\")\n-                .span_label(span, \"non-auto additional trait\")\n-                .emit();\n+        bound_trait_refs.push((principal, trait_bounds[0].span));\n+\n+        let expanded_traits = traits::expand_trait_refs(tcx, bound_trait_refs);\n+        let (auto_traits, regular_traits): (Vec<_>, Vec<_>) =\n+            expanded_traits.partition(|i| tcx.trait_is_auto(i.trait_ref.def_id()));\n+        if regular_traits.len() > 1 {\n+            let extra_trait = &regular_traits[1];\n+            let mut err = struct_span_err!(tcx.sess, extra_trait.top_level_span, E0225,\n+                \"only auto traits can be used as additional traits in a trait object\");\n+            err.span_label(extra_trait.span, \"non-auto additional trait\");\n+            if extra_trait.span != extra_trait.top_level_span {\n+                err.span_label(extra_trait.top_level_span, \"expanded from this alias\");\n+            }\n+            err.emit();\n         }\n \n         // Check that there are no gross object safety violations;\n@@ -1024,9 +1032,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             debug!(\"conv_object_ty_poly_trait_ref: observing object predicate `{:?}`\", tr);\n             match tr {\n                 ty::Predicate::Trait(pred) => {\n-                    associated_types.extend(tcx.associated_items(pred.def_id())\n-                                    .filter(|item| item.kind == ty::AssociatedKind::Type)\n-                                    .map(|item| item.def_id));\n+                    associated_types\n+                        .extend(tcx.associated_items(pred.def_id())\n+                        .filter(|item| item.kind == ty::AssociatedKind::Type)\n+                        .map(|item| item.def_id));\n                 }\n                 ty::Predicate::Projection(pred) => {\n                     // A `Self` within the original bound will be substituted with a\n@@ -1145,11 +1154,15 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n             })\n         });\n \n-        // Dedup auto traits so that `dyn Trait + Send + Send` is the same as `dyn Trait + Send`.\n+        // De-duplicate auto traits so that, e.g., `dyn Trait + Send + Send` is the same as\n+        // `dyn Trait + Send`.\n+        let mut auto_traits: Vec<_> =\n+            auto_traits.into_iter().map(|i| i.trait_ref.def_id()).collect();\n         auto_traits.sort();\n         auto_traits.dedup();\n+        debug!(\"auto_traits: {:?}\", auto_traits);\n \n-        // Calling `skip_binder` is okay, because the predicates are re-bound.\n+        // Calling `skip_binder` is okay because the predicates are re-bound.\n         let principal = if tcx.trait_is_auto(existential_principal.def_id()) {\n             ty::ExistentialPredicate::AutoTrait(existential_principal.def_id())\n         } else {\n@@ -1175,14 +1188,13 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                 } else {\n                     self.re_infer(span, None).unwrap_or_else(|| {\n                         span_err!(tcx.sess, span, E0228,\n-                                  \"the lifetime bound for this object type cannot be deduced \\\n-                                   from context; please supply an explicit bound\");\n+                            \"the lifetime bound for this object type cannot be deduced \\\n+                             from context; please supply an explicit bound\");\n                         tcx.lifetimes.re_static\n                     })\n                 }\n             })\n         };\n-\n         debug!(\"region_bound: {:?}\", region_bound);\n \n         let ty = tcx.mk_dynamic(existential_predicates, region_bound);\n@@ -2097,33 +2109,6 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n     }\n }\n \n-/// Divides a list of general trait bounds into two groups: auto traits (e.g., Sync and Send) and\n-/// the remaining general trait bounds.\n-fn split_auto_traits<'a, 'b, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                         trait_bounds: &'b [hir::PolyTraitRef])\n-    -> (Vec<DefId>, Vec<&'b hir::PolyTraitRef>)\n-{\n-    let (auto_traits, trait_bounds): (Vec<_>, _) = trait_bounds.iter().partition(|bound| {\n-        // Checks whether `trait_did` is an auto trait and adds it to `auto_traits` if so.\n-        match bound.trait_ref.path.res {\n-            Res::Def(DefKind::Trait, trait_did) if tcx.trait_is_auto(trait_did) => {\n-                true\n-            }\n-            _ => false\n-        }\n-    });\n-\n-    let auto_traits = auto_traits.into_iter().map(|tr| {\n-        if let Res::Def(DefKind::Trait, trait_did) = tr.trait_ref.path.res {\n-            trait_did\n-        } else {\n-            unreachable!()\n-        }\n-    }).collect::<Vec<_>>();\n-\n-    (auto_traits, trait_bounds)\n-}\n-\n // A helper struct for conveniently grouping a set of bounds which we pass to\n // and return from functions in multiple places.\n #[derive(PartialEq, Eq, Clone, Debug)]"}, {"sha": "590ae9d46e8db42385f9e5856624d96fd69297fc", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -758,7 +758,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates_from_param(&mut self, param_ty: ty::ParamTy) {\n-        // FIXME -- Do we want to commit to this behavior for param bounds?\n+        // FIXME: do we want to commit to this behavior for param bounds?\n \n         let bounds = self.param_env\n             .caller_bounds"}, {"sha": "7e7a8d59266737920c986d7ac5eddeca96d95ad5", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -1019,7 +1019,7 @@ fn check_false_global_bounds<'a, 'gcx, 'tcx>(\n         .iter()\n         .map(|(p, _)| *p)\n         .collect();\n-    // Check elaborated bounds\n+    // Check elaborated bounds.\n     let implied_obligations = traits::elaborate_predicates(fcx.tcx, predicates);\n \n     for pred in implied_obligations {"}, {"sha": "e299518af0be0fc832e33dbea0eab3ad321abb17", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f800457dda7ee9b8579394d1c07761f3008e573/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9f800457dda7ee9b8579394d1c07761f3008e573", "patch": "@@ -2133,10 +2133,10 @@ pub struct TraitRef {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct PolyTraitRef {\n-    /// The `'a` in `<'a> Foo<&'a T>`\n+    /// The `'a` in `<'a> Foo<&'a T>`.\n     pub bound_generic_params: Vec<GenericParam>,\n \n-    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`\n+    /// The `Foo<&'a T>` in `<'a> Foo<&'a T>`.\n     pub trait_ref: TraitRef,\n \n     pub span: Span,"}]}