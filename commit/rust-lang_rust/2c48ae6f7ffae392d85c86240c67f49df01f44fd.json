{"sha": "2c48ae6f7ffae392d85c86240c67f49df01f44fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNDhhZTZmN2ZmYWUzOTJkODVjODYyNDBjNjdmNDlkZjAxZjQ0ZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-09T13:08:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-09T13:08:10Z"}, "message": "Auto merge of #40658 - eddyb:lay-more-out, r=arielb1\n\nUse ty::layout for ABI computation instead of LLVM types.\n\nThis is the first step in creating a backend-agnostic library for computing call ABI details from signatures.\nI wanted to open the PR *before* attempting to move `cabi_*` from trans to avoid rebase churn in #39999.\n**EDIT**: As I suspected, #39999 needs this PR to fully work (see https://github.com/rust-lang/rust/pull/39999#issuecomment-287723379).\n\nThe first 3 commits add more APIs to `ty::layout` and replace non-ABI uses of `sizing_type_of`.\nThese APIs are probably usable by other backends, and miri too (cc @stoklund @solson).\n\nThe last commit rewrites `rustc_trans::cabi_*` to use `ty::layout` and new `rustc_trans::abi` APIs.\nAlso, during the process, a couple trivial bugs were identified and fixed:\n* `msp430`, `nvptx`, `nvptx64`: type sizes *in bytes* were compared with `32` and `64`\n* `x86` (`fastcall`): `f64` was incorrectly not treated the same way as `f32`\n\nAlthough not urgent, this PR also uses the more general \"homogenous aggregate\" logic to fix #32045.", "tree": {"sha": "c06e0af7f5529ddbc0de7bdd9f8908949d190724", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c06e0af7f5529ddbc0de7bdd9f8908949d190724"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c48ae6f7ffae392d85c86240c67f49df01f44fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c48ae6f7ffae392d85c86240c67f49df01f44fd", "html_url": "https://github.com/rust-lang/rust/commit/2c48ae6f7ffae392d85c86240c67f49df01f44fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c48ae6f7ffae392d85c86240c67f49df01f44fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebb10a6131834e14f0685ef399b531444d631e9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebb10a6131834e14f0685ef399b531444d631e9c", "html_url": "https://github.com/rust-lang/rust/commit/ebb10a6131834e14f0685ef399b531444d631e9c"}, {"sha": "f0636b61c7f84962a609e831760db9d77f4f5e14", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0636b61c7f84962a609e831760db9d77f4f5e14", "html_url": "https://github.com/rust-lang/rust/commit/f0636b61c7f84962a609e831760db9d77f4f5e14"}], "stats": {"total": 3261, "additions": 1442, "deletions": 1819}, "files": [{"sha": "8dc298b9c2a1788b1c0fcf0c4e1179c712b820ed", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -89,7 +89,7 @@ impl<'a, 'gcx, 'tcx> ExprVisitor<'a, 'gcx, 'tcx> {\n             let from = unpack_option_like(self.infcx.tcx.global_tcx(), from);\n             match (&from.sty, sk_to) {\n                 (&ty::TyFnDef(..), SizeSkeleton::Known(size_to))\n-                        if size_to == Pointer.size(&self.infcx.tcx.data_layout) => {\n+                        if size_to == Pointer.size(self.infcx) => {\n                     struct_span_err!(self.infcx.tcx.sess, span, E0591,\n                                      \"`{}` is zero-sized and can't be transmuted to `{}`\",\n                                      from, to)"}, {"sha": "54e5de3909086d55728f54d8c35d6884b5ebda32", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 320, "deletions": 28, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -25,6 +25,7 @@ use std::cmp;\n use std::fmt;\n use std::i64;\n use std::iter;\n+use std::ops::Deref;\n \n /// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n /// for a target, which contains everything needed to compute layouts.\n@@ -201,6 +202,16 @@ impl TargetDataLayout {\n     }\n }\n \n+pub trait HasDataLayout: Copy {\n+    fn data_layout(&self) -> &TargetDataLayout;\n+}\n+\n+impl<'a> HasDataLayout for &'a TargetDataLayout {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        self\n+    }\n+}\n+\n /// Endianness of the target, which must match cfg(target-endian).\n #[derive(Copy, Clone)]\n pub enum Endian {\n@@ -241,7 +252,9 @@ impl Size {\n         Size::from_bytes((self.bytes() + mask) & !mask)\n     }\n \n-    pub fn checked_add(self, offset: Size, dl: &TargetDataLayout) -> Option<Size> {\n+    pub fn checked_add<C: HasDataLayout>(self, offset: Size, cx: C) -> Option<Size> {\n+        let dl = cx.data_layout();\n+\n         // Each Size is less than dl.obj_size_bound(), so the sum is\n         // also less than 1 << 62 (and therefore can't overflow).\n         let bytes = self.bytes() + offset.bytes();\n@@ -253,7 +266,9 @@ impl Size {\n         }\n     }\n \n-    pub fn checked_mul(self, count: u64, dl: &TargetDataLayout) -> Option<Size> {\n+    pub fn checked_mul<C: HasDataLayout>(self, count: u64, cx: C) -> Option<Size> {\n+        let dl = cx.data_layout();\n+\n         // Each Size is less than dl.obj_size_bound(), so the sum is\n         // also less than 1 << 62 (and therefore can't overflow).\n         match self.bytes().checked_mul(count) {\n@@ -353,7 +368,9 @@ impl Integer {\n         }\n     }\n \n-    pub fn align(&self, dl: &TargetDataLayout)-> Align {\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        let dl = cx.data_layout();\n+\n         match *self {\n             I1 => dl.i1_align,\n             I8 => dl.i8_align,\n@@ -407,7 +424,9 @@ impl Integer {\n     }\n \n     /// Find the smallest integer with the given alignment.\n-    pub fn for_abi_align(dl: &TargetDataLayout, align: Align) -> Option<Integer> {\n+    pub fn for_abi_align<C: HasDataLayout>(cx: C, align: Align) -> Option<Integer> {\n+        let dl = cx.data_layout();\n+\n         let wanted = align.abi();\n         for &candidate in &[I8, I16, I32, I64] {\n             let ty = Int(candidate);\n@@ -419,7 +438,9 @@ impl Integer {\n     }\n \n     /// Get the Integer type from an attr::IntType.\n-    pub fn from_attr(dl: &TargetDataLayout, ity: attr::IntType) -> Integer {\n+    pub fn from_attr<C: HasDataLayout>(cx: C, ity: attr::IntType) -> Integer {\n+        let dl = cx.data_layout();\n+\n         match ity {\n             attr::SignedInt(IntTy::I8) | attr::UnsignedInt(UintTy::U8) => I8,\n             attr::SignedInt(IntTy::I16) | attr::UnsignedInt(UintTy::U16) => I16,\n@@ -449,7 +470,7 @@ impl Integer {\n         let min_default = I8;\n \n         if let Some(ity) = repr.int {\n-            let discr = Integer::from_attr(&tcx.data_layout, ity);\n+            let discr = Integer::from_attr(tcx, ity);\n             let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n             if discr < fit {\n                 bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n@@ -490,7 +511,9 @@ pub enum Primitive {\n }\n \n impl Primitive {\n-    pub fn size(self, dl: &TargetDataLayout) -> Size {\n+    pub fn size<C: HasDataLayout>(self, cx: C) -> Size {\n+        let dl = cx.data_layout();\n+\n         match self {\n             Int(I1) | Int(I8) => Size::from_bits(8),\n             Int(I16) => Size::from_bits(16),\n@@ -501,7 +524,9 @@ impl Primitive {\n         }\n     }\n \n-    pub fn align(self, dl: &TargetDataLayout) -> Align {\n+    pub fn align<C: HasDataLayout>(self, cx: C) -> Align {\n+        let dl = cx.data_layout();\n+\n         match self {\n             Int(I1) => dl.i1_align,\n             Int(I8) => dl.i8_align,\n@@ -681,8 +706,8 @@ impl<'a, 'gcx, 'tcx> Struct {\n     }\n \n     /// Determine whether a structure would be zero-sized, given its fields.\n-    pub fn would_be_zero_sized<I>(dl: &TargetDataLayout, fields: I)\n-                                  -> Result<bool, LayoutError<'gcx>>\n+    fn would_be_zero_sized<I>(dl: &TargetDataLayout, fields: I)\n+                              -> Result<bool, LayoutError<'gcx>>\n     where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n         for field in fields {\n             let field = field?;\n@@ -830,7 +855,7 @@ pub struct Union {\n }\n \n impl<'a, 'gcx, 'tcx> Union {\n-    pub fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n+    fn new(dl: &TargetDataLayout, packed: bool) -> Union {\n         Union {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n             min_size: Size::from_bytes(0),\n@@ -839,10 +864,10 @@ impl<'a, 'gcx, 'tcx> Union {\n     }\n \n     /// Extend the Struct with more fields.\n-    pub fn extend<I>(&mut self, dl: &TargetDataLayout,\n-                     fields: I,\n-                     scapegoat: Ty<'gcx>)\n-                     -> Result<(), LayoutError<'gcx>>\n+    fn extend<I>(&mut self, dl: &TargetDataLayout,\n+                 fields: I,\n+                 scapegoat: Ty<'gcx>)\n+                 -> Result<(), LayoutError<'gcx>>\n     where I: Iterator<Item=Result<&'a Layout, LayoutError<'gcx>>> {\n         for (index, field) in fields.enumerate() {\n             let field = field?;\n@@ -904,7 +929,8 @@ pub enum Layout {\n         /// If true, the size is exact, otherwise it's only a lower bound.\n         sized: bool,\n         align: Align,\n-        size: Size\n+        element_size: Size,\n+        count: u64\n     },\n \n     /// TyRawPtr or TyRef with a !Sized pointee.\n@@ -1087,25 +1113,35 @@ impl<'a, 'gcx, 'tcx> Layout {\n             // Arrays and slices.\n             ty::TyArray(element, count) => {\n                 let element = element.layout(infcx)?;\n+                let element_size = element.size(dl);\n+                // FIXME(eddyb) Don't use host `usize` for array lengths.\n+                let usize_count: usize = count;\n+                let count = usize_count as u64;\n+                if element_size.checked_mul(count, dl).is_none() {\n+                    return Err(LayoutError::SizeOverflow(ty));\n+                }\n                 Array {\n                     sized: true,\n                     align: element.align(dl),\n-                    size: element.size(dl).checked_mul(count as u64, dl)\n-                                 .map_or(Err(LayoutError::SizeOverflow(ty)), Ok)?\n+                    element_size: element_size,\n+                    count: count\n                 }\n             }\n             ty::TySlice(element) => {\n+                let element = element.layout(infcx)?;\n                 Array {\n                     sized: false,\n-                    align: element.layout(infcx)?.align(dl),\n-                    size: Size::from_bytes(0)\n+                    align: element.align(dl),\n+                    element_size: element.size(dl),\n+                    count: 0\n                 }\n             }\n             ty::TyStr => {\n                 Array {\n                     sized: false,\n                     align: dl.i8_align,\n-                    size: Size::from_bytes(0)\n+                    element_size: Size::from_bytes(1),\n+                    count: 0\n                 }\n             }\n \n@@ -1440,22 +1476,32 @@ impl<'a, 'gcx, 'tcx> Layout {\n         }\n     }\n \n-    pub fn size(&self, dl: &TargetDataLayout) -> Size {\n+    pub fn size<C: HasDataLayout>(&self, cx: C) -> Size {\n+        let dl = cx.data_layout();\n+\n         match *self {\n             Scalar { value, .. } | RawNullablePointer { value, .. } => {\n                 value.size(dl)\n             }\n \n             Vector { element, count } => {\n-                let elem_size = element.size(dl);\n-                let vec_size = match elem_size.checked_mul(count, dl) {\n+                let element_size = element.size(dl);\n+                let vec_size = match element_size.checked_mul(count, dl) {\n                     Some(size) => size,\n                     None => bug!(\"Layout::size({:?}): {} * {} overflowed\",\n-                                 self, elem_size.bytes(), count)\n+                                 self, element_size.bytes(), count)\n                 };\n                 vec_size.abi_align(self.align(dl))\n             }\n \n+            Array { element_size, count, .. } => {\n+                match element_size.checked_mul(count, dl) {\n+                    Some(size) => size,\n+                    None => bug!(\"Layout::size({:?}): {} * {} overflowed\",\n+                                 self, element_size.bytes(), count)\n+                }\n+            }\n+\n             FatPointer { metadata, .. } => {\n                 // Effectively a (ptr, meta) tuple.\n                 Pointer.size(dl).abi_align(metadata.align(dl))\n@@ -1464,7 +1510,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n \n             CEnum { discr, .. } => Int(discr).size(dl),\n-            Array { size, .. } | General { size, .. } => size,\n+            General { size, .. } => size,\n             UntaggedUnion { ref variants } => variants.stride(),\n \n             Univariant { ref variant, .. } |\n@@ -1474,7 +1520,9 @@ impl<'a, 'gcx, 'tcx> Layout {\n         }\n     }\n \n-    pub fn align(&self, dl: &TargetDataLayout) -> Align {\n+    pub fn align<C: HasDataLayout>(&self, cx: C) -> Align {\n+        let dl = cx.data_layout();\n+\n         match *self {\n             Scalar { value, .. } | RawNullablePointer { value, .. } => {\n                 value.align(dl)\n@@ -1513,6 +1561,61 @@ impl<'a, 'gcx, 'tcx> Layout {\n             }\n         }\n     }\n+\n+    pub fn field_offset<C: HasDataLayout>(&self,\n+                                          cx: C,\n+                                          i: usize,\n+                                          variant_index: Option<usize>)\n+                                          -> Size {\n+        let dl = cx.data_layout();\n+\n+        match *self {\n+            Scalar { .. } |\n+            CEnum { .. } |\n+            UntaggedUnion { .. } |\n+            RawNullablePointer { .. } => {\n+                Size::from_bytes(0)\n+            }\n+\n+            Vector { element, count } => {\n+                let element_size = element.size(dl);\n+                let i = i as u64;\n+                assert!(i < count);\n+                Size::from_bytes(element_size.bytes() * count)\n+            }\n+\n+            Array { element_size, count, .. } => {\n+                let i = i as u64;\n+                assert!(i < count);\n+                Size::from_bytes(element_size.bytes() * count)\n+            }\n+\n+            FatPointer { metadata, .. } => {\n+                // Effectively a (ptr, meta) tuple.\n+                assert!(i < 2);\n+                if i == 0 {\n+                    Size::from_bytes(0)\n+                } else {\n+                    Pointer.size(dl).abi_align(metadata.align(dl))\n+                }\n+            }\n+\n+            Univariant { ref variant, .. } => variant.offsets[i],\n+\n+            General { ref variants, .. } => {\n+                let v = variant_index.expect(\"variant index required\");\n+                variants[v].offsets[i + 1]\n+            }\n+\n+            StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n+                if Some(nndiscr as usize) == variant_index {\n+                    nonnull.offsets[i]\n+                } else {\n+                    Size::from_bytes(0)\n+                }\n+            }\n+        }\n+    }\n }\n \n /// Type size \"skeleton\", i.e. the only information determining a type's size.\n@@ -1544,7 +1647,7 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n         // First try computing a static layout.\n         let err = match ty.layout(infcx) {\n             Ok(layout) => {\n-                return Ok(SizeSkeleton::Known(layout.size(&tcx.data_layout)));\n+                return Ok(SizeSkeleton::Known(layout.size(tcx)));\n             }\n             Err(err) => err\n         };\n@@ -1658,3 +1761,192 @@ impl<'a, 'gcx, 'tcx> SizeSkeleton<'gcx> {\n         }\n     }\n }\n+\n+/// A pair of a type and its layout. Implements various\n+/// type traversal APIs (e.g. recursing into fields).\n+#[derive(Copy, Clone, Debug)]\n+pub struct TyLayout<'tcx> {\n+    pub ty: Ty<'tcx>,\n+    pub layout: &'tcx Layout,\n+    pub variant_index: Option<usize>,\n+}\n+\n+impl<'tcx> Deref for TyLayout<'tcx> {\n+    type Target = Layout;\n+    fn deref(&self) -> &Layout {\n+        self.layout\n+    }\n+}\n+\n+pub trait HasTyCtxt<'tcx>: HasDataLayout {\n+    fn tcx<'a>(&'a self) -> TyCtxt<'a, 'tcx, 'tcx>;\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasDataLayout for TyCtxt<'a, 'gcx, 'tcx> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.data_layout\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for TyCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n+        self.global_tcx()\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasDataLayout for &'a InferCtxt<'a, 'gcx, 'tcx> {\n+    fn data_layout(&self) -> &TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> HasTyCtxt<'gcx> for &'a InferCtxt<'a, 'gcx, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'gcx, 'gcx> {\n+        self.tcx.global_tcx()\n+    }\n+}\n+\n+pub trait LayoutTyper<'tcx>: HasTyCtxt<'tcx> {\n+    type TyLayout;\n+\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout;\n+}\n+\n+impl<'a, 'gcx, 'tcx> LayoutTyper<'gcx> for &'a InferCtxt<'a, 'gcx, 'tcx> {\n+    type TyLayout = Result<TyLayout<'gcx>, LayoutError<'gcx>>;\n+\n+    fn layout_of(self, ty: Ty<'gcx>) -> Self::TyLayout {\n+        let ty = normalize_associated_type(self, ty);\n+\n+        Ok(TyLayout {\n+            ty: ty,\n+            layout: ty.layout(self)?,\n+            variant_index: None\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> TyLayout<'tcx> {\n+    pub fn for_variant(&self, variant_index: usize) -> Self {\n+        TyLayout {\n+            variant_index: Some(variant_index),\n+            ..*self\n+        }\n+    }\n+\n+    pub fn field_offset<C: HasDataLayout>(&self, cx: C, i: usize) -> Size {\n+        self.layout.field_offset(cx, i, self.variant_index)\n+    }\n+\n+    pub fn field_count(&self) -> usize {\n+        // Handle enum/union through the type rather than Layout.\n+        if let ty::TyAdt(def, _) = self.ty.sty {\n+            let v = self.variant_index.unwrap_or(0);\n+            if def.variants.is_empty() {\n+                assert_eq!(v, 0);\n+                return 0;\n+            } else {\n+                return def.variants[v].fields.len();\n+            }\n+        }\n+\n+        match *self.layout {\n+            Scalar { .. } => {\n+                bug!(\"TyLayout::field_count({:?}): not applicable\", self)\n+            }\n+\n+            // Handled above (the TyAdt case).\n+            CEnum { .. } |\n+            General { .. } |\n+            UntaggedUnion { .. } |\n+            RawNullablePointer { .. } |\n+            StructWrappedNullablePointer { .. } => bug!(),\n+\n+            FatPointer { .. } => 2,\n+\n+            Vector { count, .. } |\n+            Array { count, .. } => {\n+                let usize_count = count as usize;\n+                assert_eq!(usize_count as u64, count);\n+                usize_count\n+            }\n+\n+            Univariant { ref variant, .. } => variant.offsets.len(),\n+        }\n+    }\n+\n+    pub fn field_type<C: HasTyCtxt<'tcx>>(&self, cx: C, i: usize) -> Ty<'tcx> {\n+        let tcx = cx.tcx();\n+\n+        let ptr_field_type = |pointee: Ty<'tcx>| {\n+            let slice = |element: Ty<'tcx>| {\n+                assert!(i < 2);\n+                if i == 0 {\n+                    tcx.mk_mut_ptr(element)\n+                } else {\n+                    tcx.types.usize\n+                }\n+            };\n+            match tcx.struct_tail(pointee).sty {\n+                ty::TySlice(element) => slice(element),\n+                ty::TyStr => slice(tcx.types.u8),\n+                ty::TyDynamic(..) => tcx.mk_mut_ptr(tcx.mk_nil()),\n+                _ => bug!(\"TyLayout::field_type({:?}): not applicable\", self)\n+            }\n+        };\n+\n+        match self.ty.sty {\n+            ty::TyBool |\n+            ty::TyChar |\n+            ty::TyInt(_) |\n+            ty::TyUint(_) |\n+            ty::TyFloat(_) |\n+            ty::TyFnPtr(_) |\n+            ty::TyNever |\n+            ty::TyFnDef(..) |\n+            ty::TyDynamic(..) => {\n+                bug!(\"TyLayout::field_type({:?}): not applicable\", self)\n+            }\n+\n+            // Potentially-fat pointers.\n+            ty::TyRef(_, ty::TypeAndMut { ty: pointee, .. }) |\n+            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n+                ptr_field_type(pointee)\n+            }\n+            ty::TyAdt(def, _) if def.is_box() => {\n+                ptr_field_type(self.ty.boxed_ty())\n+            }\n+\n+            // Arrays and slices.\n+            ty::TyArray(element, _) |\n+            ty::TySlice(element) => element,\n+            ty::TyStr => tcx.types.u8,\n+\n+            // Tuples and closures.\n+            ty::TyClosure(def_id, ref substs) => {\n+                substs.upvar_tys(def_id, tcx).nth(i).unwrap()\n+            }\n+\n+            ty::TyTuple(tys, _) => tys[i],\n+\n+            // SIMD vector types.\n+            ty::TyAdt(def, ..) if def.repr.simd => {\n+                self.ty.simd_type(tcx)\n+            }\n+\n+            // ADTs.\n+            ty::TyAdt(def, substs) => {\n+                def.variants[self.variant_index.unwrap_or(0)].fields[i].ty(tcx, substs)\n+            }\n+\n+            ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n+            ty::TyInfer(_) | ty::TyError => {\n+                bug!(\"TyLayout::field_type: unexpected type `{}`\", self.ty)\n+            }\n+        }\n+    }\n+\n+    pub fn field<C: LayoutTyper<'tcx>>(&self, cx: C, i: usize) -> C::TyLayout {\n+        cx.layout_of(self.field_type(cx, i))\n+    }\n+}"}, {"sha": "2318bb81affe67c44c50c0cbf82a1f5a5c24f87d", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -733,7 +733,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                 });\n \n                 if let Layout::General { ref variants, ref size, discr, .. } = *layout {\n-                    let discr_size = Primitive::Int(discr).size(&cx.tcx.data_layout).bytes();\n+                    let discr_size = Primitive::Int(discr).size(cx.tcx).bytes();\n \n                     debug!(\"enum `{}` is {} bytes large with layout:\\n{:#?}\",\n                       t, size.bytes(), layout);"}, {"sha": "7be80a757ca0166a300c275e96a6ca8f1320cd3b", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 403, "deletions": 194, "changes": 597, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{self, ValueRef, Integer, Pointer, Float, Double, Struct, Array, Vector, AttributePlace};\n+use llvm::{self, ValueRef, AttributePlace};\n use base;\n use builder::Builder;\n use common::{type_is_fat_ptr, C_uint};\n@@ -29,19 +29,20 @@ use cabi_sparc;\n use cabi_sparc64;\n use cabi_nvptx;\n use cabi_nvptx64;\n-use machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n+use machine::llalign_of_min;\n use type_::Type;\n use type_of;\n \n use rustc::hir;\n use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, Layout, LayoutTyper, TyLayout, Size};\n \n use libc::c_uint;\n use std::cmp;\n+use std::iter;\n \n pub use syntax::abi::Abi;\n pub use rustc::ty::layout::{FAT_PTR_ADDR, FAT_PTR_EXTRA};\n-use rustc::ty::layout::Layout;\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n enum ArgKind {\n@@ -132,33 +133,293 @@ impl ArgAttributes {\n         }\n     }\n }\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub enum RegKind {\n+    Integer,\n+    Float,\n+    Vector\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+pub struct Reg {\n+    pub kind: RegKind,\n+    pub size: Size,\n+}\n+\n+macro_rules! reg_ctor {\n+    ($name:ident, $kind:ident, $bits:expr) => {\n+        pub fn $name() -> Reg {\n+            Reg {\n+                kind: RegKind::$kind,\n+                size: Size::from_bits($bits)\n+            }\n+        }\n+    }\n+}\n+\n+impl Reg {\n+    reg_ctor!(i8, Integer, 8);\n+    reg_ctor!(i16, Integer, 16);\n+    reg_ctor!(i32, Integer, 32);\n+    reg_ctor!(i64, Integer, 64);\n+\n+    reg_ctor!(f32, Float, 32);\n+    reg_ctor!(f64, Float, 64);\n+}\n+\n+impl Reg {\n+    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+        match self.kind {\n+            RegKind::Integer => Type::ix(ccx, self.size.bits()),\n+            RegKind::Float => {\n+                match self.size.bits() {\n+                    32 => Type::f32(ccx),\n+                    64 => Type::f64(ccx),\n+                    _ => bug!(\"unsupported float: {:?}\", self)\n+                }\n+            }\n+            RegKind::Vector => {\n+                Type::vector(&Type::i8(ccx), self.size.bytes())\n+            }\n+        }\n+    }\n+}\n+\n+/// An argument passed entirely registers with the\n+/// same kind (e.g. HFA / HVA on PPC64 and AArch64).\n+#[derive(Copy, Clone)]\n+pub struct Uniform {\n+    pub unit: Reg,\n+\n+    /// The total size of the argument, which can be:\n+    /// * equal to `unit.size` (one scalar/vector)\n+    /// * a multiple of `unit.size` (an array of scalar/vectors)\n+    /// * if `unit.kind` is `Integer`, the last element\n+    ///   can be shorter, i.e. `{ i64, i64, i32 }` for\n+    ///   64-bit integers with a total size of 20 bytes\n+    pub total: Size,\n+}\n+\n+impl From<Reg> for Uniform {\n+    fn from(unit: Reg) -> Uniform {\n+        Uniform {\n+            unit,\n+            total: unit.size\n+        }\n+    }\n+}\n+\n+impl Uniform {\n+    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+        let llunit = self.unit.llvm_type(ccx);\n+\n+        if self.total <= self.unit.size {\n+            return llunit;\n+        }\n+\n+        let count = self.total.bytes() / self.unit.size.bytes();\n+        let rem_bytes = self.total.bytes() % self.unit.size.bytes();\n+\n+        if rem_bytes == 0 {\n+            return Type::array(&llunit, count);\n+        }\n+\n+        // Only integers can be really split further.\n+        assert_eq!(self.unit.kind, RegKind::Integer);\n+\n+        let args: Vec<_> = (0..count).map(|_| llunit)\n+            .chain(iter::once(Type::ix(ccx, rem_bytes * 8)))\n+            .collect();\n+\n+        Type::struct_(ccx, &args, false)\n+    }\n+}\n+\n+pub trait LayoutExt<'tcx> {\n+    fn is_aggregate(&self) -> bool;\n+    fn homogenous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg>;\n+}\n+\n+impl<'tcx> LayoutExt<'tcx> for TyLayout<'tcx> {\n+    fn is_aggregate(&self) -> bool {\n+        match *self.layout {\n+            Layout::Scalar { .. } |\n+            Layout::RawNullablePointer { .. } |\n+            Layout::CEnum { .. } |\n+            Layout::Vector { .. } => false,\n+\n+            Layout::Array { .. } |\n+            Layout::FatPointer { .. } |\n+            Layout::Univariant { .. } |\n+            Layout::UntaggedUnion { .. } |\n+            Layout::General { .. } |\n+            Layout::StructWrappedNullablePointer { .. } => true\n+        }\n+    }\n+\n+    fn homogenous_aggregate<'a>(&self, ccx: &CrateContext<'a, 'tcx>) -> Option<Reg> {\n+        match *self.layout {\n+            // The primitives for this algorithm.\n+            Layout::Scalar { value, .. } |\n+            Layout::RawNullablePointer { value, .. } => {\n+                let kind = match value {\n+                    layout::Int(_) |\n+                    layout::Pointer => RegKind::Integer,\n+                    layout::F32 |\n+                    layout::F64 => RegKind::Float\n+                };\n+                Some(Reg {\n+                    kind,\n+                    size: self.size(ccx)\n+                })\n+            }\n+\n+            Layout::CEnum { .. } => {\n+                Some(Reg {\n+                    kind: RegKind::Integer,\n+                    size: self.size(ccx)\n+                })\n+            }\n+\n+            Layout::Vector { .. } => {\n+                Some(Reg {\n+                    kind: RegKind::Integer,\n+                    size: self.size(ccx)\n+                })\n+            }\n+\n+            Layout::Array { count, .. } => {\n+                if count > 0 {\n+                    self.field(ccx, 0).homogenous_aggregate(ccx)\n+                } else {\n+                    None\n+                }\n+            }\n+\n+            Layout::Univariant { ref variant, .. } => {\n+                let mut unaligned_offset = Size::from_bytes(0);\n+                let mut result = None;\n+\n+                for i in 0..self.field_count() {\n+                    if unaligned_offset != variant.offsets[i] {\n+                        return None;\n+                    }\n+\n+                    let field = self.field(ccx, i);\n+                    match (result, field.homogenous_aggregate(ccx)) {\n+                        // The field itself must be a homogenous aggregate.\n+                        (_, None) => return None,\n+                        // If this is the first field, record the unit.\n+                        (None, Some(unit)) => {\n+                            result = Some(unit);\n+                        }\n+                        // For all following fields, the unit must be the same.\n+                        (Some(prev_unit), Some(unit)) => {\n+                            if prev_unit != unit {\n+                                return None;\n+                            }\n+                        }\n+                    }\n+\n+                    // Keep track of the offset (without padding).\n+                    let size = field.size(ccx);\n+                    match unaligned_offset.checked_add(size, ccx) {\n+                        Some(offset) => unaligned_offset = offset,\n+                        None => return None\n+                    }\n+                }\n+\n+                // There needs to be no padding.\n+                if unaligned_offset != self.size(ccx) {\n+                    None\n+                } else {\n+                    result\n+                }\n+            }\n+\n+            Layout::UntaggedUnion { .. } => {\n+                let mut max = Size::from_bytes(0);\n+                let mut result = None;\n+\n+                for i in 0..self.field_count() {\n+                    let field = self.field(ccx, i);\n+                    match (result, field.homogenous_aggregate(ccx)) {\n+                        // The field itself must be a homogenous aggregate.\n+                        (_, None) => return None,\n+                        // If this is the first field, record the unit.\n+                        (None, Some(unit)) => {\n+                            result = Some(unit);\n+                        }\n+                        // For all following fields, the unit must be the same.\n+                        (Some(prev_unit), Some(unit)) => {\n+                            if prev_unit != unit {\n+                                return None;\n+                            }\n+                        }\n+                    }\n+\n+                    // Keep track of the offset (without padding).\n+                    let size = field.size(ccx);\n+                    if size > max {\n+                        max = size;\n+                    }\n+                }\n+\n+                // There needs to be no padding.\n+                if max != self.size(ccx) {\n+                    None\n+                } else {\n+                    result\n+                }\n+            }\n+\n+            // Rust-specific types, which we can ignore for C ABIs.\n+            Layout::FatPointer { .. } |\n+            Layout::General { .. } |\n+            Layout::StructWrappedNullablePointer { .. } => None\n+        }\n+    }\n+}\n+\n+pub enum CastTarget {\n+    Uniform(Uniform),\n+    Pair(Reg, Reg)\n+}\n+\n+impl From<Reg> for CastTarget {\n+    fn from(unit: Reg) -> CastTarget {\n+        CastTarget::Uniform(Uniform::from(unit))\n+    }\n+}\n+\n+impl From<Uniform> for CastTarget {\n+    fn from(uniform: Uniform) -> CastTarget {\n+        CastTarget::Uniform(uniform)\n+    }\n+}\n+\n+impl CastTarget {\n+    fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+        match *self {\n+            CastTarget::Uniform(u) => u.llvm_type(ccx),\n+            CastTarget::Pair(a, b) => {\n+                Type::struct_(ccx, &[\n+                    a.llvm_type(ccx),\n+                    b.llvm_type(ccx)\n+                ], false)\n+            }\n+        }\n+    }\n+}\n \n /// Information about how a specific C type\n /// should be passed to or returned from a function\n ///\n /// This is borrowed from clang's ABIInfo.h\n #[derive(Clone, Copy, Debug)]\n-pub struct ArgType {\n+pub struct ArgType<'tcx> {\n     kind: ArgKind,\n-    /// Original LLVM type\n-    pub original_ty: Type,\n-    /// Sizing LLVM type (pointers are opaque).\n-    /// Unlike original_ty, this is guaranteed to be complete.\n-    ///\n-    /// For example, while we're computing the function pointer type in\n-    /// `struct Foo(fn(Foo));`, `original_ty` is still LLVM's `%Foo = {}`.\n-    /// The field type will likely end up being `void(%Foo)*`, but we cannot\n-    /// use `%Foo` to compute properties (e.g. size and alignment) of `Foo`,\n-    /// until `%Foo` is completed by having all of its field types inserted,\n-    /// so `ty` holds the \"sizing type\" of `Foo`, which replaces all pointers\n-    /// with opaque ones, resulting in `{i8*}` for `Foo`.\n-    /// ABI-specific logic can then look at the size, alignment and fields of\n-    /// `{i8*}` in order to determine how the argument will be passed.\n-    /// Only later will `original_ty` aka `%Foo` be used in the LLVM function\n-    /// pointer type, without ever having introspected it.\n-    pub ty: Type,\n-    /// Signedness for integer types, None for other types\n-    pub signedness: Option<bool>,\n+    pub layout: TyLayout<'tcx>,\n     /// Coerced LLVM Type\n     pub cast: Option<Type>,\n     /// Dummy argument, which is emitted before the real argument\n@@ -167,26 +428,24 @@ pub struct ArgType {\n     pub attrs: ArgAttributes\n }\n \n-impl ArgType {\n-    fn new(original_ty: Type, ty: Type) -> ArgType {\n+impl<'a, 'tcx> ArgType<'tcx> {\n+    fn new(layout: TyLayout<'tcx>) -> ArgType<'tcx> {\n         ArgType {\n             kind: ArgKind::Direct,\n-            original_ty: original_ty,\n-            ty: ty,\n-            signedness: None,\n+            layout: layout,\n             cast: None,\n             pad: None,\n             attrs: ArgAttributes::default()\n         }\n     }\n \n-    pub fn make_indirect(&mut self, ccx: &CrateContext) {\n+    pub fn make_indirect(&mut self, ccx: &CrateContext<'a, 'tcx>) {\n         assert_eq!(self.kind, ArgKind::Direct);\n \n         // Wipe old attributes, likely not valid through indirection.\n         self.attrs = ArgAttributes::default();\n \n-        let llarg_sz = llsize_of_alloc(ccx, self.ty);\n+        let llarg_sz = self.layout.size(ccx).bytes();\n \n         // For non-immediate arguments the callee gets its own copy of\n         // the value on the stack, so there are no aliases. It's also\n@@ -205,17 +464,44 @@ impl ArgType {\n \n     pub fn extend_integer_width_to(&mut self, bits: u64) {\n         // Only integers have signedness\n-        if let Some(signed) = self.signedness {\n-            if self.ty.int_width() < bits {\n-                self.attrs.set(if signed {\n-                    ArgAttribute::SExt\n-                } else {\n-                    ArgAttribute::ZExt\n-                });\n+        let (i, signed) = match *self.layout {\n+            Layout::Scalar { value, .. } => {\n+                match value {\n+                    layout::Int(i) => {\n+                        if self.layout.ty.is_integral() {\n+                            (i, self.layout.ty.is_signed())\n+                        } else {\n+                            return;\n+                        }\n+                    }\n+                    _ => return\n+                }\n             }\n+\n+            // Rust enum types that map onto C enums also need to follow\n+            // the target ABI zero-/sign-extension rules.\n+            Layout::CEnum { discr, signed, .. } => (discr, signed),\n+\n+            _ => return\n+        };\n+\n+        if i.size().bits() < bits {\n+            self.attrs.set(if signed {\n+                ArgAttribute::SExt\n+            } else {\n+                ArgAttribute::ZExt\n+            });\n         }\n     }\n \n+    pub fn cast_to<T: Into<CastTarget>>(&mut self, ccx: &CrateContext, target: T) {\n+        self.cast = Some(target.into().llvm_type(ccx));\n+    }\n+\n+    pub fn pad_with(&mut self, ccx: &CrateContext, reg: Reg) {\n+        self.pad = Some(reg.llvm_type(ccx));\n+    }\n+\n     pub fn is_indirect(&self) -> bool {\n         self.kind == ArgKind::Indirect\n     }\n@@ -224,27 +510,33 @@ impl ArgType {\n         self.kind == ArgKind::Ignore\n     }\n \n+    /// Get the LLVM type for an lvalue of the original Rust type of\n+    /// this argument/return, i.e. the result of `type_of::type_of`.\n+    pub fn memory_ty(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n+        type_of::type_of(ccx, self.layout.ty)\n+    }\n+\n     /// Store a direct/indirect value described by this ArgType into a\n     /// lvalue for the original Rust type of this argument/return.\n     /// Can be used for both storing formal arguments into Rust variables\n     /// or results of call/invoke instructions into their destinations.\n-    pub fn store(&self, bcx: &Builder, mut val: ValueRef, dst: ValueRef) {\n+    pub fn store(&self, bcx: &Builder<'a, 'tcx>, mut val: ValueRef, dst: ValueRef) {\n         if self.is_ignore() {\n             return;\n         }\n         let ccx = bcx.ccx;\n         if self.is_indirect() {\n-            let llsz = llsize_of(ccx, self.ty);\n-            let llalign = llalign_of_min(ccx, self.ty);\n+            let llsz = C_uint(ccx, self.layout.size(ccx).bytes());\n+            let llalign = self.layout.align(ccx).abi();\n             base::call_memcpy(bcx, dst, val, llsz, llalign as u32);\n         } else if let Some(ty) = self.cast {\n             // FIXME(eddyb): Figure out when the simpler Store is safe, clang\n             // uses it for i16 -> {i8, i8}, but not for i24 -> {i8, i8, i8}.\n             let can_store_through_cast_ptr = false;\n             if can_store_through_cast_ptr {\n                 let cast_dst = bcx.pointercast(dst, ty.ptr_to());\n-                let llalign = llalign_of_min(ccx, self.ty);\n-                bcx.store(val, cast_dst, Some(llalign));\n+                let llalign = self.layout.align(ccx).abi();\n+                bcx.store(val, cast_dst, Some(llalign as u32));\n             } else {\n                 // The actual return type is a struct, but the ABI\n                 // adaptation code has cast it into some scalar type.  The\n@@ -271,21 +563,21 @@ impl ArgType {\n                 base::call_memcpy(bcx,\n                                   bcx.pointercast(dst, Type::i8p(ccx)),\n                                   bcx.pointercast(llscratch, Type::i8p(ccx)),\n-                                  C_uint(ccx, llsize_of_alloc(ccx, self.ty)),\n-                                  cmp::min(llalign_of_min(ccx, self.ty),\n-                                           llalign_of_min(ccx, ty)) as u32);\n+                                  C_uint(ccx, self.layout.size(ccx).bytes()),\n+                                  cmp::min(self.layout.align(ccx).abi() as u32,\n+                                           llalign_of_min(ccx, ty)));\n \n                 base::Lifetime::End.call(bcx, llscratch);\n             }\n         } else {\n-            if self.original_ty == Type::i1(ccx) {\n+            if self.layout.ty == ccx.tcx().types.bool {\n                 val = bcx.zext(val, Type::i8(ccx));\n             }\n             bcx.store(val, dst, None);\n         }\n     }\n \n-    pub fn store_fn_arg(&self, bcx: &Builder, idx: &mut usize, dst: ValueRef) {\n+    pub fn store_fn_arg(&self, bcx: &Builder<'a, 'tcx>, idx: &mut usize, dst: ValueRef) {\n         if self.pad.is_some() {\n             *idx += 1;\n         }\n@@ -304,40 +596,40 @@ impl ArgType {\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n #[derive(Clone, Debug)]\n-pub struct FnType {\n+pub struct FnType<'tcx> {\n     /// The LLVM types of each argument.\n-    pub args: Vec<ArgType>,\n+    pub args: Vec<ArgType<'tcx>>,\n \n     /// LLVM return type.\n-    pub ret: ArgType,\n+    pub ret: ArgType<'tcx>,\n \n     pub variadic: bool,\n \n     pub cconv: llvm::CallConv\n }\n \n-impl FnType {\n-    pub fn new<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                         sig: ty::FnSig<'tcx>,\n-                         extra_args: &[Ty<'tcx>]) -> FnType {\n+impl<'a, 'tcx> FnType<'tcx> {\n+    pub fn new(ccx: &CrateContext<'a, 'tcx>,\n+               sig: ty::FnSig<'tcx>,\n+               extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n         fn_ty.adjust_for_abi(ccx, sig);\n         fn_ty\n     }\n \n-    pub fn new_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                                sig: ty::FnSig<'tcx>,\n-                                extra_args: &[Ty<'tcx>]) -> FnType {\n+    pub fn new_vtable(ccx: &CrateContext<'a, 'tcx>,\n+                      sig: ty::FnSig<'tcx>,\n+                      extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         let mut fn_ty = FnType::unadjusted(ccx, sig, extra_args);\n         // Don't pass the vtable, it's not an argument of the virtual fn.\n         fn_ty.args[1].ignore();\n         fn_ty.adjust_for_abi(ccx, sig);\n         fn_ty\n     }\n \n-    fn unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n-                            sig: ty::FnSig<'tcx>,\n-                            extra_args: &[Ty<'tcx>]) -> FnType {\n+    pub fn unadjusted(ccx: &CrateContext<'a, 'tcx>,\n+                      sig: ty::FnSig<'tcx>,\n+                      extra_args: &[Ty<'tcx>]) -> FnType<'tcx> {\n         use self::Abi::*;\n         let cconv = match ccx.sess().target.target.adjust_abi(sig.abi) {\n             RustIntrinsic | PlatformIntrinsic |\n@@ -394,23 +686,11 @@ impl FnType {\n         };\n \n         let arg_of = |ty: Ty<'tcx>, is_return: bool| {\n+            let mut arg = ArgType::new(ccx.layout_of(ty));\n             if ty.is_bool() {\n-                let llty = Type::i1(ccx);\n-                let mut arg = ArgType::new(llty, llty);\n                 arg.attrs.set(ArgAttribute::ZExt);\n-                arg\n             } else {\n-                let mut arg = ArgType::new(type_of::type_of(ccx, ty),\n-                                           type_of::sizing_type_of(ccx, ty));\n-                if ty.is_integral() {\n-                    arg.signedness = Some(ty.is_signed());\n-                }\n-                // Rust enum types that map onto C enums also need to follow\n-                // the target ABI zero-/sign-extension rules.\n-                if let Layout::CEnum { signed, .. } = *ccx.layout_of(ty) {\n-                    arg.signedness = Some(signed);\n-                }\n-                if llsize_of_alloc(ccx, arg.ty) == 0 {\n+                if arg.layout.size(ccx).bytes() == 0 {\n                     // For some forsaken reason, x86_64-pc-windows-gnu\n                     // doesn't ignore zero-sized struct arguments.\n                     // The same is true for s390x-unknown-linux-gnu.\n@@ -419,8 +699,8 @@ impl FnType {\n                         arg.ignore();\n                     }\n                 }\n-                arg\n             }\n+            arg\n         };\n \n         let ret_ty = sig.output();\n@@ -439,14 +719,10 @@ impl FnType {\n             match ret_ty.sty {\n                 // These are not really pointers but pairs, (pointer, len)\n                 ty::TyRef(_, ty::TypeAndMut { ty, .. }) => {\n-                    let llty = type_of::sizing_type_of(ccx, ty);\n-                    let llsz = llsize_of_alloc(ccx, llty);\n-                    ret.attrs.set_dereferenceable(llsz);\n+                    ret.attrs.set_dereferenceable(ccx.size_of(ty));\n                 }\n                 ty::TyAdt(def, _) if def.is_box() => {\n-                    let llty = type_of::sizing_type_of(ccx, ret_ty.boxed_ty());\n-                    let llsz = llsize_of_alloc(ccx, llty);\n-                    ret.attrs.set_dereferenceable(llsz);\n+                    ret.attrs.set_dereferenceable(ccx.size_of(ret_ty.boxed_ty()));\n                 }\n                 _ => {}\n             }\n@@ -495,13 +771,9 @@ impl FnType {\n         for ty in inputs.iter().chain(extra_args.iter()) {\n             let mut arg = arg_of(ty, false);\n \n-            if type_is_fat_ptr(ccx, ty) {\n-                let original_tys = arg.original_ty.field_types();\n-                let sizing_tys = arg.ty.field_types();\n-                assert_eq!((original_tys.len(), sizing_tys.len()), (2, 2));\n-\n-                let mut data = ArgType::new(original_tys[0], sizing_tys[0]);\n-                let mut info = ArgType::new(original_tys[1], sizing_tys[1]);\n+            if let ty::layout::FatPointer { .. } = *arg.layout {\n+                let mut data = ArgType::new(arg.layout.field(ccx, 0));\n+                let mut info = ArgType::new(arg.layout.field(ccx, 1));\n \n                 if let Some(inner) = rust_ptr_attrs(ty, &mut data) {\n                     data.attrs.set(ArgAttribute::NonNull);\n@@ -517,9 +789,7 @@ impl FnType {\n                 args.push(info);\n             } else {\n                 if let Some(inner) = rust_ptr_attrs(ty, &mut arg) {\n-                    let llty = type_of::sizing_type_of(ccx, inner);\n-                    let llsz = llsize_of_alloc(ccx, llty);\n-                    arg.attrs.set_dereferenceable(llsz);\n+                    arg.attrs.set_dereferenceable(ccx.size_of(inner));\n                 }\n                 args.push(arg);\n             }\n@@ -533,43 +803,51 @@ impl FnType {\n         }\n     }\n \n-    fn adjust_for_abi<'a, 'tcx>(&mut self,\n-                                ccx: &CrateContext<'a, 'tcx>,\n-                                sig: ty::FnSig<'tcx>) {\n+    fn adjust_for_abi(&mut self,\n+                      ccx: &CrateContext<'a, 'tcx>,\n+                      sig: ty::FnSig<'tcx>) {\n         let abi = sig.abi;\n         if abi == Abi::Unadjusted { return }\n \n         if abi == Abi::Rust || abi == Abi::RustCall ||\n            abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n-            let fixup = |arg: &mut ArgType| {\n-                let mut llty = arg.ty;\n-\n-                // Replace newtypes with their inner-most type.\n-                while llty.kind() == llvm::TypeKind::Struct {\n-                    let inner = llty.field_types();\n-                    if inner.len() != 1 {\n-                        break;\n-                    }\n-                    llty = inner[0];\n+            let fixup = |arg: &mut ArgType<'tcx>| {\n+                if !arg.layout.is_aggregate() {\n+                    return;\n                 }\n \n-                if !llty.is_aggregate() {\n-                    // Scalars and vectors, always immediate.\n-                    if llty != arg.ty {\n+                let size = arg.layout.size(ccx);\n+\n+                if let Some(unit) = arg.layout.homogenous_aggregate(ccx) {\n+                    // Replace newtypes with their inner-most type.\n+                    if unit.size == size {\n                         // Needs a cast as we've unpacked a newtype.\n-                        arg.cast = Some(llty);\n+                        arg.cast_to(ccx, unit);\n+                        return;\n+                    }\n+\n+                    // Pairs of floats.\n+                    if unit.kind == RegKind::Float {\n+                        if unit.size.checked_mul(2, ccx) == Some(size) {\n+                            // FIXME(eddyb) This should be using Uniform instead of a pair,\n+                            // but the resulting [2 x float/double] breaks emscripten.\n+                            // See https://github.com/kripken/emscripten-fastcomp/issues/178.\n+                            arg.cast_to(ccx, CastTarget::Pair(unit, unit));\n+                            return;\n+                        }\n                     }\n-                    return;\n                 }\n \n-                let size = llsize_of_alloc(ccx, llty);\n-                if size > llsize_of_alloc(ccx, ccx.int_type()) {\n+                if size > layout::Pointer.size(ccx) {\n                     arg.make_indirect(ccx);\n-                } else if size > 0 {\n+                } else {\n                     // We want to pass small aggregates as immediates, but using\n                     // a LLVM aggregate type for this leads to bad optimizations,\n                     // so we pick an appropriately sized integer type instead.\n-                    arg.cast = Some(Type::ix(ccx, size * 8));\n+                    arg.cast_to(ccx, Reg {\n+                        kind: RegKind::Integer,\n+                        size\n+                    });\n                 }\n             };\n             // Fat pointers are returned by-value.\n@@ -605,14 +883,7 @@ impl FnType {\n                 cabi_x86_64::compute_abi_info(ccx, self);\n             },\n             \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, self),\n-            \"arm\" => {\n-                let flavor = if ccx.sess().target.target.target_os == \"ios\" {\n-                    cabi_arm::Flavor::Ios\n-                } else {\n-                    cabi_arm::Flavor::General\n-                };\n-                cabi_arm::compute_abi_info(ccx, self, flavor);\n-            },\n+            \"arm\" => cabi_arm::compute_abi_info(ccx, self),\n             \"mips\" => cabi_mips::compute_abi_info(ccx, self),\n             \"mips64\" => cabi_mips64::compute_abi_info(ccx, self),\n             \"powerpc\" => cabi_powerpc::compute_abi_info(ccx, self),\n@@ -633,16 +904,18 @@ impl FnType {\n         }\n     }\n \n-    pub fn llvm_type(&self, ccx: &CrateContext) -> Type {\n+    pub fn llvm_type(&self, ccx: &CrateContext<'a, 'tcx>) -> Type {\n         let mut llargument_tys = Vec::new();\n \n         let llreturn_ty = if self.ret.is_ignore() {\n             Type::void(ccx)\n         } else if self.ret.is_indirect() {\n-            llargument_tys.push(self.ret.original_ty.ptr_to());\n+            llargument_tys.push(self.ret.memory_ty(ccx).ptr_to());\n             Type::void(ccx)\n         } else {\n-            self.ret.cast.unwrap_or(self.ret.original_ty)\n+            self.ret.cast.unwrap_or_else(|| {\n+                type_of::immediate_type_of(ccx, self.ret.layout.ty)\n+            })\n         };\n \n         for arg in &self.args {\n@@ -655,9 +928,11 @@ impl FnType {\n             }\n \n             let llarg_ty = if arg.is_indirect() {\n-                arg.original_ty.ptr_to()\n+                arg.memory_ty(ccx).ptr_to()\n             } else {\n-                arg.cast.unwrap_or(arg.original_ty)\n+                arg.cast.unwrap_or_else(|| {\n+                    type_of::immediate_type_of(ccx, arg.layout.ty)\n+                })\n             };\n \n             llargument_tys.push(llarg_ty);\n@@ -705,72 +980,6 @@ impl FnType {\n     }\n }\n \n-pub fn align_up_to(off: usize, a: usize) -> usize {\n-    return (off + a - 1) / a * a;\n-}\n-\n-fn align(off: usize, ty: Type, pointer: usize) -> usize {\n-    let a = ty_align(ty, pointer);\n-    return align_up_to(off, a);\n-}\n-\n-pub fn ty_align(ty: Type, pointer: usize) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => pointer,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                1\n-            } else {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t, pointer)))\n-            }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ty_align(elt, pointer)\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            ty_align(elt, pointer) * len\n-        }\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n-}\n-\n-pub fn ty_size(ty: Type, pointer: usize) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => pointer,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t, pointer))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter().fold(0, |s, t| {\n-                    align(s, *t, pointer) + ty_size(*t, pointer)\n-                });\n-                align(size, ty, pointer)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt, pointer);\n-            len * eltsz\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt, pointer);\n-            len * eltsz\n-        },\n-        _ => bug!(\"ty_size: unhandled type\")\n-    }\n+pub fn align_up_to(off: u64, a: u64) -> u64 {\n+    (off + a - 1) / a * a\n }"}, {"sha": "0fe180253b5b89c14fad0a77d6d752dd10882567", "filename": "src/librustc_trans/adt.rs", "status": "modified", "additions": 15, "deletions": 34, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fadt.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -46,8 +46,8 @@ use super::Disr;\n use std;\n \n use llvm::{ValueRef, True, IntEQ, IntNE};\n-use rustc::ty::layout;\n-use rustc::ty::{self, Ty, AdtKind};\n+use rustc::ty::{self, Ty};\n+use rustc::ty::layout::{self, LayoutTyper};\n use common::*;\n use builder::Builder;\n use base;\n@@ -95,15 +95,6 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     generic_type_of(cx, t, None, false, false)\n }\n \n-\n-// Pass dst=true if the type you are passing is a DST. Yes, we could figure\n-// this out, but if you call this on an unsized type without realising it, you\n-// are going to get the wrong type (it will not include the unsized parts of it).\n-pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n-                                t: Ty<'tcx>, dst: bool) -> Type {\n-    generic_type_of(cx, t, None, true, dst)\n-}\n-\n pub fn incomplete_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                     t: Ty<'tcx>, name: &str) -> Type {\n     generic_type_of(cx, t, Some(name), false, false)\n@@ -149,7 +140,11 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             };\n             let nnty = monomorphize::field_ty(cx.tcx(), substs,\n                 &def.variants[nndiscr as usize].fields[0]);\n-            type_of::sizing_type_of(cx, nnty)\n+            if let layout::Scalar { value: layout::Pointer, .. } = *cx.layout_of(nnty) {\n+                Type::i8p(cx)\n+            } else {\n+                type_of::type_of(cx, nnty)\n+            }\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n             let fields = compute_fields(cx, t, nndiscr as usize, false);\n@@ -181,10 +176,6 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n             }\n         }\n-        layout::Vector { element, count } => {\n-            let elem_ty = Type::from_primitive(cx, element);\n-            Type::vector(&elem_ty, count)\n-        }\n         layout::UntaggedUnion { ref variants, .. }=> {\n             // Use alignment-sized ints to fill all the union storage.\n             let size = variants.stride().bytes();\n@@ -246,9 +237,8 @@ fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n     assert_eq!(size%align, 0);\n     assert_eq!(align.count_ones(), 1, \"Alignment must be a power fof 2. Got {}\", align);\n     let align_units = size/align;\n-    let dl = &cx.tcx().data_layout;\n     let layout_align = layout::Align::from_bytes(align, align).unwrap();\n-    if let Some(ity) = layout::Integer::for_abi_align(dl, layout_align) {\n+    if let Some(ity) = layout::Integer::for_abi_align(cx, layout_align) {\n         Type::array(&Type::from_integer(cx, ity), align_units)\n     } else {\n         Type::array(&Type::vector(&Type::i32(cx), align/4),\n@@ -259,11 +249,10 @@ fn union_fill(cx: &CrateContext, size: u64, align: u64) -> Type {\n \n fn struct_llfields<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, fields: &Vec<Ty<'tcx>>,\n                              variant: &layout::Struct,\n-                             sizing: bool, dst: bool) -> Vec<Type> {\n+                             sizing: bool, _dst: bool) -> Vec<Type> {\n     let fields = variant.field_index_by_increasing_offset().map(|i| fields[i as usize]);\n     if sizing {\n-        fields.filter(|ty| !dst || cx.shared().type_is_sized(*ty))\n-            .map(|ty| type_of::sizing_type_of(cx, ty)).collect()\n+        bug!()\n     } else {\n         fields.map(|ty| type_of::in_memory_type_of(cx, ty)).collect()\n     }\n@@ -285,31 +274,24 @@ pub fn trans_get_discr<'a, 'tcx>(\n     cast_to: Option<Type>,\n     range_assert: bool\n ) -> ValueRef {\n-    let (def, substs) = match t.sty {\n-        ty::TyAdt(ref def, substs) if def.adt_kind() == AdtKind::Enum => (def, substs),\n-        _ => bug!(\"{} is not an enum\", t)\n-    };\n-\n     debug!(\"trans_get_discr t: {:?}\", t);\n     let l = bcx.ccx.layout_of(t);\n \n     let val = match *l {\n         layout::CEnum { discr, min, max, .. } => {\n             load_discr(bcx, discr, scrutinee, alignment, min, max, range_assert)\n         }\n-        layout::General { discr, .. } => {\n+        layout::General { discr, ref variants, .. } => {\n             let ptr = bcx.struct_gep(scrutinee, 0);\n             load_discr(bcx, discr, ptr, alignment,\n-                       0, def.variants.len() as u64 - 1,\n+                       0, variants.len() as u64 - 1,\n                        range_assert)\n         }\n         layout::Univariant { .. } | layout::UntaggedUnion { .. } => C_u8(bcx.ccx, 0),\n         layout::RawNullablePointer { nndiscr, .. } => {\n             let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n-            let llptrty = type_of::sizing_type_of(bcx.ccx,\n-                monomorphize::field_ty(bcx.tcx(), substs,\n-                &def.variants[nndiscr as usize].fields[0]));\n-            bcx.icmp(cmp, bcx.load(scrutinee, alignment.to_align()), C_null(llptrty))\n+            let discr = bcx.load(scrutinee, alignment.to_align());\n+            bcx.icmp(cmp, discr, C_null(val_ty(discr)))\n         }\n         layout::StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             struct_wrapped_nullable_bitdiscr(bcx, nndiscr, discrfield, scrutinee, alignment)\n@@ -383,9 +365,8 @@ pub fn trans_set_discr<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, val: Valu\n             assert_eq!(to, Disr(0));\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = compute_fields(bcx.ccx, t, nndiscr as usize, false)[0];\n             if to.0 != nndiscr {\n-                let llptrty = type_of::sizing_type_of(bcx.ccx, nnty);\n+                let llptrty = val_ty(val).element_type();\n                 bcx.store(C_null(llptrty), val, None);\n             }\n         }"}, {"sha": "574b345218be9def7543abb1534eb700aae1e23b", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -59,7 +59,6 @@ use context::{SharedCrateContext, CrateContextList};\n use debuginfo;\n use declare;\n use machine;\n-use machine::llsize_of;\n use meth;\n use mir;\n use monomorphize::{self, Instance};\n@@ -534,14 +533,13 @@ pub fn memcpy_ty<'a, 'tcx>(\n ) {\n     let ccx = bcx.ccx;\n \n-    if type_is_zero_size(ccx, t) {\n+    let size = ccx.size_of(t);\n+    if size == 0 {\n         return;\n     }\n \n-    let llty = type_of::type_of(ccx, t);\n-    let llsz = llsize_of(ccx, llty);\n-    let llalign = align.unwrap_or_else(|| type_of::align_of(ccx, t));\n-    call_memcpy(bcx, dst, src, llsz, llalign as u32);\n+    let align = align.unwrap_or_else(|| ccx.align_of(t));\n+    call_memcpy(bcx, dst, src, C_uint(ccx, size), align);\n }\n \n pub fn call_memset<'a, 'tcx>(b: &Builder<'a, 'tcx>,\n@@ -1297,8 +1295,8 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n         // (delay format until we actually need it)\n         let record = |kind, opt_discr_size, variants| {\n             let type_desc = format!(\"{:?}\", ty);\n-            let overall_size = layout.size(&tcx.data_layout);\n-            let align = layout.align(&tcx.data_layout);\n+            let overall_size = layout.size(tcx);\n+            let align = layout.align(tcx);\n             tcx.sess.code_stats.borrow_mut().record_type_size(kind,\n                                                               type_desc,\n                                                               align,\n@@ -1334,8 +1332,8 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n                     session::FieldInfo {\n                         name: field_name.to_string(),\n                         offset: offset.bytes(),\n-                        size: field_layout.size(&tcx.data_layout).bytes(),\n-                        align: field_layout.align(&tcx.data_layout).abi(),\n+                        size: field_layout.size(tcx).bytes(),\n+                        align: field_layout.align(tcx).abi(),\n                     }\n                 }\n             }\n@@ -1345,8 +1343,8 @@ fn gather_type_sizes<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n             session::VariantInfo {\n                 name: Some(name.to_string()),\n                 kind: session::SizeKind::Exact,\n-                align: value.align(&tcx.data_layout).abi(),\n-                size: value.size(&tcx.data_layout).bytes(),\n+                align: value.align(tcx).abi(),\n+                size: value.size(tcx).bytes(),\n                 fields: vec![],\n             }\n         };"}, {"sha": "c8c5af714d92a92c2e945ef9d73c181393a8fc28", "filename": "src/librustc_trans/cabi_aarch64.rs", "status": "modified", "additions": 57, "deletions": 121, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_aarch64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_aarch64.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,163 +8,99 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{self, FnType, ArgType};\n+use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 8)\n-}\n-\n-fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n-    fn check_array(ty: Type) -> Option<(Type, u64)> {\n-        let len = ty.array_length() as u64;\n-        if len == 0 {\n-            return None\n-        }\n-        let elt = ty.element_type();\n-\n-        // if our element is an HFA/HVA, so are we; multiply members by our len\n-        is_homogenous_aggregate_ty(elt).map(|(base_ty, members)| (base_ty, len * members))\n-    }\n-\n-    fn check_struct(ty: Type) -> Option<(Type, u64)> {\n-        let str_tys = ty.field_types();\n-        if str_tys.len() == 0 {\n-            return None\n-        }\n-\n-        let mut prev_base_ty = None;\n-        let mut members = 0;\n-        for opt_homog_agg in str_tys.iter().map(|t| is_homogenous_aggregate_ty(*t)) {\n-            match (prev_base_ty, opt_homog_agg) {\n-                // field isn't itself an HFA, so we aren't either\n-                (_, None) => return None,\n-\n-                // first field - store its type and number of members\n-                (None, Some((field_ty, field_members))) => {\n-                    prev_base_ty = Some(field_ty);\n-                    members = field_members;\n-                },\n \n-                // 2nd or later field - give up if it's a different type; otherwise incr. members\n-                (Some(prev_ty), Some((field_ty, field_members))) => {\n-                    if prev_ty != field_ty {\n-                        return None;\n-                    }\n-                    members += field_members;\n-                }\n-            }\n-        }\n-\n-        // Because of previous checks, we know prev_base_ty is Some(...) because\n-        //   1. str_tys has at least one element; and\n-        //   2. prev_base_ty was filled in (or we would've returned early)\n-        let (base_ty, members) = (prev_base_ty.unwrap(), members);\n+fn is_homogenous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+                                     -> Option<Uniform> {\n+    arg.layout.homogenous_aggregate(ccx).and_then(|unit| {\n+        let size = arg.layout.size(ccx);\n \n-        // Ensure there is no padding.\n-        if ty_size(ty) == ty_size(base_ty) * (members as usize) {\n-            Some((base_ty, members))\n-        } else {\n-            None\n+        // Ensure we have at most four uniquely addressable members.\n+        if size > unit.size.checked_mul(4, ccx).unwrap() {\n+            return None;\n         }\n-    }\n \n-    let homog_agg = match ty.kind() {\n-        Float  => Some((ty, 1)),\n-        Double => Some((ty, 1)),\n-        Array  => check_array(ty),\n-        Struct => check_struct(ty),\n-        Vector => match ty_size(ty) {\n-            4|8 => Some((ty, 1)),\n-            _   => None\n-        },\n-        _ => None\n-    };\n+        let valid_unit = match unit.kind {\n+            RegKind::Integer => false,\n+            RegKind::Float => true,\n+            RegKind::Vector => size.bits() == 64 || size.bits() == 128\n+        };\n \n-    // Ensure we have at most four uniquely addressable members\n-    homog_agg.and_then(|(base_ty, members)| {\n-        if members > 0 && members <= 4 {\n-            Some((base_ty, members))\n+        if valid_unit {\n+            Some(Uniform {\n+                unit,\n+                total: size\n+            })\n         } else {\n             None\n         }\n     })\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n     }\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n-        ret.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, ret) {\n+        ret.cast_to(ccx, uniform);\n         return;\n     }\n-    let size = ty_size(ret.ty);\n-    if size <= 16 {\n-        let llty = if size <= 1 {\n-            Type::i8(ccx)\n-        } else if size <= 2 {\n-            Type::i16(ccx)\n-        } else if size <= 4 {\n-            Type::i32(ccx)\n-        } else if size <= 8 {\n-            Type::i64(ccx)\n+    let size = ret.layout.size(ccx);\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        let unit = if bits <= 8 {\n+            Reg::i8()\n+        } else if bits <= 16 {\n+            Reg::i16()\n+        } else if bits <= 32 {\n+            Reg::i32()\n         } else {\n-            Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n+            Reg::i64()\n         };\n-        ret.cast = Some(llty);\n+\n+        ret.cast_to(ccx, Uniform {\n+            unit,\n+            total: size\n+        });\n         return;\n     }\n     ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if is_reg_ty(arg.ty) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n     }\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n-        arg.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, arg) {\n+        arg.cast_to(ccx, uniform);\n         return;\n     }\n-    let size = ty_size(arg.ty);\n-    if size <= 16 {\n-        let llty = if size == 0 {\n-            Type::array(&Type::i64(ccx), 0)\n-        } else if size == 1 {\n-            Type::i8(ccx)\n-        } else if size == 2 {\n-            Type::i16(ccx)\n-        } else if size <= 4 {\n-            Type::i32(ccx)\n-        } else if size <= 8 {\n-            Type::i64(ccx)\n+    let size = arg.layout.size(ccx);\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        let unit = if bits <= 8 {\n+            Reg::i8()\n+        } else if bits <= 16 {\n+            Reg::i16()\n+        } else if bits <= 32 {\n+            Reg::i32()\n         } else {\n-            Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n+            Reg::i64()\n         };\n-        arg.cast = Some(llty);\n+\n+        arg.cast_to(ccx, Uniform {\n+            unit,\n+            total: size\n+        });\n         return;\n     }\n     arg.make_indirect(ccx);\n }\n \n-fn is_reg_ty(ty: Type) -> bool {\n-    match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double\n-        | Vector => true,\n-        _ => false\n-    }\n-}\n-\n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "7a91cad511d6d17bc7688a17c30f25787da2a7a3", "filename": "src/librustc_trans/cabi_arm.rs", "status": "modified", "additions": 26, "deletions": 129, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_arm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_arm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_arm.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,156 +8,53 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{self, align_up_to, FnType, ArgType};\n+use abi::{FnType, ArgType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n-use type_::Type;\n \n-use std::cmp;\n-\n-pub enum Flavor {\n-    General,\n-    Ios\n-}\n-\n-type TyAlignFn = fn(ty: Type) -> usize;\n-\n-fn align(off: usize, ty: Type, align_fn: TyAlignFn) -> usize {\n-    let a = align_fn(ty);\n-    return align_up_to(off, a);\n-}\n-\n-fn general_ty_align(ty: Type) -> usize {\n-    abi::ty_align(ty, 4)\n-}\n-\n-// For more information see:\n-// ARMv7\n-// https://developer.apple.com/library/ios/documentation/Xcode/Conceptual\n-//    /iPhoneOSABIReference/Articles/ARMv7FunctionCallingConventions.html\n-// ARMv6\n-// https://developer.apple.com/library/ios/documentation/Xcode/Conceptual\n-//    /iPhoneOSABIReference/Articles/ARMv6FunctionCallingConventions.html\n-fn ios_ty_align(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => cmp::min(4, ((ty.int_width() as usize) + 7) / 8),\n-        Pointer => 4,\n-        Float => 4,\n-        Double => 4,\n-        Struct => {\n-            if ty.is_packed() {\n-                1\n-            } else {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, ios_ty_align(*t)))\n-            }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ios_ty_align(elt)\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            ios_ty_align(elt) * len\n-        }\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n-}\n-\n-fn ty_size(ty: Type, align_fn: TyAlignFn) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 4,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t, align_fn))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter()\n-                                  .fold(0, |s, t| {\n-                                      align(s, *t, align_fn) + ty_size(*t, align_fn)\n-                                  });\n-                align(size, ty, align_fn)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt, align_fn);\n-            len * eltsz\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt, align_fn);\n-            len * eltsz\n-        }\n-        _ => bug!(\"ty_size: unhandled type\")\n-    }\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType, align_fn: TyAlignFn) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n         return;\n     }\n-    let size = ty_size(ret.ty, align_fn);\n-    if size <= 4 {\n-        let llty = if size <= 1 {\n-            Type::i8(ccx)\n-        } else if size <= 2 {\n-            Type::i16(ccx)\n+    let size = ret.layout.size(ccx);\n+    let bits = size.bits();\n+    if bits <= 32 {\n+        let unit = if bits <= 8 {\n+            Reg::i8()\n+        } else if bits <= 16 {\n+            Reg::i16()\n         } else {\n-            Type::i32(ccx)\n+            Reg::i32()\n         };\n-        ret.cast = Some(llty);\n+        ret.cast_to(ccx, Uniform {\n+            unit,\n+            total: size\n+        });\n         return;\n     }\n     ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, align_fn: TyAlignFn) {\n-    if is_reg_ty(arg.ty) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(32);\n         return;\n     }\n-    let align = align_fn(arg.ty);\n-    let size = ty_size(arg.ty, align_fn);\n-    let llty = if align <= 4 {\n-        Type::array(&Type::i32(ccx), ((size + 3) / 4) as u64)\n-    } else {\n-        Type::array(&Type::i64(ccx), ((size + 7) / 8) as u64)\n-    };\n-    arg.cast = Some(llty);\n+    let align = arg.layout.align(ccx).abi();\n+    let total = arg.layout.size(ccx);\n+    arg.cast_to(ccx, Uniform {\n+        unit: if align <= 4 { Reg::i32() } else { Reg::i64() },\n+        total\n+    });\n }\n \n-fn is_reg_ty(ty: Type) -> bool {\n-    match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double\n-        | Vector => true,\n-        _ => false\n-    }\n-}\n-\n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n-    let align_fn = match flavor {\n-        Flavor::General => general_ty_align as TyAlignFn,\n-        Flavor::Ios => ios_ty_align as TyAlignFn,\n-    };\n-\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n-        classify_ret_ty(ccx, &mut fty.ret, align_fn);\n+        classify_ret_ty(ccx, &mut fty.ret);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        classify_arg_ty(ccx, arg, align_fn);\n+        classify_arg_ty(ccx, arg);\n     }\n }"}, {"sha": "f05dda8bce21acf819212c5cb224df06bbad50e8", "filename": "src/librustc_trans/cabi_asmjs.rs", "status": "modified", "additions": 16, "deletions": 19, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_asmjs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_asmjs.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,42 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n-use llvm::{Struct, Array};\n-use abi::{FnType, ArgType, ArgAttribute};\n+use abi::{FnType, ArgType, ArgAttribute, LayoutExt, Uniform};\n use context::CrateContext;\n \n // Data layout: e-p:32:32-i64:64-v128:32:128-n32-S128\n \n // See the https://github.com/kripken/emscripten-fastcomp-clang repository.\n // The class `EmscriptenABIInfo` in `/lib/CodeGen/TargetInfo.cpp` contains the ABI definitions.\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    match ret.ty.kind() {\n-        Struct => {\n-            let field_types = ret.ty.field_types();\n-            if field_types.len() == 1 {\n-                ret.cast = Some(field_types[0]);\n-            } else {\n-                ret.make_indirect(ccx);\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if ret.layout.is_aggregate() {\n+        if let Some(unit) = ret.layout.homogenous_aggregate(ccx) {\n+            let size = ret.layout.size(ccx);\n+            if unit.size == size {\n+                ret.cast_to(ccx, Uniform {\n+                    unit,\n+                    total: size\n+                });\n+                return;\n             }\n         }\n-        Array => {\n-            ret.make_indirect(ccx);\n-        }\n-        _ => {}\n+\n+        ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if arg.ty.is_aggregate() {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if arg.layout.is_aggregate() {\n         arg.make_indirect(ccx);\n         arg.attrs.set(ArgAttribute::ByVal);\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "b7b60859d4a048b9f53e0952659bcc7c133948ee", "filename": "src/librustc_trans/cabi_mips.rs", "status": "modified", "additions": 17, "deletions": 71, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_mips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_mips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,94 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n-use libc::c_uint;\n use std::cmp;\n-use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Vector};\n-use abi::{self, align_up_to, ArgType, FnType};\n+use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_align(ty: Type) -> usize {\n-    abi::ty_align(ty, 4)\n-}\n \n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 4)\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n-    let orig_offset = *offset;\n-    let size = ty_size(arg.ty) * 8;\n-    let mut align = ty_align(arg.ty);\n-\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+    let size = arg.layout.size(ccx);\n+    let mut align = arg.layout.align(ccx).abi();\n     align = cmp::min(cmp::max(align, 4), 8);\n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size, align * 8) / 8;\n \n-    if !is_reg_ty(arg.ty) {\n-        arg.cast = Some(struct_ty(ccx, arg.ty));\n-        arg.pad = padding_ty(ccx, align, orig_offset);\n+    if arg.layout.is_aggregate() {\n+        arg.cast_to(ccx, Uniform {\n+            unit: Reg::i32(),\n+            total: size\n+        });\n+        if ((align - 1) & *offset) > 0 {\n+            arg.pad_with(ccx, Reg::i32());\n+        }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    return match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double\n-        | Vector => true,\n-        _ => false\n-    };\n-}\n-\n-fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n-    if ((align - 1 ) & offset) > 0 {\n-        Some(Type::i32(ccx))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let int_ty = Type::i32(ccx);\n-    let mut args = Vec::new();\n-\n-    let mut n = size / 32;\n-    while n > 0 {\n-        args.push(int_ty);\n-        n -= 1;\n-    }\n \n-    let r = size % 32;\n-    if r > 0 {\n-        unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n-        }\n-    }\n-\n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n+    *offset = align_up_to(*offset, align);\n+    *offset += align_up_to(size.bytes(), align);\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "dff75e628de10270fa83b09c4c6da22281ea21d5", "filename": "src/librustc_trans/cabi_mips64.rs", "status": "modified", "additions": 17, "deletions": 71, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_mips64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_mips64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_mips64.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,94 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n-use libc::c_uint;\n use std::cmp;\n-use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Vector};\n-use abi::{self, align_up_to, ArgType, FnType};\n+use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_align(ty: Type) -> usize {\n-    abi::ty_align(ty, 8)\n-}\n \n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 8)\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n     } else {\n         ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n-    let orig_offset = *offset;\n-    let size = ty_size(arg.ty) * 8;\n-    let mut align = ty_align(arg.ty);\n-\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+    let size = arg.layout.size(ccx);\n+    let mut align = arg.layout.align(ccx).abi();\n     align = cmp::min(cmp::max(align, 4), 8);\n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size, align * 8) / 8;\n \n-    if !is_reg_ty(arg.ty) {\n-        arg.cast = Some(struct_ty(ccx, arg.ty));\n-        arg.pad = padding_ty(ccx, align, orig_offset);\n+    if arg.layout.is_aggregate() {\n+        arg.cast_to(ccx, Uniform {\n+            unit: Reg::i64(),\n+            total: size\n+        });\n+        if ((align - 1) & *offset) > 0 {\n+            arg.pad_with(ccx, Reg::i64());\n+        }\n     } else {\n         arg.extend_integer_width_to(64);\n     }\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    return match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double\n-        | Vector => true,\n-        _ => false\n-    };\n-}\n-\n-fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n-    if ((align - 1 ) & offset) > 0 {\n-        Some(Type::i64(ccx))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let int_ty = Type::i64(ccx);\n-    let mut args = Vec::new();\n-\n-    let mut n = size / 64;\n-    while n > 0 {\n-        args.push(int_ty);\n-        n -= 1;\n-    }\n \n-    let r = size % 64;\n-    if r > 0 {\n-        unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n-        }\n-    }\n-\n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n+    *offset = align_up_to(*offset, align);\n+    *offset += align_up_to(size.bytes(), align);\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "546bb5ad9b44ef39b140c81dea2d817d8b186aeb", "filename": "src/librustc_trans/cabi_msp430.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_msp430.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_msp430.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_msp430.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -11,41 +11,32 @@\n // Reference: MSP430 Embedded Application Binary Interface\n // http://www.ti.com/lit/an/slaa534/slaa534.pdf\n \n-#![allow(non_upper_case_globals)]\n-\n-use llvm::Struct;\n-\n-use abi::{self, ArgType, FnType};\n+use abi::{ArgType, FnType, LayoutExt};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 2)\n-}\n \n // 3.5 Structures or Unions Passed and Returned by Reference\n //\n // \"Structures (including classes) and unions larger than 32 bits are passed and\n // returned by reference. To pass a structure or union by reference, the caller\n // places its address in the appropriate location: either in a register or on\n // the stack, according to its position in the argument list. (..)\"\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if ret.ty.kind() == Struct && ty_size(ret.ty) > 32 {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 32 {\n         ret.make_indirect(ccx);\n     } else {\n         ret.extend_integer_width_to(16);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if arg.ty.kind() == Struct && ty_size(arg.ty) > 32 {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 32 {\n         arg.make_indirect(ccx);\n     } else {\n         arg.extend_integer_width_to(16);\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "3873752b25470638b2456a276a4b784499a6713e", "filename": "src/librustc_trans/cabi_nvptx.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -11,35 +11,26 @@\n // Reference: PTX Writer's Guide to Interoperability\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n-#![allow(non_upper_case_globals)]\n-\n-use llvm::Struct;\n-\n-use abi::{self, ArgType, FnType};\n+use abi::{ArgType, FnType, LayoutExt};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 4)\n-}\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if ret.ty.kind() == Struct && ty_size(ret.ty) > 32 {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 32 {\n         ret.make_indirect(ccx);\n     } else {\n         ret.extend_integer_width_to(32);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if arg.ty.kind() == Struct && ty_size(arg.ty) > 32 {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 32 {\n         arg.make_indirect(ccx);\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "24bf4920c16c1277dd50435442a0ffbd9cef9e3a", "filename": "src/librustc_trans/cabi_nvptx64.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx64.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -11,35 +11,26 @@\n // Reference: PTX Writer's Guide to Interoperability\n // http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n \n-#![allow(non_upper_case_globals)]\n-\n-use llvm::Struct;\n-\n-use abi::{self, ArgType, FnType};\n+use abi::{ArgType, FnType, LayoutExt};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 8)\n-}\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if ret.ty.kind() == Struct && ty_size(ret.ty) > 64 {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if ret.layout.is_aggregate() && ret.layout.size(ccx).bits() > 64 {\n         ret.make_indirect(ccx);\n     } else {\n         ret.extend_integer_width_to(64);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if arg.ty.kind() == Struct && ty_size(arg.ty) > 64 {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if arg.layout.is_aggregate() && arg.layout.size(ccx).bits() > 64 {\n         arg.make_indirect(ccx);\n     } else {\n         arg.extend_integer_width_to(64);\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "f951ac76391f6614b0936f013bbf12a3bd9d87e8", "filename": "src/librustc_trans/cabi_powerpc.rs", "status": "modified", "additions": 17, "deletions": 76, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_powerpc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,100 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::c_uint;\n-use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Vector};\n-use abi::{self, align_up_to, FnType, ArgType};\n+use abi::{align_up_to, FnType, ArgType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n-use type_::Type;\n \n use std::cmp;\n \n-fn ty_align(ty: Type) -> usize {\n-    if ty.kind() == Vector {\n-        bug!(\"ty_size: unhandled type\")\n-    } else {\n-        abi::ty_align(ty, 4)\n-    }\n-}\n-\n-fn ty_size(ty: Type) -> usize {\n-    if ty.kind() == Vector {\n-        bug!(\"ty_size: unhandled type\")\n-    } else {\n-        abi::ty_size(ty, 4)\n-    }\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n-    let orig_offset = *offset;\n-    let size = ty_size(arg.ty) * 8;\n-    let mut align = ty_align(arg.ty);\n-\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+    let size = arg.layout.size(ccx);\n+    let mut align = arg.layout.align(ccx).abi();\n     align = cmp::min(cmp::max(align, 4), 8);\n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size, align * 8) / 8;\n \n-    if !is_reg_ty(arg.ty) {\n-        arg.cast = Some(struct_ty(ccx, arg.ty));\n-        arg.pad = padding_ty(ccx, align, orig_offset);\n+    if arg.layout.is_aggregate() {\n+        arg.cast_to(ccx, Uniform {\n+            unit: Reg::i32(),\n+            total: size\n+        });\n+        if ((align - 1) & *offset) > 0 {\n+            arg.pad_with(ccx, Reg::i32());\n+        }\n     } else {\n         arg.extend_integer_width_to(32);\n     }\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    return match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double => true,\n-        _ => false\n-    };\n-}\n \n-fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n-    if ((align - 1 ) & offset) > 0 {\n-        Some(Type::i32(ccx))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let int_ty = Type::i32(ccx);\n-    let mut args = Vec::new();\n-\n-    let mut n = size / 32;\n-    while n > 0 {\n-        args.push(int_ty);\n-        n -= 1;\n-    }\n-\n-    let r = size % 32;\n-    if r > 0 {\n-        unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n-        }\n-    }\n-\n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n+    *offset = align_up_to(*offset, align);\n+    *offset += align_up_to(size.bytes(), align);\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "c4f8d0b4b963780f6192834ac9329608f4ab14bd", "filename": "src/librustc_trans/cabi_powerpc64.rs", "status": "modified", "additions": 48, "deletions": 132, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_powerpc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_powerpc64.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,100 +8,42 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// FIXME: The PowerPC64 ABI needs to zero or sign extend function\n-// call parameters, but compute_abi_info() is passed LLVM types\n-// which have no sign information.\n-//\n+// FIXME:\n // Alignment of 128 bit types is not currently handled, this will\n // need to be fixed when PowerPC vector support is added.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Vector, Array};\n-use abi::{self, FnType, ArgType};\n+use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_size(ty: Type) -> usize {\n-    if ty.kind() == Vector {\n-        bug!(\"ty_size: unhandled type\")\n-    } else {\n-        abi::ty_size(ty, 8)\n-    }\n-}\n-\n-fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n-    fn check_array(ty: Type) -> Option<(Type, u64)> {\n-        let len = ty.array_length() as u64;\n-        if len == 0 {\n-            return None\n-        }\n-        let elt = ty.element_type();\n-\n-        // if our element is an HFA/HVA, so are we; multiply members by our len\n-        is_homogenous_aggregate_ty(elt).map(|(base_ty, members)| (base_ty, len * members))\n-    }\n \n-    fn check_struct(ty: Type) -> Option<(Type, u64)> {\n-        let str_tys = ty.field_types();\n-        if str_tys.len() == 0 {\n-            return None\n-        }\n+fn is_homogenous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+                                     -> Option<Uniform> {\n+    arg.layout.homogenous_aggregate(ccx).and_then(|unit| {\n+        let size = arg.layout.size(ccx);\n \n-        let mut prev_base_ty = None;\n-        let mut members = 0;\n-        for opt_homog_agg in str_tys.iter().map(|t| is_homogenous_aggregate_ty(*t)) {\n-            match (prev_base_ty, opt_homog_agg) {\n-                // field isn't itself an HFA, so we aren't either\n-                (_, None) => return None,\n-\n-                // first field - store its type and number of members\n-                (None, Some((field_ty, field_members))) => {\n-                    prev_base_ty = Some(field_ty);\n-                    members = field_members;\n-                },\n-\n-                // 2nd or later field - give up if it's a different type; otherwise incr. members\n-                (Some(prev_ty), Some((field_ty, field_members))) => {\n-                    if prev_ty != field_ty {\n-                        return None;\n-                    }\n-                    members += field_members;\n-                }\n-            }\n+        // Ensure we have at most eight uniquely addressable members.\n+        if size > unit.size.checked_mul(8, ccx).unwrap() {\n+            return None;\n         }\n \n-        // Because of previous checks, we know prev_base_ty is Some(...) because\n-        //   1. str_tys has at least one element; and\n-        //   2. prev_base_ty was filled in (or we would've returned early)\n-        let (base_ty, members) = (prev_base_ty.unwrap(), members);\n-\n-        // Ensure there is no padding.\n-        if ty_size(ty) == ty_size(base_ty) * (members as usize) {\n-            Some((base_ty, members))\n-        } else {\n-            None\n-        }\n-    }\n+        let valid_unit = match unit.kind {\n+            RegKind::Integer => false,\n+            RegKind::Float => true,\n+            RegKind::Vector => size.bits() == 128\n+        };\n \n-    let homog_agg = match ty.kind() {\n-        Float  => Some((ty, 1)),\n-        Double => Some((ty, 1)),\n-        Array  => check_array(ty),\n-        Struct => check_struct(ty),\n-        _ => None\n-    };\n-\n-    // Ensure we have at most eight uniquely addressable members\n-    homog_agg.and_then(|(base_ty, members)| {\n-        if members > 0 && members <= 8 {\n-            Some((base_ty, members))\n+        if valid_unit {\n+            Some(Uniform {\n+                unit,\n+                total: size\n+            })\n         } else {\n             None\n         }\n     })\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n     }\n@@ -111,78 +53,52 @@ fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n         ret.make_indirect(ccx);\n     }\n \n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n-        ret.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, ret) {\n+        ret.cast_to(ccx, uniform);\n         return;\n     }\n-    let size = ty_size(ret.ty);\n-    if size <= 16 {\n-        let llty = if size <= 1 {\n-            Type::i8(ccx)\n-        } else if size <= 2 {\n-            Type::i16(ccx)\n-        } else if size <= 4 {\n-            Type::i32(ccx)\n-        } else if size <= 8 {\n-            Type::i64(ccx)\n+    let size = ret.layout.size(ccx);\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        let unit = if bits <= 8 {\n+            Reg::i8()\n+        } else if bits <= 16 {\n+            Reg::i16()\n+        } else if bits <= 32 {\n+            Reg::i32()\n         } else {\n-            Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n+            Reg::i64()\n         };\n-        ret.cast = Some(llty);\n+\n+        ret.cast_to(ccx, Uniform {\n+            unit,\n+            total: size\n+        });\n         return;\n     }\n \n     ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if is_reg_ty(arg.ty) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n-        arg.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, arg) {\n+        arg.cast_to(ccx, uniform);\n         return;\n     }\n \n-    arg.cast = Some(struct_ty(ccx, arg.ty));\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double => true,\n-        _ => false\n-    }\n-}\n-\n-fn coerce_to_long(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let long_ty = Type::i64(ccx);\n-    let mut args = Vec::new();\n-\n-    let mut n = size / 64;\n-    while n > 0 {\n-        args.push(long_ty);\n-        n -= 1;\n-    }\n-\n-    let r = size % 64;\n-    if r > 0 {\n-        args.push(Type::ix(ccx, r as u64));\n-    }\n-\n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_long(ccx, size), false)\n+    let total = arg.layout.size(ccx);\n+    arg.cast_to(ccx, Uniform {\n+        unit: Reg::i64(),\n+        total\n+    });\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "fedebea3f4c998ea177607167a3a83b2748ff0cb", "filename": "src/librustc_trans/cabi_s390x.rs", "status": "modified", "additions": 35, "deletions": 105, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_s390x.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_s390x.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_s390x.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -11,130 +11,60 @@\n // FIXME: The assumes we're using the non-vector ABI, i.e. compiling\n // for a pre-z13 machine or using -mno-vx.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Array, Vector};\n-use abi::{align_up_to, FnType, ArgType};\n+use abi::{FnType, ArgType, LayoutExt, Reg};\n use context::CrateContext;\n-use type_::Type;\n \n-use std::cmp;\n+use rustc::ty::layout::{self, Layout, TyLayout};\n \n-fn align(off: usize, ty: Type) -> usize {\n-    let a = ty_align(ty);\n-    return align_up_to(off, a);\n-}\n-\n-fn ty_align(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 8,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                1\n-            } else {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(1, |a, t| cmp::max(a, ty_align(*t)))\n-            }\n-        }\n-        Array => {\n-            let elt = ty.element_type();\n-            ty_align(elt)\n-        }\n-        Vector => ty_size(ty),\n-        _ => bug!(\"ty_align: unhandled type\")\n-    }\n-}\n-\n-fn ty_size(ty: Type) -> usize {\n-    match ty.kind() {\n-        Integer => ((ty.int_width() as usize) + 7) / 8,\n-        Pointer => 8,\n-        Float => 4,\n-        Double => 8,\n-        Struct => {\n-            if ty.is_packed() {\n-                let str_tys = ty.field_types();\n-                str_tys.iter().fold(0, |s, t| s + ty_size(*t))\n-            } else {\n-                let str_tys = ty.field_types();\n-                let size = str_tys.iter().fold(0, |s, t| align(s, *t) + ty_size(*t));\n-                align(size, ty)\n-            }\n-        }\n-        Array => {\n-            let len = ty.array_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        Vector => {\n-            let len = ty.vector_length();\n-            let elt = ty.element_type();\n-            let eltsz = ty_size(elt);\n-            len * eltsz\n-        }\n-        _ => bug!(\"ty_size: unhandled type\")\n-    }\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() && ret.layout.size(ccx).bits() <= 64 {\n         ret.extend_integer_width_to(64);\n     } else {\n         ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if arg.ty.kind() == Struct {\n-        fn is_single_fp_element(tys: &[Type]) -> bool {\n-            if tys.len() != 1 {\n-                return false;\n-            }\n-            match tys[0].kind() {\n-                Float | Double => true,\n-                Struct => is_single_fp_element(&tys[0].field_types()),\n-                _ => false\n-            }\n-        }\n-\n-        if is_single_fp_element(&arg.ty.field_types()) {\n-            match ty_size(arg.ty) {\n-                4 => arg.cast = Some(Type::f32(ccx)),\n-                8 => arg.cast = Some(Type::f64(ccx)),\n-                _ => arg.make_indirect(ccx)\n-            }\n-        } else {\n-            match ty_size(arg.ty) {\n-                1 => arg.cast = Some(Type::i8(ccx)),\n-                2 => arg.cast = Some(Type::i16(ccx)),\n-                4 => arg.cast = Some(Type::i32(ccx)),\n-                8 => arg.cast = Some(Type::i64(ccx)),\n-                _ => arg.make_indirect(ccx)\n+fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                  layout: TyLayout<'tcx>) -> bool {\n+    match *layout {\n+        Layout::Scalar { value: layout::F32, .. } |\n+        Layout::Scalar { value: layout::F64, .. } => true,\n+        Layout::Univariant { .. } => {\n+            if layout.field_count() == 1 {\n+                is_single_fp_element(ccx, layout.field(ccx, 0))\n+            } else {\n+                false\n             }\n         }\n-        return;\n+        _ => false\n     }\n+}\n \n-    if is_reg_ty(arg.ty) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    let size = arg.layout.size(ccx);\n+    if !arg.layout.is_aggregate() && size.bits() <= 64 {\n         arg.extend_integer_width_to(64);\n-    } else {\n-        arg.make_indirect(ccx);\n+        return;\n     }\n-}\n \n-fn is_reg_ty(ty: Type) -> bool {\n-    match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double => ty_size(ty) <= 8,\n-        _ => false\n+    if is_single_fp_element(ccx, arg.layout) {\n+        match size.bytes() {\n+            4 => arg.cast_to(ccx, Reg::f32()),\n+            8 => arg.cast_to(ccx, Reg::f64()),\n+            _ => arg.make_indirect(ccx)\n+        }\n+    } else {\n+        match size.bytes() {\n+            1 => arg.cast_to(ccx, Reg::i8()),\n+            2 => arg.cast_to(ccx, Reg::i16()),\n+            4 => arg.cast_to(ccx, Reg::i32()),\n+            8 => arg.cast_to(ccx, Reg::i64()),\n+            _ => arg.make_indirect(ccx)\n+        }\n     }\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "c17901e1adebc113aace587a507e7cf3044cc122", "filename": "src/librustc_trans/cabi_sparc.rs", "status": "modified", "additions": 18, "deletions": 72, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_sparc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_sparc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,94 +8,40 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(non_upper_case_globals)]\n-\n-use libc::c_uint;\n use std::cmp;\n-use llvm;\n-use llvm::{Integer, Pointer, Float, Double, Vector};\n-use abi::{self, align_up_to, ArgType, FnType};\n+use abi::{align_up_to, ArgType, FnType, LayoutExt, Reg, Uniform};\n use context::CrateContext;\n-use type_::Type;\n-\n-fn ty_align(ty: Type) -> usize {\n-    abi::ty_align(ty, 4)\n-}\n \n-fn ty_size(ty: Type) -> usize {\n-    abi::ty_size(ty, 4)\n-}\n-\n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(32);\n     } else {\n         ret.make_indirect(ccx);\n     }\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut usize) {\n-    let orig_offset = *offset;\n-    let size = ty_size(arg.ty) * 8;\n-    let mut align = ty_align(arg.ty);\n-\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType, offset: &mut u64) {\n+    let size = arg.layout.size(ccx);\n+    let mut align = arg.layout.align(ccx).abi();\n     align = cmp::min(cmp::max(align, 4), 8);\n-    *offset = align_up_to(*offset, align);\n-    *offset += align_up_to(size, align * 8) / 8;\n-\n-    if !is_reg_ty(arg.ty) {\n-        arg.cast = Some(struct_ty(ccx, arg.ty));\n-        arg.pad = padding_ty(ccx, align, orig_offset);\n-    } else {\n-        arg.extend_integer_width_to(32);\n-    }\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    return match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double\n-        | Vector => true,\n-        _ => false\n-    };\n-}\n-\n-fn padding_ty(ccx: &CrateContext, align: usize, offset: usize) -> Option<Type> {\n-    if ((align - 1 ) & offset) > 0 {\n-        Some(Type::i32(ccx))\n-    } else {\n-        None\n-    }\n-}\n-\n-fn coerce_to_int(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let int_ty = Type::i32(ccx);\n-    let mut args = Vec::new();\n \n-    let mut n = size / 32;\n-    while n > 0 {\n-        args.push(int_ty);\n-        n -= 1;\n-    }\n-\n-    let r = size % 32;\n-    if r > 0 {\n-        unsafe {\n-            args.push(Type::from_ref(llvm::LLVMIntTypeInContext(ccx.llcx(), r as c_uint)));\n+    if arg.layout.is_aggregate() {\n+        arg.cast_to(ccx, Uniform {\n+            unit: Reg::i32(),\n+            total: size\n+        });\n+        if ((align - 1) & *offset) > 0 {\n+            arg.pad_with(ccx, Reg::i32());\n         }\n+    } else {\n+        arg.extend_integer_width_to(32)\n     }\n \n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_int(ccx, size), false)\n+    *offset = align_up_to(*offset, align);\n+    *offset += align_up_to(size.bytes(), align);\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "b75fa97f948ecadfea7e2ee2c1af8f3faf825881", "filename": "src/librustc_trans/cabi_sparc64.rs", "status": "modified", "additions": 50, "deletions": 131, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_sparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_sparc64.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -10,170 +10,89 @@\n \n // FIXME: This needs an audit for correctness and completeness.\n \n-use llvm::{Integer, Pointer, Float, Double, Struct, Vector, Array};\n-use abi::{self, FnType, ArgType};\n+use abi::{FnType, ArgType, LayoutExt, Reg, RegKind, Uniform};\n use context::CrateContext;\n-use type_::Type;\n \n-fn ty_size(ty: Type) -> usize {\n-    if ty.kind() == Vector {\n-        bug!(\"ty_size: unhandled type\")\n-    } else {\n-        abi::ty_size(ty, 8)\n-    }\n-}\n-\n-fn is_homogenous_aggregate_ty(ty: Type) -> Option<(Type, u64)> {\n-    fn check_array(ty: Type) -> Option<(Type, u64)> {\n-        let len = ty.array_length() as u64;\n-        if len == 0 {\n-            return None\n-        }\n-        let elt = ty.element_type();\n-\n-        // if our element is an HFA/HVA, so are we; multiply members by our len\n-        is_homogenous_aggregate_ty(elt).map(|(base_ty, members)| (base_ty, len * members))\n-    }\n-\n-    fn check_struct(ty: Type) -> Option<(Type, u64)> {\n-        let str_tys = ty.field_types();\n-        if str_tys.len() == 0 {\n-            return None\n-        }\n-\n-        let mut prev_base_ty = None;\n-        let mut members = 0;\n-        for opt_homog_agg in str_tys.iter().map(|t| is_homogenous_aggregate_ty(*t)) {\n-            match (prev_base_ty, opt_homog_agg) {\n-                // field isn't itself an HFA, so we aren't either\n-                (_, None) => return None,\n+fn is_homogenous_aggregate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>)\n+                                     -> Option<Uniform> {\n+    arg.layout.homogenous_aggregate(ccx).and_then(|unit| {\n+        let size = arg.layout.size(ccx);\n \n-                // first field - store its type and number of members\n-                (None, Some((field_ty, field_members))) => {\n-                    prev_base_ty = Some(field_ty);\n-                    members = field_members;\n-                },\n-\n-                // 2nd or later field - give up if it's a different type; otherwise incr. members\n-                (Some(prev_ty), Some((field_ty, field_members))) => {\n-                    if prev_ty != field_ty {\n-                        return None;\n-                    }\n-                    members += field_members;\n-                }\n-            }\n+        // Ensure we have at most eight uniquely addressable members.\n+        if size > unit.size.checked_mul(8, ccx).unwrap() {\n+            return None;\n         }\n \n-        // Because of previous checks, we know prev_base_ty is Some(...) because\n-        //   1. str_tys has at least one element; and\n-        //   2. prev_base_ty was filled in (or we would've returned early)\n-        let (base_ty, members) = (prev_base_ty.unwrap(), members);\n-\n-        // Ensure there is no padding.\n-        if ty_size(ty) == ty_size(base_ty) * (members as usize) {\n-            Some((base_ty, members))\n-        } else {\n-            None\n-        }\n-    }\n-\n-    let homog_agg = match ty.kind() {\n-        Float  => Some((ty, 1)),\n-        Double => Some((ty, 1)),\n-        Array  => check_array(ty),\n-        Struct => check_struct(ty),\n-        _ => None\n-    };\n+        let valid_unit = match unit.kind {\n+            RegKind::Integer => false,\n+            RegKind::Float => true,\n+            RegKind::Vector => size.bits() == 128\n+        };\n \n-    // Ensure we have at most eight uniquely addressable members\n-    homog_agg.and_then(|(base_ty, members)| {\n-        if members > 0 && members <= 8 {\n-            Some((base_ty, members))\n+        if valid_unit {\n+            Some(Uniform {\n+                unit,\n+                total: size\n+            })\n         } else {\n             None\n         }\n     })\n }\n \n-fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n-    if is_reg_ty(ret.ty) {\n+fn classify_ret_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ret: &mut ArgType<'tcx>) {\n+    if !ret.layout.is_aggregate() {\n         ret.extend_integer_width_to(64);\n         return;\n     }\n \n-    // don't return aggregates in registers\n-    ret.make_indirect(ccx);\n-\n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(ret.ty) {\n-        ret.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, ret) {\n+        ret.cast_to(ccx, uniform);\n         return;\n     }\n-    let size = ty_size(ret.ty);\n-    if size <= 16 {\n-        let llty = if size <= 1 {\n-            Type::i8(ccx)\n-        } else if size <= 2 {\n-            Type::i16(ccx)\n-        } else if size <= 4 {\n-            Type::i32(ccx)\n-        } else if size <= 8 {\n-            Type::i64(ccx)\n+    let size = ret.layout.size(ccx);\n+    let bits = size.bits();\n+    if bits <= 128 {\n+        let unit = if bits <= 8 {\n+            Reg::i8()\n+        } else if bits <= 16 {\n+            Reg::i16()\n+        } else if bits <= 32 {\n+            Reg::i32()\n         } else {\n-            Type::array(&Type::i64(ccx), ((size + 7 ) / 8 ) as u64)\n+            Reg::i64()\n         };\n-        ret.cast = Some(llty);\n+\n+        ret.cast_to(ccx, Uniform {\n+            unit,\n+            total: size\n+        });\n         return;\n     }\n+\n+    // don't return aggregates in registers\n+    ret.make_indirect(ccx);\n }\n \n-fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n-    if is_reg_ty(arg.ty) {\n+fn classify_arg_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &mut ArgType<'tcx>) {\n+    if !arg.layout.is_aggregate() {\n         arg.extend_integer_width_to(64);\n         return;\n     }\n \n-    if let Some((base_ty, members)) = is_homogenous_aggregate_ty(arg.ty) {\n-        arg.cast = Some(Type::array(&base_ty, members));\n+    if let Some(uniform) = is_homogenous_aggregate(ccx, arg) {\n+        arg.cast_to(ccx, uniform);\n         return;\n     }\n \n-    arg.cast = Some(struct_ty(ccx, arg.ty));\n-}\n-\n-fn is_reg_ty(ty: Type) -> bool {\n-    match ty.kind() {\n-        Integer\n-        | Pointer\n-        | Float\n-        | Double => true,\n-        _ => false\n-    }\n-}\n-\n-fn coerce_to_long(ccx: &CrateContext, size: usize) -> Vec<Type> {\n-    let long_ty = Type::i64(ccx);\n-    let mut args = Vec::new();\n-\n-    let mut n = size / 64;\n-    while n > 0 {\n-        args.push(long_ty);\n-        n -= 1;\n-    }\n-\n-    let r = size % 64;\n-    if r > 0 {\n-        args.push(Type::ix(ccx, r as u64));\n-    }\n-\n-    args\n-}\n-\n-fn struct_ty(ccx: &CrateContext, ty: Type) -> Type {\n-    let size = ty_size(ty) * 8;\n-    Type::struct_(ccx, &coerce_to_long(ccx, size), false)\n+    let total = arg.layout.size(ccx);\n+    arg.cast_to(ccx, Uniform {\n+        unit: Reg::i64(),\n+        total\n+    });\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n     if !fty.ret.is_ignore() {\n         classify_ret_ty(ccx, &mut fty.ret);\n     }"}, {"sha": "9f5520dabe3349e14dbdffbfda4fdeac7998d187", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,21 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::*;\n-use abi::{ArgAttribute, FnType};\n-use type_::Type;\n-use super::common::*;\n-use super::machine::*;\n+use abi::{ArgAttribute, FnType, LayoutExt, Reg, RegKind};\n+use common::CrateContext;\n \n #[derive(PartialEq)]\n pub enum Flavor {\n     General,\n     Fastcall\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                  fty: &mut FnType<'tcx>,\n+                                  flavor: Flavor) {\n     if !fty.ret.is_ignore() {\n-        if fty.ret.ty.kind() == Struct {\n+        if fty.ret.layout.is_aggregate() {\n             // Returning a structure. Most often, this will use\n             // a hidden first argument. On some platforms, though,\n             // small structs are returned as integers.\n@@ -33,11 +32,12 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n             let t = &ccx.sess().target.target;\n             if t.options.is_like_osx || t.options.is_like_windows\n                 || t.options.is_like_openbsd {\n-                match llsize_of_alloc(ccx, fty.ret.ty) {\n-                    1 => fty.ret.cast = Some(Type::i8(ccx)),\n-                    2 => fty.ret.cast = Some(Type::i16(ccx)),\n-                    4 => fty.ret.cast = Some(Type::i32(ccx)),\n-                    8 => fty.ret.cast = Some(Type::i64(ccx)),\n+                let size = fty.ret.layout.size(ccx);\n+                match size.bytes() {\n+                    1 => fty.ret.cast_to(ccx, Reg::i8()),\n+                    2 => fty.ret.cast_to(ccx, Reg::i16()),\n+                    4 => fty.ret.cast_to(ccx, Reg::i32()),\n+                    8 => fty.ret.cast_to(ccx, Reg::i64()),\n                     _ => fty.ret.make_indirect(ccx)\n                 }\n             } else {\n@@ -50,7 +50,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        if arg.ty.kind() == Struct {\n+        if arg.layout.is_aggregate() {\n             arg.make_indirect(ccx);\n             arg.attrs.set(ArgAttribute::ByVal);\n         } else {\n@@ -73,12 +73,15 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n         for arg in &mut fty.args {\n             if arg.is_ignore() || arg.is_indirect() { continue; }\n \n-            if arg.ty.kind() == Float {\n+            // At this point we know this must be a primitive of sorts.\n+            let unit = arg.layout.homogenous_aggregate(ccx).unwrap();\n+            let size = arg.layout.size(ccx);\n+            assert_eq!(unit.size, size);\n+            if unit.kind == RegKind::Float {\n                 continue;\n             }\n \n-            let size = llbitsize_of_real(ccx, arg.ty);\n-            let size_in_regs = (size + 31) / 32;\n+            let size_in_regs = (size.bits() + 31) / 32;\n \n             if size_in_regs == 0 {\n                 continue;\n@@ -90,7 +93,7 @@ pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType, flavor: Flavor) {\n \n             free_regs -= size_in_regs;\n \n-            if size <= 32 && (arg.ty.kind() == Pointer || arg.ty.kind() == Integer) {\n+            if size.bits() <= 32 && unit.kind == RegKind::Integer {\n                 arg.attrs.set(ArgAttribute::InReg);\n             }\n "}, {"sha": "cbe170d85834cfa527dc845f877153c5dd157c89", "filename": "src/librustc_trans/cabi_x86_64.rs", "status": "modified", "additions": 187, "deletions": 325, "changes": 512, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_64.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -11,388 +11,250 @@\n // The classification code for the x86_64 ABI is taken from the clay language\n // https://github.com/jckarter/clay/blob/master/compiler/src/externals.cpp\n \n-#![allow(non_upper_case_globals)]\n-use self::RegClass::*;\n-\n-use llvm::{Integer, Pointer, Float, Double};\n-use llvm::{Struct, Array, Vector};\n-use abi::{self, ArgType, ArgAttribute, FnType};\n+use abi::{ArgType, ArgAttribute, CastTarget, FnType, LayoutExt, Reg, RegKind};\n use context::CrateContext;\n-use type_::Type;\n-\n-#[derive(Clone, Copy, PartialEq)]\n-enum RegClass {\n-    NoClass,\n-    Int,\n-    SSEFs,\n-    SSEFv,\n-    SSEDs,\n-    SSEDv,\n-    SSEInt(/* bitwidth */ u64),\n-    /// Data that can appear in the upper half of an SSE register.\n-    SSEUp,\n-    X87,\n-    X87Up,\n-    ComplexX87,\n-    Memory\n-}\n-\n-trait TypeMethods {\n-    fn is_reg_ty(&self) -> bool;\n-}\n-\n-impl TypeMethods for Type {\n-    fn is_reg_ty(&self) -> bool {\n-        match self.kind() {\n-            Integer | Pointer | Float | Double => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n-impl RegClass {\n-    fn is_sse(&self) -> bool {\n-        match *self {\n-            SSEFs | SSEFv | SSEDs | SSEDv | SSEInt(_) => true,\n-            _ => false\n-        }\n-    }\n-}\n-\n-trait ClassList {\n-    fn is_pass_byval(&self) -> bool;\n-    fn is_ret_bysret(&self) -> bool;\n-}\n-\n-impl ClassList for [RegClass] {\n-    fn is_pass_byval(&self) -> bool {\n-        if self.is_empty() { return false; }\n-\n-        let class = self[0];\n-           class == Memory\n-        || class == X87\n-        || class == ComplexX87\n-    }\n \n-    fn is_ret_bysret(&self) -> bool {\n-        if self.is_empty() { return false; }\n+use rustc::ty::layout::{self, Layout, TyLayout, Size};\n \n-        self[0] == Memory\n-    }\n+#[derive(Clone, Copy, PartialEq, Debug)]\n+enum Class {\n+    None,\n+    Int,\n+    Sse,\n+    SseUp\n }\n \n-fn classify_ty(ty: Type) -> Vec<RegClass> {\n-    fn align(off: usize, ty: Type) -> usize {\n-        let a = ty_align(ty);\n-        return (off + a - 1) / a * a;\n-    }\n-\n-    fn ty_align(ty: Type) -> usize {\n-        abi::ty_align(ty, 8)\n-    }\n-\n-    fn ty_size(ty: Type) -> usize {\n-        abi::ty_size(ty, 8)\n-    }\n-\n-    fn all_mem(cls: &mut [RegClass]) {\n-        for elt in cls {\n-            *elt = Memory;\n-        }\n-    }\n-\n-    fn unify(cls: &mut [RegClass],\n-             i: usize,\n-             newv: RegClass) {\n-        if cls[i] == newv { return }\n+#[derive(Clone, Copy, Debug)]\n+struct Memory;\n \n-        let to_write = match (cls[i], newv) {\n-            (NoClass,     _) => newv,\n-            (_,           NoClass) => return,\n+// Currently supported vector size (AVX).\n+const LARGEST_VECTOR_SIZE: usize = 256;\n+const MAX_EIGHTBYTES: usize = LARGEST_VECTOR_SIZE / 64;\n \n-            (Memory,      _) |\n-            (_,           Memory) => Memory,\n+fn classify_arg<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, arg: &ArgType<'tcx>)\n+                          -> Result<[Class; MAX_EIGHTBYTES], Memory> {\n+    fn unify(cls: &mut [Class],\n+             off: u64,\n+             c: Class) {\n+        let i = (off / 8) as usize;\n+        let to_write = match (cls[i], c) {\n+            (Class::None, _) => c,\n+            (_, Class::None) => return,\n \n-            (Int,         _) |\n-            (_,           Int) => Int,\n+            (Class::Int, _) |\n+            (_, Class::Int) => Class::Int,\n \n-            (X87,         _) |\n-            (X87Up,       _) |\n-            (ComplexX87,  _) |\n-            (_,           X87) |\n-            (_,           X87Up) |\n-            (_,           ComplexX87) => Memory,\n+            (Class::Sse, _) |\n+            (_, Class::Sse) => Class::Sse,\n \n-            (SSEFv,       SSEUp) |\n-            (SSEFs,       SSEUp) |\n-            (SSEDv,       SSEUp) |\n-            (SSEDs,       SSEUp) |\n-            (SSEInt(_),   SSEUp) => return,\n-\n-            (..) => newv\n+            (Class::SseUp, Class::SseUp) => Class::SseUp\n         };\n         cls[i] = to_write;\n     }\n \n-    fn classify_struct(tys: &[Type],\n-                       cls: &mut [RegClass],\n-                       i: usize,\n-                       off: usize,\n-                       packed: bool) {\n-        let mut field_off = off;\n-        for ty in tys {\n-            if !packed {\n-                field_off = align(field_off, *ty);\n+    fn classify<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                          layout: TyLayout<'tcx>,\n+                          cls: &mut [Class],\n+                          off: u64)\n+                          -> Result<(), Memory> {\n+        if off % layout.align(ccx).abi() != 0 {\n+            if layout.size(ccx).bytes() > 0 {\n+                return Err(Memory);\n             }\n-            classify(*ty, cls, i, field_off);\n-            field_off += ty_size(*ty);\n+            return Ok(());\n         }\n-    }\n \n-    fn classify(ty: Type,\n-                cls: &mut [RegClass], ix: usize,\n-                off: usize) {\n-        let t_align = ty_align(ty);\n-        let t_size = ty_size(ty);\n-\n-        let misalign = off % t_align;\n-        if misalign != 0 {\n-            let mut i = off / 8;\n-            let e = (off + t_size + 7) / 8;\n-            while i < e {\n-                unify(cls, ix + i, Memory);\n-                i += 1;\n+        match *layout {\n+            Layout::Scalar { value, .. } |\n+            Layout::RawNullablePointer { value, .. } => {\n+                let reg = match value {\n+                    layout::Int(_) |\n+                    layout::Pointer => Class::Int,\n+                    layout::F32 |\n+                    layout::F64 => Class::Sse\n+                };\n+                unify(cls, off, reg);\n             }\n-            return;\n-        }\n \n-        match ty.kind() {\n-            Integer |\n-            Pointer => {\n-                unify(cls, ix + off / 8, Int);\n+            Layout::CEnum { .. } => {\n+                unify(cls, off, Class::Int);\n             }\n-            Float => {\n-                if off % 8 == 4 {\n-                    unify(cls, ix + off / 8, SSEFv);\n-                } else {\n-                    unify(cls, ix + off / 8, SSEFs);\n+\n+            Layout::Vector { element, count } => {\n+                unify(cls, off, Class::Sse);\n+\n+                // everything after the first one is the upper\n+                // half of a register.\n+                let eltsz = element.size(ccx).bytes();\n+                for i in 1..count {\n+                    unify(cls, off + i * eltsz, Class::SseUp);\n                 }\n             }\n-            Double => {\n-                unify(cls, ix + off / 8, SSEDs);\n-            }\n-            Struct => {\n-                classify_struct(&ty.field_types(), cls, ix, off, ty.is_packed());\n-            }\n-            Array => {\n-                let len = ty.array_length();\n-                let elt = ty.element_type();\n-                let eltsz = ty_size(elt);\n-                let mut i = 0;\n-                while i < len {\n-                    classify(elt, cls, ix, off + i * eltsz);\n-                    i += 1;\n+\n+            Layout::Array { count, .. } => {\n+                if count > 0 {\n+                    let elt = layout.field(ccx, 0);\n+                    let eltsz = elt.size(ccx).bytes();\n+                    for i in 0..count {\n+                        classify(ccx, elt, cls, off + i * eltsz)?;\n+                    }\n                 }\n             }\n-            Vector => {\n-                let len = ty.vector_length();\n-                let elt = ty.element_type();\n-                let eltsz = ty_size(elt);\n-                let mut reg = match elt.kind() {\n-                    Integer => SSEInt(elt.int_width()),\n-                    Float => SSEFv,\n-                    Double => SSEDv,\n-                    _ => bug!(\"classify: unhandled vector element type\")\n-                };\n \n-                let mut i = 0;\n-                while i < len {\n-                    unify(cls, ix + (off + i * eltsz) / 8, reg);\n+            Layout::Univariant { ref variant, .. } => {\n+                for i in 0..layout.field_count() {\n+                    let field_off = off + variant.offsets[i].bytes();\n+                    classify(ccx, layout.field(ccx, i), cls, field_off)?;\n+                }\n+            }\n \n-                    // everything after the first one is the upper\n-                    // half of a register.\n-                    reg = SSEUp;\n-                    i += 1;\n+            Layout::UntaggedUnion { .. } => {\n+                for i in 0..layout.field_count() {\n+                    classify(ccx, layout.field(ccx, i), cls, off)?;\n                 }\n             }\n-            _ => bug!(\"classify: unhandled type\")\n+\n+            Layout::FatPointer { .. } |\n+            Layout::General { .. } |\n+            Layout::StructWrappedNullablePointer { .. } => return Err(Memory)\n         }\n+\n+        Ok(())\n+    }\n+\n+    let n = ((arg.layout.size(ccx).bytes() + 7) / 8) as usize;\n+    if n > MAX_EIGHTBYTES {\n+        return Err(Memory);\n     }\n \n-    fn fixup(ty: Type, cls: &mut [RegClass]) {\n+    let mut cls = [Class::None; MAX_EIGHTBYTES];\n+    classify(ccx, arg.layout, &mut cls, 0)?;\n+    if n > 2 {\n+        if cls[0] != Class::Sse {\n+            return Err(Memory);\n+        }\n+        if cls[1..n].iter().any(|&c| c != Class::SseUp) {\n+            return Err(Memory);\n+        }\n+    } else {\n         let mut i = 0;\n-        let ty_kind = ty.kind();\n-        let e = cls.len();\n-        if cls.len() > 2 && (ty_kind == Struct || ty_kind == Array || ty_kind == Vector) {\n-            if cls[i].is_sse() {\n+        while i < n {\n+            if cls[i] == Class::SseUp {\n+                cls[i] = Class::Sse;\n+            } else if cls[i] == Class::Sse {\n                 i += 1;\n-                while i < e {\n-                    if cls[i] != SSEUp {\n-                        all_mem(cls);\n-                        return;\n-                    }\n-                    i += 1;\n-                }\n+                while i != n && cls[i] == Class::SseUp { i += 1; }\n             } else {\n-                all_mem(cls);\n-                return\n-            }\n-        } else {\n-            while i < e {\n-                if cls[i] == Memory {\n-                    all_mem(cls);\n-                    return;\n-                }\n-                if cls[i] == X87Up {\n-                    // for darwin\n-                    // cls[i] = SSEDs;\n-                    all_mem(cls);\n-                    return;\n-                }\n-                if cls[i] == SSEUp {\n-                    cls[i] = SSEDv;\n-                } else if cls[i].is_sse() {\n-                    i += 1;\n-                    while i != e && cls[i] == SSEUp { i += 1; }\n-                } else if cls[i] == X87 {\n-                    i += 1;\n-                    while i != e && cls[i] == X87Up { i += 1; }\n-                } else {\n-                    i += 1;\n-                }\n+                i += 1;\n             }\n         }\n     }\n \n-    let words = (ty_size(ty) + 7) / 8;\n-    let mut cls = vec![NoClass; words];\n-    if words > 4 {\n-        all_mem(&mut cls);\n-        return cls;\n-    }\n-    classify(ty, &mut cls, 0, 0);\n-    fixup(ty, &mut cls);\n-    return cls;\n+    Ok(cls)\n }\n \n-fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n-    fn llvec_len(cls: &[RegClass]) -> usize {\n-        let mut len = 1;\n-        for c in cls {\n-            if *c != SSEUp {\n-                break;\n-            }\n-            len += 1;\n-        }\n-        return len;\n+fn reg_component(cls: &[Class], i: &mut usize, size: u64) -> Option<Reg> {\n+    if *i >= cls.len() {\n+        return None;\n     }\n \n-    let mut tys = Vec::new();\n-    let mut i = 0;\n-    let e = cls.len();\n-    while i < e {\n-        match cls[i] {\n-            Int => {\n-                tys.push(Type::i64(ccx));\n-            }\n-            SSEFv | SSEDv | SSEInt(_) => {\n-                let (elts_per_word, elt_ty) = match cls[i] {\n-                    SSEFv => (2, Type::f32(ccx)),\n-                    SSEDv => (1, Type::f64(ccx)),\n-                    SSEInt(bits) => {\n-                        assert!(bits == 8 || bits == 16 || bits == 32 || bits == 64,\n-                                \"llreg_ty: unsupported SSEInt width {}\", bits);\n-                        (64 / bits, Type::ix(ccx, bits))\n+    match cls[*i] {\n+        Class::None => None,\n+        Class::Int => {\n+            *i += 1;\n+            Some(match size {\n+                1 => Reg::i8(),\n+                2 => Reg::i16(),\n+                3 |\n+                4 => Reg::i32(),\n+                _ => Reg::i64()\n+            })\n+        }\n+        Class::Sse => {\n+            let vec_len = 1 + cls[*i+1..].iter().take_while(|&&c| c == Class::SseUp).count();\n+            *i += vec_len;\n+            Some(match size {\n+                4 => Reg::f32(),\n+                8 => Reg::f64(),\n+                _ => {\n+                    Reg {\n+                        kind: RegKind::Vector,\n+                        size: Size::from_bytes(vec_len as u64 * 8)\n                     }\n-                    _ => bug!(),\n-                };\n-                let vec_len = llvec_len(&cls[i + 1..]);\n-                let vec_ty = Type::vector(&elt_ty, vec_len as u64 * elts_per_word);\n-                tys.push(vec_ty);\n-                i += vec_len;\n-                continue;\n-            }\n-            SSEFs => {\n-                tys.push(Type::f32(ccx));\n-            }\n-            SSEDs => {\n-                tys.push(Type::f64(ccx));\n-            }\n-            _ => bug!(\"llregtype: unhandled class\")\n+                }\n+            })\n         }\n-        i += 1;\n+        c => bug!(\"reg_component: unhandled class {:?}\", c)\n     }\n-    if tys.len() == 1 && tys[0].kind() == Vector {\n-        // if the type contains only a vector, pass it as that vector.\n-        tys[0]\n+}\n+\n+fn cast_target(cls: &[Class], size: u64) -> CastTarget {\n+    let mut i = 0;\n+    let lo = reg_component(cls, &mut i, size).unwrap();\n+    let offset = i as u64 * 8;\n+    let target = if size <= offset {\n+        CastTarget::from(lo)\n     } else {\n-        Type::struct_(ccx, &tys, false)\n-    }\n+        let hi = reg_component(cls, &mut i, size - offset).unwrap();\n+        CastTarget::Pair(lo, hi)\n+    };\n+    assert_eq!(reg_component(cls, &mut i, 0), None);\n+    target\n }\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    fn x86_64_ty<F>(ccx: &CrateContext,\n-                    arg: &mut ArgType,\n-                    is_mem_cls: F,\n-                    ind_attr: Option<ArgAttribute>)\n-        where F: FnOnce(&[RegClass]) -> bool\n-    {\n-        if !arg.ty.is_reg_ty() {\n-            let cls = classify_ty(arg.ty);\n-            if is_mem_cls(&cls) {\n-                arg.make_indirect(ccx);\n-                if let Some(attr) = ind_attr {\n-                    arg.attrs.set(attr);\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n+    let mut sse_regs = 8; // XMM0-7\n+\n+    let mut x86_64_ty = |arg: &mut ArgType<'tcx>, is_arg: bool| {\n+        let cls = classify_arg(ccx, arg);\n+\n+        let mut needed_int = 0;\n+        let mut needed_sse = 0;\n+        let in_mem = match cls {\n+            Err(Memory) => true,\n+            Ok(ref cls) if is_arg => {\n+                for &c in cls {\n+                    match c {\n+                        Class::Int => needed_int += 1,\n+                        Class::Sse => needed_sse += 1,\n+                        _ => {}\n+                    }\n                 }\n-            } else {\n-                arg.cast = Some(llreg_ty(ccx, &cls));\n+                arg.layout.is_aggregate() &&\n+                    (int_regs < needed_int || sse_regs < needed_sse)\n             }\n-        } else {\n-            arg.extend_integer_width_to(32);\n-        }\n-    }\n+            Ok(_) => false\n+        };\n \n-    let mut int_regs = 6; // RDI, RSI, RDX, RCX, R8, R9\n-    let mut sse_regs = 8; // XMM0-7\n+        if in_mem {\n+            // `sret` / `byval` parameter thus one less integer register available\n+            int_regs -= 1;\n \n-    if !fty.ret.is_ignore() {\n-        x86_64_ty(ccx, &mut fty.ret, |cls| {\n-            if cls.is_ret_bysret() {\n-                // `sret` parameter thus one less register available\n-                int_regs -= 1;\n-                true\n+            arg.make_indirect(ccx);\n+            if is_arg {\n+                arg.attrs.set(ArgAttribute::ByVal);\n+            }\n+        } else {\n+            // split into sized chunks passed individually\n+            int_regs -= needed_int;\n+            sse_regs -= needed_sse;\n+\n+            if arg.layout.is_aggregate() {\n+                let size = arg.layout.size(ccx).bytes();\n+                arg.cast_to(ccx, cast_target(cls.as_ref().unwrap(), size))\n             } else {\n-                false\n+                arg.extend_integer_width_to(32);\n             }\n-        }, None);\n+        }\n+    };\n+\n+    if !fty.ret.is_ignore() {\n+        x86_64_ty(&mut fty.ret, false);\n     }\n \n     for arg in &mut fty.args {\n         if arg.is_ignore() { continue; }\n-        x86_64_ty(ccx, arg, |cls| {\n-            let needed_int = cls.iter().filter(|&&c| c == Int).count() as isize;\n-            let needed_sse = cls.iter().filter(|c| c.is_sse()).count() as isize;\n-            let in_mem = cls.is_pass_byval() ||\n-                         int_regs < needed_int ||\n-                         sse_regs < needed_sse;\n-            if in_mem {\n-                // `byval` parameter thus one less integer register available\n-                int_regs -= 1;\n-            } else {\n-                // split into sized chunks passed individually\n-                int_regs -= needed_int;\n-                sse_regs -= needed_sse;\n-            }\n-            in_mem\n-        }, Some(ArgAttribute::ByVal));\n-\n-        // An integer, pointer, double or float parameter\n-        // thus the above closure passed to `x86_64_ty` won't\n-        // get called.\n-        match arg.ty.kind() {\n-            Integer | Pointer => int_regs -= 1,\n-            Double | Float => sse_regs -= 1,\n-            _ => {}\n-        }\n+        x86_64_ty(arg, true);\n     }\n }"}, {"sha": "39e728d4e4f9b987bf4252031dbb2567b8665dbd", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -8,30 +8,33 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use llvm::*;\n-use super::common::*;\n-use super::machine::*;\n-use abi::{ArgType, FnType};\n-use type_::Type;\n+use abi::{ArgType, FnType, LayoutExt, Reg};\n+use common::CrateContext;\n+\n+use rustc::ty::layout::Layout;\n \n // Win64 ABI: http://msdn.microsoft.com/en-us/library/zthk2dkh.aspx\n \n-pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n-    let fixup = |a: &mut ArgType| {\n-        match a.ty.kind() {\n-            Struct => match llsize_of_alloc(ccx, a.ty) {\n-                          1 => a.cast = Some(Type::i8(ccx)),\n-                          2 => a.cast = Some(Type::i16(ccx)),\n-                          4 => a.cast = Some(Type::i32(ccx)),\n-                          8 => a.cast = Some(Type::i64(ccx)),\n-                          _ => a.make_indirect(ccx)\n-                      },\n-            Integer => match llsize_of_alloc(ccx, a.ty) {\n-                           1 ... 8 => a.extend_integer_width_to(32),\n-                           16 => a.make_indirect(ccx),\n-                           _ => bug!(),\n-            },\n-            _ => (),\n+pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fty: &mut FnType<'tcx>) {\n+    let fixup = |a: &mut ArgType<'tcx>| {\n+        let size = a.layout.size(ccx);\n+        if a.layout.is_aggregate() {\n+            match size.bits() {\n+                8 => a.cast_to(ccx, Reg::i8()),\n+                16 => a.cast_to(ccx, Reg::i16()),\n+                32 => a.cast_to(ccx, Reg::i32()),\n+                64 => a.cast_to(ccx, Reg::i64()),\n+                _ => a.make_indirect(ccx)\n+            };\n+        } else {\n+            if let Layout::Vector { .. } = *a.layout {\n+                // FIXME(eddyb) there should be a size cap here\n+                // (probably what clang calls \"illegal vectors\").\n+            } else if size.bytes() > 8 {\n+                a.make_indirect(ccx);\n+            } else {\n+                a.extend_integer_width_to(32);\n+            }\n         }\n     };\n "}, {"sha": "5d58c93538922ab6544adb417c5c1827b396551e", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -27,7 +27,7 @@ use monomorphize;\n use type_::Type;\n use value::Value;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::ty::layout::Layout;\n+use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::ty::subst::{Subst, Substs};\n use rustc::hir;\n \n@@ -63,7 +63,7 @@ pub fn type_is_immediate<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -\n         Layout::UntaggedUnion { .. } |\n         Layout::RawNullablePointer { .. } |\n         Layout::StructWrappedNullablePointer { .. } => {\n-            !layout.is_unsized() && layout.size(&ccx.tcx().data_layout).bytes() == 0\n+            !layout.is_unsized() && layout.size(ccx).bytes() == 0\n         }\n     }\n }\n@@ -125,10 +125,8 @@ pub fn type_is_imm_pair<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>)\n \n /// Identify types which have size zero at runtime.\n pub fn type_is_zero_size<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n-    use machine::llsize_of_alloc;\n-    use type_of::sizing_type_of;\n-    let llty = sizing_type_of(ccx, ty);\n-    llsize_of_alloc(ccx, llty) == 0\n+    let layout = ccx.layout_of(ty);\n+    !layout.is_unsized() && layout.size(ccx).bytes() == 0\n }\n \n /*"}, {"sha": "6b6fa538dc03b655e72d8b3af5c663f1ea01e0c3", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -255,7 +255,7 @@ pub fn trans_static<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             ccx.statics_to_rauw().borrow_mut().push((g, new_g));\n             new_g\n         };\n-        llvm::LLVMSetAlignment(g, type_of::align_of(ccx, ty));\n+        llvm::LLVMSetAlignment(g, ccx.align_of(ty));\n         llvm::LLVMSetInitializer(g, v);\n \n         // As an optimization, all shared statics which do not have interior"}, {"sha": "98fbb64fd55407b467c2bf20dbfb85744b563bfe", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -28,6 +28,7 @@ use type_::Type;\n use rustc_data_structures::base_n;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::layout::{LayoutTyper, TyLayout};\n use session::config::NoDebugInfo;\n use session::Session;\n use session::config;\n@@ -828,18 +829,6 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n         TypeOfDepthLock(self.local())\n     }\n \n-    pub fn layout_of(&self, ty: Ty<'tcx>) -> &'tcx ty::layout::Layout {\n-        self.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n-            ty.layout(&infcx).unwrap_or_else(|e| {\n-                match e {\n-                    ty::layout::LayoutError::SizeOverflow(_) =>\n-                        self.sess().fatal(&e.to_string()),\n-                    _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n-                }\n-            })\n-        })\n-    }\n-\n     pub fn check_overflow(&self) -> bool {\n         self.shared.check_overflow\n     }\n@@ -951,6 +940,54 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> ty::layout::HasDataLayout for &'a SharedCrateContext<'a, 'tcx> {\n+    fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n+        &self.tcx.data_layout\n+    }\n+}\n+\n+impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.tcx\n+    }\n+}\n+\n+impl<'a, 'tcx> ty::layout::HasDataLayout for &'a CrateContext<'a, 'tcx> {\n+    fn data_layout(&self) -> &ty::layout::TargetDataLayout {\n+        &self.shared.tcx.data_layout\n+    }\n+}\n+\n+impl<'a, 'tcx> ty::layout::HasTyCtxt<'tcx> for &'a CrateContext<'a, 'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'b, 'tcx, 'tcx> {\n+        self.shared.tcx\n+    }\n+}\n+\n+impl<'a, 'tcx> LayoutTyper<'tcx> for &'a SharedCrateContext<'a, 'tcx> {\n+    type TyLayout = TyLayout<'tcx>;\n+\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        self.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n+            infcx.layout_of(ty).unwrap_or_else(|e| {\n+                match e {\n+                    ty::layout::LayoutError::SizeOverflow(_) =>\n+                        self.sess().fatal(&e.to_string()),\n+                    _ => bug!(\"failed to get layout for `{}`: {}\", ty, e)\n+                }\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> LayoutTyper<'tcx> for &'a CrateContext<'a, 'tcx> {\n+    type TyLayout = TyLayout<'tcx>;\n+\n+    fn layout_of(self, ty: Ty<'tcx>) -> Self::TyLayout {\n+        self.shared.layout_of(ty)\n+    }\n+}\n+\n pub struct TypeOfDepthLock<'a, 'tcx: 'a>(&'a LocalCrateContext<'tcx>);\n \n impl<'a, 'tcx> Drop for TypeOfDepthLock<'a, 'tcx> {"}, {"sha": "ccb693aa41f4c4a5e8ac78ad33b5d6a1d86e4046", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -35,7 +35,8 @@ use rustc_data_structures::ToHex;\n use {type_of, machine, monomorphize};\n use common::{self, CrateContext};\n use type_::Type;\n-use rustc::ty::{self, AdtKind, Ty, layout};\n+use rustc::ty::{self, AdtKind, Ty};\n+use rustc::ty::layout::{self, LayoutTyper};\n use session::config;\n use util::nodemap::FxHashMap;\n use util::common::path2cstr;\n@@ -900,7 +901,7 @@ impl<'tcx> StructMemberDescriptionFactory<'tcx> {\n         let offsets = match *layout {\n             layout::Univariant { ref variant, .. } => &variant.offsets,\n             layout::Vector { element, count } => {\n-                let element_size = element.size(&cx.tcx().data_layout).bytes();\n+                let element_size = element.size(cx).bytes();\n                 tmp = (0..count).\n                   map(|i| layout::Size::from_bytes(i*element_size))\n                   .collect::<Vec<layout::Size>>();\n@@ -1564,7 +1565,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         enum_llvm_type,\n         EnumMDF(EnumMemberDescriptionFactory {\n             enum_type: enum_type,\n-            type_rep: type_rep,\n+            type_rep: type_rep.layout,\n             discriminant_type_metadata: discriminant_type_metadata,\n             containing_scope: containing_scope,\n             file_metadata: file_metadata,\n@@ -1772,7 +1773,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let var_name = CString::new(var_name).unwrap();\n     let linkage_name = CString::new(linkage_name).unwrap();\n \n-    let global_align = type_of::align_of(cx, variable_type);\n+    let global_align = cx.align_of(variable_type);\n \n     unsafe {\n         llvm::LLVMRustDIBuilderCreateStaticVariable(DIB(cx),"}, {"sha": "1b7cf26853bc137ebf91a01268069818776ae93e", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -449,7 +449,7 @@ pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         LocalVariable    |\n         CapturedVariable => (0, DW_TAG_auto_variable)\n     };\n-    let align = ::type_of::align_of(cx, variable_type);\n+    let align = cx.align_of(variable_type);\n \n     let name = CString::new(variable_name.as_str().as_bytes()).unwrap();\n     match (variable_access, &[][..]) {"}, {"sha": "59876a7f2a201da688fe23eda5f397852fd9ceb0", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -18,11 +18,10 @@ use llvm;\n use llvm::{ValueRef};\n use rustc::traits;\n use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::layout::LayoutTyper;\n use common::*;\n-use machine::*;\n use meth;\n use monomorphize;\n-use type_of::{sizing_type_of, align_of};\n use value::Value;\n use builder::Builder;\n \n@@ -49,7 +48,7 @@ pub fn needs_drop_glue<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>, t: Ty<'tcx>\n             if !scx.type_needs_drop(typ) && scx.type_is_sized(typ) {\n                 scx.tcx().infer_ctxt((), traits::Reveal::All).enter(|infcx| {\n                     let layout = t.layout(&infcx).unwrap();\n-                    if layout.size(&scx.tcx().data_layout).bytes() == 0 {\n+                    if layout.size(scx).bytes() == 0 {\n                         // `Box<ZeroSizeType>` does not allocate.\n                         false\n                     } else {\n@@ -69,9 +68,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n     debug!(\"calculate size of DST: {}; with lost info: {:?}\",\n            t, Value(info));\n     if bcx.ccx.shared().type_is_sized(t) {\n-        let sizing_type = sizing_type_of(bcx.ccx, t);\n-        let size = llsize_of_alloc(bcx.ccx, sizing_type);\n-        let align = align_of(bcx.ccx, t);\n+        let size = bcx.ccx.size_of(t);\n+        let align = bcx.ccx.align_of(t);\n         debug!(\"size_and_align_of_dst t={} info={:?} size: {} align: {}\",\n                t, Value(info), size, align);\n         let size = C_uint(bcx.ccx, size);\n@@ -82,9 +80,8 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n         ty::TyAdt(def, substs) => {\n             let ccx = bcx.ccx;\n             // First get the size of all statically known fields.\n-            // Don't use type_of::sizing_type_of because that expects t to be sized,\n-            // and it also rounds up to alignment, which we want to avoid,\n-            // as the unsized field's alignment could be smaller.\n+            // Don't use size_of because it also rounds up to alignment, which we\n+            // want to avoid, as the unsized field's alignment could be smaller.\n             assert!(!t.is_simd());\n             let layout = ccx.layout_of(t);\n             debug!(\"DST {} layout: {:?}\", t, layout);\n@@ -154,14 +151,11 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &Builder<'a, 'tcx>, t: Ty<'tcx>, inf\n             (meth::SIZE.get_usize(bcx, info), meth::ALIGN.get_usize(bcx, info))\n         }\n         ty::TySlice(_) | ty::TyStr => {\n-            let unit_ty = t.sequence_element_type(bcx.tcx());\n+            let unit = t.sequence_element_type(bcx.tcx());\n             // The info in this case is the length of the str, so the size is that\n             // times the unit size.\n-            let llunit_ty = sizing_type_of(bcx.ccx, unit_ty);\n-            let unit_align = llalign_of_min(bcx.ccx, llunit_ty);\n-            let unit_size = llsize_of_alloc(bcx.ccx, llunit_ty);\n-            (bcx.mul(info, C_uint(bcx.ccx, unit_size)),\n-             C_uint(bcx.ccx, unit_align))\n+            (bcx.mul(info, C_uint(bcx.ccx, bcx.ccx.size_of(unit))),\n+             C_uint(bcx.ccx, bcx.ccx.align_of(unit)))\n         }\n         _ => bug!(\"Unexpected unsized type, found {}\", t)\n     }"}, {"sha": "5e7d612d17f82e21eb12904140b5b21cabaa9b36", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -151,7 +151,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n         }\n         \"min_align_of\" => {\n             let tp_ty = substs.type_at(0);\n-            C_uint(ccx, type_of::align_of(ccx, tp_ty))\n+            C_uint(ccx, ccx.align_of(tp_ty))\n         }\n         \"min_align_of_val\" => {\n             let tp_ty = substs.type_at(0);\n@@ -160,7 +160,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                     glue::size_and_align_of_dst(bcx, tp_ty, llargs[1]);\n                 llalign\n             } else {\n-                C_uint(ccx, type_of::align_of(ccx, tp_ty))\n+                C_uint(ccx, ccx.align_of(tp_ty))\n             }\n         }\n         \"pref_align_of\" => {\n@@ -234,7 +234,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n             }\n             let load = bcx.volatile_load(ptr);\n             unsafe {\n-                llvm::LLVMSetAlignment(load, type_of::align_of(ccx, tp_ty));\n+                llvm::LLVMSetAlignment(load, ccx.align_of(tp_ty));\n             }\n             to_immediate(bcx, load, tp_ty)\n         },\n@@ -252,7 +252,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 let ptr = bcx.pointercast(llargs[0], val_ty(val).ptr_to());\n                 let store = bcx.volatile_store(val, ptr);\n                 unsafe {\n-                    llvm::LLVMSetAlignment(store, type_of::align_of(ccx, tp_ty));\n+                    llvm::LLVMSetAlignment(store, ccx.align_of(tp_ty));\n                 }\n             }\n             C_nil(ccx)\n@@ -634,7 +634,7 @@ pub fn trans_intrinsic_call<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n     if val_ty(llval) != Type::void(ccx) && machine::llsize_of_alloc(ccx, val_ty(llval)) != 0 {\n         if let Some(ty) = fn_ty.ret.cast {\n             let ptr = bcx.pointercast(llresult, ty.ptr_to());\n-            bcx.store(llval, ptr, Some(type_of::align_of(ccx, ret_ty)));\n+            bcx.store(llval, ptr, Some(ccx.align_of(ret_ty)));\n         } else {\n             store_ty(bcx, llval, llresult, Alignment::AbiAligned, ret_ty);\n         }\n@@ -651,7 +651,7 @@ fn copy_intrinsic<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                             -> ValueRef {\n     let ccx = bcx.ccx;\n     let lltp_ty = type_of::type_of(ccx, tp_ty);\n-    let align = C_i32(ccx, type_of::align_of(ccx, tp_ty) as i32);\n+    let align = C_i32(ccx, ccx.align_of(tp_ty) as i32);\n     let size = machine::llsize_of(ccx, lltp_ty);\n     let int_size = machine::llbitsize_of_real(ccx, ccx.int_type());\n \n@@ -685,7 +685,7 @@ fn memset_intrinsic<'a, 'tcx>(\n     count: ValueRef\n ) -> ValueRef {\n     let ccx = bcx.ccx;\n-    let align = C_i32(ccx, type_of::align_of(ccx, ty) as i32);\n+    let align = C_i32(ccx, ccx.align_of(ty) as i32);\n     let lltp_ty = type_of::type_of(ccx, ty);\n     let size = machine::llsize_of(ccx, lltp_ty);\n     let dst = bcx.pointercast(dst, Type::i8p(ccx));"}, {"sha": "f5f924178589a04d2d0efe8b1fcd9d1384d1ce84", "filename": "src/librustc_trans/meth.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmeth.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -17,7 +17,6 @@ use consts;\n use machine;\n use monomorphize;\n use type_::Type;\n-use type_of::*;\n use value::Value;\n use rustc::ty;\n \n@@ -80,14 +79,10 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Not in the cache. Build it.\n     let nullptr = C_null(Type::nil(ccx).ptr_to());\n \n-    let size_ty = sizing_type_of(ccx, ty);\n-    let size = machine::llsize_of_alloc(ccx, size_ty);\n-    let align = align_of(ccx, ty);\n-\n     let mut components: Vec<_> = [\n         callee::get_fn(ccx, monomorphize::resolve_drop_in_place(ccx.shared(), ty)),\n-        C_uint(ccx, size),\n-        C_uint(ccx, align)\n+        C_uint(ccx, ccx.size_of(ty)),\n+        C_uint(ccx, ccx.align_of(ty))\n     ].iter().cloned().collect();\n \n     if let Some(trait_ref) = trait_ref {"}, {"sha": "caec4789eddce310a244e9c36ddf16eaa1138342", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -12,7 +12,8 @@ use llvm::{self, ValueRef, BasicBlockRef};\n use rustc_const_eval::{ErrKind, ConstEvalErr, note_const_eval_err};\n use rustc::middle::lang_items;\n use rustc::middle::const_val::ConstInt;\n-use rustc::ty::{self, layout, TypeFoldable};\n+use rustc::ty::{self, TypeFoldable};\n+use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir;\n use abi::{Abi, FnType, ArgType};\n use base::{self, Lifetime};\n@@ -24,8 +25,8 @@ use consts;\n use machine::llalign_of_min;\n use meth;\n use monomorphize;\n+use type_of;\n use tvec;\n-use type_of::{self, align_of};\n use type_::Type;\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -177,7 +178,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let llslot = match op.val {\n                         Immediate(_) | Pair(..) => {\n-                            let llscratch = bcx.alloca(ret.original_ty, \"ret\");\n+                            let llscratch = bcx.alloca(ret.memory_ty(bcx.ccx), \"ret\");\n                             self.store_operand(&bcx, llscratch, None, op);\n                             llscratch\n                         }\n@@ -189,7 +190,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                     };\n                     let load = bcx.load(\n                         bcx.pointercast(llslot, cast_ty.ptr_to()),\n-                        Some(llalign_of_min(bcx.ccx, ret.ty)));\n+                        Some(ret.layout.align(bcx.ccx).abi() as u32));\n                     load\n                 } else {\n                     let op = self.trans_consume(&bcx, &mir::Lvalue::Local(mir::RETURN_POINTER));\n@@ -515,7 +516,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             (llargs[0], &llargs[1..])\n                         }\n                         ReturnDest::Nothing => {\n-                            (C_undef(fn_ty.ret.original_ty.ptr_to()), &llargs[..])\n+                            (C_undef(fn_ty.ret.memory_ty(bcx.ccx).ptr_to()), &llargs[..])\n                         }\n                         ReturnDest::IndirectOperand(dst, _) |\n                         ReturnDest::Store(dst) => (dst, &llargs[..]),\n@@ -534,7 +535,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             val: Ref(dst, Alignment::AbiAligned),\n                             ty: sig.output(),\n                         };\n-                        self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n+                        self.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n                     }\n \n                     if let Some((_, target)) = *destination {\n@@ -573,7 +574,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             val: Immediate(invokeret),\n                             ty: sig.output(),\n                         };\n-                        self.store_return(&ret_bcx, ret_dest, fn_ty.ret, op);\n+                        self.store_return(&ret_bcx, ret_dest, &fn_ty.ret, op);\n                     }\n                 } else {\n                     let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle);\n@@ -583,7 +584,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             val: Immediate(llret),\n                             ty: sig.output(),\n                         };\n-                        self.store_return(&bcx, ret_dest, fn_ty.ret, op);\n+                        self.store_return(&bcx, ret_dest, &fn_ty.ret, op);\n                         funclet_br(self, bcx, target);\n                     } else {\n                         bcx.unreachable();\n@@ -597,7 +598,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                       bcx: &Builder<'a, 'tcx>,\n                       op: OperandRef<'tcx>,\n                       llargs: &mut Vec<ValueRef>,\n-                      fn_ty: &FnType,\n+                      fn_ty: &FnType<'tcx>,\n                       next_idx: &mut usize,\n                       llfn: &mut Option<ValueRef>,\n                       def: &Option<ty::InstanceDef<'tcx>>) {\n@@ -640,7 +641,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let (mut llval, align, by_ref) = match op.val {\n             Immediate(_) | Pair(..) => {\n                 if arg.is_indirect() || arg.cast.is_some() {\n-                    let llscratch = bcx.alloca(arg.original_ty, \"arg\");\n+                    let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\");\n                     self.store_operand(bcx, llscratch, None, op);\n                     (llscratch, Alignment::AbiAligned, true)\n                 } else {\n@@ -652,7 +653,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 // think that ATM (Rust 1.16) we only pass temporaries, but we shouldn't\n                 // have scary latent bugs around.\n \n-                let llscratch = bcx.alloca(arg.original_ty, \"arg\");\n+                let llscratch = bcx.alloca(arg.memory_ty(bcx.ccx), \"arg\");\n                 base::memcpy_ty(bcx, llscratch, llval, op.ty, Some(1));\n                 (llscratch, Alignment::AbiAligned, true)\n             }\n@@ -661,13 +662,13 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         if by_ref && !arg.is_indirect() {\n             // Have to load the argument, maybe while casting it.\n-            if arg.original_ty == Type::i1(bcx.ccx) {\n+            if arg.layout.ty == bcx.tcx().types.bool {\n                 // We store bools as i8 so we need to truncate to i1.\n                 llval = bcx.load_range_assert(llval, 0, 2, llvm::False, None);\n-                llval = bcx.trunc(llval, arg.original_ty);\n+                llval = bcx.trunc(llval, Type::i1(bcx.ccx));\n             } else if let Some(ty) = arg.cast {\n                 llval = bcx.load(bcx.pointercast(llval, ty.ptr_to()),\n-                                 align.min_with(llalign_of_min(bcx.ccx, arg.ty)));\n+                                 align.min_with(arg.layout.align(bcx.ccx).abi() as u32));\n             } else {\n                 llval = bcx.load(llval, align.to_align());\n             }\n@@ -680,7 +681,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 bcx: &Builder<'a, 'tcx>,\n                                 operand: &mir::Operand<'tcx>,\n                                 llargs: &mut Vec<ValueRef>,\n-                                fn_ty: &FnType,\n+                                fn_ty: &FnType<'tcx>,\n                                 next_idx: &mut usize,\n                                 llfn: &mut Option<ValueRef>,\n                                 def: &Option<ty::InstanceDef<'tcx>>) {\n@@ -910,7 +911,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let cast_ptr = bcx.pointercast(dst.llval, llty.ptr_to());\n         let in_type = val.ty;\n         let out_type = dst.ty.to_ty(bcx.tcx());;\n-        let llalign = cmp::min(align_of(bcx.ccx, in_type), align_of(bcx.ccx, out_type));\n+        let llalign = cmp::min(bcx.ccx.align_of(in_type), bcx.ccx.align_of(out_type));\n         self.store_operand(bcx, cast_ptr, Some(llalign), val);\n     }\n \n@@ -919,7 +920,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     fn store_return(&mut self,\n                     bcx: &Builder<'a, 'tcx>,\n                     dest: ReturnDest,\n-                    ret_ty: ArgType,\n+                    ret_ty: &ArgType<'tcx>,\n                     op: OperandRef<'tcx>) {\n         use self::ReturnDest::*;\n "}, {"sha": "4d5b691c86ebb514def7c8e559a6a2eb39f73b59", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -18,7 +18,8 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n-use rustc::ty::{self, layout, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n+use rustc::ty::layout::{self, LayoutTyper};\n use rustc::ty::cast::{CastTy, IntTy};\n use rustc::ty::subst::{Kind, Substs, Subst};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -148,7 +149,7 @@ impl<'tcx> Const<'tcx> {\n         } else {\n             // Otherwise, or if the value is not immediate, we create\n             // a constant LLVM global and cast its address if necessary.\n-            let align = type_of::align_of(ccx, self.ty);\n+            let align = ccx.align_of(self.ty);\n             let ptr = consts::addr_of(ccx, self.llval, align, \"const\");\n             OperandValue::Ref(consts::ptrcast(ptr, llty.ptr_to()), Alignment::AbiAligned)\n         };\n@@ -717,7 +718,7 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     Base::Value(llval) => {\n                         // FIXME: may be wrong for &*(&simd_vec as &fmt::Debug)\n                         let align = if self.ccx.shared().type_is_sized(ty) {\n-                            type_of::align_of(self.ccx, ty)\n+                            self.ccx.align_of(ty)\n                         } else {\n                             self.ccx.tcx().data_layout.pointer_align.abi() as machine::llalign\n                         };\n@@ -979,7 +980,6 @@ fn trans_const<'a, 'tcx>(\n     vals: &[ValueRef]\n ) -> ValueRef {\n     let l = ccx.layout_of(t);\n-    let dl = &ccx.tcx().data_layout;\n     let variant_index = match *kind {\n         mir::AggregateKind::Adt(_, index, _, _) => index,\n         _ => 0,\n@@ -1002,7 +1002,7 @@ fn trans_const<'a, 'tcx>(\n             let mut vals_with_discr = vec![lldiscr];\n             vals_with_discr.extend_from_slice(vals);\n             let mut contents = build_const_struct(ccx, &variant, &vals_with_discr[..]);\n-            let needed_padding = l.size(dl).bytes() - variant.stride().bytes();\n+            let needed_padding = l.size(ccx).bytes() - variant.stride().bytes();\n             if needed_padding > 0 {\n                 contents.push(padding(ccx, needed_padding));\n             }\n@@ -1022,25 +1022,20 @@ fn trans_const<'a, 'tcx>(\n             C_vector(vals)\n         }\n         layout::RawNullablePointer { nndiscr, .. } => {\n-            let nnty = adt::compute_fields(ccx, t, nndiscr as usize, false)[0];\n             if variant_index as u64 == nndiscr {\n                 assert_eq!(vals.len(), 1);\n                 vals[0]\n             } else {\n-                C_null(type_of::sizing_type_of(ccx, nnty))\n+                C_null(type_of::type_of(ccx, t))\n             }\n         }\n         layout::StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             if variant_index as u64 == nndiscr {\n                 C_struct(ccx, &build_const_struct(ccx, &nonnull, vals), false)\n             } else {\n-                let fields = adt::compute_fields(ccx, t, nndiscr as usize, false);\n-                let vals = fields.iter().map(|&ty| {\n-                    // Always use null even if it's not the `discrfield`th\n-                    // field; see #8506.\n-                    C_null(type_of::sizing_type_of(ccx, ty))\n-                }).collect::<Vec<ValueRef>>();\n-                C_struct(ccx, &build_const_struct(ccx, &nonnull, &vals[..]), false)\n+                // Always use null even if it's not the `discrfield`th\n+                // field; see #8506.\n+                C_null(type_of::type_of(ccx, t))\n             }\n         }\n         _ => bug!(\"trans_const: cannot handle type {} repreented as {:#?}\", t, l)"}, {"sha": "fc889604ab88ea900c50afd2ac1e24d04e8b4078", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -9,7 +9,8 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::ty::{self, layout, Ty, TypeFoldable};\n+use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;"}, {"sha": "c8d15d28708f4e3b9a8b926bc272afd174e9c778", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -11,7 +11,8 @@\n use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n-use rustc::ty::{self, layout};\n+use rustc::ty;\n+use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir::{self, Mir};\n use rustc::mir::tcx::LvalueTy;\n use rustc::ty::subst::Substs;\n@@ -52,7 +53,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n     ccx: &'a CrateContext<'a, 'tcx>,\n \n-    fn_ty: FnType,\n+    fn_ty: FnType<'tcx>,\n \n     /// When unwinding is initiated, we have to store this personality\n     /// value somewhere so that we can load it and re-use it in the\n@@ -454,6 +455,23 @@ fn arg_local_refs<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n                 assert_eq!((meta.cast, meta.pad), (None, None));\n                 let llmeta = llvm::get_param(bcx.llfn(), llarg_idx as c_uint);\n                 llarg_idx += 1;\n+\n+                // FIXME(eddyb) As we can't perfectly represent the data and/or\n+                // vtable pointer in a fat pointers in Rust's typesystem, and\n+                // because we split fat pointers into two ArgType's, they're\n+                // not the right type so we have to cast them for now.\n+                let pointee = match arg_ty.sty {\n+                    ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n+                    ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => ty,\n+                    ty::TyAdt(def, _) if def.is_box() => arg_ty.boxed_ty(),\n+                    _ => bug!()\n+                };\n+                let data_llty = type_of::in_memory_type_of(bcx.ccx, pointee);\n+                let meta_llty = type_of::unsized_info_ty(bcx.ccx, pointee);\n+\n+                let llarg = bcx.pointercast(llarg, data_llty.ptr_to());\n+                let llmeta = bcx.pointercast(llmeta, meta_llty);\n+\n                 OperandValue::Pair(llarg, llmeta)\n             } else {\n                 OperandValue::Immediate(llarg)"}, {"sha": "771a88238b2b73a66cbcdb319bebbf97e9ce5c98", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -10,7 +10,7 @@\n \n use llvm::ValueRef;\n use rustc::ty::{self, Ty};\n-use rustc::ty::layout::Layout;\n+use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::mir;\n use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;"}, {"sha": "8f7cb914c47354294c7342dbe17b88e577c02eb2", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -11,7 +11,7 @@\n use llvm::{self, ValueRef};\n use rustc::ty::{self, Ty};\n use rustc::ty::cast::{CastTy, IntTy};\n-use rustc::ty::layout::Layout;\n+use rustc::ty::layout::{Layout, LayoutTyper};\n use rustc::mir::tcx::LvalueTy;\n use rustc::mir;\n use middle::lang_items::ExchangeMallocFnLangItem;\n@@ -438,7 +438,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                 let content_ty: Ty<'tcx> = self.monomorphize(&content_ty);\n                 let llty = type_of::type_of(bcx.ccx, content_ty);\n                 let llsize = machine::llsize_of(bcx.ccx, llty);\n-                let align = type_of::align_of(bcx.ccx, content_ty);\n+                let align = bcx.ccx.align_of(content_ty);\n                 let llalign = C_uint(bcx.ccx, align);\n                 let llty_ptr = llty.ptr_to();\n                 let box_ty = bcx.tcx().mk_box(content_ty);"}, {"sha": "d4ab6b0782855b7702c3b1fcfe030e4cf5aed512", "filename": "src/librustc_trans/type_of.rs", "status": "modified", "additions": 10, "deletions": 122, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Flibrustc_trans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_of.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -13,127 +13,12 @@ use adt;\n use common::*;\n use machine;\n use rustc::ty::{self, Ty, TypeFoldable};\n+use rustc::ty::layout::LayoutTyper;\n use trans_item::DefPathBasedNames;\n use type_::Type;\n \n use syntax::ast;\n \n-\n-// A \"sizing type\" is an LLVM type, the size and alignment of which are\n-// guaranteed to be equivalent to what you would get out of `type_of()`. It's\n-// useful because:\n-//\n-// (1) It may be cheaper to compute the sizing type than the full type if all\n-//     you're interested in is the size and/or alignment;\n-//\n-// (2) It won't make any recursive calls to determine the structure of the\n-//     type behind pointers. This can help prevent infinite loops for\n-//     recursive types. For example, enum types rely on this behavior.\n-\n-pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n-    if let Some(t) = cx.llsizingtypes().borrow().get(&t).cloned() {\n-        return t;\n-    }\n-\n-    debug!(\"sizing_type_of {:?}\", t);\n-    let _recursion_lock = cx.enter_type_of(t);\n-\n-    let ptr_sizing_ty = |ty: Ty<'tcx>| {\n-        if cx.shared().type_is_sized(ty) {\n-            Type::i8p(cx)\n-        } else {\n-            Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, ty)], false)\n-        }\n-    };\n-    let llsizingty = match t.sty {\n-        _ if !cx.shared().type_is_sized(t) => {\n-            Type::struct_(cx, &[Type::i8p(cx), unsized_info_ty(cx, t)], false)\n-        }\n-\n-        ty::TyBool => Type::bool(cx),\n-        ty::TyChar => Type::char(cx),\n-        ty::TyInt(t) => Type::int_from_ty(cx, t),\n-        ty::TyUint(t) => Type::uint_from_ty(cx, t),\n-        ty::TyFloat(t) => Type::float_from_ty(cx, t),\n-        ty::TyNever => Type::nil(cx),\n-\n-        ty::TyRef(_, ty::TypeAndMut{ty, ..}) |\n-        ty::TyRawPtr(ty::TypeAndMut{ty, ..}) => {\n-            ptr_sizing_ty(ty)\n-        }\n-        ty::TyAdt(def, _) if def.is_box() => {\n-            ptr_sizing_ty(t.boxed_ty())\n-        }\n-\n-        ty::TyFnDef(..) => Type::nil(cx),\n-        ty::TyFnPtr(_) => Type::i8p(cx),\n-\n-        ty::TyArray(ty, size) => {\n-            let llty = sizing_type_of(cx, ty);\n-            let size = size as u64;\n-            Type::array(&llty, size)\n-        }\n-\n-        ty::TyTuple(ref tys, _) if tys.is_empty() => {\n-            Type::nil(cx)\n-        }\n-\n-        ty::TyAdt(..) if t.is_simd() => {\n-            let e = t.simd_type(cx.tcx());\n-            if !e.is_machine() {\n-                cx.sess().fatal(&format!(\"monomorphising SIMD type `{}` with \\\n-                                          a non-machine element type `{}`\",\n-                                         t, e))\n-            }\n-            let llet = type_of(cx, e);\n-            let n = t.simd_size(cx.tcx()) as u64;\n-            Type::vector(&llet, n)\n-        }\n-\n-        ty::TyTuple(..) | ty::TyAdt(..) | ty::TyClosure(..) => {\n-            adt::sizing_type_of(cx, t, false)\n-        }\n-\n-        ty::TyProjection(..) | ty::TyInfer(..) | ty::TyParam(..) |\n-        ty::TyAnon(..) | ty::TyError => {\n-            bug!(\"fictitious type {:?} in sizing_type_of()\", t)\n-        }\n-        ty::TySlice(_) | ty::TyDynamic(..) | ty::TyStr => bug!()\n-    };\n-\n-    debug!(\"--> mapped t={:?} to llsizingty={:?}\", t, llsizingty);\n-\n-    cx.llsizingtypes().borrow_mut().insert(t, llsizingty);\n-\n-    // FIXME(eddyb) Temporary sanity check for ty::layout.\n-    let layout = cx.layout_of(t);\n-    if !cx.shared().type_is_sized(t) {\n-        if !layout.is_unsized() {\n-            bug!(\"layout should be unsized for type `{}` / {:#?}\",\n-                 t, layout);\n-        }\n-\n-        // Unsized types get turned into a fat pointer for LLVM.\n-        return llsizingty;\n-    }\n-\n-    let r = layout.size(&cx.tcx().data_layout).bytes();\n-    let l = machine::llsize_of_alloc(cx, llsizingty);\n-    if r != l {\n-        bug!(\"size differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n-             r, l, t, layout);\n-    }\n-\n-    let r = layout.align(&cx.tcx().data_layout).abi();\n-    let l = machine::llalign_of_min(cx, llsizingty) as u64;\n-    if r != l {\n-        bug!(\"align differs (rustc: {}, llvm: {}) for type `{}` / {:#?}\",\n-             r, l, t, layout);\n-    }\n-\n-    llsizingty\n-}\n-\n pub fn fat_ptr_base_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n     match ty.sty {\n         ty::TyRef(_, ty::TypeAndMut { ty: t, .. }) |\n@@ -147,7 +32,7 @@ pub fn fat_ptr_base_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) ->\n     }\n }\n \n-fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n+pub fn unsized_info_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n     let unsized_part = ccx.tcx().struct_tail(ty);\n     match unsized_part.sty {\n         ty::TyStr | ty::TyArray(..) | ty::TySlice(_) => {\n@@ -196,7 +81,6 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> Type {\n /// of that field's type - this is useful for taking the address of\n /// that field and ensuring the struct has the right alignment.\n /// For the LLVM type of a value as a whole, see `type_of`.\n-/// NB: If you update this, be sure to update `sizing_type_of()` as well.\n pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     // Check the cache.\n     if let Some(&llty) = cx.lltypes().borrow().get(&t) {\n@@ -322,10 +206,14 @@ pub fn in_memory_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) ->\n     llty\n }\n \n-pub fn align_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n-                          -> machine::llalign {\n-    let layout = cx.layout_of(t);\n-    layout.align(&cx.tcx().data_layout).abi() as machine::llalign\n+impl<'a, 'tcx> CrateContext<'a, 'tcx> {\n+    pub fn align_of(&self, ty: Ty<'tcx>) -> machine::llalign {\n+        self.layout_of(ty).align(self).abi() as machine::llalign\n+    }\n+\n+    pub fn size_of(&self, ty: Ty<'tcx>) -> machine::llsize {\n+        self.layout_of(ty).size(self).bytes() as machine::llsize\n+    }\n }\n \n fn llvm_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> String {"}, {"sha": "bc84ac49da985a11166ccc4e2c80793f45291e63", "filename": "src/test/codegen/function-arguments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2c48ae6f7ffae392d85c86240c67f49df01f44fd/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Ffunction-arguments.rs?ref=2c48ae6f7ffae392d85c86240c67f49df01f44fd", "patch": "@@ -121,13 +121,13 @@ pub fn unsafe_slice(_: &[UnsafeInner]) {\n fn str(_: &[u8]) {\n }\n \n-// CHECK: @trait_borrow(i8* nonnull, void (i8*)** noalias nonnull readonly)\n+// CHECK: @trait_borrow({}* nonnull, {}* noalias nonnull readonly)\n // FIXME #25759 This should also have `nocapture`\n #[no_mangle]\n fn trait_borrow(_: &Drop) {\n }\n \n-// CHECK: @trait_box(i8* noalias nonnull, void (i8*)** noalias nonnull readonly)\n+// CHECK: @trait_box({}* noalias nonnull, {}* noalias nonnull readonly)\n #[no_mangle]\n fn trait_box(_: Box<Drop>) {\n }"}]}