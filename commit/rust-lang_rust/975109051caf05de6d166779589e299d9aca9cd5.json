{"sha": "975109051caf05de6d166779589e299d9aca9cd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk3NTEwOTA1MWNhZjA1ZGU2ZDE2Njc3OTU4OWUyOTlkOWFjYTljZDU=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-06T04:42:00Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-05-31T19:03:46Z"}, "message": "Basic lowering hir_def::exrp::Pat -> typed HIR.\n\nPattern arena is broken", "tree": {"sha": "6bfbfb1e9f6ae45b2d81921bd7cf5cfe449f673f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bfbfb1e9f6ae45b2d81921bd7cf5cfe449f673f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/975109051caf05de6d166779589e299d9aca9cd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/975109051caf05de6d166779589e299d9aca9cd5", "html_url": "https://github.com/rust-lang/rust/commit/975109051caf05de6d166779589e299d9aca9cd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/975109051caf05de6d166779589e299d9aca9cd5/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2431ff5987ee1f802ede0db5eedc863ce9a8e70f", "url": "https://api.github.com/repos/rust-lang/rust/commits/2431ff5987ee1f802ede0db5eedc863ce9a8e70f", "html_url": "https://github.com/rust-lang/rust/commit/2431ff5987ee1f802ede0db5eedc863ce9a8e70f"}], "stats": {"total": 551, "additions": 387, "deletions": 164}, "files": [{"sha": "8f141a308d2f8fb66d548c055275d162a5ceb2e4", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/975109051caf05de6d166779589e299d9aca9cd5/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975109051caf05de6d166779589e299d9aca9cd5/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=975109051caf05de6d166779589e299d9aca9cd5", "patch": "@@ -2,7 +2,7 @@\n //! through the body using inference results: mismatched arg counts, missing\n //! fields, etc.\n \n-use std::sync::Arc;\n+use std::{cell::RefCell, sync::Arc};\n \n use hir_def::{expr::Statement, path::path, resolver::HasResolver, AssocItemId, DefWithBodyId};\n use hir_expand::name;\n@@ -26,7 +26,13 @@ pub(crate) use hir_def::{\n     LocalFieldId, VariantId,\n };\n \n-use super::ReplaceFilterMapNextWithFindMap;\n+use super::{\n+    pattern::{\n+        self,\n+        usefulness::{expand_pattern, PatternArena},\n+    },\n+    ReplaceFilterMapNextWithFindMap,\n+};\n \n pub(super) struct ExprValidator<'a, 'b: 'a> {\n     owner: DefWithBodyId,\n@@ -380,7 +386,16 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         };\n         // eprintln!(\"ExprValidator::validate_match2({:?})\", _match_expr_ty.kind(&Interner));\n \n-        let pattern_arena = usefulness::PatternArena::clone_from(&body.pats);\n+        let pattern_arena = RefCell::new(PatternArena::new());\n+\n+        let m_arms: Vec<_> = arms\n+            .iter()\n+            .map(|arm| usefulness::MatchArm {\n+                pat: self.lower_pattern(arm.pat, &mut pattern_arena.borrow_mut(), db, &body),\n+                has_guard: arm.guard.is_some(),\n+            })\n+            .collect();\n+\n         let cx = usefulness::MatchCheckCtx {\n             module: self.owner.module(db.upcast()),\n             match_expr,\n@@ -389,12 +404,6 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             db,\n             pattern_arena: &pattern_arena,\n         };\n-\n-        let m_arms: Vec<_> = arms\n-            .iter()\n-            .map(|arm| usefulness::MatchArm { pat: arm.pat, has_guard: arm.guard.is_some() })\n-            .collect();\n-\n         let report = usefulness::compute_match_usefulness(&cx, &m_arms);\n \n         // TODO Report unreacheble arms\n@@ -427,6 +436,18 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         }\n     }\n \n+    fn lower_pattern(\n+        &self,\n+        pat: PatId,\n+        pattern_arena: &mut PatternArena,\n+        db: &dyn HirDatabase,\n+        body: &Body,\n+    ) -> pattern::PatId {\n+        let mut patcx = pattern::PatCtxt::new(db, &self.infer, body);\n+        let pattern = patcx.lower_pattern(pat);\n+        pattern_arena.alloc(expand_pattern(pattern))\n+    }\n+\n     fn validate_results_in_tail_expr(&mut self, body_id: ExprId, id: ExprId, db: &dyn HirDatabase) {\n         // the mismatch will be on the whole block currently\n         let mismatch = match self.infer.type_mismatch_for_expr(body_id) {"}, {"sha": "6646826b33039a75bb7a9d9d9ae5f8bf3e505184", "filename": "crates/hir_ty/src/diagnostics/pattern.rs", "status": "modified", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/975109051caf05de6d166779589e299d9aca9cd5/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975109051caf05de6d166779589e299d9aca9cd5/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern.rs?ref=975109051caf05de6d166779589e299d9aca9cd5", "patch": "@@ -2,8 +2,199 @@\n #![allow(unused)] // todo remove\n \n mod deconstruct_pat;\n+// TODO: find a better place for this?\n+mod pat_util;\n pub mod usefulness;\n \n+use hir_def::{body::Body, EnumVariantId, LocalFieldId, VariantId};\n+use la_arena::Idx;\n+\n+use crate::{db::HirDatabase, AdtId, InferenceResult, Interner, Substitution, Ty, TyKind};\n+\n+use self::{deconstruct_pat::ToDo, pat_util::EnumerateAndAdjustIterator};\n+\n+pub type PatId = Idx<Pat>;\n+\n+#[derive(Clone, Debug)]\n+pub(crate) enum PatternError {\n+    Unimplemented,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct FieldPat {\n+    pub field: LocalFieldId,\n+    pub pattern: Pat,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub struct Pat {\n+    pub ty: Ty,\n+    pub kind: Box<PatKind>,\n+}\n+\n+impl Pat {\n+    pub(crate) fn wildcard_from_ty(ty: &Ty) -> Self {\n+        Pat { ty: ty.clone(), kind: Box::new(PatKind::Wild) }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum PatKind {\n+    Wild,\n+\n+    /// `x`, `ref x`, `x @ P`, etc.\n+    Binding {\n+        subpattern: Option<Pat>,\n+        // todo: ToDo,\n+    },\n+\n+    /// `Foo(...)` or `Foo{...}` or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// multiple variants.\n+    Variant {\n+        substs: Substitution,\n+        enum_variant: EnumVariantId,\n+        subpatterns: Vec<FieldPat>,\n+    },\n+\n+    /// `(...)`, `Foo(...)`, `Foo{...}`, or `Foo`, where `Foo` is a variant name from an ADT with\n+    /// a single variant.\n+    Leaf {\n+        subpatterns: Vec<FieldPat>,\n+    },\n+\n+    /// `box P`, `&P`, `&mut P`, etc.\n+    Deref {\n+        subpattern: Pat,\n+    },\n+\n+    /// An or-pattern, e.g. `p | q`.\n+    /// Invariant: `pats.len() >= 2`.\n+    Or {\n+        pats: Vec<Pat>,\n+    },\n+}\n+\n+pub(crate) struct PatCtxt<'a> {\n+    db: &'a dyn HirDatabase,\n+    infer: &'a InferenceResult,\n+    body: &'a Body,\n+    pub(crate) errors: Vec<PatternError>,\n+}\n+\n+impl<'a> PatCtxt<'a> {\n+    pub(crate) fn new(db: &'a dyn HirDatabase, infer: &'a InferenceResult, body: &'a Body) -> Self {\n+        Self { db, infer, body, errors: Vec::new() }\n+    }\n+\n+    pub(crate) fn lower_pattern(&mut self, pat: hir_def::expr::PatId) -> Pat {\n+        // TODO: pattern adjustments (implicit dereference)\n+        // More info https://github.com/rust-lang/rust/issues/42640#issuecomment-313535089\n+        let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n+        unadjusted_pat\n+    }\n+\n+    fn lower_pattern_unadjusted(&mut self, pat: hir_def::expr::PatId) -> Pat {\n+        let ty = &self.infer[pat];\n+\n+        let kind = match self.body[pat] {\n+            hir_def::expr::Pat::Wild => PatKind::Wild,\n+\n+            hir_def::expr::Pat::Tuple { ref args, ellipsis } => {\n+                let arity = match *ty.kind(&Interner) {\n+                    TyKind::Tuple(arity, _) => arity,\n+                    _ => panic!(\"unexpected type for tuple pattern: {:?}\", ty),\n+                };\n+                let subpatterns = self.lower_tuple_subpats(args, arity, ellipsis);\n+                PatKind::Leaf { subpatterns }\n+            }\n+\n+            hir_def::expr::Pat::TupleStruct { ref args, ellipsis, .. } => {\n+                let variant_data = match self.infer.variant_resolution_for_pat(pat) {\n+                    Some(variant_id) => variant_id.variant_data(self.db.upcast()),\n+                    None => panic!(\"tuple struct pattern not applied to an ADT {:?}\", ty),\n+                };\n+                let subpatterns =\n+                    self.lower_tuple_subpats(args, variant_data.fields().len(), ellipsis);\n+                self.lower_variant_or_leaf(pat, ty, subpatterns)\n+            }\n+\n+            hir_def::expr::Pat::Record { ref args, .. } => {\n+                let variant_data = match self.infer.variant_resolution_for_pat(pat) {\n+                    Some(variant_id) => variant_id.variant_data(self.db.upcast()),\n+                    None => panic!(\"record pattern not applied to an ADT {:?}\", ty),\n+                };\n+                let subpatterns = args\n+                    .iter()\n+                    .map(|field| FieldPat {\n+                        // XXX(iDawer): field lookup is inefficient\n+                        field: variant_data.field(&field.name).unwrap_or_else(|| todo!()),\n+                        pattern: self.lower_pattern(field.pat),\n+                    })\n+                    .collect();\n+                self.lower_variant_or_leaf(pat, ty, subpatterns)\n+            }\n+\n+            hir_def::expr::Pat::Or(ref pats) => PatKind::Or { pats: self.lower_patterns(pats) },\n+\n+            _ => {\n+                self.errors.push(PatternError::Unimplemented);\n+                PatKind::Wild\n+            }\n+        };\n+\n+        Pat { ty: ty.clone(), kind: Box::new(kind) }\n+    }\n+\n+    fn lower_tuple_subpats(\n+        &mut self,\n+        pats: &[hir_def::expr::PatId],\n+        expected_len: usize,\n+        ellipsis: Option<usize>,\n+    ) -> Vec<FieldPat> {\n+        pats.iter()\n+            .enumerate_and_adjust(expected_len, ellipsis)\n+            .map(|(i, &subpattern)| FieldPat {\n+                field: LocalFieldId::from_raw((i as u32).into()),\n+                pattern: self.lower_pattern(subpattern),\n+            })\n+            .collect()\n+    }\n+\n+    fn lower_patterns(&mut self, pats: &[hir_def::expr::PatId]) -> Vec<Pat> {\n+        pats.iter().map(|&p| self.lower_pattern(p)).collect()\n+    }\n+\n+    fn lower_variant_or_leaf(\n+        &mut self,\n+        pat: hir_def::expr::PatId,\n+        ty: &Ty,\n+        subpatterns: Vec<FieldPat>,\n+    ) -> PatKind {\n+        let kind = match self.infer.variant_resolution_for_pat(pat) {\n+            Some(variant_id) => {\n+                if let VariantId::EnumVariantId(enum_variant) = variant_id {\n+                    let substs = match ty.kind(&Interner) {\n+                        TyKind::Adt(_, substs) | TyKind::FnDef(_, substs) => substs.clone(),\n+                        TyKind::Error => {\n+                            return PatKind::Wild;\n+                        }\n+                        _ => panic!(\"inappropriate type for def: {:?}\", ty),\n+                    };\n+                    PatKind::Variant { substs, enum_variant, subpatterns }\n+                } else {\n+                    PatKind::Leaf { subpatterns }\n+                }\n+            }\n+            None => {\n+                self.errors.push(PatternError::Unimplemented);\n+                PatKind::Wild\n+            }\n+        };\n+        // TODO: do we need PatKind::AscribeUserType ?\n+        kind\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::diagnostics::tests::check_diagnostics;"}, {"sha": "479e0dc73a6db5300ea0f5a1ee44dbf6d485ec48", "filename": "crates/hir_ty/src/diagnostics/pattern/deconstruct_pat.rs", "status": "modified", "additions": 81, "deletions": 107, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/975109051caf05de6d166779589e299d9aca9cd5/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975109051caf05de6d166779589e299d9aca9cd5/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fdeconstruct_pat.rs?ref=975109051caf05de6d166779589e299d9aca9cd5", "patch": "@@ -5,18 +5,18 @@ use std::{\n };\n \n use hir_def::{\n-    expr::{Expr, Literal, Pat, PatId, RecordFieldPat},\n-    find_path::find_path,\n-    item_scope::ItemInNs,\n-    path::Path,\n+    expr::{Expr, Literal, RecordFieldPat},\n     type_ref::Mutability,\n-    AttrDefId, EnumVariantId, HasModule, VariantId,\n+    AttrDefId, EnumVariantId, HasModule, LocalFieldId, VariantId,\n };\n use smallvec::{smallvec, SmallVec};\n \n use crate::{AdtId, Interner, Scalar, Ty, TyExt, TyKind};\n \n-use super::usefulness::{MatchCheckCtx, PatCtxt};\n+use super::{\n+    usefulness::{MatchCheckCtx, PatCtxt},\n+    FieldPat, Pat, PatId, PatKind,\n+};\n \n use self::Constructor::*;\n \n@@ -271,29 +271,18 @@ impl Constructor {\n     /// Determines the constructor that the given pattern can be specialized to.\n     pub(super) fn from_pat(cx: &MatchCheckCtx<'_>, pat: PatId) -> Self {\n         let ty = cx.type_of(pat);\n-        match &cx.pattern_arena.borrow()[pat] {\n-            Pat::Bind { .. } | Pat::Wild => Wildcard,\n-            Pat::Tuple { .. } | Pat::Ref { .. } | Pat::Box { .. } => Single,\n-            Pat::Record { .. } | Pat::Path(_) | Pat::TupleStruct { .. } => {\n-                // TODO: path to const\n-                let variant_id =\n-                    cx.infer.variant_resolution_for_pat(pat).unwrap_or_else(|| todo!());\n-                match variant_id {\n-                    VariantId::EnumVariantId(id) => Variant(id),\n-                    VariantId::StructId(_) | VariantId::UnionId(_) => Single,\n-                }\n-            }\n-            &Pat::Lit(expr_id) => match cx.body[expr_id] {\n-                Expr::Literal(Literal::Bool(val)) => IntRange(IntRange::from_bool(val)),\n-                _ => todo!(),\n-            },\n-\n-            Pat::Or(..) => panic!(\"bug: Or-pattern should have been expanded earlier on.\"),\n-            Pat::Missing => todo!(\"Fail gracefully when there is an error in a pattern\"),\n+        match cx.pattern_arena.borrow()[pat].kind.as_ref() {\n+            PatKind::Binding { .. } | PatKind::Wild => Wildcard,\n+            PatKind::Leaf { .. } | PatKind::Deref { .. } => Single,\n+            &PatKind::Variant { enum_variant, .. } => Variant(enum_variant),\n+\n+            //Todo\n+            // &Pat::Lit(expr_id) => match cx.body[expr_id] {\n+            //     Expr::Literal(Literal::Bool(val)) => IntRange(IntRange::from_bool(val)),\n+            //     _ => todo!(),\n+            // },\n+            PatKind::Or { .. } => panic!(\"bug: Or-pattern should have been expanded earlier on.\"),\n             pat => todo!(\"Constructor::from_pat {:?}\", pat),\n-            // Pat::Range { start, end } => {}\n-            // Pat::Slice { prefix, slice, suffix } => {}\n-            // Pat::ConstBlock(_) => {}\n         }\n     }\n \n@@ -620,15 +609,15 @@ impl Fields {\n         cx: &MatchCheckCtx<'_>,\n         tys: impl IntoIterator<Item = &'a Ty>,\n     ) -> Self {\n-        let wilds = tys.into_iter().map(|ty| (Pat::Wild, ty));\n-        let pats = wilds.map(|(pat, ty)| cx.alloc_pat(pat, ty)).collect();\n+        let wilds = tys.into_iter().map(Pat::wildcard_from_ty);\n+        let pats = wilds.map(|pat| cx.alloc_pat(pat)).collect();\n         Fields::Vec(pats)\n     }\n \n     pub(crate) fn wildcards(pcx: PatCtxt<'_>, constructor: &Constructor) -> Self {\n         let ty = pcx.ty;\n         let cx = pcx.cx;\n-        let wildcard_from_ty = |ty| cx.alloc_pat(Pat::Wild, ty);\n+        let wildcard_from_ty = |ty| cx.alloc_pat(Pat::wildcard_from_ty(ty));\n \n         let ret = match constructor {\n             Single | Variant(_) => match ty.kind(&Interner) {\n@@ -696,64 +685,60 @@ impl Fields {\n     /// returns `Some(false)`\n     pub(super) fn apply(self, pcx: PatCtxt<'_>, ctor: &Constructor) -> Pat {\n         let subpatterns_and_indices = self.patterns_and_indices();\n-        let mut subpatterns = subpatterns_and_indices.iter().map(|&(_, p)| p);\n-        // TODO witnesses are not yet used\n-        const TODO: Pat = Pat::Wild;\n+        let mut subpatterns =\n+            subpatterns_and_indices.iter().map(|&(_, p)| pcx.cx.pattern_arena.borrow()[p].clone());\n+        // FIXME(iDawer) witnesses are not yet used\n+        const UNIMPLEMENTED: PatKind = PatKind::Wild;\n \n-        match ctor {\n+        let pat = match ctor {\n             Single | Variant(_) => match pcx.ty.kind(&Interner) {\n                 TyKind::Adt(..) | TyKind::Tuple(..) => {\n                     // We want the real indices here.\n-                    // TODO indices and ellipsis interaction, tests\n-                    let subpatterns = subpatterns_and_indices.iter().map(|&(_, pat)| pat).collect();\n+                    let subpatterns = subpatterns_and_indices\n+                        .iter()\n+                        .map(|&(field, pat)| FieldPat {\n+                            field,\n+                            pattern: pcx.cx.pattern_arena.borrow()[pat].clone(),\n+                        })\n+                        .collect();\n \n                     if let Some((adt, substs)) = pcx.ty.as_adt() {\n-                        let item = ItemInNs::Types(adt.into());\n-                        let path = find_path(pcx.cx.db.upcast(), item, pcx.cx.module)\n-                            .map(|mpath| Path::from_known_path(mpath, Vec::new()).into());\n-                        match adt {\n-                            hir_def::AdtId::EnumId(id) => TODO,\n-                            hir_def::AdtId::StructId(id) => {\n-                                let variant_data = &pcx.cx.db.struct_data(id).variant_data;\n-                                let args = subpatterns_and_indices\n-                                    .iter()\n-                                    .zip(variant_data.fields().iter())\n-                                    .map(|(&(_, pat), (_, field_data))| RecordFieldPat {\n-                                        name: field_data.name.clone(),\n-                                        pat,\n-                                    })\n-                                    .collect();\n-                                Pat::Record { path, args, ellipsis: false }\n-                            }\n-                            hir_def::AdtId::UnionId(_) => Pat::Wild,\n+                        if let hir_def::AdtId::EnumId(_) = adt {\n+                            let enum_variant = match ctor {\n+                                &Variant(id) => id,\n+                                _ => unreachable!(),\n+                            };\n+                            PatKind::Variant { substs: substs.clone(), enum_variant, subpatterns }\n+                        } else {\n+                            PatKind::Leaf { subpatterns }\n                         }\n                     } else {\n-                        Pat::Tuple { args: subpatterns, ellipsis: None }\n+                        PatKind::Leaf { subpatterns }\n                     }\n                 }\n                 // Note: given the expansion of `&str` patterns done in `expand_pattern`, we should\n                 // be careful to reconstruct the correct constant pattern here. However a string\n                 // literal pattern will never be reported as a non-exhaustiveness witness, so we\n                 // can ignore this issue.\n-                TyKind::Ref(..) => {\n-                    Pat::Ref { pat: subpatterns.next().unwrap(), mutability: Mutability::Shared }\n-                }\n+                TyKind::Ref(..) => PatKind::Deref { subpattern: subpatterns.next().unwrap() },\n                 TyKind::Slice(..) | TyKind::Array(..) => {\n                     panic!(\"bug: bad slice pattern {:?} {:?}\", ctor, pcx.ty)\n                 }\n-                _ => Pat::Wild,\n+                _ => PatKind::Wild,\n             },\n-            Constructor::Slice(slice) => TODO,\n-            Str(_) => TODO,\n-            FloatRange(..) => TODO,\n-            Constructor::IntRange(_) => TODO,\n-            NonExhaustive => Pat::Wild,\n-            Wildcard => Pat::Wild,\n+            Constructor::Slice(slice) => UNIMPLEMENTED,\n+            Str(_) => UNIMPLEMENTED,\n+            FloatRange(..) => UNIMPLEMENTED,\n+            Constructor::IntRange(_) => UNIMPLEMENTED,\n+            NonExhaustive => PatKind::Wild,\n+            Wildcard => return Pat::wildcard_from_ty(pcx.ty),\n             Opaque => panic!(\"bug: we should not try to apply an opaque constructor\"),\n             Missing => {\n                 panic!(\"bug: trying to apply the `Missing` constructor; this should have been done in `apply_constructors`\")\n             }\n-        }\n+        };\n+\n+        Pat { ty: pcx.ty.clone(), kind: Box::new(pat) }\n     }\n \n     /// Returns the number of patterns. This is the same as the arity of the constructor used to\n@@ -765,9 +750,14 @@ impl Fields {\n     }\n \n     /// Returns the list of patterns along with the corresponding field indices.\n-    fn patterns_and_indices(&self) -> SmallVec<[(usize, PatId); 2]> {\n+    fn patterns_and_indices(&self) -> SmallVec<[(LocalFieldId, PatId); 2]> {\n         match self {\n-            Fields::Vec(pats) => pats.iter().copied().enumerate().collect(),\n+            Fields::Vec(pats) => pats\n+                .iter()\n+                .copied()\n+                .enumerate()\n+                .map(|(i, p)| (LocalFieldId::from_raw((i as u32).into()), p))\n+                .collect(),\n         }\n     }\n \n@@ -779,8 +769,13 @@ impl Fields {\n \n     /// Overrides some of the fields with the provided patterns. Exactly like\n     /// `replace_fields_indexed`, except that it takes `FieldPat`s as input.\n-    fn replace_with_fieldpats(&self, new_pats: impl IntoIterator<Item = PatId>) -> Self {\n-        self.replace_fields_indexed(new_pats.into_iter().enumerate())\n+    fn replace_with_fieldpats(\n+        &self,\n+        new_pats: impl IntoIterator<Item = (LocalFieldId, PatId)>,\n+    ) -> Self {\n+        self.replace_fields_indexed(\n+            new_pats.into_iter().map(|(field, pat)| (u32::from(field.into_raw()) as usize, pat)),\n+        )\n     }\n \n     /// Overrides some of the fields with the provided patterns. This is used when a pattern\n@@ -814,10 +809,7 @@ impl Fields {\n             let tys: SmallVec<[Ty; 2]> = match self {\n                 Fields::Vec(pats) => pats.iter().copied().map(|pat| cx.type_of(pat)).collect(),\n             };\n-            pats.into_iter()\n-                .zip(tys.into_iter())\n-                .map(move |(pat, ty)| cx.alloc_pat(pat, &ty))\n-                .collect()\n+            pats.into_iter().zip(tys.into_iter()).map(move |(pat, ty)| cx.alloc_pat(pat)).collect()\n         };\n \n         match self {\n@@ -845,42 +837,24 @@ impl Fields {\n         pat: PatId,\n         cx: &MatchCheckCtx<'_>,\n     ) -> Self {\n-        match &cx.pattern_arena.borrow()[pat] {\n-            Pat::Ref { pat: subpattern, .. } | Pat::Box { inner: subpattern } => {\n+        // TODO: these alocations are so unfortunate (+1 for switching to references)\n+        match cx.pattern_arena.borrow()[pat].kind.as_ref() {\n+            PatKind::Deref { subpattern } => {\n                 assert_eq!(self.len(), 1);\n-                Fields::from_single_pattern(*subpattern)\n+                let subpattern = cx.pattern_arena.borrow_mut().alloc(subpattern.clone());\n+                Fields::from_single_pattern(subpattern)\n             }\n-            Pat::Tuple { args, ellipsis } | Pat::TupleStruct { args, ellipsis, .. } => {\n-                // FIXME(iDawer) handle ellipsis.\n-                // XXX(iDawer): in rustc, this is handled by HIR->TypedHIR lowering\n-                // rustc_mir_build::thir::pattern::PatCtxt::lower_tuple_subpats(..)\n-                self.replace_with_fieldpats(args.iter().copied())\n-            }\n-            Pat::Record { args, ellipsis, .. } => {\n-                let variant_id =\n-                    cx.infer.variant_resolution_for_pat(pat).unwrap_or_else(|| todo!());\n-                let variant_data = variant_id.variant_data(cx.db.upcast());\n-\n-                let new_pats = args.iter().map(|field_pat| {\n-                    // TODO: field lookup is inefficient\n-                    let raw =\n-                        variant_data.field(&field_pat.name).unwrap_or_else(|| todo!()).into_raw();\n-                    let idx = u32::from(raw) as usize;\n-                    (idx, field_pat.pat)\n+            PatKind::Leaf { subpatterns } | PatKind::Variant { subpatterns, .. } => {\n+                let subpatterns = subpatterns.iter().map(|field_pat| {\n+                    (\n+                        field_pat.field,\n+                        cx.pattern_arena.borrow_mut().alloc(field_pat.pattern.clone()),\n+                    )\n                 });\n-                self.replace_fields_indexed(new_pats)\n-            }\n-            Pat::Slice { .. } => {\n-                todo!()\n+                self.replace_with_fieldpats(subpatterns)\n             }\n-            Pat::Missing\n-            | Pat::Wild\n-            | Pat::Or(_)\n-            | Pat::Range { .. }\n-            | Pat::Path(_)\n-            | Pat::Lit(_)\n-            | Pat::Bind { .. }\n-            | Pat::ConstBlock(_) => self.clone(),\n+\n+            PatKind::Wild | PatKind::Binding { .. } | PatKind::Or { .. } => self.clone(),\n         }\n     }\n }"}, {"sha": "f8ad4e7c6fc41780ff0b57ba37aba53802ff6ceb", "filename": "crates/hir_ty/src/diagnostics/pattern/pat_util.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/975109051caf05de6d166779589e299d9aca9cd5/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fpat_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975109051caf05de6d166779589e299d9aca9cd5/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fpat_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fpat_util.rs?ref=975109051caf05de6d166779589e299d9aca9cd5", "patch": "@@ -0,0 +1,52 @@\n+use std::iter::{Enumerate, ExactSizeIterator};\n+\n+pub struct EnumerateAndAdjust<I> {\n+    enumerate: Enumerate<I>,\n+    gap_pos: usize,\n+    gap_len: usize,\n+}\n+\n+impl<I> Iterator for EnumerateAndAdjust<I>\n+where\n+    I: Iterator,\n+{\n+    type Item = (usize, <I as Iterator>::Item);\n+\n+    fn next(&mut self) -> Option<(usize, <I as Iterator>::Item)> {\n+        self.enumerate\n+            .next()\n+            .map(|(i, elem)| (if i < self.gap_pos { i } else { i + self.gap_len }, elem))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.enumerate.size_hint()\n+    }\n+}\n+\n+pub trait EnumerateAndAdjustIterator {\n+    fn enumerate_and_adjust(\n+        self,\n+        expected_len: usize,\n+        gap_pos: Option<usize>,\n+    ) -> EnumerateAndAdjust<Self>\n+    where\n+        Self: Sized;\n+}\n+\n+impl<T: ExactSizeIterator> EnumerateAndAdjustIterator for T {\n+    fn enumerate_and_adjust(\n+        self,\n+        expected_len: usize,\n+        gap_pos: Option<usize>,\n+    ) -> EnumerateAndAdjust<Self>\n+    where\n+        Self: Sized,\n+    {\n+        let actual_len = self.len();\n+        EnumerateAndAdjust {\n+            enumerate: self.enumerate(),\n+            gap_pos: gap_pos.unwrap_or(expected_len),\n+            gap_len: expected_len - actual_len,\n+        }\n+    }\n+}"}, {"sha": "28b9e71f8a7456d3e0fed45c273f7d7cf7112742", "filename": "crates/hir_ty/src/diagnostics/pattern/usefulness.rs", "status": "modified", "additions": 33, "deletions": 48, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/975109051caf05de6d166779589e299d9aca9cd5/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/975109051caf05de6d166779589e299d9aca9cd5/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fpattern%2Fusefulness.rs?ref=975109051caf05de6d166779589e299d9aca9cd5", "patch": "@@ -3,19 +3,18 @@\n \n use std::{cell::RefCell, iter::FromIterator, ops::Index, sync::Arc};\n \n-use hir_def::{\n-    body::Body,\n-    expr::{ExprId, Pat, PatId},\n-    HasModule, ModuleId,\n-};\n+use hir_def::{body::Body, expr::ExprId, HasModule, ModuleId};\n use la_arena::Arena;\n use once_cell::unsync::OnceCell;\n use rustc_hash::FxHashMap;\n use smallvec::{smallvec, SmallVec};\n \n use crate::{db::HirDatabase, InferenceResult, Ty};\n \n-use super::deconstruct_pat::{Constructor, Fields, SplitWildcard};\n+use super::{\n+    deconstruct_pat::{Constructor, Fields, SplitWildcard},\n+    Pat, PatId, PatKind,\n+};\n \n use self::{\n     helper::{Captures, PatIdExt},\n@@ -55,14 +54,13 @@ impl<'a> MatchCheckCtx<'a> {\n         false\n     }\n \n-    pub(super) fn alloc_pat(&self, pat: Pat, ty: &Ty) -> PatId {\n-        self.pattern_arena.borrow_mut().alloc(pat, ty)\n+    pub(super) fn alloc_pat(&self, pat: Pat) -> PatId {\n+        self.pattern_arena.borrow_mut().alloc(pat)\n     }\n \n     /// Get type of a pattern. Handles expanded patterns.\n     pub(super) fn type_of(&self, pat: PatId) -> Ty {\n-        let type_of_expanded_pat = self.pattern_arena.borrow().type_of_epat.get(&pat).cloned();\n-        type_of_expanded_pat.unwrap_or_else(|| self.infer[pat].clone())\n+        self.pattern_arena.borrow()[pat].ty.clone()\n     }\n }\n \n@@ -76,30 +74,40 @@ pub(super) struct PatCtxt<'a> {\n     pub(super) is_top_level: bool,\n }\n \n-impl PatIdExt for PatId {\n-    fn is_wildcard(self, cx: &MatchCheckCtx<'_>) -> bool {\n-        matches!(cx.pattern_arena.borrow()[self], Pat::Bind { subpat: None, .. } | Pat::Wild)\n+pub(crate) fn expand_pattern(pat: Pat) -> Pat {\n+    // TODO: LiteralExpander, it is about string literal patterns\n+    pat\n+}\n+\n+impl Pat {\n+    fn is_wildcard(&self) -> bool {\n+        matches!(*self.kind, PatKind::Binding { subpattern: None, .. } | PatKind::Wild)\n     }\n+}\n \n+impl PatIdExt for PatId {\n     fn is_or_pat(self, cx: &MatchCheckCtx<'_>) -> bool {\n-        matches!(cx.pattern_arena.borrow()[self], Pat::Or(..))\n+        matches!(*cx.pattern_arena.borrow()[self].kind, PatKind::Or { .. })\n     }\n \n     /// Recursively expand this pattern into its subpatterns. Only useful for or-patterns.\n     fn expand_or_pat(self, cx: &MatchCheckCtx<'_>) -> Vec<Self> {\n-        fn expand(pat: PatId, vec: &mut Vec<PatId>, pat_arena: &PatternArena) {\n-            if let Pat::Or(pats) = &pat_arena[pat] {\n-                for &pat in pats {\n-                    expand(pat, vec, pat_arena);\n-                }\n+        fn expand(pat: PatId, vec: &mut Vec<PatId>, mut pat_arena: &mut PatternArena) {\n+            if let PatKind::Or { pats } = pat_arena[pat].kind.as_ref() {\n+                // for pat in pats {\n+                //     // TODO(iDawer): Ugh, I want to go back to references (PatId -> &Pat)\n+                //     let pat = pat_arena.alloc(pat.clone());\n+                //     expand(pat, vec, pat_arena);\n+                // }\n+                todo!()\n             } else {\n                 vec.push(pat)\n             }\n         }\n \n-        let pat_arena = cx.pattern_arena.borrow();\n+        let mut pat_arena = cx.pattern_arena.borrow_mut();\n         let mut pats = Vec::new();\n-        expand(self, &mut pats, &pat_arena);\n+        expand(self, &mut pats, &mut pat_arena);\n         pats\n     }\n }\n@@ -866,7 +874,8 @@ pub(crate) fn compute_match_usefulness(\n         })\n         .collect();\n \n-    let wild_pattern = cx.pattern_arena.borrow_mut().alloc(Pat::Wild, &cx.infer[cx.match_expr]);\n+    let wild_pattern =\n+        cx.pattern_arena.borrow_mut().alloc(Pat::wildcard_from_ty(&cx.infer[cx.match_expr]));\n     let v = PatStack::from_pattern(wild_pattern);\n     let usefulness = is_useful(cx, &matrix, &v, ConstructWitness, false, true);\n     let non_exhaustiveness_witnesses = match usefulness {\n@@ -876,39 +885,15 @@ pub(crate) fn compute_match_usefulness(\n     UsefulnessReport { arm_usefulness, non_exhaustiveness_witnesses }\n }\n \n-pub(crate) struct PatternArena {\n-    arena: Arena<Pat>,\n-    /// Types of expanded patterns.\n-    type_of_epat: FxHashMap<PatId, Ty>,\n-}\n-\n-impl PatternArena {\n-    pub(crate) fn clone_from(pats: &Arena<Pat>) -> RefCell<Self> {\n-        PatternArena { arena: pats.clone(), type_of_epat: Default::default() }.into()\n-    }\n-\n-    fn alloc(&mut self, pat: Pat, ty: &Ty) -> PatId {\n-        let id = self.arena.alloc(pat);\n-        self.type_of_epat.insert(id, ty.clone());\n-        id\n-    }\n-}\n-\n-impl Index<PatId> for PatternArena {\n-    type Output = Pat;\n-\n-    fn index(&self, pat: PatId) -> &Pat {\n-        &self.arena[pat]\n-    }\n-}\n+pub(crate) type PatternArena = Arena<Pat>;\n \n mod helper {\n     use hir_def::expr::{Pat, PatId};\n \n     use super::MatchCheckCtx;\n \n     pub(super) trait PatIdExt: Sized {\n-        fn is_wildcard(self, cx: &MatchCheckCtx<'_>) -> bool;\n+        // fn is_wildcard(self, cx: &MatchCheckCtx<'_>) -> bool;\n         fn is_or_pat(self, cx: &MatchCheckCtx<'_>) -> bool;\n         fn expand_or_pat(self, cx: &MatchCheckCtx<'_>) -> Vec<Self>;\n     }"}]}