{"sha": "f6cb45ad01a4518f615926f39801996622f46179", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2Y2I0NWFkMDFhNDUxOGY2MTU5MjZmMzk4MDE5OTY2MjJmNDYxNzk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-02T09:12:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-02-02T09:12:53Z"}, "message": "Auto merge of #79015 - WaffleLapkin:vec_append_from_within, r=KodrAus\n\nadd `Vec::extend_from_within` method under `vec_extend_from_within` feature gate\n\nImplement <https://github.com/rust-lang/rfcs/pull/2714>\n\n### tl;dr\n\nThis PR adds a `extend_from_within` method to `Vec` which allows copying elements from a range to the end:\n\n```rust\n#![feature(vec_extend_from_within)]\n\nlet mut vec = vec![0, 1, 2, 3, 4];\n\nvec.extend_from_within(2..);\nassert_eq!(vec, [0, 1, 2, 3, 4, 2, 3, 4]);\n\nvec.extend_from_within(..2);\nassert_eq!(vec, [0, 1, 2, 3, 4, 2, 3, 4, 0, 1]);\n\nvec.extend_from_within(4..8);\nassert_eq!(vec, [0, 1, 2, 3, 4, 2, 3, 4, 0, 1, 4, 2, 3, 4]);\n```\n\n### Implementation notes\n\nOriginally I've copied `@Shnatsel's` [implementation](https://github.com/WanzenBug/rle-decode-helper/blob/690742a0de158d391b7bde1a0c71cccfdad33ab3/src/lib.rs#L74) with some minor changes to support other ranges:\n```rust\npub fn append_from_within<R>(&mut self, src: R)\nwhere\n    T: Copy,\n    R: RangeBounds<usize>,\n{\n    let len = self.len();\n    let Range { start, end } = src.assert_len(len);;\n\n    let count = end - start;\n    self.reserve(count);\n    unsafe {\n        // This is safe because `reserve()` above succeeded,\n        // so `self.len() + count` did not overflow usize\n        ptr::copy_nonoverlapping(\n            self.get_unchecked(src.start),\n            self.as_mut_ptr().add(len),\n            count,\n        );\n        self.set_len(len + count);\n    }\n}\n```\n\nBut then I've realized that this duplicates most of the code from (private) `Vec::append_elements`, so I've used it instead.\n\nThen I've applied `@KodrAus` suggestions from https://github.com/rust-lang/rust/pull/79015#issuecomment-727200852.", "tree": {"sha": "8db918c838e9374f90bc236feee71305e5d01fb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8db918c838e9374f90bc236feee71305e5d01fb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6cb45ad01a4518f615926f39801996622f46179", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6cb45ad01a4518f615926f39801996622f46179", "html_url": "https://github.com/rust-lang/rust/commit/f6cb45ad01a4518f615926f39801996622f46179", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6cb45ad01a4518f615926f39801996622f46179/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d60b29d1ae8147538b8d542f7ffcc03b48e2cbda", "url": "https://api.github.com/repos/rust-lang/rust/commits/d60b29d1ae8147538b8d542f7ffcc03b48e2cbda", "html_url": "https://github.com/rust-lang/rust/commit/d60b29d1ae8147538b8d542f7ffcc03b48e2cbda"}, {"sha": "125ec782bd1f5929a72ff4a520daf316db4c1e7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/125ec782bd1f5929a72ff4a520daf316db4c1e7c", "html_url": "https://github.com/rust-lang/rust/commit/125ec782bd1f5929a72ff4a520daf316db4c1e7c"}], "stats": {"total": 185, "additions": 181, "deletions": 4}, "files": [{"sha": "0a1ecced49abc0c89898e02fb0bc26f54c715f7c", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6cb45ad01a4518f615926f39801996622f46179/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cb45ad01a4518f615926f39801996622f46179/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=f6cb45ad01a4518f615926f39801996622f46179", "patch": "@@ -76,6 +76,7 @@\n #![cfg_attr(test, feature(test))]\n #![cfg_attr(test, feature(new_uninit))]\n #![feature(allocator_api)]\n+#![feature(vec_extend_from_within)]\n #![feature(array_chunks)]\n #![feature(array_methods)]\n #![feature(array_windows)]"}, {"sha": "ede1601fa33cc82faa0746124bc9634d8cf7c4a8", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 109, "deletions": 4, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/f6cb45ad01a4518f615926f39801996622f46179/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cb45ad01a4518f615926f39801996622f46179/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=f6cb45ad01a4518f615926f39801996622f46179", "patch": "@@ -1825,11 +1825,27 @@ impl<T, A: Allocator> Vec<T, A> {\n     #[unstable(feature = \"vec_spare_capacity\", issue = \"75017\")]\n     #[inline]\n     pub fn spare_capacity_mut(&mut self) -> &mut [MaybeUninit<T>] {\n+        self.split_at_spare_mut().1\n+    }\n+\n+    #[inline]\n+    fn split_at_spare_mut(&mut self) -> (&mut [T], &mut [MaybeUninit<T>]) {\n+        let ptr = self.as_mut_ptr();\n+\n+        // Safety:\n+        // - `ptr` is guaranteed to be in bounds for `capacity` elements\n+        // - `len` is guaranteed to less or equal to `capacity`\n+        // - `MaybeUninit<T>` has the same layout as `T`\n+        let spare_ptr = unsafe { ptr.cast::<MaybeUninit<T>>().add(self.len) };\n+\n+        // Safety:\n+        // - `ptr` is guaranteed to be valid for `len` elements\n+        // - `spare_ptr` is offseted from `ptr` by `len`, so it doesn't overlap `initialized` slice\n         unsafe {\n-            slice::from_raw_parts_mut(\n-                self.as_mut_ptr().add(self.len) as *mut MaybeUninit<T>,\n-                self.buf.capacity() - self.len,\n-            )\n+            let initialized = slice::from_raw_parts_mut(ptr, self.len);\n+            let spare = slice::from_raw_parts_mut(spare_ptr, self.buf.capacity() - self.len);\n+\n+            (initialized, spare)\n         }\n     }\n }\n@@ -1891,6 +1907,39 @@ impl<T: Clone, A: Allocator> Vec<T, A> {\n     pub fn extend_from_slice(&mut self, other: &[T]) {\n         self.spec_extend(other.iter())\n     }\n+\n+    /// Copies elements from `src` range to the end of the vector.\n+    ///\n+    /// ## Examples\n+    ///\n+    /// ```\n+    /// #![feature(vec_extend_from_within)]\n+    ///\n+    /// let mut vec = vec![0, 1, 2, 3, 4];\n+    ///\n+    /// vec.extend_from_within(2..);\n+    /// assert_eq!(vec, [0, 1, 2, 3, 4, 2, 3, 4]);\n+    ///\n+    /// vec.extend_from_within(..2);\n+    /// assert_eq!(vec, [0, 1, 2, 3, 4, 2, 3, 4, 0, 1]);\n+    ///\n+    /// vec.extend_from_within(4..8);\n+    /// assert_eq!(vec, [0, 1, 2, 3, 4, 2, 3, 4, 0, 1, 4, 2, 3, 4]);\n+    /// ```\n+    #[unstable(feature = \"vec_extend_from_within\", issue = \"81656\")]\n+    pub fn extend_from_within<R>(&mut self, src: R)\n+    where\n+        R: RangeBounds<usize>,\n+    {\n+        let range = src.assert_len(self.len());\n+        self.reserve(range.len());\n+\n+        // SAFETY:\n+        // - `assert_len` guarantees  that the given range is valid for indexing self\n+        unsafe {\n+            self.spec_extend_from_within(range);\n+        }\n+    }\n }\n \n // This code generalizes `extend_with_{element,default}`.\n@@ -1998,6 +2047,62 @@ pub fn from_elem_in<T: Clone, A: Allocator>(elem: T, n: usize, alloc: A) -> Vec<\n     <T as SpecFromElem>::from_elem(elem, n, alloc)\n }\n \n+trait ExtendFromWithinSpec {\n+    /// Safety:\n+    /// - `src` needs to be valid index\n+    /// - `self.capacity() - self.len()` must be `>= src.len()`\n+    unsafe fn spec_extend_from_within(&mut self, src: Range<usize>);\n+}\n+\n+impl<T: Clone, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n+    default unsafe fn spec_extend_from_within(&mut self, src: Range<usize>) {\n+        let initialized = {\n+            let (this, spare) = self.split_at_spare_mut();\n+\n+            // Safety:\n+            // - caller guaratees that src is a valid index\n+            let to_clone = unsafe { this.get_unchecked(src) };\n+\n+            to_clone.iter().cloned().zip(spare.iter_mut()).map(|(e, s)| s.write(e)).count()\n+        };\n+\n+        // Safety:\n+        // - elements were just initialized\n+        unsafe {\n+            let new_len = self.len() + initialized;\n+            self.set_len(new_len);\n+        }\n+    }\n+}\n+\n+impl<T: Copy, A: Allocator> ExtendFromWithinSpec for Vec<T, A> {\n+    unsafe fn spec_extend_from_within(&mut self, src: Range<usize>) {\n+        let count = src.len();\n+        {\n+            let (init, spare) = self.split_at_spare_mut();\n+\n+            // Safety:\n+            // - caller guaratees that `src` is a valid index\n+            let source = unsafe { init.get_unchecked(src) };\n+\n+            // Safety:\n+            // - Both pointers are created from unique slice references (`&mut [_]`)\n+            //   so they are valid and do not overlap.\n+            // - Elements are :Copy so it's OK to to copy them, without doing\n+            //   anything with the original values\n+            // - `count` is equal to the len of `source`, so source is valid for\n+            //   `count` reads\n+            // - `.reserve(count)` guarantees that `spare.len() >= count` so spare\n+            //   is valid for `count` writes\n+            unsafe { ptr::copy_nonoverlapping(source.as_ptr(), spare.as_mut_ptr() as _, count) };\n+        }\n+\n+        // Safety:\n+        // - The elements were just initialized by `copy_nonoverlapping`\n+        self.len += count;\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Common trait implementations for Vec\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "9c7343e8cbf5ab714e8e732d84518a0f1cb38bed", "filename": "library/alloc/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6cb45ad01a4518f615926f39801996622f46179/library%2Falloc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cb45ad01a4518f615926f39801996622f46179/library%2Falloc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Flib.rs?ref=f6cb45ad01a4518f615926f39801996622f46179", "patch": "@@ -19,6 +19,7 @@\n #![feature(iter_map_while)]\n #![feature(vecdeque_binary_search)]\n #![feature(slice_group_by)]\n+#![feature(vec_extend_from_within)]\n \n use std::collections::hash_map::DefaultHasher;\n use std::hash::{Hash, Hasher};"}, {"sha": "5c7ff67bc621cf203719a79c915de3470d9014f7", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f6cb45ad01a4518f615926f39801996622f46179/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6cb45ad01a4518f615926f39801996622f46179/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=f6cb45ad01a4518f615926f39801996622f46179", "patch": "@@ -1954,3 +1954,73 @@ fn test_vec_swap() {\n     assert_eq!(a[0], 42);\n     assert_eq!(n, 0);\n }\n+\n+#[test]\n+fn test_extend_from_within_spec() {\n+    #[derive(Copy)]\n+    struct CopyOnly;\n+\n+    impl Clone for CopyOnly {\n+        fn clone(&self) -> Self {\n+            panic!(\"extend_from_within must use specialization on copy\");\n+        }\n+    }\n+\n+    vec![CopyOnly, CopyOnly].extend_from_within(..);\n+}\n+\n+#[test]\n+fn test_extend_from_within_clone() {\n+    let mut v = vec![String::from(\"sssss\"), String::from(\"12334567890\"), String::from(\"c\")];\n+    v.extend_from_within(1..);\n+\n+    assert_eq!(v, [\"sssss\", \"12334567890\", \"c\", \"12334567890\", \"c\"]);\n+}\n+\n+#[test]\n+fn test_extend_from_within_complete_rande() {\n+    let mut v = vec![0, 1, 2, 3];\n+    v.extend_from_within(..);\n+\n+    assert_eq!(v, [0, 1, 2, 3, 0, 1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_extend_from_within_empty_rande() {\n+    let mut v = vec![0, 1, 2, 3];\n+    v.extend_from_within(1..1);\n+\n+    assert_eq!(v, [0, 1, 2, 3]);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_extend_from_within_out_of_rande() {\n+    let mut v = vec![0, 1];\n+    v.extend_from_within(..3);\n+}\n+\n+#[test]\n+fn test_extend_from_within_zst() {\n+    let mut v = vec![(); 8];\n+    v.extend_from_within(3..7);\n+\n+    assert_eq!(v, [(); 12]);\n+}\n+\n+#[test]\n+fn test_extend_from_within_empty_vec() {\n+    let mut v = Vec::<i32>::new();\n+    v.extend_from_within(..);\n+\n+    assert_eq!(v, []);\n+}\n+\n+#[test]\n+fn test_extend_from_within() {\n+    let mut v = vec![String::from(\"a\"), String::from(\"b\"), String::from(\"c\")];\n+    v.extend_from_within(1..=2);\n+    v.extend_from_within(..=1);\n+\n+    assert_eq!(v, [\"a\", \"b\", \"c\", \"b\", \"c\", \"a\", \"b\"]);\n+}"}]}