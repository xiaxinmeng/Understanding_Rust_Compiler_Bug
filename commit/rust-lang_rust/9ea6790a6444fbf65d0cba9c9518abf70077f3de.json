{"sha": "9ea6790a6444fbf65d0cba9c9518abf70077f3de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllYTY3OTBhNjQ0NGZiZjY1ZDBjYmE5Yzk1MThhYmY3MDA3N2YzZGU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-03-29T02:58:45Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-03-29T02:58:45Z"}, "message": "Deduplicate parse recovery code", "tree": {"sha": "09cd3326892317af525123875fe84f77b6065201", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09cd3326892317af525123875fe84f77b6065201"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9ea6790a6444fbf65d0cba9c9518abf70077f3de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9ea6790a6444fbf65d0cba9c9518abf70077f3de", "html_url": "https://github.com/rust-lang/rust/commit/9ea6790a6444fbf65d0cba9c9518abf70077f3de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9ea6790a6444fbf65d0cba9c9518abf70077f3de/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7dc8e71ccb15ff54b9cdf0f67776cc3cf4bea33", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7dc8e71ccb15ff54b9cdf0f67776cc3cf4bea33", "html_url": "https://github.com/rust-lang/rust/commit/b7dc8e71ccb15ff54b9cdf0f67776cc3cf4bea33"}], "stats": {"total": 78, "additions": 43, "deletions": 35}, "files": [{"sha": "d4b8c7ce15941484c52574671015cbd1d30fd4d2", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/9ea6790a6444fbf65d0cba9c9518abf70077f3de/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9ea6790a6444fbf65d0cba9c9518abf70077f3de/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9ea6790a6444fbf65d0cba9c9518abf70077f3de", "patch": "@@ -2639,11 +2639,9 @@ impl<'a> Parser<'a> {\n                 while self.token != token::CloseDelim(token::Paren) {\n                     es.push(match self.parse_expr() {\n                         Ok(es) => es,\n-                        Err(mut err) => {  // recover from parse error in tuple list\n-                            err.emit();\n-                            self.consume_block(token::Paren);\n-                            hi = self.prev_span;\n-                            return Ok(self.mk_expr(lo.to(hi), ExprKind::Err, ThinVec::new()));\n+                        Err(err) => {\n+                            // recover from parse error in tuple list\n+                            return Ok(self.recover_seq_parse_error(token::Paren, lo, Err(err)));\n                         }\n                     });\n                     recovered = self.expect_one_of(\n@@ -3254,44 +3252,54 @@ impl<'a> Parser<'a> {\n             }\n             if self.expr_is_complete(&e) { break; }\n             match self.token {\n-              // expr(...)\n-              token::OpenDelim(token::Paren) => {\n-                match self.parse_unspanned_seq(\n-                    &token::OpenDelim(token::Paren),\n-                    &token::CloseDelim(token::Paren),\n-                    SeqSep::trailing_allowed(token::Comma),\n-                    |p| Ok(p.parse_expr()?)\n-                ) {\n-                    Ok(es) => {\n+                // expr(...)\n+                token::OpenDelim(token::Paren) => {\n+                    let seq = self.parse_unspanned_seq(\n+                        &token::OpenDelim(token::Paren),\n+                        &token::CloseDelim(token::Paren),\n+                        SeqSep::trailing_allowed(token::Comma),\n+                        |p| Ok(p.parse_expr()?)\n+                    ).map(|es| {\n                         let nd = self.mk_call(e, es);\n-                        hi = self.prev_span;\n-                        e = self.mk_expr(lo.to(hi), nd, ThinVec::new());\n-                    }\n-                    Err(mut err) => { // recover from parse error in argument list\n-                        err.emit();\n-                        self.consume_block(token::Paren);\n-                        hi = self.prev_span;\n-                        e = self.mk_expr(lo.to(hi), ExprKind::Err, ThinVec::new());\n-                    }\n+                        let hi = self.prev_span;\n+                        self.mk_expr(lo.to(hi), nd, ThinVec::new())\n+                    });\n+                    e = self.recover_seq_parse_error(token::Paren, lo, seq);\n                 }\n-              }\n \n-              // expr[...]\n-              // Could be either an index expression or a slicing expression.\n-              token::OpenDelim(token::Bracket) => {\n-                self.bump();\n-                let ix = self.parse_expr()?;\n-                hi = self.span;\n-                self.expect(&token::CloseDelim(token::Bracket))?;\n-                let index = self.mk_index(e, ix);\n-                e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n-              }\n-              _ => return Ok(e)\n+                // expr[...]\n+                // Could be either an index expression or a slicing expression.\n+                token::OpenDelim(token::Bracket) => {\n+                    self.bump();\n+                    let ix = self.parse_expr()?;\n+                    hi = self.span;\n+                    self.expect(&token::CloseDelim(token::Bracket))?;\n+                    let index = self.mk_index(e, ix);\n+                    e = self.mk_expr(lo.to(hi), index, ThinVec::new())\n+                }\n+                _ => return Ok(e)\n             }\n         }\n         return Ok(e);\n     }\n \n+    fn recover_seq_parse_error(\n+        &mut self,\n+        delim: token::DelimToken,\n+        lo: Span,\n+        result: PResult<'a, P<Expr>>,\n+    ) -> P<Expr> {\n+        match result {\n+            Ok(x) => x,\n+            Err(mut err) => {\n+                err.emit();\n+                // recover from parse error\n+                self.consume_block(delim);\n+                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, ThinVec::new())\n+            }\n+        }\n+    }\n+\n     crate fn process_potential_macro_variable(&mut self) {\n         let (token, span) = match self.token {\n             token::Dollar if self.span.ctxt() != syntax_pos::hygiene::SyntaxContext::empty() &&"}]}