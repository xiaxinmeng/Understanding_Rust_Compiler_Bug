{"sha": "5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjMjRiZmE4YzNmYWVmN2JjMjgwNDdjYjIzM2U5MTRkZmU1ZWVlMGQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-20T01:11:40Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-20T01:11:40Z"}, "message": "auto merge of #11057 : alexcrichton/rust/no-at-in-ebml, r=pcwalton\n\nNow that the metadata is an owned value with a lifetime of a borrowed byte\r\nslice, it's possible to have future optimizations where the metadata doesn't\r\nneed to be copied around (very expensive operation).", "tree": {"sha": "b37e2095416bf4ecf515c242e388a3339451508f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b37e2095416bf4ecf515c242e388a3339451508f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "html_url": "https://github.com/rust-lang/rust/commit/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d069d58e313d476a490dae351213536901e58265", "url": "https://api.github.com/repos/rust-lang/rust/commits/d069d58e313d476a490dae351213536901e58265", "html_url": "https://github.com/rust-lang/rust/commit/d069d58e313d476a490dae351213536901e58265"}, {"sha": "73fceca7d6140fb208fa701074c4b25a4dd260c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/73fceca7d6140fb208fa701074c4b25a4dd260c6", "html_url": "https://github.com/rust-lang/rust/commit/73fceca7d6140fb208fa701074c4b25a4dd260c6"}], "stats": {"total": 338, "additions": 182, "deletions": 156}, "files": [{"sha": "16a43276401142455ae062543bc49ad68b80f7ab", "filename": "src/libextra/ebml.rs", "status": "modified", "additions": 51, "deletions": 53, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibextra%2Febml.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibextra%2Febml.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Febml.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -18,14 +18,14 @@ use std::str;\n \n // Common data structures\n #[deriving(Clone)]\n-pub struct Doc {\n-    data: @~[u8],\n+pub struct Doc<'a> {\n+    data: &'a [u8],\n     start: uint,\n     end: uint,\n }\n \n-impl Doc {\n-    pub fn get(&self, tag: uint) -> Doc {\n+impl<'doc> Doc<'doc> {\n+    pub fn get<'a>(&'a self, tag: uint) -> Doc<'a> {\n         reader::get_doc(*self, tag)\n     }\n \n@@ -38,9 +38,9 @@ impl Doc {\n     }\n }\n \n-pub struct TaggedDoc {\n+pub struct TaggedDoc<'a> {\n     priv tag: uint,\n-    doc: Doc,\n+    doc: Doc<'a>,\n }\n \n pub enum EbmlEncoderTag {\n@@ -167,25 +167,25 @@ pub mod reader {\n         vuint_at_slow(data, start)\n     }\n \n-    pub fn Doc(data: @~[u8]) -> Doc {\n+    pub fn Doc<'a>(data: &'a [u8]) -> Doc<'a> {\n         Doc { data: data, start: 0u, end: data.len() }\n     }\n \n-    pub fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n-        let elt_tag = vuint_at(*data, start);\n-        let elt_size = vuint_at(*data, elt_tag.next);\n+    pub fn doc_at<'a>(data: &'a [u8], start: uint) -> TaggedDoc<'a> {\n+        let elt_tag = vuint_at(data, start);\n+        let elt_size = vuint_at(data, elt_tag.next);\n         let end = elt_size.next + elt_size.val;\n         TaggedDoc {\n             tag: elt_tag.val,\n             doc: Doc { data: data, start: elt_size.next, end: end }\n         }\n     }\n \n-    pub fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n+    pub fn maybe_get_doc<'a>(d: Doc<'a>, tg: uint) -> Option<Doc<'a>> {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            let elt_tag = vuint_at(d.data, pos);\n+            let elt_size = vuint_at(d.data, elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 return Some(Doc { data: d.data, start: elt_size.next,\n@@ -195,7 +195,7 @@ pub mod reader {\n         None\n     }\n \n-    pub fn get_doc(d: Doc, tg: uint) -> Doc {\n+    pub fn get_doc<'a>(d: Doc<'a>, tg: uint) -> Doc<'a> {\n         match maybe_get_doc(d, tg) {\n             Some(d) => d,\n             None => {\n@@ -205,11 +205,11 @@ pub mod reader {\n         }\n     }\n \n-    pub fn docs(d: Doc, it: |uint, Doc| -> bool) -> bool {\n+    pub fn docs<'a>(d: Doc<'a>, it: |uint, Doc<'a>| -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            let elt_tag = vuint_at(d.data, pos);\n+            let elt_size = vuint_at(d.data, elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n             if !it(elt_tag.val, doc) {\n@@ -219,11 +219,11 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn tagged_docs(d: Doc, tg: uint, it: |Doc| -> bool) -> bool {\n+    pub fn tagged_docs<'a>(d: Doc<'a>, tg: uint, it: |Doc<'a>| -> bool) -> bool {\n         let mut pos = d.start;\n         while pos < d.end {\n-            let elt_tag = vuint_at(*d.data, pos);\n-            let elt_size = vuint_at(*d.data, elt_tag.next);\n+            let elt_tag = vuint_at(d.data, pos);\n+            let elt_size = vuint_at(d.data, elt_tag.next);\n             pos = elt_size.next + elt_size.val;\n             if elt_tag.val == tg {\n                 let doc = Doc { data: d.data, start: elt_size.next,\n@@ -236,49 +236,49 @@ pub mod reader {\n         return true;\n     }\n \n-    pub fn with_doc_data<T>(d: Doc, f: |x: &[u8]| -> T) -> T {\n+    pub fn with_doc_data<'a, T>(d: Doc<'a>, f: |x: &'a [u8]| -> T) -> T {\n         f(d.data.slice(d.start, d.end))\n     }\n \n \n     pub fn doc_as_u8(d: Doc) -> u8 {\n         assert_eq!(d.end, d.start + 1u);\n-        (*d.data)[d.start]\n+        d.data[d.start]\n     }\n \n     pub fn doc_as_u16(d: Doc) -> u16 {\n         assert_eq!(d.end, d.start + 2u);\n-        u64_from_be_bytes(*d.data, d.start, 2u) as u16\n+        u64_from_be_bytes(d.data, d.start, 2u) as u16\n     }\n \n     pub fn doc_as_u32(d: Doc) -> u32 {\n         assert_eq!(d.end, d.start + 4u);\n-        u64_from_be_bytes(*d.data, d.start, 4u) as u32\n+        u64_from_be_bytes(d.data, d.start, 4u) as u32\n     }\n \n     pub fn doc_as_u64(d: Doc) -> u64 {\n         assert_eq!(d.end, d.start + 8u);\n-        u64_from_be_bytes(*d.data, d.start, 8u)\n+        u64_from_be_bytes(d.data, d.start, 8u)\n     }\n \n     pub fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n     pub fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n     pub fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n     pub fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n \n-    pub struct Decoder {\n-        priv parent: Doc,\n+    pub struct Decoder<'a> {\n+        priv parent: Doc<'a>,\n         priv pos: uint,\n     }\n \n-    pub fn Decoder(d: Doc) -> Decoder {\n+    pub fn Decoder<'a>(d: Doc<'a>) -> Decoder<'a> {\n         Decoder {\n             parent: d,\n             pos: d.start\n         }\n     }\n \n-    impl Decoder {\n+    impl<'doc> Decoder<'doc> {\n         fn _check_label(&mut self, lbl: &str) {\n             if self.pos < self.parent.end {\n                 let TaggedDoc { tag: r_tag, doc: r_doc } =\n@@ -294,7 +294,7 @@ pub mod reader {\n             }\n         }\n \n-        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc {\n+        fn next_doc(&mut self, exp_tag: EbmlEncoderTag) -> Doc<'doc> {\n             debug!(\". next_doc(exp_tag={:?})\", exp_tag);\n             if self.pos >= self.parent.end {\n                 fail!(\"no more documents in current node!\");\n@@ -321,7 +321,7 @@ pub mod reader {\n         }\n \n         fn push_doc<T>(&mut self, exp_tag: EbmlEncoderTag,\n-                       f: |&mut Decoder| -> T) -> T {\n+                       f: |&mut Decoder<'doc>| -> T) -> T {\n             let d = self.next_doc(exp_tag);\n             let old_parent = self.parent;\n             let old_pos = self.pos;\n@@ -338,10 +338,8 @@ pub mod reader {\n             debug!(\"_next_uint exp_tag={:?} result={}\", exp_tag, r);\n             r as uint\n         }\n-    }\n \n-    impl Decoder {\n-        pub fn read_opaque<R>(&mut self, op: |&mut Decoder, Doc| -> R) -> R {\n+        pub fn read_opaque<R>(&mut self, op: |&mut Decoder<'doc>, Doc| -> R) -> R {\n             let doc = self.next_doc(EsOpaque);\n \n             let (old_parent, old_pos) = (self.parent, self.pos);\n@@ -356,7 +354,7 @@ pub mod reader {\n         }\n     }\n \n-    impl serialize::Decoder for Decoder {\n+    impl<'doc> serialize::Decoder for Decoder<'doc> {\n         fn read_nil(&mut self) -> () { () }\n \n         fn read_u64(&mut self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n@@ -412,7 +410,7 @@ pub mod reader {\n         }\n \n         // Compound types:\n-        fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder| -> T) -> T {\n+        fn read_enum<T>(&mut self, name: &str, f: |&mut Decoder<'doc>| -> T) -> T {\n             debug!(\"read_enum({})\", name);\n             self._check_label(name);\n \n@@ -431,7 +429,7 @@ pub mod reader {\n \n         fn read_enum_variant<T>(&mut self,\n                                 _: &[&str],\n-                                f: |&mut Decoder, uint| -> T)\n+                                f: |&mut Decoder<'doc>, uint| -> T)\n                                 -> T {\n             debug!(\"read_enum_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n@@ -452,14 +450,14 @@ pub mod reader {\n \n         fn read_enum_variant_arg<T>(&mut self,\n                                     idx: uint,\n-                                    f: |&mut Decoder| -> T) -> T {\n+                                    f: |&mut Decoder<'doc>| -> T) -> T {\n             debug!(\"read_enum_variant_arg(idx={})\", idx);\n             f(self)\n         }\n \n         fn read_enum_struct_variant<T>(&mut self,\n                                        _: &[&str],\n-                                       f: |&mut Decoder, uint| -> T)\n+                                       f: |&mut Decoder<'doc>, uint| -> T)\n                                        -> T {\n             debug!(\"read_enum_struct_variant()\");\n             let idx = self._next_uint(EsEnumVid);\n@@ -481,7 +479,7 @@ pub mod reader {\n         fn read_enum_struct_variant_field<T>(&mut self,\n                                              name: &str,\n                                              idx: uint,\n-                                             f: |&mut Decoder| -> T)\n+                                             f: |&mut Decoder<'doc>| -> T)\n                                              -> T {\n             debug!(\"read_enum_struct_variant_arg(name={}, idx={})\", name, idx);\n             f(self)\n@@ -490,7 +488,7 @@ pub mod reader {\n         fn read_struct<T>(&mut self,\n                           name: &str,\n                           _: uint,\n-                          f: |&mut Decoder| -> T)\n+                          f: |&mut Decoder<'doc>| -> T)\n                           -> T {\n             debug!(\"read_struct(name={})\", name);\n             f(self)\n@@ -499,41 +497,41 @@ pub mod reader {\n         fn read_struct_field<T>(&mut self,\n                                 name: &str,\n                                 idx: uint,\n-                                f: |&mut Decoder| -> T)\n+                                f: |&mut Decoder<'doc>| -> T)\n                                 -> T {\n             debug!(\"read_struct_field(name={}, idx={})\", name, idx);\n             self._check_label(name);\n             f(self)\n         }\n \n-        fn read_tuple<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n+        fn read_tuple<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n             debug!(\"read_tuple()\");\n             self.read_seq(f)\n         }\n \n-        fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n+        fn read_tuple_arg<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n                              -> T {\n             debug!(\"read_tuple_arg(idx={})\", idx);\n             self.read_seq_elt(idx, f)\n         }\n \n         fn read_tuple_struct<T>(&mut self,\n                                 name: &str,\n-                                f: |&mut Decoder, uint| -> T)\n+                                f: |&mut Decoder<'doc>, uint| -> T)\n                                 -> T {\n             debug!(\"read_tuple_struct(name={})\", name);\n             self.read_tuple(f)\n         }\n \n         fn read_tuple_struct_arg<T>(&mut self,\n                                     idx: uint,\n-                                    f: |&mut Decoder| -> T)\n+                                    f: |&mut Decoder<'doc>| -> T)\n                                     -> T {\n             debug!(\"read_tuple_struct_arg(idx={})\", idx);\n             self.read_tuple_arg(idx, f)\n         }\n \n-        fn read_option<T>(&mut self, f: |&mut Decoder, bool| -> T) -> T {\n+        fn read_option<T>(&mut self, f: |&mut Decoder<'doc>, bool| -> T) -> T {\n             debug!(\"read_option()\");\n             self.read_enum(\"Option\", |this| {\n                 this.read_enum_variant([\"None\", \"Some\"], |this, idx| {\n@@ -546,7 +544,7 @@ pub mod reader {\n             })\n         }\n \n-        fn read_seq<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n+        fn read_seq<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n             debug!(\"read_seq()\");\n             self.push_doc(EsVec, |d| {\n                 let len = d._next_uint(EsVecLen);\n@@ -555,13 +553,13 @@ pub mod reader {\n             })\n         }\n \n-        fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n+        fn read_seq_elt<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n                            -> T {\n             debug!(\"read_seq_elt(idx={})\", idx);\n             self.push_doc(EsVecElt, f)\n         }\n \n-        fn read_map<T>(&mut self, f: |&mut Decoder, uint| -> T) -> T {\n+        fn read_map<T>(&mut self, f: |&mut Decoder<'doc>, uint| -> T) -> T {\n             debug!(\"read_map()\");\n             self.push_doc(EsMap, |d| {\n                 let len = d._next_uint(EsMapLen);\n@@ -570,13 +568,13 @@ pub mod reader {\n             })\n         }\n \n-        fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n+        fn read_map_elt_key<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n                                -> T {\n             debug!(\"read_map_elt_key(idx={})\", idx);\n             self.push_doc(EsMapKey, f)\n         }\n \n-        fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder| -> T)\n+        fn read_map_elt_val<T>(&mut self, idx: uint, f: |&mut Decoder<'doc>| -> T)\n                                -> T {\n             debug!(\"read_map_elt_val(idx={})\", idx);\n             self.push_doc(EsMapVal, f)\n@@ -953,7 +951,7 @@ mod tests {\n             let wr = @mut MemWriter::new();\n             let mut ebml_w = writer::Encoder(wr);\n             v.encode(&mut ebml_w);\n-            let ebml_doc = reader::Doc(@wr.inner_ref().to_owned());\n+            let ebml_doc = reader::Doc(*wr.inner_ref());\n             let mut deser = reader::Decoder(ebml_doc);\n             let v1 = serialize::Decodable::decode(&mut deser);\n             debug!(\"v1 == {:?}\", v1);"}, {"sha": "9e48c3e7a73ed7207415d77a44be9632d011f535", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -792,7 +792,7 @@ mod test {\n         let u = Uuid::new_v4();\n         let wr = @mut MemWriter::new();\n         u.encode(&mut ebml::writer::Encoder(wr));\n-        let doc = ebml::reader::Doc(@wr.inner_ref().to_owned());\n+        let doc = ebml::reader::Doc(wr.inner_ref().as_slice());\n         let u2 = Decodable::decode(&mut ebml::reader::Decoder(doc));\n         assert_eq!(u, u2);\n     }"}, {"sha": "4741281e6c28b1863b196f5c2b727191d80927cf", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -267,9 +267,9 @@ fn resolve_crate(e: @mut Env,\n             dylib, rlib, metadata\n         } = load_ctxt.load_library_crate();\n \n-        let attrs = decoder::get_crate_attributes(metadata);\n+        let attrs = decoder::get_crate_attributes(metadata.as_slice());\n         let pkgid = attr::find_pkgid(attrs).unwrap();\n-        let hash = decoder::get_crate_hash(metadata);\n+        let hash = decoder::get_crate_hash(metadata.as_slice());\n \n         // Claim this crate number and cache it\n         let cnum = e.next_crate_num;\n@@ -282,7 +282,7 @@ fn resolve_crate(e: @mut Env,\n         e.next_crate_num += 1;\n \n         // Now resolve the crates referenced by this crate\n-        let cnum_map = resolve_crate_deps(e, metadata);\n+        let cnum_map = resolve_crate_deps(e, metadata.as_slice());\n \n         let cmeta = @cstore::crate_metadata {\n             name: name,\n@@ -307,7 +307,7 @@ fn resolve_crate(e: @mut Env,\n }\n \n // Go through the crate metadata and load any crates that it references\n-fn resolve_crate_deps(e: @mut Env, cdata: @~[u8]) -> cstore::cnum_map {\n+fn resolve_crate_deps(e: @mut Env, cdata: &[u8]) -> cstore::cnum_map {\n     debug!(\"resolving deps of external crate\");\n     // The map from crate numbers in the crate we're resolving to local crate\n     // numbers"}, {"sha": "3a63a6fa201436278f8057ebca46b253210dd901", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -31,13 +31,13 @@ pub struct StaticMethodInfo {\n }\n \n pub fn get_symbol(cstore: @mut cstore::CStore, def: ast::DefId) -> ~str {\n-    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n+    let cdata = cstore::get_crate_data(cstore, def.crate).data();\n     return decoder::get_symbol(cdata, def.node);\n }\n \n pub fn get_type_param_count(cstore: @mut cstore::CStore, def: ast::DefId)\n                          -> uint {\n-    let cdata = cstore::get_crate_data(cstore, def.crate).data;\n+    let cdata = cstore::get_crate_data(cstore, def.crate).data();\n     return decoder::get_type_param_count(cdata, def.node);\n }\n \n@@ -210,7 +210,7 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n     let cdata = cstore::get_crate_data(cstore, class_id.crate);\n-    let all_items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n+    let all_items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n     debug!(\"Looking up {:?}\", class_id);\n     let class_doc = expect(tcx.diag,\n                            decoder::maybe_find_item(class_id.node, all_items),"}, {"sha": "e236c4e38e6bae04c4318785cb7001292a98d9b7", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -27,9 +27,13 @@ use syntax::parse::token::ident_interner;\n // own crate numbers.\n pub type cnum_map = @mut HashMap<ast::CrateNum, ast::CrateNum>;\n \n+pub enum MetadataBlob {\n+    MetadataVec(~[u8]),\n+}\n+\n pub struct crate_metadata {\n     name: @str,\n-    data: @~[u8],\n+    data: MetadataBlob,\n     cnum_map: cnum_map,\n     cnum: ast::CrateNum\n }\n@@ -86,12 +90,12 @@ pub fn get_crate_data(cstore: &CStore, cnum: ast::CrateNum)\n \n pub fn get_crate_hash(cstore: &CStore, cnum: ast::CrateNum) -> @str {\n     let cdata = get_crate_data(cstore, cnum);\n-    decoder::get_crate_hash(cdata.data)\n+    decoder::get_crate_hash(cdata.data())\n }\n \n pub fn get_crate_vers(cstore: &CStore, cnum: ast::CrateNum) -> @str {\n     let cdata = get_crate_data(cstore, cnum);\n-    decoder::get_crate_vers(cdata.data)\n+    decoder::get_crate_vers(cdata.data())\n }\n \n pub fn set_crate_data(cstore: &mut CStore,\n@@ -182,8 +186,8 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n \n     for (_, &cnum) in cstore.extern_mod_crate_map.iter() {\n         let cdata = cstore::get_crate_data(cstore, cnum);\n-        let hash = decoder::get_crate_hash(cdata.data);\n-        let vers = decoder::get_crate_vers(cdata.data);\n+        let hash = decoder::get_crate_hash(cdata.data());\n+        let vers = decoder::get_crate_vers(cdata.data());\n         debug!(\"Add hash[{}]: {} {}\", cdata.name, vers, hash);\n         result.push(crate_hash {\n             name: cdata.name,\n@@ -203,3 +207,15 @@ pub fn get_dep_hashes(cstore: &CStore) -> ~[@str] {\n \n     sorted.map(|ch| ch.hash)\n }\n+\n+impl crate_metadata {\n+    pub fn data<'a>(&'a self) -> &'a [u8] { self.data.as_slice() }\n+}\n+\n+impl MetadataBlob {\n+    pub fn as_slice<'a>(&'a self) -> &'a [u8] {\n+        match *self {\n+            MetadataVec(ref vec) => vec.as_slice(),\n+        }\n+    }\n+}"}, {"sha": "e21a41d9ba25c2ac79666957ccf469041d45e97b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 60, "deletions": 58, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -50,19 +50,19 @@ type Cmd = @crate_metadata;\n // what crate that's in and give us a def_id that makes sense for the current\n // build.\n \n-fn lookup_hash(d: ebml::Doc, eq_fn: |&[u8]| -> bool, hash: u64) ->\n-   Option<ebml::Doc> {\n+fn lookup_hash<'a>(d: ebml::Doc<'a>, eq_fn: |&[u8]| -> bool,\n+                   hash: u64) -> Option<ebml::Doc<'a>> {\n     let index = reader::get_doc(d, tag_index);\n     let table = reader::get_doc(index, tag_index_table);\n     let hash_pos = table.start + (hash % 256 * 4) as uint;\n-    let pos = u64_from_be_bytes(*d.data, hash_pos, 4) as uint;\n+    let pos = u64_from_be_bytes(d.data, hash_pos, 4) as uint;\n     let tagged_doc = reader::doc_at(d.data, pos);\n \n     let belt = tag_index_buckets_bucket_elt;\n \n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n-        let pos = u64_from_be_bytes(*elt.data, elt.start, 4) as uint;\n+        let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n         if eq_fn(elt.data.slice(elt.start + 4, elt.end)) {\n             ret = Some(reader::doc_at(d.data, pos).doc);\n             false\n@@ -75,7 +75,8 @@ fn lookup_hash(d: ebml::Doc, eq_fn: |&[u8]| -> bool, hash: u64) ->\n \n pub type GetCrateDataCb<'a> = 'a |ast::CrateNum| -> Cmd;\n \n-pub fn maybe_find_item(item_id: ast::NodeId, items: ebml::Doc) -> Option<ebml::Doc> {\n+pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n+                           items: ebml::Doc<'a>) -> Option<ebml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n             bytes.slice(0u, 4u), 0u, 4u) as ast::NodeId\n@@ -86,7 +87,7 @@ pub fn maybe_find_item(item_id: ast::NodeId, items: ebml::Doc) -> Option<ebml::D\n                 (item_id as i64).hash())\n }\n \n-fn find_item(item_id: ast::NodeId, items: ebml::Doc) -> ebml::Doc {\n+fn find_item<'a>(item_id: ast::NodeId, items: ebml::Doc<'a>) -> ebml::Doc<'a> {\n     match maybe_find_item(item_id, items) {\n        None => fail!(\"lookup_item: id not found: {}\", item_id),\n        Some(d) => d\n@@ -95,7 +96,7 @@ fn find_item(item_id: ast::NodeId, items: ebml::Doc) -> ebml::Doc {\n \n // Looks up an item in the given metadata and returns an ebml doc pointing\n // to the item data.\n-pub fn lookup_item(item_id: ast::NodeId, data: @~[u8]) -> ebml::Doc {\n+pub fn lookup_item<'a>(item_id: ast::NodeId, data: &'a [u8]) -> ebml::Doc<'a> {\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     find_item(item_id, items)\n }\n@@ -216,13 +217,13 @@ fn variant_disr_val(d: ebml::Doc) -> Option<ty::Disr> {\n \n fn doc_type(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::t {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n-    parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n+    parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                   |_, did| translate_def_id(cdata, did))\n }\n \n fn doc_method_fty(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::BareFnTy {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n-    parse_bare_fn_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n+    parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                           |_, did| translate_def_id(cdata, did))\n }\n \n@@ -231,7 +232,7 @@ fn doc_transformed_self_ty(doc: ebml::Doc,\n                            cdata: Cmd) -> Option<ty::t>\n {\n     reader::maybe_get_doc(doc, tag_item_method_transformed_self_ty).map(|tp| {\n-        parse_ty_data(*tp.data, cdata.cnum, tp.start, tcx,\n+        parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n                       |_, did| translate_def_id(cdata, did))\n     })\n }\n@@ -242,7 +243,7 @@ pub fn item_type(_item_id: ast::DefId, item: ebml::Doc,\n }\n \n fn doc_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n-    parse_trait_ref_data(*doc.data, cdata.cnum, doc.start, tcx,\n+    parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n                          |_, did| translate_def_id(cdata, did))\n }\n \n@@ -259,7 +260,7 @@ fn item_ty_param_defs(item: ebml::Doc,\n     let mut bounds = ~[];\n     reader::tagged_docs(item, tag, |p| {\n         let bd = parse_type_param_def_data(\n-            *p.data, p.start, cdata.cnum, tcx,\n+            p.data, p.start, cdata.cnum, tcx,\n             |_, did| translate_def_id(cdata, did));\n         bounds.push(bd);\n         true\n@@ -392,7 +393,7 @@ pub fn item_to_def_like(item: ebml::Doc, did: ast::DefId, cnum: ast::CrateNum)\n     }\n }\n \n-pub fn lookup_def(cnum: ast::CrateNum, data: @~[u8], did_: ast::DefId) ->\n+pub fn lookup_def(cnum: ast::CrateNum, data: &[u8], did_: ast::DefId) ->\n    ast::Def {\n     let item = lookup_item(did_.node, data);\n     let did = ast::DefId { crate: cnum, node: did_.node };\n@@ -404,7 +405,7 @@ pub fn get_trait_def(cdata: Cmd,\n                      item_id: ast::NodeId,\n                      tcx: ty::ctxt) -> ty::TraitDef\n {\n-    let item_doc = lookup_item(item_id, cdata.data);\n+    let item_doc = lookup_item(item_id, cdata.data());\n     let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n                                      tag_items_data_item_ty_param_bounds);\n     let rp_defs = item_region_param_defs(item_doc, tcx, cdata);\n@@ -430,7 +431,7 @@ pub fn get_trait_def(cdata: Cmd,\n pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n-    let item = lookup_item(id, cdata.data);\n+    let item = lookup_item(id, cdata.data());\n \n     let t = item_type(ast::DefId { crate: cdata.cnum, node: id }, item, tcx,\n                       cdata);\n@@ -445,15 +446,15 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n     }\n }\n \n-pub fn get_type_param_count(data: @~[u8], id: ast::NodeId) -> uint {\n+pub fn get_type_param_count(data: &[u8], id: ast::NodeId) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n pub fn get_impl_trait(cdata: Cmd,\n                       id: ast::NodeId,\n                       tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n-    let item_doc = lookup_item(id, cdata.data);\n+    let item_doc = lookup_item(id, cdata.data());\n     reader::maybe_get_doc(item_doc, tag_item_trait_ref).map(|tp| {\n         @doc_trait_ref(tp, tcx, cdata)\n     })\n@@ -463,7 +464,7 @@ pub fn get_impl_vtables(cdata: Cmd,\n                         id: ast::NodeId,\n                         tcx: ty::ctxt) -> typeck::impl_res\n {\n-    let item_doc = lookup_item(id, cdata.data);\n+    let item_doc = lookup_item(id, cdata.data());\n     let vtables_doc = reader::get_doc(item_doc, tag_item_impl_vtables);\n     let mut decoder = reader::Decoder(vtables_doc);\n \n@@ -476,7 +477,7 @@ pub fn get_impl_vtables(cdata: Cmd,\n \n pub fn get_impl_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n                        name: ast::Ident) -> Option<ast::DefId> {\n-    let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n+    let items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n     let mut found = None;\n     reader::tagged_docs(find_item(id, items), tag_item_impl_method, |mid| {\n         let m_did = reader::with_doc_data(mid, parse_def_id);\n@@ -488,7 +489,7 @@ pub fn get_impl_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n     found\n }\n \n-pub fn get_symbol(data: @~[u8], id: ast::NodeId) -> ~str {\n+pub fn get_symbol(data: &[u8], id: ast::NodeId) -> ~str {\n     return item_symbol(lookup_item(id, data));\n }\n \n@@ -509,7 +510,7 @@ pub fn def_like_to_def(def_like: DefLike) -> ast::Def {\n \n /// Iterates over the language items in the given crate.\n pub fn each_lang_item(cdata: Cmd, f: |ast::NodeId, uint| -> bool) -> bool {\n-    let root = reader::Doc(cdata.data);\n+    let root = reader::Doc(cdata.data());\n     let lang_items = reader::get_doc(root, tag_lang_items);\n     reader::tagged_docs(lang_items, tag_lang_items_item, |item_doc| {\n         let id_doc = reader::get_doc(item_doc, tag_lang_items_item_id);\n@@ -538,10 +539,10 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n         // This item may be in yet another crate if it was the child of a\n         // reexport.\n         let other_crates_items = if child_def_id.crate == cdata.cnum {\n-            reader::get_doc(reader::Doc(cdata.data), tag_items)\n+            reader::get_doc(reader::Doc(cdata.data()), tag_items)\n         } else {\n             let crate_data = get_crate_data(child_def_id.crate);\n-            reader::get_doc(reader::Doc(crate_data.data), tag_items)\n+            reader::get_doc(reader::Doc(crate_data.data()), tag_items)\n         };\n \n         // Get the item.\n@@ -570,7 +571,7 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n                                 |inherent_impl_def_id_doc| {\n         let inherent_impl_def_id = item_def_id(inherent_impl_def_id_doc,\n                                                cdata);\n-        let items = reader::get_doc(reader::Doc(cdata.data), tag_items);\n+        let items = reader::get_doc(reader::Doc(cdata.data()), tag_items);\n         match maybe_find_item(inherent_impl_def_id.node, items) {\n             None => {}\n             Some(inherent_impl_doc) => {\n@@ -626,10 +627,10 @@ fn each_child_of_item_or_crate(intr: @ident_interner,\n \n         // This reexport may be in yet another crate.\n         let other_crates_items = if child_def_id.crate == cdata.cnum {\n-            reader::get_doc(reader::Doc(cdata.data), tag_items)\n+            reader::get_doc(reader::Doc(cdata.data()), tag_items)\n         } else {\n             let crate_data = get_crate_data(child_def_id.crate);\n-            reader::get_doc(reader::Doc(crate_data.data), tag_items)\n+            reader::get_doc(reader::Doc(crate_data.data()), tag_items)\n         };\n \n         // Get the item.\n@@ -657,7 +658,7 @@ pub fn each_child_of_item(intr: @ident_interner,\n                           get_crate_data: GetCrateDataCb,\n                           callback: |DefLike, ast::Ident, ast::visibility|) {\n     // Find the item.\n-    let root_doc = reader::Doc(cdata.data);\n+    let root_doc = reader::Doc(cdata.data());\n     let items = reader::get_doc(root_doc, tag_items);\n     let item_doc = match maybe_find_item(id, items) {\n         None => return,\n@@ -678,7 +679,7 @@ pub fn each_top_level_item_of_crate(intr: @ident_interner,\n                                     callback: |DefLike,\n                                                ast::Ident,\n                                                ast::visibility|) {\n-    let root_doc = reader::Doc(cdata.data);\n+    let root_doc = reader::Doc(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);\n     let crate_items_doc = reader::get_doc(misc_info_doc,\n                                           tag_misc_info_crate_items);\n@@ -691,7 +692,7 @@ pub fn each_top_level_item_of_crate(intr: @ident_interner,\n }\n \n pub fn get_item_path(cdata: Cmd, id: ast::NodeId) -> ast_map::path {\n-    item_path(lookup_item(id, cdata.data))\n+    item_path(lookup_item(id, cdata.data()))\n }\n \n pub type decode_inlined_item<'a> = 'a |cdata: @cstore::crate_metadata,\n@@ -705,7 +706,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n                           decode_inlined_item: decode_inlined_item)\n                        -> csearch::found_ast {\n     debug!(\"Looking up item: {}\", id);\n-    let item_doc = lookup_item(id, cdata.data);\n+    let item_doc = lookup_item(id, cdata.data());\n     let path = {\n         let item_path = item_path(item_doc);\n         item_path.init().to_owned()\n@@ -716,7 +717,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n         match item_parent_item(item_doc) {\n           Some(did) => {\n             let did = translate_def_id(cdata, did);\n-            let parent_item = lookup_item(did.node, cdata.data);\n+            let parent_item = lookup_item(did.node, cdata.data());\n             match decode_inlined_item(cdata, tcx, path, parent_item) {\n               Some(ref ii) => csearch::found_parent(did, *ii),\n               None => csearch::not_found\n@@ -730,7 +731,7 @@ pub fn maybe_get_item_ast(cdata: Cmd, tcx: ty::ctxt,\n \n pub fn get_enum_variants(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n                      tcx: ty::ctxt) -> ~[@ty::VariantInfo] {\n-    let data = cdata.data;\n+    let data = cdata.data();\n     let items = reader::get_doc(reader::Doc(data), tag_items);\n     let item = find_item(id, items);\n     let mut infos: ~[@ty::VariantInfo] = ~[];\n@@ -808,7 +809,7 @@ fn item_impl_methods(intr: @ident_interner, cdata: Cmd, item: ebml::Doc,\n pub fn get_impl(intr: @ident_interner, cdata: Cmd, impl_id: ast::NodeId,\n                tcx: ty::ctxt)\n                 -> ty::Impl {\n-    let data = cdata.data;\n+    let data = cdata.data();\n     let impl_item = lookup_item(impl_id, data);\n     ty::Impl {\n         did: ast::DefId {\n@@ -825,7 +826,7 @@ pub fn get_method_name_and_explicit_self(\n     cdata: Cmd,\n     id: ast::NodeId) -> (ast::Ident, ast::explicit_self_)\n {\n-    let method_doc = lookup_item(id, cdata.data);\n+    let method_doc = lookup_item(id, cdata.data());\n     let name = item_name(intr, method_doc);\n     let explicit_self = get_explicit_self(method_doc);\n     (name, explicit_self)\n@@ -834,12 +835,12 @@ pub fn get_method_name_and_explicit_self(\n pub fn get_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n                   tcx: ty::ctxt) -> ty::Method\n {\n-    let method_doc = lookup_item(id, cdata.data);\n+    let method_doc = lookup_item(id, cdata.data());\n     let def_id = item_def_id(method_doc, cdata);\n \n     let container_id = item_reqd_and_translated_parent_item(cdata.cnum,\n                                                             method_doc);\n-    let container_doc = lookup_item(container_id.node, cdata.data);\n+    let container_doc = lookup_item(container_id.node, cdata.data());\n     let container = match item_family(container_doc) {\n         Trait => TraitContainer(container_id),\n         _ => ImplContainer(container_id),\n@@ -873,7 +874,7 @@ pub fn get_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n \n pub fn get_trait_method_def_ids(cdata: Cmd,\n                                 id: ast::NodeId) -> ~[ast::DefId] {\n-    let data = cdata.data;\n+    let data = cdata.data();\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n     reader::tagged_docs(item, tag_item_trait_method, |mth| {\n@@ -884,7 +885,7 @@ pub fn get_trait_method_def_ids(cdata: Cmd,\n }\n \n pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n-    let data = cdata.data;\n+    let data = cdata.data();\n     let item_doc = lookup_item(id, data);\n     let variance_doc = reader::get_doc(item_doc, tag_item_variances);\n     let mut decoder = reader::Decoder(variance_doc);\n@@ -894,7 +895,7 @@ pub fn get_item_variances(cdata: Cmd, id: ast::NodeId) -> ty::ItemVariances {\n pub fn get_provided_trait_methods(intr: @ident_interner, cdata: Cmd,\n                                   id: ast::NodeId, tcx: ty::ctxt) ->\n         ~[@ty::Method] {\n-    let data = cdata.data;\n+    let data = cdata.data();\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n \n@@ -915,7 +916,7 @@ pub fn get_provided_trait_methods(intr: @ident_interner, cdata: Cmd,\n pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n                     -> ~[@ty::TraitRef] {\n     let mut results = ~[];\n-    let item_doc = lookup_item(id, cdata.data);\n+    let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc, tag_item_super_trait_ref, |trait_doc| {\n         // NB. Only reads the ones that *aren't* builtin-bounds. See also\n         // get_trait_def() for collecting the builtin bounds.\n@@ -931,7 +932,7 @@ pub fn get_supertraits(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n \n pub fn get_type_name_if_impl(cdata: Cmd,\n                              node_id: ast::NodeId) -> Option<ast::Ident> {\n-    let item = lookup_item(node_id, cdata.data);\n+    let item = lookup_item(node_id, cdata.data());\n     if item_family(item) != Impl {\n         return None;\n     }\n@@ -949,7 +950,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n                                   cdata: Cmd,\n                                   node_id: ast::NodeId)\n                                -> Option<~[StaticMethodInfo]> {\n-    let item = lookup_item(node_id, cdata.data);\n+    let item = lookup_item(node_id, cdata.data());\n     if item_family(item) != Impl {\n         return None;\n     }\n@@ -969,7 +970,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n \n     let mut static_impl_methods = ~[];\n     for impl_method_id in impl_method_ids.iter() {\n-        let impl_method_doc = lookup_item(impl_method_id.node, cdata.data);\n+        let impl_method_doc = lookup_item(impl_method_id.node, cdata.data());\n         let family = item_family(impl_method_doc);\n         match family {\n             StaticMethod | UnsafeStaticMethod => {\n@@ -997,7 +998,7 @@ pub fn get_static_methods_if_impl(intr: @ident_interner,\n pub fn get_item_attrs(cdata: Cmd,\n                       node_id: ast::NodeId,\n                       f: |~[@ast::MetaItem]|) {\n-    let item = lookup_item(node_id, cdata.data);\n+    let item = lookup_item(node_id, cdata.data());\n     reader::tagged_docs(item, tag_attributes, |attributes| {\n         reader::tagged_docs(attributes, tag_attribute, |attribute| {\n             f(get_meta_items(attribute));\n@@ -1018,7 +1019,7 @@ fn struct_field_family_to_visibility(family: Family) -> ast::visibility {\n \n pub fn get_struct_fields(intr: @ident_interner, cdata: Cmd, id: ast::NodeId)\n     -> ~[ty::field_ty] {\n-    let data = cdata.data;\n+    let data = cdata.data();\n     let item = lookup_item(id, data);\n     let mut result = ~[];\n     reader::tagged_docs(item, tag_item_field, |an_item| {\n@@ -1049,7 +1050,7 @@ pub fn get_struct_fields(intr: @ident_interner, cdata: Cmd, id: ast::NodeId)\n \n pub fn get_item_visibility(cdata: Cmd, id: ast::NodeId)\n                         -> ast::visibility {\n-    item_visibility(lookup_item(id, cdata.data))\n+    item_visibility(lookup_item(id, cdata.data()))\n }\n \n fn get_meta_items(md: ebml::Doc) -> ~[@ast::MetaItem] {\n@@ -1119,7 +1120,7 @@ fn list_crate_attributes(intr: @ident_interner, md: ebml::Doc, hash: &str,\n     write!(out, \"\\n\\n\");\n }\n \n-pub fn get_crate_attributes(data: @~[u8]) -> ~[ast::Attribute] {\n+pub fn get_crate_attributes(data: &[u8]) -> ~[ast::Attribute] {\n     return get_attributes(reader::Doc(data));\n }\n \n@@ -1131,7 +1132,7 @@ pub struct CrateDep {\n     hash: @str\n }\n \n-pub fn get_crate_deps(data: @~[u8]) -> ~[CrateDep] {\n+pub fn get_crate_deps(data: &[u8]) -> ~[CrateDep] {\n     let mut deps: ~[CrateDep] = ~[];\n     let cratedoc = reader::Doc(data);\n     let depsdoc = reader::get_doc(cratedoc, tag_crate_deps);\n@@ -1151,7 +1152,7 @@ pub fn get_crate_deps(data: @~[u8]) -> ~[CrateDep] {\n     return deps;\n }\n \n-fn list_crate_deps(data: @~[u8], out: @mut io::Writer) {\n+fn list_crate_deps(data: &[u8], out: @mut io::Writer) {\n     write!(out, \"=External Dependencies=\\n\");\n \n     let r = get_crate_deps(data);\n@@ -1163,21 +1164,21 @@ fn list_crate_deps(data: @~[u8], out: @mut io::Writer) {\n     write!(out, \"\\n\");\n }\n \n-pub fn get_crate_hash(data: @~[u8]) -> @str {\n+pub fn get_crate_hash(data: &[u8]) -> @str {\n     let cratedoc = reader::Doc(data);\n     let hashdoc = reader::get_doc(cratedoc, tag_crate_hash);\n     hashdoc.as_str_slice().to_managed()\n }\n \n-pub fn get_crate_vers(data: @~[u8]) -> @str {\n+pub fn get_crate_vers(data: &[u8]) -> @str {\n     let attrs = decoder::get_crate_attributes(data);\n     match attr::find_pkgid(attrs) {\n         None => @\"0.0\",\n         Some(pkgid) => pkgid.version_or_default().to_managed(),\n     }\n }\n \n-pub fn list_crate_metadata(intr: @ident_interner, bytes: @~[u8],\n+pub fn list_crate_metadata(intr: @ident_interner, bytes: &[u8],\n                            out: @mut io::Writer) {\n     let hash = get_crate_hash(bytes);\n     let md = reader::Doc(bytes);\n@@ -1202,7 +1203,7 @@ pub fn translate_def_id(cdata: Cmd, did: ast::DefId) -> ast::DefId {\n }\n \n pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n-    let impls_doc = reader::get_doc(reader::Doc(cdata.data), tag_impls);\n+    let impls_doc = reader::get_doc(reader::Doc(cdata.data()), tag_impls);\n     let _ = reader::tagged_docs(impls_doc, tag_impls_impl, |impl_doc| {\n         callback(item_def_id(impl_doc, cdata));\n         true\n@@ -1212,7 +1213,7 @@ pub fn each_impl(cdata: Cmd, callback: |ast::DefId|) {\n pub fn each_implementation_for_type(cdata: Cmd,\n                                     id: ast::NodeId,\n                                     callback: |ast::DefId|) {\n-    let item_doc = lookup_item(id, cdata.data);\n+    let item_doc = lookup_item(id, cdata.data());\n     reader::tagged_docs(item_doc,\n                         tag_items_data_item_inherent_impl,\n                         |impl_doc| {\n@@ -1225,7 +1226,7 @@ pub fn each_implementation_for_type(cdata: Cmd,\n pub fn each_implementation_for_trait(cdata: Cmd,\n                                      id: ast::NodeId,\n                                      callback: |ast::DefId|) {\n-    let item_doc = lookup_item(id, cdata.data);\n+    let item_doc = lookup_item(id, cdata.data());\n \n     let _ = reader::tagged_docs(item_doc,\n                                 tag_items_data_item_extension_impl,\n@@ -1238,13 +1239,13 @@ pub fn each_implementation_for_trait(cdata: Cmd,\n \n pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n                            -> Option<ast::DefId> {\n-    let item_doc = lookup_item(id, cdata.data);\n+    let item_doc = lookup_item(id, cdata.data());\n     let parent_item_id = match item_parent_item(item_doc) {\n         None => return None,\n         Some(item_id) => item_id,\n     };\n     let parent_item_id = translate_def_id(cdata, parent_item_id);\n-    let parent_item_doc = lookup_item(parent_item_id.node, cdata.data);\n+    let parent_item_doc = lookup_item(parent_item_id.node, cdata.data());\n     match item_family(parent_item_doc) {\n         Trait => Some(item_def_id(parent_item_doc, cdata)),\n         Impl => {\n@@ -1257,7 +1258,8 @@ pub fn get_trait_of_method(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n \n \n pub fn get_native_libraries(cdata: Cmd) -> ~[(cstore::NativeLibaryKind, ~str)] {\n-    let libraries = reader::get_doc(reader::Doc(cdata.data), tag_native_libraries);\n+    let libraries = reader::get_doc(reader::Doc(cdata.data()),\n+                                    tag_native_libraries);\n     let mut result = ~[];\n     reader::tagged_docs(libraries, tag_native_libraries_lib, |lib_doc| {\n         let kind_doc = reader::get_doc(lib_doc, tag_native_libraries_kind);"}, {"sha": "76b0c48e95ef8c26ecda90edd020418d7b18e08b", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -1526,8 +1526,8 @@ fn encode_crate_deps(ecx: &EncodeContext,\n         cstore::iter_crate_data(cstore, |key, val| {\n             let dep = decoder::CrateDep {cnum: key,\n                        name: ecx.tcx.sess.ident_of(val.name),\n-                       vers: decoder::get_crate_vers(val.data),\n-                       hash: decoder::get_crate_hash(val.data)};\n+                       vers: decoder::get_crate_vers(val.data()),\n+                       hash: decoder::get_crate_hash(val.data())};\n             deps.push(dep);\n         });\n "}, {"sha": "ae851a7377dc6bba3a4d726995b6a8867b2e1789", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -13,6 +13,7 @@\n use back::archive::{Archive, METADATA_FILENAME};\n use driver::session::Session;\n use lib::llvm::{False, llvm, ObjectFile, mk_section_iter};\n+use metadata::cstore::{MetadataBlob, MetadataVec};\n use metadata::decoder;\n use metadata::encoder;\n use metadata::filesearch::{FileMatches, FileDoesntMatch};\n@@ -57,7 +58,7 @@ pub struct Context {\n pub struct Library {\n     dylib: Option<Path>,\n     rlib: Option<Path>,\n-    metadata: @~[u8],\n+    metadata: MetadataBlob,\n }\n \n impl Context {\n@@ -103,8 +104,10 @@ impl Context {\n                     } else if candidate {\n                         match get_metadata_section(self.sess, self.os, path) {\n                             Some(cvec) =>\n-                                if crate_matches(cvec, self.name, self.version, self.hash) {\n-                                    debug!(\"found {} with matching pkgid\", path.display());\n+                                if crate_matches(cvec.as_slice(), self.name,\n+                                                 self.version, self.hash) {\n+                                    debug!(\"found {} with matching pkgid\",\n+                                           path.display());\n                                     let (rlib, dylib) = if file.ends_with(\".rlib\") {\n                                         (Some(path.clone()), None)\n                                     } else {\n@@ -154,7 +157,8 @@ impl Context {\n                         }\n                         None => {}\n                     }\n-                    let attrs = decoder::get_crate_attributes(lib.metadata);\n+                    let data = lib.metadata.as_slice();\n+                    let attrs = decoder::get_crate_attributes(data);\n                     match attr::find_pkgid(attrs) {\n                         None => {}\n                         Some(pkgid) => {\n@@ -226,7 +230,7 @@ pub fn note_pkgid_attr(diag: @mut span_handler,\n     diag.handler().note(format!(\"pkgid: {}\", pkgid.to_str()));\n }\n \n-fn crate_matches(crate_data: @~[u8],\n+fn crate_matches(crate_data: &[u8],\n                  name: @str,\n                  version: @str,\n                  hash: @str) -> bool {\n@@ -244,10 +248,11 @@ fn crate_matches(crate_data: @~[u8],\n     }\n }\n \n-fn get_metadata_section(sess: Session, os: Os, filename: &Path) -> Option<@~[u8]> {\n+fn get_metadata_section(sess: Session, os: Os,\n+                        filename: &Path) -> Option<MetadataBlob> {\n     if filename.filename_str().unwrap().ends_with(\".rlib\") {\n         let archive = Archive::open(sess, filename.clone());\n-        return Some(@archive.read(METADATA_FILENAME));\n+        return Some(MetadataVec(archive.read(METADATA_FILENAME)));\n     }\n     unsafe {\n         let mb = filename.with_c_str(|buf| {\n@@ -284,15 +289,15 @@ fn get_metadata_section(sess: Session, os: Os, filename: &Path) -> Option<@~[u8]\n                        csz - vlen);\n                 vec::raw::buf_as_slice(cvbuf1, csz-vlen, |bytes| {\n                     let inflated = flate::inflate_bytes(bytes);\n-                    found = Some(@(inflated));\n+                    found = Some(MetadataVec(inflated));\n                 });\n-                if found != None {\n+                if found.is_some() {\n                     return found;\n                 }\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        return option::None::<@~[u8]>;\n+        return None;\n     }\n }\n \n@@ -323,7 +328,8 @@ pub fn list_file_metadata(sess: Session,\n                           path: &Path,\n                           out: @mut io::Writer) {\n     match get_metadata_section(sess, os, path) {\n-      option::Some(bytes) => decoder::list_crate_metadata(intr, bytes, out),\n+      option::Some(bytes) => decoder::list_crate_metadata(intr, bytes.as_slice(),\n+                                                          out),\n       option::None => {\n         write!(out, \"could not find metadata in {}.\\n\", path.display())\n       }"}, {"sha": "93302739178bdfeac7dd568637def2d06983590d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -511,7 +511,7 @@ trait ebml_decoder_helper {\n                           -> freevar_entry;\n }\n \n-impl ebml_decoder_helper for reader::Decoder {\n+impl<'a> ebml_decoder_helper for reader::Decoder<'a> {\n     fn read_freevar_entry(&mut self, xcx: @ExtendedDecodeContext)\n                           -> freevar_entry {\n         let fv: freevar_entry = Decodable::decode(self);\n@@ -536,7 +536,7 @@ trait capture_var_helper {\n                         -> moves::CaptureVar;\n }\n \n-impl capture_var_helper for reader::Decoder {\n+impl<'a> capture_var_helper for reader::Decoder<'a> {\n     fn read_capture_var(&mut self, xcx: @ExtendedDecodeContext)\n                         -> moves::CaptureVar {\n         let cvar: moves::CaptureVar = Decodable::decode(self);\n@@ -581,7 +581,7 @@ fn encode_method_map_entry(ecx: &e::EncodeContext,\n     })\n }\n \n-impl read_method_map_entry_helper for reader::Decoder {\n+impl<'a> read_method_map_entry_helper for reader::Decoder<'a> {\n     fn read_method_map_entry(&mut self, xcx: @ExtendedDecodeContext)\n                              -> method_map_entry {\n         self.read_struct(\"method_map_entry\", 3, |this| {\n@@ -703,7 +703,7 @@ pub trait vtable_decoder_helpers {\n                           -> typeck::vtable_origin;\n }\n \n-impl vtable_decoder_helpers for reader::Decoder {\n+impl<'a> vtable_decoder_helpers for reader::Decoder<'a> {\n     fn read_vtable_res(&mut self,\n                        tcx: ty::ctxt, cdata: @cstore::crate_metadata)\n                       -> typeck::vtable_res {\n@@ -1026,12 +1026,12 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n \n trait doc_decoder_helpers {\n     fn as_int(&self) -> int;\n-    fn opt_child(&self, tag: c::astencode_tag) -> Option<ebml::Doc>;\n+    fn opt_child(&self, tag: c::astencode_tag) -> Option<Self>;\n }\n \n-impl doc_decoder_helpers for ebml::Doc {\n+impl<'a> doc_decoder_helpers for ebml::Doc<'a> {\n     fn as_int(&self) -> int { reader::doc_as_u64(*self) as int }\n-    fn opt_child(&self, tag: c::astencode_tag) -> Option<ebml::Doc> {\n+    fn opt_child(&self, tag: c::astencode_tag) -> Option<ebml::Doc<'a>> {\n         reader::maybe_get_doc(*self, tag as uint)\n     }\n }\n@@ -1058,12 +1058,12 @@ trait ebml_decoder_decoder_helpers {\n                       cdata: @cstore::crate_metadata) -> ~[ty::t];\n }\n \n-impl ebml_decoder_decoder_helpers for reader::Decoder {\n+impl<'a> ebml_decoder_decoder_helpers for reader::Decoder<'a> {\n     fn read_ty_noxcx(&mut self,\n                      tcx: ty::ctxt, cdata: @cstore::crate_metadata) -> ty::t {\n         self.read_opaque(|_, doc| {\n             tydecode::parse_ty_data(\n-                *doc.data,\n+                doc.data,\n                 cdata.cnum,\n                 doc.start,\n                 tcx,\n@@ -1087,7 +1087,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n             debug!(\"read_ty({})\", type_string(doc));\n \n             let ty = tydecode::parse_ty_data(\n-                *doc.data,\n+                doc.data,\n                 xcx.dcx.cdata.cnum,\n                 doc.start,\n                 xcx.dcx.tcx,\n@@ -1113,7 +1113,7 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                            -> ty::TypeParameterDef {\n         self.read_opaque(|this, doc| {\n             tydecode::parse_type_param_def_data(\n-                *doc.data,\n+                doc.data,\n                 doc.start,\n                 xcx.dcx.cdata.cnum,\n                 xcx.dcx.tcx,\n@@ -1338,7 +1338,7 @@ fn roundtrip(in_item: Option<@ast::item>) {\n     let wr = @mut MemWriter::new();\n     let mut ebml_w = writer::Encoder(wr);\n     encode_item_ast(&mut ebml_w, in_item);\n-    let ebml_doc = reader::Doc(@wr.inner_ref().to_owned());\n+    let ebml_doc = reader::Doc(wr.inner_ref().as_slice());\n     let out_item = decode_item_ast(ebml_doc);\n \n     assert_eq!(in_item, out_item);"}, {"sha": "dd921fb9e93b5d66ef66218aa8a81b86ab89eeb0", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -102,7 +102,7 @@ impl Clean<ExternalCrate> for cstore::crate_metadata {\n     fn clean(&self) -> ExternalCrate {\n         ExternalCrate {\n             name: self.name.to_owned(),\n-            attrs: decoder::get_crate_attributes(self.data).clean()\n+            attrs: decoder::get_crate_attributes(self.data()).clean()\n         }\n     }\n }"}, {"sha": "1810f33eadbd9c8af1c5707dc17c9b48f33bcd3d", "filename": "src/test/run-pass/auto-encode.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Ftest%2Frun-pass%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-encode.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -10,6 +10,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// xfail-test FIXME(#5121)\n+\n #[feature(managed_boxes)];\n \n extern mod extra;\n@@ -28,18 +30,18 @@ use std::io;\n use extra::serialize::{Decodable, Encodable};\n use extra::time;\n \n-fn test_ebml<A:\n+fn test_ebml<'a, A:\n     Eq +\n     Encodable<EBWriter::Encoder> +\n-    Decodable<EBReader::Decoder>\n+    Decodable<EBReader::Decoder<'a>>\n >(a1: &A) {\n     let mut wr = @mut std::io::mem::MemWriter::new();\n     let mut ebml_w = EBWriter::Encoder(wr);\n     a1.encode(&mut ebml_w);\n-    let bytes = wr.inner_ref().to_owned();\n+    let bytes = wr.inner_ref().as_slice();\n \n-    let d = EBReader::Doc(@bytes);\n-    let mut decoder = EBReader::Decoder(d);\n+    let d: extra::ebml::Doc<'a> = EBReader::Doc(bytes);\n+    let mut decoder: EBReader::Decoder<'a> = EBReader::Decoder(d);\n     let a2: A = Decodable::decode(&mut decoder);\n     assert!(*a1 == a2);\n }"}, {"sha": "4f4e9c9ce00b7e9f7f20015171365ed474b5018b", "filename": "src/test/run-pass/deriving-encodable-decodable.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c24bfa8c3faef7bc28047cb233e914dfe5eee0d/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-encodable-decodable.rs?ref=5c24bfa8c3faef7bc28047cb233e914dfe5eee0d", "patch": "@@ -12,6 +12,7 @@\n // job done at least\n \n // xfail-fast\n+// xfail-test FIXME(#5121)\n \n #[feature(struct_variant, managed_boxes)];\n \n@@ -54,7 +55,8 @@ struct G<T> {\n     t: T\n }\n \n-fn roundtrip<T: Rand + Eq + Encodable<Encoder> + Decodable<Decoder>>() {\n+fn roundtrip<'a, T: Rand + Eq + Encodable<Encoder> +\n+                    Decodable<Decoder<'a>>>() {\n     let obj: T = random();\n     let w = @mut MemWriter::new();\n     let mut e = Encoder(w);"}]}