{"sha": "1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNGZhYWVlNDAxZjg2ODFlMjVhZmJjZjNiNjI5NmI2Y2QyY2E1NWE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-10-29T10:03:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-11-09T00:42:46Z"}, "message": "Generalize AST and ty::Generics to accept multiple lifetimes.", "tree": {"sha": "f0dac4e7f58ebab635c4bba59a04fca2833db4a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f0dac4e7f58ebab635c4bba59a04fca2833db4a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "html_url": "https://github.com/rust-lang/rust/commit/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85c51d3b02e421e2ab99c330e0d8212293f64f04", "url": "https://api.github.com/repos/rust-lang/rust/commits/85c51d3b02e421e2ab99c330e0d8212293f64f04", "html_url": "https://github.com/rust-lang/rust/commit/85c51d3b02e421e2ab99c330e0d8212293f64f04"}], "stats": {"total": 2976, "additions": 1516, "deletions": 1460}, "files": [{"sha": "c2d0251b23cc21d3a490cb128702734129ae777f", "filename": "src/librustc/front/std_inject.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Ffront%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fstd_inject.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -116,12 +116,12 @@ impl fold::ast_fold for StandardLibraryInjector {\n             segments: ~[\n                 ast::PathSegment {\n                     identifier: self.sess.ident_of(\"std\"),\n-                    lifetime: None,\n+                    lifetimes: opt_vec::Empty,\n                     types: opt_vec::Empty,\n                 },\n                 ast::PathSegment {\n                     identifier: self.sess.ident_of(\"prelude\"),\n-                    lifetime: None,\n+                    lifetimes: opt_vec::Empty,\n                     types: opt_vec::Empty,\n                 },\n             ],"}, {"sha": "b6ae41833777a8626d46514acb71df1f02d47405", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -343,7 +343,7 @@ fn path_node(ids: ~[ast::Ident]) -> ast::Path {\n         global: false,\n         segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n-            lifetime: None,\n+            lifetimes: opt_vec::Empty,\n             types: opt_vec::Empty,\n         }).collect()\n     }\n@@ -355,7 +355,7 @@ fn path_node_global(ids: ~[ast::Ident]) -> ast::Path {\n         global: true,\n         segments: ids.move_iter().map(|identifier| ast::PathSegment {\n             identifier: identifier,\n-            lifetime: None,\n+            lifetimes: opt_vec::Empty,\n             types: opt_vec::Empty,\n         }).collect()\n     }"}, {"sha": "f2f200affe802a9351efb33db7f65cd2548820b2", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -53,8 +53,10 @@ use syntax::diagnostic;\n pub mod middle {\n     pub mod trans;\n     pub mod ty;\n+    pub mod ty_fold;\n     pub mod subst;\n     pub mod resolve;\n+    pub mod resolve_lifetime;\n     pub mod typeck;\n     pub mod check_loop;\n     pub mod check_match;"}, {"sha": "05d40bbb6aea778b7fa68909cb43fae0dc3860ec", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -193,6 +193,11 @@ pub static tag_path_elt_pretty_name: uint = 0x87;\n pub static tag_path_elt_pretty_name_ident: uint = 0x88;\n pub static tag_path_elt_pretty_name_extra: uint = 0x89;\n \n+pub static tag_region_param_def: uint = 0x100;\n+pub static tag_region_param_def_ident: uint = 0x101;\n+pub static tag_region_param_def_def_id: uint = 0x102;\n+\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "436b4c3df6bec8c4f36831d147e5933a5fd036bb", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -199,12 +199,6 @@ pub fn get_trait_def(tcx: ty::ctxt, def: ast::DefId) -> ty::TraitDef {\n     decoder::get_trait_def(cdata, def.node, tcx)\n }\n \n-pub fn get_region_param(cstore: @mut metadata::cstore::CStore,\n-                        def: ast::DefId) -> Option<ty::region_variance> {\n-    let cdata = cstore::get_crate_data(cstore, def.crate);\n-    return decoder::get_region_param(cdata, def.node);\n-}\n-\n pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n                       def: ast::DefId) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.cstore;\n@@ -224,7 +218,7 @@ pub fn get_field_type(tcx: ty::ctxt, class_id: ast::DefId,\n     let ty = decoder::item_type(def, the_field, tcx, cdata);\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: @~[],\n-                                region_param: None},\n+                                region_param_defs: @[]},\n         ty: ty\n     }\n }"}, {"sha": "3b4e29c97c0149003fa886846099588b0025ad14", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -25,7 +25,7 @@ use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n \n-\n+use std::at_vec;\n use std::u64;\n use std::rt::io;\n use std::rt::io::extensions::u64_from_be_bytes;\n@@ -252,9 +252,11 @@ fn item_trait_ref(doc: ebml::Doc, tcx: ty::ctxt, cdata: Cmd) -> ty::TraitRef {\n     doc_trait_ref(tp, tcx, cdata)\n }\n \n-fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: Cmd,\n+fn item_ty_param_defs(item: ebml::Doc,\n+                      tcx: ty::ctxt,\n+                      cdata: Cmd,\n                       tag: uint)\n-    -> @~[ty::TypeParameterDef] {\n+                      -> @~[ty::TypeParameterDef] {\n     let mut bounds = ~[];\n     do reader::tagged_docs(item, tag) |p| {\n         let bd = parse_type_param_def_data(\n@@ -266,10 +268,23 @@ fn item_ty_param_defs(item: ebml::Doc, tcx: ty::ctxt, cdata: Cmd,\n     @bounds\n }\n \n-fn item_ty_region_param(item: ebml::Doc) -> Option<ty::region_variance> {\n-    do reader::maybe_get_doc(item, tag_region_param).map |doc| {\n-        let mut decoder = reader::Decoder(doc);\n-        Decodable::decode(&mut decoder)\n+fn item_region_param_defs(item_doc: ebml::Doc,\n+                          tcx: ty::ctxt,\n+                          cdata: Cmd)\n+                          -> @[ty::RegionParameterDef] {\n+    do at_vec::build(None) |push| {\n+        do reader::tagged_docs(item_doc, tag_region_param_def) |rp_doc| {\n+            let ident_str_doc = reader::get_doc(rp_doc,\n+                                                tag_region_param_def_ident);\n+            let ident = item_name(tcx.sess.intr(), ident_str_doc);\n+            let def_id_doc = reader::get_doc(rp_doc,\n+                                             tag_region_param_def_def_id);\n+            let def_id = reader::with_doc_data(def_id_doc, parse_def_id);\n+            let def_id = translate_def_id(cdata, def_id);\n+            push(ty::RegionParameterDef { ident: ident,\n+                                          def_id: def_id });\n+            true\n+        };\n     }\n }\n \n@@ -393,7 +408,7 @@ pub fn get_trait_def(cdata: Cmd,\n     let item_doc = lookup_item(item_id, cdata.data);\n     let tp_defs = item_ty_param_defs(item_doc, tcx, cdata,\n                                      tag_items_data_item_ty_param_bounds);\n-    let rp = item_ty_region_param(item_doc);\n+    let rp_defs = item_region_param_defs(item_doc, tcx, cdata);\n     let mut bounds = ty::EmptyBuiltinBounds();\n     // Collect the builtin bounds from the encoded supertraits.\n     // FIXME(#8559): They should be encoded directly.\n@@ -407,7 +422,7 @@ pub fn get_trait_def(cdata: Cmd,\n     };\n     ty::TraitDef {\n         generics: ty::Generics {type_param_defs: tp_defs,\n-                                region_param: rp},\n+                                region_param_defs: rp_defs},\n         bounds: bounds,\n         trait_ref: @item_trait_ref(item_doc, tcx, cdata)\n     }\n@@ -417,33 +432,27 @@ pub fn get_type(cdata: Cmd, id: ast::NodeId, tcx: ty::ctxt)\n     -> ty::ty_param_bounds_and_ty {\n \n     let item = lookup_item(id, cdata.data);\n+\n     let t = item_type(ast::DefId { crate: cdata.cnum, node: id }, item, tcx,\n                       cdata);\n-    let tp_defs = if family_has_type_params(item_family(item)) {\n-        item_ty_param_defs(item, tcx, cdata, tag_items_data_item_ty_param_bounds)\n-    } else { @~[] };\n-    let rp = item_ty_region_param(item);\n+\n+    let tp_defs = item_ty_param_defs(item, tcx, cdata, tag_items_data_item_ty_param_bounds);\n+    let rp_defs = item_region_param_defs(item, tcx, cdata);\n+\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: tp_defs,\n-                                region_param: rp},\n+                                region_param_defs: rp_defs},\n         ty: t\n     }\n }\n \n-pub fn get_region_param(cdata: Cmd, id: ast::NodeId)\n-    -> Option<ty::region_variance> {\n-\n-    let item = lookup_item(id, cdata.data);\n-    return item_ty_region_param(item);\n-}\n-\n pub fn get_type_param_count(data: @~[u8], id: ast::NodeId) -> uint {\n     item_ty_param_count(lookup_item(id, data))\n }\n \n pub fn get_impl_trait(cdata: Cmd,\n-                       id: ast::NodeId,\n-                       tcx: ty::ctxt) -> Option<@ty::TraitRef>\n+                      id: ast::NodeId,\n+                      tcx: ty::ctxt) -> Option<@ty::TraitRef>\n {\n     let item_doc = lookup_item(id, cdata.data);\n     do reader::maybe_get_doc(item_doc, tag_item_trait_ref).map |tp| {\n@@ -1044,6 +1053,7 @@ pub fn get_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n     let name = item_name(intr, method_doc);\n     let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n                                              tag_item_method_tps);\n+    let rp_defs = item_region_param_defs(method_doc, tcx, cdata);\n     let transformed_self_ty = doc_transformed_self_ty(method_doc, tcx, cdata);\n     let fty = doc_method_fty(method_doc, tcx, cdata);\n     let vis = item_visibility(method_doc);\n@@ -1054,7 +1064,7 @@ pub fn get_method(intr: @ident_interner, cdata: Cmd, id: ast::NodeId,\n         name,\n         ty::Generics {\n             type_param_defs: type_param_defs,\n-            region_param: None\n+            region_param_defs: rp_defs,\n         },\n         transformed_self_ty,\n         fty,"}, {"sha": "76c49da5861e6e2a28b7958b445691f95d58137d", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -121,17 +121,6 @@ pub fn encode_def_id(ebml_w: &mut writer::Encoder, id: DefId) {\n     ebml_w.wr_tagged_str(tag_def_id, def_to_str(id));\n }\n \n-fn encode_region_param(ecx: &EncodeContext,\n-                       ebml_w: &mut writer::Encoder,\n-                       it: @ast::item) {\n-    let opt_rp = ecx.tcx.region_paramd_items.find(&it.id);\n-    for rp in opt_rp.iter() {\n-        ebml_w.start_tag(tag_region_param);\n-        rp.encode(ebml_w);\n-        ebml_w.end_tag();\n-    }\n-}\n-\n #[deriving(Clone)]\n struct entry<T> {\n     val: T,\n@@ -205,11 +194,29 @@ fn encode_ty_type_param_defs(ebml_w: &mut writer::Encoder,\n     }\n }\n \n+fn encode_region_param_defs(ebml_w: &mut writer::Encoder,\n+                            ecx: &EncodeContext,\n+                            params: @[ty::RegionParameterDef]) {\n+    for param in params.iter() {\n+        ebml_w.start_tag(tag_region_param_def);\n+\n+        ebml_w.start_tag(tag_region_param_def_ident);\n+        encode_name(ecx, ebml_w, param.ident);\n+        ebml_w.end_tag();\n+\n+        ebml_w.wr_tagged_str(tag_region_param_def_def_id,\n+                             def_to_str(param.def_id));\n+\n+        ebml_w.end_tag();\n+    }\n+}\n+\n fn encode_bounds_and_type(ebml_w: &mut writer::Encoder,\n                           ecx: &EncodeContext,\n                           tpt: &ty::ty_param_bounds_and_ty) {\n     encode_ty_type_param_defs(ebml_w, ecx, tpt.generics.type_param_defs,\n                               tag_items_data_item_ty_param_bounds);\n+    encode_region_param_defs(ebml_w, ecx, tpt.generics.region_param_defs);\n     encode_type(ecx, ebml_w, tpt.ty);\n }\n \n@@ -976,7 +983,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ecx, ebml_w, item);\n         encode_visibility(ebml_w, vis);\n         ebml_w.end_tag();\n       }\n@@ -994,7 +1000,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         }\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ecx, ebml_w, item);\n \n         // Encode inherent implementations for this enumeration.\n         encode_inherent_implementations(ecx, ebml_w, def_id);\n@@ -1030,7 +1035,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n-        encode_region_param(ecx, ebml_w, item);\n         encode_visibility(ebml_w, vis);\n \n         /* Encode def_ids for each field and method\n@@ -1075,7 +1079,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'i');\n-        encode_region_param(ecx, ebml_w, item);\n         encode_bounds_and_type(ebml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n@@ -1135,7 +1138,6 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.start_tag(tag_items_data_item);\n         encode_def_id(ebml_w, def_id);\n         encode_family(ebml_w, 'I');\n-        encode_region_param(ecx, ebml_w, item);\n         let trait_def = ty::lookup_trait_def(tcx, def_id);\n         encode_ty_type_param_defs(ebml_w, ecx,\n                                   trait_def.generics.type_param_defs,"}, {"sha": "1636205c76d626ccde8cde1ad2311c8599aea8b2", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 64, "deletions": 44, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -48,7 +48,10 @@ pub enum DefIdSource {\n     TypeWithId,\n \n     // Identifies a type parameter (`fn foo<X>() { ... }`).\n-    TypeParameter\n+    TypeParameter,\n+\n+    // Identifies a region parameter (`fn foo<'X>() { ... }`).\n+    RegionParameter,\n }\n type conv_did<'self> =\n     &'self fn(source: DefIdSource, ast::DefId) -> ast::DefId;\n@@ -143,7 +146,7 @@ fn parse_path(st: &mut PState) -> @ast::Path {\n                     segments: idents.move_iter().map(|identifier| {\n                         ast::PathSegment {\n                             identifier: identifier,\n-                            lifetime: None,\n+                            lifetimes: opt_vec::Empty,\n                             types: opt_vec::Empty,\n                         }\n                     }).collect()\n@@ -165,7 +168,7 @@ fn parse_sigil(st: &mut PState) -> ast::Sigil {\n     }\n }\n \n-fn parse_vstore(st: &mut PState) -> ty::vstore {\n+fn parse_vstore(st: &mut PState, conv: conv_did) -> ty::vstore {\n     assert_eq!(next(st), '/');\n \n     let c = peek(st);\n@@ -178,22 +181,22 @@ fn parse_vstore(st: &mut PState) -> ty::vstore {\n     match next(st) {\n       '~' => ty::vstore_uniq,\n       '@' => ty::vstore_box,\n-      '&' => ty::vstore_slice(parse_region(st)),\n+      '&' => ty::vstore_slice(parse_region(st, conv)),\n       c => st.tcx.sess.bug(format!(\"parse_vstore(): bad input '{}'\", c))\n     }\n }\n \n-fn parse_trait_store(st: &mut PState) -> ty::TraitStore {\n+fn parse_trait_store(st: &mut PState, conv: conv_did) -> ty::TraitStore {\n     match next(st) {\n         '~' => ty::UniqTraitStore,\n         '@' => ty::BoxTraitStore,\n-        '&' => ty::RegionTraitStore(parse_region(st)),\n+        '&' => ty::RegionTraitStore(parse_region(st, conv)),\n         c => st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\", c))\n     }\n }\n \n fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n-    let regions = parse_region_substs(st);\n+    let regions = parse_region_substs(st, |x,y| conv(x,y));\n \n     let self_ty = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)) );\n \n@@ -209,13 +212,13 @@ fn parse_substs(st: &mut PState, conv: conv_did) -> ty::substs {\n     };\n }\n \n-fn parse_region_substs(st: &mut PState) -> ty::RegionSubsts {\n+fn parse_region_substs(st: &mut PState, conv: conv_did) -> ty::RegionSubsts {\n     match next(st) {\n         'e' => ty::ErasedRegions,\n         'n' => {\n             let mut regions = opt_vec::Empty;\n             while peek(st) != '.' {\n-                let r = parse_region(st);\n+                let r = parse_region(st, |x,y| conv(x,y));\n                 regions.push(r);\n             }\n             assert_eq!(next(st), '.');\n@@ -225,34 +228,51 @@ fn parse_region_substs(st: &mut PState) -> ty::RegionSubsts {\n     }\n }\n \n-fn parse_bound_region(st: &mut PState) -> ty::bound_region {\n+fn parse_bound_region(st: &mut PState, conv: conv_did) -> ty::bound_region {\n     match next(st) {\n-      's' => ty::br_self,\n-      'a' => {\n-        let id = parse_uint(st);\n-        assert_eq!(next(st), '|');\n-        ty::br_anon(id)\n-      }\n-      '[' => ty::br_named(st.tcx.sess.ident_of(parse_str(st, ']'))),\n-      'c' => {\n-        let id = parse_uint(st) as int;\n-        assert_eq!(next(st), '|');\n-        ty::br_cap_avoid(id, @parse_bound_region(st))\n-      },\n-      _ => fail!(\"parse_bound_region: bad input\")\n+        'a' => {\n+            let id = parse_uint(st);\n+            assert_eq!(next(st), '|');\n+            ty::br_anon(id)\n+        }\n+        '[' => {\n+            let def = parse_def(st, RegionParameter, |x,y| conv(x,y));\n+            let ident = st.tcx.sess.ident_of(parse_str(st, ']'));\n+            ty::br_named(def, ident)\n+        }\n+        'f' => {\n+            let id = parse_uint(st);\n+            assert_eq!(next(st), '|');\n+            ty::br_fresh(id)\n+        }\n+        _ => fail!(\"parse_bound_region: bad input\")\n     }\n }\n \n-fn parse_region(st: &mut PState) -> ty::Region {\n+fn parse_region(st: &mut PState, conv: conv_did) -> ty::Region {\n     match next(st) {\n       'b' => {\n-        ty::re_bound(parse_bound_region(st))\n+        assert_eq!(next(st), '[');\n+        let id = parse_uint(st) as int;\n+        assert_eq!(next(st), '|');\n+        let br = parse_bound_region(st, |x,y| conv(x,y));\n+        assert_eq!(next(st), ']');\n+        ty::re_fn_bound(id, br)\n+      }\n+      'B' => {\n+        assert_eq!(next(st), '[');\n+        let node_id = parse_uint(st) as int;\n+        assert_eq!(next(st), '|');\n+        let index = parse_uint(st);\n+        assert_eq!(next(st), '|');\n+        let nm = st.tcx.sess.ident_of(parse_str(st, ']'));\n+        ty::re_type_bound(node_id, index, nm)\n       }\n       'f' => {\n         assert_eq!(next(st), '[');\n         let id = parse_uint(st) as int;\n         assert_eq!(next(st), '|');\n-        let br = parse_bound_region(st);\n+        let br = parse_bound_region(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         ty::re_free(ty::FreeRegion {scope_id: id,\n                                     bound_region: br})\n@@ -331,14 +351,14 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         assert_eq!(next(st), '[');\n         let def = parse_def(st, NominalType, |x,y| conv(x,y));\n         let substs = parse_substs(st, |x,y| conv(x,y));\n-        let store = parse_trait_store(st);\n+        let store = parse_trait_store(st, |x,y| conv(x,y));\n         let mt = parse_mutability(st);\n         let bounds = parse_bounds(st, |x,y| conv(x,y));\n         assert_eq!(next(st), ']');\n         return ty::mk_trait(st.tcx, def, substs, store, mt, bounds.builtin_bounds);\n       }\n       'p' => {\n-        let did = parse_def(st, TypeParameter, conv);\n+        let did = parse_def(st, TypeParameter, |x,y| conv(x,y));\n         debug!(\"parsed ty_param: did={:?}\", did);\n         return ty::mk_param(st.tcx, parse_uint(st), did);\n       }\n@@ -356,12 +376,12 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n       }\n       'U' => return ty::mk_unboxed_vec(st.tcx, parse_mt(st, conv)),\n       'V' => {\n-        let mt = parse_mt(st, conv);\n-        let v = parse_vstore(st);\n+        let mt = parse_mt(st, |x,y| conv(x,y));\n+        let v = parse_vstore(st, |x,y| conv(x,y));\n         return ty::mk_evec(st.tcx, mt, v);\n       }\n       'v' => {\n-        let v = parse_vstore(st);\n+        let v = parse_vstore(st, |x,y| conv(x,y));\n         return ty::mk_estr(st.tcx, v);\n       }\n       'T' => {\n@@ -495,7 +515,7 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n     let sigil = parse_sigil(st);\n     let purity = parse_purity(next(st));\n     let onceness = parse_onceness(next(st));\n-    let region = parse_region(st);\n+    let region = parse_region(st, |x,y| conv(x,y));\n     let bounds = parse_bounds(st, |x,y| conv(x,y));\n     let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::ClosureTy {\n@@ -511,7 +531,7 @@ fn parse_closure_ty(st: &mut PState, conv: conv_did) -> ty::ClosureTy {\n fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n     let purity = parse_purity(next(st));\n     let abi = parse_abi_set(st);\n-    let sig = parse_sig(st, conv);\n+    let sig = parse_sig(st, |x,y| conv(x,y));\n     ty::BareFnTy {\n         purity: purity,\n         abis: abi,\n@@ -521,22 +541,22 @@ fn parse_bare_fn_ty(st: &mut PState, conv: conv_did) -> ty::BareFnTy {\n \n fn parse_sig(st: &mut PState, conv: conv_did) -> ty::FnSig {\n     assert_eq!(next(st), '[');\n+    let id = parse_uint(st) as int;\n+    assert_eq!(next(st), '|');\n     let mut inputs = ~[];\n     while peek(st) != ']' {\n         inputs.push(parse_ty(st, |x,y| conv(x,y)));\n     }\n     st.pos += 1u; // eat the ']'\n-    let variadic = if peek(st) == 'A' {\n-        st.pos += 1; // eat the 'A'\n-        true\n-    } else { false };\n-    let ret_ty = parse_ty(st, conv);\n-    ty::FnSig {\n-        bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n-        inputs: inputs,\n-        output: ret_ty,\n-        variadic: variadic\n-    }\n+    let variadic = match next(st) {\n+        'V' => true,\n+        'N' => false,\n+    };\n+    let ret_ty = parse_ty(st, |x,y| conv(x,y));\n+    ty::FnSig {binder_id: id,\n+               inputs: inputs,\n+               output: ret_ty,\n+               variadic: variadic}\n }\n \n // Rust metadata parsing"}, {"sha": "af28162dbfd5dd4c7d56e10f42574dc7d470e46d", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -155,18 +155,31 @@ fn enc_region_substs(w: @mut MemWriter, cx: @ctxt, substs: &ty::RegionSubsts) {\n \n fn enc_region(w: @mut MemWriter, cx: @ctxt, r: ty::Region) {\n     match r {\n-        ty::re_bound(br) => {\n-            mywrite!(w, \"b\");\n+        ty::re_fn_bound(id, br) => {\n+            mywrite!(w, \"b[{}|\", id);\n             enc_bound_region(w, cx, br);\n+            mywrite!(w, \"]\");\n+        }\n+        ty::re_type_bound(node_id, index, ident) => {\n+            mywrite!(w, \"B[{}|{}|{}]\",\n+                     node_id,\n+                     index,\n+                     cx.tcx.sess.str_of(ident));\n         }\n         ty::re_free(ref fr) => {\n             mywrite!(w, \"f[{}|\", fr.scope_id);\n             enc_bound_region(w, cx, fr.bound_region);\n             mywrite!(w, \"]\");\n         }\n-        ty::re_scope(nid) => mywrite!(w, \"s{}|\", nid),\n-        ty::re_static => mywrite!(w, \"t\"),\n-        ty::re_empty => mywrite!(w, \"e\"),\n+        ty::re_scope(nid) => {\n+            mywrite!(w, \"s{}|\", nid);\n+        }\n+        ty::re_static => {\n+            mywrite!(w, \"t\");\n+        }\n+        ty::re_empty => {\n+            mywrite!(w, \"e\");\n+        }\n         ty::re_infer(_) => {\n             // these should not crop up after typeck\n             cx.diag.handler().bug(\"Cannot encode region variables\");\n@@ -176,14 +189,17 @@ fn enc_region(w: @mut MemWriter, cx: @ctxt, r: ty::Region) {\n \n fn enc_bound_region(w: @mut MemWriter, cx: @ctxt, br: ty::bound_region) {\n     match br {\n-        ty::br_self => mywrite!(w, \"s\"),\n-        ty::br_anon(idx) => mywrite!(w, \"a{}|\", idx),\n-        ty::br_named(s) => mywrite!(w, \"[{}]\", cx.tcx.sess.str_of(s)),\n-        ty::br_cap_avoid(id, br) => {\n-            mywrite!(w, \"c{}|\", id);\n-            enc_bound_region(w, cx, *br);\n-        }\n-        ty::br_fresh(id) => mywrite!(w, \"{}\", id),\n+        ty::br_anon(idx) => {\n+            mywrite!(w, \"a{}|\", idx);\n+        }\n+        ty::br_named(d, s) => {\n+            mywrite!(w, \"[{}|{}]\",\n+                     (cx.ds)(d),\n+                     cx.tcx.sess.str_of(s));\n+        }\n+        ty::br_fresh(id) => {\n+            mywrite!(w, \"f{}|\", id);\n+        }\n     }\n }\n \n@@ -366,13 +382,15 @@ fn enc_closure_ty(w: @mut MemWriter, cx: @ctxt, ft: &ty::ClosureTy) {\n }\n \n fn enc_fn_sig(w: @mut MemWriter, cx: @ctxt, fsig: &ty::FnSig) {\n-    mywrite!(w, \"[\");\n+    mywrite!(w, \"[{}|\", fsig.binder_id);\n     for ty in fsig.inputs.iter() {\n         enc_ty(w, cx, *ty);\n     }\n     mywrite!(w, \"]\");\n     if fsig.variadic {\n-        mywrite!(w, \"A\");\n+        mywrite!(w, \"V\");\n+    } else {\n+        mywrite!(w, \"N\");\n     }\n     enc_ty(w, cx, fsig.output);\n }"}, {"sha": "e60b9382be49af8952fe47aea86ac489f6ba27de", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 38, "deletions": 15, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -15,7 +15,8 @@ use driver::session::Session;\n use e = metadata::encoder;\n use metadata::decoder;\n use metadata::tydecode;\n-use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter};\n+use metadata::tydecode::{DefIdSource, NominalType, TypeWithId, TypeParameter,\n+                         RegionParameter};\n use metadata::tyencode;\n use middle::freevars::freevar_entry;\n use middle::typeck::{method_origin, method_map_entry};\n@@ -234,6 +235,12 @@ impl tr for ast::DefId {\n     }\n }\n \n+impl tr for Option<ast::DefId> {\n+    fn tr(&self, xcx: @ExtendedDecodeContext) -> Option<ast::DefId> {\n+        self.map(|d| xcx.tr_def_id(d))\n+    }\n+}\n+\n impl tr for Span {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> Span {\n         xcx.tr_span(*self)\n@@ -469,7 +476,11 @@ impl tr for ty::AutoRef {\n impl tr for ty::Region {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::Region {\n         match *self {\n-            ty::re_bound(br) => ty::re_bound(br.tr(xcx)),\n+            ty::re_fn_bound(id, br) => ty::re_fn_bound(xcx.tr_id(id),\n+                                                       br.tr(xcx)),\n+            ty::re_type_bound(id, index, ident) => ty::re_type_bound(xcx.tr_id(id),\n+                                                                     index,\n+                                                                     ident),\n             ty::re_scope(id) => ty::re_scope(xcx.tr_id(id)),\n             ty::re_empty | ty::re_static | ty::re_infer(*) => *self,\n             ty::re_free(ref fr) => {\n@@ -483,10 +494,10 @@ impl tr for ty::Region {\n impl tr for ty::bound_region {\n     fn tr(&self, xcx: @ExtendedDecodeContext) -> ty::bound_region {\n         match *self {\n-            ty::br_anon(_) | ty::br_named(_) | ty::br_self |\n+            ty::br_anon(_) |\n             ty::br_fresh(_) => *self,\n-            ty::br_cap_avoid(id, br) => ty::br_cap_avoid(xcx.tr_id(id),\n-                                                         @br.tr(xcx))\n+            ty::br_named(id, ident) => ty::br_named(xcx.tr_def_id(id),\n+                                                    ident),\n         }\n     }\n }\n@@ -821,8 +832,8 @@ impl ebml_writer_helpers for writer::Encoder {\n                             this.emit_type_param_def(ecx, type_param_def);\n                         }\n                     }\n-                    do this.emit_struct_field(\"region_param\", 1) |this| {\n-                        tpbt.generics.region_param.encode(this);\n+                    do this.emit_struct_field(\"region_param_defs\", 1) |this| {\n+                        tpbt.generics.region_param_defs.encode(this);\n                     }\n                 }\n             }\n@@ -1086,17 +1097,15 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n         // are not used during trans.\n \n         return do self.read_opaque |this, doc| {\n+            debug!(\"read_ty({})\", type_string(doc));\n+\n             let ty = tydecode::parse_ty_data(\n                 *doc.data,\n                 xcx.dcx.cdata.cnum,\n                 doc.start,\n                 xcx.dcx.tcx,\n                 |s, a| this.convert_def_id(xcx, s, a));\n \n-            debug!(\"read_ty({}) = {}\",\n-                   type_string(doc),\n-                   ty_to_str(xcx.dcx.tcx, ty));\n-\n             ty\n         };\n \n@@ -1139,8 +1148,8 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                                     @this.read_to_vec(|this|\n                                         this.read_type_param_def(xcx))\n                             }),\n-                            region_param:\n-                                this.read_struct_field(\"region_param\",\n+                            region_param_defs:\n+                                this.read_struct_field(\"region_param_defs\",\n                                                        1,\n                                                        |this| {\n                                     Decodable::decode(this)\n@@ -1161,7 +1170,6 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n                       did: ast::DefId)\n                       -> ast::DefId {\n         /*!\n-         *\n          * Converts a def-id that appears in a type.  The correct\n          * translation will depend on what kind of def-id this is.\n          * This is a subtle point: type definitions are not\n@@ -1172,10 +1180,25 @@ impl ebml_decoder_decoder_helpers for reader::Decoder {\n          * However, *type parameters* are cloned along with the function\n          * they are attached to.  So we should translate those def-ids\n          * to refer to the new, cloned copy of the type parameter.\n+         * We only see references to free type parameters in the body of\n+         * an inlined function. In such cases, we need the def-id to\n+         * be a local id so that the TypeContents code is able to lookup\n+         * the relevant info in the ty_param_defs table.\n+         *\n+         * *Region parameters*, unfortunately, are another kettle of fish.\n+         * In such cases, def_id's can appear in types to distinguish\n+         * shadowed bound regions and so forth. It doesn't actually\n+         * matter so much what we do to these, since regions are erased\n+         * at trans time, but it's good to keep them consistent just in\n+         * case. We translate them with `tr_def_id()` which will map\n+         * the crate numbers back to the original source crate.\n+         *\n+         * It'd be really nice to refactor the type repr to not include\n+         * def-ids so that all these distinctions were unnecessary.\n          */\n \n         let r = match source {\n-            NominalType | TypeWithId => xcx.tr_def_id(did),\n+            NominalType | TypeWithId | RegionParameter => xcx.tr_def_id(did),\n             TypeParameter => xcx.tr_intern_def_id(did)\n         };\n         debug!(\"convert_def_id(source={:?}, did={:?})={:?}\", source, did, r);"}, {"sha": "729da749ec6916799b1f9f1b28fcd5e76b104f3a", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -486,7 +486,8 @@ impl<'self> GatherLoanCtxt<'self> {\n                     }\n \n                     ty::re_empty |\n-                    ty::re_bound(*) |\n+                    ty::re_fn_bound(*) |\n+                    ty::re_type_bound(*) |\n                     ty::re_infer(*) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,"}, {"sha": "99f2d7a87002f6e59db24390da6c410acbe9fb5d", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -540,7 +540,7 @@ pub fn check_cast_for_escaping_regions(\n                 target_regions.push(r);\n             }\n         },\n-        |_| true);\n+        |_| ());\n \n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n@@ -582,7 +582,6 @@ pub fn check_cast_for_escaping_regions(\n                 }\n                 _ => {}\n             }\n-            true\n         });\n \n     fn is_re_scope(r: ty::Region) -> bool {"}, {"sha": "eeedd25adac28d5f23bd04d6bde3df977d40665c", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -781,7 +781,7 @@ impl<'self> Visitor<()> for PrivacyVisitor<'self> {\n                                 debug!(\"privacy - list {}\", pid.node.id);\n                                 let seg = ast::PathSegment {\n                                     identifier: pid.node.name,\n-                                    lifetime: None,\n+                                    lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 };\n                                 let segs = ~[seg];"}, {"sha": "23fef5e3516748e571b384bed4454be8af6f46cf", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -4182,7 +4182,7 @@ impl Resolver {\n \n                             if path.segments\n                                    .iter()\n-                                   .any(|s| s.lifetime.is_some()) {\n+                                   .any(|s| !s.lifetimes.is_empty()) {\n                                 self.session.span_err(path.span,\n                                                       \"lifetime parameters \\\n                                                        are not allowed on \\"}, {"sha": "7654a46ec3639db7ce631e41013370cdf6a86c86", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -173,35 +173,30 @@ impl Subst for ty::Generics {\n     fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::Generics {\n         ty::Generics {\n             type_param_defs: self.type_param_defs.subst(tcx, substs),\n-            region_param: self.region_param\n+            region_param_defs: self.region_param_defs.subst(tcx, substs),\n         }\n     }\n }\n \n+impl Subst for ty::RegionParameterDef {\n+    fn subst(&self, _: ty::ctxt, _: &ty::substs) -> ty::RegionParameterDef {\n+        *self\n+    }\n+}\n+\n impl Subst for ty::Region {\n-    fn subst(&self, tcx: ty::ctxt, substs: &ty::substs) -> ty::Region {\n-        // Note: This routine only handles the self region, because it\n-        // is only concerned with substitutions of regions that appear\n-        // in types. Region substitution of the bound regions that\n-        // appear in a function signature is done using the\n-        // specialized routine\n+    fn subst(&self, _tcx: ty::ctxt, substs: &ty::substs) -> ty::Region {\n+        // Note: This routine only handles regions that are bound on\n+        // type declarationss and other outer declarations, not those\n+        // bound in *fn types*. Region substitution of the bound\n+        // regions that appear in a function signature is done using\n+        // the specialized routine\n         // `middle::typeck::check::regionmanip::replace_bound_regions_in_fn_sig()`.\n-        // As we transition to the new region syntax this distinction\n-        // will most likely disappear.\n         match self {\n-            &ty::re_bound(ty::br_self) => {\n+            &ty::re_type_bound(_, i, _) => {\n                 match substs.regions {\n                     ty::ErasedRegions => ty::re_static,\n-                    ty::NonerasedRegions(ref regions) => {\n-                        if regions.len() != 1 {\n-                            tcx.sess.bug(\n-                                format!(\"ty::Region\\\\#subst(): \\\n-                                      Reference to self region when \\\n-                                      given substs with no self region: {}\",\n-                                     substs.repr(tcx)));\n-                        }\n-                        *regions.get(0)\n-                    }\n+                    ty::NonerasedRegions(ref regions) => *regions.get(i),\n                 }\n             }\n             _ => *self"}, {"sha": "66fba347acc13c67b1f2329507675b1f244a5e26", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 139, "deletions": 34, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -436,14 +436,17 @@ pub struct ClosureTy {\n  * Signature of a function type, which I have arbitrarily\n  * decided to use to refer to the input/output types.\n  *\n- * - `lifetimes` is the list of region names bound in this fn.\n+ * - `binder_id` is the node id where this fn type appeared;\n+ *   it is used to identify all the bound regions appearing\n+ *   in the input/output types that are bound by this fn type\n+ *   (vs some enclosing or enclosed fn type)\n  * - `inputs` is the list of arguments and their modes.\n  * - `output` is the return type.\n  * - `variadic` indicates whether this is a varidic function. (only true for foreign fns)\n  */\n #[deriving(Clone, Eq, IterBytes)]\n pub struct FnSig {\n-    bound_lifetime_names: OptVec<ast::Ident>,\n+    binder_id: ast::NodeId,\n     inputs: ~[t],\n     output: t,\n     variadic: bool\n@@ -458,16 +461,13 @@ pub struct param_ty {\n /// Representation of regions:\n #[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n pub enum Region {\n-    /// Bound regions are found (primarily) in function types.  They indicate\n-    /// region parameters that have yet to be replaced with actual regions\n-    /// (analogous to type parameters, except that due to the monomorphic\n-    /// nature of our type system, bound type parameters are always replaced\n-    /// with fresh type variables whenever an item is referenced, so type\n-    /// parameters only appear \"free\" in types.  Regions in contrast can\n-    /// appear free or bound.).  When a function is called, all bound regions\n-    /// tied to that function's node-id are replaced with fresh region\n-    /// variables whose value is then inferred.\n-    re_bound(bound_region),\n+    // Region bound in a type declaration (type/enum/struct/trait),\n+    // which will be substituted when an instance of the type is accessed\n+    re_type_bound(/* param id */ ast::NodeId, /*index*/ uint, ast::Ident),\n+\n+    // Region bound in a fn scope, which will be substituted when the\n+    // fn is called.\n+    re_fn_bound(/* binder_id */ ast::NodeId, bound_region),\n \n     /// When checking a function body, the types of all arguments and so forth\n     /// that refer to bound region parameters are modified to refer to free\n@@ -496,42 +496,32 @@ pub enum Region {\n impl Region {\n     pub fn is_bound(&self) -> bool {\n         match self {\n-            &re_bound(*) => true,\n+            &ty::re_type_bound(*) => true,\n+            &ty::re_fn_bound(*) => true,\n             _ => false\n         }\n     }\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n+#[deriving(Clone, Eq, TotalOrd, TotalEq, IterBytes, Encodable, Decodable, ToStr)]\n pub struct FreeRegion {\n     scope_id: NodeId,\n     bound_region: bound_region\n }\n \n-#[deriving(Clone, Eq, IterBytes, Encodable, Decodable, ToStr)]\n+#[deriving(Clone, Eq, TotalEq, TotalOrd, IterBytes, Encodable, Decodable, ToStr)]\n pub enum bound_region {\n-    /// The self region for structs, impls (&T in a type defn or &'self T)\n-    br_self,\n-\n     /// An anonymous region parameter for a given fn (&T)\n     br_anon(uint),\n \n     /// Named region parameters for functions (a in &'a T)\n-    br_named(ast::Ident),\n+    ///\n+    /// The def-id is needed to distinguish free regions in\n+    /// the event of shadowing.\n+    br_named(ast::DefId, ast::Ident),\n \n     /// Fresh bound identifiers created during GLB computations.\n     br_fresh(uint),\n-\n-    /**\n-     * Handles capture-avoiding substitution in a rather subtle case.  If you\n-     * have a closure whose argument types are being inferred based on the\n-     * expected type, and the expected type includes bound regions, then we\n-     * will wrap those bound regions in a br_cap_avoid() with the id of the\n-     * fn expression.  This ensures that the names are not \"captured\" by the\n-     * enclosing scope, which may define the same names.  For an example of\n-     * where this comes up, see src/test/compile-fail/regions-ret-borrowed.rs\n-     * and regions-ret-borrowed-1.rs. */\n-    br_cap_avoid(ast::NodeId, @bound_region),\n }\n \n /**\n@@ -868,12 +858,21 @@ pub struct TypeParameterDef {\n     bounds: @ParamBounds\n }\n \n-/// Information about the type/lifetime parametesr associated with an item.\n+#[deriving(Encodable, Decodable, Clone)]\n+pub struct RegionParameterDef {\n+    ident: ast::Ident,\n+    def_id: ast::DefId,\n+}\n+\n+/// Information about the type/lifetime parameters associated with an item.\n /// Analogous to ast::Generics.\n #[deriving(Clone)]\n pub struct Generics {\n+    /// List of type parameters declared on the item.\n     type_param_defs: @~[TypeParameterDef],\n-    region_param: Option<region_variance>,\n+\n+    /// List of region parameters declared on the item.\n+    region_param_defs: @[RegionParameterDef],\n }\n \n impl Generics {\n@@ -882,6 +881,33 @@ impl Generics {\n     }\n }\n \n+/// When type checking, we use the `ParameterEnvironment` to track\n+/// details about the type/lifetime parameters that are in scope.\n+/// It primarily stores the bounds information.\n+///\n+/// Note: This information might seem to be redundant with the data in\n+/// `tcx.ty_param_defs`, but it is not. That table contains the\n+/// parameter definitions from an \"outside\" perspective, but this\n+/// struct will contain the bounds for a parameter as seen from inside\n+/// the function body. Currently the only real distinction is that\n+/// bound lifetime parameters are replaced with free ones, but in the\n+/// future I hope to refine the representation of types so as to make\n+/// more distinctions clearer.\n+pub struct ParameterEnvironment {\n+    /// A substitution that can be applied to move from\n+    /// the \"outer\" view of a type or method to the \"inner\" view.\n+    /// In general, this means converting from bound parameters to\n+    /// free parameters. Since we currently represent bound/free type\n+    /// parameters in the same way, this only has an affect on regions.\n+    free_substs: ty::substs,\n+\n+    /// Bound on the Self parameter\n+    self_param_bound: Option<@TraitRef>,\n+\n+    /// Bounds on each numbered type parameter\n+    type_param_bounds: ~[ParamBounds],\n+}\n+\n /// A polytype.\n ///\n /// - `bounds`: The list of bounds for each type parameter.  The length of the\n@@ -1255,14 +1281,17 @@ pub fn mk_bare_fn(cx: ctxt, fty: BareFnTy) -> t {\n     mk_t(cx, ty_bare_fn(fty))\n }\n \n-pub fn mk_ctor_fn(cx: ctxt, input_tys: &[ty::t], output: ty::t) -> t {\n+pub fn mk_ctor_fn(cx: ctxt,\n+                  binder_id: ast::NodeId,\n+                  input_tys: &[ty::t],\n+                  output: ty::t) -> t {\n     let input_args = input_tys.map(|t| *t);\n     mk_bare_fn(cx,\n                BareFnTy {\n                    purity: ast::impure_fn,\n                    abis: AbiSet::Rust(),\n                    sig: FnSig {\n-                    bound_lifetime_names: opt_vec::Empty,\n+                    binder_id: binder_id,\n                     inputs: input_args,\n                     output: output,\n                     variadic: false\n@@ -4662,3 +4691,79 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n \n     hash.result_u64()\n }\n+\n+pub fn construct_parameter_environment(\n+    tcx: ctxt,\n+    self_bound: Option<@TraitRef>,\n+    item_type_params: &[TypeParameterDef],\n+    method_type_params: &[TypeParameterDef],\n+    item_region_params: &[RegionParameterDef],\n+    free_id: ast::NodeId)\n+    -> ParameterEnvironment\n+{\n+    /*! See `ParameterEnvironment` struct def'n for details */\n+\n+    //\n+    // Construct the free substs.\n+    //\n+\n+    // map Self => Self\n+    let self_ty = self_bound.map(|t| ty::mk_self(tcx, t.def_id));\n+\n+    // map A => A\n+    let num_item_type_params = item_type_params.len();\n+    let num_method_type_params = method_type_params.len();\n+    let num_type_params = num_item_type_params + num_method_type_params;\n+    let type_params = vec::from_fn(num_type_params, |i| {\n+            let def_id = if i < num_item_type_params {\n+                item_type_params[i].def_id\n+            } else {\n+                method_type_params[i - num_item_type_params].def_id\n+            };\n+\n+            ty::mk_param(tcx, i, def_id)\n+        });\n+\n+    // map bound 'a => free 'a\n+    let region_params = item_region_params.iter().\n+        map(|r| ty::re_free(ty::FreeRegion {\n+                scope_id: free_id,\n+                bound_region: ty::br_named(r.def_id, r.ident)})).\n+        collect();\n+\n+    let free_substs = substs {\n+        self_ty: self_ty,\n+        tps: type_params,\n+        regions: ty::NonerasedRegions(region_params)\n+    };\n+\n+    //\n+    // Compute the bounds on Self and the type parameters.\n+    //\n+\n+    let self_bound_substd = self_bound.map(|b| b.subst(tcx, &free_substs));\n+    let type_param_bounds_substd = vec::from_fn(num_type_params, |i| {\n+        if i < num_item_type_params {\n+            (*item_type_params[i].bounds).subst(tcx, &free_substs)\n+        } else {\n+            let j = i - num_item_type_params;\n+            (*method_type_params[j].bounds).subst(tcx, &free_substs)\n+        }\n+    });\n+\n+    ty::ParameterEnvironment {\n+        free_substs: free_substs,\n+        self_param_bound: self_bound_substd,\n+        type_param_bounds: type_param_bounds_substd,\n+    }\n+}\n+\n+impl substs {\n+    pub fn empty() -> substs {\n+        substs {\n+            self_ty: None,\n+            tps: ~[],\n+            regions: NonerasedRegions(opt_vec::Empty)\n+        }\n+    }\n+}"}, {"sha": "0c0abaa5d76cf8036f92bae071eef4539c20231c", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 44, "deletions": 60, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -154,13 +154,11 @@ pub fn opt_ast_region_to_region<AC:AstConv,RS:RegionScope>(\n fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n-    def_id: ast::DefId,\n     decl_generics: &ty::Generics,\n     self_ty: Option<ty::t>,\n     path: &ast::Path) -> ty::substs\n {\n     /*!\n-     *\n      * Given a path `path` that refers to an item `I` with the\n      * declared generics `decl_generics`, returns an appropriate\n      * set of substitutions for this particular reference to `I`.\n@@ -171,30 +169,28 @@ fn ast_path_substs<AC:AstConv,RS:RegionScope>(\n     // If the type is parameterized by the this region, then replace this\n     // region with the current anon region binding (in other words,\n     // whatever & would get replaced with).\n-    let regions = match (&decl_generics.region_param,\n-                         &path.segments.last().lifetime) {\n-        (&None, &None) => {\n-            opt_vec::Empty\n-        }\n-        (&None, &Some(_)) => {\n+    let expected_num_region_params = decl_generics.region_param_defs.len();\n+    let supplied_num_region_params = path.segments.last().lifetimes.len();\n+    let regions = if expected_num_region_params == supplied_num_region_params {\n+        path.segments.last().lifetimes.map(\n+            |l| ast_region_to_region(this.tcx(), l))\n+    } else {\n+        let anon_regions =\n+            rscope.anon_regions(path.span, expected_num_region_params);\n+\n+        if supplied_num_region_params != 0 || anon_regions.is_none() {\n             tcx.sess.span_err(\n                 path.span,\n-                format!(\"no region bound is allowed on `{}`, \\\n-                      which is not declared as containing region pointers\",\n-                     ty::item_path_str(tcx, def_id)));\n-            opt_vec::Empty\n-        }\n-        (&Some(_), &None) => {\n-            let res = rscope.anon_region(path.span);\n-            let r = get_region_reporting_err(this.tcx(), path.span, &None, res);\n-            opt_vec::with(r)\n+                format!(\"wrong number of lifetime parameters: \\\n+                        expected {} but found {}\",\n+                        expected_num_region_params,\n+                        supplied_num_region_params));\n         }\n-        (&Some(_), &Some(_)) => {\n-            opt_vec::with(\n-                ast_region_to_region(this,\n-                                     rscope,\n-                                     path.span,\n-                                     &path.segments.last().lifetime))\n+\n+        match anon_regions {\n+            Some(v) => opt_vec::from(v),\n+            None => opt_vec::from(vec::from_fn(expected_num_region_params,\n+                                               |_| ty::re_static)) // hokey\n         }\n     };\n \n@@ -234,7 +230,7 @@ pub fn ast_path_to_substs_and_ty<AC:AstConv,\n         ty: decl_ty\n     } = this.get_item_ty(did);\n \n-    let substs = ast_path_substs(this, rscope, did, &generics, None, path);\n+    let substs = ast_path_substs(this, rscope, &generics, None, path);\n     let ty = ty::subst(tcx, &substs, decl_ty);\n     ty_param_substs_and_ty { substs: substs, ty: ty }\n }\n@@ -252,7 +248,6 @@ pub fn ast_path_to_trait_ref<AC:AstConv,RS:RegionScope>(\n         ast_path_substs(\n             this,\n             rscope,\n-            trait_def.trait_ref.def_id,\n             &trait_def.generics,\n             self_ty,\n             path);\n@@ -304,13 +299,15 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         constr: &fn(ty::mt) -> ty::t) -> ty::t\n     {\n         let tcx = this.tcx();\n+        debug!(\"mk_pointer(vst={:?})\", vst);\n \n         match a_seq_ty.ty.node {\n             ast::ty_vec(ref mt) => {\n                 let mut mt = ast_mt_to_mt(this, rscope, mt);\n                 if a_seq_ty.mutbl == ast::MutMutable {\n                     mt = ty::mt { ty: mt.ty, mutbl: a_seq_ty.mutbl };\n                 }\n+                debug!(\"&[]: vst={:?}\", vst);\n                 return ty::mk_evec(tcx, mt, vst);\n             }\n             ast::ty_path(ref path, ref bounds, id) => {\n@@ -369,7 +366,7 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n         }\n \n         if (flags & NO_REGIONS) != 0u {\n-            if path.segments.last().lifetime.is_some() {\n+            if !path.segments.last().lifetimes.is_empty() {\n                 tcx.sess.span_err(\n                     path.span,\n                     \"region parameters are not allowed on this type\");\n@@ -422,8 +419,8 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n           if bf.decl.variadic && !bf.abis.is_c() {\n             tcx.sess.span_err(ast_ty.span, \"variadic function must have C calling convention\");\n           }\n-          ty::mk_bare_fn(tcx, ty_of_bare_fn(this, rscope, bf.purity,\n-                                            bf.abis, &bf.lifetimes, &bf.decl))\n+          ty::mk_bare_fn(tcx, ty_of_bare_fn(this, ast_ty.id, bf.purity,\n+                                            bf.abis, &bf.decl))\n       }\n       ast::ty_closure(ref f) => {\n         if f.sigil == ast::ManagedSigil {\n@@ -440,14 +437,14 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:RegionScope>(\n           });\n           let fn_decl = ty_of_closure(this,\n                                       rscope,\n+                                      ast_ty.id,\n                                       f.sigil,\n                                       f.purity,\n                                       f.onceness,\n                                       bounds,\n                                       &f.region,\n                                       &f.decl,\n                                       None,\n-                                      &f.lifetimes,\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n@@ -594,9 +591,8 @@ struct SelfInfo {\n \n pub fn ty_of_method<AC:AstConv>(\n     this: &AC,\n-    rscope: &RS,\n+    id: ast::NodeId,\n     purity: ast::purity,\n-    lifetimes: &OptVec<ast::Lifetime>,\n     untransformed_self_ty: ty::t,\n     explicit_self: ast::explicit_self,\n     decl: &ast::fn_decl) -> (Option<ty::t>, ty::BareFnTy)\n@@ -606,33 +602,31 @@ pub fn ty_of_method<AC:AstConv>(\n         explicit_self: explicit_self\n     };\n     let (a, b) = ty_of_method_or_bare_fn(\n-        this, rscope, purity, AbiSet::Rust(), lifetimes, Some(&self_info), decl);\n+        this, id, purity, AbiSet::Rust(), Some(&self_info), decl);\n     (a.unwrap(), b)\n }\n \n-pub fn ty_of_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+pub fn ty_of_bare_fn<AC:AstConv>(\n     this: &AC,\n-    rscope: &RS,\n+    id: ast::NodeId,\n     purity: ast::purity,\n     abi: AbiSet,\n-    lifetimes: &OptVec<ast::Lifetime>,\n     decl: &ast::fn_decl) -> ty::BareFnTy\n {\n-    let (_, b) = ty_of_method_or_bare_fn(\n-        this, rscope, purity, abi, lifetimes, None, decl);\n+    let (_, b) = ty_of_method_or_bare_fn(this, id, purity,\n+                                         abi, None, decl);\n     b\n }\n \n-fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n+fn ty_of_method_or_bare_fn<AC:AstConv>(\n     this: &AC,\n-    rscope: &RS,\n+    id: ast::NodeId,\n     purity: ast::purity,\n     abi: AbiSet,\n-    lifetimes: &OptVec<ast::Lifetime>,\n     opt_self_info: Option<&SelfInfo>,\n     decl: &ast::fn_decl) -> (Option<Option<ty::t>>, ty::BareFnTy)\n {\n-    debug!(\"ty_of_bare_fn\");\n+    debug!(\"ty_of_method_or_bare_fn\");\n \n     // new region names that appear inside of the fn decl are bound to\n     // that function type\n@@ -653,12 +647,10 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n             ty::BareFnTy {\n                 purity: purity,\n                 abis: abi,\n-                sig: ty::FnSig {\n-                    bound_lifetime_names: bound_lifetime_names,\n-                    inputs: input_tys,\n-                    output: output_ty,\n-                    variadic: decl.variadic\n-                }\n+                sig: ty::FnSig {binder_id: id,\n+                                inputs: input_tys,\n+                                output: output_ty,\n+                                variadic: decl.variadic}\n             });\n \n     fn transform_self_ty<AC:AstConv,RS:RegionScope>(\n@@ -697,24 +689,18 @@ fn ty_of_method_or_bare_fn<AC:AstConv,RS:RegionScope + Clone + 'static>(\n pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n     this: &AC,\n     rscope: &RS,\n+    id: ast::NodeId,\n     sigil: ast::Sigil,\n     purity: ast::purity,\n     onceness: ast::Onceness,\n     bounds: ty::BuiltinBounds,\n     opt_lifetime: &Option<ast::Lifetime>,\n     decl: &ast::fn_decl,\n     expected_sig: Option<ty::FnSig>,\n-    lifetimes: &OptVec<ast::Lifetime>,\n     span: Span)\n     -> ty::ClosureTy\n {\n-    // The caller should not both provide explicit bound lifetime\n-    // names and expected types.  Either we infer the bound lifetime\n-    // names or they are provided, but not both.\n-    assert!(lifetimes.is_empty() || expected_sig.is_none());\n-\n     debug!(\"ty_of_fn_decl\");\n-    let _i = indenter();\n \n     // resolve the function bound region in the original region\n     // scope `rscope`, not the scope of the function parameters\n@@ -763,12 +749,10 @@ pub fn ty_of_closure<AC:AstConv,RS:RegionScope>(\n         onceness: onceness,\n         region: bound_region,\n         bounds: bounds,\n-        sig: ty::FnSig {\n-            bound_lifetime_names: bound_lifetime_names,\n-            inputs: input_tys,\n-            output: output_ty,\n-            variadic: decl.variadic\n-        }\n+        sig: ty::FnSig {binder_id: id,\n+                        inputs: input_tys,\n+                        output: output_ty,\n+                        variadic: decl.variadic}\n     }\n }\n "}, {"sha": "870b29882fd6eb167309d3e5a92a56009476f930", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 12, "deletions": 31, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -85,7 +85,6 @@ use middle::ty::*;\n use middle::ty;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n-use middle::typeck::check::vtable::VtableContext;\n use middle::typeck::check::vtable;\n use middle::typeck::check;\n use middle::typeck::infer;\n@@ -99,7 +98,6 @@ use util::ppaux::Repr;\n use std::hashmap::HashSet;\n use std::result;\n use std::vec;\n-use extra::list::Nil;\n use syntax::ast::{DefId, sty_value, sty_region, sty_box};\n use syntax::ast::{sty_uniq, sty_static, NodeId};\n use syntax::ast::{MutMutable, MutImmutable};\n@@ -265,8 +263,7 @@ impl<'self> LookupContext<'self> {\n         self.search_for_autosliced_method(self_ty, autoderefs)\n     }\n \n-    fn deref(&self, ty: ty::t)\n-                 -> Option<ty::t> {\n+    fn deref(&self, ty: ty::t) -> Option<ty::t> {\n         match ty::deref(self.tcx(), ty, false) {\n             None => None,\n             Some(t) => {\n@@ -327,11 +324,10 @@ impl<'self> LookupContext<'self> {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, p);\n                 }\n-                ty_self(self_did) => {\n+                ty_self(*) => {\n                     // Call is of the form \"self.foo()\" and appears in one\n                     // of a trait's default method implementations.\n-                    self.push_inherent_candidates_from_self(\n-                        self_ty, self_did);\n+                    self.push_inherent_candidates_from_self(self_ty);\n                 }\n                 _ => { /* No bound methods in these types */ }\n             }\n@@ -448,32 +444,20 @@ impl<'self> LookupContext<'self> {\n                                            param_ty: param_ty) {\n         debug!(\"push_inherent_candidates_from_param(param_ty={:?})\",\n                param_ty);\n-        let _indenter = indenter();\n-\n-        let tcx = self.tcx();\n-        let type_param_def = match tcx.ty_param_defs.find(&param_ty.def_id.node) {\n-            Some(t) => t,\n-            None => {\n-                tcx.sess.span_bug(\n-                    self.expr.span,\n-                    format!(\"No param def for {:?}\", param_ty));\n-            }\n-        };\n-\n         self.push_inherent_candidates_from_bounds(\n-            rcvr_ty, type_param_def.bounds.trait_bounds,\n+            rcvr_ty,\n+            self.fcx.inh.param_env.type_param_bounds[param_ty.idx].trait_bounds,\n             param_numbered(param_ty.idx));\n     }\n \n \n     fn push_inherent_candidates_from_self(&self,\n-                                              self_ty: ty::t,\n-                                              did: DefId) {\n-        let tcx = self.tcx();\n-\n-        let trait_ref = ty::lookup_trait_def(tcx, did).trait_ref;\n+                                          rcvr_ty: ty::t) {\n+        debug!(\"push_inherent_candidates_from_self()\");\n         self.push_inherent_candidates_from_bounds(\n-            self_ty, &[trait_ref], param_self);\n+            rcvr_ty,\n+            [self.fcx.inh.param_env.self_param_bound.unwrap()],\n+            param_self)\n     }\n \n     fn push_inherent_candidates_from_bounds(&self,\n@@ -574,10 +558,7 @@ impl<'self> LookupContext<'self> {\n         // determine the `self` of the impl with fresh\n         // variables for each parameter:\n         let location_info = &vtable::location_info_for_expr(self.self_expr);\n-        let vcx = VtableContext {\n-            ccx: self.fcx.ccx,\n-            infcx: self.fcx.infcx()\n-        };\n+        let vcx = self.fcx.vtable_context();\n         let ty::ty_param_substs_and_ty {\n             substs: impl_substs,\n             ty: impl_ty\n@@ -1010,7 +991,7 @@ impl<'self> LookupContext<'self> {\n         };\n         let (_, opt_transformed_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n-                tcx, @Nil, Some(transformed_self_ty), &bare_fn_ty.sig,\n+                tcx, Some(transformed_self_ty), &bare_fn_ty.sig,\n                 |br| self.fcx.infcx().next_region_var(\n                     infer::BoundRegionInFnCall(self.expr.span, br)));\n         let transformed_self_ty = opt_transformed_self_ty.unwrap();"}, {"sha": "982bc493417677c053a34e361653e046dcfa4717", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 235, "deletions": 312, "changes": 547, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -81,10 +81,12 @@ use middle::const_eval;\n use middle::pat_util::pat_id_map;\n use middle::pat_util;\n use middle::lint::unreachable_code;\n+use middle::subst::Subst;\n use middle::ty::{FnSig, VariantInfo};\n use middle::ty::{ty_param_bounds_and_ty, ty_param_substs_and_ty};\n use middle::ty::{substs, param_ty, Disr, ExprTyProvider};\n use middle::ty;\n+use middle::ty_fold::TypeFolder;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::astconv::{ast_region_to_region, ast_ty_to_ty};\n use middle::typeck::astconv;\n@@ -99,22 +101,18 @@ use middle::typeck::check::vtable::{LocationInfo, VtableContext};\n use middle::typeck::CrateCtxt;\n use middle::typeck::infer::{resolve_type, force_tvar};\n use middle::typeck::infer;\n-use middle::typeck::rscope::bound_self_region;\n-use middle::typeck::rscope::{RegionError};\n use middle::typeck::rscope::RegionScope;\n-use middle::typeck::{isr_alist, lookup_def_ccx};\n+use middle::typeck::{lookup_def_ccx};\n use middle::typeck::no_params;\n use middle::typeck::{require_same_types, method_map, vtable_map};\n use util::common::{block_query, indenter, loop_query};\n-use util::ppaux::{bound_region_ptr_to_str};\n+use util::ppaux::UserString;\n use util::ppaux;\n \n-\n use std::hashmap::HashMap;\n use std::result;\n use std::util::replace;\n use std::vec;\n-use extra::list::Nil;\n use syntax::abi::AbiSet;\n use syntax::ast::{provided, required};\n use syntax::ast;\n@@ -127,7 +125,6 @@ use syntax::codemap;\n use syntax::opt_vec::OptVec;\n use syntax::opt_vec;\n use syntax::parse::token;\n-use syntax::parse::token::special_idents;\n use syntax::print::pprust;\n use syntax::visit;\n use syntax::visit::Visitor;\n@@ -157,9 +154,10 @@ pub struct SelfInfo {\n /// Here, the function `foo()` and the closure passed to\n /// `bar()` will each have their own `FnCtxt`, but they will\n /// share the inherited fields.\n-pub struct inherited {\n+pub struct Inherited {\n     infcx: @mut infer::InferCtxt,\n     locals: @mut HashMap<ast::NodeId, ty::t>,\n+    param_env: ty::ParameterEnvironment,\n \n     // Temporary tables:\n     node_types: @mut HashMap<ast::NodeId, ty::t>,\n@@ -249,40 +247,45 @@ pub struct FnCtxt {\n     // function return type.\n     fn_kind: FnKind,\n \n-    in_scope_regions: isr_alist,\n-\n-    inh: @inherited,\n+    inh: @Inherited,\n \n     ccx: @mut CrateCtxt,\n }\n \n-pub fn blank_inherited(ccx: @mut CrateCtxt) -> @inherited {\n-    @inherited {\n-        infcx: infer::new_infer_ctxt(ccx.tcx),\n-        locals: @mut HashMap::new(),\n-        node_types: @mut HashMap::new(),\n-        node_type_substs: @mut HashMap::new(),\n-        adjustments: @mut HashMap::new(),\n-        method_map: @mut HashMap::new(),\n-        vtable_map: @mut HashMap::new(),\n+impl Inherited {\n+    fn new(tcx: ty::ctxt,\n+           param_env: ty::ParameterEnvironment)\n+           -> Inherited {\n+        Inherited {\n+            infcx: infer::new_infer_ctxt(tcx),\n+            locals: @mut HashMap::new(),\n+            param_env: param_env,\n+            node_types: @mut HashMap::new(),\n+            node_type_substs: @mut HashMap::new(),\n+            adjustments: @mut HashMap::new(),\n+            method_map: @mut HashMap::new(),\n+            vtable_map: @mut HashMap::new(),\n+        }\n     }\n }\n \n // Used by check_const and check_enum_variants\n pub fn blank_fn_ctxt(ccx: @mut CrateCtxt,\n                      rty: ty::t,\n                      region_bnd: ast::NodeId)\n-                  -> @mut FnCtxt {\n-// It's kind of a kludge to manufacture a fake function context\n-// and statement context, but we might as well do write the code only once\n+                     -> @mut FnCtxt {\n+    // It's kind of a kludge to manufacture a fake function context\n+    // and statement context, but we might as well do write the code only once\n+    let param_env = ty::ParameterEnvironment { free_substs: substs::empty(),\n+                                               self_param_bound: None,\n+                                               type_param_bounds: ~[] };\n     @mut FnCtxt {\n         err_count_on_creation: ccx.tcx.sess.err_count(),\n         ret_ty: rty,\n         ps: PurityState::function(ast::impure_fn, 0),\n         region_lb: region_bnd,\n-        in_scope_regions: @Nil,\n         fn_kind: Vanilla,\n-        inh: blank_inherited(ccx),\n+        inh: @Inherited::new(ccx.tcx, param_env),\n         ccx: ccx\n     }\n }\n@@ -315,14 +318,15 @@ pub fn check_bare_fn(ccx: @mut CrateCtxt,\n                      decl: &ast::fn_decl,\n                      body: &ast::Block,\n                      id: ast::NodeId,\n-                     self_info: Option<SelfInfo>) {\n-    let fty = ty::node_id_to_type(ccx.tcx, id);\n+                     self_info: Option<SelfInfo>,\n+                     fty: ty::t,\n+                     param_env: ty::ParameterEnvironment) {\n     match ty::get(fty).sty {\n         ty::ty_bare_fn(ref fn_ty) => {\n             let fcx =\n                 check_fn(ccx, self_info, fn_ty.purity,\n                          &fn_ty.sig, decl, id, body, Vanilla,\n-                         @Nil, blank_inherited(ccx));;\n+                         @Inherited::new(ccx.tcx, param_env));\n \n             vtable::resolve_in_block(fcx, body);\n             regionck::regionck_fn(fcx, body);\n@@ -411,39 +415,35 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n                 id: ast::NodeId,\n                 body: &ast::Block,\n                 fn_kind: FnKind,\n-                inherited_isr: isr_alist,\n-                inherited: @inherited) -> @mut FnCtxt\n+                inherited: @Inherited) -> @mut FnCtxt\n {\n     /*!\n-     *\n      * Helper used by check_bare_fn and check_expr_fn.  Does the\n      * grungy work of checking a function body and returns the\n      * function context used for that purpose, since in the case of a\n      * fn item there is still a bit more to do.\n      *\n      * - ...\n-     * - inherited_isr: regions in scope from the enclosing fn (if any)\n      * - inherited: other fields inherited from the enclosing fn (if any)\n      */\n \n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n-    // ______________________________________________________________________\n     // First, we have to replace any bound regions in the fn and self\n     // types with free ones.  The free region references will be bound\n     // the node_id of the body block.\n-    let (isr, opt_self_info, fn_sig) = {\n+    let (opt_self_info, fn_sig) = {\n         let opt_self_ty = opt_self_info.map(|i| i.self_ty);\n-        let (isr, opt_self_ty, fn_sig) =\n+        let (_, opt_self_ty, fn_sig) =\n             replace_bound_regions_in_fn_sig(\n-                tcx, inherited_isr, opt_self_ty, fn_sig,\n+                tcx, opt_self_ty, fn_sig,\n                 |br| ty::re_free(ty::FreeRegion {scope_id: body.id,\n                                                  bound_region: br}));\n         let opt_self_info =\n             opt_self_info.map(\n                 |si| SelfInfo {self_ty: opt_self_ty.unwrap(), .. si});\n-        (isr, opt_self_info, fn_sig)\n+        (opt_self_info, fn_sig)\n     };\n \n     relate_free_regions(tcx, opt_self_info.map(|s| s.self_ty), &fn_sig);\n@@ -456,7 +456,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n            ppaux::ty_to_str(tcx, ret_ty),\n            opt_self_info.map(|si| ppaux::ty_to_str(tcx, si.self_ty)));\n \n-    // ______________________________________________________________________\n     // Create the function context.  This is either derived from scratch or,\n     // in the case of function expressions, based on the outer context.\n     let fcx: @mut FnCtxt = {\n@@ -465,7 +464,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n             ret_ty: ret_ty,\n             ps: PurityState::function(purity, id),\n             region_lb: body.id,\n-            in_scope_regions: isr,\n             fn_kind: fn_kind,\n             inh: inherited,\n             ccx: ccx\n@@ -536,26 +534,6 @@ pub fn check_fn(ccx: @mut CrateCtxt,\n     }\n }\n \n-pub fn check_method(ccx: @mut CrateCtxt,\n-                    method: @ast::method)\n-{\n-    let method_def_id = local_def(method.id);\n-    let method_ty = ty::method(ccx.tcx, method_def_id);\n-    let opt_self_info = method_ty.transformed_self_ty.map(|ty| {\n-        SelfInfo {self_ty: ty,\n-                  self_id: method.self_id,\n-                  span: method.explicit_self.span}\n-    });\n-\n-    check_bare_fn(\n-        ccx,\n-        &method.decl,\n-        &method.body,\n-        method.id,\n-        opt_self_info\n-    );\n-}\n-\n pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n                                  fields: ~[(ast::Ident, Span)]) {\n     let mut field_names = HashMap::new();\n@@ -566,7 +544,7 @@ pub fn check_no_duplicate_fields(tcx: ty::ctxt,\n         match orig_sp {\n             Some(orig_sp) => {\n                 tcx.sess.span_err(sp, format!(\"Duplicate field name {} in record type declaration\",\n-                                           tcx.sess.str_of(id)));\n+                                              tcx.sess.str_of(id)));\n                 tcx.sess.span_note(orig_sp, \"First declaration of this field occurred here\");\n                 break;\n             }\n@@ -603,26 +581,41 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n                             it.id);\n       }\n       ast::item_fn(ref decl, _, _, _, ref body) => {\n-        check_bare_fn(ccx, decl, body, it.id, None);\n+        let fn_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n+\n+            // FIXME -- this won't fly for the case where people reference\n+            // a lifetime from within a type parameter. That's actually fairly\n+            // tricky.\n+        let param_env = ty::construct_parameter_environment(\n+                ccx.tcx,\n+                None,\n+                *fn_tpt.generics.type_param_defs,\n+                [],\n+                [],\n+                body.id);\n+\n+        check_bare_fn(ccx, decl, body, it.id, None, fn_tpt.ty, param_env);\n       }\n-      ast::item_impl(_, _, _, ref ms) => {\n-        let rp = ccx.tcx.region_paramd_items.find(&it.id).map(|x| *x);\n-        debug!(\"item_impl {} with id {} rp {:?}\",\n-               ccx.tcx.sess.str_of(it.ident), it.id, rp);\n+      ast::item_impl(_, ref opt_trait_ref, _, ref ms) => {\n+        debug!(\"item_impl {} with id {}\", ccx.tcx.sess.str_of(it.ident), it.id);\n+\n+        let impl_tpt = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         for m in ms.iter() {\n-            check_method(ccx, *m);\n+            check_method_body(ccx, &impl_tpt.generics, None, *m);\n         }\n         vtable::resolve_impl(ccx, it);\n       }\n       ast::item_trait(_, _, ref trait_methods) => {\n+        let trait_def = ty::lookup_trait_def(ccx.tcx, local_def(it.id));\n         for trait_method in (*trait_methods).iter() {\n             match *trait_method {\n               required(*) => {\n                 // Nothing to do, since required methods don't have\n                 // bodies to check.\n               }\n               provided(m) => {\n-                check_method(ccx, m);\n+                check_method_body(ccx, &trait_def.generics,\n+                                  Some(trait_def.trait_ref), m);\n               }\n             }\n         }\n@@ -662,6 +655,58 @@ pub fn check_item(ccx: @mut CrateCtxt, it: @ast::item) {\n     }\n }\n \n+fn check_method_body(ccx: @mut CrateCtxt,\n+                     item_generics: &ty::Generics,\n+                     self_bound: Option<@ty::TraitRef>,\n+                     method: @ast::method) {\n+    /*!\n+     * Type checks a method body.\n+     *\n+     * # Parameters\n+     * - `item_generics`: generics defined on the impl/trait that contains\n+     *   the method\n+     * - `self_bound`: bound for the `Self` type parameter, if any\n+     * - `method`: the method definition\n+     */\n+\n+    debug!(\"check_method_body(item_generics={}, \\\n+            self_bound={}, \\\n+            method.id={})\",\n+            item_generics.repr(ccx.tcx),\n+            self_bound.repr(ccx.tcx),\n+            method.id);\n+    let method_def_id = local_def(method.id);\n+    let method_ty = ty::method(ccx.tcx, method_def_id);\n+    let method_generics = &method_ty.generics;\n+\n+    let param_env =\n+        ty::construct_parameter_environment(\n+            ccx.tcx,\n+            self_bound,\n+            *item_generics.type_param_defs,\n+            *method_generics.type_param_defs,\n+            item_generics.region_param_defs,\n+            method.body.id);\n+\n+    // Compute the self type and fty from point of view of inside fn\n+    let opt_self_info = method_ty.transformed_self_ty.map(|ty| {\n+        SelfInfo {self_ty: ty.subst(ccx.tcx, &param_env.free_substs),\n+                  self_id: method.self_id,\n+                  span: method.explicit_self.span}\n+    });\n+    let fty = ty::node_id_to_type(ccx.tcx, method.id);\n+    let fty = fty.subst(ccx.tcx, &param_env.free_substs);\n+\n+    check_bare_fn(\n+        ccx,\n+        &method.decl,\n+        &method.body,\n+        method.id,\n+        opt_self_info,\n+        fty,\n+        param_env);\n+}\n+\n impl AstConv for FnCtxt {\n     fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n \n@@ -682,48 +727,26 @@ impl FnCtxt {\n     pub fn infcx(&self) -> @mut infer::InferCtxt {\n         self.inh.infcx\n     }\n+\n     pub fn err_count_since_creation(&self) -> uint {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n-    pub fn search_in_scope_regions(&self,\n-                                   span: Span,\n-                                   br: ty::bound_region)\n-                                   -> Result<ty::Region, RegionError> {\n-        let in_scope_regions = self.in_scope_regions;\n-        match in_scope_regions.find(br) {\n-            Some(r) => result::Ok(r),\n-            None => {\n-                let blk_br = ty::br_named(special_idents::blk);\n-                if br == blk_br {\n-                    result::Ok(self.block_region())\n-                } else {\n-                    result::Err(RegionError {\n-                        msg: {\n-                            format!(\"named region `{}` not in scope here\",\n-                                 bound_region_ptr_to_str(self.tcx(), br))\n-                        },\n-                        replacement: {\n-                            self.infcx().next_region_var(\n-                                infer::BoundRegionError(span))\n-                        }\n-                    })\n-                }\n-            }\n+\n+    pub fn vtable_context<'a>(&'a self) -> VtableContext<'a> {\n+        VtableContext {\n+            infcx: self.infcx(),\n+            param_env: &self.inh.param_env\n         }\n     }\n }\n \n-impl RegionScope for FnCtxt {\n-    fn anon_region(&self, span: Span) -> Result<ty::Region, RegionError> {\n-        result::Ok(self.infcx().next_region_var(infer::MiscVariable(span)))\n-    }\n-    fn self_region(&self, span: Span) -> Result<ty::Region, RegionError> {\n-        self.search_in_scope_regions(span, ty::br_self)\n-    }\n-    fn named_region(&self,\n+impl RegionScope for @mut infer::InferCtxt {\n+    fn anon_regions(&self,\n                     span: Span,\n-                    id: ast::Ident) -> Result<ty::Region, RegionError> {\n-        self.search_in_scope_regions(span, ty::br_named(id))\n+                    count: uint) -> Option<~[ty::Region]> {\n+        Some(vec::from_fn(\n+                count,\n+                |_| self.next_region_var(infer::MiscVariable(span))))\n     }\n }\n \n@@ -805,7 +828,7 @@ impl FnCtxt {\n     }\n \n     pub fn to_ty(&self, ast_t: &ast::Ty) -> ty::t {\n-        ast_ty_to_ty(self, self, ast_t)\n+        ast_ty_to_ty(self, &self.infcx(), ast_t)\n     }\n \n     pub fn pat_to_str(&self, pat: @ast::Pat) -> ~str {\n@@ -817,7 +840,7 @@ impl FnCtxt {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n-                                         self.tag()));\n+                                            self.tag()));\n             }\n         }\n     }\n@@ -828,10 +851,10 @@ impl FnCtxt {\n             None => {\n                 self.tcx().sess.bug(\n                     format!(\"no type for node {}: {} in fcx {}\",\n-                         id, ast_map::node_id_to_str(\n-                             self.tcx().items, id,\n-                             token::get_ident_interner()),\n-                         self.tag()));\n+                            id, ast_map::node_id_to_str(\n+                                self.tcx().items, id,\n+                                token::get_ident_interner()),\n+                            self.tag()));\n             }\n         }\n     }\n@@ -842,10 +865,9 @@ impl FnCtxt {\n             None => {\n                 self.tcx().sess.bug(\n                     format!(\"no type substs for node {}: {} in fcx {}\",\n-                         id, ast_map::node_id_to_str(\n-                             self.tcx().items, id,\n-                             token::get_ident_interner()),\n-                         self.tag()));\n+                            id, ast_map::node_id_to_str(self.tcx().items, id,\n+                                                        token::get_ident_interner()),\n+                            self.tag()));\n             }\n         }\n     }\n@@ -924,20 +946,6 @@ impl FnCtxt {\n         v\n     }\n \n-    pub fn region_var_if_parameterized(&self,\n-                                       rp: Option<ty::region_variance>,\n-                                       span: Span)\n-                                       -> OptVec<ty::Region> {\n-        match rp {\n-            None => opt_vec::Empty,\n-            Some(_) => {\n-                opt_vec::with(\n-                    self.infcx().next_region_var(\n-                        infer::BoundRegionInTypeOrImpl(span)))\n-            }\n-        }\n-    }\n-\n     pub fn type_error_message(&self,\n                               sp: Span,\n                               mk_msg: &fn(~str) -> ~str,\n@@ -1105,20 +1113,22 @@ pub fn impl_self_ty(vcx: &VtableContext,\n                  -> ty_param_substs_and_ty {\n     let tcx = vcx.tcx();\n \n-    let (n_tps, region_param, raw_ty) = {\n+    let (n_tps, n_rps, raw_ty) = {\n         let ity = ty::lookup_item_type(tcx, did);\n-        (ity.generics.type_param_defs.len(), ity.generics.region_param, ity.ty)\n+        (ity.generics.type_param_defs.len(),\n+         ity.generics.region_param_defs.len(),\n+         ity.ty)\n     };\n \n-    let regions = ty::NonerasedRegions(if region_param.is_some() {\n-        opt_vec::with(vcx.infcx.next_region_var(\n-            infer::BoundRegionInTypeOrImpl(location_info.span)))\n-    } else {\n-        opt_vec::Empty\n-    });\n+    let rps =\n+        vcx.infcx.next_region_vars(\n+            infer::BoundRegionInTypeOrImpl(location_info.span),\n+            n_rps);\n     let tps = vcx.infcx.next_ty_vars(n_tps);\n \n-    let substs = substs {regions: regions, self_ty: None, tps: tps};\n+    let substs = substs {regions: ty::NonerasedRegions(opt_vec::from(rps)),\n+                         self_ty: None,\n+                         tps: tps};\n     let substd_ty = ty::subst(tcx, &substs, raw_ty);\n \n     ty_param_substs_and_ty { substs: substs, ty: substd_ty }\n@@ -1174,30 +1184,29 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n     // Verify that no lifetimes or type parameters are present anywhere\n     // except the final two elements of the path.\n     for i in range(0, path.segments.len() - 2) {\n-        match path.segments[i].lifetime {\n-            None => {}\n-            Some(lifetime) => {\n-                function_context.tcx()\n-                                .sess\n-                                .span_err(lifetime.span,\n-                                          \"lifetime parameters may not \\\n-                                           appear here\")\n-            }\n+        for lifetime in path.segments[i].lifetimes.iter() {\n+            function_context.tcx()\n+                .sess\n+                .span_err(lifetime.span,\n+                          \"lifetime parameters may not \\\n+                          appear here\");\n+            break;\n         }\n \n         for typ in path.segments[i].types.iter() {\n             function_context.tcx()\n                             .sess\n                             .span_err(typ.span,\n-                                      \"type parameters may not appear here\")\n+                                      \"type parameters may not appear here\");\n+            break;\n         }\n     }\n \n     // If there are no parameters at all, there is nothing more to do; the\n     // rest of typechecking will (attempt to) infer everything.\n     if path.segments\n            .iter()\n-           .all(|s| s.lifetime.is_none() && s.types.is_empty()) {\n+           .all(|s| s.lifetimes.is_empty() && s.types.is_empty()) {\n         return\n     }\n \n@@ -1219,26 +1228,17 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n \n             // Make sure lifetime parameterization agrees with the trait or\n             // implementation type.\n-            match (generics.region_param, trait_segment.lifetime) {\n-                (Some(_), None) => {\n-                    function_context.tcx()\n-                                    .sess\n-                                    .span_err(path.span,\n-                                              format!(\"this {} has a lifetime \\\n-                                                    parameter but no \\\n-                                                    lifetime was specified\",\n-                                                   name))\n-                }\n-                (None, Some(_)) => {\n-                    function_context.tcx()\n-                                    .sess\n-                                    .span_err(path.span,\n-                                              format!(\"this {} has no lifetime \\\n-                                                    parameter but a lifetime \\\n-                                                    was specified\",\n-                                                   name))\n-                }\n-                (Some(_), Some(_)) | (None, None) => {}\n+            let trait_region_parameter_count = generics.region_param_defs.len();\n+            let supplied_region_parameter_count = trait_segment.lifetimes.len();\n+            if trait_region_parameter_count != supplied_region_parameter_count\n+                && supplied_region_parameter_count != 0 {\n+                function_context.tcx()\n+                    .sess\n+                    .span_err(path.span,\n+                              format!(\"expected {} lifetime parameter(s), \\\n+                                      found {} lifetime parameter(s)\",\n+                                      trait_region_parameter_count,\n+                                      supplied_region_parameter_count));\n             }\n \n             // Make sure the number of type parameters supplied on the trait\n@@ -1276,26 +1276,21 @@ fn check_type_parameter_positions_in_path(function_context: @mut FnCtxt,\n             // Verify that no lifetimes or type parameters are present on\n             // the penultimate segment of the path.\n             let segment = &path.segments[path.segments.len() - 2];\n-            match segment.lifetime {\n-                None => {}\n-                Some(lifetime) => {\n-                    function_context.tcx()\n-                                    .sess\n-                                    .span_err(lifetime.span,\n-                                              \"lifetime parameters may not\n-                                               appear here\")\n-                }\n+            for lifetime in segment.lifetimes.iter() {\n+                function_context.tcx()\n+                    .sess\n+                    .span_err(lifetime.span,\n+                              \"lifetime parameters may not\n+                              appear here\");\n+                break;\n             }\n             for typ in segment.types.iter() {\n                 function_context.tcx()\n                                 .sess\n                                 .span_err(typ.span,\n                                           \"type parameters may not appear \\\n                                            here\");\n-                function_context.tcx()\n-                                .sess\n-                                .span_note(typ.span,\n-                                           format!(\"this is a {:?}\", def));\n+                break;\n             }\n         }\n     }\n@@ -1556,7 +1551,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // In that case, we check each argument against \"error\" in order to\n         // set up all the node type bindings.\n         let error_fn_sig = FnSig {\n-            bound_lifetime_names: opt_vec::Empty,\n+            binder_id: ast::CRATE_NODE_ID,\n             inputs: err_args(args.len()),\n             output: ty::mk_err(),\n             variadic: false\n@@ -1577,7 +1572,6 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         // signature with region variables\n         let (_, _, fn_sig) =\n             replace_bound_regions_in_fn_sig(fcx.tcx(),\n-                                            @Nil,\n                                             None,\n                                             fn_sig,\n                                             |br| fcx.infcx()\n@@ -1908,10 +1902,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                      expected: Option<ty::t>) {\n         let tcx = fcx.ccx.tcx;\n \n-        // Find the expected input/output types (if any).  Careful to\n-        // avoid capture of bound regions in the expected type.  See\n-        // def'n of br_cap_avoid() for a more lengthy explanation of\n-        // what's going on here.\n+        // Find the expected input/output types (if any). Substitute\n+        // fresh bound regions for any bound regions we find in the\n+        // expected types so as to avoid capture.\n+        //\n         // Also try to pick up inferred purity and sigil, defaulting\n         // to impure and block. Note that we only will use those for\n         // block syntax lambdas; that is, lambdas without explicit\n@@ -1927,11 +1921,10 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n              expected_bounds) = {\n             match expected_sty {\n                 Some(ty::ty_closure(ref cenv)) => {\n-                    let id = expr.id;\n                     let (_, _, sig) =\n                         replace_bound_regions_in_fn_sig(\n-                            tcx, @Nil, None, &cenv.sig,\n-                            |br| ty::re_bound(ty::br_cap_avoid(id, @br)));\n+                            tcx, None, &cenv.sig,\n+                            |_| fcx.inh.infcx.fresh_bound_region(expr.id));\n                     (Some(sig), cenv.purity, cenv.sigil,\n                      cenv.onceness, cenv.bounds)\n                 }\n@@ -1952,21 +1945,21 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // construct the function type\n         let fn_ty = astconv::ty_of_closure(fcx,\n-                                           fcx,\n+                                           &fcx.infcx(),\n+                                           expr.id,\n                                            sigil,\n                                            purity,\n                                            expected_onceness,\n                                            expected_bounds,\n                                            &None,\n                                            decl,\n                                            expected_sig,\n-                                           &opt_vec::Empty,\n                                            expr.span);\n \n         let fty_sig;\n         let fty = if error_happened {\n             fty_sig = FnSig {\n-                bound_lifetime_names: opt_vec::Empty,\n+                binder_id: ast::CRATE_NODE_ID,\n                 inputs: fn_ty.sig.inputs.map(|_| ty::mk_err()),\n                 output: ty::mk_err(),\n                 variadic: false\n@@ -1989,7 +1982,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                                            sigil);\n \n         check_fn(fcx.ccx, None, inherited_purity, &fty_sig,\n-                 decl, id, body, fn_kind, fcx.in_scope_regions, fcx.inh);\n+                 decl, id, body, fn_kind, fcx.inh);\n     }\n \n \n@@ -2168,50 +2161,18 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Look up the number of type parameters and the raw type, and\n         // determine whether the class is region-parameterized.\n-        let type_parameter_count;\n-        let region_parameterized;\n-        let raw_type;\n-        if class_id.crate == ast::LOCAL_CRATE {\n-            region_parameterized =\n-                tcx.region_paramd_items.find(&class_id.node).\n-                    map(|x| *x);\n-            match tcx.items.find(&class_id.node) {\n-                Some(&ast_map::node_item(@ast::item {\n-                        node: ast::item_struct(_, ref generics),\n-                        _\n-                    }, _)) => {\n-\n-                    type_parameter_count = generics.ty_params.len();\n-\n-                    let self_region =\n-                        bound_self_region(region_parameterized);\n-\n-                    raw_type = ty::mk_struct(tcx, class_id, substs {\n-                        regions: ty::NonerasedRegions(self_region),\n-                        self_ty: None,\n-                        tps: ty::ty_params_to_tys(\n-                            tcx,\n-                            generics)\n-                    });\n-                }\n-                _ => {\n-                    tcx.sess.span_bug(span,\n-                                      \"resolve didn't map this to a class\");\n-                }\n-            }\n-        } else {\n-            let item_type = ty::lookup_item_type(tcx, class_id);\n-            type_parameter_count = item_type.generics.type_param_defs.len();\n-            region_parameterized = item_type.generics.region_param;\n-            raw_type = item_type.ty;\n-        }\n+        let item_type = ty::lookup_item_type(tcx, class_id);\n+        let type_parameter_count = item_type.generics.type_param_defs.len();\n+        let region_parameter_count = item_type.generics.region_param_defs.len();\n+        let raw_type = item_type.ty;\n \n         // Generate the struct type.\n-        let regions =\n-            fcx.region_var_if_parameterized(region_parameterized, span);\n+        let regions = fcx.infcx().next_region_vars(\n+            infer::BoundRegionInTypeOrImpl(span),\n+            region_parameter_count);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(regions),\n+            regions: ty::NonerasedRegions(opt_vec::from(regions)),\n             self_ty: None,\n             tps: type_parameters\n         };\n@@ -2258,48 +2219,18 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n \n         // Look up the number of type parameters and the raw type, and\n         // determine whether the enum is region-parameterized.\n-        let type_parameter_count;\n-        let region_parameterized;\n-        let raw_type;\n-        if enum_id.crate == ast::LOCAL_CRATE {\n-            region_parameterized =\n-                tcx.region_paramd_items.find(&enum_id.node).map(|x| *x);\n-            match tcx.items.find(&enum_id.node) {\n-                Some(&ast_map::node_item(@ast::item {\n-                        node: ast::item_enum(_, ref generics),\n-                        _\n-                    }, _)) => {\n-\n-                    type_parameter_count = generics.ty_params.len();\n-\n-                    let regions = bound_self_region(region_parameterized);\n-\n-                    raw_type = ty::mk_enum(tcx, enum_id, substs {\n-                        regions: ty::NonerasedRegions(regions),\n-                        self_ty: None,\n-                        tps: ty::ty_params_to_tys(\n-                            tcx,\n-                            generics)\n-                    });\n-                }\n-                _ => {\n-                    tcx.sess.span_bug(span,\n-                                      \"resolve didn't map this to an enum\");\n-                }\n-            }\n-        } else {\n-            let item_type = ty::lookup_item_type(tcx, enum_id);\n-            type_parameter_count = item_type.generics.type_param_defs.len();\n-            region_parameterized = item_type.generics.region_param;\n-            raw_type = item_type.ty;\n-        }\n+        let item_type = ty::lookup_item_type(tcx, enum_id);\n+        let type_parameter_count = item_type.generics.type_param_defs.len();\n+        let region_parameter_count = item_type.generics.region_param_defs.len();\n+        let raw_type = item_type.ty;\n \n         // Generate the enum type.\n-        let regions =\n-            fcx.region_var_if_parameterized(region_parameterized, span);\n+        let regions = fcx.infcx().next_region_vars(\n+            infer::BoundRegionInTypeOrImpl(span),\n+            region_parameter_count);\n         let type_parameters = fcx.infcx().next_ty_vars(type_parameter_count);\n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(regions),\n+            regions: ty::NonerasedRegions(opt_vec::from(regions)),\n             self_ty: None,\n             tps: type_parameters\n         };\n@@ -3445,28 +3376,25 @@ pub fn instantiate_path(fcx: @mut FnCtxt,\n            ty_param_count,\n            ty_substs_len);\n \n-    // determine the region bound, using the value given by the user\n+    // determine the region parameters, using the value given by the user\n     // (if any) and otherwise using a fresh region variable\n-    let regions = match pth.segments.last().lifetime {\n-        Some(_) => { // user supplied a lifetime parameter...\n-            match tpt.generics.region_param {\n-                None => { // ...but the type is not lifetime parameterized!\n-                    fcx.ccx.tcx.sess.span_err\n-                        (span, \"this item is not region-parameterized\");\n-                    opt_vec::Empty\n-                }\n-                Some(_) => { // ...and the type is lifetime parameterized, ok.\n-                    opt_vec::with(\n-                        ast_region_to_region(fcx,\n-                                             fcx,\n-                                             span,\n-                                             &pth.segments.last().lifetime))\n-                }\n-            }\n-        }\n-        None => { // no lifetime parameter supplied, insert default\n-            fcx.region_var_if_parameterized(tpt.generics.region_param, span)\n+    let num_expected_regions = tpt.generics.region_param_defs.len();\n+    let num_supplied_regions = pth.segments.last().lifetimes.len();\n+    let regions = if num_expected_regions == num_supplied_regions {\n+        pth.segments.last().lifetimes.map(\n+            |l| ast_region_to_region(fcx.tcx(), l))\n+    } else {\n+        if num_supplied_regions != 0 {\n+            fcx.ccx.tcx.sess.span_err(\n+                span,\n+                format!(\"expected {} lifetime parameter(s), \\\n+                        found {} lifetime parameter(s)\",\n+                        num_expected_regions, num_supplied_regions));\n         }\n+\n+        opt_vec::from(fcx.infcx().next_region_vars(\n+                infer::BoundRegionInTypeOrImpl(span),\n+                num_expected_regions))\n     };\n \n     // Special case: If there is a self parameter, omit it from the list of\n@@ -3642,18 +3570,14 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n     if tps.len() == 0u { return; }\n     let mut tps_used = vec::from_elem(tps.len(), false);\n \n-    ty::walk_regions_and_ty(\n-        ccx.tcx, ty,\n-        |_r| {},\n-        |t| {\n+    ty::walk_ty(ty, |t| {\n             match ty::get(t).sty {\n-              ty::ty_param(param_ty {idx, _}) => {\n-                  debug!(\"Found use of ty param \\\\#{}\", idx);\n-                  tps_used[idx] = true;\n-              }\n-              _ => ()\n+                ty::ty_param(param_ty {idx, _}) => {\n+                    debug!(\"Found use of ty param \\\\#{}\", idx);\n+                    tps_used[idx] = true;\n+                }\n+                _ => ()\n             }\n-            true\n         });\n \n     for (i, b) in tps_used.iter().enumerate() {\n@@ -3680,27 +3604,27 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n         //We only care about the operation here\n         match split[1] {\n             \"cxchg\" => (0, ~[ty::mk_mut_rptr(tcx,\n-                                             ty::re_bound(ty::br_anon(0)),\n+                                             ty::re_fn_bound(it.id, ty::br_anon(0)),\n                                              ty::mk_int()),\n                         ty::mk_int(),\n                         ty::mk_int()\n                         ], ty::mk_int()),\n             \"load\" => (0,\n                ~[\n-                  ty::mk_imm_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int())\n+                  ty::mk_imm_rptr(tcx, ty::re_fn_bound(it.id, ty::br_anon(0)), ty::mk_int())\n                ],\n               ty::mk_int()),\n             \"store\" => (0,\n                ~[\n-                  ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+                  ty::mk_mut_rptr(tcx, ty::re_fn_bound(it.id, ty::br_anon(0)), ty::mk_int()),\n                   ty::mk_int()\n                ],\n                ty::mk_nil()),\n \n             \"xchg\" | \"xadd\" | \"xsub\" | \"and\"  | \"nand\" | \"or\"   | \"xor\"  | \"max\"  |\n             \"min\"  | \"umax\" | \"umin\" => {\n                 (0, ~[ty::mk_mut_rptr(tcx,\n-                                      ty::re_bound(ty::br_anon(0)),\n+                                      ty::re_fn_bound(it.id, ty::br_anon(0)),\n                                       ty::mk_int()), ty::mk_int() ], ty::mk_int())\n             }\n             \"fence\" => {\n@@ -3726,7 +3650,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             \"move_val\" | \"move_val_init\" => {\n                 (1u,\n                  ~[\n-                    ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), param(ccx, 0)),\n+                    ty::mk_mut_rptr(tcx, ty::re_fn_bound(it.id, ty::br_anon(0)), param(ccx, 0)),\n                     param(ccx, 0u)\n                   ],\n                ty::mk_nil())\n@@ -3738,7 +3662,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n             \"atomic_xchg_rel\" | \"atomic_xadd_rel\" | \"atomic_xsub_rel\" => {\n               (0,\n                ~[\n-                  ty::mk_mut_rptr(tcx, ty::re_bound(ty::br_anon(0)), ty::mk_int()),\n+                  ty::mk_mut_rptr(tcx, ty::re_fn_bound(it.id, ty::br_anon(0)), ty::mk_int()),\n                   ty::mk_int()\n                ],\n                ty::mk_int())\n@@ -3761,7 +3685,7 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                   Ok(t) => t,\n                   Err(s) => { tcx.sess.span_fatal(it.span, s); }\n               };\n-              let region = ty::re_bound(ty::br_anon(0));\n+              let region = ty::re_fn_bound(it.id, ty::br_anon(0));\n               let visitor_object_ty = match ty::visitor_object_ty(tcx, region) {\n                   Ok((_, vot)) => vot,\n                   Err(s) => { tcx.sess.span_fatal(it.span, s); }\n@@ -3953,12 +3877,10 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n     let fty = ty::mk_bare_fn(tcx, ty::BareFnTy {\n         purity: ast::unsafe_fn,\n         abis: AbiSet::Intrinsic(),\n-        sig: FnSig {\n-            bound_lifetime_names: opt_vec::Empty,\n-            inputs: inputs,\n-            output: output,\n-            variadic: false\n-        }\n+        sig: FnSig {binder_id: it.id,\n+                    inputs: inputs,\n+                    output: output,\n+                    variadic: false}\n     });\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = i_ty.generics.type_param_defs.len();\n@@ -3974,3 +3896,4 @@ pub fn check_intrinsic_type(ccx: @mut CrateCtxt, it: @ast::foreign_item) {\n                      ppaux::ty_to_str(ccx.tcx, fty)));\n     }\n }\n+"}, {"sha": "cd94e040ac371ee3dd82631d1eb9f0f0728dbd7b", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -535,8 +535,14 @@ fn constrain_call(rcx: &mut Rcx,\n     //! appear in the arguments appropriately.\n \n     let tcx = rcx.fcx.tcx();\n-    debug!(\"constrain_call(call_expr={}, implicitly_ref_args={:?})\",\n-           call_expr.repr(tcx), implicitly_ref_args);\n+    debug!(\"constrain_call(call_expr={}, \\\n+            receiver={}, \\\n+            arg_exprs={}, \\\n+            implicitly_ref_args={:?})\",\n+            call_expr.repr(tcx),\n+            receiver.repr(tcx),\n+            arg_exprs.repr(tcx),\n+            implicitly_ref_args);\n     let callee_ty = rcx.resolve_node_type(callee_id);\n     if ty::type_is_error(callee_ty) {\n         // Bail, as function type is unknown\n@@ -552,6 +558,8 @@ fn constrain_call(rcx: &mut Rcx,\n     let callee_region = ty::re_scope(callee_scope);\n \n     for &arg_expr in arg_exprs.iter() {\n+        debug!(\"Argument\");\n+\n         // ensure that any regions appearing in the argument type are\n         // valid for at least the lifetime of the function:\n         constrain_regions_in_type_of_node(\n@@ -569,6 +577,7 @@ fn constrain_call(rcx: &mut Rcx,\n \n     // as loop above, but for receiver\n     for &r in receiver.iter() {\n+        debug!(\"Receiver\");\n         constrain_regions_in_type_of_node(\n             rcx, r.id, callee_region, infer::CallRcvr(r.span));\n         if implicitly_ref_args {\n@@ -727,9 +736,9 @@ fn constrain_regions_in_type(\n            ty_to_str(tcx, ty));\n \n     do relate_nested_regions(tcx, Some(minimum_lifetime), ty) |r_sub, r_sup| {\n-        debug!(\"relate(r_sub={}, r_sup={})\",\n-               region_to_str(tcx, \"\", false, r_sub),\n-               region_to_str(tcx, \"\", false, r_sup));\n+        debug!(\"relate_nested_regions(r_sub={}, r_sup={})\",\n+                r_sub.repr(tcx),\n+                r_sup.repr(tcx));\n \n         if r_sup.is_bound() || r_sub.is_bound() {\n             // a bound region is one which appears inside an fn type."}, {"sha": "ea7b2faf2734286da0bc984f355b3668131e31b0", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 78, "deletions": 168, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -10,155 +10,41 @@\n \n // #[warn(deprecated_mode)];\n \n-\n use middle::ty;\n-\n-use middle::typeck::isr_alist;\n-use util::common::indenter;\n-use util::ppaux::region_to_str;\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFolder;\n+use std::hashmap::HashMap;\n+use util::ppaux::Repr;\n use util::ppaux;\n \n-use extra::list::Cons;\n-\n // Helper functions related to manipulating region types.\n \n pub fn replace_bound_regions_in_fn_sig(\n     tcx: ty::ctxt,\n-    isr: isr_alist,\n     opt_self_ty: Option<ty::t>,\n     fn_sig: &ty::FnSig,\n     mapf: &fn(ty::bound_region) -> ty::Region)\n-    -> (isr_alist, Option<ty::t>, ty::FnSig)\n+    -> (HashMap<ty::bound_region,ty::Region>, Option<ty::t>, ty::FnSig)\n {\n-    let mut all_tys = ty::tys_in_fn_sig(fn_sig);\n-\n-    for &t in opt_self_ty.iter() { all_tys.push(t) }\n-\n-    debug!(\"replace_bound_regions_in_fn_sig(self_ty={:?}, fn_sig={}, \\\n-            all_tys={:?})\",\n-           opt_self_ty.map(|t| ppaux::ty_to_str(tcx, t)),\n-           ppaux::fn_sig_to_str(tcx, fn_sig),\n-           all_tys.map(|t| ppaux::ty_to_str(tcx, *t)));\n-    let _i = indenter();\n-\n-    let isr = do create_bound_region_mapping(tcx, isr, all_tys) |br| {\n-        debug!(\"br={:?}\", br);\n-        mapf(br)\n-    };\n-    let new_fn_sig = ty::fold_sig(fn_sig, |t| {\n-        replace_bound_regions(tcx, isr, t)\n-    });\n-    let new_self_ty = opt_self_ty.map(|t| replace_bound_regions(tcx, isr, t));\n-\n-    debug!(\"result of replace_bound_regions_in_fn_sig: \\\n-            new_self_ty={:?}, \\\n-            fn_sig={}\",\n-           new_self_ty.map(|t| ppaux::ty_to_str(tcx, t)),\n-           ppaux::fn_sig_to_str(tcx, &new_fn_sig));\n-\n-    return (isr, new_self_ty, new_fn_sig);\n-\n-    // Takes `isr`, a (possibly empty) mapping from in-scope region\n-    // names (\"isr\"s) to their corresponding regions; `tys`, a list of\n-    // types, and `to_r`, a closure that takes a bound_region and\n-    // returns a region.  Returns an updated version of `isr`,\n-    // extended with the in-scope region names from all of the bound\n-    // regions appearing in the types in the `tys` list (if they're\n-    // not in `isr` already), with each of those in-scope region names\n-    // mapped to a region that's the result of applying `to_r` to\n-    // itself.\n-    fn create_bound_region_mapping(\n-        tcx: ty::ctxt,\n-        isr: isr_alist,\n-        tys: ~[ty::t],\n-        to_r: &fn(ty::bound_region) -> ty::Region) -> isr_alist {\n-\n-        // Takes `isr` (described above), `to_r` (described above),\n-        // and `r`, a region.  If `r` is anything other than a bound\n-        // region, or if it's a bound region that already appears in\n-        // `isr`, then we return `isr` unchanged.  If `r` is a bound\n-        // region that doesn't already appear in `isr`, we return an\n-        // updated isr_alist that now contains a mapping from `r` to\n-        // the result of calling `to_r` on it.\n-        fn append_isr(isr: isr_alist,\n-                      to_r: &fn(ty::bound_region) -> ty::Region,\n-                      r: ty::Region) -> isr_alist {\n-            match r {\n-              ty::re_empty | ty::re_free(*) | ty::re_static | ty::re_scope(_) |\n-              ty::re_infer(_) => {\n-                isr\n-              }\n-              ty::re_bound(br) => {\n-                match isr.find(br) {\n-                  Some(_) => isr,\n-                  None => @Cons((br, to_r(br)), isr)\n-                }\n-              }\n-            }\n-        }\n-\n-        // For each type `ty` in `tys`...\n-        do tys.iter().fold(isr) |isr, ty| {\n-            let mut isr = isr;\n-\n-            // Using fold_regions is inefficient, because it\n-            // constructs new types, but it avoids code duplication in\n-            // terms of locating all the regions within the various\n-            // kinds of types.  This had already caused me several\n-            // bugs so I decided to switch over.\n-            do ty::fold_regions(tcx, *ty) |r, in_fn| {\n-                if !in_fn { isr = append_isr(isr, |br| to_r(br), r); }\n-                r\n-            };\n-\n-            isr\n-        }\n-    }\n-\n-    // Takes `isr`, a mapping from in-scope region names (\"isr\"s) to\n-    // their corresponding regions; and `ty`, a type.  Returns an\n-    // updated version of `ty`, in which bound regions in `ty` have\n-    // been replaced with the corresponding bindings in `isr`.\n-    fn replace_bound_regions(\n-        tcx: ty::ctxt,\n-        isr: isr_alist,\n-        ty: ty::t) -> ty::t {\n-\n-        do ty::fold_regions(tcx, ty) |r, in_fn| {\n-            let r1 = match r {\n-              // As long as we are not within a fn() type, `&T` is\n-              // mapped to the free region anon_r.  But within a fn\n-              // type, it remains bound.\n-              ty::re_bound(ty::br_anon(_)) if in_fn => r,\n-\n-              ty::re_bound(br) => {\n-                match isr.find(br) {\n-                  // In most cases, all named, bound regions will be\n-                  // mapped to some free region.\n-                  Some(fr) => fr,\n-\n-                  // But in the case of a fn() type, there may be\n-                  // named regions within that remain bound:\n-                  None if in_fn => r,\n-                  None => {\n-                    tcx.sess.bug(\n-                        format!(\"Bound region not found in \\\n-                              in_scope_regions list: {}\",\n-                             region_to_str(tcx, \"\", false, r)));\n-                  }\n+    debug!(\"replace_bound_regions_in_fn_sig(self_ty={}, fn_sig={})\",\n+            opt_self_ty.repr(tcx),\n+            fn_sig.repr(tcx));\n+\n+    let mut map = HashMap::new();\n+    let (fn_sig, opt_self_ty) = {\n+        let mut f = ty_fold::RegionFolder::regions(tcx, |r| {\n+                debug!(\"region r={}\", r.to_str());\n+                match r {\n+                ty::re_fn_bound(s, br) if s == fn_sig.binder_id => {\n+                    *map.find_or_insert_with(br, |_| mapf(br))\n                 }\n-              }\n-\n-              // Free regions like these just stay the same:\n-              ty::re_empty |\n-              ty::re_static |\n-              ty::re_scope(_) |\n-              ty::re_free(*) |\n-              ty::re_infer(_) => r\n-            };\n-            r1\n-        }\n-    }\n+                _ => r\n+            }});\n+        (ty_fold::super_fold_sig(&mut f, fn_sig),\n+         ty_fold::fold_opt_ty(&mut f, opt_self_ty))\n+    };\n+    debug!(\"resulting map: {}\", map.to_str());\n+    (map, opt_self_ty, fn_sig)\n }\n \n pub fn relate_nested_regions(\n@@ -168,7 +54,6 @@ pub fn relate_nested_regions(\n     relate_op: &fn(ty::Region, ty::Region))\n {\n     /*!\n-     *\n      * This rather specialized function walks each region `r` that appear\n      * in `ty` and invokes `relate_op(r_encl, r)` for each one.  `r_encl`\n      * here is the region of any enclosing `&'r T` pointer.  If there is\n@@ -194,41 +79,66 @@ pub fn relate_nested_regions(\n      * Hence, in the second example above, `'r2` must be a subregion of `'r3`.\n      */\n \n-    let mut the_stack = ~[];\n-    for &r in opt_region.iter() { the_stack.push(r); }\n-    walk_ty(tcx, &mut the_stack, ty, relate_op);\n+    let mut rr = RegionRelator { tcx: tcx,\n+                                 stack: ~[],\n+                                 relate_op: relate_op };\n+    match opt_region {\n+        Some(o_r) => { rr.stack.push(o_r); }\n+        None => {}\n+    }\n+    rr.fold_ty(ty);\n \n-    fn walk_ty(tcx: ty::ctxt,\n-               the_stack: &mut ~[ty::Region],\n-               ty: ty::t,\n-               relate_op: &fn(ty::Region, ty::Region))\n-    {\n-        match ty::get(ty).sty {\n-            ty::ty_rptr(r, ref mt) |\n-            ty::ty_evec(ref mt, ty::vstore_slice(r)) => {\n-                relate(*the_stack, r, |x,y| relate_op(x,y));\n-                the_stack.push(r);\n-                walk_ty(tcx, the_stack, mt.ty, |x,y| relate_op(x,y));\n-                the_stack.pop();\n-            }\n-            _ => {\n-                ty::fold_regions_and_ty(\n-                    tcx,\n-                    ty,\n-                    |r| { relate(     *the_stack, r, |x,y| relate_op(x,y)); r },\n-                    |t| { walk_ty(tcx, the_stack, t, |x,y| relate_op(x,y)); t },\n-                    |t| { walk_ty(tcx, the_stack, t, |x,y| relate_op(x,y)); t });\n+    struct RegionRelator<'self> {\n+        tcx: ty::ctxt,\n+        stack: ~[ty::Region],\n+        relate_op: &'self fn(ty::Region, ty::Region),\n+    }\n+\n+    // FIXME we should define more precisely when a\n+    //       region is considered \"nested\" and take variance into account.\n+    //\n+    //       I can't decide whether skipping closure parameter types and\n+    //       so on is necessary or not. What is the difference, after all,\n+    //       between `&'a |&'b T|` and `&'a Fn<&'b T>`? And yet in the\n+    //       latter case I'm inclined to think we should probably track\n+    //       the relationship (but then again maybe we should just skip\n+    //       all such cases until it \"proves necessary\")\n+\n+    impl<'self> TypeFolder for RegionRelator<'self> {\n+        fn tcx(&self) -> ty::ctxt {\n+            self.tcx\n+        }\n+\n+        fn fold_ty(&mut self, ty: ty::t) -> ty::t {\n+            match ty::get(ty).sty {\n+                ty::ty_rptr(r, ref mt) |\n+                ty::ty_evec(ref mt, ty::vstore_slice(r)) => {\n+                    self.relate(r);\n+                    self.stack.push(r);\n+                    ty_fold::super_fold_ty(self, mt.ty);\n+                    self.stack.pop();\n+                }\n+\n+                _ => {\n+                    ty_fold::super_fold_ty(self, ty);\n+                }\n             }\n+\n+            ty\n+        }\n+\n+        fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+            self.relate(r);\n+            r\n         }\n     }\n \n-    fn relate(the_stack: &[ty::Region],\n-              r_sub: ty::Region,\n-              relate_op: &fn(ty::Region, ty::Region))\n-    {\n-        for &r in the_stack.iter() {\n-            if !r.is_bound() && !r_sub.is_bound() {\n-                relate_op(r, r_sub);\n+    impl<'self> RegionRelator<'self> {\n+        fn relate(&mut self, r_sub: ty::Region) {\n+            for &r in self.stack.iter() {\n+                if !r.is_bound() && !r_sub.is_bound() {\n+                    (self.relate_op)(r, r_sub);\n+                }\n             }\n         }\n     }"}, {"sha": "ae76c9ed6dd49d6ac96ae329e6c7b2d1b309570b", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 77, "deletions": 70, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -11,6 +11,7 @@\n \n use middle::ty::param_ty;\n use middle::ty;\n+use middle::ty_fold::TypeFolder;\n use middle::typeck::check::{FnCtxt, impl_self_ty};\n use middle::typeck::check::{structurally_resolved_type};\n use middle::typeck::infer::fixup_err_to_str;\n@@ -68,13 +69,13 @@ pub struct LocationInfo {\n \n /// A vtable context includes an inference context, a crate context, and a\n /// callback function to call in case of type error.\n-pub struct VtableContext {\n-    ccx: @mut CrateCtxt,\n-    infcx: @mut infer::InferCtxt\n+pub struct VtableContext<'self> {\n+    infcx: @mut infer::InferCtxt,\n+    param_env: &'self ty::ParameterEnvironment,\n }\n \n-impl VtableContext {\n-    pub fn tcx(&self) -> ty::ctxt { self.ccx.tcx }\n+impl<'self> VtableContext<'self> {\n+    pub fn tcx(&self) -> ty::ctxt { self.infcx.tcx }\n }\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n@@ -95,7 +96,6 @@ fn lookup_vtables(vcx: &VtableContext,\n            substs.repr(vcx.tcx()));\n     let _i = indenter();\n \n-\n     // We do this backwards for reasons discussed above.\n     assert_eq!(substs.tps.len(), type_param_defs.len());\n     let mut result =\n@@ -233,8 +233,6 @@ fn lookup_vtable(vcx: &VtableContext,\n            vcx.infcx.trait_ref_to_str(trait_ref));\n     let _i = indenter();\n \n-    let tcx = vcx.tcx();\n-\n     let ty = match fixup_ty(vcx, location_info, ty, is_early) {\n         Some(ty) => ty,\n         None => {\n@@ -250,18 +248,21 @@ fn lookup_vtable(vcx: &VtableContext,\n     // If the type is self or a param, we look at the trait/supertrait\n     // bounds to see if they include the trait we are looking for.\n     let vtable_opt = match ty::get(ty).sty {\n-        ty::ty_param(param_ty {idx: n, def_id: did}) => {\n-            let type_param_def = tcx.ty_param_defs.get(&did.node);\n-            lookup_vtable_from_bounds(vcx, location_info,\n-                                      type_param_def.bounds.trait_bounds,\n+        ty::ty_param(param_ty {idx: n, _}) => {\n+            let type_param_bounds: &[@ty::TraitRef] =\n+                vcx.param_env.type_param_bounds[n].trait_bounds;\n+            lookup_vtable_from_bounds(vcx,\n+                                      location_info,\n+                                      type_param_bounds,\n                                       param_numbered(n),\n                                       trait_ref)\n         }\n \n-        ty::ty_self(trait_id) => {\n-            let self_trait_ref = ty::lookup_trait_def(tcx, trait_id).trait_ref;\n-            lookup_vtable_from_bounds(vcx, location_info,\n-                                      &[self_trait_ref],\n+        ty::ty_self(_) => {\n+            let self_param_bound = vcx.param_env.self_param_bound.unwrap();\n+            lookup_vtable_from_bounds(vcx,\n+                                      location_info,\n+                                      [self_param_bound],\n                                       param_self,\n                                       trait_ref)\n         }\n@@ -285,7 +286,7 @@ fn lookup_vtable_from_bounds(vcx: &VtableContext,\n                              bounds: &[@ty::TraitRef],\n                              param: param_index,\n                              trait_ref: @ty::TraitRef)\n-    -> Option<vtable_origin> {\n+                             -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n \n     let mut n_bound = 0;\n@@ -317,8 +318,7 @@ fn search_for_vtable(vcx: &VtableContext,\n                      ty: ty::t,\n                      trait_ref: @ty::TraitRef,\n                      is_early: bool)\n-    -> Option<vtable_origin>\n-{\n+                     -> Option<vtable_origin> {\n     let tcx = vcx.tcx();\n \n     let mut found = ~[];\n@@ -494,7 +494,8 @@ fn fixup_substs(vcx: &VtableContext,\n fn fixup_ty(vcx: &VtableContext,\n             location_info: &LocationInfo,\n             ty: ty::t,\n-            is_early: bool) -> Option<ty::t> {\n+            is_early: bool)\n+            -> Option<ty::t> {\n     let tcx = vcx.tcx();\n     match resolve_type(vcx.infcx, ty, resolve_and_force_all_but_regions) {\n         Ok(new_type) => Some(new_type),\n@@ -515,8 +516,7 @@ fn connect_trait_tps(vcx: &VtableContext,\n                      location_info: &LocationInfo,\n                      impl_substs: &ty::substs,\n                      trait_ref: @ty::TraitRef,\n-                     impl_did: ast::DefId)\n-{\n+                     impl_did: ast::DefId) {\n     let tcx = vcx.tcx();\n \n     let impl_trait_ref = match ty::impl_trait_ref(tcx, impl_did) {\n@@ -571,7 +571,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n             if has_trait_bounds(*item_ty.generics.type_param_defs) {\n                 debug!(\"early_resolve_expr: looking up vtables for type params {}\",\n                        item_ty.generics.type_param_defs.repr(fcx.tcx()));\n-                let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n+                let vcx = fcx.vtable_context();\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n                                            *item_ty.generics.type_param_defs,\n                                            substs, is_early);\n@@ -599,7 +599,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                    ex.repr(fcx.tcx()));\n             if has_trait_bounds(*type_param_defs) {\n                 let substs = fcx.node_ty_substs(callee_id);\n-                let vcx = VtableContext { ccx: fcx.ccx, infcx: fcx.infcx() };\n+                let vcx = fcx.vtable_context();\n                 let vtbls = lookup_vtables(&vcx, &location_info_for_expr(ex),\n                                            *type_param_defs, &substs, is_early);\n                 if !is_early {\n@@ -642,10 +642,7 @@ pub fn early_resolve_expr(ex: @ast::Expr,\n                       (&ty::ty_rptr(_, mt), ty::RegionTraitStore(*)) => {\n                           let location_info =\n                               &location_info_for_expr(ex);\n-                          let vcx = VtableContext {\n-                              ccx: fcx.ccx,\n-                              infcx: fcx.infcx()\n-                          };\n+                          let vcx = fcx.vtable_context();\n                           let target_trait_ref = @ty::TraitRef {\n                               def_id: target_def_id,\n                               substs: ty::substs {\n@@ -726,48 +723,58 @@ fn resolve_expr(fcx: @mut FnCtxt,\n     visit::walk_expr(&mut fcx, ex, ());\n }\n \n-pub fn resolve_impl(ccx: @mut CrateCtxt, impl_item: @ast::item) {\n-    let def_id = ast_util::local_def(impl_item.id);\n-    match ty::impl_trait_ref(ccx.tcx, def_id) {\n-        None => {},\n-        Some(trait_ref) => {\n-            let infcx = infer::new_infer_ctxt(ccx.tcx);\n-            let vcx = VtableContext { ccx: ccx, infcx: infcx };\n-            let loc_info = location_info_for_item(impl_item);\n-\n-            // First, check that the impl implements any trait bounds\n-            // on the trait.\n-            let trait_def = ty::lookup_trait_def(ccx.tcx, trait_ref.def_id);\n-            let vtbls = lookup_vtables(&vcx,\n-                                       &loc_info,\n-                                       *trait_def.generics.type_param_defs,\n-                                       &trait_ref.substs,\n-                                       false);\n-\n-            // Now, locate the vtable for the impl itself. The real\n-            // purpose of this is to check for supertrait impls,\n-            // but that falls out of doing this.\n-            let param_bounds = ty::ParamBounds {\n-                builtin_bounds: ty::EmptyBuiltinBounds(),\n-                trait_bounds: ~[trait_ref]\n-            };\n-            let t = ty::node_id_to_type(ccx.tcx, impl_item.id);\n-            debug!(\"=== Doing a self lookup now.\");\n-            // Right now, we don't have any place to store this.\n-            // We will need to make one so we can use this information\n-            // for compiling default methods that refer to supertraits.\n-            let self_vtable_res =\n-                lookup_vtables_for_param(&vcx, &loc_info, None,\n-                                         &param_bounds, t, false);\n-\n-\n-            let res = impl_res {\n-                trait_vtables: vtbls,\n-                self_vtables: self_vtable_res\n-            };\n-            ccx.tcx.impl_vtables.insert(def_id, res);\n-        }\n-    }\n+pub fn resolve_impl(ccx: @mut CrateCtxt,\n+                    impl_item: @ast::item,\n+                    impl_generics: &ty::Generics,\n+                    impl_trait_ref: &ty::TraitRef) {\n+    let param_env = ty::construct_parameter_environment(\n+        ccx.tcx,\n+        None,\n+        *impl_generics.type_param_defs,\n+        [],\n+        impl_generics.region_param_defs,\n+        impl_item.id);\n+\n+    let impl_trait_ref = @impl_trait_ref.subst(ccx.tcx, &param_env.free_substs);\n+\n+    let infcx = infer::new_infer_ctxt(ccx.tcx);\n+    let vcx = VtableContext { infcx: infcx, param_env: &param_env };\n+    let loc_info = location_info_for_item(impl_item);\n+\n+    // First, check that the impl implements any trait bounds\n+    // on the trait.\n+    let trait_def = ty::lookup_trait_def(ccx.tcx, impl_trait_ref.def_id);\n+    let vtbls = lookup_vtables(&vcx,\n+                               &loc_info,\n+                               *trait_def.generics.type_param_defs,\n+                               &impl_trait_ref.substs,\n+                               false);\n+\n+    // Now, locate the vtable for the impl itself. The real\n+    // purpose of this is to check for supertrait impls,\n+    // but that falls out of doing this.\n+    let param_bounds = ty::ParamBounds {\n+        builtin_bounds: ty::EmptyBuiltinBounds(),\n+        trait_bounds: ~[impl_trait_ref]\n+    };\n+    let t = ty::node_id_to_type(ccx.tcx, impl_item.id);\n+    let t = t.subst(ccx.tcx, &param_env.free_substs);\n+    debug!(\"=== Doing a self lookup now.\");\n+\n+    // Right now, we don't have any place to store this.\n+    // We will need to make one so we can use this information\n+    // for compiling default methods that refer to supertraits.\n+    let self_vtable_res =\n+        lookup_vtables_for_param(&vcx, &loc_info, None,\n+                                 &param_bounds, t, false);\n+\n+\n+    let res = impl_res {\n+        trait_vtables: vtbls,\n+        self_vtables: self_vtable_res\n+    };\n+    let impl_def_id = ast_util::local_def(impl_item.id);\n+    ccx.tcx.impl_vtables.insert(impl_def_id, res);\n }\n \n impl visit::Visitor<()> for @mut FnCtxt {"}, {"sha": "b959c80db38a81a6267668b439962abf83455598", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -357,8 +357,8 @@ impl CoherenceChecker {\n                     @vec::append(\n                         (*impl_poly_type.generics.type_param_defs).clone(),\n                         *new_method_ty.generics.type_param_defs),\n-                region_param:\n-                    impl_poly_type.generics.region_param\n+                region_param_defs:\n+                    impl_poly_type.generics.region_param_defs\n             };\n             let new_polytype = ty::ty_param_bounds_and_ty {\n                 generics: new_generics,\n@@ -482,20 +482,17 @@ impl CoherenceChecker {\n     pub fn universally_quantify_polytype(&self,\n                                          polytype: ty_param_bounds_and_ty)\n                                          -> UniversalQuantificationResult {\n-        let regions = match polytype.generics.region_param {\n-            None => opt_vec::Empty,\n-            Some(_) => {\n-                opt_vec::with(\n-                    self.inference_context.next_region_var(\n-                        infer::BoundRegionInCoherence))\n-            }\n-        };\n+        let region_parameter_count = polytype.generics.region_param_defs.len();\n+        let region_parameters =\n+            self.inference_context.next_region_vars(\n+                infer::BoundRegionInCoherence,\n+                region_parameter_count);\n \n         let bounds_count = polytype.generics.type_param_defs.len();\n         let type_parameters = self.inference_context.next_ty_vars(bounds_count);\n \n         let substitutions = substs {\n-            regions: ty::NonerasedRegions(regions),\n+            regions: ty::NonerasedRegions(opt_vec::from(region_parameters)),\n             self_ty: None,\n             tps: type_parameters\n         };"}, {"sha": "c1908e69f1e09681f05dc903d958b28cd782d4fb", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 211, "deletions": 280, "changes": 491, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -39,15 +39,10 @@ use middle::subst::Subst;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n use middle::typeck::astconv::{ast_ty_to_ty};\n use middle::typeck::astconv;\n-use middle::typeck::infer;\n use middle::typeck::rscope::*;\n-use middle::typeck::rscope;\n use middle::typeck::{CrateCtxt, lookup_def_tcx, no_params, write_ty_to_tcx};\n-use util::common::pluralize;\n use util::ppaux;\n-use util::ppaux::UserString;\n \n-use std::result;\n use std::vec;\n use syntax::abi::AbiSet;\n use syntax::ast::{RegionTyParamBound, TraitTyParamBound};\n@@ -56,10 +51,9 @@ use syntax::ast_map;\n use syntax::ast_util::{local_def, split_trait_methods};\n use syntax::codemap::Span;\n use syntax::codemap;\n-use syntax::print::pprust::{path_to_str, explicit_self_to_str};\n+use syntax::print::pprust::{path_to_str};\n use syntax::visit;\n use syntax::opt_vec::OptVec;\n-use syntax::opt_vec;\n use syntax::parse::token::special_idents;\n \n struct CollectItemTypesVisitor {\n@@ -97,19 +91,11 @@ pub fn collect_item_types(ccx: @mut CrateCtxt, crate: &ast::Crate) {\n }\n \n pub trait ToTy {\n-    fn to_ty<RS:RegionScope + Clone + 'static>(\n-             &self,\n-             rs: &RS,\n-             ast_ty: &ast::Ty)\n-             -> ty::t;\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t;\n }\n \n impl ToTy for CrateCtxt {\n-    fn to_ty<RS:RegionScope + Clone + 'static>(\n-             &self,\n-             rs: &RS,\n-             ast_ty: &ast::Ty)\n-             -> ty::t {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n }\n@@ -149,88 +135,74 @@ impl AstConv for CrateCtxt {\n pub fn get_enum_variant_types(ccx: &CrateCtxt,\n                               enum_ty: ty::t,\n                               variants: &[ast::variant],\n-                              generics: &ast::Generics,\n-                              rp: Option<ty::region_variance>) {\n+                              generics: &ast::Generics) {\n     let tcx = ccx.tcx;\n \n     // Create a set of parameter types shared among all the variants.\n     for variant in variants.iter() {\n-        let region_parameterization =\n-            RegionParameterization::from_variance_and_generics(rp, generics);\n-\n         // Nullary enum constructors get turned into constants; n-ary enum\n         // constructors get turned into functions.\n-        let result_ty;\n-        match variant.node.kind {\n+        let scope = variant.node.id;\n+        let result_ty = match variant.node.kind {\n             ast::tuple_variant_kind(ref args) if args.len() > 0 => {\n-                let rs = TypeRscope(region_parameterization);\n+                let rs = ExplicitRscope;\n                 let input_tys = args.map(|va| ccx.to_ty(&rs, &va.ty));\n-                result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n+                ty::mk_ctor_fn(tcx, scope, input_tys, enum_ty)\n             }\n \n             ast::tuple_variant_kind(_) => {\n-                result_ty = Some(enum_ty);\n+                enum_ty\n             }\n \n             ast::struct_variant_kind(struct_def) => {\n                 let tpt = ty_param_bounds_and_ty {\n-                    generics: ty_generics(ccx, rp, generics, 0),\n+                    generics: ty_generics(ccx, generics, 0),\n                     ty: enum_ty\n                 };\n \n-                convert_struct(ccx,\n-                               rp,\n-                               struct_def,\n-                               generics,\n-                               tpt,\n-                               variant.node.id);\n+                convert_struct(ccx, struct_def, tpt, variant.node.id);\n \n                 let input_tys = struct_def.fields.map(\n                     |f| ty::node_id_to_type(ccx.tcx, f.node.id));\n-                result_ty = Some(ty::mk_ctor_fn(tcx, input_tys, enum_ty));\n+                ty::mk_ctor_fn(tcx, scope, input_tys, enum_ty)\n             }\n         };\n \n-        match result_ty {\n-            None => {}\n-            Some(result_ty) => {\n-                let tpt = ty_param_bounds_and_ty {\n-                    generics: ty_generics(ccx, rp, generics, 0),\n-                    ty: result_ty\n-                };\n-                tcx.tcache.insert(local_def(variant.node.id), tpt);\n-                write_ty_to_tcx(tcx, variant.node.id, result_ty);\n-            }\n-        }\n+        let tpt = ty_param_bounds_and_ty {\n+            generics: ty_generics(ccx, generics, 0),\n+            ty: result_ty\n+        };\n+        tcx.tcache.insert(local_def(variant.node.id), tpt);\n+        write_ty_to_tcx(tcx, variant.node.id, result_ty);\n     }\n }\n \n pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                             trait_id: ast::NodeId)\n {\n     let tcx = ccx.tcx;\n-    let region_paramd = tcx.region_paramd_items.find(&trait_id).map(|x| *x);\n     match tcx.items.get_copy(&trait_id) {\n         ast_map::node_item(@ast::item {\n             node: ast::item_trait(ref generics, _, ref ms),\n             _\n         }, _) => {\n-            let trait_ty_generics = ty_generics(ccx, region_paramd, generics, 0);\n+            let trait_ty_generics =\n+                ty_generics(ccx, generics, 0);\n \n             // For each method, construct a suitable ty::Method and\n             // store it into the `tcx.methods` table:\n             for m in ms.iter() {\n                 let ty_method = @match m {\n                     &ast::required(ref m) => {\n                         ty_method_of_trait_method(\n-                            ccx, trait_id, region_paramd, generics,\n+                            ccx, trait_id, &trait_ty_generics,\n                             &m.id, &m.ident, &m.explicit_self,\n                             &m.generics, &m.purity, &m.decl)\n                     }\n \n                     &ast::provided(ref m) => {\n                         ty_method_of_trait_method(\n-                            ccx, trait_id, region_paramd, generics,\n+                            ccx, trait_id, &trait_ty_generics,\n                             &m.id, &m.ident, &m.explicit_self,\n                             &m.generics, &m.purity, &m.decl)\n                     }\n@@ -264,13 +236,13 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                              trait_ty_generics: &ty::Generics) {\n         // If declaration is\n         //\n-        //     trait<A,B,C> {\n-        //        fn foo<D,E,F>(...) -> Self;\n+        //     trait<'a,'b,'c,A,B,C> {\n+        //        fn foo<'d,'e,'f,D,E,F>(...) -> Self;\n         //     }\n         //\n         // and we will create a function like\n         //\n-        //     fn foo<A',B',C',D',E',F',G'>(...) -> D' {}\n+        //     fn foo<'a,'b,'c,'d,'e,'f,A',B',C',D',E',F',G'>(...) -> D' {}\n         //\n         // Note that `Self` is replaced with an explicit type\n         // parameter D' that is sandwiched in between the trait params\n@@ -307,12 +279,19 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                          m.generics.type_param_defs[i].def_id)\n         };\n \n+        // Convert the regions 'a, 'b, 'c defined on the trait into\n+        // bound regions on the fn.\n+        let rps_from_trait = trait_ty_generics.region_param_defs.iter().map(|d| {\n+            ty::re_fn_bound(m.fty.sig.binder_id,\n+                            ty::br_named(d.def_id, d.ident))\n+        }).collect();\n+\n         // build up the substitution from\n         //     A,B,C => A',B',C'\n         //     Self => D'\n         //     D,E,F => E',F',G'\n         let substs = substs {\n-            regions: ty::NonerasedRegions(opt_vec::Empty),\n+            regions: ty::NonerasedRegions(rps_from_trait),\n             self_ty: Some(self_param),\n             tps: non_shifted_trait_tps + shifted_method_tps\n         };\n@@ -357,16 +336,15 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                           ty_param_bounds_and_ty {\n                               generics: ty::Generics {\n                                   type_param_defs: @new_type_param_defs,\n-                                  region_param: trait_ty_generics.region_param\n+                                  region_param_defs: @[], // fn items\n                               },\n                               ty: ty\n                           });\n     }\n \n     fn ty_method_of_trait_method(this: &CrateCtxt,\n                                  trait_id: ast::NodeId,\n-                                 trait_rp: Option<ty::region_variance>,\n-                                 trait_generics: &ast::Generics,\n+                                 trait_generics: &ty::Generics,\n                                  m_id: &ast::NodeId,\n                                  m_ident: &ast::Ident,\n                                  m_explicit_self: &ast::explicit_self,\n@@ -375,14 +353,14 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n                                  m_decl: &ast::fn_decl) -> ty::Method\n     {\n         let trait_self_ty = ty::mk_self(this.tcx, local_def(trait_id));\n-        let rscope = MethodRscope::new(m_explicit_self.node, trait_rp, trait_generics);\n         let (transformed_self_ty, fty) =\n-            astconv::ty_of_method(this, &rscope, *m_purity, &m_generics.lifetimes,\n+            astconv::ty_of_method(this, *m_id, *m_purity,\n                                   trait_self_ty, *m_explicit_self, m_decl);\n-        let num_trait_type_params = trait_generics.ty_params.len();\n+        let num_trait_type_params = trait_generics.type_param_defs.len();\n         ty::Method::new(\n             *m_ident,\n-            ty_generics(this, None, m_generics, num_trait_type_params),\n+            // FIXME -- what about lifetime parameters here?\n+            ty_generics(this, m_generics, num_trait_type_params),\n             transformed_self_ty,\n             fty,\n             m_explicit_self.node,\n@@ -398,9 +376,8 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n pub fn ensure_supertraits(ccx: &CrateCtxt,\n                           id: ast::NodeId,\n                           sp: codemap::Span,\n-                          rp: Option<ty::region_variance>,\n-                          ast_trait_refs: &[ast::trait_ref],\n-                          generics: &ast::Generics) -> ty::BuiltinBounds\n+                          ast_trait_refs: &[ast::trait_ref])\n+                          -> ty::BuiltinBounds\n {\n     let tcx = ccx.tcx;\n \n@@ -416,8 +393,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n         // FIXME(#8559): Need to instantiate the trait_ref whether or not it's a\n         // builtin trait, so that the trait's node id appears in the tcx trait_ref\n         // map. This is only needed for metadata; see the similar fixme in encoder.rs.\n-        let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, rp,\n-                                              generics, self_ty);\n+        let trait_ref = instantiate_trait_ref(ccx, ast_trait_ref, self_ty);\n         if !ty::try_add_builtin_trait(ccx.tcx, trait_def_id, &mut bounds) {\n \n             // FIXME(#5527) Could have same trait multiple times\n@@ -720,91 +696,68 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n } // fn\n \n pub fn convert_field(ccx: &CrateCtxt,\n-                     rp: Option<ty::region_variance>,\n-                     type_param_defs: @~[ty::TypeParameterDef],\n-                     v: &ast::struct_field,\n-                     generics: &ast::Generics) {\n-    let region_parameterization =\n-        RegionParameterization::from_variance_and_generics(rp, generics);\n-    let tt = ccx.to_ty(&TypeRscope(region_parameterization), &v.node.ty);\n+                     struct_generics: &ty::Generics,\n+                     v: &ast::struct_field) {\n+    let tt = ccx.to_ty(&ExplicitRscope, &v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n     /* add the field to the tcache */\n     ccx.tcx.tcache.insert(local_def(v.node.id),\n                           ty::ty_param_bounds_and_ty {\n-                              generics: ty::Generics {\n-                                  type_param_defs: type_param_defs,\n-                                  region_param: rp\n-                              },\n+                              generics: struct_generics.clone(),\n                               ty: tt\n                           });\n }\n \n-pub struct ConvertedMethod {\n-    mty: @ty::Method,\n-    id: ast::NodeId,\n-    span: Span,\n-    body_id: ast::NodeId\n-}\n-\n-pub fn convert_methods(ccx: &CrateCtxt,\n-                       container: MethodContainer,\n-                       ms: &[@ast::method],\n-                       untransformed_rcvr_ty: ty::t,\n-                       rcvr_ty_generics: &ty::Generics,\n-                       rcvr_ast_generics: &ast::Generics,\n-                       rcvr_visibility: ast::visibility)\n-                    -> ~[ConvertedMethod]\n+fn convert_methods(ccx: &CrateCtxt,\n+                   container: MethodContainer,\n+                   ms: &[@ast::method],\n+                   untransformed_rcvr_ty: ty::t,\n+                   rcvr_ty_generics: &ty::Generics,\n+                   rcvr_ast_generics: &ast::Generics,\n+                   rcvr_visibility: ast::visibility)\n {\n     let tcx = ccx.tcx;\n-    return ms.iter().map(|m| {\n+    for m in ms.iter() {\n         let num_rcvr_ty_params = rcvr_ty_generics.type_param_defs.len();\n-        let m_ty_generics =\n-            ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics,\n-                        num_rcvr_ty_params);\n+        let m_ty_generics = ty_generics(ccx, &m.generics, num_rcvr_ty_params);\n         let mty = @ty_of_method(ccx,\n                                 container,\n                                 *m,\n-                                rcvr_ty_generics.region_param,\n                                 untransformed_rcvr_ty,\n                                 rcvr_ast_generics,\n-                                rcvr_visibility,\n-                                &m.generics);\n+                                rcvr_visibility);\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n+        debug!(\"method {} (id {}) has type {}\",\n+                m.ident.repr(ccx.tcx),\n+                m.id,\n+                fty.repr(ccx.tcx));\n         tcx.tcache.insert(\n             local_def(m.id),\n \n             // n.b.: the type of a method is parameterized by both\n-            // the tps on the receiver and those on the method itself\n+            // the parameters on the receiver and those on the method itself\n             ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @vec::append(\n                         (*rcvr_ty_generics.type_param_defs).clone(),\n                         *m_ty_generics.type_param_defs),\n-                    region_param: rcvr_ty_generics.region_param\n+                    region_param_defs: rcvr_ty_generics.region_param_defs,\n                 },\n                 ty: fty\n             });\n         write_ty_to_tcx(tcx, m.id, fty);\n         tcx.methods.insert(mty.def_id, mty);\n-        ConvertedMethod {mty: mty, id: m.id,\n-                         span: m.span, body_id: m.body.id}\n-    }).collect();\n+    }\n \n     fn ty_of_method(ccx: &CrateCtxt,\n                     container: MethodContainer,\n                     m: &ast::method,\n-                    rp: Option<ty::region_variance>,\n                     untransformed_rcvr_ty: ty::t,\n                     rcvr_generics: &ast::Generics,\n-                    rcvr_visibility: ast::visibility,\n-                    method_generics: &ast::Generics) -> ty::Method\n+                    rcvr_visibility: ast::visibility) -> ty::Method\n     {\n-        let rscope = MethodRscope::new(m.explicit_self.node,\n-                                       rp,\n-                                       rcvr_generics);\n         let (transformed_self_ty, fty) =\n-            astconv::ty_of_method(ccx, &rscope, m.purity,\n-                                  &method_generics.lifetimes,\n+            astconv::ty_of_method(ccx, m.id, m.purity,\n                                   untransformed_rcvr_ty,\n                                   m.explicit_self, &m.decl);\n \n@@ -817,7 +770,8 @@ pub fn convert_methods(ccx: &CrateCtxt,\n         let num_rcvr_type_params = rcvr_generics.ty_params.len();\n         ty::Method::new(\n             m.ident,\n-            ty_generics(ccx, None, &m.generics, num_rcvr_type_params),\n+            // FIXME region param\n+            ty_generics(ccx, &m.generics, num_rcvr_type_params),\n             transformed_self_ty,\n             fty,\n             m.explicit_self.node,\n@@ -845,27 +799,22 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n \n pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n     let tcx = ccx.tcx;\n-    let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n-    debug!(\"convert: item {} with id {} rp {:?}\",\n-           tcx.sess.str_of(it.ident), it.id, rp);\n+    debug!(\"convert: item {} with id {}\", tcx.sess.str_of(it.ident), it.id);\n     match it.node {\n-      // These don't define types.\n-      ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n-      ast::item_enum(ref enum_definition, ref generics) => {\n-        ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n-        let tpt = ty_of_item(ccx, it);\n-        write_ty_to_tcx(tcx, it.id, tpt.ty);\n-        get_enum_variant_types(ccx,\n-                               tpt.ty,\n-                               enum_definition.variants,\n-                               generics,\n-                               rp);\n-      }\n+        // These don't define types.\n+        ast::item_foreign_mod(_) | ast::item_mod(_) => {}\n+        ast::item_enum(ref enum_definition, ref generics) => {\n+            ensure_no_ty_param_bounds(ccx, it.span, generics, \"enumeration\");\n+            let tpt = ty_of_item(ccx, it);\n+            write_ty_to_tcx(tcx, it.id, tpt.ty);\n+            get_enum_variant_types(ccx,\n+                                   tpt.ty,\n+                                   enum_definition.variants,\n+                                   generics);\n+        }\n       ast::item_impl(ref generics, ref opt_trait_ref, ref selfty, ref ms) => {\n-        let i_ty_generics = ty_generics(ccx, rp, generics, 0);\n-        let region_parameterization =\n-            RegionParameterization::from_variance_and_generics(rp, generics);\n-        let selfty = ccx.to_ty(&TypeRscope(region_parameterization), selfty);\n+        let i_ty_generics = ty_generics(ccx, generics, 0);\n+        let selfty = ccx.to_ty(&ExplicitRscope, selfty);\n         write_ty_to_tcx(tcx, it.id, selfty);\n         tcx.tcache.insert(local_def(it.id),\n                           ty_param_bounds_and_ty {\n@@ -883,17 +832,19 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n             it.vis\n         };\n \n-        let cms = convert_methods(ccx,\n-                                  ImplContainer(local_def(it.id)),\n-                                  *ms,\n-                                  selfty,\n-                                  &i_ty_generics,\n-                                  generics,\n-                                  parent_visibility);\n-        for t in opt_trait_ref.iter() {\n+        convert_methods(ccx,\n+                        ImplContainer(local_def(it.id)),\n+                        *ms,\n+                        selfty,\n+                        &i_ty_generics,\n+                        generics,\n+                        parent_visibility);\n+\n+        for trait_ref in opt_trait_ref.iter() {\n+            let trait_ref = instantiate_trait_ref(ccx, trait_ref, selfty);\n+\n             // Prevent the builtin kind traits from being manually implemented.\n-            let trait_def_id = ty::trait_ref_to_def_id(tcx, t);\n-            if tcx.lang_items.to_builtin_kind(trait_def_id).is_some() {\n+            if tcx.lang_items.to_builtin_kind(trait_ref.def_id).is_some() {\n                 tcx.sess.span_err(it.span,\n                     \"cannot provide an explicit implementation \\\n                      for a builtin kind\");\n@@ -903,21 +854,19 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n         }\n       }\n       ast::item_trait(ref generics, _, ref trait_methods) => {\n-          let _trait_def = trait_def_of_item(ccx, it);\n+          let trait_def = trait_def_of_item(ccx, it);\n \n           // Run convert_methods on the provided methods.\n           let (_, provided_methods) =\n               split_trait_methods(*trait_methods);\n           let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n-          let (ty_generics, _) = mk_item_substs(ccx, generics, rp,\n-                                                Some(untransformed_rcvr_ty));\n-          let _ = convert_methods(ccx,\n-                                  TraitContainer(local_def(it.id)),\n-                                  provided_methods,\n-                                  untransformed_rcvr_ty,\n-                                  &ty_generics,\n-                                  generics,\n-                                  it.vis);\n+          convert_methods(ccx,\n+                          TraitContainer(local_def(it.id)),\n+                          provided_methods,\n+                          untransformed_rcvr_ty,\n+                          &trait_def.generics,\n+                          generics,\n+                          it.vis);\n \n           // We need to do this *after* converting methods, since\n           // convert_methods produces a tcache entry that is wrong for\n@@ -932,7 +881,7 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n         write_ty_to_tcx(tcx, it.id, tpt.ty);\n         tcx.tcache.insert(local_def(it.id), tpt);\n \n-        convert_struct(ccx, rp, struct_def, generics, tpt, it.id);\n+        convert_struct(ccx, struct_def, tpt, it.id);\n       }\n       ast::item_ty(_, ref generics) => {\n         ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n@@ -950,18 +899,16 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n }\n \n pub fn convert_struct(ccx: &CrateCtxt,\n-                      rp: Option<ty::region_variance>,\n                       struct_def: &ast::struct_def,\n-                      generics: &ast::Generics,\n                       tpt: ty::ty_param_bounds_and_ty,\n                       id: ast::NodeId) {\n     let tcx = ccx.tcx;\n \n     // Write the type of each of the members\n     for f in struct_def.fields.iter() {\n-       convert_field(ccx, rp, tpt.generics.type_param_defs, *f, generics);\n+       convert_field(ccx, &tpt.generics, *f);\n     }\n-    let (_, substs) = mk_item_substs(ccx, generics, rp, None);\n+    let substs = mk_item_substs(ccx, &tpt.generics, None);\n     let selfty = ty::mk_struct(tcx, local_def(id), substs);\n \n     // If this struct is enum-like or tuple-like, create the type of its\n@@ -979,7 +926,7 @@ pub fn convert_struct(ccx: &CrateCtxt,\n                     struct_def.fields.map(\n                         |field| ccx.tcx.tcache.get(\n                             &local_def(field.node.id)).ty);\n-                let ctor_fn_ty = ty::mk_ctor_fn(tcx, inputs, selfty);\n+                let ctor_fn_ty = ty::mk_ctor_fn(tcx, ctor_id, inputs, selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.insert(local_def(ctor_id), ty_param_bounds_and_ty {\n                     generics: tpt.generics,\n@@ -1014,8 +961,6 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::foreign_item) {\n \n pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n                              ast_trait_ref: &ast::trait_ref,\n-                             rp: Option<ty::region_variance>,\n-                             generics: &ast::Generics,\n                              self_ty: ty::t) -> @ty::TraitRef\n {\n     /*!\n@@ -1024,9 +969,7 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n      * trait. Fails if the type is a type other than an trait type.\n      */\n \n-    let rp = RegionParameterization::from_variance_and_generics(rp, generics);\n-\n-    let rscope = TypeRscope(rp);\n+    let rscope = ExplicitRscope; // FIXME\n \n     match lookup_def_tcx(ccx.tcx, ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n         ast::DefTrait(trait_did) => {\n@@ -1066,14 +1009,12 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n       Some(&def) => return def,\n       _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n     match it.node {\n         ast::item_trait(ref generics, ref supertraits, _) => {\n             let self_ty = ty::mk_self(tcx, def_id);\n-            let (ty_generics, substs) = mk_item_substs(ccx, generics, rp,\n-                                                       Some(self_ty));\n-            let bounds = ensure_supertraits(ccx, it.id, it.span, rp,\n-                                            *supertraits, generics);\n+            let ty_generics = ty_generics(ccx, generics, 0);\n+            let substs = mk_item_substs(ccx, &ty_generics, Some(self_ty));\n+            let bounds = ensure_supertraits(ccx, it.id, it.span, *supertraits);\n             let trait_ref = @ty::TraitRef {def_id: def_id,\n                                            substs: substs};\n             let trait_def = @ty::TraitDef {generics: ty_generics,\n@@ -1091,93 +1032,89 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::item) -> @ty::TraitDef {\n }\n \n pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::item)\n-               -> ty::ty_param_bounds_and_ty {\n+                  -> ty::ty_param_bounds_and_ty {\n     let def_id = local_def(it.id);\n     let tcx = ccx.tcx;\n     match tcx.tcache.find(&def_id) {\n-      Some(&tpt) => return tpt,\n-      _ => {}\n+        Some(&tpt) => return tpt,\n+        _ => {}\n     }\n-    let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n     match it.node {\n-      ast::item_static(ref t, _, _) => {\n-        let typ = ccx.to_ty(&EmptyRscope, t);\n-        let tpt = no_params(typ);\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        return tpt;\n-      }\n-      ast::item_fn(ref decl, purity, abi, ref generics, _) => {\n-        assert!(rp.is_none());\n-        let ty_generics = ty_generics(ccx, None, generics, 0);\n-        let tofd = astconv::ty_of_bare_fn(ccx,\n-                                          &EmptyRscope,\n-                                          purity,\n-                                          abi,\n-                                          &generics.lifetimes,\n-                                          decl);\n-        let tpt = ty_param_bounds_and_ty {\n-            generics: ty::Generics {\n-                type_param_defs: ty_generics.type_param_defs,\n-                region_param: None\n-            },\n-            ty: ty::mk_bare_fn(ccx.tcx, tofd)\n-        };\n-        debug!(\"type of {} (id {}) is {}\",\n-               tcx.sess.str_of(it.ident),\n-               it.id,\n-               ppaux::ty_to_str(tcx, tpt.ty));\n-        ccx.tcx.tcache.insert(local_def(it.id), tpt);\n-        return tpt;\n-      }\n-      ast::item_ty(ref t, ref generics) => {\n-        match tcx.tcache.find(&local_def(it.id)) {\n-          Some(&tpt) => return tpt,\n-          None => { }\n+        ast::item_static(ref t, _, _) => {\n+            let typ = ccx.to_ty(&ExplicitRscope, t);\n+            let tpt = no_params(typ);\n+            tcx.tcache.insert(local_def(it.id), tpt);\n+            return tpt;\n         }\n-\n-        let rp = tcx.region_paramd_items.find(&it.id).map(|x| *x);\n-        let region_parameterization =\n-            RegionParameterization::from_variance_and_generics(rp, generics);\n-        let tpt = {\n-            let ty = ccx.to_ty(&TypeRscope(region_parameterization), t);\n-            ty_param_bounds_and_ty {\n-                generics: ty_generics(ccx, rp, generics, 0),\n-                ty: ty\n+        ast::item_fn(ref decl, purity, abi, ref generics, _) => {\n+            let ty_generics = ty_generics(ccx, generics, 0);\n+            let tofd = astconv::ty_of_bare_fn(ccx,\n+                                              it.id,\n+                                              purity,\n+                                              abi,\n+                                              decl);\n+            let tpt = ty_param_bounds_and_ty {\n+                generics: ty::Generics {\n+                    type_param_defs: ty_generics.type_param_defs,\n+                    region_param_defs: @[],\n+                },\n+                ty: ty::mk_bare_fn(ccx.tcx, tofd)\n+            };\n+            debug!(\"type of {} (id {}) is {}\",\n+                    tcx.sess.str_of(it.ident),\n+                    it.id,\n+                    ppaux::ty_to_str(tcx, tpt.ty));\n+            ccx.tcx.tcache.insert(local_def(it.id), tpt);\n+            return tpt;\n+        }\n+        ast::item_ty(ref t, ref generics) => {\n+            match tcx.tcache.find(&local_def(it.id)) {\n+                Some(&tpt) => return tpt,\n+                None => { }\n             }\n-        };\n \n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        return tpt;\n-      }\n-      ast::item_enum(_, ref generics) => {\n-        // Create a new generic polytype.\n-        let (ty_generics, substs) = mk_item_substs(ccx, generics, rp, None);\n-        let t = ty::mk_enum(tcx, local_def(it.id), substs);\n-        let tpt = ty_param_bounds_and_ty {\n-            generics: ty_generics,\n-            ty: t\n-        };\n-        tcx.tcache.insert(local_def(it.id), tpt);\n-        return tpt;\n-      }\n-      ast::item_trait(*) => {\n-          tcx.sess.span_bug(\n-              it.span,\n-              format!(\"Invoked ty_of_item on trait\"));\n-      }\n-      ast::item_struct(_, ref generics) => {\n-          let (ty_generics, substs) = mk_item_substs(ccx, generics, rp, None);\n-          let t = ty::mk_struct(tcx, local_def(it.id), substs);\n-          let tpt = ty_param_bounds_and_ty {\n-              generics: ty_generics,\n-              ty: t\n-          };\n-          tcx.tcache.insert(local_def(it.id), tpt);\n-          return tpt;\n-      }\n-      ast::item_impl(*) | ast::item_mod(_) |\n-      ast::item_foreign_mod(_) => fail!(),\n-      ast::item_mac(*) => fail!(\"item macros unimplemented\")\n+            let tpt = {\n+                let ty = ccx.to_ty(&ExplicitRscope, t);\n+                ty_param_bounds_and_ty {\n+                    generics: ty_generics(ccx, generics, 0),\n+                    ty: ty\n+                }\n+            };\n+\n+            tcx.tcache.insert(local_def(it.id), tpt);\n+            return tpt;\n+        }\n+        ast::item_enum(_, ref generics) => {\n+            // Create a new generic polytype.\n+            let ty_generics = ty_generics(ccx, generics, 0);\n+            let substs = mk_item_substs(ccx, &ty_generics, None);\n+            let t = ty::mk_enum(tcx, local_def(it.id), substs);\n+            let tpt = ty_param_bounds_and_ty {\n+                generics: ty_generics,\n+                ty: t\n+            };\n+            tcx.tcache.insert(local_def(it.id), tpt);\n+            return tpt;\n+        }\n+        ast::item_trait(*) => {\n+            tcx.sess.span_bug(\n+                it.span,\n+                format!(\"Invoked ty_of_item on trait\"));\n+        }\n+        ast::item_struct(_, ref generics) => {\n+            let ty_generics = ty_generics(ccx, generics, 0);\n+            let substs = mk_item_substs(ccx, &ty_generics, None);\n+            let t = ty::mk_struct(tcx, local_def(it.id), substs);\n+            let tpt = ty_param_bounds_and_ty {\n+                generics: ty_generics,\n+                ty: t\n+            };\n+            tcx.tcache.insert(local_def(it.id), tpt);\n+            return tpt;\n+        }\n+        ast::item_impl(*) | ast::item_mod(_) |\n+        ast::item_foreign_mod(_) => fail!(),\n+        ast::item_mac(*) => fail!(\"item macros unimplemented\")\n     }\n }\n \n@@ -1197,28 +1134,29 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n             ty::ty_param_bounds_and_ty {\n                 generics: ty::Generics {\n                     type_param_defs: @~[],\n-                    region_param: None,\n+                    region_param_defs: @[],\n                 },\n-                ty: ast_ty_to_ty(ccx, &EmptyRscope, t)\n+                ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n             }\n         }\n     }\n }\n \n pub fn ty_generics(ccx: &CrateCtxt,\n-                   rp: Option<ty::region_variance>,\n                    generics: &ast::Generics,\n                    base_index: uint) -> ty::Generics {\n     return ty::Generics {\n-        region_param: rp,\n+        region_param_defs: generics.lifetimes.iter().map(|l| {\n+                ty::RegionParameterDef { ident: l.ident,\n+                                         def_id: local_def(l.id) }\n+            }).collect(),\n         type_param_defs: @generics.ty_params.mapi_to_vec(|offset, param| {\n             match ccx.tcx.ty_param_defs.find(&param.id) {\n                 Some(&def) => def,\n                 None => {\n                     let param_ty = ty::param_ty {idx: base_index + offset,\n                                                  def_id: local_def(param.id)};\n-                    let bounds = @compute_bounds(ccx, rp, generics,\n-                                                 param_ty, &param.bounds);\n+                    let bounds = @compute_bounds(ccx, param_ty, &param.bounds);\n                     let def = ty::TypeParameterDef {\n                         ident: param.ident,\n                         def_id: local_def(param.id),\n@@ -1234,13 +1172,10 @@ pub fn ty_generics(ccx: &CrateCtxt,\n \n     fn compute_bounds(\n         ccx: &CrateCtxt,\n-        rp: Option<ty::region_variance>,\n-        generics: &ast::Generics,\n         param_ty: ty::param_ty,\n         ast_bounds: &OptVec<ast::TyParamBound>) -> ty::ParamBounds\n     {\n         /*!\n-         *\n          * Translate the AST's notion of ty param bounds (which are an\n          * enum consisting of a newtyped Ty or a region) to ty's\n          * notion of ty param bounds, which can either be user-defined\n@@ -1256,7 +1191,7 @@ pub fn ty_generics(ccx: &CrateCtxt,\n             match *ast_bound {\n                 TraitTyParamBound(ref b) => {\n                     let ty = ty::mk_param(ccx.tcx, param_ty.idx, param_ty.def_id);\n-                    let trait_ref = instantiate_trait_ref(ccx, b, rp, generics, ty);\n+                    let trait_ref = instantiate_trait_ref(ccx, b, ty);\n                     if !ty::try_add_builtin_trait(\n                         ccx.tcx, trait_ref.def_id,\n                         &mut param_bounds.builtin_bounds)\n@@ -1282,9 +1217,8 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              ast_generics: &ast::Generics,\n                              abis: AbiSet)\n                           -> ty::ty_param_bounds_and_ty {\n-    let ty_generics = ty_generics(ccx, None, ast_generics, 0);\n-    let region_param_names = RegionParamNames::from_generics(ast_generics);\n-    let rb = in_binding_rscope(&EmptyRscope, region_param_names);\n+    let ty_generics = ty_generics(ccx, ast_generics, 0);\n+    let rb = BindingRscope::new(def_id.node);\n     let input_tys = decl.inputs.map(|a| ty_of_arg(ccx, &rb, a, None) );\n     let output_ty = ast_ty_to_ty(ccx, &rb, &decl.output);\n \n@@ -1293,12 +1227,10 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         ty::BareFnTy {\n             abis: abis,\n             purity: ast::unsafe_fn,\n-            sig: ty::FnSig {\n-                bound_lifetime_names: opt_vec::Empty,\n-                inputs: input_tys,\n-                output: output_ty,\n-                variadic: decl.variadic\n-            }\n+            sig: ty::FnSig {binder_id: def_id.node,\n+                            inputs: input_tys,\n+                            output: output_ty,\n+                            variadic: decl.variadic}\n         });\n     let tpt = ty_param_bounds_and_ty {\n         generics: ty_generics,\n@@ -1309,19 +1241,18 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n }\n \n pub fn mk_item_substs(ccx: &CrateCtxt,\n-                      ast_generics: &ast::Generics,\n-                      rp: Option<ty::region_variance>,\n-                      self_ty: Option<ty::t>) -> (ty::Generics, ty::substs)\n+                      ty_generics: &ty::Generics,\n+                      self_ty: Option<ty::t>) -> ty::substs\n {\n-    let mut i = 0;\n-    let ty_generics = ty_generics(ccx, rp, ast_generics, 0);\n-    let params = ast_generics.ty_params.map_to_vec(|atp| {\n-        let t = ty::mk_param(ccx.tcx, i, local_def(atp.id));\n-        i += 1u;\n-        t\n-    });\n-    let regions = rscope::bound_self_region(rp);\n-    (ty_generics, substs {regions: ty::NonerasedRegions(regions),\n-                          self_ty: self_ty,\n-                          tps: params})\n+    let params: ~[ty::t] =\n+        ty_generics.type_param_defs.iter().enumerate().map(\n+            |(i, t)| ty::mk_param(ccx.tcx, i, t.def_id)).collect();\n+\n+    let regions: OptVec<ty::Region> =\n+        ty_generics.region_param_defs.iter().enumerate().map(\n+            |(i, l)| ty::re_type_bound(l.def_id.node, i, l.ident)).collect();\n+\n+    substs {regions: ty::NonerasedRegions(regions),\n+            self_ty: self_ty,\n+            tps: params}\n }"}, {"sha": "d6d1618de71005f24fe1557f80864b318f0bf438", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -429,23 +429,20 @@ pub fn super_fn_sigs<C:Combine>(this: &C, a: &ty::FnSig, b: &ty::FnSig) -> cres<\n         return Err(ty::terr_variadic_mismatch(expected_found(this, a.variadic, b.variadic)));\n     }\n \n-    do argvecs(this, a.inputs, b.inputs)\n-            .and_then |inputs| {\n-        do this.tys(a.output, b.output).and_then |output| {\n-            Ok(FnSig {\n-                bound_lifetime_names: opt_vec::Empty, // FIXME(#4846)\n-                inputs: inputs.clone(),\n-                output: output,\n-                variadic: a.variadic\n-            })\n-        }\n-    }\n+    let inputs = if_ok!(argvecs(this, a.inputs, b.inputs));\n+    let output = if_ok!(this.tys(a.output, b.output));\n+    Ok(FnSig {binder_id: a.binder_id,\n+              inputs: inputs,\n+              output: output,\n+              variadic: a.variadic})\n }\n \n-pub fn super_tys<C:Combine>(\n-    this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n+pub fn super_tys<C:Combine>(this: &C, a: ty::t, b: ty::t) -> cres<ty::t> {\n     let tcx = this.infcx().tcx;\n-    return match (&ty::get(a).sty, &ty::get(b).sty) {\n+    let a_sty = &ty::get(a).sty;\n+    let b_sty = &ty::get(b).sty;\n+    debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n+    return match (a_sty, b_sty) {\n       // The \"subtype\" ought to be handling cases involving bot or var:\n       (&ty::ty_bot, _) |\n       (_, &ty::ty_bot) |\n@@ -494,6 +491,7 @@ pub fn super_tys<C:Combine>(\n             unify_float_variable(this, !this.a_is_expected(), v_id, v)\n         }\n \n+      (&ty::ty_char, _) |\n       (&ty::ty_nil, _) |\n       (&ty::ty_bool, _) |\n       (&ty::ty_int(_), _) |"}, {"sha": "78e0bd17ecaa824f09f323e42be59480247ee35e", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 48, "deletions": 47, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -20,15 +20,13 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::fold_regions_in_sig;\n-use middle::typeck::isr_alist;\n use syntax::ast::{Many, Once, extern_fn, impure_fn, MutImmutable, MutMutable};\n-use syntax::ast::{unsafe_fn};\n+use syntax::ast::{unsafe_fn, NodeId};\n use syntax::ast::{Onceness, purity};\n+use std::hashmap::HashMap;\n use util::common::{indenter};\n use util::ppaux::mt_to_str;\n \n-use extra::list;\n-\n pub struct Glb(CombineFields);  // \"greatest lower bound\" (common subtype)\n \n impl Combine for Glb {\n@@ -132,14 +130,14 @@ impl Combine for Glb {\n         let snapshot = self.infcx.region_vars.start_snapshot();\n \n         // Instantiate each bound region with a fresh region variable.\n-        let (a_with_fresh, a_isr) =\n+        let (a_with_fresh, a_map) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n                 self.trace, a);\n-        let a_vars = var_ids(self, a_isr);\n-        let (b_with_fresh, b_isr) =\n+        let a_vars = var_ids(self, &a_map);\n+        let (b_with_fresh, b_map) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n                 self.trace, b);\n-        let b_vars = var_ids(self, b_isr);\n+        let b_vars = var_ids(self, &b_map);\n \n         // Collect constraints.\n         let sig0 = if_ok!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n@@ -152,20 +150,23 @@ impl Combine for Glb {\n             fold_regions_in_sig(\n                 self.infcx.tcx,\n                 &sig0,\n-                |r, _in_fn| generalize_region(self, snapshot,\n-                                              new_vars, a_isr, a_vars, b_vars,\n-                                              r));\n+                |r| generalize_region(self, snapshot,\n+                                      new_vars, sig0.binder_id,\n+                                      &a_map, a_vars, b_vars,\n+                                      r));\n         debug!(\"sig1 = {}\", sig1.inf_str(self.infcx));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Glb,\n                              snapshot: uint,\n                              new_vars: &[RegionVid],\n-                             a_isr: isr_alist,\n+                             new_binder_id: NodeId,\n+                             a_map: &HashMap<ty::bound_region, ty::Region>,\n                              a_vars: &[RegionVid],\n                              b_vars: &[RegionVid],\n                              r0: ty::Region) -> ty::Region {\n             if !is_var_in_set(new_vars, r0) {\n+                assert!(!r0.is_bound());\n                 return r0;\n             }\n \n@@ -177,13 +178,13 @@ impl Combine for Glb {\n             for r in tainted.iter() {\n                 if is_var_in_set(a_vars, *r) {\n                     if a_r.is_some() {\n-                        return fresh_bound_variable(this);\n+                        return fresh_bound_variable(this, new_binder_id);\n                     } else {\n                         a_r = Some(*r);\n                     }\n                 } else if is_var_in_set(b_vars, *r) {\n                     if b_r.is_some() {\n-                        return fresh_bound_variable(this);\n+                        return fresh_bound_variable(this, new_binder_id);\n                     } else {\n                         b_r = Some(*r);\n                     }\n@@ -192,57 +193,57 @@ impl Combine for Glb {\n                 }\n             }\n \n-                // NB---I do not believe this algorithm computes\n-                // (necessarily) the GLB.  As written it can\n-                // spuriously fail.  In particular, if there is a case\n-                // like: &fn(fn(&a)) and fn(fn(&b)), where a and b are\n-                // free, it will return fn(&c) where c = GLB(a,b).  If\n-                // however this GLB is not defined, then the result is\n-                // an error, even though something like\n-                // \"fn<X>(fn(&X))\" where X is bound would be a\n-                // subtype of both of those.\n-                //\n-                // The problem is that if we were to return a bound\n-                // variable, we'd be computing a lower-bound, but not\n-                // necessarily the *greatest* lower-bound.\n+            // NB---I do not believe this algorithm computes\n+            // (necessarily) the GLB.  As written it can\n+            // spuriously fail.  In particular, if there is a case\n+            // like: &fn(fn(&a)) and fn(fn(&b)), where a and b are\n+            // free, it will return fn(&c) where c = GLB(a,b).  If\n+            // however this GLB is not defined, then the result is\n+            // an error, even though something like\n+            // \"fn<X>(fn(&X))\" where X is bound would be a\n+            // subtype of both of those.\n+            //\n+            // The problem is that if we were to return a bound\n+            // variable, we'd be computing a lower-bound, but not\n+            // necessarily the *greatest* lower-bound.\n+            //\n+            // Unfortunately, this problem is non-trivial to solve,\n+            // because we do not know at the time of computing the GLB\n+            // whether a GLB(a,b) exists or not, because we haven't\n+            // run region inference (or indeed, even fully computed\n+            // the region hierarchy!). The current algorithm seems to\n+            // works ok in practice.\n \n             if a_r.is_some() && b_r.is_some() && only_new_vars {\n                 // Related to exactly one bound variable from each fn:\n-                return rev_lookup(this, a_isr, a_r.unwrap());\n+                return rev_lookup(this, a_map, new_binder_id, a_r.unwrap());\n             } else if a_r.is_none() && b_r.is_none() {\n                 // Not related to bound variables from either fn:\n+                assert!(!r0.is_bound());\n                 return r0;\n             } else {\n                 // Other:\n-                return fresh_bound_variable(this);\n+                return fresh_bound_variable(this, new_binder_id);\n             }\n         }\n \n         fn rev_lookup(this: &Glb,\n-                      a_isr: isr_alist,\n+                      a_map: &HashMap<ty::bound_region, ty::Region>,\n+                      new_binder_id: NodeId,\n                       r: ty::Region) -> ty::Region\n         {\n-            let mut ret = None;\n-            do list::each(a_isr) |pair| {\n-                let (a_br, a_r) = *pair;\n-                if a_r == r {\n-                    ret = Some(ty::re_bound(a_br));\n-                    false\n-                } else {\n-                    true\n+            for (a_br, a_r) in a_map.iter() {\n+                if *a_r == r {\n+                    return ty::re_fn_bound(new_binder_id, *a_br);\n                 }\n-            };\n-\n-            match ret {\n-                Some(x) => x,\n-                None => this.infcx.tcx.sess.span_bug(\n-                            this.trace.origin.span(),\n-                            format!(\"could not find original bound region for {:?}\", r))\n             }\n+            this.infcx.tcx.sess.span_bug(\n+                this.trace.origin.span(),\n+                format!(\"could not find original bound region for {:?}\", r))\n         }\n \n-        fn fresh_bound_variable(this: &Glb) -> ty::Region {\n-            this.infcx.region_vars.new_bound()\n+        fn fresh_bound_variable(this: &Glb, binder_id: NodeId) -> ty::Region {\n+            this.infcx.region_vars.new_bound(binder_id)\n         }\n     }\n }"}, {"sha": "9aaa4be1181f7db762e566d1a872c180537f4436", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 11, "deletions": 17, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -35,18 +35,16 @@\n \n use middle::ty::{RegionVid, TyVar, Vid};\n use middle::ty;\n-use middle::typeck::isr_alist;\n use middle::typeck::infer::*;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::glb::Glb;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::unify::*;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::to_str::InferStr;\n+use std::hashmap::HashMap;\n use util::common::indenter;\n \n-use extra::list;\n-\n pub trait LatticeValue {\n     fn sub(cf: &CombineFields, a: &Self, b: &Self) -> ures;\n     fn lub(cf: &CombineFields, a: &Self, b: &Self) -> cres<Self>;\n@@ -366,14 +364,13 @@ impl TyLatticeDir for Glb {\n     }\n }\n \n-pub fn super_lattice_tys<L:LatticeDir + TyLatticeDir + Combine>(\n-    this: &L,\n-    a: ty::t,\n-    b: ty::t) -> cres<ty::t> {\n+pub fn super_lattice_tys<L:LatticeDir+TyLatticeDir+Combine>(this: &L,\n+                                                            a: ty::t,\n+                                                            b: ty::t)\n+                                                            -> cres<ty::t> {\n     debug!(\"{}.lattice_tys({}, {})\", this.tag(),\n            a.inf_str(this.infcx()),\n            b.inf_str(this.infcx()));\n-    let _r = indenter();\n \n     if a == b {\n         return Ok(a);\n@@ -524,20 +521,17 @@ pub fn lattice_var_and_t<L:LatticeDir + Combine,\n // Random utility functions used by LUB/GLB when computing LUB/GLB of\n // fn types\n \n-pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n-    let mut result = ~[];\n-    do list::each(isr) |pair| {\n-        match pair.second() {\n-            ty::re_infer(ty::ReVar(r)) => { result.push(r); }\n+pub fn var_ids<T:Combine>(this: &T,\n+                          map: &HashMap<ty::bound_region, ty::Region>)\n+                          -> ~[RegionVid] {\n+    map.iter().map(|(_, r)| match *r {\n+            ty::re_infer(ty::ReVar(r)) => { r }\n             r => {\n                 this.infcx().tcx.sess.span_bug(\n                     this.trace().origin.span(),\n                     format!(\"Found non-region-vid: {:?}\", r));\n             }\n-        }\n-        true\n-    };\n-    result\n+        }).collect()\n }\n \n pub fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {"}, {"sha": "ad649f379b58ca9086681f6d2eeaa373e217c0be", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -20,13 +20,11 @@ use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::{TypeTrace, Subtype};\n-use middle::typeck::isr_alist;\n-use util::ppaux::mt_to_str;\n-\n-use extra::list;\n-use syntax::ast::{Many, Once, extern_fn, impure_fn};\n+use std::hashmap::HashMap;\n+use syntax::ast::{Many, Once, extern_fn, impure_fn, NodeId};\n use syntax::ast::{unsafe_fn};\n use syntax::ast::{Onceness, purity};\n+use util::ppaux::mt_to_str;\n \n pub struct Lub(CombineFields);  // least-upper-bound: common supertype\n \n@@ -125,7 +123,7 @@ impl Combine for Lub {\n         let snapshot = self.infcx.region_vars.start_snapshot();\n \n         // Instantiate each bound region with a fresh region variable.\n-        let (a_with_fresh, a_isr) =\n+        let (a_with_fresh, a_map) =\n             self.infcx.replace_bound_regions_with_fresh_regions(\n                 self.trace, a);\n         let (b_with_fresh, _) =\n@@ -143,17 +141,20 @@ impl Combine for Lub {\n             fold_regions_in_sig(\n                 self.infcx.tcx,\n                 &sig0,\n-                |r, _in_fn| generalize_region(self, snapshot, new_vars,\n-                                              a_isr, r));\n+                |r| generalize_region(self, snapshot, new_vars,\n+                                      sig0.binder_id, &a_map, r));\n         return Ok(sig1);\n \n         fn generalize_region(this: &Lub,\n                              snapshot: uint,\n                              new_vars: &[RegionVid],\n-                             a_isr: isr_alist,\n-                             r0: ty::Region) -> ty::Region {\n+                             new_scope: NodeId,\n+                             a_map: &HashMap<ty::bound_region, ty::Region>,\n+                             r0: ty::Region)\n+                             -> ty::Region {\n             // Regions that pre-dated the LUB computation stay as they are.\n             if !is_var_in_set(new_vars, r0) {\n+                assert!(!r0.is_bound());\n                 debug!(\"generalize_region(r0={:?}): not new variable\", r0);\n                 return r0;\n             }\n@@ -167,6 +168,7 @@ impl Combine for Lub {\n                 debug!(\"generalize_region(r0={:?}): \\\n                         non-new-variables found in {:?}\",\n                        r0, tainted);\n+                assert!(!r0.is_bound());\n                 return r0;\n             }\n \n@@ -175,27 +177,19 @@ impl Combine for Lub {\n             // in both A and B.  Replace the variable with the \"first\"\n             // bound region from A that we find it to be associated\n             // with.\n-            let mut ret = None;\n-            do list::each(a_isr) |pair| {\n-                let (a_br, a_r) = *pair;\n-                if tainted.iter().any(|x| x == &a_r) {\n+            for (a_br, a_r) in a_map.iter() {\n+                if tainted.iter().any(|x| x == a_r) {\n                     debug!(\"generalize_region(r0={:?}): \\\n                             replacing with {:?}, tainted={:?}\",\n-                           r0, a_br, tainted);\n-                    ret = Some(ty::re_bound(a_br));\n-                    false\n-                } else {\n-                    true\n+                           r0, *a_br, tainted);\n+                    return ty::re_fn_bound(new_scope, *a_br);\n                 }\n-            };\n-\n-            match ret {\n-                Some(x) => x,\n-                None => this.infcx.tcx.sess.span_bug(\n-                            this.trace.origin.span(),\n-                            format!(\"Region {:?} is not associated with \\\n-                                  any bound region from A!\", r0))\n             }\n+\n+            this.infcx.tcx.sess.span_bug(\n+                this.trace.origin.span(),\n+                format!(\"Region {:?} is not associated with \\\n+                        any bound region from A!\", r0))\n         }\n     }\n "}, {"sha": "121b32f4145a4e73daae8c2dc1e2cb3fc81368db", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -20,8 +20,11 @@ pub use middle::typeck::infer::resolve::{resolve_ivar, resolve_all};\n pub use middle::typeck::infer::resolve::{resolve_nested_tvar};\n pub use middle::typeck::infer::resolve::{resolve_rvar};\n \n+use extra::smallintmap::SmallIntMap;\n use middle::ty::{TyVid, IntVid, FloatVid, RegionVid, Vid};\n use middle::ty;\n+use middle::ty_fold;\n+use middle::ty_fold::TypeFolder;\n use middle::typeck::check::regionmanip::{replace_bound_regions_in_fn_sig};\n use middle::typeck::infer::coercion::Coerce;\n use middle::typeck::infer::combine::{Combine, CombineFields, eq_tys};\n@@ -32,19 +35,16 @@ use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::to_str::InferStr;\n use middle::typeck::infer::unify::{ValsAndBindings, Root};\n use middle::typeck::infer::error_reporting::ErrorReporting;\n-use middle::typeck::isr_alist;\n-use util::common::indent;\n-use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr,\n-                  UserString};\n-\n+use std::hashmap::HashMap;\n use std::result;\n use std::vec;\n-use extra::list::Nil;\n-use extra::smallintmap::SmallIntMap;\n use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n+use util::common::indent;\n+use util::ppaux::{bound_region_to_str, ty_to_str, trait_ref_to_str, Repr,\n+                  UserString};\n \n pub mod doc;\n pub mod macros;\n@@ -225,8 +225,6 @@ pub enum RegionVariableOrigin {\n     BoundRegionInTypeOrImpl(Span),\n \n     BoundRegionInCoherence,\n-\n-    BoundRegionError(Span),\n }\n \n pub enum fixup_err {\n@@ -568,15 +566,16 @@ impl InferCtxt {\n     /// Execute `f`, unroll bindings on failure\n     pub fn try<T,E>(@mut self, f: &fn() -> Result<T,E>) -> Result<T,E> {\n         debug!(\"try()\");\n-        do indent {\n-            let snapshot = self.start_snapshot();\n-            let r = f();\n-            match r {\n-              Ok(_) => (),\n-              Err(_) => self.rollback_to(&snapshot)\n+        let snapshot = self.start_snapshot();\n+        let r = f();\n+        match r {\n+            Ok(_) => { debug!(\"success\"); }\n+            Err(ref e) => {\n+                debug!(\"error: {:?}\", *e);\n+                self.rollback_to(&snapshot)\n             }\n-            r\n         }\n+        r\n     }\n \n     /// Execute `f` then unroll any bindings it creates\n@@ -642,6 +641,17 @@ impl InferCtxt {\n         ty::re_infer(ty::ReVar(self.region_vars.new_region_var(origin)))\n     }\n \n+    pub fn next_region_vars(&mut self,\n+                            origin: RegionVariableOrigin,\n+                            count: uint)\n+                            -> ~[ty::Region] {\n+        vec::from_fn(count, |_| self.next_region_var(origin))\n+    }\n+\n+    pub fn fresh_bound_region(&mut self, binder_id: ast::NodeId) -> ty::Region {\n+        self.region_vars.new_bound(binder_id)\n+    }\n+\n     pub fn resolve_regions(@mut self) {\n         let errors = self.region_vars.resolve_regions();\n         self.report_region_errors(&errors); // see error_reporting.rs\n@@ -787,28 +797,28 @@ impl InferCtxt {\n     pub fn replace_bound_regions_with_fresh_regions(&mut self,\n                                                     trace: TypeTrace,\n                                                     fsig: &ty::FnSig)\n-                                                    -> (ty::FnSig, isr_alist) {\n-        let(isr, _, fn_sig) =\n-            replace_bound_regions_in_fn_sig(self.tcx, @Nil, None, fsig, |br| {\n+                                                    -> (ty::FnSig,\n+                                                        HashMap<ty::bound_region,\n+                                                                ty::Region>) {\n+        let (map, _, fn_sig) =\n+            replace_bound_regions_in_fn_sig(self.tcx, None, fsig, |br| {\n                 let rvar = self.next_region_var(\n                     BoundRegionInFnType(trace.origin.span(), br));\n                 debug!(\"Bound region {} maps to {:?}\",\n                        bound_region_to_str(self.tcx, \"\", false, br),\n                        rvar);\n                 rvar\n             });\n-        (fn_sig, isr)\n+        (fn_sig, map)\n     }\n }\n \n pub fn fold_regions_in_sig(\n     tcx: ty::ctxt,\n     fn_sig: &ty::FnSig,\n-    fldr: &fn(r: ty::Region, in_fn: bool) -> ty::Region) -> ty::FnSig\n+    fldr: &fn(r: ty::Region) -> ty::Region) -> ty::FnSig\n {\n-    do ty::fold_sig(fn_sig) |t| {\n-        ty::fold_regions(tcx, t, |r, in_fn| fldr(r, in_fn))\n-    }\n+    ty_fold::RegionFolder::regions(tcx, fldr).fold_sig(fn_sig)\n }\n \n impl TypeTrace {\n@@ -910,7 +920,6 @@ impl RegionVariableOrigin {\n             BoundRegionInFnType(a, _) => a,\n             BoundRegionInTypeOrImpl(a) => a,\n             BoundRegionInCoherence => codemap::dummy_sp(),\n-            BoundRegionError(a) => a,\n         }\n     }\n }\n@@ -931,7 +940,6 @@ impl Repr for RegionVariableOrigin {\n             BoundRegionInTypeOrImpl(a) => format!(\"BoundRegionInTypeOrImpl({})\",\n                                                a.repr(tcx)),\n             BoundRegionInCoherence => format!(\"BoundRegionInCoherence\"),\n-            BoundRegionError(a) => format!(\"BoundRegionError({})\", a.repr(tcx)),\n         }\n     }\n }"}, {"sha": "effd34da0de9d767b83780bc6739e5975fdbe36d", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 54, "deletions": 34, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -13,7 +13,8 @@\n \n use middle::ty;\n use middle::ty::{FreeRegion, Region, RegionVid};\n-use middle::ty::{re_empty, re_static, re_infer, re_free, re_bound};\n+use middle::ty::{re_empty, re_static, re_infer, re_free, re_type_bound,\n+                 re_fn_bound};\n use middle::ty::{re_scope, ReVar, ReSkolemized, br_fresh};\n use middle::typeck::infer::cres;\n use middle::typeck::infer::{RegionVariableOrigin, SubregionOrigin};\n@@ -192,24 +193,33 @@ impl RegionVarBindings {\n         re_infer(ReSkolemized(sc, br))\n     }\n \n-    pub fn new_bound(&mut self) -> Region {\n+    pub fn new_bound(&mut self, binder_id: ast::NodeId) -> Region {\n         // Creates a fresh bound variable for use in GLB computations.\n         // See discussion of GLB computation in the large comment at\n         // the top of this file for more details.\n         //\n-        // This computation is mildly wrong in the face of rollover.\n-        // It's conceivable, if unlikely, that one might wind up with\n-        // accidental capture for nested functions in that case, if\n-        // the outer function had bound regions created a very long\n-        // time before and the inner function somehow wound up rolling\n-        // over such that supposedly fresh identifiers were in fact\n-        // shadowed.  We should convert our bound_region\n-        // representation to use deBruijn indices or something like\n-        // that to eliminate that possibility.\n+        // This computation is potentially wrong in the face of\n+        // rollover.  It's conceivable, if unlikely, that one might\n+        // wind up with accidental capture for nested functions in\n+        // that case, if the outer function had bound regions created\n+        // a very long time before and the inner function somehow\n+        // wound up rolling over such that supposedly fresh\n+        // identifiers were in fact shadowed. For now, we just assert\n+        // that there is no rollover -- eventually we should try to be\n+        // robust against this possibility, either by checking the set\n+        // of bound identifiers that appear in a given expression and\n+        // ensure that we generate one that is distinct, or by\n+        // changing the representation of bound regions in a fn\n+        // declaration\n \n         let sc = self.bound_count;\n         self.bound_count += 1;\n-        re_bound(br_fresh(sc))\n+\n+        if sc >= self.bound_count {\n+            self.tcx.sess.bug(\"Rollover in RegionInference new_bound()\");\n+        }\n+\n+        re_fn_bound(binder_id, br_fresh(sc))\n     }\n \n     pub fn add_constraint(&mut self,\n@@ -236,6 +246,16 @@ impl RegionVarBindings {\n \n         debug!(\"RegionVarBindings: make_subregion({:?}, {:?})\", sub, sup);\n         match (sub, sup) {\n+          (re_type_bound(*), _) |\n+          (re_fn_bound(*), _) |\n+          (_, re_type_bound(*)) |\n+          (_, re_fn_bound(*)) => {\n+            self.tcx.sess.span_bug(\n+                origin.span(),\n+                format!(\"Cannot relate bound region: {} <= {}\",\n+                        sub.repr(self.tcx),\n+                        sup.repr(self.tcx)));\n+          }\n           (re_infer(ReVar(sub_id)), re_infer(ReVar(sup_id))) => {\n             self.add_constraint(ConstrainVarSubVar(sub_id, sup_id), origin);\n           }\n@@ -245,16 +265,6 @@ impl RegionVarBindings {\n           (re_infer(ReVar(sub_id)), r) => {\n             self.add_constraint(ConstrainVarSubReg(sub_id, r), origin);\n           }\n-          (re_bound(br), _) => {\n-            self.tcx.sess.span_bug(\n-                origin.span(),\n-                format!(\"Cannot relate bound region as subregion: {:?}\", br));\n-          }\n-          (_, re_bound(br)) => {\n-            self.tcx.sess.span_bug(\n-                origin.span(),\n-                format!(\"Cannot relate bound region as superregion: {:?}\", br));\n-          }\n           _ => {\n             self.add_constraint(ConstrainRegSubReg(sub, sup), origin);\n           }\n@@ -485,6 +495,16 @@ impl RegionVarBindings {\n \n     fn lub_concrete_regions(&self, a: Region, b: Region) -> Region {\n         match (a, b) {\n+          (re_fn_bound(*), _) |\n+          (_, re_fn_bound(*)) |\n+          (re_type_bound(*), _) |\n+          (_, re_type_bound(*)) => {\n+            self.tcx.sess.bug(\n+                format!(\"Cannot relate bound region: LUB({}, {})\",\n+                        a.repr(self.tcx),\n+                        b.repr(self.tcx)));\n+          }\n+\n           (re_static, _) | (_, re_static) => {\n             re_static // nothing lives longer than static\n           }\n@@ -536,12 +556,7 @@ impl RegionVarBindings {\n           // For these types, we cannot define any additional\n           // relationship:\n           (re_infer(ReSkolemized(*)), _) |\n-          (_, re_infer(ReSkolemized(*))) |\n-          (re_bound(_), re_bound(_)) |\n-          (re_bound(_), re_free(_)) |\n-          (re_bound(_), re_scope(_)) |\n-          (re_free(_), re_bound(_)) |\n-          (re_scope(_), re_bound(_)) => {\n+          (_, re_infer(ReSkolemized(*))) => {\n             if a == b {a} else {re_static}\n           }\n         }\n@@ -584,6 +599,16 @@ impl RegionVarBindings {\n                          -> cres<Region> {\n         debug!(\"glb_concrete_regions({:?}, {:?})\", a, b);\n         match (a, b) {\n+            (re_fn_bound(*), _) |\n+            (_, re_fn_bound(*)) |\n+            (re_type_bound(*), _) |\n+            (_, re_type_bound(*)) => {\n+              self.tcx.sess.bug(\n+                  format!(\"Cannot relate bound region: GLB({}, {})\",\n+                          a.repr(self.tcx),\n+                          b.repr(self.tcx)));\n+            }\n+\n             (re_static, r) | (r, re_static) => {\n                 // static lives longer than everything else\n                 Ok(r)\n@@ -627,12 +652,7 @@ impl RegionVarBindings {\n             // For these types, we cannot define any additional\n             // relationship:\n             (re_infer(ReSkolemized(*)), _) |\n-            (_, re_infer(ReSkolemized(*))) |\n-            (re_bound(_), re_bound(_)) |\n-            (re_bound(_), re_free(_)) |\n-            (re_bound(_), re_scope(_)) |\n-            (re_free(_), re_bound(_)) |\n-            (re_scope(_), re_bound(_)) => {\n+            (_, re_infer(ReSkolemized(*))) => {\n                 if a == b {\n                     Ok(a)\n                 } else {"}, {"sha": "84f3d9c69379bb49d08595c37e504817efc85023", "filename": "src/librustc/middle/typeck/infer/resolve.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fresolve.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -50,6 +50,7 @@\n use middle::ty::{FloatVar, FloatVid, IntVar, IntVid, RegionVid, TyVar, TyVid};\n use middle::ty::{type_is_bot, IntType, UintType};\n use middle::ty;\n+use middle::ty_fold;\n use middle::typeck::infer::{Bounds, cyclic_ty, fixup_err, fres, InferCtxt};\n use middle::typeck::infer::{region_var_bound_by_region_var, unresolved_ty};\n use middle::typeck::infer::to_str::InferStr;\n@@ -96,6 +97,20 @@ pub fn resolver(infcx: @mut InferCtxt, modes: uint) -> ResolveState {\n     }\n }\n \n+impl ty_fold::TypeFolder for ResolveState {\n+    fn tcx(&self) -> ty::ctxt {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: ty::t) -> ty::t {\n+        self.resolve_type(t)\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region) -> ty::Region {\n+        self.resolve_region(r)\n+    }\n+}\n+\n impl ResolveState {\n     pub fn should(&mut self, mode: uint) -> bool {\n         (self.modes & mode) == mode\n@@ -166,11 +181,7 @@ impl ResolveState {\n                     typ\n                 } else {\n                     self.type_depth += 1;\n-                    let result = ty::fold_regions_and_ty(\n-                        self.infcx.tcx, typ,\n-                        |r| self.resolve_region(r),\n-                        |t| self.resolve_type(t),\n-                        |t| self.resolve_type(t));\n+                    let result = ty_fold::super_fold_ty(self, typ);\n                     self.type_depth -= 1;\n                     result\n                 }"}, {"sha": "802d635a3f0c0edcb2502acdde448345d562363f", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -24,8 +24,6 @@ use middle::typeck::infer::{TypeTrace, Subtype};\n use util::common::{indenter};\n use util::ppaux::bound_region_to_str;\n \n-use extra::list::Nil;\n-use extra::list;\n use syntax::ast::{Onceness, purity};\n \n pub struct Sub(CombineFields);  // \"subtype\", \"subregion\" etc\n@@ -168,9 +166,8 @@ impl Combine for Sub {\n \n         // Second, we instantiate each bound region in the supertype with a\n         // fresh concrete region.\n-        let (skol_isr, _, b_sig) = {\n-            do replace_bound_regions_in_fn_sig(self.infcx.tcx, @Nil,\n-                                              None, b) |br| {\n+        let (skol_map, _, b_sig) = {\n+            do replace_bound_regions_in_fn_sig(self.infcx.tcx, None, b) |br| {\n                 let skol = self.infcx.region_vars.new_skolemized(br);\n                 debug!(\"Bound region {} skolemized to {:?}\",\n                        bound_region_to_str(self.infcx.tcx, \"\", false, br),\n@@ -189,10 +186,7 @@ impl Combine for Sub {\n         // that the skolemized regions do not \"leak\".\n         let new_vars =\n             self.infcx.region_vars.vars_created_since_snapshot(snapshot);\n-\n-        let mut ret = Ok(sig);\n-        do list::each(skol_isr) |pair| {\n-            let (skol_br, skol) = *pair;\n+        for (&skol_br, &skol) in skol_map.iter() {\n             let tainted = self.infcx.region_vars.tainted(snapshot, skol);\n             for tainted_region in tainted.iter() {\n                 // Each skolemized should only be relatable to itself\n@@ -208,19 +202,16 @@ impl Combine for Sub {\n \n                 // A is not as polymorphic as B:\n                 if self.a_is_expected {\n-                    ret = Err(ty::terr_regions_insufficiently_polymorphic(\n-                        skol_br, *tainted_region));\n-                    break\n+                    return Err(ty::terr_regions_insufficiently_polymorphic(\n+                            skol_br, *tainted_region));\n                 } else {\n-                    ret = Err(ty::terr_regions_overly_polymorphic(\n-                        skol_br, *tainted_region));\n-                    break\n+                    return Err(ty::terr_regions_overly_polymorphic(\n+                            skol_br, *tainted_region));\n                 }\n             }\n-            ret.is_ok()\n-        };\n+        }\n \n-        ret\n+        return Ok(sig);\n     }\n \n }"}, {"sha": "022c0ffb432541f05ac7b82e6823bc0c4e0392f7", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -64,7 +64,6 @@ use extra::list;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n-use syntax::opt_vec;\n \n pub mod check;\n pub mod rscope;\n@@ -266,7 +265,7 @@ pub fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n pub fn no_params(t: ty::t) -> ty::ty_param_bounds_and_ty {\n     ty::ty_param_bounds_and_ty {\n         generics: ty::Generics {type_param_defs: @~[],\n-                                region_param: None},\n+                                region_param_defs: @[]},\n         ty: t\n     }\n }\n@@ -354,7 +353,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n                 purity: ast::impure_fn,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n-                    bound_lifetime_names: opt_vec::Empty,\n+                    binder_id: main_id,\n                     inputs: ~[],\n                     output: ty::mk_nil(),\n                     variadic: false\n@@ -400,7 +399,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n                 purity: ast::impure_fn,\n                 abis: abi::AbiSet::Rust(),\n                 sig: ty::FnSig {\n-                    bound_lifetime_names: opt_vec::Empty,\n+                    binder_id: start_id,\n                     inputs: ~[\n                         ty::mk_int(),\n                         ty::mk_imm_ptr(tcx, ty::mk_imm_ptr(tcx, ty::mk_u8()))"}, {"sha": "89dc71b3af648241ba834e98b8e1947316b2e102", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 118, "deletions": 34, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -11,10 +11,10 @@\n \n use metadata::encoder;\n use middle::ty::{ReSkolemized, ReVar};\n-use middle::ty::{bound_region, br_anon, br_named, br_self, br_cap_avoid};\n+use middle::ty::{bound_region, br_anon, br_named};\n use middle::ty::{br_fresh, ctxt, field};\n use middle::ty::{mt, t, param_ty};\n-use middle::ty::{re_bound, re_free, re_scope, re_infer, re_static, Region,\n+use middle::ty::{re_free, re_scope, re_infer, re_static, Region,\n                  re_empty};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_estr, ty_evec, ty_float, ty_bare_fn, ty_closure};\n@@ -118,6 +118,11 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n             let (msg, opt_span) = explain_span(cx, \"block\", blk.span);\n             (format!(\"{} {}\", prefix, msg), opt_span)\n           }\n+          Some(&ast_map::node_item(it, _)) if match it.node {\n+                ast::item_impl(*) => true, _ => false} => {\n+            let (msg, opt_span) = explain_span(cx, \"impl\", it.span);\n+            (format!(\"{} {}\", prefix, msg), opt_span)\n+          }\n           Some(_) | None => {\n             // this really should not happen\n             (format!(\"{} node {}\", prefix, fr.scope_id), None)\n@@ -131,7 +136,7 @@ pub fn explain_region_and_span(cx: ctxt, region: ty::Region)\n \n       // I believe these cases should not occur (except when debugging,\n       // perhaps)\n-      re_infer(_) | re_bound(_) => {\n+      ty::re_infer(_) | ty::re_type_bound(*) | ty::re_fn_bound(*) => {\n         (format!(\"lifetime {:?}\", region), None)\n       }\n     };\n@@ -154,14 +159,15 @@ pub fn bound_region_to_str(cx: ctxt,\n                            br: bound_region) -> ~str {\n     let space_str = if space { \" \" } else { \"\" };\n \n-    if cx.sess.verbose() { return format!(\"{}{:?}{}\", prefix, br, space_str); }\n+    if cx.sess.verbose() {\n+        return format!(\"{}{}{}\", prefix, br.repr(cx), space_str);\n+    }\n \n     match br {\n-      br_named(id)         => format!(\"{}'{}{}\", prefix, cx.sess.str_of(id), space_str),\n-      br_self              => format!(\"{}'self{}\", prefix, space_str),\n+      br_named(_, ident)   => format!(\"{}'{}{}\", prefix,\n+                                      cx.sess.str_of(ident), space_str),\n       br_anon(_)           => prefix.to_str(),\n       br_fresh(_)          => prefix.to_str(),\n-      br_cap_avoid(_, br)  => bound_region_to_str(cx, prefix, space, *br)\n     }\n }\n \n@@ -215,23 +221,24 @@ pub fn region_to_str(cx: ctxt, prefix: &str, space: bool, region: Region) -> ~st\n     let space_str = if space { \" \" } else { \"\" };\n \n     if cx.sess.verbose() {\n-        return format!(\"{}{:?}{}\", prefix, region, space_str);\n+        return format!(\"{}{}{}\", prefix, region.repr(cx), space_str);\n     }\n \n     // These printouts are concise.  They do not contain all the information\n     // the user might want to diagnose an error, but there is basically no way\n     // to fit that into a short string.  Hence the recommendation to use\n     // `explain_region()` or `note_and_explain_region()`.\n     match region {\n-        re_scope(_) => prefix.to_str(),\n-        re_bound(br) => bound_region_to_str(cx, prefix, space, br),\n-        re_free(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n-        re_infer(ReSkolemized(_, br)) => {\n+        ty::re_scope(_) => prefix.to_str(),\n+        ty::re_type_bound(_, _, ident) => cx.sess.str_of(ident).to_owned(),\n+        ty::re_fn_bound(_, br) => bound_region_to_str(cx, prefix, space, br),\n+        ty::re_free(ref fr) => bound_region_to_str(cx, prefix, space, fr.bound_region),\n+        ty::re_infer(ReSkolemized(_, br)) => {\n             bound_region_to_str(cx, prefix, space, br)\n         }\n-        re_infer(ReVar(_)) => prefix.to_str(),\n-        re_static => format!(\"{}'static{}\", prefix, space_str),\n-        re_empty => format!(\"{}'<empty>{}\", prefix, space_str)\n+        ty::re_infer(ReVar(_)) => prefix.to_str(),\n+        ty::re_static => format!(\"{}'static{}\", prefix, space_str),\n+        ty::re_empty => format!(\"{}'<empty>{}\", prefix, space_str)\n     }\n }\n \n@@ -289,9 +296,10 @@ pub fn tys_to_str(cx: ctxt, ts: &[t]) -> ~str {\n }\n \n pub fn fn_sig_to_str(cx: ctxt, typ: &ty::FnSig) -> ~str {\n-    format!(\"fn{} -> {}\",\n-         tys_to_str(cx, typ.inputs.map(|a| *a)),\n-         ty_to_str(cx, typ.output))\n+    format!(\"fn{}{} -> {}\",\n+            typ.binder_id,\n+            typ.inputs.repr(cx),\n+            typ.output.repr(cx))\n }\n \n pub fn trait_ref_to_str(cx: ctxt, trait_ref: &ty::TraitRef) -> ~str {\n@@ -594,8 +602,17 @@ impl<T:Repr> Repr for ~[T] {\n \n impl Repr for ty::TypeParameterDef {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"TypeParameterDef \\\\{{:?}, bounds: {}\\\\}\",\n-             self.def_id, self.bounds.repr(tcx))\n+        format!(\"TypeParameterDef({:?}, {})\",\n+                self.def_id,\n+                self.bounds.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::RegionParameterDef {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        format!(\"RegionParameterDef({}, {:?})\",\n+                tcx.sess.str_of(self.ident),\n+                self.def_id)\n     }\n }\n \n@@ -655,6 +672,15 @@ impl Repr for ast::Expr {\n     }\n }\n \n+impl Repr for ast::item {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        format!(\"item({})\",\n+                ast_map::node_id_to_str(tcx.items,\n+                                        self.id,\n+                                        token::get_ident_interner()))\n+    }\n+}\n+\n impl Repr for ast::Pat {\n     fn repr(&self, tcx: ctxt) -> ~str {\n         format!(\"pat({}: {})\",\n@@ -665,13 +691,56 @@ impl Repr for ast::Pat {\n \n impl Repr for ty::bound_region {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        bound_region_ptr_to_str(tcx, *self)\n+        match *self {\n+            ty::br_anon(id) => format!(\"br_anon({})\", id),\n+            ty::br_named(id, ident) => format!(\"br_named({}, {})\",\n+                                               id.repr(tcx),\n+                                               ident.repr(tcx)),\n+            ty::br_fresh(id) => format!(\"br_fresh({})\", id),\n+        }\n     }\n }\n \n impl Repr for ty::Region {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        region_to_str(tcx, \"\", false, *self)\n+        match *self {\n+            ty::re_type_bound(id, index, ident) => {\n+                format!(\"re_type_bound({}, {}, {})\",\n+                        id, index, ident.repr(tcx))\n+            }\n+\n+            ty::re_fn_bound(binder_id, ref bound_region) => {\n+                format!(\"re_fn_bound({}, {})\",\n+                        binder_id, bound_region.repr(tcx))\n+            }\n+\n+            ty::re_free(ref fr) => {\n+                format!(\"re_free({}, {})\",\n+                        fr.scope_id,\n+                        fr.bound_region.repr(tcx))\n+            }\n+\n+            ty::re_scope(id) => {\n+                format!(\"re_scope({})\", id)\n+            }\n+\n+            ty::re_static => {\n+                format!(\"re_static\")\n+            }\n+\n+            ty::re_infer(ReVar(ref vid)) => {\n+                format!(\"re_infer({})\", vid.id)\n+            }\n+\n+            ty::re_infer(ReSkolemized(id, ref bound_region)) => {\n+                format!(\"re_skolemized({}, {})\",\n+                        id, bound_region.repr(tcx))\n+            }\n+\n+            ty::re_empty => {\n+                format!(\"re_empty\")\n+            }\n+        }\n     }\n }\n \n@@ -707,23 +776,38 @@ impl Repr for ty::ty_param_bounds_and_ty {\n \n impl Repr for ty::Generics {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"Generics \\\\{type_param_defs: {}, region_param: {:?}\\\\}\",\n-             self.type_param_defs.repr(tcx),\n-             self.region_param)\n+        format!(\"Generics(type_param_defs: {}, region_param_defs: {})\",\n+                self.type_param_defs.repr(tcx),\n+                self.region_param_defs.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::ItemVariances {\n+    fn repr(&self, tcx: ctxt) -> ~str {\n+        format!(\"IterVariances(self_param={}, type_params={}, region_params={})\",\n+                self.self_param.repr(tcx),\n+                self.type_params.repr(tcx),\n+                self.region_params.repr(tcx))\n+    }\n+}\n+\n+impl Repr for ty::Variance {\n+    fn repr(&self, _: ctxt) -> ~str {\n+        self.to_str().to_owned()\n     }\n }\n \n impl Repr for ty::Method {\n     fn repr(&self, tcx: ctxt) -> ~str {\n-        format!(\"method \\\\{ident: {}, generics: {}, transformed_self_ty: {}, \\\n-              fty: {}, explicit_self: {}, vis: {}, def_id: {}\\\\}\",\n-             self.ident.repr(tcx),\n-             self.generics.repr(tcx),\n-             self.transformed_self_ty.repr(tcx),\n-             self.fty.repr(tcx),\n-             self.explicit_self.repr(tcx),\n-             self.vis.repr(tcx),\n-             self.def_id.repr(tcx))\n+        format!(\"method(ident: {}, generics: {}, transformed_self_ty: {}, \\\n+                fty: {}, explicit_self: {}, vis: {}, def_id: {})\",\n+                self.ident.repr(tcx),\n+                self.generics.repr(tcx),\n+                self.transformed_self_ty.repr(tcx),\n+                self.fty.repr(tcx),\n+                self.explicit_self.repr(tcx),\n+                self.vis.repr(tcx),\n+                self.def_id.repr(tcx))\n     }\n }\n "}, {"sha": "f48ad25712d1226cd129f13637f6a1433f22406e", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -835,15 +835,15 @@ impl Clean<Path> for ast::Path {\n #[deriving(Clone, Encodable, Decodable)]\n pub struct PathSegment {\n     name: ~str,\n-    lifetime: Option<Lifetime>,\n+    lifetimes: ~[Lifetime],\n     types: ~[Type],\n }\n \n impl Clean<PathSegment> for ast::PathSegment {\n     fn clean(&self) -> PathSegment {\n         PathSegment {\n             name: self.identifier.clean(),\n-            lifetime: self.lifetime.clean(),\n+            lifetimes: self.lifetimes.clean(),\n             types: self.types.clean()\n         }\n     }"}, {"sha": "4c64feee384397ed5f1ef198e41aa8c13b99343d", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -92,16 +92,17 @@ impl fmt::Default for clean::Path {\n             if i > 0 { f.buf.write(\"::\".as_bytes()) }\n             f.buf.write(seg.name.as_bytes());\n \n-            if seg.lifetime.is_some() || seg.types.len() > 0 {\n+            if seg.lifetimes.len() > 0 || seg.types.len() > 0 {\n                 f.buf.write(\"&lt;\".as_bytes());\n-                match seg.lifetime {\n-                    Some(ref lifetime) => write!(f.buf, \"{}\", *lifetime),\n-                    None => {}\n+                let mut comma = false;\n+                for lifetime in seg.lifetimes.iter() {\n+                    if comma { f.buf.write(\", \".as_bytes()); }\n+                    comma = true;\n+                    write!(f.buf, \"{}\", *lifetime);\n                 }\n-                for (i, ty) in seg.types.iter().enumerate() {\n-                    if i > 0 || seg.lifetime.is_some() {\n-                        f.buf.write(\", \".as_bytes());\n-                    }\n+                for ty in seg.types.iter() {\n+                    if comma { f.buf.write(\", \".as_bytes()); }\n+                    comma = true;\n                     write!(f.buf, \"{}\", *ty);\n                 }\n                 f.buf.write(\"&gt;\".as_bytes());\n@@ -152,16 +153,17 @@ fn path(w: &mut io::Writer, path: &clean::Path, print_all: bool,\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n     let last = path.segments.last();\n-    if last.lifetime.is_some() || last.types.len() > 0 {\n+    if last.lifetimes.len() > 0 || last.types.len() > 0 {\n+        let mut counter = 0;\n         generics.push_str(\"&lt;\");\n-        match last.lifetime {\n-            Some(ref lifetime) => generics.push_str(format!(\"{}\", *lifetime)),\n-            None => {}\n+        for lifetime in last.lifetimes.iter() {\n+            if counter > 0 { generics.push_str(\", \"); }\n+            counter += 1;\n+            generics.push_str(format!(\"{}\", *lifetime));\n         }\n-        for (i, ty) in last.types.iter().enumerate() {\n-            if i > 0 || last.lifetime.is_some() {\n-                generics.push_str(\", \");\n-            }\n+        for ty in last.types.iter() {\n+            if counter > 0 { generics.push_str(\", \"); }\n+            counter += 1;\n             generics.push_str(format!(\"{}\", *ty));\n         }\n         generics.push_str(\"&gt;\");\n@@ -495,7 +497,7 @@ impl fmt::Default for clean::ViewListIdent {\n                     global: false,\n                     segments: ~[clean::PathSegment {\n                         name: v.name.clone(),\n-                        lifetime: None,\n+                        lifetimes: ~[],\n                         types: ~[],\n                     }]\n                 };"}, {"sha": "90729966c18a64be77025e69ad8826ab5081584c", "filename": "src/libstd/at_vec.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibstd%2Fat_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibstd%2Fat_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fat_vec.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -12,7 +12,7 @@\n \n use clone::Clone;\n use container::Container;\n-use iter::Iterator;\n+use iter::{Iterator, FromIterator};\n use option::{Option, Some, None};\n use mem;\n use unstable::raw::Repr;\n@@ -134,6 +134,17 @@ impl<T> Clone for @[T] {\n     }\n }\n \n+impl<A> FromIterator<A> for @[A] {\n+    fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> @[A] {\n+        let (lower, _) = iterator.size_hint();\n+        do build(Some(lower)) |push| {\n+            for x in *iterator {\n+                push(x);\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(not(test))]\n #[allow(missing_doc)]\n pub mod traits {"}, {"sha": "6245c61dfa1844fc5673bad1d6a11d0141731118", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -28,7 +28,7 @@ use extra::serialize::{Encodable, Decodable, Encoder, Decoder};\n // table) and a SyntaxContext to track renaming and\n // macro expansion per Flatt et al., \"Macros\n // That Work Together\"\n-#[deriving(Clone, IterBytes, ToStr)]\n+#[deriving(Clone, IterBytes, ToStr, TotalEq, TotalOrd)]\n pub struct Ident { name: Name, ctxt: SyntaxContext }\n \n impl Ident {\n@@ -110,6 +110,7 @@ pub enum SyntaxContext_ {\n /// A name is a part of an identifier, representing a string or gensym. It's\n /// the result of interning.\n pub type Name = uint;\n+\n /// A mark represents a unique id associated with a macro expansion\n pub type Mrk = uint;\n \n@@ -156,9 +157,8 @@ pub struct Path {\n pub struct PathSegment {\n     /// The identifier portion of this path segment.\n     identifier: Ident,\n-    /// The lifetime parameter for this path segment. Currently only one\n-    /// lifetime parameter is allowed.\n-    lifetime: Option<Lifetime>,\n+    /// The lifetime parameters for this path segment.\n+    lifetimes: OptVec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     types: OptVec<Ty>,\n }\n@@ -167,7 +167,7 @@ pub type CrateNum = int;\n \n pub type NodeId = int;\n \n-#[deriving(Clone, Eq, Encodable, Decodable, IterBytes, ToStr)]\n+#[deriving(Clone, TotalEq, TotalOrd, Eq, Encodable, Decodable, IterBytes, ToStr)]\n pub struct DefId {\n     crate: CrateNum,\n     node: NodeId,"}, {"sha": "f3d7ac1804db79f7431369a738f9a919cf6c6e25", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -488,3 +488,15 @@ pub fn node_item_query<Result>(items: map, id: NodeId,\n         _ => fail!(\"{}\", error_msg)\n     }\n }\n+\n+pub fn item_span(items: map,\n+                 id: ast::NodeId)\n+                 -> Span {\n+    match items.find(&id) {\n+        Some(&node_item(item, _)) => item.span,\n+        r => {\n+            fail!(format!(\"item_span: expected item with id {} but found {:?}\",\n+                           id, r))\n+        }\n+    }\n+}"}, {"sha": "ccae25dc012ac8866a643cf3850c17a5335e2543", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -225,7 +225,7 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n         segments: ~[\n             ast::PathSegment {\n                 identifier: identifier,\n-                lifetime: None,\n+                lifetimes: opt_vec::Empty,\n                 types: opt_vec::Empty,\n             }\n         ],\n@@ -948,7 +948,7 @@ pub fn segments_name_eq(a : &[ast::PathSegment], b : &[ast::PathSegment]) -> boo\n         for (idx,seg) in a.iter().enumerate() {\n             if (seg.identifier.name != b[idx].identifier.name)\n                 // FIXME #7743: ident -> name problems in lifetime comparison?\n-                || (seg.lifetime != b[idx].lifetime)\n+                || (seg.lifetimes != b[idx].lifetimes)\n                 // can types contain idents?\n                 || (seg.types != b[idx].types) {\n                 return false;\n@@ -966,7 +966,9 @@ mod test {\n     use std::hashmap::HashMap;\n \n     fn ident_to_segment(id : &Ident) -> PathSegment {\n-        PathSegment{identifier:id.clone(), lifetime: None, types: opt_vec::Empty}\n+        PathSegment {identifier:id.clone(),\n+                     lifetimes: opt_vec::Empty,\n+                     types: opt_vec::Empty}\n     }\n \n     #[test] fn idents_name_eq_test() {"}, {"sha": "5ae158045e0e72e289430f48732e84ef8d52a4a1", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -38,7 +38,7 @@ pub trait AstBuilder {\n     fn path_all(&self, sp: Span,\n                 global: bool,\n                 idents: ~[ast::Ident],\n-                rp: Option<ast::Lifetime>,\n+                lifetimes: OptVec<ast::Lifetime>,\n                 types: ~[ast::Ty])\n         -> ast::Path;\n \n@@ -237,33 +237,33 @@ pub trait AstBuilder {\n \n impl AstBuilder for @ExtCtxt {\n     fn path(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n-        self.path_all(span, false, strs, None, ~[])\n+        self.path_all(span, false, strs, opt_vec::Empty, ~[])\n     }\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n         self.path(span, ~[id])\n     }\n     fn path_global(&self, span: Span, strs: ~[ast::Ident]) -> ast::Path {\n-        self.path_all(span, true, strs, None, ~[])\n+        self.path_all(span, true, strs, opt_vec::Empty, ~[])\n     }\n     fn path_all(&self,\n                 sp: Span,\n                 global: bool,\n                 mut idents: ~[ast::Ident],\n-                rp: Option<ast::Lifetime>,\n+                lifetimes: OptVec<ast::Lifetime>,\n                 types: ~[ast::Ty])\n                 -> ast::Path {\n         let last_identifier = idents.pop();\n         let mut segments: ~[ast::PathSegment] = idents.move_iter()\n                                                       .map(|ident| {\n             ast::PathSegment {\n                 identifier: ident,\n-                lifetime: None,\n+                lifetimes: opt_vec::Empty,\n                 types: opt_vec::Empty,\n             }\n         }).collect();\n         segments.push(ast::PathSegment {\n             identifier: last_identifier,\n-            lifetime: rp,\n+            lifetimes: lifetimes,\n             types: opt_vec::from(types),\n         });\n         ast::Path {\n@@ -327,7 +327,7 @@ impl AstBuilder for @ExtCtxt {\n                               self.ident_of(\"option\"),\n                               self.ident_of(\"Option\")\n                           ],\n-                          None,\n+                          opt_vec::Empty,\n                           ~[ ty ]), None)\n     }\n "}, {"sha": "216bc3097ce9402ef86150ac0f6c3e32a62ea538", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -43,7 +43,7 @@ pub fn expand_syntax_ext(cx: @ExtCtxt, sp: Span, tts: &[ast::token_tree])\n                  segments: ~[\n                     ast::PathSegment {\n                         identifier: res,\n-                        lifetime: None,\n+                        lifetimes: opt_vec::Empty,\n                         types: opt_vec::Empty,\n                     }\n                 ]"}, {"sha": "b37757341efd8fea67b42cba87e03576afd6b191", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -375,14 +375,10 @@ impl<'self> TraitDef<'self> {\n             cx.ty_ident(trait_span, ty_param.ident)\n         };\n \n-        let self_lifetime = if generics.lifetimes.is_empty() {\n-            None\n-        } else {\n-            Some(*generics.lifetimes.get(0))\n-        };\n+        let self_lifetimes = generics.lifetimes.clone();\n \n         // Create the type of `self`.\n-        let self_type = cx.ty_path(cx.path_all(trait_span, false, ~[ type_ident ], self_lifetime,\n+        let self_type = cx.ty_path(cx.path_all(trait_span, false, ~[ type_ident ], self_lifetimes,\n                                                opt_vec::take_vec(self_ty_params)), None);\n \n         let doc_attr = cx.attribute("}, {"sha": "d014816c070c113c202e8f37c2160eeb1967b5da", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -14,6 +14,7 @@ use codemap::Span;\n use ext::base::ExtCtxt;\n use ext::build::{AstBuilder};\n use ext::deriving::generic::*;\n+use opt_vec;\n \n pub fn expand_deriving_rand(cx: @ExtCtxt,\n                             span: Span,\n@@ -77,7 +78,7 @@ fn rand_substructure(cx: @ExtCtxt, span: Span, substr: &Substructure) -> @Expr {\n             let rand_name = cx.path_all(span,\n                                         true,\n                                         rand_ident.clone(),\n-                                        None,\n+                                        opt_vec::Empty,\n                                         ~[]);\n             let rand_name = cx.expr_path(rand_name);\n "}, {"sha": "d1a5af5f7e8911102811fa26ed2c04a0569bd848", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -19,6 +19,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{Span,respan};\n use opt_vec;\n+use opt_vec::OptVec;\n \n /// The types of pointers\n pub enum PtrTy<'self> {\n@@ -71,7 +72,7 @@ impl<'self> Path<'self> {\n                    self_generics: &Generics)\n                    -> ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n-        let lt = mk_lifetime(cx, span, &self.lifetime);\n+        let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n \n         cx.path_all(span, self.global, idents, lt, tys)\n@@ -116,6 +117,13 @@ fn mk_lifetime(cx: @ExtCtxt, span: Span, lt: &Option<&str>) -> Option<ast::Lifet\n     }\n }\n \n+fn mk_lifetimes(cx: @ExtCtxt, span: Span, lt: &Option<&str>) -> OptVec<ast::Lifetime> {\n+    match *lt {\n+        Some(ref s) => opt_vec::with(cx.lifetime(span, cx.ident_of(*s))),\n+        None => opt_vec::Empty\n+    }\n+}\n+\n impl<'self> Ty<'self> {\n     pub fn to_ty(&self,\n                  cx: @ExtCtxt,\n@@ -166,13 +174,9 @@ impl<'self> Ty<'self> {\n                 let self_params = do self_generics.ty_params.map |ty_param| {\n                     cx.ty_ident(span, ty_param.ident)\n                 };\n-                let lifetime = if self_generics.lifetimes.is_empty() {\n-                    None\n-                } else {\n-                    Some(*self_generics.lifetimes.get(0))\n-                };\n+                let lifetimes = self_generics.lifetimes.clone();\n \n-                cx.path_all(span, false, ~[self_ty], lifetime,\n+                cx.path_all(span, false, ~[self_ty], lifetimes,\n                             opt_vec::take_vec(self_params))\n             }\n             Literal(ref p) => {"}, {"sha": "b74349da2a9fa6b80e7e88cb75a26001d38d2115", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -169,7 +169,7 @@ pub fn expand_expr(extsbox: @mut SyntaxEnv,\n                     segments: ~[\n                         ast::PathSegment {\n                             identifier: ident,\n-                            lifetime: None,\n+                            lifetimes: opt_vec::Empty,\n                             types: opt_vec::Empty,\n                         }\n                     ],\n@@ -628,7 +628,7 @@ impl Visitor<()> for NewNameFinderContext {\n                         segments: [\n                             ast::PathSegment {\n                                 identifier: id,\n-                                lifetime: _,\n+                                lifetimes: _,\n                                 types: _\n                             }\n                         ]"}, {"sha": "00919fce5db6cf79ddf1451630c24dc0e757113f", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -15,7 +15,7 @@ use ext::base;\n use ext::build::AstBuilder;\n use rsparse = parse;\n use parse::token;\n-\n+use opt_vec;\n use std::fmt::parse;\n use std::hashmap::{HashMap, HashSet};\n use std::vec;\n@@ -464,7 +464,7 @@ impl Context {\n                 sp,\n                 true,\n                 rtpath(\"Method\"),\n-                Some(life),\n+                opt_vec::with(life),\n                 ~[]\n             ), None);\n             let st = ast::item_static(ty, ast::MutImmutable, method);\n@@ -582,7 +582,8 @@ impl Context {\n                     self.ecx.ident_of(\"rt\"),\n                     self.ecx.ident_of(\"Piece\"),\n                 ],\n-                Some(self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\"))),\n+                opt_vec::with(\n+                    self.ecx.lifetime(self.fmtsp, self.ecx.ident_of(\"static\"))),\n                 ~[]\n             ), None);\n         let ty = ast::ty_fixed_length_vec("}, {"sha": "ea0ab95a45105358ce4aa269870049cdab3c8c2d", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -144,7 +144,7 @@ pub trait ast_fold {\n             ident: self.fold_ident(m.ident),\n             attrs: m.attrs.map(|a| fold_attribute_(*a, self)),\n             generics: fold_generics(&m.generics, self),\n-            explicit_self: m.explicit_self,\n+            explicit_self: self.fold_explicit_self(&m.explicit_self),\n             purity: m.purity,\n             decl: fold_fn_decl(&m.decl, self),\n             body: self.fold_block(&m.body),\n@@ -245,12 +245,14 @@ pub trait ast_fold {\n             ty_uniq(ref mt) => ty_uniq(fold_mt(mt, self)),\n             ty_vec(ref mt) => ty_vec(fold_mt(mt, self)),\n             ty_ptr(ref mt) => ty_ptr(fold_mt(mt, self)),\n-            ty_rptr(region, ref mt) => ty_rptr(region, fold_mt(mt, self)),\n+            ty_rptr(ref region, ref mt) => {\n+                ty_rptr(fold_opt_lifetime(region, self), fold_mt(mt, self))\n+            }\n             ty_closure(ref f) => {\n                 ty_closure(@TyClosure {\n                     sigil: f.sigil,\n                     purity: f.purity,\n-                    region: f.region,\n+                    region: fold_opt_lifetime(&f.region, self),\n                     onceness: f.onceness,\n                     bounds: fold_opt_bounds(&f.bounds, self),\n                     decl: fold_fn_decl(&f.decl, self),\n@@ -349,7 +351,7 @@ pub trait ast_fold {\n             global: p.global,\n             segments: p.segments.map(|segment| ast::PathSegment {\n                 identifier: self.fold_ident(segment.identifier),\n-                lifetime: segment.lifetime,\n+                lifetimes: segment.lifetimes.map(|l| fold_lifetime(l, self)),\n                 types: segment.types.map(|typ| self.fold_ty(typ)),\n             })\n         }\n@@ -389,6 +391,24 @@ pub trait ast_fold {\n     fn new_span(&self, sp: Span) -> Span {\n         sp\n     }\n+\n+    fn fold_explicit_self(&self, es: &explicit_self) -> explicit_self {\n+        Spanned {\n+            span: self.new_span(es.span),\n+            node: self.fold_explicit_self_(&es.node)\n+        }\n+    }\n+\n+    fn fold_explicit_self_(&self, es: &explicit_self_) -> explicit_self_ {\n+        match *es {\n+            sty_static | sty_value(_) | sty_uniq(_) | sty_box(_) => {\n+                *es\n+            }\n+            sty_region(ref lifetime, m) => {\n+                sty_region(fold_opt_lifetime(lifetime, self), m)\n+            }\n+        }\n+    }\n }\n \n /* some little folds that probably aren't useful to have in ast_fold itself*/\n@@ -505,6 +525,11 @@ pub fn fold_lifetimes<T:ast_fold>(lts: &OptVec<Lifetime>, fld: &T)\n     lts.map(|l| fold_lifetime(l, fld))\n }\n \n+pub fn fold_opt_lifetime<T:ast_fold>(o_lt: &Option<Lifetime>, fld: &T)\n+                                     -> Option<Lifetime> {\n+    o_lt.as_ref().map(|lt| fold_lifetime(lt, fld))\n+}\n+\n pub fn fold_generics<T:ast_fold>(generics: &Generics, fld: &T) -> Generics {\n     Generics {ty_params: fold_ty_params(&generics.ty_params, fld),\n               lifetimes: fold_lifetimes(&generics.lifetimes, fld)}\n@@ -675,7 +700,7 @@ pub fn noop_fold_type_method<T:ast_fold>(m: &TypeMethod, fld: &T)\n         purity: m.purity,\n         decl: fold_fn_decl(&m.decl, fld),\n         generics: fold_generics(&m.generics, fld),\n-        explicit_self: m.explicit_self,\n+        explicit_self: fld.fold_explicit_self(&m.explicit_self),\n         id: fld.new_id(m.id),\n         span: fld.new_span(m.span),\n     }"}, {"sha": "4d39d4df72f5363123e9c302e6d3b4bcbfb5c2d7", "filename": "src/libsyntax/opt_vec.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fopt_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fopt_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fopt_vec.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -165,3 +165,13 @@ impl<'self, T> Iterator<&'self T> for OptVecIterator<'self, T> {\n         }\n     }\n }\n+\n+impl<A> FromIterator<A> for OptVec<A> {\n+    fn from_iterator<T: Iterator<A>>(iterator: &mut T) -> OptVec<A> {\n+        let mut r = Empty;\n+        for x in *iterator {\n+            r.push(x);\n+        }\n+        r\n+    }\n+}"}, {"sha": "672865aadcc2672123a45a47375f9b079b945bab", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -368,7 +368,7 @@ mod test {\n                         segments: ~[\n                             ast::PathSegment {\n                                 identifier: str_to_ident(\"a\"),\n-                                lifetime: None,\n+                                lifetimes: opt_vec::Empty,\n                                 types: opt_vec::Empty,\n                             }\n                         ],\n@@ -387,12 +387,12 @@ mod test {\n                             segments: ~[\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"a\"),\n-                                    lifetime: None,\n+                                    lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 },\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetime: None,\n+                                    lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n                             ]\n@@ -592,7 +592,7 @@ mod test {\n                             segments: ~[\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"d\"),\n-                                    lifetime: None,\n+                                    lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n                             ],\n@@ -614,7 +614,7 @@ mod test {\n                                segments: ~[\n                                 ast::PathSegment {\n                                     identifier: str_to_ident(\"b\"),\n-                                    lifetime: None,\n+                                    lifetimes: opt_vec::Empty,\n                                     types: opt_vec::Empty,\n                                 }\n                                ],\n@@ -641,7 +641,7 @@ mod test {\n                                     segments: ~[\n                                         ast::PathSegment {\n                                             identifier: str_to_ident(\"b\"),\n-                                            lifetime: None,\n+                                            lifetimes: opt_vec::Empty,\n                                             types: opt_vec::Empty,\n                                         }\n                                     ],\n@@ -669,7 +669,7 @@ mod test {\n                                             ast::PathSegment {\n                                                 identifier:\n                                                     str_to_ident(\"int\"),\n-                                                lifetime: None,\n+                                                lifetimes: opt_vec::Empty,\n                                                 types: opt_vec::Empty,\n                                             }\n                                         ],\n@@ -687,7 +687,7 @@ mod test {\n                                                     ast::PathSegment {\n                                                         identifier:\n                                                             str_to_ident(\"b\"),\n-                                                        lifetime: None,\n+                                                        lifetimes: opt_vec::Empty,\n                                                         types: opt_vec::Empty,\n                                                     }\n                                                 ],\n@@ -724,8 +724,8 @@ mod test {\n                                                                 identifier:\n                                                                 str_to_ident(\n                                                                     \"b\"),\n-                                                                lifetime:\n-                                                                    None,\n+                                                                lifetimes:\n+                                                                opt_vec::Empty,\n                                                                 types:\n                                                                 opt_vec::Empty\n                                                             }"}, {"sha": "cfb4da87720becaf97ca6bb29c68df389faf7491", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 15, "deletions": 40, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -1490,7 +1490,7 @@ impl Parser {\n                 segments.push(PathSegmentAndBoundSet {\n                     segment: ast::PathSegment {\n                         identifier: identifier,\n-                        lifetime: None,\n+                        lifetimes: opt_vec::Empty,\n                         types: opt_vec::Empty,\n                     },\n                     bound_set: bound_set\n@@ -1499,46 +1499,21 @@ impl Parser {\n             }\n \n             // Parse the `<` before the lifetime and types, if applicable.\n-            let (any_lifetime_or_types, optional_lifetime, types) =\n-                    if mode != NoTypesAllowed && self.eat(&token::LT) {\n-                // Parse an optional lifetime.\n-                let optional_lifetime = match *self.token {\n-                    token::LIFETIME(*) => Some(self.parse_lifetime()),\n-                    _ => None,\n-                };\n-\n-                // Parse type parameters.\n-                let mut types = opt_vec::Empty;\n-                let mut need_comma = optional_lifetime.is_some();\n-                loop {\n-                    // We're done if we see a `>`.\n-                    match *self.token {\n-                        token::GT | token::BINOP(token::SHR) => {\n-                            self.expect_gt();\n-                            break\n-                        }\n-                        _ => {} // Go on.\n-                    }\n-\n-                    if need_comma {\n-                        self.expect(&token::COMMA)\n-                    } else {\n-                        need_comma = true\n-                    }\n-\n-                    types.push(self.parse_ty(false))\n+            let (any_lifetime_or_types, lifetimes, types) = {\n+                if mode != NoTypesAllowed && self.eat(&token::LT) {\n+                    let (lifetimes, types) =\n+                        self.parse_generic_values_after_lt();\n+                    (true, lifetimes, opt_vec::from(types))\n+                } else {\n+                    (false, opt_vec::Empty, opt_vec::Empty)\n                 }\n-\n-                (true, optional_lifetime, types)\n-            } else {\n-                (false, None, opt_vec::Empty)\n             };\n \n             // Assemble and push the result.\n             segments.push(PathSegmentAndBoundSet {\n                 segment: ast::PathSegment {\n                     identifier: identifier,\n-                    lifetime: optional_lifetime,\n+                    lifetimes: lifetimes,\n                     types: types,\n                 },\n                 bound_set: bound_set\n@@ -1609,11 +1584,11 @@ impl Parser {\n     pub fn parse_lifetime(&self) -> ast::Lifetime {\n         match *self.token {\n             token::LIFETIME(i) => {\n-                let span = self.span;\n+                let span = *self.span;\n                 self.bump();\n                 return ast::Lifetime {\n                     id: ast::DUMMY_NODE_ID,\n-                    span: *span,\n+                    span: span,\n                     ident: i\n                 };\n             }\n@@ -4856,7 +4831,7 @@ impl Parser {\n                 segments: path.move_iter().map(|identifier| {\n                     ast::PathSegment {\n                         identifier: identifier,\n-                        lifetime: None,\n+                        lifetimes: opt_vec::Empty,\n                         types: opt_vec::Empty,\n                     }\n                 }).collect()\n@@ -4892,7 +4867,7 @@ impl Parser {\n                         segments: path.move_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetime: None,\n+                                lifetimes: opt_vec::Empty,\n                                 types: opt_vec::Empty,\n                             }\n                         }).collect()\n@@ -4910,7 +4885,7 @@ impl Parser {\n                         segments: path.move_iter().map(|identifier| {\n                             ast::PathSegment {\n                                 identifier: identifier,\n-                                lifetime: None,\n+                                lifetimes: opt_vec::Empty,\n                                 types: opt_vec::Empty,\n                             }\n                         }).collect()\n@@ -4932,7 +4907,7 @@ impl Parser {\n             segments: path.move_iter().map(|identifier| {\n                 ast::PathSegment {\n                     identifier: identifier,\n-                    lifetime: None,\n+                    lifetimes: opt_vec::Empty,\n                     types: opt_vec::Empty,\n                 }\n             }).collect()"}, {"sha": "fd02ac68f4e1a039665baae7ff3e38dc0d6dfb46", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f4faaee401f8681e25afbcf3b6296b6cd2ca55a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=1f4faaee401f8681e25afbcf3b6296b6cd2ca55a", "patch": "@@ -1566,13 +1566,13 @@ fn print_path_(s: @ps,\n             }\n         }\n \n-        if segment.lifetime.is_some() || !segment.types.is_empty() {\n+        if !segment.lifetimes.is_empty() || !segment.types.is_empty() {\n             if colons_before_params {\n                 word(s.s, \"::\")\n             }\n             word(s.s, \"<\");\n \n-            for lifetime in segment.lifetime.iter() {\n+            for lifetime in segment.lifetimes.iter() {\n                 print_lifetime(s, lifetime);\n                 if !segment.types.is_empty() {\n                     word_space(s, \",\")\n@@ -1905,7 +1905,8 @@ pub fn print_meta_item(s: @ps, item: &ast::MetaItem) {\n pub fn print_view_path(s: @ps, vp: &ast::view_path) {\n     match vp.node {\n       ast::view_path_simple(ident, ref path, _) => {\n-        if path.segments.last().identifier != ident {\n+            // FIXME can't compare identifiers directly here\n+        if path.segments.last().identifier.name != ident.name {\n             print_ident(s, ident);\n             space(s.s);\n             word_space(s, \"=\");"}]}