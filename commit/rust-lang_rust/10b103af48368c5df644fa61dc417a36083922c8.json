{"sha": "10b103af48368c5df644fa61dc417a36083922c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYjEwM2FmNDgzNjhjNWRmNjQ0ZmE2MWRjNDE3YTM2MDgzOTIyYzg=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-26T16:30:35Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-06-28T02:45:24Z"}, "message": "std: Fix Windows XP compatibility\n\nThis commit enables executables linked against the standard library to run on\nWindows XP. There are two main components of this commit:\n\n* APIs not available on XP are shimmed to have a fallback implementation and use\n  runtime detection to determine if they are available.\n* Mutexes on Windows were reimplemented to use critical sections on XP where\n  rwlocks are not available.\n\nThe APIs which are not available on XP are:\n\n* SetFileInformationByHandle - this is just used by `File::truncate` and that\n  function just returns an error now.\n* SetThreadStackGuarantee - this is used by the stack overflow support on\n  windows, but if this isn't available then it's just ignored (it seems\n  non-critical).\n* All condition variable APIs are missing - the shims added for these apis\n  simply always panic for now. We may eventually provide a fallback\n  implementation, but for now the standard library does not rely on condition\n  variables for normal use.\n* RWLocks, like condition variables, are missing entirely. The same story for\n  condition variables is taken here. These APIs are all now panicking stubs as\n  the standard library doesn't rely on RWLocks for normal use.\n\nCurrently, as an optimization, we use SRWLOCKs for the standard `sync::Mutex`\nimplementation on Windows, which is indeed required for normal operation of the\nstandard library. To allow the standard library to run on XP, this commit\nreimplements mutexes on Windows to use SRWLOCK instances *if available* and\notherwise a CriticalSection is used (with some checking for recursive\nlocking).\n\nWith all these changes put together, a 32-bit MSVC-built executable can run on\nWindows XP and print \"hello world\"\n\nCloses #12842\nCloses #19992\nCloses #24776", "tree": {"sha": "538dbf67a23dbd8297576319f4bb0011bb633a65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/538dbf67a23dbd8297576319f4bb0011bb633a65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10b103af48368c5df644fa61dc417a36083922c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10b103af48368c5df644fa61dc417a36083922c8", "html_url": "https://github.com/rust-lang/rust/commit/10b103af48368c5df644fa61dc417a36083922c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10b103af48368c5df644fa61dc417a36083922c8/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87909582374be91bc5affdd2e74e265077a6e571", "url": "https://api.github.com/repos/rust-lang/rust/commits/87909582374be91bc5affdd2e74e265077a6e571", "html_url": "https://github.com/rust-lang/rust/commit/87909582374be91bc5affdd2e74e265077a6e571"}], "stats": {"total": 596, "additions": 353, "deletions": 243}, "files": [{"sha": "a17d121e60a2a834c4928480d6d2d9191ec6d962", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=10b103af48368c5df644fa61dc417a36083922c8", "patch": "@@ -263,7 +263,7 @@ mod dl {\n     use sys::os;\n     use os::windows::prelude::*;\n     use ptr;\n-    use sys::c::compat::kernel32::SetThreadErrorMode;\n+    use sys::c::SetThreadErrorMode;\n \n     pub fn open(filename: Option<&OsStr>) -> Result<*mut u8, String> {\n         // disable \"dll load failed\" error dialog."}, {"sha": "7f89ea979391e251d3517090dd73ab8ff4e7c2f8", "filename": "src/libstd/sys/windows/c.rs", "status": "modified", "additions": 96, "deletions": 115, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fc.rs?ref=10b103af48368c5df644fa61dc417a36083922c8", "patch": "@@ -13,6 +13,9 @@\n #![allow(bad_style, dead_code, overflowing_literals)]\n \n use libc;\n+use libc::{c_uint, c_ulong};\n+use libc::{DWORD, BOOL, BOOLEAN, ERROR_CALL_NOT_IMPLEMENTED, LPVOID, HANDLE};\n+use libc::{LPCWSTR, LONG};\n \n pub use self::GET_FILEEX_INFO_LEVELS::*;\n pub use self::FILE_INFO_BY_HANDLE_CLASS::*;\n@@ -240,7 +243,32 @@ pub struct SYMBOLIC_LINK_REPARSE_BUFFER {\n     pub PathBuffer: libc::WCHAR,\n }\n \n+pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n+pub type PSRWLOCK = *mut SRWLOCK;\n+pub type ULONG = c_ulong;\n+pub type ULONG_PTR = c_ulong;\n+\n+#[repr(C)]\n+pub struct CONDITION_VARIABLE { pub ptr: LPVOID }\n+#[repr(C)]\n+pub struct SRWLOCK { pub ptr: LPVOID }\n+#[repr(C)]\n+pub struct CRITICAL_SECTION {\n+    CriticalSectionDebug: LPVOID,\n+    LockCount: LONG,\n+    RecursionCount: LONG,\n+    OwningThread: HANDLE,\n+    LockSemaphore: HANDLE,\n+    SpinCount: ULONG_PTR\n+}\n+\n+pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n+    ptr: 0 as *mut _,\n+};\n+pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: 0 as *mut _ };\n+\n #[link(name = \"ws2_32\")]\n+#[link(name = \"userenv\")]\n extern \"system\" {\n     pub fn WSAStartup(wVersionRequested: libc::WORD,\n                       lpWSAData: LPWSADATA) -> libc::c_int;\n@@ -295,115 +323,13 @@ extern \"system\" {\n     pub fn CancelIo(hFile: libc::HANDLE) -> libc::BOOL;\n     pub fn CancelIoEx(hFile: libc::HANDLE,\n                       lpOverlapped: libc::LPOVERLAPPED) -> libc::BOOL;\n-}\n-\n-pub mod compat {\n-    use prelude::v1::*;\n \n-    use ffi::CString;\n-    use libc::types::os::arch::extra::{LPCWSTR, HMODULE, LPCSTR, LPVOID};\n-    use sync::atomic::{AtomicUsize, Ordering};\n+    pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n+    pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n+    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;\n+    pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n+    pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n \n-    extern \"system\" {\n-        fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n-        fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n-    }\n-\n-    fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n-                  fallback: usize) -> usize {\n-        let mut module: Vec<u16> = module.utf16_units().collect();\n-        module.push(0);\n-        let symbol = CString::new(symbol).unwrap();\n-        let func = unsafe {\n-            let handle = GetModuleHandleW(module.as_ptr());\n-            GetProcAddress(handle, symbol.as_ptr()) as usize\n-        };\n-        let value = if func == 0 {fallback} else {func};\n-        ptr.store(value, Ordering::SeqCst);\n-        value\n-    }\n-\n-    /// Macro for creating a compatibility fallback for a Windows function\n-    ///\n-    /// # Examples\n-    /// ```\n-    /// compat_fn!(adll32::SomeFunctionW(_arg: LPCWSTR) {\n-    ///     // Fallback implementation\n-    /// })\n-    /// ```\n-    ///\n-    /// Note that arguments unused by the fallback implementation should not be\n-    /// called `_` as they are used to be passed to the real function if\n-    /// available.\n-    macro_rules! compat_fn {\n-        ($module:ident::$symbol:ident($($argname:ident: $argtype:ty),*)\n-                                      -> $rettype:ty { $fallback:expr }) => (\n-            #[inline(always)]\n-            pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n-                use sync::atomic::{AtomicUsize, Ordering};\n-                use mem;\n-\n-                static PTR: AtomicUsize = AtomicUsize::new(0);\n-\n-                fn load() -> usize {\n-                    ::sys::c::compat::store_func(&PTR,\n-                                                 stringify!($module),\n-                                                 stringify!($symbol),\n-                                                 fallback as usize)\n-                }\n-\n-                extern \"system\" fn fallback($($argname: $argtype),*)\n-                                            -> $rettype { $fallback }\n-\n-                let addr = match PTR.load(Ordering::SeqCst) {\n-                    0 => load(),\n-                    n => n,\n-                };\n-                let f: extern \"system\" fn($($argtype),*) -> $rettype =\n-                    mem::transmute(addr);\n-                f($($argname),*)\n-            }\n-        )\n-    }\n-\n-    /// Compatibility layer for functions in `kernel32.dll`\n-    ///\n-    /// Latest versions of Windows this is needed for:\n-    ///\n-    /// * `CreateSymbolicLinkW`: Windows XP, Windows Server 2003\n-    /// * `GetFinalPathNameByHandleW`: Windows XP, Windows Server 2003\n-    pub mod kernel32 {\n-        use libc::c_uint;\n-        use libc::types::os::arch::extra::{DWORD, LPCWSTR, BOOLEAN, HANDLE};\n-        use libc::consts::os::extra::ERROR_CALL_NOT_IMPLEMENTED;\n-        use sys::c::SetLastError;\n-\n-        compat_fn! {\n-            kernel32::CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n-                                          _lpTargetFileName: LPCWSTR,\n-                                          _dwFlags: DWORD) -> BOOLEAN {\n-                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0 }\n-            }\n-        }\n-\n-        compat_fn! {\n-            kernel32::GetFinalPathNameByHandleW(_hFile: HANDLE,\n-                                                _lpszFilePath: LPCWSTR,\n-                                                _cchFilePath: DWORD,\n-                                                _dwFlags: DWORD) -> DWORD {\n-                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0 }\n-            }\n-        }\n-\n-        compat_fn! {\n-            kernel32::SetThreadErrorMode(_dwNewMode: DWORD, _lpOldMode: *mut DWORD) -> c_uint {\n-                unsafe { SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0 }\n-            }\n-        }\n-    }\n-}\n-\n-extern \"system\" {\n     // FIXME - pInputControl should be PCONSOLE_READCONSOLE_CONTROL\n     pub fn ReadConsoleW(hConsoleInput: libc::HANDLE,\n                         lpBuffer: libc::LPVOID,\n@@ -447,10 +373,6 @@ extern \"system\" {\n                        lpCreationTime: *const libc::FILETIME,\n                        lpLastAccessTime: *const libc::FILETIME,\n                        lpLastWriteTime: *const libc::FILETIME) -> libc::BOOL;\n-    pub fn SetFileInformationByHandle(hFile: libc::HANDLE,\n-                    FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n-                    lpFileInformation: libc::LPVOID,\n-                    dwBufferSize: libc::DWORD) -> libc::BOOL;\n     pub fn GetTempPathW(nBufferLength: libc::DWORD,\n                         lpBuffer: libc::LPCWSTR) -> libc::DWORD;\n     pub fn OpenProcessToken(ProcessHandle: libc::HANDLE,\n@@ -483,11 +405,70 @@ extern \"system\" {\n     pub fn SwitchToThread() -> libc::BOOL;\n     pub fn Sleep(dwMilliseconds: libc::DWORD);\n     pub fn GetProcessId(handle: libc::HANDLE) -> libc::DWORD;\n-}\n-\n-#[link(name = \"userenv\")]\n-extern \"system\" {\n     pub fn GetUserProfileDirectoryW(hToken: libc::HANDLE,\n                                     lpProfileDir: libc::LPCWSTR,\n                                     lpcchSize: *mut libc::DWORD) -> libc::BOOL;\n }\n+\n+// Functions that aren't available on Windows XP, but we still use them and just\n+// provide some form of a fallback implementation.\n+compat_fn! {\n+    kernel32:\n+\n+    pub fn CreateSymbolicLinkW(_lpSymlinkFileName: LPCWSTR,\n+                               _lpTargetFileName: LPCWSTR,\n+                               _dwFlags: DWORD) -> BOOLEAN {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+    }\n+    pub fn GetFinalPathNameByHandleW(_hFile: HANDLE,\n+                                     _lpszFilePath: LPCWSTR,\n+                                     _cchFilePath: DWORD,\n+                                     _dwFlags: DWORD) -> DWORD {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+    }\n+    pub fn SetThreadErrorMode(_dwNewMode: DWORD,\n+                              _lpOldMode: *mut DWORD) -> c_uint {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+    }\n+    pub fn SetThreadStackGuarantee(_size: *mut c_ulong) -> BOOL {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+    }\n+    pub fn SetFileInformationByHandle(_hFile: HANDLE,\n+                    _FileInformationClass: FILE_INFO_BY_HANDLE_CLASS,\n+                    _lpFileInformation: LPVOID,\n+                    _dwBufferSize: DWORD) -> BOOL {\n+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED as DWORD); 0\n+    }\n+    pub fn SleepConditionVariableSRW(ConditionVariable: PCONDITION_VARIABLE,\n+                                     SRWLock: PSRWLOCK,\n+                                     dwMilliseconds: DWORD,\n+                                     Flags: ULONG) -> BOOL {\n+        panic!(\"condition variables not available\")\n+    }\n+    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE)\n+                                 -> () {\n+        panic!(\"condition variables not available\")\n+    }\n+    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE)\n+                                    -> () {\n+        panic!(\"condition variables not available\")\n+    }\n+    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> () {\n+        panic!(\"rwlocks not available\")\n+    }\n+    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK) -> () {\n+        panic!(\"rwlocks not available\")\n+    }\n+    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK) -> () {\n+        panic!(\"rwlocks not available\")\n+    }\n+    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK) -> () {\n+        panic!(\"rwlocks not available\")\n+    }\n+    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN {\n+        panic!(\"rwlocks not available\")\n+    }\n+    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN {\n+        panic!(\"rwlocks not available\")\n+    }\n+}"}, {"sha": "3a03b91f24ed3ba75a05db658ae9307f315d2c8c", "filename": "src/libstd/sys/windows/compat.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcompat.rs?ref=10b103af48368c5df644fa61dc417a36083922c8", "patch": "@@ -0,0 +1,88 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A \"compatibility layer\" for spanning XP and Windows 7\n+//!\n+//! The standard library currently binds many functions that are not available\n+//! on Windows XP, but we would also like to support building executables that\n+//! run on XP. To do this we specify all non-XP APIs as having a fallback\n+//! implementation to do something reasonable.\n+//!\n+//! This dynamic runtime detection of whether a function is available is\n+//! implemented with `GetModuleHandle` and `GetProcAddress` paired with a\n+//! static-per-function which caches the result of the first check. In this\n+//! manner we pay a semi-large one-time cost up front for detecting whether a\n+//! function is available but afterwards it's just a load and a jump.\n+\n+use prelude::v1::*;\n+\n+use ffi::CString;\n+use libc::{LPVOID, LPCWSTR, HMODULE, LPCSTR};\n+use sync::atomic::{AtomicUsize, Ordering};\n+\n+extern \"system\" {\n+    fn GetModuleHandleW(lpModuleName: LPCWSTR) -> HMODULE;\n+    fn GetProcAddress(hModule: HMODULE, lpProcName: LPCSTR) -> LPVOID;\n+}\n+\n+pub fn lookup(module: &str, symbol: &str) -> Option<usize> {\n+    let mut module: Vec<u16> = module.utf16_units().collect();\n+    module.push(0);\n+    let symbol = CString::new(symbol).unwrap();\n+    unsafe {\n+        let handle = GetModuleHandleW(module.as_ptr());\n+        match GetProcAddress(handle, symbol.as_ptr()) as usize {\n+            0 => None,\n+            n => Some(n),\n+        }\n+    }\n+}\n+\n+pub fn store_func(ptr: &AtomicUsize, module: &str, symbol: &str,\n+                  fallback: usize) -> usize {\n+    let value = lookup(module, symbol).unwrap_or(fallback);\n+    ptr.store(value, Ordering::SeqCst);\n+    value\n+}\n+\n+macro_rules! compat_fn {\n+    ($module:ident: $(\n+        pub fn $symbol:ident($($argname:ident: $argtype:ty),*)\n+                                  -> $rettype:ty {\n+            $($body:expr);*\n+        }\n+    )*) => ($(\n+        #[allow(unused_variables)]\n+        pub unsafe fn $symbol($($argname: $argtype),*) -> $rettype {\n+            use sync::atomic::{AtomicUsize, Ordering};\n+            use mem;\n+            type F = unsafe extern \"system\" fn($($argtype),*) -> $rettype;\n+\n+            static PTR: AtomicUsize = AtomicUsize::new(0);\n+\n+            fn load() -> usize {\n+                ::sys::compat::store_func(&PTR,\n+                                          stringify!($module),\n+                                          stringify!($symbol),\n+                                          fallback as usize)\n+            }\n+            unsafe extern \"system\" fn fallback($($argname: $argtype),*)\n+                                               -> $rettype {\n+                $($body);*\n+            }\n+\n+            let addr = match PTR.load(Ordering::SeqCst) {\n+                0 => load(),\n+                n => n,\n+            };\n+            mem::transmute::<usize, F>(addr)($($argname),*)\n+        }\n+    )*)\n+}"}, {"sha": "04d62200e9bcc553777977cbe47171609972da6a", "filename": "src/libstd/sys/windows/condvar.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=10b103af48368c5df644fa61dc417a36083922c8", "patch": "@@ -12,35 +12,35 @@ use prelude::v1::*;\n \n use cell::UnsafeCell;\n use libc::{self, DWORD};\n-use sys::os;\n+use sys::c;\n use sys::mutex::{self, Mutex};\n-use sys::sync as ffi;\n+use sys::os;\n use time::Duration;\n \n-pub struct Condvar { inner: UnsafeCell<ffi::CONDITION_VARIABLE> }\n+pub struct Condvar { inner: UnsafeCell<c::CONDITION_VARIABLE> }\n \n unsafe impl Send for Condvar {}\n unsafe impl Sync for Condvar {}\n \n impl Condvar {\n     pub const fn new() -> Condvar {\n-        Condvar { inner: UnsafeCell::new(ffi::CONDITION_VARIABLE_INIT) }\n+        Condvar { inner: UnsafeCell::new(c::CONDITION_VARIABLE_INIT) }\n     }\n \n     #[inline]\n     pub unsafe fn wait(&self, mutex: &Mutex) {\n-        let r = ffi::SleepConditionVariableSRW(self.inner.get(),\n-                                               mutex::raw(mutex),\n-                                               libc::INFINITE,\n-                                               0);\n+        let r = c::SleepConditionVariableSRW(self.inner.get(),\n+                                             mutex::raw(mutex),\n+                                             libc::INFINITE,\n+                                             0);\n         debug_assert!(r != 0);\n     }\n \n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        let r = ffi::SleepConditionVariableSRW(self.inner.get(),\n-                                               mutex::raw(mutex),\n-                                               super::dur2timeout(dur),\n-                                               0);\n+        let r = c::SleepConditionVariableSRW(self.inner.get(),\n+                                             mutex::raw(mutex),\n+                                             super::dur2timeout(dur),\n+                                             0);\n         if r == 0 {\n             const ERROR_TIMEOUT: DWORD = 0x5B4;\n             debug_assert_eq!(os::errno() as usize, ERROR_TIMEOUT as usize);\n@@ -52,12 +52,12 @@ impl Condvar {\n \n     #[inline]\n     pub unsafe fn notify_one(&self) {\n-        ffi::WakeConditionVariable(self.inner.get())\n+        c::WakeConditionVariable(self.inner.get())\n     }\n \n     #[inline]\n     pub unsafe fn notify_all(&self) {\n-        ffi::WakeAllConditionVariable(self.inner.get())\n+        c::WakeAllConditionVariable(self.inner.get())\n     }\n \n     pub unsafe fn destroy(&self) {"}, {"sha": "36fabe72aa0c1f70fb5665bf653aabee9780f246", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=10b103af48368c5df644fa61dc417a36083922c8", "patch": "@@ -497,12 +497,11 @@ pub fn symlink(src: &Path, dst: &Path) -> io::Result<()> {\n }\n \n pub fn symlink_inner(src: &Path, dst: &Path, dir: bool) -> io::Result<()> {\n-    use sys::c::compat::kernel32::CreateSymbolicLinkW;\n     let src = to_utf16(src);\n     let dst = to_utf16(dst);\n     let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };\n     try!(cvt(unsafe {\n-        CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as libc::BOOL\n+        c::CreateSymbolicLinkW(dst.as_ptr(), src.as_ptr(), flags) as libc::BOOL\n     }));\n     Ok(())\n }\n@@ -565,14 +564,13 @@ pub fn utimes(p: &Path, atime: u64, mtime: u64) -> io::Result<()> {\n }\n \n pub fn canonicalize(p: &Path) -> io::Result<PathBuf> {\n-    use sys::c::compat::kernel32::GetFinalPathNameByHandleW;\n \n     let mut opts = OpenOptions::new();\n     opts.read(true);\n     let f = try!(File::open(p, &opts));\n     super::fill_utf16_buf(|buf, sz| unsafe {\n-        GetFinalPathNameByHandleW(f.handle.raw(), buf, sz,\n-                                  libc::VOLUME_NAME_DOS)\n+        c::GetFinalPathNameByHandleW(f.handle.raw(), buf, sz,\n+                                     libc::VOLUME_NAME_DOS)\n     }, |buf| {\n         PathBuf::from(OsString::from_wide(buf))\n     })"}, {"sha": "b6d080109df053d4290f0c5f19a1fac3678fe625", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=10b103af48368c5df644fa61dc417a36083922c8", "patch": "@@ -22,6 +22,8 @@ use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n use time::Duration;\n \n+#[macro_use] pub mod compat;\n+\n pub mod backtrace;\n pub mod c;\n pub mod condvar;\n@@ -36,7 +38,6 @@ pub mod pipe;\n pub mod process;\n pub mod rwlock;\n pub mod stack_overflow;\n-pub mod sync;\n pub mod thread;\n pub mod thread_local;\n pub mod time;"}, {"sha": "277c3d14c0ec5515e4a2396986ede72ac9cdae93", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 128, "deletions": 31, "changes": 159, "blob_url": "https://github.com/rust-lang/rust/blob/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=10b103af48368c5df644fa61dc417a36083922c8", "patch": "@@ -8,57 +8,154 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! System Mutexes\n+//!\n+//! The Windows implementation of mutexes is a little odd and it may not be\n+//! immediately obvious what's going on. The primary oddness is that SRWLock is\n+//! used instead of CriticalSection, and this is done because:\n+//!\n+//! 1. SRWLock is several times faster than CriticalSection according to\n+//!    benchmarks performed on both Windows 8 and Windows 7.\n+//!\n+//! 2. CriticalSection allows recursive locking while SRWLock deadlocks. The\n+//!    Unix implementation deadlocks so consistency is preferred. See #19962 for\n+//!    more details.\n+//!\n+//! 3. While CriticalSection is fair and SRWLock is not, the current Rust policy\n+//!    is there there are no guarantees of fairness.\n+//!\n+//! The downside of this approach, however, is that SRWLock is not available on\n+//! Windows XP, so we continue to have a fallback implementation where\n+//! CriticalSection is used and we keep track of who's holding the mutex to\n+//! detect recursive locks.\n+\n use prelude::v1::*;\n \n use cell::UnsafeCell;\n-use sys::sync as ffi;\n use mem;\n+use sync::atomic::{AtomicUsize, Ordering};\n+use sys::c;\n+use sys::compat;\n \n-pub struct Mutex { inner: UnsafeCell<ffi::SRWLOCK> }\n+pub struct Mutex {\n+    lock: AtomicUsize,\n+    held: UnsafeCell<bool>,\n+}\n \n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n-#[inline]\n-pub unsafe fn raw(m: &Mutex) -> ffi::PSRWLOCK {\n-    m.inner.get()\n+#[derive(Clone, Copy)]\n+enum Kind {\n+    SRWLock = 1,\n+    CriticalSection = 2,\n }\n \n-// So you might be asking why we're using SRWLock instead of CriticalSection?\n-//\n-// 1. SRWLock is several times faster than CriticalSection according to\n-//    benchmarks performed on both Windows 8 and Windows 7.\n-//\n-// 2. CriticalSection allows recursive locking while SRWLock deadlocks. The Unix\n-//    implementation deadlocks so consistency is preferred. See #19962 for more\n-//    details.\n-//\n-// 3. While CriticalSection is fair and SRWLock is not, the current Rust policy\n-//    is there there are no guarantees of fairness.\n+#[inline]\n+pub unsafe fn raw(m: &Mutex) -> c::PSRWLOCK {\n+    debug_assert!(mem::size_of::<c::SRWLOCK>() <= mem::size_of_val(&m.lock));\n+    &m.lock as *const _ as *mut _\n+}\n \n impl Mutex {\n     pub const fn new() -> Mutex {\n-        Mutex { inner: UnsafeCell::new(ffi::SRWLOCK_INIT) }\n+        Mutex {\n+            lock: AtomicUsize::new(0),\n+            held: UnsafeCell::new(false),\n+        }\n     }\n-    #[inline]\n     pub unsafe fn lock(&self) {\n-        ffi::AcquireSRWLockExclusive(self.inner.get())\n+        match kind() {\n+            Kind::SRWLock => c::AcquireSRWLockExclusive(raw(self)),\n+            Kind::CriticalSection => {\n+                let re = self.remutex();\n+                (*re).lock();\n+                if !self.flag_locked() {\n+                    (*re).unlock();\n+                    panic!(\"cannot recursively lock a mutex\");\n+                }\n+            }\n+        }\n     }\n-    #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        ffi::TryAcquireSRWLockExclusive(self.inner.get()) != 0\n+        match kind() {\n+            Kind::SRWLock => c::TryAcquireSRWLockExclusive(raw(self)) != 0,\n+            Kind::CriticalSection => {\n+                let re = self.remutex();\n+                if !(*re).try_lock() {\n+                    false\n+                } else if self.flag_locked() {\n+                    true\n+                } else {\n+                    (*re).unlock();\n+                    false\n+                }\n+            }\n+        }\n     }\n-    #[inline]\n     pub unsafe fn unlock(&self) {\n-        ffi::ReleaseSRWLockExclusive(self.inner.get())\n+        *self.held.get() = false;\n+        match kind() {\n+            Kind::SRWLock => c::ReleaseSRWLockExclusive(raw(self)),\n+            Kind::CriticalSection => (*self.remutex()).unlock(),\n+        }\n     }\n-    #[inline]\n     pub unsafe fn destroy(&self) {\n-        // ...\n+        match kind() {\n+            Kind::SRWLock => {}\n+            Kind::CriticalSection => {\n+                match self.lock.load(Ordering::SeqCst) {\n+                    0 => {}\n+                    n => { Box::from_raw(n as *mut ReentrantMutex).destroy(); }\n+                }\n+            }\n+        }\n+    }\n+\n+    unsafe fn remutex(&self) -> *mut ReentrantMutex {\n+        match self.lock.load(Ordering::SeqCst) {\n+            0 => {}\n+            n => return n as *mut _,\n+        }\n+        let mut re = Box::new(ReentrantMutex::uninitialized());\n+        re.init();\n+        let re = Box::into_raw(re);\n+        match self.lock.compare_and_swap(0, re as usize, Ordering::SeqCst) {\n+            0 => re,\n+            n => { Box::from_raw(re).destroy(); n as *mut _ }\n+        }\n+    }\n+\n+    unsafe fn flag_locked(&self) -> bool {\n+        if *self.held.get() {\n+            false\n+        } else {\n+            *self.held.get() = true;\n+            true\n+        }\n+\n     }\n }\n \n-pub struct ReentrantMutex { inner: UnsafeCell<ffi::CRITICAL_SECTION> }\n+fn kind() -> Kind {\n+    static KIND: AtomicUsize = AtomicUsize::new(0);\n+\n+    let val = KIND.load(Ordering::SeqCst);\n+    if val == Kind::SRWLock as usize {\n+        return Kind::SRWLock\n+    } else if val == Kind::CriticalSection as usize {\n+        return Kind::CriticalSection\n+    }\n+\n+    let ret = match compat::lookup(\"kernel32\", \"AcquireSRWLockExclusive\") {\n+        None => Kind::CriticalSection,\n+        Some(..) => Kind::SRWLock,\n+    };\n+    KIND.store(ret as usize, Ordering::SeqCst);\n+    return ret;\n+}\n+\n+pub struct ReentrantMutex { inner: UnsafeCell<c::CRITICAL_SECTION> }\n \n unsafe impl Send for ReentrantMutex {}\n unsafe impl Sync for ReentrantMutex {}\n@@ -69,23 +166,23 @@ impl ReentrantMutex {\n     }\n \n     pub unsafe fn init(&mut self) {\n-        ffi::InitializeCriticalSection(self.inner.get());\n+        c::InitializeCriticalSection(self.inner.get());\n     }\n \n     pub unsafe fn lock(&self) {\n-        ffi::EnterCriticalSection(self.inner.get());\n+        c::EnterCriticalSection(self.inner.get());\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        ffi::TryEnterCriticalSection(self.inner.get()) != 0\n+        c::TryEnterCriticalSection(self.inner.get()) != 0\n     }\n \n     pub unsafe fn unlock(&self) {\n-        ffi::LeaveCriticalSection(self.inner.get());\n+        c::LeaveCriticalSection(self.inner.get());\n     }\n \n     pub unsafe fn destroy(&self) {\n-        ffi::DeleteCriticalSection(self.inner.get());\n+        c::DeleteCriticalSection(self.inner.get());\n     }\n }"}, {"sha": "25865286db051aba32e4f60c33b191efc35cb00b", "filename": "src/libstd/sys/windows/rwlock.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs?ref=10b103af48368c5df644fa61dc417a36083922c8", "patch": "@@ -11,40 +11,40 @@\n use prelude::v1::*;\n \n use cell::UnsafeCell;\n-use sys::sync as ffi;\n+use sys::c;\n \n-pub struct RWLock { inner: UnsafeCell<ffi::SRWLOCK> }\n+pub struct RWLock { inner: UnsafeCell<c::SRWLOCK> }\n \n unsafe impl Send for RWLock {}\n unsafe impl Sync for RWLock {}\n \n impl RWLock {\n     pub const fn new() -> RWLock {\n-        RWLock { inner: UnsafeCell::new(ffi::SRWLOCK_INIT) }\n+        RWLock { inner: UnsafeCell::new(c::SRWLOCK_INIT) }\n     }\n     #[inline]\n     pub unsafe fn read(&self) {\n-        ffi::AcquireSRWLockShared(self.inner.get())\n+        c::AcquireSRWLockShared(self.inner.get())\n     }\n     #[inline]\n     pub unsafe fn try_read(&self) -> bool {\n-        ffi::TryAcquireSRWLockShared(self.inner.get()) != 0\n+        c::TryAcquireSRWLockShared(self.inner.get()) != 0\n     }\n     #[inline]\n     pub unsafe fn write(&self) {\n-        ffi::AcquireSRWLockExclusive(self.inner.get())\n+        c::AcquireSRWLockExclusive(self.inner.get())\n     }\n     #[inline]\n     pub unsafe fn try_write(&self) -> bool {\n-        ffi::TryAcquireSRWLockExclusive(self.inner.get()) != 0\n+        c::TryAcquireSRWLockExclusive(self.inner.get()) != 0\n     }\n     #[inline]\n     pub unsafe fn read_unlock(&self) {\n-        ffi::ReleaseSRWLockShared(self.inner.get())\n+        c::ReleaseSRWLockShared(self.inner.get())\n     }\n     #[inline]\n     pub unsafe fn write_unlock(&self) {\n-        ffi::ReleaseSRWLockExclusive(self.inner.get())\n+        c::ReleaseSRWLockExclusive(self.inner.get())\n     }\n \n     #[inline]"}, {"sha": "cf827848db5c99f0f70de6295220a007ecb4fb76", "filename": "src/libstd/sys/windows/stack_overflow.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/10b103af48368c5df644fa61dc417a36083922c8/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fstack_overflow.rs?ref=10b103af48368c5df644fa61dc417a36083922c8", "patch": "@@ -8,12 +8,14 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use rt::util::report_overflow;\n use core::prelude::*;\n-use ptr;\n-use mem;\n+\n+use libc::types::os::arch::extra::{LPVOID, DWORD, LONG};\n use libc;\n-use libc::types::os::arch::extra::{LPVOID, DWORD, LONG, BOOL};\n+use mem;\n+use ptr;\n+use rt::util::report_overflow;\n+use sys::c;\n use sys_common::stack;\n \n pub struct Handler {\n@@ -69,8 +71,12 @@ pub unsafe fn cleanup() {\n }\n \n pub unsafe fn make_handler() -> Handler {\n-    if SetThreadStackGuarantee(&mut 0x5000) == 0 {\n-        panic!(\"failed to reserve stack space for exception handling\");\n+    // This API isn't available on XP, so don't panic in that case and just pray\n+    // it works out ok.\n+    if c::SetThreadStackGuarantee(&mut 0x5000) == 0 {\n+        if libc::GetLastError() as u32 != libc::ERROR_CALL_NOT_IMPLEMENTED as u32 {\n+            panic!(\"failed to reserve stack space for exception handling\");\n+        }\n     }\n \n     Handler { _data: 0 as *mut libc::c_void }\n@@ -103,5 +109,4 @@ extern \"system\" {\n     fn AddVectoredExceptionHandler(FirstHandler: ULONG,\n                                    VectoredHandler: PVECTORED_EXCEPTION_HANDLER)\n                                   -> LPVOID;\n-    fn SetThreadStackGuarantee(StackSizeInBytes: *mut ULONG) -> BOOL;\n }"}, {"sha": "5410259540eaccbf5338c460a0c0c0add8a2a7c1", "filename": "src/libstd/sys/windows/sync.rs", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/87909582374be91bc5affdd2e74e265077a6e571/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87909582374be91bc5affdd2e74e265077a6e571/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fsync.rs?ref=87909582374be91bc5affdd2e74e265077a6e571", "patch": "@@ -1,60 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use libc::{BOOL, DWORD, LPVOID, LONG, HANDLE, c_ulong};\n-use libc::types::os::arch::extra::BOOLEAN;\n-\n-pub type PCONDITION_VARIABLE = *mut CONDITION_VARIABLE;\n-pub type PSRWLOCK = *mut SRWLOCK;\n-pub type ULONG = c_ulong;\n-pub type ULONG_PTR = c_ulong;\n-\n-#[repr(C)]\n-pub struct CONDITION_VARIABLE { pub ptr: LPVOID }\n-#[repr(C)]\n-pub struct SRWLOCK { pub ptr: LPVOID }\n-#[repr(C)]\n-pub struct CRITICAL_SECTION {\n-    CriticalSectionDebug: LPVOID,\n-    LockCount: LONG,\n-    RecursionCount: LONG,\n-    OwningThread: HANDLE,\n-    LockSemaphore: HANDLE,\n-    SpinCount: ULONG_PTR\n-}\n-\n-pub const CONDITION_VARIABLE_INIT: CONDITION_VARIABLE = CONDITION_VARIABLE {\n-    ptr: 0 as *mut _,\n-};\n-pub const SRWLOCK_INIT: SRWLOCK = SRWLOCK { ptr: 0 as *mut _ };\n-\n-extern \"system\" {\n-    // condition variables\n-    pub fn SleepConditionVariableSRW(ConditionVariable: PCONDITION_VARIABLE,\n-                                     SRWLock: PSRWLOCK,\n-                                     dwMilliseconds: DWORD,\n-                                     Flags: ULONG) -> BOOL;\n-    pub fn WakeConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n-    pub fn WakeAllConditionVariable(ConditionVariable: PCONDITION_VARIABLE);\n-\n-    // slim rwlocks\n-    pub fn AcquireSRWLockExclusive(SRWLock: PSRWLOCK);\n-    pub fn AcquireSRWLockShared(SRWLock: PSRWLOCK);\n-    pub fn ReleaseSRWLockExclusive(SRWLock: PSRWLOCK);\n-    pub fn ReleaseSRWLockShared(SRWLock: PSRWLOCK);\n-    pub fn TryAcquireSRWLockExclusive(SRWLock: PSRWLOCK) -> BOOLEAN;\n-    pub fn TryAcquireSRWLockShared(SRWLock: PSRWLOCK) -> BOOLEAN;\n-\n-    pub fn InitializeCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-    pub fn EnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-    pub fn TryEnterCriticalSection(CriticalSection: *mut CRITICAL_SECTION) -> BOOLEAN;\n-    pub fn LeaveCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-    pub fn DeleteCriticalSection(CriticalSection: *mut CRITICAL_SECTION);\n-}"}]}