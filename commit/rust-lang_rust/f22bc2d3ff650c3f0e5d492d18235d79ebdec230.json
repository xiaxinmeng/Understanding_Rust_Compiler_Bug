{"sha": "f22bc2d3ff650c3f0e5d492d18235d79ebdec230", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMmJjMmQzZmY2NTBjM2YwZTVkNDkyZDE4MjM1ZDc5ZWJkZWMyMzA=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-07-17T23:34:13Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-07-18T18:50:50Z"}, "message": "Suggest trait bound on type parameter when it is unconstrained\n\nGiven\n\n```\nmented on Jan 26, 2015 \u2022\n trait Foo { fn method(&self) {} }\n\nfn call_method<T>(x: &T) {\n    x.method()\n}\n```\n\nsuggest constraining `T` with `Foo`.", "tree": {"sha": "dd41933b53e5bfc11b6f24dce5b59afca56f3ee9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dd41933b53e5bfc11b6f24dce5b59afca56f3ee9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f22bc2d3ff650c3f0e5d492d18235d79ebdec230", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f22bc2d3ff650c3f0e5d492d18235d79ebdec230", "html_url": "https://github.com/rust-lang/rust/commit/f22bc2d3ff650c3f0e5d492d18235d79ebdec230", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2eb0bc5e3c52a34b6d62ab0527520c66e4c575bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb0bc5e3c52a34b6d62ab0527520c66e4c575bd", "html_url": "https://github.com/rust-lang/rust/commit/2eb0bc5e3c52a34b6d62ab0527520c66e4c575bd"}], "stats": {"total": 184, "additions": 148, "deletions": 36}, "files": [{"sha": "cb83630100a2d97aab65e30b4ec3e2d3c1284750", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 98, "deletions": 30, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f22bc2d3ff650c3f0e5d492d18235d79ebdec230", "patch": "@@ -643,13 +643,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn suggest_traits_to_import<'b>(&self,\n-                                    err: &mut DiagnosticBuilder<'_>,\n-                                    span: Span,\n-                                    rcvr_ty: Ty<'tcx>,\n-                                    item_name: ast::Ident,\n-                                    source: SelfSource<'b>,\n-                                    valid_out_of_scope_traits: Vec<DefId>) {\n+    fn suggest_traits_to_import<'b>(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        span: Span,\n+        rcvr_ty: Ty<'tcx>,\n+        item_name: ast::Ident,\n+        source: SelfSource<'b>,\n+        valid_out_of_scope_traits: Vec<DefId>,\n+    ) {\n         if self.suggest_valid_traits(err, valid_out_of_scope_traits) {\n             return;\n         }\n@@ -683,30 +685,96 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             candidates.sort_by(|a, b| a.cmp(b).reverse());\n             candidates.dedup();\n \n-            // FIXME #21673: this help message could be tuned to the case\n-            // of a type parameter: suggest adding a trait bound rather\n-            // than implementing.\n-            err.help(\"items from traits can only be used if the trait is implemented and in scope\");\n-            let mut msg = format!(\"the following {traits_define} an item `{name}`, \\\n-                                   perhaps you need to implement {one_of_them}:\",\n-                                  traits_define = if candidates.len() == 1 {\n-                                      \"trait defines\"\n-                                  } else {\n-                                      \"traits define\"\n-                                  },\n-                                  one_of_them = if candidates.len() == 1 {\n-                                      \"it\"\n-                                  } else {\n-                                      \"one of them\"\n-                                  },\n-                                  name = item_name);\n-\n-            for (i, trait_info) in candidates.iter().enumerate() {\n-                msg.push_str(&format!(\"\\ncandidate #{}: `{}`\",\n-                                      i + 1,\n-                                      self.tcx.def_path_str(trait_info.def_id)));\n+            let param_type = match rcvr_ty.sty {\n+                ty::Param(param) => Some(param),\n+                ty::Ref(_, ty, _) => match ty.sty {\n+                    ty::Param(param) => Some(param),\n+                    _ => None,\n+                }\n+                _ => None,\n+            };\n+            err.help(if param_type.is_some() {\n+                \"items from traits can only be used if the type parameter is bounded by the trait\"\n+            } else {\n+                \"items from traits can only be used if the trait is implemented and in scope\"\n+            });\n+            let mut msg = format!(\n+                \"the following {traits_define} an item `{name}`, perhaps you need to {action} \\\n+                 {one_of_them}:\",\n+                traits_define = if candidates.len() == 1 {\n+                    \"trait defines\"\n+                } else {\n+                    \"traits define\"\n+                },\n+                action = if let Some(param) = param_type {\n+                    format!(\"restrict type parameter `{}` with\", param)\n+                } else {\n+                    \"implement\".to_string()\n+                },\n+                one_of_them = if candidates.len() == 1 {\n+                    \"it\"\n+                } else {\n+                    \"one of them\"\n+                },\n+                name = item_name,\n+            );\n+            // Obtain the span for `param` and use it for a structured suggestion.\n+            let mut suggested = false;\n+            if let (Some(ref param), Some(ref table)) = (param_type, self.in_progress_tables) {\n+                let table = table.borrow();\n+                if let Some(did) = table.local_id_root {\n+                    let generics = self.tcx.generics_of(did);\n+                    let type_param = generics.type_param(param, self.tcx);\n+                    let hir = &self.tcx.hir();\n+                    if let Some(id) = hir.as_local_hir_id(type_param.def_id) {\n+                        // Get the `hir::Param` to verify whether it already has any bounds.\n+                        // We do this to avoid suggesting code that ends up as `T: FooBar`,\n+                        // instead we suggest `T: Foo + Bar` in that case.\n+                        let mut has_bounds = false;\n+                        if let Node::GenericParam(ref param) = hir.get(id) {\n+                            has_bounds = !param.bounds.is_empty();\n+                        }\n+                        let sp = hir.span(id);\n+                        // `sp` only covers `T`, change it so that it covers\n+                        // `T:` when appropriate\n+                        let sp = if has_bounds {\n+                            sp.to(self.tcx\n+                                .sess\n+                                .source_map()\n+                                .next_point(self.tcx.sess.source_map().next_point(sp)))\n+                        } else {\n+                            sp\n+                        };\n+\n+                        // FIXME: contrast `t.def_id` against `param.bounds` to not suggest traits\n+                        // already there. That can happen when the cause is that we're in a const\n+                        // scope or associated function used as a method.\n+                        err.span_suggestions(\n+                            sp,\n+                            &msg[..],\n+                            candidates.iter().map(|t| format!(\n+                                \"{}: {}{}\",\n+                                param,\n+                                self.tcx.def_path_str(t.def_id),\n+                                if has_bounds { \" +\"} else { \"\" },\n+                            )),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                        suggested = true;\n+                    }\n+                };\n+            }\n+\n+            if !suggested {\n+                for (i, trait_info) in candidates.iter().enumerate() {\n+                    msg.push_str(&format!(\n+                        \"\\ncandidate #{}: `{}`\",\n+                        i + 1,\n+                        self.tcx.def_path_str(trait_info.def_id),\n+                    ));\n+                }\n+                err.note(&msg[..]);\n             }\n-            err.note(&msg[..]);\n         }\n     }\n "}, {"sha": "b945b5e665459fd626e4d8fe6a9230a27c756a4e", "filename": "src/test/ui/issues/issue-39559.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/src%2Ftest%2Fui%2Fissues%2Fissue-39559.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/src%2Ftest%2Fui%2Fissues%2Fissue-39559.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559.stderr?ref=f22bc2d3ff650c3f0e5d492d18235d79ebdec230", "patch": "@@ -4,9 +4,11 @@ error[E0599]: no function or associated item named `dim` found for type `D` in t\n LL |     entries: [T; D::dim()],\n    |                     ^^^ function or associated item not found in `D`\n    |\n-   = help: items from traits can only be used if the trait is implemented and in scope\n-   = note: the following trait defines an item `dim`, perhaps you need to implement it:\n-           candidate #1: `Dim`\n+   = help: items from traits can only be used if the type parameter is bounded by the trait\n+help: the following trait defines an item `dim`, perhaps you need to restrict type parameter `D` with it:\n+   |\n+LL | pub struct Vector<T, D: Dim + Dim> {\n+   |                      ^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "36db5bea8629489ffd456e22c947a2ef0a4e6a44", "filename": "src/test/ui/span/issue-7575.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-7575.stderr?ref=f22bc2d3ff650c3f0e5d492d18235d79ebdec230", "patch": "@@ -61,9 +61,11 @@ note: the candidate is defined in the trait `ManyImplTrait`\n LL |     fn is_str() -> bool {\n    |     ^^^^^^^^^^^^^^^^^^^\n    = help: to disambiguate the method call, write `ManyImplTrait::is_str(t)` instead\n-   = help: items from traits can only be used if the trait is implemented and in scope\n-   = note: the following trait defines an item `is_str`, perhaps you need to implement it:\n-           candidate #1: `ManyImplTrait`\n+   = help: items from traits can only be used if the type parameter is bounded by the trait\n+help: the following trait defines an item `is_str`, perhaps you need to restrict type parameter `T` with it:\n+   |\n+LL | fn param_bound<T: ManyImplTrait + ManyImplTrait>(t: T) -> bool {\n+   |                ^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 3 previous errors\n "}, {"sha": "9d66cae056a81187de56596e02eb115cf2c0549c", "filename": "src/test/ui/suggestions/issue-21673.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/src%2Ftest%2Fui%2Fsuggestions%2Fissue-21673.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/src%2Ftest%2Fui%2Fsuggestions%2Fissue-21673.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-21673.rs?ref=f22bc2d3ff650c3f0e5d492d18235d79ebdec230", "patch": "@@ -0,0 +1,13 @@\n+trait Foo {\n+    fn method(&self) {}\n+}\n+\n+fn call_method<T: std::fmt::Debug>(x: &T) {\n+    x.method() //~ ERROR E0599\n+}\n+\n+fn call_method_2<T>(x: T) {\n+    x.method() //~ ERROR E0599\n+}\n+\n+fn main() {}"}, {"sha": "6cf71c8b7c53b7e13af1ae8eb07de5d32991ceac", "filename": "src/test/ui/suggestions/issue-21673.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/src%2Ftest%2Fui%2Fsuggestions%2Fissue-21673.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f22bc2d3ff650c3f0e5d492d18235d79ebdec230/src%2Ftest%2Fui%2Fsuggestions%2Fissue-21673.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fissue-21673.stderr?ref=f22bc2d3ff650c3f0e5d492d18235d79ebdec230", "patch": "@@ -0,0 +1,27 @@\n+error[E0599]: no method named `method` found for type `&T` in the current scope\n+  --> $DIR/issue-21673.rs:6:7\n+   |\n+LL |     x.method()\n+   |       ^^^^^^\n+   |\n+   = help: items from traits can only be used if the type parameter is bounded by the trait\n+help: the following trait defines an item `method`, perhaps you need to restrict type parameter `T` with it:\n+   |\n+LL | fn call_method<T: Foo + std::fmt::Debug>(x: &T) {\n+   |                ^^^^^^^^\n+\n+error[E0599]: no method named `method` found for type `T` in the current scope\n+  --> $DIR/issue-21673.rs:10:7\n+   |\n+LL |     x.method()\n+   |       ^^^^^^\n+   |\n+   = help: items from traits can only be used if the type parameter is bounded by the trait\n+help: the following trait defines an item `method`, perhaps you need to restrict type parameter `T` with it:\n+   |\n+LL | fn call_method_2<T: Foo>(x: T) {\n+   |                  ^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0599`."}]}