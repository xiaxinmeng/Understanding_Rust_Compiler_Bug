{"sha": "7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiNzNkMTRiMGIzNWU3YjRmNzlmMmQ3MWRjMWJiYmFiMzE2OTgyODg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-27T00:25:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-03-27T00:25:26Z"}, "message": "Auto merge of #70451 - Dylan-DPC:rollup-2g9oyht, r=Dylan-DPC\n\nRollup of 5 pull requests\n\nSuccessful merges:\n\n - #69644 (Remove framework in `dataflow/mod.rs` in favor of \"generic\" one)\n - #69936 (Fix cycle error when emitting suggestion for mismatched `fn` type)\n - #70048 (Allow obtaining &mut OsStr)\n - #70344 (Decouple `rustc_hir::print` into `rustc_hir_pretty`)\n - #70435 (Add regression test for #66706)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "274c58c487448e0f043ca91acd85c82d1a1164b2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/274c58c487448e0f043ca91acd85c82d1a1164b2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "html_url": "https://github.com/rust-lang/rust/commit/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62c6006450d8bd33a351673c1f969846d768aab4", "url": "https://api.github.com/repos/rust-lang/rust/commits/62c6006450d8bd33a351673c1f969846d768aab4", "html_url": "https://github.com/rust-lang/rust/commit/62c6006450d8bd33a351673c1f969846d768aab4"}, {"sha": "fa15774a4b3466ac71a0f84871c0106591484fd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa15774a4b3466ac71a0f84871c0106591484fd4", "html_url": "https://github.com/rust-lang/rust/commit/fa15774a4b3466ac71a0f84871c0106591484fd4"}], "stats": {"total": 1990, "additions": 547, "deletions": 1443}, "files": [{"sha": "f1fa91362b1ac1c3b0f257dd0227dca07f8b694c", "filename": "Cargo.lock", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -3668,6 +3668,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_feature\",\n  \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n  \"rustc_interface\",\n  \"rustc_lint\",\n  \"rustc_metadata\",\n@@ -3742,9 +3743,7 @@ dependencies = [\n  \"lazy_static 1.4.0\",\n  \"log\",\n  \"rustc_ast\",\n- \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n- \"rustc_errors\",\n  \"rustc_index\",\n  \"rustc_macros\",\n  \"rustc_span\",\n@@ -3753,6 +3752,18 @@ dependencies = [\n  \"smallvec 1.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_hir_pretty\"\n+version = \"0.0.0\"\n+dependencies = [\n+ \"rustc_ast\",\n+ \"rustc_ast_pretty\",\n+ \"rustc_data_structures\",\n+ \"rustc_hir\",\n+ \"rustc_span\",\n+ \"rustc_target\",\n+]\n+\n [[package]]\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n@@ -3903,6 +3914,7 @@ dependencies = [\n  \"rustc_errors\",\n  \"rustc_expand\",\n  \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_session\",\n  \"rustc_span\",\n@@ -4087,6 +4099,7 @@ dependencies = [\n  \"rustc_ast_pretty\",\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n  \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\","}, {"sha": "bc42ac1f0d7aac39d9cd4464c584fa646c709fd8", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 24, "deletions": 41, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -10,7 +10,6 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, Definitions};\n use rustc_hir::intravisit;\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::print::Nested;\n use rustc_hir::*;\n use rustc_index::vec::IndexVec;\n use rustc_span::hygiene::MacroKind;\n@@ -890,20 +889,18 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Get a representation of this `id` for debugging purposes.\n+    /// NOTE: Do NOT use this in diagnostics!\n     pub fn node_to_string(&self, id: HirId) -> String {\n-        hir_id_to_string(self, id, true)\n-    }\n-\n-    pub fn hir_to_user_string(&self, id: HirId) -> String {\n-        hir_id_to_string(self, id, false)\n-    }\n-\n-    pub fn hir_to_pretty_string(&self, id: HirId) -> String {\n-        print::to_string(self, |s| s.print_node(self.get(id)))\n+        hir_id_to_string(self, id)\n     }\n }\n \n impl<'hir> intravisit::Map<'hir> for Map<'hir> {\n+    fn find(&self, hir_id: HirId) -> Option<Node<'hir>> {\n+        self.find(hir_id)\n+    }\n+\n     fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n         self.body(id)\n     }\n@@ -982,23 +979,8 @@ pub(super) fn index_hir<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> &'tcx Indexe\n     tcx.arena.alloc(IndexedHir { crate_hash, map })\n }\n \n-/// Identical to the `PpAnn` implementation for `hir::Crate`,\n-/// except it avoids creating a dependency on the whole crate.\n-impl<'hir> print::PpAnn for Map<'hir> {\n-    fn nested(&self, state: &mut print::State<'_>, nested: print::Nested) {\n-        match nested {\n-            Nested::Item(id) => state.print_item(self.expect_item(id.id)),\n-            Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n-            Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n-            Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat),\n-        }\n-    }\n-}\n-\n-fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n+fn hir_id_to_string(map: &Map<'_>, id: HirId) -> String {\n     let id_str = format!(\" (hir_id={})\", id);\n-    let id_str = if include_id { &id_str[..] } else { \"\" };\n \n     let path_str = || {\n         // This functionality is used for debugging, try to use `TyCtxt` to get\n@@ -1019,6 +1001,9 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         })\n     };\n \n+    let span_str = || map.tcx.sess.source_map().span_to_snippet(map.span(id)).unwrap_or_default();\n+    let node_str = |prefix| format!(\"{} {}{}\", prefix, span_str(), id_str);\n+\n     match map.find(id) {\n         Some(Node::Item(item)) => {\n             let item_str = match item.kind {\n@@ -1069,22 +1054,20 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         Some(Node::Field(ref field)) => {\n             format!(\"field {} in {}{}\", field.ident, path_str(), id_str)\n         }\n-        Some(Node::AnonConst(_)) => format!(\"const {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Expr(_)) => format!(\"expr {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Stmt(_)) => format!(\"stmt {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::PathSegment(_)) => {\n-            format!(\"path segment {}{}\", map.hir_to_pretty_string(id), id_str)\n-        }\n-        Some(Node::Ty(_)) => format!(\"type {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::TraitRef(_)) => format!(\"trait_ref {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Binding(_)) => format!(\"local {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Pat(_)) => format!(\"pat {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Param(_)) => format!(\"param {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Arm(_)) => format!(\"arm {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Block(_)) => format!(\"block {}{}\", map.hir_to_pretty_string(id), id_str),\n-        Some(Node::Local(_)) => format!(\"local {}{}\", map.hir_to_pretty_string(id), id_str),\n+        Some(Node::AnonConst(_)) => node_str(\"const\"),\n+        Some(Node::Expr(_)) => node_str(\"expr\"),\n+        Some(Node::Stmt(_)) => node_str(\"stmt\"),\n+        Some(Node::PathSegment(_)) => node_str(\"path segment\"),\n+        Some(Node::Ty(_)) => node_str(\"type\"),\n+        Some(Node::TraitRef(_)) => node_str(\"trait ref\"),\n+        Some(Node::Binding(_)) => node_str(\"local\"),\n+        Some(Node::Pat(_)) => node_str(\"pat\"),\n+        Some(Node::Param(_)) => node_str(\"param\"),\n+        Some(Node::Arm(_)) => node_str(\"arm\"),\n+        Some(Node::Block(_)) => node_str(\"block\"),\n+        Some(Node::Local(_)) => node_str(\"local\"),\n         Some(Node::Ctor(..)) => format!(\"ctor {}{}\", path_str(), id_str),\n-        Some(Node::Lifetime(_)) => format!(\"lifetime {}{}\", map.hir_to_pretty_string(id), id_str),\n+        Some(Node::Lifetime(_)) => node_str(\"lifetime\"),\n         Some(Node::GenericParam(ref param)) => format!(\"generic_param {:?}{}\", param, id_str),\n         Some(Node::Visibility(ref vis)) => format!(\"visibility {:?}{}\", vis, id_str),\n         Some(Node::MacroDef(_)) => format!(\"macro {}{}\", path_str(), id_str),"}, {"sha": "3ca39b24c5276784a7eae26d7b7fdb719c0b9898", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -21,6 +21,7 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_feature = { path = \"../librustc_feature\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n rustc_metadata = { path = \"../librustc_metadata\" }\n rustc_mir = { path = \"../librustc_mir\" }\n rustc_parse = { path = \"../librustc_parse\" }"}, {"sha": "a57a70e6b8ca71be2871eb7b6982755fa124bd0c", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -7,7 +7,7 @@ use rustc_ast::ast;\n use rustc_ast_pretty::pprust;\n use rustc_hir as hir;\n use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_hir::print as pprust_hir;\n+use rustc_hir_pretty as pprust_hir;\n use rustc_mir::util::{write_mir_graphviz, write_mir_pretty};\n use rustc_session::config::{Input, PpMode, PpSourceMode};\n use rustc_session::Session;\n@@ -155,7 +155,7 @@ impl<'hir> pprust::PpAnn for NoAnn<'hir> {}\n impl<'hir> pprust_hir::PpAnn for NoAnn<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(tcx) = self.tcx {\n-            pprust_hir::PpAnn::nested(&tcx.hir(), state, nested)\n+            pprust_hir::PpAnn::nested(&(&tcx.hir() as &dyn hir::intravisit::Map<'_>), state, nested)\n         }\n     }\n }\n@@ -228,7 +228,7 @@ impl<'hir> HirPrinterSupport<'hir> for IdentifiedAnnotation<'hir> {\n impl<'hir> pprust_hir::PpAnn for IdentifiedAnnotation<'hir> {\n     fn nested(&self, state: &mut pprust_hir::State<'_>, nested: pprust_hir::Nested) {\n         if let Some(ref tcx) = self.tcx {\n-            pprust_hir::PpAnn::nested(&tcx.hir(), state, nested)\n+            pprust_hir::PpAnn::nested(&(&tcx.hir() as &dyn hir::intravisit::Map<'_>), state, nested)\n         }\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {\n@@ -334,7 +334,8 @@ impl<'a, 'tcx> pprust_hir::PpAnn for TypedAnnotation<'a, 'tcx> {\n         if let pprust_hir::Nested::Body(id) = nested {\n             self.tables.set(self.tcx.body_tables(id));\n         }\n-        pprust_hir::PpAnn::nested(&self.tcx.hir(), state, nested);\n+        let pp_ann = &(&self.tcx.hir() as &dyn hir::intravisit::Map<'_>);\n+        pprust_hir::PpAnn::nested(pp_ann, state, nested);\n         self.tables.set(old_tables);\n     }\n     fn pre(&self, s: &mut pprust_hir::State<'_>, node: pprust_hir::AnnNode<'_>) {"}, {"sha": "811440fdeb987f7430e715b5d0bb5b3bfbceba42", "filename": "src/librustc_hir/Cargo.toml", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2FCargo.toml?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -10,13 +10,11 @@ path = \"lib.rs\"\n doctest = false\n \n [dependencies]\n-rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_span = { path = \"../librustc_span\" }\n-rustc_errors = { path = \"../librustc_errors\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n rustc_ast = { path = \"../librustc_ast\" }\n lazy_static = \"1\""}, {"sha": "2054759933f3ce6044fed0b3c1282974d8ee2a28", "filename": "src/librustc_hir/hir.rs", "status": "modified", "additions": 12, "deletions": 86, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fhir.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -2,11 +2,6 @@ use crate::def::{DefKind, Namespace, Res};\n use crate::def_id::DefId;\n crate use crate::hir_id::HirId;\n use crate::itemlikevisit;\n-use crate::print;\n-\n-crate use BlockCheckMode::*;\n-crate use FnRetTy::*;\n-crate use UnsafeSource::*;\n \n use rustc_ast::ast::{self, AsmDialect, CrateSugar, Ident, Name};\n use rustc_ast::ast::{AttrVec, Attribute, FloatTy, IntTy, Label, LitKind, StrStyle, UintTy};\n@@ -16,7 +11,6 @@ use rustc_ast::node_id::NodeMap;\n use rustc_ast::util::parser::ExprPrecedence;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n-use rustc_errors::FatalError;\n use rustc_macros::HashStable_Generic;\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, sym, Symbol};\n@@ -169,12 +163,7 @@ impl fmt::Display for Lifetime {\n \n impl fmt::Debug for Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"lifetime({}: {})\",\n-            self.hir_id,\n-            print::to_string(print::NO_ANN, |s| s.print_lifetime(self))\n-        )\n+        write!(f, \"lifetime({}: {})\", self.hir_id, self.name.ident())\n     }\n }\n \n@@ -191,7 +180,7 @@ impl Lifetime {\n /// A `Path` is essentially Rust's notion of a name; for instance,\n /// `std::cmp::PartialEq`. It's represented as a sequence of identifiers,\n /// along with a bunch of supporting information.\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Path<'hir> {\n     pub span: Span,\n     /// The resolution for the path.\n@@ -206,18 +195,6 @@ impl Path<'_> {\n     }\n }\n \n-impl fmt::Debug for Path<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"path({})\", self)\n-    }\n-}\n-\n-impl fmt::Display for Path<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{}\", print::to_string(print::NO_ANN, |s| s.print_path(self, false)))\n-    }\n-}\n-\n /// A segment of a path: an identifier, an optional lifetime, and a set of\n /// types.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n@@ -388,9 +365,9 @@ pub enum GenericBound<'hir> {\n }\n \n impl GenericBound<'_> {\n-    pub fn trait_def_id(&self) -> Option<DefId> {\n+    pub fn trait_ref(&self) -> Option<&TraitRef<'_>> {\n         match self {\n-            GenericBound::Trait(data, _) => Some(data.trait_ref.trait_def_id()),\n+            GenericBound::Trait(data, _) => Some(&data.trait_ref),\n             _ => None,\n         }\n     }\n@@ -758,25 +735,14 @@ pub struct Block<'hir> {\n     pub targeted_by_break: bool,\n }\n \n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(Debug, RustcEncodable, RustcDecodable, HashStable_Generic)]\n pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]\n     pub hir_id: HirId,\n     pub kind: PatKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Pat<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"pat({}: {})\",\n-            self.hir_id,\n-            print::to_string(print::NO_ANN, |s| s.print_pat(self))\n-        )\n-    }\n-}\n-\n impl Pat<'_> {\n     // FIXME(#19596) this is a workaround, but there should be a better way\n     fn walk_short_(&self, it: &mut impl FnMut(&Pat<'_>) -> bool) -> bool {\n@@ -1118,26 +1084,15 @@ impl UnOp {\n }\n \n /// A statement.\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub struct Stmt<'hir> {\n     pub hir_id: HirId,\n     pub kind: StmtKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Stmt<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"stmt({}: {})\",\n-            self.hir_id,\n-            print::to_string(print::NO_ANN, |s| s.print_stmt(self))\n-        )\n-    }\n-}\n-\n /// The contents of a statement.\n-#[derive(RustcEncodable, RustcDecodable, HashStable_Generic)]\n+#[derive(RustcEncodable, RustcDecodable, Debug, HashStable_Generic)]\n pub enum StmtKind<'hir> {\n     /// A local (`let`) binding.\n     Local(&'hir Local<'hir>),\n@@ -1351,7 +1306,7 @@ pub struct AnonConst {\n }\n \n /// An expression.\n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct Expr<'hir> {\n     pub hir_id: HirId,\n     pub kind: ExprKind<'hir>,\n@@ -1472,17 +1427,6 @@ impl Expr<'_> {\n     }\n }\n \n-impl fmt::Debug for Expr<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"expr({}: {})\",\n-            self.hir_id,\n-            print::to_string(print::NO_ANN, |s| s.print_expr(self))\n-        )\n-    }\n-}\n-\n /// Checks if the specified expression is a built-in range literal.\n /// (See: `LoweringContext::lower_expr()`).\n ///\n@@ -1965,19 +1909,13 @@ impl TypeBinding<'_> {\n     }\n }\n \n-#[derive(RustcEncodable, RustcDecodable)]\n+#[derive(Debug, RustcEncodable, RustcDecodable)]\n pub struct Ty<'hir> {\n     pub hir_id: HirId,\n     pub kind: TyKind<'hir>,\n     pub span: Span,\n }\n \n-impl fmt::Debug for Ty<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"type({})\", print::to_string(print::NO_ANN, |s| s.print_type(self)))\n-    }\n-}\n-\n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n@@ -2182,15 +2120,6 @@ pub enum FnRetTy<'hir> {\n     Return(&'hir Ty<'hir>),\n }\n \n-impl fmt::Display for FnRetTy<'_> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            Self::Return(ref ty) => print::to_string(print::NO_ANN, |s| s.print_type(ty)).fmt(f),\n-            Self::DefaultReturn(_) => \"()\".fmt(f),\n-        }\n-    }\n-}\n-\n impl FnRetTy<'_> {\n     pub fn span(&self) -> Span {\n         match *self {\n@@ -2274,13 +2203,10 @@ pub struct TraitRef<'hir> {\n \n impl TraitRef<'_> {\n     /// Gets the `DefId` of the referenced trait. It _must_ actually be a trait or trait alias.\n-    pub fn trait_def_id(&self) -> DefId {\n+    pub fn trait_def_id(&self) -> Option<DefId> {\n         match self.path.res {\n-            Res::Def(DefKind::Trait, did) => did,\n-            Res::Def(DefKind::TraitAlias, did) => did,\n-            Res::Err => {\n-                FatalError.raise();\n-            }\n+            Res::Def(DefKind::Trait | DefKind::TraitAlias, did) => Some(did),\n+            Res::Err => None,\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "08b4ef1b918e1afc81221f6301703ea7d30291f2", "filename": "src/librustc_hir/intravisit.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fintravisit.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -121,6 +121,8 @@ impl<'a> FnKind<'a> {\n \n /// An abstract representation of the HIR `rustc::hir::map::Map`.\n pub trait Map<'hir> {\n+    /// Retrieves the `Node` corresponding to `id`, returning `None` if cannot be found.\n+    fn find(&self, hir_id: HirId) -> Option<Node<'hir>>;\n     fn body(&self, id: BodyId) -> &'hir Body<'hir>;\n     fn item(&self, id: HirId) -> &'hir Item<'hir>;\n     fn trait_item(&self, id: TraitItemId) -> &'hir TraitItem<'hir>;\n@@ -132,6 +134,9 @@ pub trait Map<'hir> {\n pub struct ErasedMap<'hir>(&'hir dyn Map<'hir>);\n \n impl<'hir> Map<'hir> for ErasedMap<'hir> {\n+    fn find(&self, _: HirId) -> Option<Node<'hir>> {\n+        None\n+    }\n     fn body(&self, id: BodyId) -> &'hir Body<'hir> {\n         self.0.body(id)\n     }"}, {"sha": "49692c73fad80fb3b9fac8a3eeb71710144d56e4", "filename": "src/librustc_hir/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flib.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -7,6 +7,7 @@\n #![feature(const_fn)] // For the unsizing cast on `&[]`\n #![feature(const_panic)]\n #![feature(in_band_lifetimes)]\n+#![feature(or_patterns)]\n #![feature(specialization)]\n #![recursion_limit = \"256\"]\n \n@@ -23,7 +24,6 @@ pub mod intravisit;\n pub mod itemlikevisit;\n pub mod lang_items;\n pub mod pat_util;\n-pub mod print;\n mod stable_hash_impls;\n mod target;\n pub mod weak_lang_items;"}, {"sha": "6a9339b4b9cee874ce67c7e617be30b42adddc5f", "filename": "src/librustc_hir_pretty/Cargo.toml", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir_pretty%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir_pretty%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2FCargo.toml?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -0,0 +1,18 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_hir_pretty\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"rustc_hir_pretty\"\n+path = \"lib.rs\"\n+doctest = false\n+\n+[dependencies]\n+rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n+rustc_hir = { path = \"../librustc_hir\" }\n+rustc_target = { path = \"../librustc_target\" }\n+rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_span = { path = \"../librustc_span\" }\n+rustc_ast = { path = \"../librustc_ast\" }"}, {"sha": "88b1288848f4f6dddbfd2a90dbee60a53a9cb16b", "filename": "src/librustc_hir_pretty/lib.rs", "status": "renamed", "additions": 38, "deletions": 18, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir_pretty%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_hir_pretty%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir_pretty%2Flib.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1,21 +1,26 @@\n+#![recursion_limit = \"256\"]\n+\n use rustc_ast::ast;\n use rustc_ast::util::parser::{self, AssocOp, Fixity};\n use rustc_ast_pretty::pp::Breaks::{Consistent, Inconsistent};\n use rustc_ast_pretty::pp::{self, Breaks};\n use rustc_ast_pretty::pprust::{Comments, PrintState};\n+use rustc_hir as hir;\n+use rustc_hir::{GenericArg, GenericParam, GenericParamKind, Node};\n+use rustc_hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n use rustc_span::source_map::{SourceMap, Spanned};\n use rustc_span::symbol::{kw, IdentPrinter};\n use rustc_span::{self, BytePos, FileName};\n use rustc_target::spec::abi::Abi;\n \n-use crate::hir;\n-use crate::hir::{GenericArg, GenericParam, GenericParamKind, Node};\n-use crate::hir::{GenericBound, PatKind, RangeEnd, TraitBoundModifier};\n-\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::vec;\n \n+pub fn id_to_string(map: &dyn rustc_hir::intravisit::Map<'_>, hir_id: hir::HirId) -> String {\n+    to_string(&map, |s| s.print_node(map.find(hir_id).unwrap()))\n+}\n+\n pub enum AnnNode<'a> {\n     Name(&'a ast::Name),\n     Block(&'a hir::Block<'a>),\n@@ -47,7 +52,7 @@ pub struct NoAnn;\n impl PpAnn for NoAnn {}\n pub const NO_ANN: &dyn PpAnn = &NoAnn;\n \n-impl PpAnn for hir::Crate<'a> {\n+impl PpAnn for hir::Crate<'_> {\n     fn try_fetch_item(&self, item: hir::HirId) -> Option<&hir::Item<'_>> {\n         Some(self.item(item))\n     }\n@@ -62,6 +67,20 @@ impl PpAnn for hir::Crate<'a> {\n     }\n }\n \n+/// Identical to the `PpAnn` implementation for `hir::Crate`,\n+/// except it avoids creating a dependency on the whole crate.\n+impl PpAnn for &dyn rustc_hir::intravisit::Map<'_> {\n+    fn nested(&self, state: &mut State<'_>, nested: Nested) {\n+        match nested {\n+            Nested::Item(id) => state.print_item(self.item(id.id)),\n+            Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n+            Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n+            Nested::Body(id) => state.print_expr(&self.body(id).value),\n+            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat),\n+        }\n+    }\n+}\n+\n pub struct State<'a> {\n     pub s: pp::Printer,\n     comments: Option<Comments<'a>>,\n@@ -1006,10 +1025,10 @@ impl<'a> State<'a> {\n         close_box: bool,\n     ) {\n         match blk.rules {\n-            hir::UnsafeBlock(..) => self.word_space(\"unsafe\"),\n-            hir::PushUnsafeBlock(..) => self.word_space(\"push_unsafe\"),\n-            hir::PopUnsafeBlock(..) => self.word_space(\"pop_unsafe\"),\n-            hir::DefaultBlock => (),\n+            hir::BlockCheckMode::UnsafeBlock(..) => self.word_space(\"unsafe\"),\n+            hir::BlockCheckMode::PushUnsafeBlock(..) => self.word_space(\"push_unsafe\"),\n+            hir::BlockCheckMode::PopUnsafeBlock(..) => self.word_space(\"pop_unsafe\"),\n+            hir::BlockCheckMode::DefaultBlock => (),\n         }\n         self.maybe_print_comment(blk.span.lo());\n         self.ann.pre(self, AnnNode::Block(blk));\n@@ -1092,7 +1111,7 @@ impl<'a> State<'a> {\n         &mut self,\n         qpath: &hir::QPath<'_>,\n         fields: &[hir::Field<'_>],\n-        wth: &Option<&'hir hir::Expr<'_>>,\n+        wth: &Option<&hir::Expr<'_>>,\n     ) {\n         self.print_qpath(qpath, true);\n         self.s.word(\"{\");\n@@ -1848,7 +1867,8 @@ impl<'a> State<'a> {\n                 self.print_block_unclosed(&blk);\n \n                 // If it is a user-provided unsafe block, print a comma after it\n-                if let hir::UnsafeBlock(hir::UserProvided) = blk.rules {\n+                if let hir::BlockCheckMode::UnsafeBlock(hir::UnsafeSource::UserProvided) = blk.rules\n+                {\n                     self.s.word(\",\");\n                 }\n             }\n@@ -1928,18 +1948,18 @@ impl<'a> State<'a> {\n         });\n         self.s.word(\"|\");\n \n-        if let hir::DefaultReturn(..) = decl.output {\n+        if let hir::FnRetTy::DefaultReturn(..) = decl.output {\n             return;\n         }\n \n         self.space_if_not_bol();\n         self.word_space(\"->\");\n         match decl.output {\n-            hir::Return(ref ty) => {\n+            hir::FnRetTy::Return(ref ty) => {\n                 self.print_type(&ty);\n                 self.maybe_print_comment(ty.span.lo())\n             }\n-            hir::DefaultReturn(..) => unreachable!(),\n+            hir::FnRetTy::DefaultReturn(..) => unreachable!(),\n         }\n     }\n \n@@ -2112,21 +2132,21 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_fn_output(&mut self, decl: &hir::FnDecl<'_>) {\n-        if let hir::DefaultReturn(..) = decl.output {\n+        if let hir::FnRetTy::DefaultReturn(..) = decl.output {\n             return;\n         }\n \n         self.space_if_not_bol();\n         self.ibox(INDENT_UNIT);\n         self.word_space(\"->\");\n         match decl.output {\n-            hir::DefaultReturn(..) => unreachable!(),\n-            hir::Return(ref ty) => self.print_type(&ty),\n+            hir::FnRetTy::DefaultReturn(..) => unreachable!(),\n+            hir::FnRetTy::Return(ref ty) => self.print_type(&ty),\n         }\n         self.end();\n \n         match decl.output {\n-            hir::Return(ref output) => self.maybe_print_comment(output.span.lo()),\n+            hir::FnRetTy::Return(ref output) => self.maybe_print_comment(output.span.lo()),\n             _ => {}\n         }\n     }", "previous_filename": "src/librustc_hir/print.rs"}, {"sha": "ea439b1f41d4252cfc757544e39c8418bdb3a98f", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -19,6 +19,7 @@ rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_index = { path = \"../librustc_index\" }\n rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }"}, {"sha": "3686b2f20487b0844d5eef190e5f60a0c94b1a67", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -824,8 +824,10 @@ impl EncodeContext<'tcx> {\n \n         record!(self.per_def.kind[def_id] <- match trait_item.kind {\n             ty::AssocKind::Const => {\n-                let rendered =\n-                    hir::print::to_string(&self.tcx.hir(), |s| s.print_trait_item(ast_item));\n+                let rendered = rustc_hir_pretty::to_string(\n+                    &(&self.tcx.hir() as &dyn intravisit::Map<'_>),\n+                    |s| s.print_trait_item(ast_item)\n+                );\n                 let rendered_const = self.lazy(RenderedConst(rendered));\n \n                 EntryKind::AssocConst(\n@@ -1044,8 +1046,11 @@ impl EncodeContext<'tcx> {\n     }\n \n     fn encode_rendered_const_for_body(&mut self, body_id: hir::BodyId) -> Lazy<RenderedConst> {\n-        let body = self.tcx.hir().body(body_id);\n-        let rendered = hir::print::to_string(&self.tcx.hir(), |s| s.print_expr(&body.value));\n+        let hir = self.tcx.hir();\n+        let body = hir.body(body_id);\n+        let rendered = rustc_hir_pretty::to_string(&(&hir as &dyn intravisit::Map<'_>), |s| {\n+            s.print_expr(&body.value)\n+        });\n         let rendered_const = &RenderedConst(rendered);\n         self.lazy(rendered_const)\n     }"}, {"sha": "882c6bd0333eeaffc6f4cac9c7dd8279c90db799", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -29,12 +29,12 @@ use std::mem;\n use std::rc::Rc;\n \n use crate::dataflow;\n-use crate::dataflow::generic::{Analysis, BorrowckFlowState as Flows, BorrowckResults};\n use crate::dataflow::indexes::{BorrowIndex, InitIndex, MoveOutIndex, MovePathIndex};\n use crate::dataflow::move_paths::{InitLocation, LookupResult, MoveData, MoveError};\n use crate::dataflow::Borrows;\n use crate::dataflow::EverInitializedPlaces;\n use crate::dataflow::MoveDataParamEnv;\n+use crate::dataflow::{Analysis, BorrowckFlowState as Flows, BorrowckResults};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use crate::transform::MirSource;\n \n@@ -298,7 +298,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n         mbcx.report_move_errors(errors);\n     }\n \n-    dataflow::generic::visit_results(\n+    dataflow::visit_results(\n         &*body,\n         traversal::reverse_postorder(&*body).map(|(bb, _)| bb),\n         &results,\n@@ -509,7 +509,7 @@ crate struct MirBorrowckCtxt<'cx, 'tcx> {\n // 2. loans made in overlapping scopes do not conflict\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n-impl<'cx, 'tcx> dataflow::generic::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n+impl<'cx, 'tcx> dataflow::ResultsVisitor<'cx, 'tcx> for MirBorrowckCtxt<'cx, 'tcx> {\n     type FlowState = Flows<'cx, 'tcx>;\n \n     fn visit_statement("}, {"sha": "8e929a4fa22f48ee640d73dee11f434985525069", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -21,9 +21,9 @@ use std::str::FromStr;\n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n \n-use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::{InitKind, InitLocation, MoveData};\n use crate::dataflow::MaybeInitializedPlaces;\n+use crate::dataflow::ResultsCursor;\n use crate::transform::MirSource;\n use crate::util as mir_util;\n use crate::util::pretty;"}, {"sha": "a55529ed0ef12efd2c1adc93d76c40013a480f83", "filename": "src/librustc_mir/borrow_check/type_check/liveness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Fmod.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -3,9 +3,9 @@ use rustc::ty::{RegionVid, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n \n-use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::MaybeInitializedPlaces;\n+use crate::dataflow::ResultsCursor;\n \n use crate::borrow_check::{\n     constraints::OutlivesConstraintSet,"}, {"sha": "75b269c79b96e59e16b45957cd4cb9348f3ff06e", "filename": "src/librustc_mir/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -8,10 +8,10 @@ use rustc_trait_selection::traits::query::type_op::outlives::DropckOutlives;\n use rustc_trait_selection::traits::query::type_op::TypeOp;\n use std::rc::Rc;\n \n-use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::indexes::MovePathIndex;\n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n use crate::dataflow::MaybeInitializedPlaces;\n+use crate::dataflow::ResultsCursor;\n \n use crate::borrow_check::{\n     region_infer::values::{self, PointIndex, RegionValueElements},"}, {"sha": "02f6bcade23a2cdc1200caaa039571b6e0af23f5", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -39,9 +39,9 @@ use rustc_trait_selection::traits::query::type_op::custom::CustomTypeOp;\n use rustc_trait_selection::traits::query::{Fallible, NoSolution};\n use rustc_trait_selection::traits::{self, ObligationCause, PredicateObligations};\n \n-use crate::dataflow::generic::ResultsCursor;\n use crate::dataflow::move_paths::MoveData;\n use crate::dataflow::MaybeInitializedPlaces;\n+use crate::dataflow::ResultsCursor;\n use crate::transform::promote_consts::should_suggest_const_in_array_repeat_expressions_attribute;\n \n use crate::borrow_check::{"}, {"sha": "e4eb8506846c0b60b571ef0fc9603e780f2a2277", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "removed", "additions": 0, "deletions": 169, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c6006450d8bd33a351673c1f969846d768aab4/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=62c6006450d8bd33a351673c1f969846d768aab4", "patch": "@@ -1,169 +0,0 @@\n-//! A nice wrapper to consume dataflow results at several CFG\n-//! locations.\n-\n-use rustc::mir::{BasicBlock, Location};\n-use rustc_index::bit_set::{BitIter, BitSet, HybridBitSet};\n-\n-use crate::dataflow::{BitDenotation, DataflowResults, GenKillSet};\n-\n-use std::borrow::Borrow;\n-use std::iter;\n-\n-/// A trait for \"cartesian products\" of multiple FlowAtLocation.\n-///\n-/// There's probably a way to auto-impl this, but I think\n-/// it is cleaner to have manual visitor impls.\n-pub trait FlowsAtLocation {\n-    /// Reset the state bitvector to represent the entry to block `bb`.\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock);\n-\n-    /// Reset the state bitvector to represent the exit of the\n-    /// terminator of block `bb`.\n-    ///\n-    /// **Important:** In the case of a `Call` terminator, these\n-    /// effects do *not* include the result of storing the destination\n-    /// of the call, since that is edge-dependent (in other words, the\n-    /// effects don't apply to the unwind edge).\n-    fn reset_to_exit_of(&mut self, bb: BasicBlock);\n-\n-    /// Builds gen and kill sets for statement at `loc`.\n-    ///\n-    /// Note that invoking this method alone does not change the\n-    /// `curr_state` -- you must invoke `apply_local_effect`\n-    /// afterwards.\n-    fn reconstruct_statement_effect(&mut self, loc: Location);\n-\n-    /// Builds gen and kill sets for terminator for `loc`.\n-    ///\n-    /// Note that invoking this method alone does not change the\n-    /// `curr_state` -- you must invoke `apply_local_effect`\n-    /// afterwards.\n-    fn reconstruct_terminator_effect(&mut self, loc: Location);\n-\n-    /// Apply current gen + kill sets to `flow_state`.\n-    ///\n-    /// (`loc` parameters can be ignored if desired by\n-    /// client. For the terminator, the `stmt_idx` will be the number\n-    /// of statements in the block.)\n-    fn apply_local_effect(&mut self, loc: Location);\n-}\n-\n-/// Represents the state of dataflow at a particular\n-/// CFG location, both before and after it is\n-/// executed.\n-///\n-/// Data flow results are typically computed only as basic block\n-/// boundaries. A `FlowInProgress` allows you to reconstruct the\n-/// effects at any point in the control-flow graph by starting with\n-/// the state at the start of the basic block (`reset_to_entry_of`)\n-/// and then replaying the effects of statements and terminators\n-/// (e.g., via `reconstruct_statement_effect` and\n-/// `reconstruct_terminator_effect`; don't forget to call\n-/// `apply_local_effect`).\n-pub struct FlowAtLocation<'tcx, BD, DR = DataflowResults<'tcx, BD>>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    base_results: DR,\n-    curr_state: BitSet<BD::Idx>,\n-    stmt_trans: GenKillSet<BD::Idx>,\n-}\n-\n-impl<'tcx, BD, DR> FlowAtLocation<'tcx, BD, DR>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    /// Iterate over each bit set in the current state.\n-    pub fn each_state_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.curr_state.iter().for_each(f)\n-    }\n-\n-    /// Iterate over each `gen` bit in the current effect (invoke\n-    /// `reconstruct_statement_effect` or\n-    /// `reconstruct_terminator_effect` first).\n-    pub fn each_gen_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.stmt_trans.gen_set.iter().for_each(f)\n-    }\n-\n-    pub fn new(results: DR) -> Self {\n-        let bits_per_block = results.borrow().sets().bits_per_block();\n-        let curr_state = BitSet::new_empty(bits_per_block);\n-        let stmt_trans = GenKillSet::from_elem(HybridBitSet::new_empty(bits_per_block));\n-        FlowAtLocation { base_results: results, curr_state, stmt_trans }\n-    }\n-\n-    /// Access the underlying operator.\n-    pub fn operator(&self) -> &BD {\n-        self.base_results.borrow().operator()\n-    }\n-\n-    pub fn contains(&self, x: BD::Idx) -> bool {\n-        self.curr_state.contains(x)\n-    }\n-\n-    /// Returns an iterator over the elements present in the current state.\n-    pub fn iter_incoming(&self) -> iter::Peekable<BitIter<'_, BD::Idx>> {\n-        self.curr_state.iter().peekable()\n-    }\n-\n-    /// Creates a clone of the current state and applies the local\n-    /// effects to the clone (leaving the state of self intact).\n-    /// Invokes `f` with an iterator over the resulting state.\n-    pub fn with_iter_outgoing<F>(&self, f: F)\n-    where\n-        F: FnOnce(BitIter<'_, BD::Idx>),\n-    {\n-        let mut curr_state = self.curr_state.clone();\n-        self.stmt_trans.apply(&mut curr_state);\n-        f(curr_state.iter());\n-    }\n-\n-    /// Returns a bitset of the elements present in the current state.\n-    pub fn as_dense(&self) -> &BitSet<BD::Idx> {\n-        &self.curr_state\n-    }\n-}\n-\n-impl<'tcx, BD, DR> FlowsAtLocation for FlowAtLocation<'tcx, BD, DR>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    fn reset_to_entry_of(&mut self, bb: BasicBlock) {\n-        self.curr_state.overwrite(self.base_results.borrow().sets().entry_set_for(bb.index()));\n-    }\n-\n-    fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n-        self.reset_to_entry_of(bb);\n-        let trans = self.base_results.borrow().sets().trans_for(bb.index());\n-        trans.apply(&mut self.curr_state)\n-    }\n-\n-    fn reconstruct_statement_effect(&mut self, loc: Location) {\n-        self.stmt_trans.clear();\n-        self.base_results.borrow().operator().before_statement_effect(&mut self.stmt_trans, loc);\n-        self.stmt_trans.apply(&mut self.curr_state);\n-\n-        self.base_results.borrow().operator().statement_effect(&mut self.stmt_trans, loc);\n-    }\n-\n-    fn reconstruct_terminator_effect(&mut self, loc: Location) {\n-        self.stmt_trans.clear();\n-        self.base_results.borrow().operator().before_terminator_effect(&mut self.stmt_trans, loc);\n-        self.stmt_trans.apply(&mut self.curr_state);\n-\n-        self.base_results.borrow().operator().terminator_effect(&mut self.stmt_trans, loc);\n-    }\n-\n-    fn apply_local_effect(&mut self, _loc: Location) {\n-        self.stmt_trans.apply(&mut self.curr_state)\n-    }\n-}"}, {"sha": "170157aca5ddd678391efc9083286821b27898d8", "filename": "src/librustc_mir/dataflow/framework/cursor.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fcursor.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "previous_filename": "src/librustc_mir/dataflow/generic/cursor.rs"}, {"sha": "d32072125b3b9fcd101dfbc5bea2de536a0382e3", "filename": "src/librustc_mir/dataflow/framework/engine.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fengine.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "previous_filename": "src/librustc_mir/dataflow/generic/engine.rs"}, {"sha": "c15f2a726ee705e5d2f4c570be1a4615ae3691ca", "filename": "src/librustc_mir/dataflow/framework/graphviz.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fgraphviz.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "previous_filename": "src/librustc_mir/dataflow/generic/graphviz.rs"}, {"sha": "8556be7e740623ab05e6297ce684ad4116f0ab57", "filename": "src/librustc_mir/dataflow/framework/mod.rs", "status": "renamed", "additions": 56, "deletions": 19, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fmod.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1,26 +1,25 @@\n //! A framework that can express both [gen-kill] and generic dataflow problems.\n //!\n-//! There is another interface for dataflow in the compiler in `librustc_mir/dataflow/mod.rs`. The\n-//! interface in this module will eventually [replace that one][design-meeting].\n+//! To actually use this framework, you must implement either the `Analysis` or the\n+//! `GenKillAnalysis` trait. If your transfer function can be expressed with only gen/kill\n+//! operations, prefer `GenKillAnalysis` since it will run faster while iterating to fixpoint. The\n+//! `impls` module contains several examples of gen/kill dataflow analyses.\n //!\n-//! To actually use this framework, you must implement either the `Analysis` or the `GenKillAnalysis`\n-//! trait. If your transfer function can be expressed with only gen/kill operations, prefer\n-//! `GenKillAnalysis` since it will run faster while iterating to fixpoint. Create an `Engine` using\n-//! the appropriate constructor and call `iterate_to_fixpoint`. You can use a `ResultsCursor` to\n-//! inspect the fixpoint solution to your dataflow problem.\n+//! Create an `Engine` for your analysis using the `into_engine` method on the `Analysis` trait,\n+//! then call `iterate_to_fixpoint`. From there, you can use a `ResultsCursor` to inspect the\n+//! fixpoint solution to your dataflow problem, or implement the `ResultsVisitor` interface and use\n+//! `visit_results`. The following example uses the `ResultsCursor` approach.\n //!\n //! ```ignore(cross-crate-imports)\n-//! fn do_my_analysis(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>, did: DefId) {\n-//!     let analysis = MyAnalysis::new();\n-//!\n-//!     // If `MyAnalysis` implements `GenKillAnalysis`.\n-//!     let results = Engine::new_gen_kill(tcx, body, did, analysis).iterate_to_fixpoint();\n+//! use rustc_mir::dataflow::Analysis; // Makes `into_engine` available.\n //!\n-//!     // If `MyAnalysis` implements `Analysis`.\n-//!     // let results = Engine::new_generic(tcx, body, did, analysis).iterate_to_fixpoint();\n-//!\n-//!     let mut cursor = ResultsCursor::new(body, results);\n+//! fn do_my_analysis(tcx: TyCtxt<'tcx>, body: &mir::Body<'tcx>, did: DefId) {\n+//!     let analysis = MyAnalysis::new()\n+//!         .into_engine(tcx, body, did)\n+//!         .iterate_to_fixpoint()\n+//!         .into_results_cursor(body);\n //!\n+//!     // Print the dataflow state *after* each statement in the start block.\n //!     for (_, statement_index) in body.block_data[START_BLOCK].statements.iter_enumerated() {\n //!         cursor.seek_after(Location { block: START_BLOCK, statement_index });\n //!         let state = cursor.get();\n@@ -30,7 +29,6 @@\n //! ```\n //!\n //! [gen-kill]: https://en.wikipedia.org/wiki/Data-flow_analysis#Bit_vector_problems\n-//! [design-meeting]https://github.com/rust-lang/compiler-team/issues/202\n \n use std::io;\n \n@@ -41,8 +39,6 @@ use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::{BitSet, HybridBitSet};\n use rustc_index::vec::{Idx, IndexVec};\n \n-use crate::dataflow::BottomValue;\n-\n mod cursor;\n mod engine;\n mod graphviz;\n@@ -95,6 +91,47 @@ where\n     }\n }\n \n+/// Parameterization for the precise form of data flow that is used.\n+///\n+/// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n+/// This also determines the semantics of the lattice `join` operator used to merge dataflow\n+/// results, since dataflow works by starting at the bottom and moving monotonically to a fixed\n+/// point.\n+///\n+/// This means, for propagation across the graph, that you either want to start at all-zeroes and\n+/// then use Union as your merge when propagating, or you start at all-ones and then use Intersect\n+/// as your merge when propagating.\n+pub trait BottomValue {\n+    /// Specifies the initial value for each bit in the entry set for each basic block.\n+    const BOTTOM_VALUE: bool;\n+\n+    /// Merges `in_set` into `inout_set`, returning `true` if `inout_set` changed.\n+    ///\n+    /// It is almost certainly wrong to override this, since it automatically applies\n+    /// * `inout_set & in_set` if `BOTTOM_VALUE == true`\n+    /// * `inout_set | in_set` if `BOTTOM_VALUE == false`\n+    ///\n+    /// This means that if a bit is not `BOTTOM_VALUE`, it is propagated into all target blocks.\n+    /// For clarity, the above statement again from a different perspective:\n+    /// A bit in the block's entry set is `!BOTTOM_VALUE` if *any* predecessor block's bit value is\n+    /// `!BOTTOM_VALUE`.\n+    ///\n+    /// There are situations where you want the opposite behaviour: propagate only if *all*\n+    /// predecessor blocks's value is `!BOTTOM_VALUE`.\n+    /// E.g. if you want to know whether a bit is *definitely* set at a specific location. This\n+    /// means that all code paths leading to the location must have set the bit, instead of any\n+    /// code path leading there.\n+    ///\n+    /// If you want this kind of \"definitely set\" analysis, you need to\n+    /// 1. Invert `BOTTOM_VALUE`\n+    /// 2. Reset the `entry_set` in `start_block_effect` to `!BOTTOM_VALUE`\n+    /// 3. Override `join` to do the opposite from what it's doing now.\n+    #[inline]\n+    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n+        if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n+    }\n+}\n+\n /// Define the domain of a dataflow problem.\n ///\n /// This trait specifies the lattice on which this analysis operates. For now, this must be a", "previous_filename": "src/librustc_mir/dataflow/generic/mod.rs"}, {"sha": "8f07a10e1b01ce11734a44859e60faceea5fe0be", "filename": "src/librustc_mir/dataflow/framework/tests.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Ftests.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "previous_filename": "src/librustc_mir/dataflow/generic/tests.rs"}, {"sha": "6e1513bcd1dd0beb042e6d673cb0f0e9c49c9a12", "filename": "src/librustc_mir/dataflow/framework/visitor.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fframework%2Fvisitor.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "previous_filename": "src/librustc_mir/dataflow/generic/visitor.rs"}, {"sha": "955021d83aa098a69ba4e50cbde0f58219546286", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1,6 +1,6 @@\n pub use super::*;\n \n-use crate::dataflow::generic::{AnalysisDomain, GenKill, GenKillAnalysis};\n+use crate::dataflow::{AnalysisDomain, GenKill, GenKillAnalysis};\n use rustc::mir::visit::Visitor;\n use rustc::mir::*;\n use rustc::ty::{ParamEnv, TyCtxt};"}, {"sha": "9e9e414ad648bf4445c815de5ef5c2f6177b7fd9", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -8,8 +8,8 @@ use rustc_index::bit_set::BitSet;\n use crate::borrow_check::{\n     places_conflict, BorrowSet, PlaceConflictBias, PlaceExt, RegionInferenceContext, ToRegionVid,\n };\n-use crate::dataflow::generic::{self, GenKill};\n use crate::dataflow::BottomValue;\n+use crate::dataflow::{self, GenKill};\n \n use std::rc::Rc;\n \n@@ -226,7 +226,7 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     }\n }\n \n-impl<'tcx> generic::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n+impl<'tcx> dataflow::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n     type Idx = BorrowIndex;\n \n     const NAME: &'static str = \"borrows\";\n@@ -245,7 +245,7 @@ impl<'tcx> generic::AnalysisDomain<'tcx> for Borrows<'_, 'tcx> {\n     }\n }\n \n-impl<'tcx> generic::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n+impl<'tcx> dataflow::GenKillAnalysis<'tcx> for Borrows<'_, 'tcx> {\n     fn before_statement_effect(\n         &self,\n         trans: &mut impl GenKill<Self::Idx>,"}, {"sha": "180094e412b15ce665d905c802aea283a3b7b00f", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -12,9 +12,8 @@ use super::MoveDataParamEnv;\n \n use crate::util::elaborate_drops::DropFlagState;\n \n-use super::generic::{AnalysisDomain, GenKill, GenKillAnalysis};\n use super::move_paths::{HasMoveData, InitIndex, InitKind, LookupResult, MoveData, MovePathIndex};\n-use super::BottomValue;\n+use super::{AnalysisDomain, BottomValue, GenKill, GenKillAnalysis};\n \n use super::drop_flag_effects_for_function_entry;\n use super::drop_flag_effects_for_location;"}, {"sha": "f8d1efabd33c055197790e198f4f9532ed309ed2", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1,7 +1,7 @@\n pub use super::*;\n \n-use crate::dataflow::generic::{self as dataflow, GenKill, Results, ResultsRefCursor};\n use crate::dataflow::BottomValue;\n+use crate::dataflow::{self, GenKill, Results, ResultsRefCursor};\n use rustc::mir::visit::{NonMutatingUseContext, PlaceContext, Visitor};\n use rustc::mir::*;\n use std::cell::RefCell;"}, {"sha": "96e5b6936a191e7523f6d5a609196309fd5736cc", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 14, "deletions": 900, "changes": 914, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1,35 +1,22 @@\n-use rustc::mir::traversal;\n-use rustc::mir::{self, BasicBlock, BasicBlockData, Body, Location, Statement, Terminator};\n-use rustc::ty::{self, TyCtxt};\n+use rustc::ty;\n use rustc_ast::ast::{self, MetaItem};\n-use rustc_ast_pretty::pprust;\n-use rustc_data_structures::work_queue::WorkQueue;\n-use rustc_hir::def_id::DefId;\n-use rustc_index::bit_set::{BitSet, HybridBitSet};\n-use rustc_index::vec::Idx;\n-use rustc_session::Session;\n use rustc_span::symbol::{sym, Symbol};\n \n-use std::borrow::Borrow;\n-use std::fmt;\n-use std::io;\n-use std::path::PathBuf;\n-\n-pub use self::at_location::{FlowAtLocation, FlowsAtLocation};\n pub(crate) use self::drop_flag_effects::*;\n-pub use self::impls::borrows::Borrows;\n-pub use self::impls::DefinitelyInitializedPlaces;\n-pub use self::impls::EverInitializedPlaces;\n-pub use self::impls::{MaybeBorrowedLocals, MaybeMutBorrowedLocals};\n-pub use self::impls::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n-pub use self::impls::{MaybeRequiresStorage, MaybeStorageLive};\n+pub use self::framework::{\n+    visit_results, Analysis, AnalysisDomain, BorrowckFlowState, BorrowckResults, BottomValue,\n+    Engine, GenKill, GenKillAnalysis, Results, ResultsCursor, ResultsRefCursor, ResultsVisitor,\n+};\n+pub use self::impls::{\n+    borrows::Borrows, DefinitelyInitializedPlaces, EverInitializedPlaces, MaybeBorrowedLocals,\n+    MaybeInitializedPlaces, MaybeMutBorrowedLocals, MaybeRequiresStorage, MaybeStorageLive,\n+    MaybeUninitializedPlaces,\n+};\n \n use self::move_paths::MoveData;\n \n-mod at_location;\n pub mod drop_flag_effects;\n-pub mod generic;\n-mod graphviz;\n+mod framework;\n mod impls;\n pub mod move_paths;\n \n@@ -40,74 +27,9 @@ pub(crate) mod indexes {\n     };\n }\n \n-pub(crate) struct DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    def_id: DefId,\n-    flow_state: DataflowAnalysis<'a, 'tcx, BD>,\n-    print_preflow_to: Option<String>,\n-    print_postflow_to: Option<String>,\n-}\n-\n-/// `DebugFormatted` encapsulates the \"{:?}\" rendering of some\n-/// arbitrary value. This way: you pay cost of allocating an extra\n-/// string (as well as that of rendering up-front); in exchange, you\n-/// don't have to hand over ownership of your value or deal with\n-/// borrowing it.\n-pub struct DebugFormatted(String);\n-\n-impl DebugFormatted {\n-    pub fn new(input: &dyn fmt::Debug) -> DebugFormatted {\n-        DebugFormatted(format!(\"{:?}\", input))\n-    }\n-}\n-\n-impl fmt::Debug for DebugFormatted {\n-    fn fmt(&self, w: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(w, \"{}\", self.0)\n-    }\n-}\n-\n-pub trait Dataflow<'tcx, BD: BitDenotation<'tcx>> {\n-    /// Sets up and runs the dataflow problem, using `p` to render results if\n-    /// implementation so chooses.\n-    fn dataflow<P>(&mut self, p: P)\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        let _ = p; // default implementation does not instrument process.\n-        self.build_sets();\n-        self.propagate();\n-    }\n-\n-    /// Sets up the entry, gen, and kill sets for this instance of a dataflow problem.\n-    fn build_sets(&mut self);\n-\n-    /// Finds a fixed-point solution to this instance of a dataflow problem.\n-    fn propagate(&mut self);\n-}\n-\n-impl<'a, 'tcx, BD> Dataflow<'tcx, BD> for DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn dataflow<P>(&mut self, p: P)\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        self.flow_state.build_sets();\n-        self.pre_dataflow_instrumentation(|c, i| p(c, i)).unwrap();\n-        self.flow_state.propagate();\n-        self.post_dataflow_instrumentation(|c, i| p(c, i)).unwrap();\n-    }\n-\n-    fn build_sets(&mut self) {\n-        self.flow_state.build_sets();\n-    }\n-    fn propagate(&mut self) {\n-        self.flow_state.propagate();\n-    }\n+pub struct MoveDataParamEnv<'tcx> {\n+    pub(crate) move_data: MoveData<'tcx>,\n+    pub(crate) param_env: ty::ParamEnv<'tcx>,\n }\n \n pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Option<MetaItem> {\n@@ -124,811 +46,3 @@ pub(crate) fn has_rustc_mir_with(attrs: &[ast::Attribute], name: Symbol) -> Opti\n     }\n     None\n }\n-\n-pub struct MoveDataParamEnv<'tcx> {\n-    pub(crate) move_data: MoveData<'tcx>,\n-    pub(crate) param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-pub fn do_dataflow<'a, 'tcx, BD, P>(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a Body<'tcx>,\n-    def_id: DefId,\n-    attributes: &[ast::Attribute],\n-    dead_unwinds: &BitSet<BasicBlock>,\n-    bd: BD,\n-    p: P,\n-) -> DataflowResults<'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-    P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-{\n-    let flow_state = DataflowAnalysis::new(body, dead_unwinds, bd);\n-    flow_state.run(tcx, def_id, attributes, p)\n-}\n-\n-impl<'a, 'tcx, BD> DataflowAnalysis<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    pub(crate) fn run<P>(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        def_id: DefId,\n-        attributes: &[ast::Attribute],\n-        p: P,\n-    ) -> DataflowResults<'tcx, BD>\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        let name_found = |sess: &Session, attrs: &[ast::Attribute], name| -> Option<String> {\n-            if let Some(item) = has_rustc_mir_with(attrs, name) {\n-                if let Some(s) = item.value_str() {\n-                    return Some(s.to_string());\n-                } else {\n-                    let path = pprust::path_to_string(&item.path);\n-                    sess.span_err(item.span, &format!(\"{} attribute requires a path\", path));\n-                    return None;\n-                }\n-            }\n-            None\n-        };\n-\n-        let print_preflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_preflow);\n-        let print_postflow_to = name_found(tcx.sess, attributes, sym::borrowck_graphviz_postflow);\n-\n-        let mut mbcx =\n-            DataflowBuilder { def_id, print_preflow_to, print_postflow_to, flow_state: self };\n-\n-        mbcx.dataflow(p);\n-        mbcx.flow_state.results()\n-    }\n-}\n-\n-struct PropagationContext<'b, 'a, 'tcx, O>\n-where\n-    O: BitDenotation<'tcx>,\n-{\n-    builder: &'b mut DataflowAnalysis<'a, 'tcx, O>,\n-}\n-\n-impl<'a, 'tcx, BD> DataflowAnalysis<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn propagate(&mut self) {\n-        let mut temp = BitSet::new_empty(self.flow_state.sets.bits_per_block);\n-        let mut propcx = PropagationContext { builder: self };\n-        propcx.walk_cfg(&mut temp);\n-    }\n-\n-    fn build_sets(&mut self) {\n-        // Build the transfer function for each block.\n-        for (bb, data) in self.body.basic_blocks().iter_enumerated() {\n-            let &mir::BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = data;\n-\n-            let trans = self.flow_state.sets.trans_mut_for(bb.index());\n-            for j_stmt in 0..statements.len() {\n-                let location = Location { block: bb, statement_index: j_stmt };\n-                self.flow_state.operator.before_statement_effect(trans, location);\n-                self.flow_state.operator.statement_effect(trans, location);\n-            }\n-\n-            if terminator.is_some() {\n-                let location = Location { block: bb, statement_index: statements.len() };\n-                self.flow_state.operator.before_terminator_effect(trans, location);\n-                self.flow_state.operator.terminator_effect(trans, location);\n-            }\n-        }\n-\n-        // Initialize the flow state at entry to the start block.\n-        let on_entry = self.flow_state.sets.entry_set_mut_for(mir::START_BLOCK.index());\n-        self.flow_state.operator.start_block_effect(on_entry);\n-    }\n-}\n-\n-impl<'b, 'a, 'tcx, BD> PropagationContext<'b, 'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn walk_cfg(&mut self, in_out: &mut BitSet<BD::Idx>) {\n-        let body = self.builder.body;\n-\n-        // Initialize the dirty queue in reverse post-order. This makes it more likely that the\n-        // entry state for each basic block will have the effects of its predecessors applied\n-        // before it is processed. In fact, for CFGs without back edges, this guarantees that\n-        // dataflow will converge in exactly `N` iterations, where `N` is the number of basic\n-        // blocks.\n-        let mut dirty_queue: WorkQueue<mir::BasicBlock> =\n-            WorkQueue::with_none(body.basic_blocks().len());\n-        for (bb, _) in traversal::reverse_postorder(body) {\n-            dirty_queue.insert(bb);\n-        }\n-\n-        // Add blocks which are not reachable from START_BLOCK to the work queue. These blocks will\n-        // be processed after the ones added above.\n-        for bb in body.basic_blocks().indices() {\n-            dirty_queue.insert(bb);\n-        }\n-\n-        while let Some(bb) = dirty_queue.pop() {\n-            let (on_entry, trans) = self.builder.flow_state.sets.get_mut(bb.index());\n-            debug_assert!(in_out.words().len() == on_entry.words().len());\n-            in_out.overwrite(on_entry);\n-            trans.apply(in_out);\n-\n-            let bb_data = &body[bb];\n-            self.builder.propagate_bits_into_graph_successors_of(\n-                in_out,\n-                (bb, bb_data),\n-                &mut dirty_queue,\n-            );\n-        }\n-    }\n-}\n-\n-fn dataflow_path(context: &str, path: &str) -> PathBuf {\n-    let mut path = PathBuf::from(path);\n-    let new_file_name = {\n-        let orig_file_name = path.file_name().unwrap().to_str().unwrap();\n-        format!(\"{}_{}\", context, orig_file_name)\n-    };\n-    path.set_file_name(new_file_name);\n-    path\n-}\n-\n-impl<'a, 'tcx, BD> DataflowBuilder<'a, 'tcx, BD>\n-where\n-    BD: BitDenotation<'tcx>,\n-{\n-    fn pre_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        if let Some(ref path_str) = self.print_preflow_to {\n-            let path = dataflow_path(BD::name(), path_str);\n-            graphviz::print_borrowck_graph_to(self, &path, p)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-\n-    fn post_dataflow_instrumentation<P>(&self, p: P) -> io::Result<()>\n-    where\n-        P: Fn(&BD, BD::Idx) -> DebugFormatted,\n-    {\n-        if let Some(ref path_str) = self.print_postflow_to {\n-            let path = dataflow_path(BD::name(), path_str);\n-            graphviz::print_borrowck_graph_to(self, &path, p)\n-        } else {\n-            Ok(())\n-        }\n-    }\n-}\n-\n-/// DataflowResultsConsumer abstracts over walking the MIR with some\n-/// already constructed dataflow results.\n-///\n-/// It abstracts over the FlowState and also completely hides the\n-/// underlying flow analysis results, because it needs to handle cases\n-/// where we are combining the results of *multiple* flow analyses\n-/// (e.g., borrows + inits + uninits).\n-pub(crate) trait DataflowResultsConsumer<'a, 'tcx: 'a> {\n-    type FlowState: FlowsAtLocation;\n-\n-    // Observation Hooks: override (at least one of) these to get analysis feedback.\n-    fn visit_block_entry(&mut self, _bb: BasicBlock, _flow_state: &Self::FlowState) {}\n-\n-    fn visit_statement_entry(\n-        &mut self,\n-        _loc: Location,\n-        _stmt: &'a Statement<'tcx>,\n-        _flow_state: &Self::FlowState,\n-    ) {\n-    }\n-\n-    fn visit_terminator_entry(\n-        &mut self,\n-        _loc: Location,\n-        _term: &'a Terminator<'tcx>,\n-        _flow_state: &Self::FlowState,\n-    ) {\n-    }\n-\n-    // Main entry point: this drives the processing of results.\n-\n-    fn analyze_results(&mut self, flow_uninit: &mut Self::FlowState) {\n-        let flow = flow_uninit;\n-        for (bb, _) in traversal::reverse_postorder(self.body()) {\n-            flow.reset_to_entry_of(bb);\n-            self.process_basic_block(bb, flow);\n-        }\n-    }\n-\n-    fn process_basic_block(&mut self, bb: BasicBlock, flow_state: &mut Self::FlowState) {\n-        self.visit_block_entry(bb, flow_state);\n-\n-        let BasicBlockData { ref statements, ref terminator, is_cleanup: _ } = self.body()[bb];\n-        let mut location = Location { block: bb, statement_index: 0 };\n-        for stmt in statements.iter() {\n-            flow_state.reconstruct_statement_effect(location);\n-            self.visit_statement_entry(location, stmt, flow_state);\n-            flow_state.apply_local_effect(location);\n-            location.statement_index += 1;\n-        }\n-\n-        if let Some(ref term) = *terminator {\n-            flow_state.reconstruct_terminator_effect(location);\n-            self.visit_terminator_entry(location, term, flow_state);\n-\n-            // We don't need to apply the effect of the terminator,\n-            // since we are only visiting dataflow state on control\n-            // flow entry to the various nodes. (But we still need to\n-            // reconstruct the effect, because the visit method might\n-            // inspect it.)\n-        }\n-    }\n-\n-    // Delegated Hooks: Provide access to the MIR and process the flow state.\n-\n-    fn body(&self) -> &'a Body<'tcx>;\n-}\n-\n-/// Allows iterating dataflow results in a flexible and reasonably fast way.\n-pub struct DataflowResultsCursor<'mir, 'tcx, BD, DR = DataflowResults<'tcx, BD>>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    flow_state: FlowAtLocation<'tcx, BD, DR>,\n-\n-    // The statement (or terminator) whose effect has been reconstructed in\n-    // flow_state.\n-    curr_loc: Option<Location>,\n-\n-    body: &'mir Body<'tcx>,\n-}\n-\n-pub type DataflowResultsRefCursor<'mir, 'tcx, BD> =\n-    DataflowResultsCursor<'mir, 'tcx, BD, &'mir DataflowResults<'tcx, BD>>;\n-\n-impl<'mir, 'tcx, BD, DR> DataflowResultsCursor<'mir, 'tcx, BD, DR>\n-where\n-    BD: BitDenotation<'tcx>,\n-    DR: Borrow<DataflowResults<'tcx, BD>>,\n-{\n-    pub fn new(result: DR, body: &'mir Body<'tcx>) -> Self {\n-        DataflowResultsCursor { flow_state: FlowAtLocation::new(result), curr_loc: None, body }\n-    }\n-\n-    /// Seek to the given location in MIR. This method is fast if you are\n-    /// traversing your MIR statements in order.\n-    ///\n-    /// After calling `seek`, the current state will reflect all effects up to\n-    /// and including the `before_statement_effect` of the statement at location\n-    /// `loc`. The `statement_effect` of the statement at `loc` will be\n-    /// available as the current effect (see e.g. `each_gen_bit`).\n-    ///\n-    /// If `loc.statement_index` equals the number of statements in the block,\n-    /// we will reconstruct the terminator effect in the same way as described\n-    /// above.\n-    pub fn seek(&mut self, loc: Location) {\n-        if self.curr_loc.map(|cur| loc == cur).unwrap_or(false) {\n-            return;\n-        }\n-\n-        let start_index;\n-        let should_reset = match self.curr_loc {\n-            None => true,\n-            Some(cur) if loc.block != cur.block || loc.statement_index < cur.statement_index => {\n-                true\n-            }\n-            _ => false,\n-        };\n-        if should_reset {\n-            self.flow_state.reset_to_entry_of(loc.block);\n-            start_index = 0;\n-        } else {\n-            let curr_loc = self.curr_loc.unwrap();\n-            start_index = curr_loc.statement_index;\n-            // Apply the effect from the last seek to the current state.\n-            self.flow_state.apply_local_effect(curr_loc);\n-        }\n-\n-        for stmt in start_index..loc.statement_index {\n-            let mut stmt_loc = loc;\n-            stmt_loc.statement_index = stmt;\n-            self.flow_state.reconstruct_statement_effect(stmt_loc);\n-            self.flow_state.apply_local_effect(stmt_loc);\n-        }\n-\n-        if loc.statement_index == self.body[loc.block].statements.len() {\n-            self.flow_state.reconstruct_terminator_effect(loc);\n-        } else {\n-            self.flow_state.reconstruct_statement_effect(loc);\n-        }\n-        self.curr_loc = Some(loc);\n-    }\n-\n-    /// Return whether the current state contains bit `x`.\n-    pub fn contains(&self, x: BD::Idx) -> bool {\n-        self.flow_state.contains(x)\n-    }\n-\n-    /// Iterate over each `gen` bit in the current effect (invoke `seek` first).\n-    pub fn each_gen_bit<F>(&self, f: F)\n-    where\n-        F: FnMut(BD::Idx),\n-    {\n-        self.flow_state.each_gen_bit(f)\n-    }\n-\n-    pub fn get(&self) -> &BitSet<BD::Idx> {\n-        self.flow_state.as_dense()\n-    }\n-}\n-\n-pub struct DataflowAnalysis<'a, 'tcx, O>\n-where\n-    O: BitDenotation<'tcx>,\n-{\n-    flow_state: DataflowState<'tcx, O>,\n-    dead_unwinds: &'a BitSet<mir::BasicBlock>,\n-    body: &'a Body<'tcx>,\n-}\n-\n-impl<'a, 'tcx, O> DataflowAnalysis<'a, 'tcx, O>\n-where\n-    O: BitDenotation<'tcx>,\n-{\n-    pub fn results(self) -> DataflowResults<'tcx, O> {\n-        DataflowResults(self.flow_state)\n-    }\n-\n-    pub fn body(&self) -> &'a Body<'tcx> {\n-        self.body\n-    }\n-}\n-\n-pub struct DataflowResults<'tcx, O>(pub(crate) DataflowState<'tcx, O>)\n-where\n-    O: BitDenotation<'tcx>;\n-\n-impl<'tcx, O: BitDenotation<'tcx>> DataflowResults<'tcx, O> {\n-    pub fn sets(&self) -> &AllSets<O::Idx> {\n-        &self.0.sets\n-    }\n-\n-    pub fn operator(&self) -> &O {\n-        &self.0.operator\n-    }\n-}\n-\n-/// State of a dataflow analysis; couples a collection of bit sets\n-/// with operator used to initialize and merge bits during analysis.\n-pub struct DataflowState<'tcx, O: BitDenotation<'tcx>> {\n-    /// All the sets for the analysis. (Factored into its\n-    /// own structure so that we can borrow it mutably\n-    /// on its own separate from other fields.)\n-    pub sets: AllSets<O::Idx>,\n-\n-    /// operator used to initialize, combine, and interpret bits.\n-    pub(crate) operator: O,\n-}\n-\n-impl<'tcx, O: BitDenotation<'tcx>> DataflowState<'tcx, O> {\n-    pub(crate) fn interpret_set<'c, P>(\n-        &self,\n-        o: &'c O,\n-        set: &BitSet<O::Idx>,\n-        render_idx: &P,\n-    ) -> Vec<DebugFormatted>\n-    where\n-        P: Fn(&O, O::Idx) -> DebugFormatted,\n-    {\n-        set.iter().map(|i| render_idx(o, i)).collect()\n-    }\n-\n-    pub(crate) fn interpret_hybrid_set<'c, P>(\n-        &self,\n-        o: &'c O,\n-        set: &HybridBitSet<O::Idx>,\n-        render_idx: &P,\n-    ) -> Vec<DebugFormatted>\n-    where\n-        P: Fn(&O, O::Idx) -> DebugFormatted,\n-    {\n-        set.iter().map(|i| render_idx(o, i)).collect()\n-    }\n-}\n-\n-/// A 2-tuple representing the \"gen\" and \"kill\" bitsets during\n-/// dataflow analysis.\n-///\n-/// It is best to ensure that the intersection of `gen_set` and\n-/// `kill_set` is empty; otherwise the results of the dataflow will\n-/// have a hidden dependency on what order the bits are generated and\n-/// killed during the iteration. (This is such a good idea that the\n-/// `fn gen` and `fn kill` methods that set their state enforce this\n-/// for you.)\n-#[derive(Debug, Clone, Copy)]\n-pub struct GenKill<T> {\n-    pub(crate) gen_set: T,\n-    pub(crate) kill_set: T,\n-}\n-\n-pub type GenKillSet<T> = GenKill<HybridBitSet<T>>;\n-\n-impl<T> GenKill<T> {\n-    /// Creates a new tuple where `gen_set == kill_set == elem`.\n-    pub(crate) fn from_elem(elem: T) -> Self\n-    where\n-        T: Clone,\n-    {\n-        GenKill { gen_set: elem.clone(), kill_set: elem }\n-    }\n-}\n-\n-impl<E: Idx> GenKillSet<E> {\n-    pub fn clear(&mut self) {\n-        self.gen_set.clear();\n-        self.kill_set.clear();\n-    }\n-\n-    pub fn gen(&mut self, e: E) {\n-        self.gen_set.insert(e);\n-        self.kill_set.remove(e);\n-    }\n-\n-    pub fn gen_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n-        for j in i {\n-            self.gen(*j.borrow());\n-        }\n-    }\n-\n-    pub fn kill(&mut self, e: E) {\n-        self.gen_set.remove(e);\n-        self.kill_set.insert(e);\n-    }\n-\n-    pub fn kill_all(&mut self, i: impl IntoIterator<Item: Borrow<E>>) {\n-        for j in i {\n-            self.kill(*j.borrow());\n-        }\n-    }\n-\n-    /// Computes `(set \u222a gen) - kill` and assigns the result to `set`.\n-    pub(crate) fn apply(&self, set: &mut BitSet<E>) {\n-        set.union(&self.gen_set);\n-        set.subtract(&self.kill_set);\n-    }\n-}\n-\n-#[derive(Debug)]\n-pub struct AllSets<E: Idx> {\n-    /// Analysis bitwidth for each block.\n-    bits_per_block: usize,\n-\n-    /// For each block, bits valid on entry to the block.\n-    on_entry: Vec<BitSet<E>>,\n-\n-    /// The transfer function of each block expressed as the set of bits\n-    /// generated and killed by executing the statements + terminator in the\n-    /// block -- with one caveat. In particular, for *call terminators*, the\n-    /// effect of storing the destination is not included, since that only takes\n-    /// effect on the **success** edge (and not the unwind edge).\n-    trans: Vec<GenKillSet<E>>,\n-}\n-\n-impl<E: Idx> AllSets<E> {\n-    pub fn bits_per_block(&self) -> usize {\n-        self.bits_per_block\n-    }\n-\n-    pub fn get_mut(&mut self, block_idx: usize) -> (&mut BitSet<E>, &mut GenKillSet<E>) {\n-        (&mut self.on_entry[block_idx], &mut self.trans[block_idx])\n-    }\n-\n-    pub fn trans_for(&self, block_idx: usize) -> &GenKillSet<E> {\n-        &self.trans[block_idx]\n-    }\n-    pub fn trans_mut_for(&mut self, block_idx: usize) -> &mut GenKillSet<E> {\n-        &mut self.trans[block_idx]\n-    }\n-    pub fn entry_set_for(&self, block_idx: usize) -> &BitSet<E> {\n-        &self.on_entry[block_idx]\n-    }\n-    pub fn entry_set_mut_for(&mut self, block_idx: usize) -> &mut BitSet<E> {\n-        &mut self.on_entry[block_idx]\n-    }\n-    pub fn gen_set_for(&self, block_idx: usize) -> &HybridBitSet<E> {\n-        &self.trans_for(block_idx).gen_set\n-    }\n-    pub fn kill_set_for(&self, block_idx: usize) -> &HybridBitSet<E> {\n-        &self.trans_for(block_idx).kill_set\n-    }\n-}\n-\n-/// Parameterization for the precise form of data flow that is used.\n-///\n-/// `BottomValue` determines whether the initial entry set for each basic block is empty or full.\n-/// This also determines the semantics of the lattice `join` operator used to merge dataflow\n-/// results, since dataflow works by starting at the bottom and moving monotonically to a fixed\n-/// point.\n-///\n-/// This means, for propagation across the graph, that you either want to start at all-zeroes and\n-/// then use Union as your merge when propagating, or you start at all-ones and then use Intersect\n-/// as your merge when propagating.\n-pub trait BottomValue {\n-    /// Specifies the initial value for each bit in the entry set for each basic block.\n-    const BOTTOM_VALUE: bool;\n-\n-    /// Merges `in_set` into `inout_set`, returning `true` if `inout_set` changed.\n-    ///\n-    /// It is almost certainly wrong to override this, since it automatically applies\n-    /// * `inout_set & in_set` if `BOTTOM_VALUE == true`\n-    /// * `inout_set | in_set` if `BOTTOM_VALUE == false`\n-    ///\n-    /// This means that if a bit is not `BOTTOM_VALUE`, it is propagated into all target blocks.\n-    /// For clarity, the above statement again from a different perspective:\n-    /// A bit in the block's entry set is `!BOTTOM_VALUE` if *any* predecessor block's bit value is\n-    /// `!BOTTOM_VALUE`.\n-    ///\n-    /// There are situations where you want the opposite behaviour: propagate only if *all*\n-    /// predecessor blocks's value is `!BOTTOM_VALUE`.\n-    /// E.g. if you want to know whether a bit is *definitely* set at a specific location. This\n-    /// means that all code paths leading to the location must have set the bit, instead of any\n-    /// code path leading there.\n-    ///\n-    /// If you want this kind of \"definitely set\" analysis, you need to\n-    /// 1. Invert `BOTTOM_VALUE`\n-    /// 2. Reset the `entry_set` in `start_block_effect` to `!BOTTOM_VALUE`\n-    /// 3. Override `join` to do the opposite from what it's doing now.\n-    #[inline]\n-    fn join<T: Idx>(&self, inout_set: &mut BitSet<T>, in_set: &BitSet<T>) -> bool {\n-        if !Self::BOTTOM_VALUE { inout_set.union(in_set) } else { inout_set.intersect(in_set) }\n-    }\n-}\n-\n-/// A specific flavor of dataflow analysis.\n-///\n-/// To run a dataflow analysis, one sets up an initial state for the\n-/// `START_BLOCK` via `start_block_effect` and a transfer function (`trans`)\n-/// for each block individually. The entry set for all other basic blocks is\n-/// initialized to `Self::BOTTOM_VALUE`. The dataflow analysis then\n-/// iteratively modifies the various entry sets (but leaves the the transfer\n-/// function unchanged). `BottomValue::join` is used to merge the bitsets from\n-/// two blocks (e.g. when two blocks' terminator jumps to a single block, that\n-/// target block's state is the merged state of both incoming blocks).\n-pub trait BitDenotation<'tcx>: BottomValue {\n-    /// Specifies what index type is used to access the bitvector.\n-    type Idx: Idx;\n-\n-    /// A name describing the dataflow analysis that this\n-    /// `BitDenotation` is supporting. The name should be something\n-    /// suitable for plugging in as part of a filename (i.e., avoid\n-    /// space-characters or other things that tend to look bad on a\n-    /// file system, like slashes or periods). It is also better for\n-    /// the name to be reasonably short, again because it will be\n-    /// plugged into a filename.\n-    fn name() -> &'static str;\n-\n-    /// Size of each bitvector allocated for each block in the analysis.\n-    fn bits_per_block(&self) -> usize;\n-\n-    /// Mutates the entry set according to the effects that\n-    /// have been established *prior* to entering the start\n-    /// block. This can't access the gen/kill sets, because\n-    /// these won't be accounted for correctly.\n-    ///\n-    /// (For example, establishing the call arguments.)\n-    fn start_block_effect(&self, entry_set: &mut BitSet<Self::Idx>);\n-\n-    /// Similar to `statement_effect`, except it applies\n-    /// *just before* the statement rather than *just after* it.\n-    ///\n-    /// This matters for \"dataflow at location\" APIs, because the\n-    /// before-statement effect is visible while visiting the\n-    /// statement, while the after-statement effect only becomes\n-    /// visible at the next statement.\n-    ///\n-    /// Both the before-statement and after-statement effects are\n-    /// applied, in that order, before moving for the next\n-    /// statement.\n-    fn before_statement_effect(&self, _trans: &mut GenKillSet<Self::Idx>, _location: Location) {}\n-\n-    /// Mutates the block-sets (the flow sets for the given\n-    /// basic block) according to the effects of evaluating statement.\n-    ///\n-    /// This is used, in particular, for building up the\n-    /// \"transfer-function\" representing the overall-effect of the\n-    /// block, represented via GEN and KILL sets.\n-    ///\n-    /// The statement is identified as `bb_data[idx_stmt]`, where\n-    /// `bb_data` is the sequence of statements identified by `bb` in\n-    /// the MIR.\n-    fn statement_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location);\n-\n-    /// Similar to `terminator_effect`, except it applies\n-    /// *just before* the terminator rather than *just after* it.\n-    ///\n-    /// This matters for \"dataflow at location\" APIs, because the\n-    /// before-terminator effect is visible while visiting the\n-    /// terminator, while the after-terminator effect only becomes\n-    /// visible at the terminator's successors.\n-    ///\n-    /// Both the before-terminator and after-terminator effects are\n-    /// applied, in that order, before moving for the next\n-    /// terminator.\n-    fn before_terminator_effect(&self, _trans: &mut GenKillSet<Self::Idx>, _location: Location) {}\n-\n-    /// Mutates the block-sets (the flow sets for the given\n-    /// basic block) according to the effects of evaluating\n-    /// the terminator.\n-    ///\n-    /// This is used, in particular, for building up the\n-    /// \"transfer-function\" representing the overall-effect of the\n-    /// block, represented via GEN and KILL sets.\n-    ///\n-    /// The effects applied here cannot depend on which branch the\n-    /// terminator took.\n-    fn terminator_effect(&self, trans: &mut GenKillSet<Self::Idx>, location: Location);\n-\n-    /// Mutates the block-sets according to the (flow-dependent)\n-    /// effect of a successful return from a Call terminator.\n-    ///\n-    /// If basic-block BB_x ends with a call-instruction that, upon\n-    /// successful return, flows to BB_y, then this method will be\n-    /// called on the exit flow-state of BB_x in order to set up the\n-    /// entry flow-state of BB_y.\n-    ///\n-    /// This is used, in particular, as a special case during the\n-    /// \"propagate\" loop where all of the basic blocks are repeatedly\n-    /// visited. Since the effects of a Call terminator are\n-    /// flow-dependent, the current MIR cannot encode them via just\n-    /// GEN and KILL sets attached to the block, and so instead we add\n-    /// this extra machinery to represent the flow-dependent effect.\n-    //\n-    // FIXME: right now this is a bit of a wart in the API. It might\n-    // be better to represent this as an additional gen- and\n-    // kill-sets associated with each edge coming out of the basic\n-    // block.\n-    fn propagate_call_return(\n-        &self,\n-        in_out: &mut BitSet<Self::Idx>,\n-        call_bb: mir::BasicBlock,\n-        dest_bb: mir::BasicBlock,\n-        dest_place: &mir::Place<'tcx>,\n-    );\n-}\n-\n-impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D>\n-where\n-    D: BitDenotation<'tcx>,\n-{\n-    pub fn new(\n-        body: &'a Body<'tcx>,\n-        dead_unwinds: &'a BitSet<mir::BasicBlock>,\n-        denotation: D,\n-    ) -> Self {\n-        let bits_per_block = denotation.bits_per_block();\n-        let num_blocks = body.basic_blocks().len();\n-\n-        let on_entry = if D::BOTTOM_VALUE {\n-            vec![BitSet::new_filled(bits_per_block); num_blocks]\n-        } else {\n-            vec![BitSet::new_empty(bits_per_block); num_blocks]\n-        };\n-        let nop = GenKill::from_elem(HybridBitSet::new_empty(bits_per_block));\n-\n-        DataflowAnalysis {\n-            body,\n-            dead_unwinds,\n-            flow_state: DataflowState {\n-                sets: AllSets { bits_per_block, on_entry, trans: vec![nop; num_blocks] },\n-                operator: denotation,\n-            },\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx, D> DataflowAnalysis<'a, 'tcx, D>\n-where\n-    D: BitDenotation<'tcx>,\n-{\n-    /// Propagates the bits of `in_out` into all the successors of `bb`,\n-    /// using bitwise operator denoted by `self.operator`.\n-    ///\n-    /// For most blocks, this is entirely uniform. However, for blocks\n-    /// that end with a call terminator, the effect of the call on the\n-    /// dataflow state may depend on whether the call returned\n-    /// successfully or unwound.\n-    ///\n-    /// To reflect this, the `propagate_call_return` method of the\n-    /// `BitDenotation` mutates `in_out` when propagating `in_out` via\n-    /// a call terminator; such mutation is performed *last*, to\n-    /// ensure its side-effects do not leak elsewhere (e.g., into\n-    /// unwind target).\n-    fn propagate_bits_into_graph_successors_of(\n-        &mut self,\n-        in_out: &mut BitSet<D::Idx>,\n-        (bb, bb_data): (mir::BasicBlock, &mir::BasicBlockData<'tcx>),\n-        dirty_list: &mut WorkQueue<mir::BasicBlock>,\n-    ) {\n-        match bb_data.terminator().kind {\n-            mir::TerminatorKind::Return\n-            | mir::TerminatorKind::Resume\n-            | mir::TerminatorKind::Abort\n-            | mir::TerminatorKind::GeneratorDrop\n-            | mir::TerminatorKind::Unreachable => {}\n-            mir::TerminatorKind::Goto { target }\n-            | mir::TerminatorKind::Assert { target, cleanup: None, .. }\n-            | mir::TerminatorKind::Yield { resume: target, drop: None, .. }\n-            | mir::TerminatorKind::Drop { target, location: _, unwind: None }\n-            | mir::TerminatorKind::DropAndReplace { target, value: _, location: _, unwind: None } =>\n-            {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-            }\n-            mir::TerminatorKind::Yield { resume: target, drop: Some(drop), .. } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, drop, dirty_list);\n-            }\n-            mir::TerminatorKind::Assert { target, cleanup: Some(unwind), .. }\n-            | mir::TerminatorKind::Drop { target, location: _, unwind: Some(unwind) }\n-            | mir::TerminatorKind::DropAndReplace {\n-                target,\n-                value: _,\n-                location: _,\n-                unwind: Some(unwind),\n-            } => {\n-                self.propagate_bits_into_entry_set_for(in_out, target, dirty_list);\n-                if !self.dead_unwinds.contains(bb) {\n-                    self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                }\n-            }\n-            mir::TerminatorKind::SwitchInt { ref targets, .. } => {\n-                for target in targets {\n-                    self.propagate_bits_into_entry_set_for(in_out, *target, dirty_list);\n-                }\n-            }\n-            mir::TerminatorKind::Call { cleanup, ref destination, .. } => {\n-                if let Some(unwind) = cleanup {\n-                    if !self.dead_unwinds.contains(bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-                if let Some((ref dest_place, dest_bb)) = *destination {\n-                    // N.B.: This must be done *last*, after all other\n-                    // propagation, as documented in comment above.\n-                    self.flow_state.operator.propagate_call_return(in_out, bb, dest_bb, dest_place);\n-                    self.propagate_bits_into_entry_set_for(in_out, dest_bb, dirty_list);\n-                }\n-            }\n-            mir::TerminatorKind::FalseEdges { real_target, imaginary_target } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                self.propagate_bits_into_entry_set_for(in_out, imaginary_target, dirty_list);\n-            }\n-            mir::TerminatorKind::FalseUnwind { real_target, unwind } => {\n-                self.propagate_bits_into_entry_set_for(in_out, real_target, dirty_list);\n-                if let Some(unwind) = unwind {\n-                    if !self.dead_unwinds.contains(bb) {\n-                        self.propagate_bits_into_entry_set_for(in_out, unwind, dirty_list);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn propagate_bits_into_entry_set_for(\n-        &mut self,\n-        in_out: &BitSet<D::Idx>,\n-        bb: mir::BasicBlock,\n-        dirty_queue: &mut WorkQueue<mir::BasicBlock>,\n-    ) {\n-        let entry_set = self.flow_state.sets.entry_set_mut_for(bb.index());\n-        let set_changed = self.flow_state.operator.join(entry_set, &in_out);\n-        if set_changed {\n-            dirty_queue.insert(bb);\n-        }\n-    }\n-}"}, {"sha": "5f761ce344880baec15db92e3a2164d1ec1f6b15", "filename": "src/librustc_mir/transform/check_consts/resolver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fresolver.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -9,7 +9,7 @@ use rustc_index::bit_set::BitSet;\n use std::marker::PhantomData;\n \n use super::{qualifs, Item, Qualif};\n-use crate::dataflow::{self as old_dataflow, generic as dataflow};\n+use crate::dataflow;\n \n /// A `Visitor` that propagates qualifs between locals. This defines the transfer function of\n /// `FlowSensitiveAnalysis`.\n@@ -165,7 +165,7 @@ where\n     }\n }\n \n-impl<Q> old_dataflow::BottomValue for FlowSensitiveAnalysis<'_, '_, '_, Q> {\n+impl<Q> dataflow::BottomValue for FlowSensitiveAnalysis<'_, '_, '_, Q> {\n     const BOTTOM_VALUE: bool = false;\n }\n "}, {"sha": "7f4714e9f9c1999e2276ba5c4a6747db92ab69bd", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -22,8 +22,8 @@ use super::qualifs::{self, HasMutInterior, NeedsDrop};\n use super::resolver::FlowSensitiveAnalysis;\n use super::{is_lang_panic_fn, ConstKind, Item, Qualif};\n use crate::const_eval::{is_const_fn, is_unstable_const_fn};\n-use crate::dataflow::generic::{self as dataflow, Analysis};\n use crate::dataflow::MaybeMutBorrowedLocals;\n+use crate::dataflow::{self, Analysis};\n \n // We are using `MaybeMutBorrowedLocals` as a proxy for whether an item may have been mutated\n // through a pointer prior to the given point. This is okay even though `MaybeMutBorrowedLocals`"}, {"sha": "4ec4ef0206105c82e0eee6f372f3273c01946546", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1,9 +1,9 @@\n use crate::dataflow;\n-use crate::dataflow::generic::{Analysis, ResultsCursor};\n use crate::dataflow::move_paths::{LookupResult, MoveData, MovePathIndex};\n use crate::dataflow::on_lookup_result_bits;\n use crate::dataflow::MoveDataParamEnv;\n use crate::dataflow::{on_all_children_bits, on_all_drop_children_bits};\n+use crate::dataflow::{Analysis, ResultsCursor};\n use crate::dataflow::{MaybeInitializedPlaces, MaybeUninitializedPlaces};\n use crate::transform::{MirPass, MirSource};\n use crate::util::elaborate_drops::{elaborate_drop, DropFlagState, Unwind};"}, {"sha": "1945efb6bf7ccf8f9b3d78c418c8a69a494942bb", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -49,7 +49,7 @@\n //! For generators with state 1 (returned) and state 2 (poisoned) it does nothing.\n //! Otherwise it drops all the values in scope at the last suspension point.\n \n-use crate::dataflow::generic::{self as dataflow, Analysis};\n+use crate::dataflow::{self, Analysis};\n use crate::dataflow::{MaybeBorrowedLocals, MaybeRequiresStorage, MaybeStorageLive};\n use crate::transform::no_landing_pads::no_landing_pads;\n use crate::transform::simplify;"}, {"sha": "c9a00166f0f9c9b61f757d6ae974552fd2ef6c1b", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -9,11 +9,11 @@ use rustc::ty::{self, Ty, TyCtxt};\n use rustc_hir::def_id::DefId;\n use rustc_index::bit_set::BitSet;\n \n-use crate::dataflow::generic::{Analysis, Results, ResultsCursor};\n use crate::dataflow::move_paths::{HasMoveData, MoveData};\n use crate::dataflow::move_paths::{LookupResult, MovePathIndex};\n use crate::dataflow::MaybeMutBorrowedLocals;\n use crate::dataflow::MoveDataParamEnv;\n+use crate::dataflow::{Analysis, Results, ResultsCursor};\n use crate::dataflow::{\n     DefinitelyInitializedPlaces, MaybeInitializedPlaces, MaybeUninitializedPlaces,\n };"}, {"sha": "e729c2d517feaeae4c9289e867be816fa508159f", "filename": "src/librustc_passes/liveness.rs", "status": "modified", "additions": 4, "deletions": 14, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_passes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_passes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fliveness.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -903,10 +903,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn compute(&mut self, body: &hir::Expr<'_>) -> LiveNode {\n-        debug!(\n-            \"compute: using id for body, {}\",\n-            self.ir.tcx.hir().hir_to_pretty_string(body.hir_id)\n-        );\n+        debug!(\"compute: using id for body, {:?}\", body);\n \n         // the fallthrough exit is only for those cases where we do not\n         // explicitly return:\n@@ -979,7 +976,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn propagate_through_expr(&mut self, expr: &Expr<'_>, succ: LiveNode) -> LiveNode {\n-        debug!(\"propagate_through_expr: {}\", self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id));\n+        debug!(\"propagate_through_expr: {:?}\", expr);\n \n         match expr.kind {\n             // Interesting cases with control flow or which gen/kill\n@@ -990,10 +987,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             hir::ExprKind::Field(ref e, _) => self.propagate_through_expr(&e, succ),\n \n             hir::ExprKind::Closure(..) => {\n-                debug!(\n-                    \"{} is an ExprKind::Closure\",\n-                    self.ir.tcx.hir().hir_to_pretty_string(expr.hir_id)\n-                );\n+                debug!(\"{:?} is an ExprKind::Closure\", expr);\n \n                 // the construction of a closure itself is not important,\n                 // but we have to consider the closed over variables.\n@@ -1344,11 +1338,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n         let mut first_merge = true;\n         let ln = self.live_node(expr.hir_id, expr.span);\n         self.init_empty(ln, succ);\n-        debug!(\n-            \"propagate_through_loop: using id for loop body {} {}\",\n-            expr.hir_id,\n-            self.ir.tcx.hir().hir_to_pretty_string(body.hir_id)\n-        );\n+        debug!(\"propagate_through_loop: using id for loop body {} {:?}\", expr.hir_id, body);\n \n         self.break_ln.insert(expr.hir_id, succ);\n "}, {"sha": "0df1d08cbd8bdd382e9f326e5712304b308388d2", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1320,14 +1320,18 @@ impl<'a, 'tcx> Visitor<'tcx> for TypePrivacyVisitor<'a, 'tcx> {\n             let is_local_static =\n                 if let DefKind::Static = kind { def_id.is_local() } else { false };\n             if !self.item_is_accessible(def_id) && !is_local_static {\n-                let name = match *qpath {\n-                    hir::QPath::Resolved(_, ref path) => path.to_string(),\n-                    hir::QPath::TypeRelative(_, ref segment) => segment.ident.to_string(),\n+                let sess = self.tcx.sess;\n+                let sm = sess.source_map();\n+                let name = match qpath {\n+                    hir::QPath::Resolved(_, path) => sm.span_to_snippet(path.span).ok(),\n+                    hir::QPath::TypeRelative(_, segment) => Some(segment.ident.to_string()),\n                 };\n                 let kind = kind.descr(def_id);\n-                self.tcx\n-                    .sess\n-                    .struct_span_err(span, &format!(\"{} `{}` is private\", kind, name))\n+                let msg = match name {\n+                    Some(name) => format!(\"{} `{}` is private\", kind, name),\n+                    None => format!(\"{} is private\", kind),\n+                };\n+                sess.struct_span_err(span, &msg)\n                     .span_label(span, &format!(\"private {}\", kind))\n                     .emit();\n                 return;"}, {"sha": "623da1ddcb4258971df6d12bfa6f2a012e173151", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -11,13 +11,14 @@ path = \"lib.rs\"\n [dependencies]\n log = \"0.4\"\n rustc = { path = \"../librustc\" }\n+rustc_ast = { path = \"../librustc_ast\" }\n rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n-rustc_session = { path = \"../librustc_session\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n rustc_parse = { path = \"../librustc_parse\" }\n serde_json = \"1\"\n-rustc_ast = { path = \"../librustc_ast\" }\n+rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }\n rls-data = \"0.19\"\n rls-span = \"0.5\""}, {"sha": "21551eeddb927b3a05554f3f7a2485f87d461bdb", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -404,14 +404,15 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n             Some(impl_id) => match self.tcx.hir().get_if_local(impl_id) {\n                 Some(Node::Item(item)) => match item.kind {\n                     hir::ItemKind::Impl { ref self_ty, .. } => {\n+                        let hir = self.tcx.hir();\n+\n                         let mut qualname = String::from(\"<\");\n-                        qualname.push_str(&self.tcx.hir().hir_to_pretty_string(self_ty.hir_id));\n+                        qualname.push_str(&rustc_hir_pretty::id_to_string(&hir, self_ty.hir_id));\n \n                         let trait_id = self.tcx.trait_id_of_impl(impl_id);\n                         let mut docs = String::new();\n                         let mut attrs = vec![];\n-                        let hir_id = self.tcx.hir().node_to_hir_id(id);\n-                        if let Some(Node::ImplItem(item)) = self.tcx.hir().find(hir_id) {\n+                        if let Some(Node::ImplItem(item)) = hir.find(hir.node_to_hir_id(id)) {\n                             docs = self.docs_for_attrs(&item.attrs);\n                             attrs = item.attrs.to_vec();\n                         }"}, {"sha": "8cbed43cac01df032112a10ae05c571cba69f30d", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1581,7 +1581,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 for param in generics.params {\n                     if param.span == *span\n                         && !param.bounds.iter().any(|bound| {\n-                            bound.trait_def_id() == self.tcx.lang_items().sized_trait()\n+                            bound.trait_ref().and_then(|trait_ref| trait_ref.trait_def_id())\n+                                == self.tcx.lang_items().sized_trait()\n                         })\n                     {\n                         let (span, separator) = match param.bounds {"}, {"sha": "7d4ad61902a926f923f92621b0ebeb77a3b8efad", "filename": "src/librustc_trait_selection/traits/object_safety.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fobject_safety.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -15,7 +15,7 @@ use crate::traits::query::evaluate_obligation::InferCtxtExt;\n use crate::traits::{self, Obligation, ObligationCause};\n use rustc::ty::subst::{InternalSubsts, Subst};\n use rustc::ty::{self, Predicate, ToPredicate, Ty, TyCtxt, TypeFoldable, WithConstness};\n-use rustc_errors::Applicability;\n+use rustc_errors::{Applicability, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_session::lint::builtin::WHERE_CLAUSES_OBJECT_SAFETY;\n@@ -170,6 +170,24 @@ fn object_safety_violations_for_trait(\n     violations\n }\n \n+fn sized_trait_bound_spans<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    bounds: hir::GenericBounds<'tcx>,\n+) -> impl 'tcx + Iterator<Item = Span> {\n+    bounds.iter().filter_map(move |b| match b {\n+        hir::GenericBound::Trait(trait_ref, hir::TraitBoundModifier::None)\n+            if trait_has_sized_self(\n+                tcx,\n+                trait_ref.trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise()),\n+            ) =>\n+        {\n+            // Fetch spans for supertraits that are `Sized`: `trait T: Super`\n+            Some(trait_ref.span)\n+        }\n+        _ => None,\n+    })\n+}\n+\n fn get_sized_bounds(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span; 1]> {\n     tcx.hir()\n         .get_if_local(trait_def_id)\n@@ -189,33 +207,14 @@ fn get_sized_bounds(tcx: TyCtxt<'_>, trait_def_id: DefId) -> SmallVec<[Span; 1]>\n                             {\n                                 // Fetch spans for trait bounds that are Sized:\n                                 // `trait T where Self: Pred`\n-                                Some(pred.bounds.iter().filter_map(|b| match b {\n-                                    hir::GenericBound::Trait(\n-                                        trait_ref,\n-                                        hir::TraitBoundModifier::None,\n-                                    ) if trait_has_sized_self(\n-                                        tcx,\n-                                        trait_ref.trait_ref.trait_def_id(),\n-                                    ) =>\n-                                    {\n-                                        Some(trait_ref.span)\n-                                    }\n-                                    _ => None,\n-                                }))\n+                                Some(sized_trait_bound_spans(tcx, pred.bounds))\n                             }\n                             _ => None,\n                         }\n                     })\n                     .flatten()\n-                    .chain(bounds.iter().filter_map(|b| match b {\n-                        hir::GenericBound::Trait(trait_ref, hir::TraitBoundModifier::None)\n-                            if trait_has_sized_self(tcx, trait_ref.trait_ref.trait_def_id()) =>\n-                        {\n-                            // Fetch spans for supertraits that are `Sized`: `trait T: Super`\n-                            Some(trait_ref.span)\n-                        }\n-                        _ => None,\n-                    }))\n+                    // Fetch spans for supertraits that are `Sized`: `trait T: Super`.\n+                    .chain(sized_trait_bound_spans(tcx, bounds))\n                     .collect::<SmallVec<[Span; 1]>>(),\n             ),\n             _ => None,"}, {"sha": "07630d7969e81178839b5c7efa597cc53c5b073b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -16,12 +16,11 @@ use rustc::ty::{GenericParamDef, GenericParamDefKind};\n use rustc_ast::ast;\n use rustc_ast::util::lev_distance::find_best_match_for_name;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, DiagnosticId, FatalError};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::DefId;\n-use rustc_hir::intravisit::{walk_generics, Visitor};\n-use rustc_hir::print;\n+use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{Constness, GenericArg, GenericArgs};\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, LATE_BOUND_LIFETIME_ARGUMENTS};\n use rustc_session::parse::feature_err;\n@@ -991,7 +990,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         self.ast_path_to_mono_trait_ref(\n             trait_ref.path.span,\n-            trait_ref.trait_def_id(),\n+            trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise()),\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n         )\n@@ -1007,7 +1006,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         bounds: &mut Bounds<'tcx>,\n         speculative: bool,\n     ) -> Result<(), GenericArgCountMismatch> {\n-        let trait_def_id = trait_ref.trait_def_id();\n+        let trait_def_id = trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise());\n \n         debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n \n@@ -1118,6 +1117,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         if !self.tcx().features().unboxed_closures\n             && trait_segment.generic_args().parenthesized != trait_def.paren_sugar\n         {\n+            let sess = &self.tcx().sess.parse_sess;\n             // For now, require that parenthetical notation be used only with `Fn()` etc.\n             let (msg, sugg) = if trait_def.paren_sugar {\n                 (\n@@ -1132,7 +1132,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             .and_then(|args| args.args.get(0))\n                             .and_then(|arg| match arg {\n                                 hir::GenericArg::Type(ty) => {\n-                                    Some(print::to_string(print::NO_ANN, |s| s.print_type(ty)))\n+                                    sess.source_map().span_to_snippet(ty.span).ok()\n                                 }\n                                 _ => None,\n                             })\n@@ -1143,7 +1143,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                             .iter()\n                             .filter_map(|b| match (b.ident.as_str() == \"Output\", &b.kind) {\n                                 (true, hir::TypeBindingKind::Equality { ty }) => {\n-                                    Some(print::to_string(print::NO_ANN, |s| s.print_type(ty)))\n+                                    sess.source_map().span_to_snippet(ty.span).ok()\n                                 }\n                                 _ => None,\n                             })\n@@ -1154,7 +1154,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             } else {\n                 (\"parenthetical notation is only stable when used with `Fn`-family traits\", None)\n             };\n-            let sess = &self.tcx().sess.parse_sess;\n             let mut err = feature_err(sess, sym::unboxed_closures, span, msg);\n             if let Some(sugg) = sugg {\n                 let msg = \"use parenthetical notation instead\";"}, {"sha": "b44bab2675d37562f99b9ce244ca0ccbdc31ec81", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -245,11 +245,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             {\n                 // check that the `if` expr without `else` is the fn body's expr\n                 if expr.span == span {\n-                    return self.get_fn_decl(hir_id).map(|(fn_decl, _)| {\n-                        (\n-                            fn_decl.output.span(),\n-                            format!(\"expected `{}` because of this return type\", fn_decl.output),\n-                        )\n+                    return self.get_fn_decl(hir_id).and_then(|(fn_decl, _)| {\n+                        let span = fn_decl.output.span();\n+                        let snippet = self.tcx.sess.source_map().span_to_snippet(span).ok()?;\n+                        Some((span, format!(\"expected `{}` because of this return type\", snippet)))\n                     });\n                 }\n             }"}, {"sha": "074951684ef06c2ffc633f27463dc4293ed80841", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -265,7 +265,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 if let &ty::Adt(adt_def, ..) = t {\n                     if adt_def.is_enum() {\n                         if let hir::ExprKind::Call(ref expr, _) = call_expr.kind {\n-                            unit_variant = Some(self.tcx.hir().hir_to_pretty_string(expr.hir_id))\n+                            unit_variant =\n+                                self.tcx.sess.source_map().span_to_snippet(expr.span).ok();\n                         }\n                     }\n                 }\n@@ -335,16 +336,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     err.span_label(call_expr.span, \"call expression requires function\");\n \n                     if let Some(span) = self.tcx.hir().res_span(def) {\n+                        let callee_ty = callee_ty.to_string();\n                         let label = match (unit_variant, inner_callee_path) {\n-                            (Some(path), _) => format!(\"`{}` defined here\", path),\n-                            (_, Some(hir::QPath::Resolved(_, path))) => format!(\n-                                \"`{}` defined here returns `{}`\",\n-                                path,\n-                                callee_ty.to_string()\n-                            ),\n-                            _ => format!(\"`{}` defined here\", callee_ty.to_string()),\n+                            (Some(path), _) => Some(format!(\"`{}` defined here\", path)),\n+                            (_, Some(hir::QPath::Resolved(_, path))) => {\n+                                self.tcx.sess.source_map().span_to_snippet(path.span).ok().map(\n+                                    |p| format!(\"`{}` defined here returns `{}`\", p, callee_ty),\n+                                )\n+                            }\n+                            _ => Some(format!(\"`{}` defined here\", callee_ty)),\n                         };\n-                        err.span_label(span, label);\n+                        if let Some(label) = label {\n+                            err.span_label(span, label);\n+                        }\n                     }\n                     err.emit();\n                 } else {"}, {"sha": "2dc2a48ecbce82f2fdfae9d657ad761d5fe2503b", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1402,9 +1402,12 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                     {\n                         // Are of this `impl Trait`'s traits object safe?\n                         is_object_safe = bounds.iter().all(|bound| {\n-                            bound.trait_def_id().map_or(false, |def_id| {\n-                                fcx.tcx.object_safety_violations(def_id).is_empty()\n-                            })\n+                            bound\n+                                .trait_ref()\n+                                .and_then(|t| t.trait_def_id())\n+                                .map_or(false, |def_id| {\n+                                    fcx.tcx.object_safety_violations(def_id).is_empty()\n+                                })\n                         })\n                     }\n                 }"}, {"sha": "f7ffb5a2218baa75d36c2fe533b0c1f14e3c8ee0", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -9,7 +9,7 @@ use rustc::ty::{self, AssocItem, Ty};\n use rustc_ast::util::parser::PREC_POSTFIX;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n-use rustc_hir::{is_range_literal, print, Node};\n+use rustc_hir::{is_range_literal, Node};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n \n@@ -198,13 +198,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 .peekable();\n \n             if compatible_variants.peek().is_some() {\n-                let expr_text =\n-                    self.tcx.sess.source_map().span_to_snippet(expr.span).unwrap_or_else(|_| {\n-                        print::to_string(print::NO_ANN, |s| s.print_expr(expr))\n-                    });\n-                let suggestions = compatible_variants.map(|v| format!(\"{}({})\", v, expr_text));\n-                let msg = \"try using a variant of the expected enum\";\n-                err.span_suggestions(expr.span, msg, suggestions, Applicability::MaybeIncorrect);\n+                if let Ok(expr_text) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n+                    let suggestions = compatible_variants.map(|v| format!(\"{}({})\", v, expr_text));\n+                    let msg = \"try using a variant of the expected enum\";\n+                    err.span_suggestions(\n+                        expr.span,\n+                        msg,\n+                        suggestions,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n             }\n         }\n     }"}, {"sha": "53a20d9e867888fe63ec3d556e5f0059b393ba15", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 23, "deletions": 28, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -475,7 +475,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tcx.types.err\n             }\n             Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _) => {\n-                report_unexpected_variant_res(tcx, res, expr.span, qpath);\n+                report_unexpected_variant_res(tcx, res, expr.span);\n                 tcx.types.err\n             }\n             _ => self.instantiate_value_path(segs, opt_ty, res, expr.span, expr.hir_id).0,\n@@ -696,10 +696,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self,\n                     &cause,\n                     &mut |db| {\n-                        db.span_label(\n-                            fn_decl.output.span(),\n-                            format!(\"expected `{}` because of this return type\", fn_decl.output,),\n-                        );\n+                        let span = fn_decl.output.span();\n+                        if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n+                            db.span_label(\n+                                span,\n+                                format!(\"expected `{}` because of this return type\", snippet),\n+                            );\n+                        }\n                     },\n                     true,\n                 );\n@@ -1668,20 +1671,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let (Some(len), Ok(user_index)) =\n             (len.try_eval_usize(self.tcx, self.param_env), field.as_str().parse::<u64>())\n         {\n-            let base = self\n-                .tcx\n-                .sess\n-                .source_map()\n-                .span_to_snippet(base.span)\n-                .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-            let help = \"instead of using tuple indexing, use array indexing\";\n-            let suggestion = format!(\"{}[{}]\", base, field);\n-            let applicability = if len < user_index {\n-                Applicability::MachineApplicable\n-            } else {\n-                Applicability::MaybeIncorrect\n-            };\n-            err.span_suggestion(expr.span, help, suggestion, applicability);\n+            if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n+                let help = \"instead of using tuple indexing, use array indexing\";\n+                let suggestion = format!(\"{}[{}]\", base, field);\n+                let applicability = if len < user_index {\n+                    Applicability::MachineApplicable\n+                } else {\n+                    Applicability::MaybeIncorrect\n+                };\n+                err.span_suggestion(expr.span, help, suggestion, applicability);\n+            }\n         }\n     }\n \n@@ -1692,15 +1691,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         base: &hir::Expr<'_>,\n         field: ast::Ident,\n     ) {\n-        let base = self\n-            .tcx\n-            .sess\n-            .source_map()\n-            .span_to_snippet(base.span)\n-            .unwrap_or_else(|_| self.tcx.hir().hir_to_pretty_string(base.hir_id));\n-        let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n-        let suggestion = format!(\"(*{}).{}\", base, field);\n-        err.span_suggestion(expr.span, &msg, suggestion, Applicability::MaybeIncorrect);\n+        if let Ok(base) = self.tcx.sess.source_map().span_to_snippet(base.span) {\n+            let msg = format!(\"`{}` is a raw pointer; try dereferencing it\", base);\n+            let suggestion = format!(\"(*{}).{}\", base, field);\n+            err.span_suggestion(expr.span, &msg, suggestion, Applicability::MaybeIncorrect);\n+        }\n     }\n \n     fn no_such_field_err<T: Display>("}, {"sha": "688820029febc95a49e3496ba1bbf6aad898d05a", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1061,7 +1061,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let trait_def_ids: FxHashSet<DefId> = param\n                                     .bounds\n                                     .iter()\n-                                    .filter_map(|bound| bound.trait_def_id())\n+                                    .filter_map(|bound| Some(bound.trait_ref()?.trait_def_id()?))\n                                     .collect();\n                                 if !candidates.iter().any(|t| trait_def_ids.contains(&t.def_id)) {\n                                     err.span_suggestions("}, {"sha": "f188ee0a13c3d2197551d9d02f316fb142219f0c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -2677,14 +2677,14 @@ pub fn check_enum<'tcx>(\n     check_transparent(tcx, sp, def_id);\n }\n \n-fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span, qpath: &QPath<'_>) {\n+fn report_unexpected_variant_res(tcx: TyCtxt<'_>, res: Res, span: Span) {\n     struct_span_err!(\n         tcx.sess,\n         span,\n         E0533,\n-        \"expected unit struct, unit variant or constant, found {} `{}`\",\n+        \"expected unit struct, unit variant or constant, found {}{}\",\n         res.descr(),\n-        hir::print::to_string(&tcx.hir(), |s| s.print_qpath(qpath, false))\n+        tcx.sess.source_map().span_to_snippet(span).map_or(String::new(), |s| format!(\" `{}`\", s)),\n     )\n     .emit();\n }"}, {"sha": "657926a1825fa307ecc058b2321ff4f22001f040", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -492,36 +492,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         err.span_label(span, ty.to_string());\n         if let FnDef(def_id, _) = ty.kind {\n             let source_map = self.tcx.sess.source_map();\n-            let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n-                Some(hir_id) => hir_id,\n-                None => return false,\n-            };\n             if !self.tcx.has_typeck_tables(def_id) {\n                 return false;\n             }\n-            let fn_sig = {\n-                match self.tcx.typeck_tables_of(def_id).liberated_fn_sigs().get(hir_id) {\n-                    Some(f) => *f,\n-                    None => {\n-                        bug!(\"No fn-sig entry for def_id={:?}\", def_id);\n-                    }\n-                }\n-            };\n+            // We're emitting a suggestion, so we can just ignore regions\n+            let fn_sig = *self.tcx.fn_sig(def_id).skip_binder();\n \n             let other_ty = if let FnDef(def_id, _) = other_ty.kind {\n-                let hir_id = match self.tcx.hir().as_local_hir_id(def_id) {\n-                    Some(hir_id) => hir_id,\n-                    None => return false,\n-                };\n                 if !self.tcx.has_typeck_tables(def_id) {\n                     return false;\n                 }\n-                match self.tcx.typeck_tables_of(def_id).liberated_fn_sigs().get(hir_id) {\n-                    Some(f) => f.clone().output(),\n-                    None => {\n-                        bug!(\"No fn-sig entry for def_id={:?}\", def_id);\n-                    }\n-                }\n+                // We're emitting a suggestion, so we can just ignore regions\n+                self.tcx.fn_sig(def_id).skip_binder().output()\n             } else {\n                 other_ty\n             };"}, {"sha": "ec703d5ec9e9a2e8ffc9e9e5431d96dae1a35924", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -171,9 +171,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             PatKind::TupleStruct(ref qpath, subpats, ddpos) => {\n                 self.check_pat_tuple_struct(pat, qpath, subpats, ddpos, expected, def_bm, ti)\n             }\n-            PatKind::Path(ref qpath) => {\n-                self.check_pat_path(pat, path_res.unwrap(), qpath, expected, ti)\n-            }\n+            PatKind::Path(_) => self.check_pat_path(pat, path_res.unwrap(), expected, ti),\n             PatKind::Struct(ref qpath, fields, etc) => {\n                 self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n             }\n@@ -694,7 +692,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         &self,\n         pat: &Pat<'_>,\n         path_resolution: (Res, Option<Ty<'tcx>>, &'b [hir::PathSegment<'b>]),\n-        qpath: &hir::QPath<'_>,\n         expected: Ty<'tcx>,\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n@@ -707,17 +704,18 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 self.set_tainted_by_errors();\n                 return tcx.types.err;\n             }\n-            Res::Def(DefKind::AssocFn, _)\n-            | Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _)\n-            | Res::Def(DefKind::Ctor(_, CtorKind::Fn), _) => {\n-                report_unexpected_variant_res(tcx, res, pat.span, qpath);\n+            Res::Def(DefKind::AssocFn | DefKind::Ctor(_, CtorKind::Fictive | CtorKind::Fn), _) => {\n+                report_unexpected_variant_res(tcx, res, pat.span);\n                 return tcx.types.err;\n             }\n-            Res::Def(DefKind::Ctor(_, CtorKind::Const), _)\n-            | Res::SelfCtor(..)\n-            | Res::Def(DefKind::Const, _)\n-            | Res::Def(DefKind::AssocConst, _)\n-            | Res::Def(DefKind::ConstParam, _) => {} // OK\n+            Res::SelfCtor(..)\n+            | Res::Def(\n+                DefKind::Ctor(_, CtorKind::Const)\n+                | DefKind::Const\n+                | DefKind::AssocConst\n+                | DefKind::ConstParam,\n+                _,\n+            ) => {} // OK\n             _ => bug!(\"unexpected pattern resolution: {:?}\", res),\n         }\n \n@@ -791,14 +789,19 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n+            let sm = tcx.sess.source_map();\n+            let path_str = sm\n+                .span_to_snippet(sm.span_until_char(pat.span, '('))\n+                .map_or(String::new(), |s| format!(\" `{}`\", s.trim_end()));\n             let msg = format!(\n-                \"expected tuple struct or tuple variant, found {} `{}`\",\n+                \"expected tuple struct or tuple variant, found {}{}\",\n                 res.descr(),\n-                hir::print::to_string(&tcx.hir(), |s| s.print_qpath(qpath, false)),\n+                path_str\n             );\n+\n             let mut err = struct_span_err!(tcx.sess, pat.span, E0164, \"{}\", msg);\n-            match (res, &pat.kind) {\n-                (Res::Def(DefKind::Fn, _), _) | (Res::Def(DefKind::AssocFn, _), _) => {\n+            match res {\n+                Res::Def(DefKind::Fn | DefKind::AssocFn, _) => {\n                     err.span_label(pat.span, \"`fn` calls are not allowed in patterns\");\n                     err.help(\n                         \"for more information, visit \\"}, {"sha": "9d8113e7b3fff4942f9665b69bf825e8d772ba5c", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -5,7 +5,6 @@ use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, DefIdSet, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n-use rustc_hir::print::visibility_qualified;\n use rustc_session::lint;\n use rustc_span::Span;\n \n@@ -176,16 +175,13 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n                 Some(orig_name) => format!(\"use {} as {};\", orig_name, item.ident.name),\n                 None => format!(\"use {};\", item.ident.name),\n             };\n-\n-            let replacement = visibility_qualified(&item.vis, base_replacement);\n-            let msg = \"`extern crate` is not idiomatic in the new edition\";\n-            let help = format!(\"convert it to a `{}`\", visibility_qualified(&item.vis, \"use\"));\n-\n-            lint.build(msg)\n+            let vis = tcx.sess.source_map().span_to_snippet(item.vis.span).unwrap_or_default();\n+            let add_vis = |to| if vis.is_empty() { to } else { format!(\"{} {}\", vis, to) };\n+            lint.build(\"`extern crate` is not idiomatic in the new edition\")\n                 .span_suggestion_short(\n                     extern_crate.span,\n-                    &help,\n-                    replacement,\n+                    &format!(\"convert it to a `{}`\", add_vis(\"use\".to_string())),\n+                    add_vis(base_replacement),\n                     Applicability::MachineApplicable,\n                 )\n                 .emit();"}, {"sha": "31123c5cf028c410862f87e02c36b95a673017fd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -2146,13 +2146,18 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     {\n         let check = |ast_ty: &hir::Ty<'_>, ty: Ty<'_>| {\n             if ty.is_simd() {\n+                let snip = tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(ast_ty.span)\n+                    .map_or(String::new(), |s| format!(\" `{}`\", s));\n                 tcx.sess\n                     .struct_span_err(\n                         ast_ty.span,\n                         &format!(\n-                            \"use of SIMD type `{}` in FFI is highly experimental and \\\n+                            \"use of SIMD type{} in FFI is highly experimental and \\\n                              may result in invalid code\",\n-                            tcx.hir().hir_to_pretty_string(ast_ty.hir_id)\n+                            snip\n                         ),\n                     )\n                     .help(\"add `#![feature(simd_ffi)]` to the crate attributes to enable\")"}, {"sha": "510eae82834c873d4557bcd8021066985282ada7", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -482,8 +482,8 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n }\n \n pub fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {\n-    if let Some(node_id) = cx.tcx.hir().as_local_hir_id(did) {\n-        cx.tcx.hir().hir_to_pretty_string(node_id)\n+    if let Some(hir_id) = cx.tcx.hir().as_local_hir_id(did) {\n+        rustc_hir_pretty::id_to_string(&cx.tcx.hir(), hir_id)\n     } else {\n         cx.tcx.rendered_const(did)\n     }"}, {"sha": "b3bfb559749cb4143b9423c8c62adb9b3acbfcb0", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -578,7 +578,7 @@ pub fn print_const_expr(cx: &DocContext<'_>, body: hir::BodyId) -> String {\n         None\n     };\n \n-    snippet.unwrap_or_else(|| cx.tcx.hir().hir_to_pretty_string(body.hir_id))\n+    snippet.unwrap_or_else(|| rustc_hir_pretty::id_to_string(&cx.tcx.hir(), body.hir_id))\n }\n \n /// Given a type Path, resolve it to a Type using the TyCtxt"}, {"sha": "3c5df0247c1e8f382d18fb3b52ae1e616eec2a3d", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -26,6 +26,7 @@ extern crate rustc_errors;\n extern crate rustc_expand;\n extern crate rustc_feature;\n extern crate rustc_hir;\n+extern crate rustc_hir_pretty;\n extern crate rustc_index;\n extern crate rustc_infer;\n extern crate rustc_interface;"}, {"sha": "93305a1f87a16e7e079d705720932e087a85c610", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -910,7 +910,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n \n     fn visit_item(&mut self, item: &'hir hir::Item) {\n         let name = if let hir::ItemKind::Impl { ref self_ty, .. } = item.kind {\n-            self.map.hir_to_pretty_string(self_ty.hir_id)\n+            rustc_hir_pretty::id_to_string(&self.map, self_ty.hir_id)\n         } else {\n             item.ident.to_string()\n         };"}, {"sha": "0fbe8e5dd83e84d0ca4d1d7879a092d3cec8e7a2", "filename": "src/libstd/ffi/os_str.rs", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibstd%2Fffi%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibstd%2Fffi%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fffi%2Fos_str.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -379,6 +379,14 @@ impl ops::Index<ops::RangeFull> for OsString {\n     }\n }\n \n+#[stable(feature = \"mut_osstr\", since = \"1.44.0\")]\n+impl ops::IndexMut<ops::RangeFull> for OsString {\n+    #[inline]\n+    fn index_mut(&mut self, _index: ops::RangeFull) -> &mut OsStr {\n+        OsStr::from_inner_mut(self.inner.as_mut_slice())\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ops::Deref for OsString {\n     type Target = OsStr;\n@@ -389,6 +397,14 @@ impl ops::Deref for OsString {\n     }\n }\n \n+#[stable(feature = \"mut_osstr\", since = \"1.44.0\")]\n+impl ops::DerefMut for OsString {\n+    #[inline]\n+    fn deref_mut(&mut self) -> &mut OsStr {\n+        &mut self[..]\n+    }\n+}\n+\n #[stable(feature = \"osstring_default\", since = \"1.9.0\")]\n impl Default for OsString {\n     /// Constructs an empty `OsString`.\n@@ -509,9 +525,20 @@ impl OsStr {\n \n     #[inline]\n     fn from_inner(inner: &Slice) -> &OsStr {\n+        // Safety: OsStr is just a wrapper of Slice,\n+        // therefore converting &Slice to &OsStr is safe.\n         unsafe { &*(inner as *const Slice as *const OsStr) }\n     }\n \n+    #[inline]\n+    fn from_inner_mut(inner: &mut Slice) -> &mut OsStr {\n+        // Safety: OsStr is just a wrapper of Slice,\n+        // therefore converting &mut Slice to &mut OsStr is safe.\n+        // Any method that mutates OsStr must be careful not to\n+        // break platform-specific encoding, in particular Wtf8 on Windows.\n+        unsafe { &mut *(inner as *mut Slice as *mut OsStr) }\n+    }\n+\n     /// Yields a [`&str`] slice if the `OsStr` is valid Unicode.\n     ///\n     /// This conversion may entail doing a check for UTF-8 validity."}, {"sha": "ff6885cb27477e7c9bd9efb4110b430c48ef2829", "filename": "src/libstd/sys/windows/os_str.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos_str.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -77,9 +77,21 @@ impl Buf {\n     }\n \n     pub fn as_slice(&self) -> &Slice {\n+        // Safety: Slice is just a wrapper for Wtf8,\n+        // and self.inner.as_slice() returns &Wtf8.\n+        // Therefore, transmuting &Wtf8 to &Slice is safe.\n         unsafe { mem::transmute(self.inner.as_slice()) }\n     }\n \n+    pub fn as_mut_slice(&mut self) -> &mut Slice {\n+        // Safety: Slice is just a wrapper for Wtf8,\n+        // and self.inner.as_mut_slice() returns &mut Wtf8.\n+        // Therefore, transmuting &mut Wtf8 to &mut Slice is safe.\n+        // Additionally, care should be taken to ensure the slice\n+        // is always valid Wtf8.\n+        unsafe { mem::transmute(self.inner.as_mut_slice()) }\n+    }\n+\n     pub fn into_string(self) -> Result<String, Buf> {\n         self.inner.into_string().map_err(|buf| Buf { inner: buf })\n     }"}, {"sha": "c5d02fb17722f4401ddcb70a60b5a53fc32c6ecc", "filename": "src/libstd/sys_common/os_str_bytes.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys_common%2Fos_str_bytes.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -106,9 +106,20 @@ impl Buf {\n \n     #[inline]\n     pub fn as_slice(&self) -> &Slice {\n+        // Safety: Slice just wraps [u8],\n+        // and &*self.inner is &[u8], therefore\n+        // transmuting &[u8] to &Slice is safe.\n         unsafe { mem::transmute(&*self.inner) }\n     }\n \n+    #[inline]\n+    pub fn as_mut_slice(&mut self) -> &mut Slice {\n+        // Safety: Slice just wraps [u8],\n+        // and &mut *self.inner is &mut [u8], therefore\n+        // transmuting &mut [u8] to &mut Slice is safe.\n+        unsafe { mem::transmute(&mut *self.inner) }\n+    }\n+\n     pub fn into_string(self) -> Result<String, Buf> {\n         String::from_utf8(self.inner).map_err(|p| Buf { inner: p.into_bytes() })\n     }"}, {"sha": "7b025be11a09edc0f57678591aa3f00836d87947", "filename": "src/test/ui/issues/issue-66667-function-cmp-cycle.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -0,0 +1,16 @@\n+fn first() {\n+    second == 1 //~ ERROR binary operation\n+    //~^ ERROR mismatched types\n+}\n+\n+fn second() {\n+    first == 1 //~ ERROR binary operation\n+    //~^ ERROR mismatched types\n+}\n+\n+fn bar() {\n+    bar == 1 //~ ERROR binary operation\n+    //~^ ERROR mismatched types\n+}\n+\n+fn main() {}"}, {"sha": "887699ef5ce85e09b038e8f5122a7a7f2f486111", "filename": "src/test/ui/issues/issue-66667-function-cmp-cycle.stderr", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66667-function-cmp-cycle.stderr?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -0,0 +1,55 @@\n+error[E0369]: binary operation `==` cannot be applied to type `fn() {second}`\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:2:12\n+   |\n+LL |     second == 1\n+   |     ------ ^^ - {integer}\n+   |     |\n+   |     fn() {second}\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:2:15\n+   |\n+LL |     second == 1\n+   |               ^ expected fn item, found integer\n+   |\n+   = note: expected fn item `fn() {second}`\n+                 found type `{integer}`\n+\n+error[E0369]: binary operation `==` cannot be applied to type `fn() {first}`\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:7:11\n+   |\n+LL |     first == 1\n+   |     ----- ^^ - {integer}\n+   |     |\n+   |     fn() {first}\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:7:14\n+   |\n+LL |     first == 1\n+   |              ^ expected fn item, found integer\n+   |\n+   = note: expected fn item `fn() {first}`\n+                 found type `{integer}`\n+\n+error[E0369]: binary operation `==` cannot be applied to type `fn() {bar}`\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:12:9\n+   |\n+LL |     bar == 1\n+   |     --- ^^ - {integer}\n+   |     |\n+   |     fn() {bar}\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-66667-function-cmp-cycle.rs:12:12\n+   |\n+LL |     bar == 1\n+   |            ^ expected fn item, found integer\n+   |\n+   = note: expected fn item `fn() {bar}`\n+                 found type `{integer}`\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0308, E0369.\n+For more information about an error, try `rustc --explain E0308`."}, {"sha": "5e64f63d53395e7aa978897c899912af147a1c0d", "filename": "src/test/ui/issues/issue-66706.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fissues%2Fissue-66706.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fissues%2Fissue-66706.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66706.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -0,0 +1,13 @@\n+fn a() {\n+    [0; [|_: _ &_| ()].len()]\n+    //~^ ERROR expected `,`, found `&`\n+    //~| ERROR type annotations needed\n+    //~| ERROR mismatched types\n+}\n+\n+fn b() {\n+    [0; [|f @ &ref _| {} ; 0 ].len() ];\n+    //~^ ERROR expected identifier, found reserved identifier `_`\n+}\n+\n+fn main() {}"}, {"sha": "6d290bccc7d0dded792c05b84b6c291ce86f54f7", "filename": "src/test/ui/issues/issue-66706.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fissues%2Fissue-66706.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fissues%2Fissue-66706.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-66706.stderr?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -0,0 +1,32 @@\n+error: expected `,`, found `&`\n+  --> $DIR/issue-66706.rs:2:16\n+   |\n+LL |     [0; [|_: _ &_| ()].len()]\n+   |               -^ expected `,`\n+   |               |\n+   |               help: missing `,`\n+\n+error: expected identifier, found reserved identifier `_`\n+  --> $DIR/issue-66706.rs:9:20\n+   |\n+LL |     [0; [|f @ &ref _| {} ; 0 ].len() ];\n+   |                    ^ expected identifier, found reserved identifier\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-66706.rs:2:11\n+   |\n+LL |     [0; [|_: _ &_| ()].len()]\n+   |           ^ consider giving this closure parameter a type\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-66706.rs:2:5\n+   |\n+LL | fn a() {\n+   |        - help: try adding a return type: `-> [{integer}; _]`\n+LL |     [0; [|_: _ &_| ()].len()]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found array `[{integer}; _]`\n+\n+error: aborting due to 4 previous errors\n+\n+Some errors have detailed explanations: E0282, E0308.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "ed3c0222c7542bdd71fbc961774c7e065df9550c", "filename": "src/test/ui/methods/method-path-in-pattern.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fmethods%2Fmethod-path-in-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fmethods%2Fmethod-path-in-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-path-in-pattern.stderr?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -4,13 +4,13 @@ error[E0533]: expected unit struct, unit variant or constant, found associated f\n LL |         Foo::bar => {}\n    |         ^^^^^^^^\n \n-error[E0533]: expected unit struct, unit variant or constant, found associated function `Foo::bar`\n+error[E0533]: expected unit struct, unit variant or constant, found associated function `<Foo>::bar`\n   --> $DIR/method-path-in-pattern.rs:19:9\n    |\n LL |         <Foo>::bar => {}\n    |         ^^^^^^^^^^\n \n-error[E0533]: expected unit struct, unit variant or constant, found associated function `Foo::trait_bar`\n+error[E0533]: expected unit struct, unit variant or constant, found associated function `<Foo>::trait_bar`\n   --> $DIR/method-path-in-pattern.rs:23:9\n    |\n LL |         <Foo>::trait_bar => {}\n@@ -22,7 +22,7 @@ error[E0533]: expected unit struct, unit variant or constant, found associated f\n LL |     if let Foo::bar = 0u32 {}\n    |            ^^^^^^^^\n \n-error[E0533]: expected unit struct, unit variant or constant, found associated function `Foo::bar`\n+error[E0533]: expected unit struct, unit variant or constant, found associated function `<Foo>::bar`\n   --> $DIR/method-path-in-pattern.rs:28:12\n    |\n LL |     if let <Foo>::bar = 0u32 {}"}, {"sha": "b1482bc040f5332b2bc273af26be316fa9f1303b", "filename": "src/test/ui/privacy/associated-item-privacy-trait.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.rs?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -21,9 +21,9 @@ mod priv_trait {\n         Pub.method();\n         //~^ ERROR type `for<'r> fn(&'r Self) {<Self as priv_trait::PrivTr>::method}` is private\n         <Pub as PrivTr>::CONST;\n-        //~^ ERROR associated constant `PrivTr::CONST` is private\n+        //~^ ERROR associated constant `<Pub as PrivTr>::CONST` is private\n         let _: <Pub as PrivTr>::AssocTy;\n-        //~^ ERROR associated type `PrivTr::AssocTy` is private\n+        //~^ ERROR associated type `<Pub as PrivTr>::AssocTy` is private\n         pub type InSignatureTy = <Pub as PrivTr>::AssocTy;\n         //~^ ERROR trait `priv_trait::PrivTr` is private\n         pub trait InSignatureTr: PrivTr {}\n@@ -115,7 +115,7 @@ mod priv_parent_substs {\n         <Priv as PubTr<_>>::CONST;\n         //~^ ERROR type `priv_parent_substs::Priv` is private\n \n-        let _: <Pub as PubTr>::AssocTy;  // FIXME no longer an error?!\n+        let _: <Pub as PubTr>::AssocTy; // FIXME no longer an error?!\n         let _: <Pub as PubTr<_>>::AssocTy;\n         //~^ ERROR type `priv_parent_substs::Priv` is private\n         let _: <Priv as PubTr<_>>::AssocTy;"}, {"sha": "b9f3e35d72261813e846413f40ab73bc4985b6e2", "filename": "src/test/ui/privacy/associated-item-privacy-trait.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-trait.stderr?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -31,7 +31,7 @@ LL |     priv_trait::mac!();\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: associated constant `PrivTr::CONST` is private\n+error: associated constant `<Pub as PrivTr>::CONST` is private\n   --> $DIR/associated-item-privacy-trait.rs:23:9\n    |\n LL |         <Pub as PrivTr>::CONST;\n@@ -42,7 +42,7 @@ LL |     priv_trait::mac!();\n    |\n    = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error: associated type `PrivTr::AssocTy` is private\n+error: associated type `<Pub as PrivTr>::AssocTy` is private\n   --> $DIR/associated-item-privacy-trait.rs:25:16\n    |\n LL |         let _: <Pub as PrivTr>::AssocTy;"}, {"sha": "4214e2503c345cad36a3a4e12df95e88e21fcbd5", "filename": "src/test/ui/qualified/qualified-path-params.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b73d14b0b35e7b4f79f2d71dc1bbbab31698288/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr?ref=7b73d14b0b35e7b4f79f2d71dc1bbbab31698288", "patch": "@@ -1,4 +1,4 @@\n-error[E0533]: expected unit struct, unit variant or constant, found associated function `<<S as Tr>::A>::f<u8>`\n+error[E0533]: expected unit struct, unit variant or constant, found associated function `<S as Tr>::A::f::<u8>`\n   --> $DIR/qualified-path-params.rs:20:9\n    |\n LL |         <S as Tr>::A::f::<u8> => {}"}]}