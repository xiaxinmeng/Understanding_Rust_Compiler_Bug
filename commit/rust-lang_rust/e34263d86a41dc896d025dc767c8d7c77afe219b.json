{"sha": "e34263d86a41dc896d025dc767c8d7c77afe219b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzNDI2M2Q4NmE0MWRjODk2ZDAyNWRjNzY3YzhkN2M3N2FmZTIxOWI=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2020-10-24T20:39:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-24T20:39:44Z"}, "message": "Rollup merge of #77610 - hermitcore:dtors, r=m-ou-se\n\nrevise Hermit's mutex interface to support the behaviour of StaticMutex\n\nrust-lang/rust#77147 simplifies things by splitting this Mutex type into two types matching the two use cases: StaticMutex and MovableMutex. To support the new behavior of StaticMutex, we move part of the mutex implementation into libstd.\n\nThe interface to the OS changed. Consequently, I removed a few functions, which aren't longer needed.", "tree": {"sha": "598a3f38d08aa23d8d3d101d8ca1695318f1f516", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/598a3f38d08aa23d8d3d101d8ca1695318f1f516"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e34263d86a41dc896d025dc767c8d7c77afe219b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJflJEQCRBK7hj4Ov3rIwAAdHIIAFlIsy1VoPb+TawuQAD2ZdF0\nJTskyDEhx7TkzkB0U8RgozfSxOT+rtjcUJ+RUv8LPrAzF+nxp4Qn4Dnlk6t2koUV\nSPdAV8FRRciq28xjUu2UX7pg0ElsjU6jRRAO0HUpi6Kr/vCPTYRPWQqUQjX7LCAx\nK9s1d1GFcfZ/0yoIVgY2nxTKsVGf4jlDsyIbgXS5pyyZDoyzeTz+Mp/gnrxXvqIJ\n9c0D2aA53Vg5PwWMlq8wIOSTwgg8vP4mjYHQdexmZrTnvyfxunHjzBpNI758VoOq\no+4Bky/zjVV0seaCuclBzVtA27fPr98oZyKmHjTZ1cfLmFRuDWtJAm9JCS/+iVk=\n=h5+z\n-----END PGP SIGNATURE-----\n", "payload": "tree 598a3f38d08aa23d8d3d101d8ca1695318f1f516\nparent a547055184c55961b3e7d89b031d0e7b07de0a36\nparent bf268fe928eae8d85a868ccdbcc086ea033ae51c\nauthor Jonas Schievink <jonasschievink@gmail.com> 1603571984 +0200\ncommitter GitHub <noreply@github.com> 1603571984 +0200\n\nRollup merge of #77610 - hermitcore:dtors, r=m-ou-se\n\nrevise Hermit's mutex interface to support the behaviour of StaticMutex\n\nrust-lang/rust#77147 simplifies things by splitting this Mutex type into two types matching the two use cases: StaticMutex and MovableMutex. To support the new behavior of StaticMutex, we move part of the mutex implementation into libstd.\n\nThe interface to the OS changed. Consequently, I removed a few functions, which aren't longer needed.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e34263d86a41dc896d025dc767c8d7c77afe219b", "html_url": "https://github.com/rust-lang/rust/commit/e34263d86a41dc896d025dc767c8d7c77afe219b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e34263d86a41dc896d025dc767c8d7c77afe219b/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a547055184c55961b3e7d89b031d0e7b07de0a36", "url": "https://api.github.com/repos/rust-lang/rust/commits/a547055184c55961b3e7d89b031d0e7b07de0a36", "html_url": "https://github.com/rust-lang/rust/commit/a547055184c55961b3e7d89b031d0e7b07de0a36"}, {"sha": "bf268fe928eae8d85a868ccdbcc086ea033ae51c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf268fe928eae8d85a868ccdbcc086ea033ae51c", "html_url": "https://github.com/rust-lang/rust/commit/bf268fe928eae8d85a868ccdbcc086ea033ae51c"}], "stats": {"total": 353, "additions": 186, "deletions": 167}, "files": [{"sha": "8af442c8f4b3e2e3155691b05e199645b963380f", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e34263d86a41dc896d025dc767c8d7c77afe219b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e34263d86a41dc896d025dc767c8d7c77afe219b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e34263d86a41dc896d025dc767c8d7c77afe219b", "patch": "@@ -1366,9 +1366,9 @@ dependencies = [\n \n [[package]]\n name = \"hermit-abi\"\n-version = \"0.1.15\"\n+version = \"0.1.17\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"3deed196b6e7f9e44a2ae8d94225d80302d81208b1bb673fd21fe634645c85a9\"\n+checksum = \"5aca5565f760fb5b220e499d72710ed156fdb74e631659e99377d9ebfbd13ae8\"\n dependencies = [\n  \"compiler_builtins\",\n  \"libc\","}, {"sha": "dd7dcfbc4aa452f55b94af9b1ab305d5b3b4d1b5", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=e34263d86a41dc896d025dc767c8d7c77afe219b", "patch": "@@ -372,7 +372,7 @@ pub fn handle_alloc_error(layout: Layout) -> ! {\n     unsafe { oom_impl(layout) }\n }\n \n-#[cfg(not(any(test, bootstrap)))]\n+#[cfg(not(any(target_os = \"hermit\", test, bootstrap)))]\n #[doc(hidden)]\n #[allow(unused_attributes)]\n #[unstable(feature = \"alloc_internals\", issue = \"none\")]"}, {"sha": "5925aa87a3f1398bdd3aabcbca2f8b1789a4f24f", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=e34263d86a41dc896d025dc767c8d7c77afe219b", "patch": "@@ -42,7 +42,7 @@ dlmalloc = { version = \"0.1\", features = ['rustc-dep-of-std'] }\n fortanix-sgx-abi = { version = \"0.3.2\", features = ['rustc-dep-of-std'] }\n \n [target.'cfg(all(any(target_arch = \"x86_64\", target_arch = \"aarch64\"), target_os = \"hermit\"))'.dependencies]\n-hermit-abi = { version = \"0.1.15\", features = ['rustc-dep-of-std'] }\n+hermit-abi = { version = \"0.1.17\", features = ['rustc-dep-of-std'] }\n \n [target.wasm32-wasi.dependencies]\n wasi = { version = \"0.9.0\", features = ['rustc-dep-of-std'], default-features = false }"}, {"sha": "829d4c943f11b2b33d743def77331af5136e1270", "filename": "library/std/src/sys/hermit/fs.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ffs.rs?ref=e34263d86a41dc896d025dc767c8d7c77afe219b", "patch": "@@ -334,10 +334,6 @@ impl File {\n     pub fn set_permissions(&self, _perm: FilePermissions) -> io::Result<()> {\n         Err(Error::from_raw_os_error(22))\n     }\n-\n-    pub fn diverge(&self) -> ! {\n-        loop {}\n-    }\n }\n \n impl DirBuilder {"}, {"sha": "af05310a8d3ab0c8c1118d484de8d817623027bb", "filename": "library/std/src/sys/hermit/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmod.rs?ref=e34263d86a41dc896d025dc767c8d7c77afe219b", "patch": "@@ -31,6 +31,7 @@ pub mod net;\n pub mod os;\n pub mod path;\n pub mod pipe;\n+#[path = \"../unsupported/process.rs\"]\n pub mod process;\n pub mod rwlock;\n pub mod stack_overflow;"}, {"sha": "f988a019cfedb39f98c22f5fd12543f961d4cacb", "filename": "library/std/src/sys/hermit/mutex.rs", "status": "modified", "additions": 180, "deletions": 10, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fmutex.rs?ref=e34263d86a41dc896d025dc767c8d7c77afe219b", "patch": "@@ -1,44 +1,214 @@\n+use crate::cell::UnsafeCell;\n+use crate::collections::VecDeque;\n use crate::ffi::c_void;\n+use crate::ops::{Deref, DerefMut, Drop};\n use crate::ptr;\n+use crate::sync::atomic::{spin_loop_hint, AtomicUsize, Ordering};\n use crate::sys::hermit::abi;\n \n+/// This type provides a lock based on busy waiting to realize mutual exclusion\n+///\n+/// # Description\n+///\n+/// This structure behaves a lot like a common mutex. There are some differences:\n+///\n+/// - By using busy waiting, it can be used outside the runtime.\n+/// - It is a so called ticket lock and is completly fair.\n+#[cfg_attr(target_arch = \"x86_64\", repr(align(128)))]\n+#[cfg_attr(not(target_arch = \"x86_64\"), repr(align(64)))]\n+struct Spinlock<T: ?Sized> {\n+    queue: AtomicUsize,\n+    dequeue: AtomicUsize,\n+    data: UnsafeCell<T>,\n+}\n+\n+unsafe impl<T: ?Sized + Send> Sync for Spinlock<T> {}\n+unsafe impl<T: ?Sized + Send> Send for Spinlock<T> {}\n+\n+/// A guard to which the protected data can be accessed\n+///\n+/// When the guard falls out of scope it will release the lock.\n+struct SpinlockGuard<'a, T: ?Sized + 'a> {\n+    dequeue: &'a AtomicUsize,\n+    data: &'a mut T,\n+}\n+\n+impl<T> Spinlock<T> {\n+    pub const fn new(user_data: T) -> Spinlock<T> {\n+        Spinlock {\n+            queue: AtomicUsize::new(0),\n+            dequeue: AtomicUsize::new(1),\n+            data: UnsafeCell::new(user_data),\n+        }\n+    }\n+\n+    #[inline]\n+    fn obtain_lock(&self) {\n+        let ticket = self.queue.fetch_add(1, Ordering::SeqCst) + 1;\n+        while self.dequeue.load(Ordering::SeqCst) != ticket {\n+            spin_loop_hint();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn lock(&self) -> SpinlockGuard<'_, T> {\n+        self.obtain_lock();\n+        SpinlockGuard { dequeue: &self.dequeue, data: &mut *self.data.get() }\n+    }\n+}\n+\n+impl<T: ?Sized + Default> Default for Spinlock<T> {\n+    fn default() -> Spinlock<T> {\n+        Spinlock::new(Default::default())\n+    }\n+}\n+\n+impl<'a, T: ?Sized> Deref for SpinlockGuard<'a, T> {\n+    type Target = T;\n+    fn deref(&self) -> &T {\n+        &*self.data\n+    }\n+}\n+\n+impl<'a, T: ?Sized> DerefMut for SpinlockGuard<'a, T> {\n+    fn deref_mut(&mut self) -> &mut T {\n+        &mut *self.data\n+    }\n+}\n+\n+impl<'a, T: ?Sized> Drop for SpinlockGuard<'a, T> {\n+    /// The dropping of the SpinlockGuard will release the lock it was created from.\n+    fn drop(&mut self) {\n+        self.dequeue.fetch_add(1, Ordering::SeqCst);\n+    }\n+}\n+\n+/// Realize a priority queue for tasks\n+struct PriorityQueue {\n+    queues: [Option<VecDeque<abi::Tid>>; abi::NO_PRIORITIES],\n+    prio_bitmap: u64,\n+}\n+\n+impl PriorityQueue {\n+    pub const fn new() -> PriorityQueue {\n+        PriorityQueue {\n+            queues: [\n+                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n+                None, None, None, None, None, None, None, None, None, None, None, None, None, None,\n+                None, None, None,\n+            ],\n+            prio_bitmap: 0,\n+        }\n+    }\n+\n+    /// Add a task id by its priority to the queue\n+    pub fn push(&mut self, prio: abi::Priority, id: abi::Tid) {\n+        let i: usize = prio.into().into();\n+        self.prio_bitmap |= (1 << i) as u64;\n+        if let Some(queue) = &mut self.queues[i] {\n+            queue.push_back(id);\n+        } else {\n+            let mut queue = VecDeque::new();\n+            queue.push_back(id);\n+            self.queues[i] = Some(queue);\n+        }\n+    }\n+\n+    fn pop_from_queue(&mut self, queue_index: usize) -> Option<abi::Tid> {\n+        if let Some(queue) = &mut self.queues[queue_index] {\n+            let id = queue.pop_front();\n+\n+            if queue.is_empty() {\n+                self.prio_bitmap &= !(1 << queue_index as u64);\n+            }\n+\n+            id\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Pop the task handle with the highest priority from the queue\n+    pub fn pop(&mut self) -> Option<abi::Tid> {\n+        for i in 0..abi::NO_PRIORITIES {\n+            if self.prio_bitmap & (1 << i) != 0 {\n+                return self.pop_from_queue(i);\n+            }\n+        }\n+\n+        None\n+    }\n+}\n+\n+struct MutexInner {\n+    locked: bool,\n+    blocked_task: PriorityQueue,\n+}\n+\n+impl MutexInner {\n+    pub const fn new() -> MutexInner {\n+        MutexInner { locked: false, blocked_task: PriorityQueue::new() }\n+    }\n+}\n+\n pub struct Mutex {\n-    inner: *const c_void,\n+    inner: Spinlock<MutexInner>,\n }\n \n+pub type MovableMutex = Box<Mutex>;\n+\n unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n impl Mutex {\n     pub const fn new() -> Mutex {\n-        Mutex { inner: ptr::null() }\n+        Mutex { inner: Spinlock::new(MutexInner::new()) }\n     }\n \n     #[inline]\n     pub unsafe fn init(&mut self) {\n-        let _ = abi::sem_init(&mut self.inner as *mut *const c_void, 1);\n+        self.inner = Spinlock::new(MutexInner::new());\n     }\n \n     #[inline]\n     pub unsafe fn lock(&self) {\n-        let _ = abi::sem_timedwait(self.inner, 0);\n+        loop {\n+            let mut guard = self.inner.lock();\n+            if guard.locked == false {\n+                guard.locked = true;\n+                return;\n+            } else {\n+                let prio = abi::get_priority();\n+                let id = abi::getpid();\n+\n+                guard.blocked_task.push(prio, id);\n+                abi::block_current_task();\n+                drop(guard);\n+                abi::yield_now();\n+            }\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn unlock(&self) {\n-        let _ = abi::sem_post(self.inner);\n+        let mut guard = self.inner.lock();\n+        guard.locked = false;\n+        if let Some(tid) = guard.blocked_task.pop() {\n+            abi::wakeup_task(tid);\n+        }\n     }\n \n     #[inline]\n     pub unsafe fn try_lock(&self) -> bool {\n-        let result = abi::sem_trywait(self.inner);\n-        result == 0\n+        let mut guard = self.inner.lock();\n+        if guard.locked == false {\n+            guard.locked = true;\n+        }\n+        guard.locked\n     }\n \n     #[inline]\n-    pub unsafe fn destroy(&self) {\n-        let _ = abi::sem_destroy(self.inner);\n-    }\n+    pub unsafe fn destroy(&self) {}\n }\n \n pub struct ReentrantMutex {"}, {"sha": "4702e5c549228ea27e5c59777cb707b34ea5d248", "filename": "library/std/src/sys/hermit/process.rs", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/a547055184c55961b3e7d89b031d0e7b07de0a36/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a547055184c55961b3e7d89b031d0e7b07de0a36/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Fprocess.rs?ref=a547055184c55961b3e7d89b031d0e7b07de0a36", "patch": "@@ -1,149 +0,0 @@\n-use crate::ffi::OsStr;\n-use crate::fmt;\n-use crate::io;\n-use crate::sys::fs::File;\n-use crate::sys::pipe::AnonPipe;\n-use crate::sys::{unsupported, Void};\n-use crate::sys_common::process::CommandEnv;\n-\n-pub use crate::ffi::OsString as EnvKey;\n-\n-////////////////////////////////////////////////////////////////////////////////\n-// Command\n-////////////////////////////////////////////////////////////////////////////////\n-\n-pub struct Command {\n-    env: CommandEnv,\n-}\n-\n-// passed back to std::process with the pipes connected to the child, if any\n-// were requested\n-pub struct StdioPipes {\n-    pub stdin: Option<AnonPipe>,\n-    pub stdout: Option<AnonPipe>,\n-    pub stderr: Option<AnonPipe>,\n-}\n-\n-pub enum Stdio {\n-    Inherit,\n-    Null,\n-    MakePipe,\n-}\n-\n-impl Command {\n-    pub fn new(_program: &OsStr) -> Command {\n-        Command { env: Default::default() }\n-    }\n-\n-    pub fn arg(&mut self, _arg: &OsStr) {}\n-\n-    pub fn env_mut(&mut self) -> &mut CommandEnv {\n-        &mut self.env\n-    }\n-\n-    pub fn cwd(&mut self, _dir: &OsStr) {}\n-\n-    pub fn stdin(&mut self, _stdin: Stdio) {}\n-\n-    pub fn stdout(&mut self, _stdout: Stdio) {}\n-\n-    pub fn stderr(&mut self, _stderr: Stdio) {}\n-\n-    pub fn spawn(\n-        &mut self,\n-        _default: Stdio,\n-        _needs_stdin: bool,\n-    ) -> io::Result<(Process, StdioPipes)> {\n-        unsupported()\n-    }\n-}\n-\n-impl From<AnonPipe> for Stdio {\n-    fn from(pipe: AnonPipe) -> Stdio {\n-        pipe.diverge()\n-    }\n-}\n-\n-impl From<File> for Stdio {\n-    fn from(file: File) -> Stdio {\n-        file.diverge()\n-    }\n-}\n-\n-impl fmt::Debug for Command {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        Ok(())\n-    }\n-}\n-\n-pub struct ExitStatus(Void);\n-\n-impl ExitStatus {\n-    pub fn success(&self) -> bool {\n-        match self.0 {}\n-    }\n-\n-    pub fn code(&self) -> Option<i32> {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Clone for ExitStatus {\n-    fn clone(&self) -> ExitStatus {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Copy for ExitStatus {}\n-\n-impl PartialEq for ExitStatus {\n-    fn eq(&self, _other: &ExitStatus) -> bool {\n-        match self.0 {}\n-    }\n-}\n-\n-impl Eq for ExitStatus {}\n-\n-impl fmt::Debug for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-impl fmt::Display for ExitStatus {\n-    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self.0 {}\n-    }\n-}\n-\n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub struct ExitCode(bool);\n-\n-impl ExitCode {\n-    pub const SUCCESS: ExitCode = ExitCode(false);\n-    pub const FAILURE: ExitCode = ExitCode(true);\n-\n-    pub fn as_i32(&self) -> i32 {\n-        self.0 as i32\n-    }\n-}\n-\n-pub struct Process(Void);\n-\n-impl Process {\n-    pub fn id(&self) -> u32 {\n-        match self.0 {}\n-    }\n-\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        match self.0 {}\n-    }\n-\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        match self.0 {}\n-    }\n-\n-    pub fn try_wait(&mut self) -> io::Result<Option<ExitStatus>> {\n-        match self.0 {}\n-    }\n-}"}, {"sha": "b4628b649117ed6b353afd45025a9d697e3da818", "filename": "library/std/src/sys/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e34263d86a41dc896d025dc767c8d7c77afe219b/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fmod.rs?ref=e34263d86a41dc896d025dc767c8d7c77afe219b", "patch": "@@ -89,6 +89,7 @@ cfg_if::cfg_if! {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         pub use self::ext as windows_ext;\n     } else if #[cfg(any(target_os = \"cloudabi\",\n+                        target_os = \"hermit\",\n                         target_arch = \"wasm32\",\n                         all(target_vendor = \"fortanix\", target_env = \"sgx\")))] {\n         // On CloudABI and wasm right now the shim below doesn't compile, so"}]}