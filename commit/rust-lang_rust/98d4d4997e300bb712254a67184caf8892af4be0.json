{"sha": "98d4d4997e300bb712254a67184caf8892af4be0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4ZDRkNDk5N2UzMDBiYjcxMjI1NGE2NzE4NGNhZjg4OTJhZjRiZTA=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-15T22:11:39Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-01-15T22:11:39Z"}, "message": "rollup merge of #21052: nick29581/methods-ext\n\nAllows modifiers to be used on methods, associated types, etc.\n\nr? @sfackler", "tree": {"sha": "21e271dd83e7f1b0e04083834868c2780756783a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21e271dd83e7f1b0e04083834868c2780756783a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98d4d4997e300bb712254a67184caf8892af4be0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98d4d4997e300bb712254a67184caf8892af4be0", "html_url": "https://github.com/rust-lang/rust/commit/98d4d4997e300bb712254a67184caf8892af4be0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98d4d4997e300bb712254a67184caf8892af4be0/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87dce0c138af6887704fc2379b7a75e05a1e8b18", "url": "https://api.github.com/repos/rust-lang/rust/commits/87dce0c138af6887704fc2379b7a75e05a1e8b18", "html_url": "https://github.com/rust-lang/rust/commit/87dce0c138af6887704fc2379b7a75e05a1e8b18"}, {"sha": "98d471120a09607ad429bebf56c97b512bdf9847", "url": "https://api.github.com/repos/rust-lang/rust/commits/98d471120a09607ad429bebf56c97b512bdf9847", "html_url": "https://github.com/rust-lang/rust/commit/98d471120a09607ad429bebf56c97b512bdf9847"}], "stats": {"total": 540, "additions": 419, "deletions": 121}, "files": [{"sha": "f6fb1c2d41928ad57cabd02a69f56cf9842474ff", "filename": "src/librustc/plugin/registry.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/98d4d4997e300bb712254a67184caf8892af4be0/src%2Flibrustc%2Fplugin%2Fregistry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4d4997e300bb712254a67184caf8892af4be0/src%2Flibrustc%2Fplugin%2Fregistry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fregistry.rs?ref=98d4d4997e300bb712254a67184caf8892af4be0", "patch": "@@ -14,7 +14,7 @@ use lint::{LintPassObject, LintId, Lint};\n use session::Session;\n \n use syntax::ext::base::{SyntaxExtension, NamedSyntaxExtension, NormalTT};\n-use syntax::ext::base::{IdentTT, Decorator, Modifier, MacroRulesTT};\n+use syntax::ext::base::{IdentTT, Decorator, Modifier, MultiModifier, MacroRulesTT};\n use syntax::ext::base::{MacroExpanderFn};\n use syntax::codemap::Span;\n use syntax::parse::token;\n@@ -82,7 +82,7 @@ impl<'a> Registry<'a> {\n             IdentTT(ext, _) => IdentTT(ext, Some(self.krate_span)),\n             Decorator(ext) => Decorator(ext),\n             Modifier(ext) => Modifier(ext),\n-\n+            MultiModifier(ext) => MultiModifier(ext),\n             MacroRulesTT => {\n                 self.sess.err(\"plugin tried to register a new MacroRulesTT\");\n                 return;"}, {"sha": "0ea429116b0bb86308ee7532ce1a8304016139ed", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/98d4d4997e300bb712254a67184caf8892af4be0/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4d4997e300bb712254a67184caf8892af4be0/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=98d4d4997e300bb712254a67184caf8892af4be0", "patch": "@@ -957,7 +957,7 @@ pub type Mac = Spanned<Mac_>;\n pub enum Mac_ {\n     // NB: the additional ident for a macro_rules-style macro is actually\n     // stored in the enclosing item. Oog.\n-    MacInvocTT(Path, Vec<TokenTree> , SyntaxContext),   // new macro-invocation\n+    MacInvocTT(Path, Vec<TokenTree>, SyntaxContext),   // new macro-invocation\n }\n \n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Show, Copy)]"}, {"sha": "f2498abfa6a593439e4cef48e71fae7e3aeab59c", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/98d4d4997e300bb712254a67184caf8892af4be0/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4d4997e300bb712254a67184caf8892af4be0/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=98d4d4997e300bb712254a67184caf8892af4be0", "patch": "@@ -73,6 +73,108 @@ impl<F> ItemModifier for F\n     }\n }\n \n+#[derive(Show,Clone)]\n+pub enum Annotatable {\n+    Item(P<ast::Item>),\n+    TraitItem(ast::TraitItem),\n+    ImplItem(ast::ImplItem),\n+}\n+\n+impl Annotatable {\n+    pub fn attrs(&self) -> &[ast::Attribute] {\n+        match *self {\n+            Annotatable::Item(ref i) => &i.attrs[],\n+            Annotatable::TraitItem(ref i) => match *i {\n+                ast::TraitItem::RequiredMethod(ref tm) => &tm.attrs[],\n+                ast::TraitItem::ProvidedMethod(ref m) => &m.attrs[],\n+                ast::TraitItem::TypeTraitItem(ref at) => &at.attrs[],\n+            },\n+            Annotatable::ImplItem(ref i) => match *i {\n+                ast::ImplItem::MethodImplItem(ref m) => &m.attrs[],\n+                ast::ImplItem::TypeImplItem(ref t) => &t.attrs[],\n+            }\n+        }\n+    }\n+\n+    pub fn fold_attrs(self, attrs: Vec<ast::Attribute>) -> Annotatable {\n+        match self {\n+            Annotatable::Item(i) => Annotatable::Item(P(ast::Item {\n+                attrs: attrs,\n+                ..(*i).clone()\n+            })),\n+            Annotatable::TraitItem(i) => match i {\n+                ast::TraitItem::RequiredMethod(tm) => Annotatable::TraitItem(\n+                    ast::TraitItem::RequiredMethod(\n+                        ast::TypeMethod { attrs: attrs, ..tm })),\n+                ast::TraitItem::ProvidedMethod(m) => Annotatable::TraitItem(\n+                    ast::TraitItem::ProvidedMethod(P(\n+                        ast::Method { attrs: attrs, ..(*m).clone() }))),\n+                ast::TraitItem::TypeTraitItem(at) => Annotatable::TraitItem(\n+                    ast::TraitItem::TypeTraitItem(P(\n+                        ast::AssociatedType { attrs: attrs, ..(*at).clone() }))),\n+            },\n+            Annotatable::ImplItem(i) => match i {\n+                ast::ImplItem::MethodImplItem(m) => Annotatable::ImplItem(\n+                    ast::ImplItem::MethodImplItem(P(\n+                        ast::Method { attrs: attrs, ..(*m).clone() }))),\n+                ast::ImplItem::TypeImplItem(t) => Annotatable::ImplItem(\n+                    ast::ImplItem::TypeImplItem(P(\n+                        ast::Typedef { attrs: attrs, ..(*t).clone() }))),\n+            }\n+        }\n+    }\n+\n+    pub fn expect_item(self) -> P<ast::Item> {\n+        match self {\n+            Annotatable::Item(i) => i,\n+            _ => panic!(\"expected Item\")\n+        }\n+    }\n+\n+    pub fn expect_trait_item(self) -> ast::TraitItem {\n+        match self {\n+            Annotatable::TraitItem(i) => i,\n+            _ => panic!(\"expected Item\")\n+        }\n+    }\n+\n+    pub fn expect_impl_item(self) -> ast::ImplItem {\n+        match self {\n+            Annotatable::ImplItem(i) => i,\n+            _ => panic!(\"expected Item\")\n+        }\n+    }\n+}\n+\n+// A more flexible ItemModifier (ItemModifier should go away, eventually, FIXME).\n+// meta_item is the annotation, item is the item being modified, parent_item\n+// is the impl or trait item is declared in if item is part of such a thing.\n+// FIXME Decorators should follow the same pattern too.\n+pub trait MultiItemModifier {\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt,\n+              span: Span,\n+              meta_item: &ast::MetaItem,\n+              item: Annotatable)\n+              -> Annotatable;\n+}\n+\n+impl<F> MultiItemModifier for F\n+    where F: Fn(&mut ExtCtxt,\n+                Span,\n+                &ast::MetaItem,\n+                Annotatable) -> Annotatable\n+{\n+    fn expand(&self,\n+              ecx: &mut ExtCtxt,\n+              span: Span,\n+              meta_item: &ast::MetaItem,\n+              item: Annotatable)\n+              -> Annotatable {\n+        (*self)(ecx, span, meta_item, item)\n+    }\n+}\n+\n /// Represents a thing that maps token trees to Macro Results\n pub trait TTMacroExpander {\n     fn expand<'cx>(&self,\n@@ -299,6 +401,10 @@ pub enum SyntaxExtension {\n     /// in-place.\n     Modifier(Box<ItemModifier + 'static>),\n \n+    /// A syntax extension that is attached to an item and modifies it\n+    /// in-place. More flexible version than Modifier.\n+    MultiModifier(Box<MultiItemModifier + 'static>),\n+\n     /// A normal, function-like syntax extension.\n     ///\n     /// `bytes!` is a `NormalTT`."}, {"sha": "c95bdeefd454046f39e6d5548c9c5bf10c5d3b83", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 211, "deletions": 73, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/98d4d4997e300bb712254a67184caf8892af4be0/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4d4997e300bb712254a67184caf8892af4be0/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=98d4d4997e300bb712254a67184caf8892af4be0", "patch": "@@ -395,89 +395,24 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n                    -> SmallVector<P<ast::Item>> {\n     let it = expand_item_modifiers(it, fld);\n \n-    let mut decorator_items = SmallVector::zero();\n-    let mut new_attrs = Vec::new();\n-    for attr in it.attrs.iter() {\n-        let mname = attr.name();\n-\n-        match fld.cx.syntax_env.find(&intern(mname.get())) {\n-            Some(rc) => match *rc {\n-                Decorator(ref dec) => {\n-                    attr::mark_used(attr);\n-\n-                    fld.cx.bt_push(ExpnInfo {\n-                        call_site: attr.span,\n-                        callee: NameAndSpan {\n-                            name: mname.get().to_string(),\n-                            format: MacroAttribute,\n-                            span: None\n-                        }\n-                    });\n-\n-                    // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n-                    // but that double-mut-borrows fld\n-                    let mut items: SmallVector<P<ast::Item>> = SmallVector::zero();\n-                    dec.expand(fld.cx, attr.span, &*attr.node.value, &*it,\n-                               box |&mut : item| items.push(item));\n-                    decorator_items.extend(items.into_iter()\n-                        .flat_map(|item| expand_item(item, fld).into_iter()));\n-\n-                    fld.cx.bt_pop();\n-                }\n-                _ => new_attrs.push((*attr).clone()),\n-            },\n-            _ => new_attrs.push((*attr).clone()),\n-        }\n-    }\n-\n-    let mut new_items = match it.node {\n-        ast::ItemMac(..) => expand_item_mac(it, fld),\n-        ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n-            let valid_ident =\n-                it.ident.name != parse::token::special_idents::invalid.name;\n-\n-            if valid_ident {\n-                fld.cx.mod_push(it.ident);\n-            }\n-            let macro_use = contains_macro_use(fld, &new_attrs[]);\n-            let result = with_exts_frame!(fld.cx.syntax_env,\n-                                          macro_use,\n-                                          noop_fold_item(it, fld));\n-            if valid_ident {\n-                fld.cx.mod_pop();\n-            }\n-            result\n-        },\n-        _ => {\n-            let it = P(ast::Item {\n-                attrs: new_attrs,\n-                ..(*it).clone()\n-            });\n-            noop_fold_item(it, fld)\n-        }\n-    };\n-\n-    new_items.push_all(decorator_items);\n-    new_items\n+    expand_annotatable(Annotatable::Item(it), fld)\n+        .into_iter().map(|i| i.expect_item()).collect()\n }\n \n fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n                          -> P<ast::Item> {\n     // partition the attributes into ItemModifiers and others\n-    let (modifiers, other_attrs): (Vec<_>, _) = it.attrs.iter().cloned().partition(|attr| {\n-        match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n-            Some(rc) => match *rc { Modifier(_) => true, _ => false },\n-            _ => false\n-        }\n-    });\n+    let (modifiers, other_attrs) = modifiers(&it.attrs, fld);\n+\n     // update the attrs, leave everything else alone. Is this mutation really a good idea?\n     it = P(ast::Item {\n         attrs: other_attrs,\n         ..(*it).clone()\n     });\n \n     if modifiers.is_empty() {\n-        return it;\n+        let it = expand_item_multi_modifier(Annotatable::Item(it), fld);\n+        return it.expect_item();\n     }\n \n     for attr in modifiers.iter() {\n@@ -504,7 +439,12 @@ fn expand_item_modifiers(mut it: P<ast::Item>, fld: &mut MacroExpander)\n         }\n     }\n \n-    // expansion may have added new ItemModifiers\n+    // Expansion may have added new ItemModifiers.\n+    // It is possible, that an item modifier could expand to a multi-modifier or\n+    // vice versa. In this case we will expand all modifiers before multi-modifiers,\n+    // which might give an odd ordering. However, I think it is unlikely that the\n+    // two kinds will be mixed, and I old-style multi-modifiers should be deprecated\n+    // anyway.\n     expand_item_modifiers(it, fld)\n }\n \n@@ -1029,6 +969,196 @@ impl<'a> Folder for PatIdentRenamer<'a> {\n     }\n }\n \n+fn expand_annotatable(a: Annotatable,\n+                      fld: &mut MacroExpander)\n+                      -> SmallVector<Annotatable> {\n+    let a = expand_item_multi_modifier(a, fld);\n+\n+    let mut decorator_items = SmallVector::zero();\n+    let mut new_attrs = Vec::new();\n+    for attr in a.attrs().iter() {\n+        let mname = attr.name();\n+\n+        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+            Some(rc) => match *rc {\n+                Decorator(ref dec) => {\n+                    let it = match a {\n+                        Annotatable::Item(ref it) => it,\n+                        // ItemDecorators are only implemented for Items.\n+                        _ => break,\n+                    };\n+\n+                    attr::mark_used(attr);\n+\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.get().to_string(),\n+                            format: MacroAttribute,\n+                            span: None\n+                        }\n+                    });\n+\n+                    // we'd ideally decorator_items.push_all(expand_item(item, fld)),\n+                    // but that double-mut-borrows fld\n+                    let mut items: SmallVector<P<ast::Item>> = SmallVector::zero();\n+                    dec.expand(fld.cx, attr.span, &*attr.node.value, &**it,\n+                               box |&mut: item| items.push(item));\n+                    decorator_items.extend(items.into_iter()\n+                        .flat_map(|item| expand_item(item, fld).into_iter()));\n+\n+                    fld.cx.bt_pop();\n+                }\n+                _ => new_attrs.push((*attr).clone()),\n+            },\n+            _ => new_attrs.push((*attr).clone()),\n+        }\n+    }\n+\n+    let mut new_items: SmallVector<Annotatable> = match a {\n+        Annotatable::Item(it) => match it.node {\n+            ast::ItemMac(..) => {\n+                expand_item_mac(it, fld).into_iter().map(|i| Annotatable::Item(i)).collect()\n+            }\n+            ast::ItemMod(_) | ast::ItemForeignMod(_) => {\n+                let valid_ident =\n+                    it.ident.name != parse::token::special_idents::invalid.name;\n+\n+                if valid_ident {\n+                    fld.cx.mod_push(it.ident);\n+                }\n+                let macro_use = contains_macro_use(fld, &new_attrs[]);\n+                let result = with_exts_frame!(fld.cx.syntax_env,\n+                                              macro_use,\n+                                              noop_fold_item(it, fld));\n+                if valid_ident {\n+                    fld.cx.mod_pop();\n+                }\n+                result.into_iter().map(|i| Annotatable::Item(i)).collect()\n+            },\n+            _ => {\n+                let it = P(ast::Item {\n+                    attrs: new_attrs,\n+                    ..(*it).clone()\n+                });\n+                noop_fold_item(it, fld).into_iter().map(|i| Annotatable::Item(i)).collect()\n+            }\n+        },\n+        Annotatable::TraitItem(it) => match it {\n+            ast::TraitItem::ProvidedMethod(m) => {\n+                expand_method(m, fld).into_iter().map(|m|\n+                    Annotatable::TraitItem(ast::TraitItem::ProvidedMethod(m))).collect()\n+            }\n+            ast::TraitItem::RequiredMethod(m) => {\n+                SmallVector::one(Annotatable::TraitItem(\n+                    ast::TraitItem::RequiredMethod(fld.fold_type_method(m))))\n+            }\n+            ast::TraitItem::TypeTraitItem(t) => {\n+                SmallVector::one(Annotatable::TraitItem(\n+                    ast::TraitItem::TypeTraitItem(P(fld.fold_associated_type((*t).clone())))))\n+            }\n+        },\n+        Annotatable::ImplItem(it) => match it {\n+            ast::ImplItem::MethodImplItem(m) => {\n+                expand_method(m, fld).into_iter().map(|m|\n+                    Annotatable::ImplItem(ast::ImplItem::MethodImplItem(m))).collect()\n+            }\n+            ast::ImplItem::TypeImplItem(t) => {\n+                SmallVector::one(Annotatable::ImplItem(\n+                    ast::ImplItem::TypeImplItem(P(fld.fold_typedef((*t).clone())))))\n+            }\n+        }\n+    };\n+\n+    new_items.push_all(decorator_items.into_iter().map(|i| Annotatable::Item(i)).collect());\n+    new_items\n+}\n+\n+fn expand_trait_item(i: ast::TraitItem,\n+                     fld: &mut MacroExpander)\n+                     -> SmallVector<ast::TraitItem> {\n+    expand_annotatable(Annotatable::TraitItem(i), fld)\n+        .into_iter().map(|i| i.expect_trait_item()).collect()\n+\n+}\n+\n+fn expand_impl_item(i: ast::ImplItem,\n+                    fld: &mut MacroExpander)\n+                    -> SmallVector<ast::ImplItem> {\n+    expand_annotatable(Annotatable::ImplItem(i), fld)\n+        .into_iter().map(|i| i.expect_impl_item()).collect()\n+}\n+\n+// partition the attributes into ItemModifiers and others\n+fn modifiers(attrs: &Vec<ast::Attribute>,\n+             fld: &MacroExpander)\n+             -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n+    attrs.iter().cloned().partition(|attr| {\n+        match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n+            Some(rc) => match *rc {\n+                Modifier(_) => true,\n+                _ => false\n+            },\n+            _ => false\n+        }\n+    })\n+}\n+\n+// partition the attributes into MultiModifiers and others\n+fn multi_modifiers(attrs: &[ast::Attribute],\n+                   fld: &MacroExpander)\n+                   -> (Vec<ast::Attribute>, Vec<ast::Attribute>) {\n+    attrs.iter().cloned().partition(|attr| {\n+        match fld.cx.syntax_env.find(&intern(attr.name().get())) {\n+            Some(rc) => match *rc {\n+                MultiModifier(_) => true,\n+                _ => false\n+            },\n+            _ => false\n+        }\n+    })\n+}\n+\n+fn expand_item_multi_modifier(mut it: Annotatable,\n+                              fld: &mut MacroExpander)\n+                              -> Annotatable {\n+    let (modifiers, other_attrs) = multi_modifiers(it.attrs(), fld);\n+\n+    // Update the attrs, leave everything else alone. Is this mutation really a good idea?\n+    it = it.fold_attrs(other_attrs);\n+\n+    if modifiers.is_empty() {\n+        return it\n+    }\n+\n+    for attr in modifiers.iter() {\n+        let mname = attr.name();\n+\n+        match fld.cx.syntax_env.find(&intern(mname.get())) {\n+            Some(rc) => match *rc {\n+                MultiModifier(ref mac) => {\n+                    attr::mark_used(attr);\n+                    fld.cx.bt_push(ExpnInfo {\n+                        call_site: attr.span,\n+                        callee: NameAndSpan {\n+                            name: mname.get().to_string(),\n+                            format: MacroAttribute,\n+                            span: None,\n+                        }\n+                    });\n+                    it = mac.expand(fld.cx, attr.span, &*attr.node.value, it);\n+                    fld.cx.bt_pop();\n+                }\n+                _ => unreachable!()\n+            },\n+            _ => unreachable!()\n+        }\n+    }\n+\n+    // Expansion may have added new ItemModifiers.\n+    expand_item_multi_modifier(it, fld)\n+}\n+\n // expand a method\n fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<ast::Method>> {\n     m.and_then(|m| match m.node {\n@@ -1042,7 +1172,7 @@ fn expand_method(m: P<ast::Method>, fld: &mut MacroExpander) -> SmallVector<P<as\n                       vis) => {\n             let id = fld.new_id(m.id);\n             let (rewritten_fn_decl, rewritten_body)\n-                = expand_and_rename_fn_decl_and_block(decl,body,fld);\n+                = expand_and_rename_fn_decl_and_block(decl, body, fld);\n             SmallVector::one(P(ast::Method {\n                     attrs: m.attrs.move_map(|a| fld.fold_attribute(a)),\n                     id: id,\n@@ -1147,6 +1277,14 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_arm(arm, self)\n     }\n \n+    fn fold_trait_item(&mut self, i: ast::TraitItem) -> SmallVector<ast::TraitItem> {\n+        expand_trait_item(i, self)\n+    }\n+\n+    fn fold_impl_item(&mut self, i: ast::ImplItem) -> SmallVector<ast::ImplItem> {\n+        expand_impl_item(i, self)\n+    }\n+\n     fn fold_method(&mut self, method: P<ast::Method>) -> SmallVector<P<ast::Method>> {\n         expand_method(method, self)\n     }"}, {"sha": "16c29c9b5eb33a4bc206baf8b39b477c3fb09064", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 45, "deletions": 42, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/98d4d4997e300bb712254a67184caf8892af4be0/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4d4997e300bb712254a67184caf8892af4be0/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=98d4d4997e300bb712254a67184caf8892af4be0", "patch": "@@ -102,6 +102,14 @@ pub trait Folder : Sized {\n         noop_fold_item_underscore(i, self)\n     }\n \n+    fn fold_trait_item(&mut self, i: TraitItem) -> SmallVector<TraitItem> {\n+        noop_fold_trait_item(i, self)\n+    }\n+\n+    fn fold_impl_item(&mut self, i: ImplItem) -> SmallVector<ImplItem> {\n+        noop_fold_impl_item(i, self)\n+    }\n+\n     fn fold_fn_decl(&mut self, d: P<FnDecl>) -> P<FnDecl> {\n         noop_fold_fn_decl(d, self)\n     }\n@@ -1007,21 +1015,9 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n         ItemImpl(unsafety, polarity, generics, ifce, ty, impl_items) => {\n-            let mut new_impl_items = Vec::new();\n-            for impl_item in impl_items.iter() {\n-                match *impl_item {\n-                    MethodImplItem(ref x) => {\n-                        for method in folder.fold_method((*x).clone())\n-                                            .into_iter() {\n-                            new_impl_items.push(MethodImplItem(method))\n-                        }\n-                    }\n-                    TypeImplItem(ref t) => {\n-                        new_impl_items.push(TypeImplItem(\n-                                P(folder.fold_typedef((**t).clone()))));\n-                    }\n-                }\n-            }\n+            let new_impl_items = impl_items.into_iter().flat_map(|item| {\n+                folder.fold_impl_item(item).into_iter()\n+            }).collect();\n             let ifce = match ifce {\n                 None => None,\n                 Some(ref trait_ref) => {\n@@ -1035,43 +1031,50 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n                      folder.fold_ty(ty),\n                      new_impl_items)\n         }\n-        ItemTrait(unsafety, generics, bounds, methods) => {\n+        ItemTrait(unsafety, generics, bounds, items) => {\n             let bounds = folder.fold_bounds(bounds);\n-            let methods = methods.into_iter().flat_map(|method| {\n-                let r = match method {\n-                    RequiredMethod(m) => {\n-                            SmallVector::one(RequiredMethod(\n-                                    folder.fold_type_method(m)))\n-                                .into_iter()\n-                    }\n-                    ProvidedMethod(method) => {\n-                        // the awkward collect/iter idiom here is because\n-                        // even though an iter and a map satisfy the same\n-                        // trait bound, they're not actually the same type, so\n-                        // the method arms don't unify.\n-                        let methods: SmallVector<ast::TraitItem> =\n-                            folder.fold_method(method).into_iter()\n-                            .map(|m| ProvidedMethod(m)).collect();\n-                        methods.into_iter()\n-                    }\n-                    TypeTraitItem(at) => {\n-                        SmallVector::one(TypeTraitItem(P(\n-                                    folder.fold_associated_type(\n-                                        (*at).clone()))))\n-                            .into_iter()\n-                    }\n-                };\n-                r\n+            let items = items.into_iter().flat_map(|item| {\n+                folder.fold_trait_item(item).into_iter()\n             }).collect();\n             ItemTrait(unsafety,\n                       folder.fold_generics(generics),\n                       bounds,\n-                      methods)\n+                      items)\n         }\n         ItemMac(m) => ItemMac(folder.fold_mac(m)),\n     }\n }\n \n+pub fn noop_fold_trait_item<T: Folder>(i: TraitItem, folder: &mut T) -> SmallVector<TraitItem> {\n+    match i {\n+        RequiredMethod(m) => {\n+                SmallVector::one(RequiredMethod(\n+                        folder.fold_type_method(m)))\n+        }\n+        ProvidedMethod(method) => {\n+            folder.fold_method(method).into_iter()\n+                .map(|m| ProvidedMethod(m)).collect()\n+        }\n+        TypeTraitItem(at) => {\n+            SmallVector::one(TypeTraitItem(P(\n+                        folder.fold_associated_type(\n+                            (*at).clone()))))\n+        }\n+    }\n+}\n+\n+pub fn noop_fold_impl_item<T: Folder>(i: ImplItem, folder: &mut T) -> SmallVector<ImplItem> {\n+    match i {\n+        MethodImplItem(ref x) => {\n+            folder.fold_method((*x).clone()).into_iter().map(|m| MethodImplItem(m)).collect()\n+        }\n+        TypeImplItem(ref t) => {\n+            SmallVector::one(TypeImplItem(\n+                    P(folder.fold_typedef((**t).clone()))))\n+        }\n+    }\n+}\n+\n pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMethod {\n     let TypeMethod {\n         id,"}, {"sha": "e3e91e05f55e9197b5e23fe9facff88c17d2626e", "filename": "src/test/auxiliary/macro_crate_test.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/98d4d4997e300bb712254a67184caf8892af4be0/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4d4997e300bb712254a67184caf8892af4be0/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fmacro_crate_test.rs?ref=98d4d4997e300bb712254a67184caf8892af4be0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -16,7 +16,7 @@\n extern crate syntax;\n extern crate rustc;\n \n-use syntax::ast::{TokenTree, Item, MetaItem};\n+use syntax::ast::{TokenTree, Item, MetaItem, ImplItem, TraitItem, Method};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n use syntax::parse::token;\n@@ -37,6 +37,9 @@ pub fn plugin_registrar(reg: &mut Registry) {\n     reg.register_syntax_extension(\n         token::intern(\"into_foo\"),\n         Modifier(box expand_into_foo));\n+    reg.register_syntax_extension(\n+        token::intern(\"into_multi_foo\"),\n+        MultiModifier(box expand_into_foo_multi));\n }\n \n fn expand_make_a_1(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree])\n@@ -65,6 +68,30 @@ fn expand_into_foo(cx: &mut ExtCtxt, sp: Span, attr: &MetaItem, it: P<Item>)\n     })\n }\n \n+fn expand_into_foo_multi(cx: &mut ExtCtxt,\n+                         sp: Span,\n+                         attr: &MetaItem,\n+                         it: Annotatable) -> Annotatable {\n+    match it {\n+        Annotatable::Item(it) => {\n+            Annotatable::Item(P(Item {\n+                attrs: it.attrs.clone(),\n+                ..(*quote_item!(cx, enum Foo2 { Bar2, Baz2 }).unwrap()).clone()\n+            }))\n+        }\n+        Annotatable::ImplItem(it) => {\n+            Annotatable::ImplItem(ImplItem::MethodImplItem(\n+                quote_method!(cx, fn foo(&self) -> i32 { 42 })\n+            ))\n+        }\n+        Annotatable::TraitItem(it) => {\n+            Annotatable::TraitItem(TraitItem::ProvidedMethod(\n+                quote_method!(cx, fn foo(&self) -> i32 { 0 })\n+            ))\n+        }\n+    }\n+}\n+\n fn expand_forged_ident(cx: &mut ExtCtxt, sp: Span, tts: &[TokenTree]) -> Box<MacResult+'static> {\n     use syntax::ext::quote::rt::*;\n "}, {"sha": "5236b35d4d2b9019254dec0dd8d2480a2d7961af", "filename": "src/test/run-pass-fulldeps/macro-crate.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/98d4d4997e300bb712254a67184caf8892af4be0/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98d4d4997e300bb712254a67184caf8892af4be0/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fmacro-crate.rs?ref=98d4d4997e300bb712254a67184caf8892af4be0", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2013-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -20,12 +20,36 @@ extern crate macro_crate_test;\n #[derive(PartialEq, Clone, Show)]\n fn foo() -> AFakeTypeThatHadBetterGoAway {}\n \n+#[into_multi_foo]\n+#[derive(PartialEq, Clone, Show)]\n+fn foo() -> AnotherFakeTypeThatHadBetterGoAway {}\n+\n+trait Qux {\n+    #[into_multi_foo]\n+    fn bar();\n+}\n+\n+impl Qux for i32 {\n+    #[into_multi_foo]\n+    fn bar() {}\n+}\n+\n+impl Qux for u8 {}\n+\n pub fn main() {\n     assert_eq!(1, make_a_1!());\n     assert_eq!(2, exported_macro!());\n \n     assert_eq!(Foo::Bar, Foo::Bar);\n     test(None::<Foo>);\n+\n+    assert_eq!(Foo2::Bar2, Foo2::Bar2);\n+    test(None::<Foo2>);\n+\n+    let x = 10i32;\n+    assert_eq!(x.foo(), 42);\n+    let x = 10u8;\n+    assert_eq!(x.foo(), 0);\n }\n \n fn test<T: PartialEq+Clone>(_: Option<T>) {}"}]}