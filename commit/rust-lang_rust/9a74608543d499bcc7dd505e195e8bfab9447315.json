{"sha": "9a74608543d499bcc7dd505e195e8bfab9447315", "node_id": "C_kwDOAAsO6NoAKDlhNzQ2MDg1NDNkNDk5YmNjN2RkNTA1ZTE5NWU4YmZhYjk0NDczMTU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-03T15:26:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-03T15:26:06Z"}, "message": "Auto merge of #97694 - Dylan-DPC:rollup-2yxo7ce, r=Dylan-DPC\n\nRollup of 3 pull requests\n\nSuccessful merges:\n\n - #97415 (Compute `is_late_bound_map` query separately from lifetime resolution)\n - #97471 (Provide more context when denying invalid type params )\n - #97681 (Add more eslint checks)\n\nFailed merges:\n\n - #97446 (Make hir().get_generics and generics_of consistent.)\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "efcb4d4a2294dcae517f2d690d3c544df5ce7511", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/efcb4d4a2294dcae517f2d690d3c544df5ce7511"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a74608543d499bcc7dd505e195e8bfab9447315", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a74608543d499bcc7dd505e195e8bfab9447315", "html_url": "https://github.com/rust-lang/rust/commit/9a74608543d499bcc7dd505e195e8bfab9447315", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a74608543d499bcc7dd505e195e8bfab9447315/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "url": "https://api.github.com/repos/rust-lang/rust/commits/e40d5e83dc133d093c22c7ff016b10daa4f40dcf", "html_url": "https://github.com/rust-lang/rust/commit/e40d5e83dc133d093c22c7ff016b10daa4f40dcf"}, {"sha": "5549d50ccf5c9f505672d9a1eb524e77aac95842", "url": "https://api.github.com/repos/rust-lang/rust/commits/5549d50ccf5c9f505672d9a1eb524e77aac95842", "html_url": "https://github.com/rust-lang/rust/commit/5549d50ccf5c9f505672d9a1eb524e77aac95842"}], "stats": {"total": 1792, "additions": 1211, "deletions": 581}, "files": [{"sha": "d1ea76b392223c9b76bf53c918b9c261e11d602d", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 17, "deletions": 24, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -672,9 +672,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             LifetimeRes::Param { .. } => {\n                 (hir::ParamName::Plain(ident), hir::LifetimeParamKind::Explicit)\n             }\n-            LifetimeRes::Fresh { param, .. } => {\n-                (hir::ParamName::Fresh(param), hir::LifetimeParamKind::Elided)\n-            }\n+            LifetimeRes::Fresh { .. } => (hir::ParamName::Fresh, hir::LifetimeParamKind::Elided),\n             LifetimeRes::Static | LifetimeRes::Error => return None,\n             res => panic!(\n                 \"Unexpected lifetime resolution {:?} for {:?} at {:?}\",\n@@ -1576,10 +1574,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     (hir::ParamName::Plain(ident), LifetimeRes::Param { param, binder: fn_node_id })\n                 }\n                 // Input lifetime like `'1`:\n-                LifetimeRes::Fresh { param, .. } => (\n-                    hir::ParamName::Fresh(outer_def_id),\n-                    LifetimeRes::Fresh { param, binder: fn_node_id },\n-                ),\n+                LifetimeRes::Fresh { param, .. } => {\n+                    (hir::ParamName::Fresh, LifetimeRes::Fresh { param, binder: fn_node_id })\n+                }\n                 LifetimeRes::Static | LifetimeRes::Error => continue,\n                 res => {\n                     panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span)\n@@ -1749,18 +1746,18 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     ) -> hir::Lifetime {\n         debug!(?self.captured_lifetimes);\n         let name = match res {\n-            LifetimeRes::Param { param, binder } => {\n+            LifetimeRes::Param { mut param, binder } => {\n                 debug_assert_ne!(ident.name, kw::UnderscoreLifetime);\n                 let p_name = ParamName::Plain(ident);\n                 if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n                     &mut self.captured_lifetimes\n                     && !binders_to_ignore.contains(&binder)\n                 {\n                     match captures.entry(param) {\n-                        Entry::Occupied(_) => {}\n+                        Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n                         Entry::Vacant(v) => {\n                             let p_id = self.resolver.next_node_id();\n-                            self.resolver.create_def(\n+                            let p_def_id = self.resolver.create_def(\n                                 *parent_def_id,\n                                 p_id,\n                                 DefPathData::LifetimeNs(p_name.ident().name),\n@@ -1769,10 +1766,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             );\n \n                             v.insert((span, p_id, p_name, res));\n+                            param = p_def_id;\n                         }\n                     }\n                 }\n-                hir::LifetimeName::Param(p_name)\n+                hir::LifetimeName::Param(param, p_name)\n             }\n             LifetimeRes::Fresh { mut param, binder } => {\n                 debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n@@ -1792,21 +1790,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                                 span.with_parent(None),\n                             );\n \n-                            let p_name = ParamName::Fresh(param);\n-                            v.insert((span, p_id, p_name, res));\n+                            v.insert((span, p_id, ParamName::Fresh, res));\n                             param = p_def_id;\n                         }\n                     }\n                 }\n-                let p_name = ParamName::Fresh(param);\n-                hir::LifetimeName::Param(p_name)\n+                hir::LifetimeName::Param(param, ParamName::Fresh)\n             }\n             LifetimeRes::Anonymous { binder, elided } => {\n-                let l_name = if elided {\n-                    hir::LifetimeName::Implicit\n-                } else {\n-                    hir::LifetimeName::Underscore\n-                };\n                 if let Some(LifetimeCaptureContext { parent_def_id, captures, binders_to_ignore }) =\n                     &mut self.captured_lifetimes\n                     && !binders_to_ignore.contains(&binder)\n@@ -1819,18 +1810,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         ExpnId::root(),\n                         span.with_parent(None),\n                     );\n-                    let p_name = ParamName::Fresh(p_def_id);\n-                    captures.insert(p_def_id, (span, p_id, p_name, res));\n-                    hir::LifetimeName::Param(p_name)\n+                    captures.insert(p_def_id, (span, p_id, ParamName::Fresh, res));\n+                    hir::LifetimeName::Param(p_def_id, ParamName::Fresh)\n+                } else if elided {\n+                    hir::LifetimeName::Implicit\n                 } else {\n-                    l_name\n+                    hir::LifetimeName::Underscore\n                 }\n             }\n             LifetimeRes::Static => hir::LifetimeName::Static,\n             LifetimeRes::Error => hir::LifetimeName::Error,\n             res => panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span),\n         };\n         debug!(?self.captured_lifetimes);\n+        debug!(?name);\n         hir::Lifetime { hir_id: self.lower_node_id(id), span: self.lower_span(span), name }\n     }\n "}, {"sha": "fcb6ae438fed9768726737a68858817e8593d9de", "filename": "compiler/rustc_borrowck/src/diagnostics/region_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_name.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -567,14 +567,14 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         let lifetime =\n             self.try_match_adt_and_generic_args(substs, needle_fr, args, search_stack)?;\n         match lifetime.name {\n-            hir::LifetimeName::Param(hir::ParamName::Plain(_) | hir::ParamName::Error)\n+            hir::LifetimeName::Param(_, hir::ParamName::Plain(_) | hir::ParamName::Error)\n             | hir::LifetimeName::Error\n             | hir::LifetimeName::Static => {\n                 let lifetime_span = lifetime.span;\n                 Some(RegionNameHighlight::MatchedAdtAndSegment(lifetime_span))\n             }\n \n-            hir::LifetimeName::Param(hir::ParamName::Fresh(_))\n+            hir::LifetimeName::Param(_, hir::ParamName::Fresh)\n             | hir::LifetimeName::ImplicitObjectLifetimeDefault\n             | hir::LifetimeName::Implicit\n             | hir::LifetimeName::Underscore => {"}, {"sha": "c2c093f9f2fc74e685b1589063b809c772f09702", "filename": "compiler/rustc_borrowck/src/universal_regions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Funiversal_regions.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -830,11 +830,11 @@ fn for_each_late_bound_region_defined_on<'tcx>(\n     fn_def_id: DefId,\n     mut f: impl FnMut(ty::Region<'tcx>),\n ) {\n-    if let Some((owner, late_bounds)) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n+    if let Some(late_bounds) = tcx.is_late_bound_map(fn_def_id.expect_local()) {\n         for &region_def_id in late_bounds.iter() {\n             let name = tcx.item_name(region_def_id.to_def_id());\n             let liberated_region = tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: owner.to_def_id(),\n+                scope: fn_def_id,\n                 bound_region: ty::BoundRegionKind::BrNamed(region_def_id.to_def_id(), name),\n             }));\n             f(liberated_region);"}, {"sha": "b98d4341118628544ae65a239477dba0fa74f66a", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 32, "deletions": 20, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -26,7 +26,7 @@ use rustc_target::spec::abi::Abi;\n use smallvec::SmallVec;\n use std::fmt;\n \n-#[derive(Copy, Clone, Encodable, HashStable_Generic)]\n+#[derive(Debug, Copy, Clone, Encodable, HashStable_Generic)]\n pub struct Lifetime {\n     pub hir_id: HirId,\n     pub span: Span,\n@@ -60,7 +60,7 @@ pub enum ParamName {\n     /// ```\n     /// where `'f` is something like `Fresh(0)`. The indices are\n     /// unique per impl, but not necessarily continuous.\n-    Fresh(LocalDefId),\n+    Fresh,\n \n     /// Indicates an illegal name was given and an error has been\n     /// reported (so we should squelch other derived errors). Occurs\n@@ -72,9 +72,7 @@ impl ParamName {\n     pub fn ident(&self) -> Ident {\n         match *self {\n             ParamName::Plain(ident) => ident,\n-            ParamName::Fresh(_) | ParamName::Error => {\n-                Ident::with_dummy_span(kw::UnderscoreLifetime)\n-            }\n+            ParamName::Fresh | ParamName::Error => Ident::with_dummy_span(kw::UnderscoreLifetime),\n         }\n     }\n \n@@ -90,7 +88,7 @@ impl ParamName {\n #[derive(HashStable_Generic)]\n pub enum LifetimeName {\n     /// User-given names or fresh (synthetic) names.\n-    Param(ParamName),\n+    Param(LocalDefId, ParamName),\n \n     /// User wrote nothing (e.g., the lifetime in `&u32`).\n     Implicit,\n@@ -127,7 +125,7 @@ impl LifetimeName {\n             | LifetimeName::Error => Ident::empty(),\n             LifetimeName::Underscore => Ident::with_dummy_span(kw::UnderscoreLifetime),\n             LifetimeName::Static => Ident::with_dummy_span(kw::StaticLifetime),\n-            LifetimeName::Param(param_name) => param_name.ident(),\n+            LifetimeName::Param(_, param_name) => param_name.ident(),\n         }\n     }\n \n@@ -136,9 +134,9 @@ impl LifetimeName {\n             LifetimeName::ImplicitObjectLifetimeDefault\n             | LifetimeName::Implicit\n             | LifetimeName::Underscore\n-            | LifetimeName::Param(ParamName::Fresh(_))\n+            | LifetimeName::Param(_, ParamName::Fresh)\n             | LifetimeName::Error => true,\n-            LifetimeName::Static | LifetimeName::Param(_) => false,\n+            LifetimeName::Static | LifetimeName::Param(..) => false,\n         }\n     }\n \n@@ -148,12 +146,12 @@ impl LifetimeName {\n             | LifetimeName::Implicit\n             | LifetimeName::Underscore => true,\n \n-            // It might seem surprising that `Fresh(_)` counts as\n+            // It might seem surprising that `Fresh` counts as\n             // *not* elided -- but this is because, as far as the code\n-            // in the compiler is concerned -- `Fresh(_)` variants act\n+            // in the compiler is concerned -- `Fresh` variants act\n             // equivalently to \"some fresh name\". They correspond to\n             // early-bound regions on an impl, in other words.\n-            LifetimeName::Error | LifetimeName::Param(_) | LifetimeName::Static => false,\n+            LifetimeName::Error | LifetimeName::Param(..) | LifetimeName::Static => false,\n         }\n     }\n \n@@ -163,8 +161,8 @@ impl LifetimeName {\n \n     pub fn normalize_to_macros_2_0(&self) -> LifetimeName {\n         match *self {\n-            LifetimeName::Param(param_name) => {\n-                LifetimeName::Param(param_name.normalize_to_macros_2_0())\n+            LifetimeName::Param(def_id, param_name) => {\n+                LifetimeName::Param(def_id, param_name.normalize_to_macros_2_0())\n             }\n             lifetime_name => lifetime_name,\n         }\n@@ -177,12 +175,6 @@ impl fmt::Display for Lifetime {\n     }\n }\n \n-impl fmt::Debug for Lifetime {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"lifetime({}: {})\", self.hir_id, self.name.ident())\n-    }\n-}\n-\n impl Lifetime {\n     pub fn is_elided(&self) -> bool {\n         self.name.is_elided()\n@@ -628,6 +620,16 @@ impl<'hir> Generics<'hir> {\n         })\n     }\n \n+    pub fn outlives_for_param(\n+        &self,\n+        param_def_id: LocalDefId,\n+    ) -> impl Iterator<Item = &WhereRegionPredicate<'_>> {\n+        self.predicates.iter().filter_map(move |pred| match pred {\n+            WherePredicate::RegionPredicate(rp) if rp.is_param_bound(param_def_id) => Some(rp),\n+            _ => None,\n+        })\n+    }\n+\n     pub fn bounds_span_for_suggestions(&self, param_def_id: LocalDefId) -> Option<Span> {\n         self.bounds_for_param(param_def_id).flat_map(|bp| bp.bounds.iter().rev()).find_map(\n             |bound| {\n@@ -769,6 +771,16 @@ pub struct WhereRegionPredicate<'hir> {\n     pub bounds: GenericBounds<'hir>,\n }\n \n+impl<'hir> WhereRegionPredicate<'hir> {\n+    /// Returns `true` if `param_def_id` matches the `lifetime` of this predicate.\n+    pub fn is_param_bound(&self, param_def_id: LocalDefId) -> bool {\n+        match self.lifetime.name {\n+            LifetimeName::Param(id, _) => id == param_def_id,\n+            _ => false,\n+        }\n+    }\n+}\n+\n /// An equality predicate (e.g., `T = int`); currently unsupported.\n #[derive(Debug, HashStable_Generic)]\n pub struct WhereEqPredicate<'hir> {"}, {"sha": "bd8587f1106e9ad708fbf007bbbec54e73d64e1c", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -510,11 +510,11 @@ pub fn walk_label<'v, V: Visitor<'v>>(visitor: &mut V, label: &'v Label) {\n pub fn walk_lifetime<'v, V: Visitor<'v>>(visitor: &mut V, lifetime: &'v Lifetime) {\n     visitor.visit_id(lifetime.hir_id);\n     match lifetime.name {\n-        LifetimeName::Param(ParamName::Plain(ident)) => {\n+        LifetimeName::Param(_, ParamName::Plain(ident)) => {\n             visitor.visit_ident(ident);\n         }\n-        LifetimeName::Param(ParamName::Fresh(_))\n-        | LifetimeName::Param(ParamName::Error)\n+        LifetimeName::Param(_, ParamName::Fresh)\n+        | LifetimeName::Param(_, ParamName::Error)\n         | LifetimeName::Static\n         | LifetimeName::Error\n         | LifetimeName::Implicit\n@@ -879,7 +879,7 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n     visitor.visit_id(param.hir_id);\n     match param.name {\n         ParamName::Plain(ident) => visitor.visit_ident(ident),\n-        ParamName::Error | ParamName::Fresh(_) => {}\n+        ParamName::Error | ParamName::Fresh => {}\n     }\n     match param.kind {\n         GenericParamKind::Lifetime { .. } => {}"}, {"sha": "aab84b718d406ec00caeb2e301b1025ad3325ee1", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -364,7 +364,11 @@ impl<'hir> Map<'hir> {\n         match node.node {\n             OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),\n             OwnerNode::TraitItem(trait_item) => Some(&trait_item.generics),\n-            OwnerNode::Item(Item {\n+            OwnerNode::ForeignItem(ForeignItem {\n+                kind: ForeignItemKind::Fn(_, _, generics),\n+                ..\n+            })\n+            | OwnerNode::Item(Item {\n                 kind:\n                     ItemKind::Fn(_, generics, _)\n                     | ItemKind::TyAlias(_, generics)"}, {"sha": "cdc0d07680193ef54818efa149a235e4d4b8b0db", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -6,7 +6,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::ItemLocalId;\n use rustc_macros::HashStable;\n-use rustc_span::symbol::Symbol;\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum Region {\n@@ -22,12 +21,12 @@ pub enum Region {\n /// so that we can e.g. suggest elided-lifetimes-in-paths of the form <'_, '_> e.g.\n #[derive(Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, HashStable)]\n pub enum LifetimeScopeForPath {\n-    // Contains all lifetime names that are in scope and could possibly be used in generics\n-    // arguments of path.\n-    NonElided(Vec<Symbol>),\n+    /// Contains all lifetime names that are in scope and could possibly be used in generics\n+    /// arguments of path.\n+    NonElided(Vec<LocalDefId>),\n \n-    // Information that allows us to suggest args of the form `<'_>` in case\n-    // no generic arguments were provided for a path.\n+    /// Information that allows us to suggest args of the form `<'_>` in case\n+    /// no generic arguments were provided for a path.\n     Elided,\n }\n "}, {"sha": "899d6c7e490a60416802322c3c208eabbe8cae9c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1584,7 +1584,7 @@ rustc_queries! {\n         Option<&'tcx FxHashMap<ItemLocalId, Region>> {\n         desc { \"looking up a named region\" }\n     }\n-    query is_late_bound_map(_: LocalDefId) -> Option<(LocalDefId, &'tcx FxHashSet<LocalDefId>)> {\n+    query is_late_bound_map(_: LocalDefId) -> Option<&'tcx FxHashSet<LocalDefId>> {\n         desc { \"testing if a region is late bound\" }\n     }\n     /// For a given item (like a struct), gets the default lifetimes to be used"}, {"sha": "72e2beb372d3ca117e15ca8a56568679286fef34", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -2803,6 +2803,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.named_region_map(id.owner).and_then(|map| map.get(&id.local_id).cloned())\n     }\n \n+    pub fn is_late_bound(self, id: HirId) -> bool {\n+        self.is_late_bound_map(id.owner).map_or(false, |set| {\n+            let def_id = self.hir().local_def_id(id);\n+            set.contains(&def_id)\n+        })\n+    }\n+\n     pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n         self.mk_bound_variable_kinds(\n             self.late_bound_vars_map(id.owner)"}, {"sha": "cb39eb5416ba27dbc2822d8529ffb2d32ef6b870", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -13,15 +13,15 @@ use rustc_ast::{\n };\n use rustc_ast_lowering::ResolverAstLowering;\n use rustc_ast_pretty::pprust::path_segment_to_string;\n-use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::fx::{FxHashSet, FxIndexSet};\n use rustc_errors::{\n     pluralize, struct_span_err, Applicability, Diagnostic, DiagnosticBuilder, ErrorGuaranteed,\n     MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, CtorOf, DefKind};\n-use rustc_hir::def_id::{DefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_hir::PrimTy;\n use rustc_session::lint;\n use rustc_session::parse::feature_err;\n@@ -2082,7 +2082,7 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n \n     /// Returns whether to add `'static` lifetime to the suggested lifetime list.\n     pub(crate) fn report_elision_failure(\n-        &mut self,\n+        &self,\n         diag: &mut Diagnostic,\n         params: &[ElisionFailureInfo],\n     ) -> bool {\n@@ -2187,10 +2187,27 @@ impl<'tcx> LifetimeContext<'_, 'tcx> {\n         &self,\n         err: &mut Diagnostic,\n         mut spans_with_counts: Vec<(Span, usize)>,\n-        lifetime_names: &FxHashSet<Symbol>,\n-        lifetime_spans: Vec<Span>,\n-        params: &[ElisionFailureInfo],\n+        in_scope_lifetimes: FxIndexSet<LocalDefId>,\n+        params: Option<&[ElisionFailureInfo]>,\n     ) {\n+        let (mut lifetime_names, lifetime_spans): (FxHashSet<_>, Vec<_>) = in_scope_lifetimes\n+            .iter()\n+            .filter_map(|def_id| {\n+                let name = self.tcx.item_name(def_id.to_def_id());\n+                let span = self.tcx.def_ident_span(def_id.to_def_id())?;\n+                Some((name, span))\n+            })\n+            .filter(|&(n, _)| n != kw::UnderscoreLifetime)\n+            .unzip();\n+\n+        if let Some(params) = params {\n+            // If there's no lifetime available, suggest `'static`.\n+            if self.report_elision_failure(err, params) && lifetime_names.is_empty() {\n+                lifetime_names.insert(kw::StaticLifetime);\n+            }\n+        }\n+        let params = params.unwrap_or(&[]);\n+\n         let snippets: Vec<Option<String>> = spans_with_counts\n             .iter()\n             .map(|(span, _)| self.tcx.sess.source_map().span_to_snippet(*span).ok())"}, {"sha": "11f80b314d7702171607eed088358b860c830bce", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 85, "deletions": 148, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -8,19 +8,19 @@\n \n use crate::late::diagnostics::{ForLifetimeSpanType, MissingLifetimeSpot};\n use rustc_ast::walk_list;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet};\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::{DefIdMap, LocalDefId};\n use rustc_hir::hir_id::ItemLocalId;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node, ParamName};\n-use rustc_hir::{GenericParamKind, HirIdMap, HirIdSet};\n+use rustc_hir::{GenericArg, GenericParam, LifetimeName, Node};\n+use rustc_hir::{GenericParamKind, HirIdMap};\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::middle::resolve_lifetime::*;\n-use rustc_middle::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n+use rustc_middle::ty::{self, GenericParamDefKind, TyCtxt};\n use rustc_middle::{bug, span_bug};\n use rustc_span::def_id::DefId;\n use rustc_span::symbol::{kw, sym, Ident};\n@@ -33,9 +33,9 @@ use std::mem::take;\n use tracing::{debug, span, Level};\n \n trait RegionExt {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n-    fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region);\n+    fn late(index: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region);\n \n     fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region;\n \n@@ -51,22 +51,22 @@ trait RegionExt {\n }\n \n impl RegionExt for Region {\n-    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn early(hir_map: Map<'_>, index: &mut u32, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n         let i = *index;\n         *index += 1;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         debug!(\"Region::early: index={} def_id={:?}\", i, def_id);\n-        (param.name.normalize_to_macros_2_0(), Region::EarlyBound(i, def_id.to_def_id()))\n+        (def_id, Region::EarlyBound(i, def_id.to_def_id()))\n     }\n \n-    fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region) {\n+    fn late(idx: u32, hir_map: Map<'_>, param: &GenericParam<'_>) -> (LocalDefId, Region) {\n         let depth = ty::INNERMOST;\n         let def_id = hir_map.local_def_id(param.hir_id);\n         debug!(\n             \"Region::late: idx={:?}, param={:?} depth={:?} def_id={:?}\",\n             idx, param, depth, def_id,\n         );\n-        (param.name.normalize_to_macros_2_0(), Region::LateBound(depth, idx, def_id.to_def_id()))\n+        (def_id, Region::LateBound(depth, idx, def_id.to_def_id()))\n     }\n \n     fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region {\n@@ -134,11 +134,6 @@ struct NamedRegionMap {\n     // `Region` describing how that region is bound\n     defs: HirIdMap<Region>,\n \n-    // the set of lifetime def ids that are late-bound; a region can\n-    // be late-bound if (a) it does NOT appear in a where-clause and\n-    // (b) it DOES appear in the arguments.\n-    late_bound: HirIdSet,\n-\n     // Maps relevant hir items to the bound vars on them. These include:\n     // - function defs\n     // - function pointers\n@@ -178,7 +173,7 @@ enum Scope<'a> {\n     Binder {\n         /// We use an IndexMap here because we want these lifetimes in order\n         /// for diagnostics.\n-        lifetimes: FxIndexMap<hir::ParamName, Region>,\n+        lifetimes: FxIndexMap<LocalDefId, Region>,\n \n         /// if we extend this scope with another scope, what is the next index\n         /// we should use for an early-bound region?\n@@ -402,15 +397,15 @@ fn resolve_lifetimes_trait_definition(\n     tcx: TyCtxt<'_>,\n     local_def_id: LocalDefId,\n ) -> ResolveLifetimes {\n-    convert_named_region_map(tcx, do_resolve(tcx, local_def_id, true, false))\n+    convert_named_region_map(do_resolve(tcx, local_def_id, true, false))\n }\n \n /// Computes the `ResolveLifetimes` map that contains data for an entire `Item`.\n /// You should not read the result of this query directly, but rather use\n /// `named_region_map`, `is_late_bound_map`, etc.\n #[tracing::instrument(level = \"debug\", skip(tcx))]\n fn resolve_lifetimes(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> ResolveLifetimes {\n-    convert_named_region_map(tcx, do_resolve(tcx, local_def_id, false, false))\n+    convert_named_region_map(do_resolve(tcx, local_def_id, false, false))\n }\n \n fn do_resolve(\n@@ -422,7 +417,6 @@ fn do_resolve(\n     let item = tcx.hir().expect_item(local_def_id);\n     let mut named_region_map = NamedRegionMap {\n         defs: Default::default(),\n-        late_bound: Default::default(),\n         late_bound_vars: Default::default(),\n         scope_for_path: with_scope_for_path.then(|| Default::default()),\n     };\n@@ -439,18 +433,13 @@ fn do_resolve(\n     named_region_map\n }\n \n-fn convert_named_region_map(tcx: TyCtxt<'_>, named_region_map: NamedRegionMap) -> ResolveLifetimes {\n+fn convert_named_region_map(named_region_map: NamedRegionMap) -> ResolveLifetimes {\n     let mut rl = ResolveLifetimes::default();\n \n     for (hir_id, v) in named_region_map.defs {\n         let map = rl.defs.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n     }\n-    for hir_id in named_region_map.late_bound {\n-        let map = rl.late_bound.entry(hir_id.owner).or_default();\n-        let def_id = tcx.hir().local_def_id(hir_id);\n-        map.insert(def_id);\n-    }\n     for (hir_id, v) in named_region_map.late_bound_vars {\n         let map = rl.late_bound_vars.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id, v);\n@@ -506,28 +495,6 @@ fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n     item\n }\n \n-fn is_late_bound_map<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n-) -> Option<(LocalDefId, &'tcx FxHashSet<LocalDefId>)> {\n-    match tcx.def_kind(def_id) {\n-        DefKind::AnonConst | DefKind::InlineConst => {\n-            let mut def_id = tcx.local_parent(def_id);\n-            // We search for the next outer anon const or fn here\n-            // while skipping closures.\n-            //\n-            // Note that for `AnonConst` we still just recurse until we\n-            // find a function body, but who cares :shrug:\n-            while tcx.is_closure(def_id.to_def_id()) {\n-                def_id = tcx.local_parent(def_id);\n-            }\n-\n-            tcx.is_late_bound_map(def_id)\n-        }\n-        _ => resolve_lifetimes_for(tcx, def_id).late_bound.get(&def_id).map(|lt| (def_id, lt)),\n-    }\n-}\n-\n /// In traits, there is an implicit `Self` type parameter which comes before the generics.\n /// We have to account for this when computing the index of the other generic parameters.\n /// This function returns whether there is such an implicit parameter defined on the given item.\n@@ -554,10 +521,7 @@ fn get_lifetime_scopes_for_path(mut scope: &Scope<'_>) -> LifetimeScopeForPath {\n     loop {\n         match scope {\n             Scope::Binder { lifetimes, s, .. } => {\n-                available_lifetimes.extend(lifetimes.keys().filter_map(|p| match p {\n-                    hir::ParamName::Plain(ident) => Some(ident.name),\n-                    _ => None,\n-                }));\n+                available_lifetimes.extend(lifetimes.keys());\n                 scope = s;\n             }\n             Scope::Body { s, .. } => {\n@@ -690,9 +654,9 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             _ => {}\n         }\n         match item.kind {\n-            hir::ItemKind::Fn(ref sig, ref generics, _) => {\n+            hir::ItemKind::Fn(_, ref generics, _) => {\n                 self.missing_named_lifetime_spots.push(generics.into());\n-                self.visit_early_late(None, item.hir_id(), &sig.decl, generics, |this| {\n+                self.visit_early_late(None, item.hir_id(), generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n                 self.missing_named_lifetime_spots.pop();\n@@ -734,13 +698,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                     self.map.defs.insert(hir::HirId { owner, local_id }, *region);\n                                 });\n                             }\n-                            for (&owner, late_bound) in resolved_lifetimes.late_bound.iter() {\n-                                late_bound.iter().for_each(|&id| {\n-                                    let hir_id = self.tcx.local_def_id_to_hir_id(id);\n-                                    debug_assert_eq!(owner, hir_id.owner);\n-                                    self.map.late_bound.insert(hir_id);\n-                                });\n-                            }\n                             for (&owner, late_bound_vars) in\n                                 resolved_lifetimes.late_bound_vars.iter()\n                             {\n@@ -810,8 +767,8 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n-            hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n-                self.visit_early_late(None, item.hir_id(), decl, generics, |this| {\n+            hir::ForeignItemKind::Fn(_, _, ref generics) => {\n+                self.visit_early_late(None, item.hir_id(), generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n@@ -841,7 +798,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.missing_named_lifetime_spots\n                     .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n-                let (lifetimes, binders): (FxIndexMap<hir::ParamName, Region>, Vec<_>) = c\n+                let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) = c\n                     .generic_params\n                     .iter()\n                     .filter(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n@@ -898,7 +855,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // cc #48468\n                         self.resolve_elided_lifetimes(&[lifetime])\n                     }\n-                    LifetimeName::Param(_) | LifetimeName::Static => {\n+                    LifetimeName::Param(..) | LifetimeName::Static => {\n                         // If the user wrote an explicit name, use that.\n                         self.visit_lifetime(lifetime);\n                     }\n@@ -1016,17 +973,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 for param in generics.params {\n                     match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            let (name, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n+                            let (def_id, reg) = Region::early(self.tcx.hir(), &mut index, &param);\n                             if let hir::ParamName::Plain(Ident {\n                                 name: kw::UnderscoreLifetime,\n                                 ..\n-                            }) = name\n+                            }) = param.name\n                             {\n                                 // Pick the elided lifetime \"definition\" if one exists\n                                 // and use it to make an elision scope.\n                                 elision = Some(reg);\n                             } else {\n-                                lifetimes.insert(name, reg);\n+                                lifetimes.insert(def_id, reg);\n                             }\n                         }\n                         GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n@@ -1088,13 +1045,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n         use self::hir::TraitItemKind::*;\n         match trait_item.kind {\n-            Fn(ref sig, _) => {\n+            Fn(_, _) => {\n                 self.missing_named_lifetime_spots.push((&trait_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n                     trait_item.hir_id(),\n-                    &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n                 );\n@@ -1156,13 +1112,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n         use self::hir::ImplItemKind::*;\n         match impl_item.kind {\n-            Fn(ref sig, _) => {\n+            Fn(..) => {\n                 self.missing_named_lifetime_spots.push((&impl_item.generics).into());\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n                     impl_item.hir_id(),\n-                    &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n                 );\n@@ -1174,7 +1129,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut non_lifetime_count = 0;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes: FxIndexMap<hir::ParamName, Region> = generics\n+                let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n@@ -1218,15 +1173,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_lifetime(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n-        if lifetime_ref.is_elided() {\n-            self.resolve_elided_lifetimes(&[lifetime_ref]);\n-            return;\n-        }\n-        if lifetime_ref.is_static() {\n-            self.insert_lifetime(lifetime_ref, Region::Static);\n-            return;\n+        match lifetime_ref.name {\n+            hir::LifetimeName::ImplicitObjectLifetimeDefault\n+            | hir::LifetimeName::Implicit\n+            | hir::LifetimeName::Underscore => self.resolve_elided_lifetimes(&[lifetime_ref]),\n+            hir::LifetimeName::Static => self.insert_lifetime(lifetime_ref, Region::Static),\n+            hir::LifetimeName::Param(param_def_id, _) => {\n+                self.resolve_lifetime_ref(param_def_id, lifetime_ref)\n+            }\n+            // If we've already reported an error, just ignore `lifetime_ref`.\n+            hir::LifetimeName::Error => {}\n         }\n-        self.resolve_lifetime_ref(lifetime_ref);\n     }\n \n     fn visit_assoc_type_binding(&mut self, type_binding: &'tcx hir::TypeBinding<'_>) {\n@@ -1311,7 +1268,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         ref bound_generic_params,\n                         ..\n                     }) => {\n-                        let (lifetimes, binders): (FxIndexMap<hir::ParamName, Region>, Vec<_>) =\n+                        let (lifetimes, binders): (FxIndexMap<LocalDefId, Region>, Vec<_>) =\n                             bound_generic_params\n                                 .iter()\n                                 .filter(|param| {\n@@ -1433,7 +1390,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         let (mut binders, scope_type) = self.poly_trait_ref_binder_info();\n \n         let initial_bound_vars = binders.len() as u32;\n-        let mut lifetimes: FxIndexMap<hir::ParamName, Region> = FxIndexMap::default();\n+        let mut lifetimes: FxIndexMap<LocalDefId, Region> = FxIndexMap::default();\n         let binders_iter = trait_ref\n             .bound_generic_params\n             .iter()\n@@ -1580,14 +1537,17 @@ fn object_lifetime_defaults_for_item<'tcx>(\n                             .iter()\n                             .filter_map(|param| match param.kind {\n                                 GenericParamKind::Lifetime { .. } => {\n-                                    Some((param.hir_id, hir::LifetimeName::Param(param.name)))\n+                                    let param_def_id = tcx.hir().local_def_id(param.hir_id);\n+                                    Some((\n+                                        param_def_id,\n+                                        hir::LifetimeName::Param(param_def_id, param.name),\n+                                    ))\n                                 }\n                                 _ => None,\n                             })\n                             .enumerate()\n                             .find(|&(_, (_, lt_name))| lt_name == name)\n-                            .map_or(Set1::Many, |(i, (id, _))| {\n-                                let def_id = tcx.hir().local_def_id(id);\n+                            .map_or(Set1::Many, |(i, (def_id, _))| {\n                                 Set1::One(Region::EarlyBound(i as u32, def_id.to_def_id()))\n                             })\n                     }\n@@ -1654,14 +1614,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         &mut self,\n         parent_id: Option<LocalDefId>,\n         hir_id: hir::HirId,\n-        decl: &'tcx hir::FnDecl<'tcx>,\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n     ) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n-        insert_late_bound_lifetimes(self.map, decl, generics);\n-\n         // Find the start of nested early scopes, e.g., in methods.\n         let mut next_early_index = 0;\n         if let Some(parent_id) = parent_id {\n@@ -1680,12 +1637,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut non_lifetime_count = 0;\n         let mut named_late_bound_vars = 0;\n-        let lifetimes: FxIndexMap<hir::ParamName, Region> = generics\n+        let lifetimes: FxIndexMap<LocalDefId, Region> = generics\n             .params\n             .iter()\n             .filter_map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n-                    if self.map.late_bound.contains(&param.hir_id) {\n+                    if self.tcx.is_late_bound(param.hir_id) {\n                         let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n                         Some(Region::late(late_bound_idx, self.tcx.hir(), param))\n@@ -1706,7 +1663,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             .iter()\n             .filter(|param| {\n                 matches!(param.kind, GenericParamKind::Lifetime { .. })\n-                    && self.map.late_bound.contains(&param.hir_id)\n+                    && self.tcx.is_late_bound(param.hir_id)\n             })\n             .enumerate()\n             .map(|(late_bound_idx, param)| {\n@@ -1763,14 +1720,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.next_early_index_helper(false)\n     }\n \n-    fn resolve_lifetime_ref(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n-        debug!(\"resolve_lifetime_ref(lifetime_ref={:?})\", lifetime_ref);\n-\n-        // If we've already reported an error, just ignore `lifetime_ref`.\n-        if let LifetimeName::Error = lifetime_ref.name {\n-            return;\n-        }\n-\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn resolve_lifetime_ref(\n+        &mut self,\n+        region_def_id: LocalDefId,\n+        lifetime_ref: &'tcx hir::Lifetime,\n+    ) {\n         // Walk up the scope chain, tracking the number of fn scopes\n         // that we pass through, until we find a lifetime with the\n         // given name or we run out of scopes.\n@@ -1790,14 +1745,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n \n                 Scope::Binder { ref lifetimes, scope_type, s, .. } => {\n-                    match lifetime_ref.name {\n-                        LifetimeName::Param(param_name) => {\n-                            if let Some(&def) = lifetimes.get(&param_name.normalize_to_macros_2_0())\n-                            {\n-                                break Some(def.shifted(late_depth));\n-                            }\n-                        }\n-                        _ => bug!(\"expected LifetimeName::Param\"),\n+                    if let Some(&def) = lifetimes.get(&region_def_id) {\n+                        break Some(def.shifted(late_depth));\n                     }\n                     match scope_type {\n                         BinderScopeType::Normal => late_depth += 1,\n@@ -2473,8 +2422,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut late_depth = 0;\n         let mut scope = self.scope;\n-        let mut lifetime_names = FxHashSet::default();\n-        let mut lifetime_spans = vec![];\n+        let mut in_scope_lifetimes = FxIndexSet::default();\n         let error = loop {\n             match *scope {\n                 // Do not assign any resolution, it will be inferred.\n@@ -2484,12 +2432,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Binder { s, ref lifetimes, scope_type, .. } => {\n                     // collect named lifetimes for suggestions\n-                    for name in lifetimes.keys() {\n-                        if let hir::ParamName::Plain(name) = name {\n-                            lifetime_names.insert(name.name);\n-                            lifetime_spans.push(name.span);\n-                        }\n-                    }\n+                    in_scope_lifetimes.extend(lifetimes.keys().copied());\n                     match scope_type {\n                         BinderScopeType::Normal => late_depth += 1,\n                         BinderScopeType::Concatenating => {}\n@@ -2524,12 +2467,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         match scope {\n                             Scope::Binder { ref lifetimes, s, .. } => {\n                                 // Collect named lifetimes for suggestions.\n-                                for name in lifetimes.keys() {\n-                                    if let hir::ParamName::Plain(name) = name {\n-                                        lifetime_names.insert(name.name);\n-                                        lifetime_spans.push(name.span);\n-                                    }\n-                                }\n+                                in_scope_lifetimes.extend(lifetimes.keys().copied());\n                                 scope = s;\n                             }\n                             Scope::ObjectLifetimeDefault { ref s, .. }\n@@ -2574,19 +2512,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let mut err = self.report_missing_lifetime_specifiers(spans.clone(), lifetime_refs.len());\n \n-        if let Some(params) = error {\n-            // If there's no lifetime available, suggest `'static`.\n-            if self.report_elision_failure(&mut err, params) && lifetime_names.is_empty() {\n-                lifetime_names.insert(kw::StaticLifetime);\n-            }\n-        }\n-\n         self.add_missing_lifetime_specifiers_label(\n             &mut err,\n             spans_with_counts,\n-            &lifetime_names,\n-            lifetime_spans,\n-            error.unwrap_or(&[]),\n+            in_scope_lifetimes,\n+            error,\n         );\n         err.emit();\n     }\n@@ -2638,7 +2568,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n }\n \n /// Detects late-bound lifetimes and inserts them into\n-/// `map.late_bound`.\n+/// `late_bound`.\n ///\n /// A region declared on a fn is **late-bound** if:\n /// - it is constrained by an argument type;\n@@ -2647,12 +2577,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// \"Constrained\" basically means that it appears in any type but\n /// not amongst the inputs to a projection. In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n-#[tracing::instrument(level = \"debug\", skip(map))]\n-fn insert_late_bound_lifetimes(\n-    map: &mut NamedRegionMap,\n-    decl: &hir::FnDecl<'_>,\n-    generics: &hir::Generics<'_>,\n-) {\n+fn is_late_bound_map(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<&FxHashSet<LocalDefId>> {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+    let decl = tcx.hir().fn_decl_by_hir_id(hir_id)?;\n+    let generics = tcx.hir().get_generics(def_id)?;\n+\n+    let mut late_bound = FxHashSet::default();\n+\n     let mut constrained_by_input = ConstrainedCollector::default();\n     for arg_ty in decl.inputs {\n         constrained_by_input.visit_ty(arg_ty);\n@@ -2683,30 +2614,32 @@ fn insert_late_bound_lifetimes(\n             hir::GenericParamKind::Type { .. } | hir::GenericParamKind::Const { .. } => continue,\n         }\n \n-        let lt_name = hir::LifetimeName::Param(param.name.normalize_to_macros_2_0());\n+        let param_def_id = tcx.hir().local_def_id(param.hir_id);\n+\n         // appears in the where clauses? early-bound.\n-        if appears_in_where_clause.regions.contains(&lt_name) {\n+        if appears_in_where_clause.regions.contains(&param_def_id) {\n             continue;\n         }\n \n         // does not appear in the inputs, but appears in the return type? early-bound.\n-        if !constrained_by_input.regions.contains(&lt_name)\n-            && appears_in_output.regions.contains(&lt_name)\n+        if !constrained_by_input.regions.contains(&param_def_id)\n+            && appears_in_output.regions.contains(&param_def_id)\n         {\n             continue;\n         }\n \n         debug!(\"lifetime {:?} with id {:?} is late-bound\", param.name.ident(), param.hir_id);\n \n-        let inserted = map.late_bound.insert(param.hir_id);\n+        let inserted = late_bound.insert(param_def_id);\n         assert!(inserted, \"visited lifetime {:?} twice\", param.hir_id);\n     }\n \n-    return;\n+    debug!(?late_bound);\n+    return Some(tcx.arena.alloc(late_bound));\n \n     #[derive(Default)]\n     struct ConstrainedCollector {\n-        regions: FxHashSet<hir::LifetimeName>,\n+        regions: FxHashSet<LocalDefId>,\n     }\n \n     impl<'v> Visitor<'v> for ConstrainedCollector {\n@@ -2738,18 +2671,22 @@ fn insert_late_bound_lifetimes(\n         }\n \n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n+            if let hir::LifetimeName::Param(def_id, _) = lifetime_ref.name {\n+                self.regions.insert(def_id);\n+            }\n         }\n     }\n \n     #[derive(Default)]\n     struct AllCollector {\n-        regions: FxHashSet<hir::LifetimeName>,\n+        regions: FxHashSet<LocalDefId>,\n     }\n \n     impl<'v> Visitor<'v> for AllCollector {\n         fn visit_lifetime(&mut self, lifetime_ref: &'v hir::Lifetime) {\n-            self.regions.insert(lifetime_ref.name.normalize_to_macros_2_0());\n+            if let hir::LifetimeName::Param(def_id, _) = lifetime_ref.name {\n+                self.regions.insert(def_id);\n+            }\n         }\n     }\n }"}, {"sha": "bcff2ae51290932fb4df6995be917329f25e6bd7", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 287, "deletions": 77, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -16,7 +16,7 @@ use crate::require_c_abi_if_c_variadic;\n use rustc_ast::TraitObjectSyntax;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::{\n-    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError,\n+    struct_span_err, Applicability, DiagnosticBuilder, ErrorGuaranteed, FatalError, MultiSpan,\n };\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n@@ -30,7 +30,7 @@ use rustc_middle::ty::{self, Const, DefIdTree, EarlyBinder, Ty, TyCtxt, TypeFold\n use rustc_session::lint::builtin::{AMBIGUOUS_ASSOCIATED_ITEMS, BARE_TRAIT_OBJECTS};\n use rustc_span::edition::Edition;\n use rustc_span::lev_distance::find_best_match_for_name;\n-use rustc_span::symbol::{Ident, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi;\n use rustc_trait_selection::traits;\n@@ -653,7 +653,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             span, item_def_id, item_segment\n         );\n         if tcx.generics_of(item_def_id).params.is_empty() {\n-            self.prohibit_generics(slice::from_ref(item_segment));\n+            self.prohibit_generics(slice::from_ref(item_segment).iter(), |_| {});\n \n             parent_substs\n         } else {\n@@ -681,7 +681,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         trait_ref: &hir::TraitRef<'_>,\n         self_ty: Ty<'tcx>,\n     ) -> ty::TraitRef<'tcx> {\n-        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter(), |_| {});\n \n         self.ast_path_to_mono_trait_ref(\n             trait_ref.path.span,\n@@ -784,7 +784,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let args = trait_segment.args();\n         let infer_args = trait_segment.infer_args;\n \n-        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n+        self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1.iter(), |_| {});\n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment, false);\n \n         self.instantiate_poly_trait_ref_inner(\n@@ -1776,12 +1776,17 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         hir_ref_id: hir::HirId,\n         span: Span,\n         qself_ty: Ty<'tcx>,\n-        qself_res: Res,\n+        qself: &hir::Ty<'_>,\n         assoc_segment: &hir::PathSegment<'_>,\n         permit_variants: bool,\n     ) -> Result<(Ty<'tcx>, DefKind, DefId), ErrorGuaranteed> {\n         let tcx = self.tcx();\n         let assoc_ident = assoc_segment.ident;\n+        let qself_res = if let hir::TyKind::Path(hir::QPath::Resolved(_, ref path)) = qself.kind {\n+            path.res\n+        } else {\n+            Res::Err\n+        };\n \n         debug!(\"associated_path_to_ty: {:?}::{}\", qself_ty, assoc_ident);\n \n@@ -1796,7 +1801,87 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 if let Some(variant_def) = variant_def {\n                     if permit_variants {\n                         tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span, None);\n-                        self.prohibit_generics(slice::from_ref(assoc_segment));\n+                        self.prohibit_generics(slice::from_ref(assoc_segment).iter(), |err| {\n+                            err.note(\"enum variants can't have type parameters\");\n+                            let type_name = tcx.item_name(adt_def.did());\n+                            let msg = format!(\n+                                \"you might have meant to specity type parameters on enum \\\n+                                 `{type_name}`\"\n+                            );\n+                            let Some(args) = assoc_segment.args else { return; };\n+                            // Get the span of the generics args *including* the leading `::`.\n+                            let args_span = assoc_segment.ident.span.shrink_to_hi().to(args.span_ext);\n+                            if tcx.generics_of(adt_def.did()).count() == 0 {\n+                                // FIXME(estebank): we could also verify that the arguments being\n+                                // work for the `enum`, instead of just looking if it takes *any*.\n+                                err.span_suggestion_verbose(\n+                                    args_span,\n+                                    &format!(\"{type_name} doesn't have generic parameters\"),\n+                                    String::new(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                return;\n+                            }\n+                            let Ok(snippet) = tcx.sess.source_map().span_to_snippet(args_span) else {\n+                                err.note(&msg);\n+                                return;\n+                            };\n+                            let (qself_sugg_span, is_self) = if let hir::TyKind::Path(\n+                                hir::QPath::Resolved(_, ref path)\n+                            ) = qself.kind {\n+                                // If the path segment already has type params, we want to overwrite\n+                                // them.\n+                                match &path.segments[..] {\n+                                    // `segment` is the previous to last element on the path,\n+                                    // which would normally be the `enum` itself, while the last\n+                                    // `_` `PathSegment` corresponds to the variant.\n+                                    [.., hir::PathSegment {\n+                                        ident,\n+                                        args,\n+                                        res: Some(Res::Def(DefKind::Enum, _)),\n+                                        ..\n+                                    }, _] => (\n+                                        // We need to include the `::` in `Type::Variant::<Args>`\n+                                        // to point the span to `::<Args>`, not just `<Args>`.\n+                                        ident.span.shrink_to_hi().to(args.map_or(\n+                                            ident.span.shrink_to_hi(),\n+                                            |a| a.span_ext)),\n+                                        false,\n+                                    ),\n+                                    [segment] => (\n+                                        // We need to include the `::` in `Type::Variant::<Args>`\n+                                        // to point the span to `::<Args>`, not just `<Args>`.\n+                                        segment.ident.span.shrink_to_hi().to(segment.args.map_or(\n+                                            segment.ident.span.shrink_to_hi(),\n+                                            |a| a.span_ext)),\n+                                        kw::SelfUpper == segment.ident.name,\n+                                    ),\n+                                    _ => {\n+                                        err.note(&msg);\n+                                        return;\n+                                    }\n+                                }\n+                            } else {\n+                                err.note(&msg);\n+                                return;\n+                            };\n+                            let suggestion = vec![\n+                                if is_self {\n+                                    // Account for people writing `Self::Variant::<Args>`, where\n+                                    // `Self` is the enum, and suggest replacing `Self` with the\n+                                    // appropriate type: `Type::<Args>::Variant`.\n+                                    (qself.span, format!(\"{type_name}{snippet}\"))\n+                                } else {\n+                                    (qself_sugg_span, snippet)\n+                                },\n+                                (args_span, String::new()),\n+                            ];\n+                            err.multipart_suggestion_verbose(\n+                                &msg,\n+                                suggestion,\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        });\n                         return Ok((qself_ty, DefKind::Variant, variant_def.def_id));\n                     } else {\n                         variant_resolution = Some(variant_def.def_id);\n@@ -2017,69 +2102,112 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self.normalize_ty(span, tcx.mk_projection(item_def_id, item_substs))\n     }\n \n-    pub fn prohibit_generics<'a, T: IntoIterator<Item = &'a hir::PathSegment<'a>>>(\n+    pub fn prohibit_generics<'a>(\n         &self,\n-        segments: T,\n+        segments: impl Iterator<Item = &'a hir::PathSegment<'a>> + Clone,\n+        extend: impl Fn(&mut DiagnosticBuilder<'tcx, ErrorGuaranteed>),\n     ) -> bool {\n-        let mut has_err = false;\n-        for segment in segments {\n-            let (mut err_for_lt, mut err_for_ty, mut err_for_ct) = (false, false, false);\n-            for arg in segment.args().args {\n-                let (span, kind) = match arg {\n-                    hir::GenericArg::Lifetime(lt) => {\n-                        if err_for_lt {\n-                            continue;\n-                        }\n-                        err_for_lt = true;\n-                        has_err = true;\n-                        (lt.span, \"lifetime\")\n-                    }\n-                    hir::GenericArg::Type(ty) => {\n-                        if err_for_ty {\n-                            continue;\n-                        }\n-                        err_for_ty = true;\n-                        has_err = true;\n-                        (ty.span, \"type\")\n-                    }\n-                    hir::GenericArg::Const(ct) => {\n-                        if err_for_ct {\n-                            continue;\n-                        }\n-                        err_for_ct = true;\n-                        has_err = true;\n-                        (ct.span, \"const\")\n-                    }\n-                    hir::GenericArg::Infer(inf) => {\n-                        if err_for_ty {\n-                            continue;\n-                        }\n-                        has_err = true;\n-                        err_for_ty = true;\n-                        (inf.span, \"generic\")\n+        let args = segments.clone().flat_map(|segment| segment.args().args);\n+        let types_and_spans: Vec<_> = segments\n+            .clone()\n+            .flat_map(|segment| {\n+                segment.res.and_then(|res| {\n+                    if segment.args().args.is_empty() {\n+                        None\n+                    } else {\n+                        Some((\n+                            match res {\n+                                Res::PrimTy(ty) => format!(\"{} `{}`\", res.descr(), ty.name()),\n+                                Res::Def(_, def_id)\n+                                if let Some(name) = self.tcx().opt_item_name(def_id) => {\n+                                    format!(\"{} `{name}`\", res.descr())\n+                                }\n+                                Res::Err => \"this type\".to_string(),\n+                                _ => res.descr().to_string(),\n+                            },\n+                            segment.ident.span,\n+                        ))\n                     }\n-                };\n-                let mut err = struct_span_err!(\n-                    self.tcx().sess,\n-                    span,\n-                    E0109,\n-                    \"{} arguments are not allowed for this type\",\n-                    kind,\n-                );\n-                err.span_label(span, format!(\"{} argument not allowed\", kind));\n-                err.emit();\n-                if err_for_lt && err_for_ty && err_for_ct {\n-                    break;\n-                }\n+                })\n+            })\n+            .collect();\n+        let this_type = match &types_and_spans[..] {\n+            [.., _, (last, _)] => format!(\n+                \"{} and {last}\",\n+                types_and_spans[..types_and_spans.len() - 1]\n+                    .iter()\n+                    .map(|(x, _)| x.as_str())\n+                    .intersperse(&\", \")\n+                    .collect::<String>()\n+            ),\n+            [(only, _)] => only.to_string(),\n+            [] => \"this type\".to_string(),\n+        };\n+\n+        let (lt, ty, ct, inf) =\n+            args.clone().fold((false, false, false, false), |(lt, ty, ct, inf), arg| match arg {\n+                hir::GenericArg::Lifetime(_) => (true, ty, ct, inf),\n+                hir::GenericArg::Type(_) => (lt, true, ct, inf),\n+                hir::GenericArg::Const(_) => (lt, ty, true, inf),\n+                hir::GenericArg::Infer(_) => (lt, ty, ct, true),\n+            });\n+        let mut emitted = false;\n+        if lt || ty || ct || inf {\n+            let arg_spans: Vec<Span> = args.map(|arg| arg.span()).collect();\n+\n+            let mut kinds = Vec::with_capacity(4);\n+            if lt {\n+                kinds.push(\"lifetime\");\n+            }\n+            if ty {\n+                kinds.push(\"type\");\n+            }\n+            if ct {\n+                kinds.push(\"const\");\n             }\n+            if inf {\n+                kinds.push(\"generic\");\n+            }\n+            let (kind, s) = match kinds[..] {\n+                [.., _, last] => (\n+                    format!(\n+                        \"{} and {last}\",\n+                        kinds[..kinds.len() - 1]\n+                            .iter()\n+                            .map(|&x| x)\n+                            .intersperse(\", \")\n+                            .collect::<String>()\n+                    ),\n+                    \"s\",\n+                ),\n+                [only] => (format!(\"{only}\"), \"\"),\n+                [] => unreachable!(),\n+            };\n+            let last_span = *arg_spans.last().unwrap();\n+            let span: MultiSpan = arg_spans.into();\n+            let mut err = struct_span_err!(\n+                self.tcx().sess,\n+                span,\n+                E0109,\n+                \"{kind} arguments are not allowed on {this_type}\",\n+            );\n+            err.span_label(last_span, format!(\"{kind} argument{s} not allowed\"));\n+            for (_, span) in types_and_spans {\n+                err.span_label(span, \"not allowed on this\");\n+            }\n+            extend(&mut err);\n+            err.emit();\n+            emitted = true;\n+        }\n \n+        for segment in segments {\n             // Only emit the first error to avoid overloading the user with error messages.\n             if let [binding, ..] = segment.args().bindings {\n-                has_err = true;\n                 Self::prohibit_assoc_ty_binding(self.tcx(), binding.span);\n+                return true;\n             }\n         }\n-        has_err\n+        emitted\n     }\n \n     // FIXME(eddyb, varkor) handle type paths here too, not just value ones.\n@@ -2229,7 +2357,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 // Check for desugared `impl Trait`.\n                 assert!(ty::is_impl_trait_defn(tcx, did).is_none());\n                 let item_segment = path.segments.split_last().unwrap();\n-                self.prohibit_generics(item_segment.1);\n+                self.prohibit_generics(item_segment.1.iter(), |err| {\n+                    err.note(\"`impl Trait` types can't have type parameters\");\n+                });\n                 let substs = self.ast_path_substs_for_ty(span, did, item_segment.0);\n                 self.normalize_ty(span, tcx.mk_opaque(did, substs))\n             }\n@@ -2242,7 +2372,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 did,\n             ) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments.split_last().unwrap().1);\n+                self.prohibit_generics(path.segments.split_last().unwrap().1.iter(), |_| {});\n                 self.ast_path_to_ty(span, did, path.segments.last().unwrap())\n             }\n             Res::Def(kind @ DefKind::Variant, def_id) if permit_variants => {\n@@ -2254,18 +2384,26 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     self.def_ids_for_value_path_segments(path.segments, None, kind, def_id);\n                 let generic_segs: FxHashSet<_> =\n                     path_segs.iter().map(|PathSeg(_, index)| index).collect();\n-                self.prohibit_generics(path.segments.iter().enumerate().filter_map(\n-                    |(index, seg)| {\n+                self.prohibit_generics(\n+                    path.segments.iter().enumerate().filter_map(|(index, seg)| {\n                         if !generic_segs.contains(&index) { Some(seg) } else { None }\n+                    }),\n+                    |err| {\n+                        err.note(\"enum variants can't have type parameters\");\n                     },\n-                ));\n+                );\n \n                 let PathSeg(def_id, index) = path_segs.last().unwrap();\n                 self.ast_path_to_ty(span, *def_id, &path.segments[*index])\n             }\n             Res::Def(DefKind::TyParam, def_id) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    if let Some(span) = tcx.def_ident_span(def_id) {\n+                        let name = tcx.item_name(def_id);\n+                        err.span_note(span, &format!(\"type parameter `{name}` defined here\"));\n+                    }\n+                });\n \n                 let def_id = def_id.expect_local();\n                 let item_def_id = tcx.hir().ty_param_owner(def_id);\n@@ -2276,15 +2414,81 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::SelfTy { trait_: Some(_), alias_to: None } => {\n                 // `Self` in trait or type alias.\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    if let [hir::PathSegment { args: Some(args), ident, .. }] = &path.segments[..] {\n+                        err.span_suggestion_verbose(\n+                            ident.span.shrink_to_hi().to(args.span_ext),\n+                            \"the `Self` type doesn't accept type parameters\",\n+                            String::new(),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                });\n                 tcx.types.self_param\n             }\n             Res::SelfTy { trait_: _, alias_to: Some((def_id, forbid_generic)) } => {\n                 // `Self` in impl (we know the concrete type).\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n                 // Try to evaluate any array length constants.\n                 let ty = tcx.at(span).type_of(def_id);\n+                let span_of_impl = tcx.span_of_impl(def_id);\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    let def_id = match *ty.kind() {\n+                        ty::Adt(self_def, _) => self_def.did(),\n+                        _ => return,\n+                    };\n+\n+                    let type_name = tcx.item_name(def_id);\n+                    let span_of_ty = tcx.def_ident_span(def_id);\n+                    let generics = tcx.generics_of(def_id).count();\n+\n+                    let msg = format!(\"`Self` is of type `{ty}`\");\n+                    if let (Ok(i_sp), Some(t_sp)) = (span_of_impl, span_of_ty) {\n+                        let i_sp = tcx.sess.source_map().guess_head_span(i_sp);\n+                        let mut span: MultiSpan = vec![t_sp].into();\n+                        span.push_span_label(\n+                            i_sp,\n+                            &format!(\"`Self` is on type `{type_name}` in this `impl`\"),\n+                        );\n+                        let mut postfix = \"\";\n+                        if generics == 0 {\n+                            postfix = \", which doesn't have generic parameters\";\n+                        }\n+                        span.push_span_label(\n+                            t_sp,\n+                            &format!(\"`Self` corresponds to this type{postfix}\"),\n+                        );\n+                        err.span_note(span, &msg);\n+                    } else {\n+                        err.note(&msg);\n+                    }\n+                    for segment in path.segments {\n+                        if let Some(args) = segment.args && segment.ident.name == kw::SelfUpper {\n+                            if generics == 0 {\n+                                // FIXME(estebank): we could also verify that the arguments being\n+                                // work for the `enum`, instead of just looking if it takes *any*.\n+                                err.span_suggestion_verbose(\n+                                    segment.ident.span.shrink_to_hi().to(args.span_ext),\n+                                    \"the `Self` type doesn't accept type parameters\",\n+                                    String::new(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                return;\n+                            } else {\n+                                err.span_suggestion_verbose(\n+                                    segment.ident.span,\n+                                    format!(\n+                                        \"the `Self` type doesn't accept type parameters, use the \\\n+                                        concrete type's name `{type_name}` instead if you want to \\\n+                                        specify its type parameters\"\n+                                    ),\n+                                    type_name.to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                            }\n+                        }\n+                    }\n+                });\n                 // HACK(min_const_generics): Forbid generic `Self` types\n                 // here as we can't easily do that during nameres.\n                 //\n@@ -2324,7 +2528,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::Def(DefKind::AssocTy, def_id) => {\n                 debug_assert!(path.segments.len() >= 2);\n-                self.prohibit_generics(&path.segments[..path.segments.len() - 2]);\n+                self.prohibit_generics(path.segments[..path.segments.len() - 2].iter(), |_| {});\n                 self.qpath_to_ty(\n                     span,\n                     opt_self_ty,\n@@ -2335,7 +2539,19 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             Res::PrimTy(prim_ty) => {\n                 assert_eq!(opt_self_ty, None);\n-                self.prohibit_generics(path.segments);\n+                self.prohibit_generics(path.segments.iter(), |err| {\n+                    let name = prim_ty.name_str();\n+                    for segment in path.segments {\n+                        if let Some(args) = segment.args {\n+                            err.span_suggestion_verbose(\n+                                segment.ident.span.shrink_to_hi().to(args.span_ext),\n+                                &format!(\"primitive type `{name}` doesn't have generic parameters\"),\n+                                String::new(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        }\n+                    }\n+                });\n                 match prim_ty {\n                     hir::PrimTy::Bool => tcx.types.bool,\n                     hir::PrimTy::Char => tcx.types.char,\n@@ -2426,13 +2642,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             hir::TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n                 debug!(?qself, ?segment);\n                 let ty = self.ast_ty_to_ty_inner(qself, false, true);\n-\n-                let res = if let hir::TyKind::Path(hir::QPath::Resolved(_, path)) = qself.kind {\n-                    path.res\n-                } else {\n-                    Res::Err\n-                };\n-                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, res, segment, false)\n+                self.associated_path_to_ty(ast_ty.hir_id, ast_ty.span, ty, qself, segment, false)\n                     .map(|(ty, _, _)| ty)\n                     .unwrap_or_else(|_| tcx.ty_error())\n             }"}, {"sha": "c28c041e78dff9c9709211b3f784363cfd417f2f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1228,6 +1228,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     None\n                 }\n             }),\n+            |_| {},\n         );\n \n         if let Res::Local(hid) = res {"}, {"sha": "83afbfa54b1dda8dbe272df87ffb2045d8901990", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1564,13 +1564,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             QPath::TypeRelative(ref qself, ref segment) => {\n                 let ty = self.to_ty(qself);\n \n-                let res = if let hir::TyKind::Path(QPath::Resolved(_, ref path)) = qself.kind {\n-                    path.res\n-                } else {\n-                    Res::Err\n-                };\n                 let result = <dyn AstConv<'_>>::associated_path_to_ty(\n-                    self, hir_id, path_span, ty, res, segment, true,\n+                    self, hir_id, path_span, ty, qself, segment, true,\n                 );\n                 let ty = result.map(|(ty, _, _)| ty).unwrap_or_else(|_| self.tcx().ty_error());\n                 let result = result.map(|(_, kind, def_id)| (kind, def_id));"}, {"sha": "34d107349e7c70b29527103fa44f20fbc8264bc2", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 8, "deletions": 27, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1364,7 +1364,6 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n \n     fn has_late_bound_regions<'tcx>(\n         tcx: TyCtxt<'tcx>,\n-        def_id: LocalDefId,\n         generics: &'tcx hir::Generics<'tcx>,\n         decl: &'tcx hir::FnDecl<'tcx>,\n     ) -> Option<Span> {\n@@ -1373,14 +1372,9 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n             outer_index: ty::INNERMOST,\n             has_late_bound_regions: None,\n         };\n-        let late_bound_map = tcx.is_late_bound_map(def_id);\n-        let is_late_bound = |id| {\n-            let id = tcx.hir().local_def_id(id);\n-            late_bound_map.map_or(false, |(_, set)| set.contains(&id))\n-        };\n         for param in generics.params {\n             if let GenericParamKind::Lifetime { .. } = param.kind {\n-                if is_late_bound(param.hir_id) {\n+                if tcx.is_late_bound(param.hir_id) {\n                     return Some(param.span);\n                 }\n             }\n@@ -1392,25 +1386,25 @@ fn has_late_bound_regions<'tcx>(tcx: TyCtxt<'tcx>, node: Node<'tcx>) -> Option<S\n     match node {\n         Node::TraitItem(item) => match item.kind {\n             hir::TraitItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, item.def_id, &item.generics, sig.decl)\n+                has_late_bound_regions(tcx, &item.generics, sig.decl)\n             }\n             _ => None,\n         },\n         Node::ImplItem(item) => match item.kind {\n             hir::ImplItemKind::Fn(ref sig, _) => {\n-                has_late_bound_regions(tcx, item.def_id, &item.generics, sig.decl)\n+                has_late_bound_regions(tcx, &item.generics, sig.decl)\n             }\n             _ => None,\n         },\n         Node::ForeignItem(item) => match item.kind {\n             hir::ForeignItemKind::Fn(fn_decl, _, ref generics) => {\n-                has_late_bound_regions(tcx, item.def_id, generics, fn_decl)\n+                has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n         Node::Item(item) => match item.kind {\n             hir::ItemKind::Fn(ref sig, .., ref generics, _) => {\n-                has_late_bound_regions(tcx, item.def_id, generics, sig.decl)\n+                has_late_bound_regions(tcx, generics, sig.decl)\n             }\n             _ => None,\n         },\n@@ -1671,7 +1665,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         params.push(opt_self);\n     }\n \n-    let early_lifetimes = early_bound_lifetimes_from_generics(tcx, hir_id.owner, ast_generics);\n+    let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n     params.extend(early_lifetimes.enumerate().map(|(i, param)| ty::GenericParamDef {\n         name: param.name.ident().name,\n         index: own_start + i as u32,\n@@ -2054,23 +2048,10 @@ fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n /// `resolve_lifetime::early_bound_lifetimes`.\n fn early_bound_lifetimes_from_generics<'a, 'tcx: 'a>(\n     tcx: TyCtxt<'tcx>,\n-    def_id: LocalDefId,\n     generics: &'a hir::Generics<'a>,\n ) -> impl Iterator<Item = &'a hir::GenericParam<'a>> + Captures<'tcx> {\n-    let late_bound_map = if generics.params.is_empty() {\n-        // This function may be called on `def_id == CRATE_DEF_ID`,\n-        // which makes `is_late_bound_map` ICE.  Don't even try if there\n-        // is no generic parameter.\n-        None\n-    } else {\n-        tcx.is_late_bound_map(def_id)\n-    };\n-    let is_late_bound = move |hir_id| {\n-        let id = tcx.hir().local_def_id(hir_id);\n-        late_bound_map.map_or(false, |(_, set)| set.contains(&id))\n-    };\n     generics.params.iter().filter(move |param| match param.kind {\n-        GenericParamKind::Lifetime { .. } => !is_late_bound(param.hir_id),\n+        GenericParamKind::Lifetime { .. } => !tcx.is_late_bound(param.hir_id),\n         _ => false,\n     })\n }\n@@ -2255,7 +2236,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     // have to be careful to only iterate over early-bound regions.\n     let mut index = parent_count\n         + has_own_self as u32\n-        + early_bound_lifetimes_from_generics(tcx, hir_id.owner, ast_generics).count() as u32;\n+        + early_bound_lifetimes_from_generics(tcx, ast_generics).count() as u32;\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T: Foo>`)."}, {"sha": "bc3a3db9fdadb3e7ce35a12f4d6c71f7fd39f738", "filename": "compiler/rustc_typeck/src/structured_errors/wrong_number_of_generic_args.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fstructured_errors%2Fwrong_number_of_generic_args.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -514,7 +514,9 @@ impl<'a, 'tcx> WrongNumberOfGenericArgs<'a, 'tcx> {\n                             param_names\n                                 .iter()\n                                 .take(num_params_to_take)\n-                                .map(|p| p.as_str())\n+                                .map(|def_id| {\n+                                    self.tcx.item_name(def_id.to_def_id()).to_ident_string()\n+                                })\n                                 .collect::<Vec<_>>()\n                                 .join(\", \")\n                         } else {"}, {"sha": "f3070fb35f1d09bf2354a034809c77990b2b267e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -475,24 +475,14 @@ fn clean_generic_param<'tcx>(\n     generics: Option<&hir::Generics<'tcx>>,\n     param: &hir::GenericParam<'tcx>,\n ) -> GenericParamDef {\n+    let did = cx.tcx.hir().local_def_id(param.hir_id);\n     let (name, kind) = match param.kind {\n         hir::GenericParamKind::Lifetime { .. } => {\n             let outlives = if let Some(generics) = generics {\n                 generics\n-                    .predicates\n-                    .iter()\n-                    .flat_map(|pred| {\n-                        match pred {\n-                            hir::WherePredicate::RegionPredicate(rp)\n-                                if rp.lifetime.name == hir::LifetimeName::Param(param.name)\n-                                    && !rp.in_where_clause =>\n-                            {\n-                                rp.bounds\n-                            }\n-                            _ => &[],\n-                        }\n-                        .iter()\n-                    })\n+                    .outlives_for_param(did)\n+                    .filter(|bp| !bp.in_where_clause)\n+                    .flat_map(|bp| bp.bounds)\n                     .map(|bound| match bound {\n                         hir::GenericBound::Outlives(lt) => lt.clean(cx),\n                         _ => panic!(),\n@@ -504,7 +494,6 @@ fn clean_generic_param<'tcx>(\n             (param.name.ident().name, GenericParamDefKind::Lifetime { outlives })\n         }\n         hir::GenericParamKind::Type { ref default, synthetic } => {\n-            let did = cx.tcx.hir().local_def_id(param.hir_id);\n             let bounds = if let Some(generics) = generics {\n                 generics\n                     .bounds_for_param(did)\n@@ -528,7 +517,7 @@ fn clean_generic_param<'tcx>(\n         hir::GenericParamKind::Const { ty, default } => (\n             param.name.ident().name,\n             GenericParamDefKind::Const {\n-                did: cx.tcx.hir().local_def_id(param.hir_id).to_def_id(),\n+                did: did.to_def_id(),\n                 ty: Box::new(ty.clean(cx)),\n                 default: default.map(|ct| {\n                     let def_id = cx.tcx.hir().local_def_id(ct.hir_id);\n@@ -1459,7 +1448,7 @@ impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n                 // Turning `fn f(&'_ self)` into `fn f(&self)` isn't the worst thing in the world, though;\n                 // there's no case where it could cause the function to fail to compile.\n                 let elided =\n-                    l.is_elided() || matches!(l.name, LifetimeName::Param(ParamName::Fresh(_)));\n+                    l.is_elided() || matches!(l.name, LifetimeName::Param(_, ParamName::Fresh));\n                 let lifetime = if elided { None } else { Some(l.clean(cx)) };\n                 BorrowedRef { lifetime, mutability: m.mutbl, type_: box m.ty.clean(cx) }\n             }"}, {"sha": "bd83b254caacbe76cb7464f9852f931900d22713", "filename": "src/librustdoc/html/static/.eslintrc.js", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2F.eslintrc.js?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -70,5 +70,13 @@ module.exports = {\n         \"no-dupe-keys\": \"error\",\n         \"no-duplicate-case\": \"error\",\n         \"no-ex-assign\": \"error\",\n+        \"no-fallthrough\": \"error\",\n+        \"no-invalid-regexp\": \"error\",\n+        \"no-import-assign\": \"error\",\n+        \"no-self-compare\": \"error\",\n+        \"no-template-curly-in-string\": \"error\",\n+        \"block-scoped-var\": \"error\",\n+        \"guard-for-in\": \"error\",\n+        \"no-alert\": \"error\",\n     }\n };"}, {"sha": "6f0e4d55aeb0432f33146021b8a866cc3267cf6e", "filename": "src/test/ui/derives/issue-97343.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fderives%2Fissue-97343.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fderives%2Fissue-97343.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fissue-97343.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,7 +1,7 @@\n use std::fmt::Debug;\n \n #[derive(Debug)]\n-pub struct Irrelevant<Irrelevant> { //~ ERROR type arguments are not allowed for this type\n+pub struct Irrelevant<Irrelevant> { //~ ERROR type arguments are not allowed on type parameter\n     irrelevant: Irrelevant,\n }\n "}, {"sha": "ac797a8f50152e0c4a8cab24419255d44c28504b", "filename": "src/test/ui/derives/issue-97343.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fderives%2Fissue-97343.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fderives%2Fissue-97343.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fissue-97343.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,11 +1,19 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on type parameter `Irrelevant`\n   --> $DIR/issue-97343.rs:4:23\n    |\n LL | #[derive(Debug)]\n-   |          ----- in this derive macro expansion\n+   |          -----\n+   |          |\n+   |          not allowed on this\n+   |          in this derive macro expansion\n LL | pub struct Irrelevant<Irrelevant> {\n    |                       ^^^^^^^^^^ type argument not allowed\n    |\n+note: type parameter `Irrelevant` defined here\n+  --> $DIR/issue-97343.rs:4:23\n+   |\n+LL | pub struct Irrelevant<Irrelevant> {\n+   |                       ^^^^^^^^^^\n    = note: this error originates in the derive macro `Debug` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to previous error"}, {"sha": "e0e437e18ae8c6a4b9c93c9ce4a48501fbcd416a", "filename": "src/test/ui/error-codes/E0109.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0109.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,8 +1,16 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/E0109.rs:1:14\n    |\n LL | type X = u32<i32>;\n-   |              ^^^ type argument not allowed\n+   |          --- ^^^ type argument not allowed\n+   |          |\n+   |          not allowed on this\n+   |\n+help: primitive type `u32` doesn't have generic parameters\n+   |\n+LL - type X = u32<i32>;\n+LL + type X = u32;\n+   | \n \n error: aborting due to previous error\n "}, {"sha": "15e1b959193fae7cdd99407326d20d13af060134", "filename": "src/test/ui/error-codes/E0110.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0110.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,8 +1,16 @@\n-error[E0109]: lifetime arguments are not allowed for this type\n+error[E0109]: lifetime arguments are not allowed on this type\n   --> $DIR/E0110.rs:1:14\n    |\n LL | type X = u32<'static>;\n-   |              ^^^^^^^ lifetime argument not allowed\n+   |          --- ^^^^^^^ lifetime argument not allowed\n+   |          |\n+   |          not allowed on this\n+   |\n+help: primitive type `u32` doesn't have generic parameters\n+   |\n+LL - type X = u32<'static>;\n+LL + type X = u32;\n+   | \n \n error: aborting due to previous error\n "}, {"sha": "bb8a58d3d2ecc63c36340bff5de941e6379f08ca", "filename": "src/test/ui/issues/issue-22706.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-22706.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-22706.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22706.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,3 +1,3 @@\n fn is_copy<T: ::std::marker<i32>::Copy>() {}\n-//~^ ERROR type arguments are not allowed for this type [E0109]\n+//~^ ERROR type arguments are not allowed on module `marker` [E0109]\n fn main() {}"}, {"sha": "66911f081d76cd74f2e2ec78f717e7b4dbcb7a62", "filename": "src/test/ui/issues/issue-22706.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-22706.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-22706.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22706.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,8 +1,10 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on module `marker`\n   --> $DIR/issue-22706.rs:1:29\n    |\n LL | fn is_copy<T: ::std::marker<i32>::Copy>() {}\n-   |                             ^^^ type argument not allowed\n+   |                      ------ ^^^ type argument not allowed\n+   |                      |\n+   |                      not allowed on this\n \n error: aborting due to previous error\n "}, {"sha": "8846912a8ff79bb11d6daeda27101d845d4f61cd", "filename": "src/test/ui/issues/issue-57924.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-57924.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-57924.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57924.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -3,7 +3,7 @@ pub struct Gcm<E>(E);\n impl<E> Gcm<E> {\n     pub fn crash(e: E) -> Self {\n         Self::<E>(e)\n-        //~^ ERROR type arguments are not allowed for this type\n+        //~^ ERROR type arguments are not allowed on self constructor\n     }\n }\n "}, {"sha": "211b0dde48c2e24046245cfe994138bd1257970b", "filename": "src/test/ui/issues/issue-57924.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-57924.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-57924.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57924.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,8 +1,10 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self constructor\n   --> $DIR/issue-57924.rs:5:16\n    |\n LL |         Self::<E>(e)\n-   |                ^ type argument not allowed\n+   |         ----   ^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n \n error: aborting due to previous error\n "}, {"sha": "29db3fdb47104815247640c37fcb33494f3325b1", "filename": "src/test/ui/issues/issue-60989.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-60989.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-60989.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60989.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -10,9 +10,9 @@ impl From<A> for B {\n fn main() {\n     let c1 = ();\n     c1::<()>;\n-    //~^ ERROR type arguments are not allowed for this type\n+    //~^ ERROR type arguments are not allowed on local variable\n \n     let c1 = A {};\n     c1::<dyn Into<B>>;\n-    //~^ ERROR type arguments are not allowed for this type\n+    //~^ ERROR type arguments are not allowed on local variable\n }"}, {"sha": "9076f4f9385ba178073a6f532423ec9c7cd31876", "filename": "src/test/ui/issues/issue-60989.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-60989.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fissues%2Fissue-60989.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-60989.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,14 +1,18 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on local variable\n   --> $DIR/issue-60989.rs:12:10\n    |\n LL |     c1::<()>;\n-   |          ^^ type argument not allowed\n+   |     --   ^^ type argument not allowed\n+   |     |\n+   |     not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on local variable\n   --> $DIR/issue-60989.rs:16:10\n    |\n LL |     c1::<dyn Into<B>>;\n-   |          ^^^^^^^^^^^ type argument not allowed\n+   |     --   ^^^^^^^^^^^ type argument not allowed\n+   |     |\n+   |     not allowed on this\n \n error: aborting due to 2 previous errors\n "}, {"sha": "959024c46f4ffe601e9e52c22b822f65abe15dbc", "filename": "src/test/ui/mod-subitem-as-enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -5,5 +5,5 @@ mod Mod {\n fn main() {\n     Mod::FakeVariant::<i32>(0);\n     Mod::<i32>::FakeVariant(0);\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on module `Mod` [E0109]\n }"}, {"sha": "15da1d155a337fc17a2a26a3fa81ba91f350dfae", "filename": "src/test/ui/mod-subitem-as-enum-variant.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmod-subitem-as-enum-variant.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,8 +1,10 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on module `Mod`\n   --> $DIR/mod-subitem-as-enum-variant.rs:7:11\n    |\n LL |     Mod::<i32>::FakeVariant(0);\n-   |           ^^^ type argument not allowed\n+   |     ---   ^^^ type argument not allowed\n+   |     |\n+   |     not allowed on this\n \n error: aborting due to previous error\n "}, {"sha": "f88572f8419c03a1590888658bc41458bb5d6100", "filename": "src/test/ui/structs/struct-path-associated-type.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -13,7 +13,7 @@ fn f<T: Tr>() {\n     //~^ ERROR expected struct, variant or union type, found associated type\n     let z = T::A::<u8> {};\n     //~^ ERROR expected struct, variant or union type, found associated type\n-    //~| ERROR type arguments are not allowed for this type\n+    //~| ERROR type arguments are not allowed on this type\n     match S {\n         T::A {} => {}\n         //~^ ERROR expected struct, variant or union type, found associated type\n@@ -22,7 +22,7 @@ fn f<T: Tr>() {\n \n fn g<T: Tr<A = S>>() {\n     let s = T::A {}; // OK\n-    let z = T::A::<u8> {}; //~ ERROR type arguments are not allowed for this type\n+    let z = T::A::<u8> {}; //~ ERROR type arguments are not allowed on this type\n     match S {\n         T::A {} => {} // OK\n     }"}, {"sha": "7424ceecbe3b63195ab9f00da7dcae7606ad8ac7", "filename": "src/test/ui/structs/struct-path-associated-type.stderr", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-associated-type.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -4,11 +4,13 @@ error[E0071]: expected struct, variant or union type, found associated type\n LL |     let s = T::A {};\n    |             ^^^^ not a struct\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/struct-path-associated-type.rs:14:20\n    |\n LL |     let z = T::A::<u8> {};\n-   |                    ^^ type argument not allowed\n+   |                -   ^^ type argument not allowed\n+   |                |\n+   |                not allowed on this\n \n error[E0071]: expected struct, variant or union type, found associated type\n   --> $DIR/struct-path-associated-type.rs:14:13\n@@ -22,11 +24,13 @@ error[E0071]: expected struct, variant or union type, found associated type\n LL |         T::A {} => {}\n    |         ^^^^ not a struct\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/struct-path-associated-type.rs:25:20\n    |\n LL |     let z = T::A::<u8> {};\n-   |                    ^^ type argument not allowed\n+   |                -   ^^ type argument not allowed\n+   |                |\n+   |                not allowed on this\n \n error[E0223]: ambiguous associated type\n   --> $DIR/struct-path-associated-type.rs:32:13"}, {"sha": "6e529c7ed2b70c417fc56fafb4a54f9e01fe1613", "filename": "src/test/ui/structs/struct-path-self.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -6,7 +6,7 @@ trait Tr {\n         //~^ ERROR expected struct, variant or union type, found type parameter\n         let z = Self::<u8> {};\n         //~^ ERROR expected struct, variant or union type, found type parameter\n-        //~| ERROR type arguments are not allowed for this type\n+        //~| ERROR type arguments are not allowed on self type\n         match s {\n             Self { .. } => {}\n             //~^ ERROR expected struct, variant or union type, found type parameter\n@@ -17,7 +17,7 @@ trait Tr {\n impl Tr for S {\n     fn f() {\n         let s = Self {}; // OK\n-        let z = Self::<u8> {}; //~ ERROR type arguments are not allowed for this type\n+        let z = Self::<u8> {}; //~ ERROR type arguments are not allowed on self type\n         match s {\n             Self { .. } => {} // OK\n         }\n@@ -27,7 +27,7 @@ impl Tr for S {\n impl S {\n     fn g() {\n         let s = Self {}; // OK\n-        let z = Self::<u8> {}; //~ ERROR type arguments are not allowed for this type\n+        let z = Self::<u8> {}; //~ ERROR type arguments are not allowed on self type\n         match s {\n             Self { .. } => {} // OK\n         }"}, {"sha": "cccdd7b0f023ff938575e152b3e88af51fdd60ec", "filename": "src/test/ui/structs/struct-path-self.stderr", "status": "modified", "additions": 46, "deletions": 6, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-path-self.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -4,11 +4,19 @@ error[E0071]: expected struct, variant or union type, found type parameter `Self\n LL |         let s = Self {};\n    |                 ^^^^ not a struct\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/struct-path-self.rs:7:24\n    |\n LL |         let z = Self::<u8> {};\n-   |                        ^^ type argument not allowed\n+   |                 ----   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n+   |\n+help: the `Self` type doesn't accept type parameters\n+   |\n+LL -         let z = Self::<u8> {};\n+LL +         let z = Self {};\n+   | \n \n error[E0071]: expected struct, variant or union type, found type parameter `Self`\n   --> $DIR/struct-path-self.rs:7:17\n@@ -22,17 +30,49 @@ error[E0071]: expected struct, variant or union type, found type parameter `Self\n LL |             Self { .. } => {}\n    |             ^^^^ not a struct\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/struct-path-self.rs:20:24\n    |\n LL |         let z = Self::<u8> {};\n-   |                        ^^ type argument not allowed\n+   |                 ----   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n+   |\n+note: `Self` is of type `S`\n+  --> $DIR/struct-path-self.rs:1:8\n+   |\n+LL | struct S;\n+   |        ^ `Self` corresponds to this type, which doesn't have generic parameters\n+...\n+LL | impl Tr for S {\n+   | ------------- `Self` is on type `S` in this `impl`\n+help: the `Self` type doesn't accept type parameters\n+   |\n+LL -         let z = Self::<u8> {};\n+LL +         let z = Self {};\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/struct-path-self.rs:30:24\n    |\n LL |         let z = Self::<u8> {};\n-   |                        ^^ type argument not allowed\n+   |                 ----   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n+   |\n+note: `Self` is of type `S`\n+  --> $DIR/struct-path-self.rs:1:8\n+   |\n+LL | struct S;\n+   |        ^ `Self` corresponds to this type, which doesn't have generic parameters\n+...\n+LL | impl S {\n+   | ------ `Self` is on type `S` in this `impl`\n+help: the `Self` type doesn't accept type parameters\n+   |\n+LL -         let z = Self::<u8> {};\n+LL +         let z = Self {};\n+   | \n \n error: aborting due to 6 previous errors\n "}, {"sha": "e6f45036f8514fcd8b59e16fcd4674bbdf5577b8", "filename": "src/test/ui/type-alias-enum-variants/enum-variant-generic-args.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -13,93 +13,93 @@ impl<T> Enum<T> {\n         Self::TSVariant(());\n         //~^ ERROR mismatched types [E0308]\n         Self::TSVariant::<()>(());\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on this type [E0109]\n         Self::<()>::TSVariant(());\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n         //~| ERROR mismatched types [E0308]\n         Self::<()>::TSVariant::<()>(());\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n-        //~| ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n+        //~| ERROR type arguments are not allowed on this type [E0109]\n     }\n \n     fn s_variant() {\n         Self::SVariant { v: () };\n         //~^ ERROR mismatched types [E0308]\n         Self::SVariant::<()> { v: () };\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on this type [E0109]\n         //~| ERROR mismatched types [E0308]\n         Self::<()>::SVariant { v: () };\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n         //~| ERROR mismatched types [E0308]\n         Self::<()>::SVariant::<()> { v: () };\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n-        //~| ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n+        //~| ERROR type arguments are not allowed on this type [E0109]\n         //~| ERROR mismatched types [E0308]\n     }\n \n     fn u_variant() {\n         Self::UVariant::<()>;\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on this type [E0109]\n         Self::<()>::UVariant;\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n         Self::<()>::UVariant::<()>;\n-        //~^ ERROR type arguments are not allowed for this type [E0109]\n-        //~| ERROR type arguments are not allowed for this type [E0109]\n+        //~^ ERROR type arguments are not allowed on self type [E0109]\n+        //~| ERROR type arguments are not allowed on this type [E0109]\n     }\n }\n \n fn main() {\n     // Tuple struct variant\n \n     Enum::<()>::TSVariant::<()>(());\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     Alias::TSVariant::<()>(());\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     Alias::<()>::TSVariant::<()>(());\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     AliasFixed::TSVariant::<()>(());\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     AliasFixed::<()>::TSVariant(());\n     //~^ ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n     AliasFixed::<()>::TSVariant::<()>(());\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     //~| ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n \n     // Struct variant\n \n     Enum::<()>::SVariant::<()> { v: () };\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     Alias::SVariant::<()> { v: () };\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     Alias::<()>::SVariant::<()> { v: () };\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     AliasFixed::SVariant::<()> { v: () };\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     AliasFixed::<()>::SVariant { v: () };\n     //~^ ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n     AliasFixed::<()>::SVariant::<()> { v: () };\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     //~| ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n \n     // Unit variant\n \n     Enum::<()>::UVariant::<()>;\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     Alias::UVariant::<()>;\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     Alias::<()>::UVariant::<()>;\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n \n     AliasFixed::UVariant::<()>;\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     AliasFixed::<()>::UVariant;\n     //~^ ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n     AliasFixed::<()>::UVariant::<()>;\n-    //~^ ERROR type arguments are not allowed for this type [E0109]\n+    //~^ ERROR type arguments are not allowed on this type [E0109]\n     //~| ERROR this type alias takes 0 generic arguments but 1 generic argument was supplied [E0107]\n }"}, {"sha": "3e60ab108a82fc8fda4488d83150a4b6f1c286fb", "filename": "src/test/ui/type-alias-enum-variants/enum-variant-generic-args.stderr", "status": "modified", "additions": 230, "deletions": 54, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fenum-variant-generic-args.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -17,17 +17,34 @@ note: tuple variant defined here\n LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n    |                ^^^^^^^^^\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:15:27\n    |\n LL |         Self::TSVariant::<()>(());\n-   |                           ^^ type argument not allowed\n+   |               ---------   ^^ type argument not allowed\n+   |               |\n+   |               not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:17:16\n    |\n LL |         Self::<()>::TSVariant(());\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::TSVariant(());\n+   |         ~~~~\n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:17:31\n@@ -48,17 +65,34 @@ note: tuple variant defined here\n LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n    |                ^^^^^^^^^\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:20:16\n    |\n LL |         Self::<()>::TSVariant::<()>(());\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::TSVariant::<()>(());\n+   |         ~~~~\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:20:33\n    |\n LL |         Self::<()>::TSVariant::<()>(());\n-   |                                 ^^ type argument not allowed\n+   |                     ---------   ^^ type argument not allowed\n+   |                     |\n+   |                     not allowed on this\n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:26:29\n@@ -72,11 +106,20 @@ LL |         Self::SVariant { v: () };\n    = note: expected type parameter `T`\n                    found unit type `()`\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:28:26\n    |\n LL |         Self::SVariant::<()> { v: () };\n-   |                          ^^ type argument not allowed\n+   |               --------   ^^ type argument not allowed\n+   |               |\n+   |               not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -         Self::SVariant::<()> { v: () };\n+LL +         Enum::<()>::SVariant { v: () };\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:28:35\n@@ -90,11 +133,26 @@ LL |         Self::SVariant::<()> { v: () };\n    = note: expected type parameter `T`\n                    found unit type `()`\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:31:16\n    |\n LL |         Self::<()>::SVariant { v: () };\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::SVariant { v: () };\n+   |         ~~~~\n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:31:35\n@@ -108,17 +166,41 @@ LL |         Self::<()>::SVariant { v: () };\n    = note: expected type parameter `T`\n                    found unit type `()`\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:34:16\n    |\n LL |         Self::<()>::SVariant::<()> { v: () };\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::SVariant::<()> { v: () };\n+   |         ~~~~\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:34:32\n    |\n LL |         Self::<()>::SVariant::<()> { v: () };\n-   |                                ^^ type argument not allowed\n+   |                     --------   ^^ type argument not allowed\n+   |                     |\n+   |                     not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -         Self::<()>::SVariant::<()> { v: () };\n+LL +         Enum::<()>::SVariant { v: () };\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/enum-variant-generic-args.rs:34:41\n@@ -132,53 +214,95 @@ LL |         Self::<()>::SVariant::<()> { v: () };\n    = note: expected type parameter `T`\n                    found unit type `()`\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:41:26\n    |\n LL |         Self::UVariant::<()>;\n-   |                          ^^ type argument not allowed\n+   |               --------   ^^ type argument not allowed\n+   |               |\n+   |               not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:43:16\n    |\n LL |         Self::<()>::UVariant;\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::UVariant;\n+   |         ~~~~\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on self type\n   --> $DIR/enum-variant-generic-args.rs:45:16\n    |\n LL |         Self::<()>::UVariant::<()>;\n-   |                ^^ type argument not allowed\n+   |         ----   ^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+note: `Self` is of type `Enum<T>`\n+  --> $DIR/enum-variant-generic-args.rs:7:6\n+   |\n+LL | enum Enum<T> { TSVariant(T), SVariant { v: T }, UVariant }\n+   |      ^^^^ `Self` corresponds to this type\n+...\n+LL | impl<T> Enum<T> {\n+   | --------------- `Self` is on type `Enum` in this `impl`\n+help: the `Self` type doesn't accept type parameters, use the concrete type's name `Enum` instead if you want to specify its type parameters\n+   |\n+LL |         Enum::<()>::UVariant::<()>;\n+   |         ~~~~\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:45:32\n    |\n LL |         Self::<()>::UVariant::<()>;\n-   |                                ^^ type argument not allowed\n+   |                     --------   ^^ type argument not allowed\n+   |                     |\n+   |                     not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:54:29\n    |\n LL |     Enum::<()>::TSVariant::<()>(());\n-   |                             ^^ type argument not allowed\n+   |                 ---------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:57:24\n    |\n LL |     Alias::TSVariant::<()>(());\n-   |                        ^^ type argument not allowed\n+   |            ---------   ^^ type argument not allowed\n+   |            |\n+   |            not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:59:30\n    |\n LL |     Alias::<()>::TSVariant::<()>(());\n-   |                              ^^ type argument not allowed\n+   |                  ---------   ^^ type argument not allowed\n+   |                  |\n+   |                  not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:62:29\n    |\n LL |     AliasFixed::TSVariant::<()>(());\n-   |                             ^^ type argument not allowed\n+   |                 ---------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n \n error[E0107]: this type alias takes 0 generic arguments but 1 generic argument was supplied\n   --> $DIR/enum-variant-generic-args.rs:64:5\n@@ -208,35 +332,68 @@ note: type alias defined here, with 0 generic parameters\n LL | type AliasFixed = Enum<()>;\n    |      ^^^^^^^^^^\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:66:35\n    |\n LL |     AliasFixed::<()>::TSVariant::<()>(());\n-   |                                   ^^ type argument not allowed\n+   |                       ---------   ^^ type argument not allowed\n+   |                       |\n+   |                       not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:72:28\n    |\n LL |     Enum::<()>::SVariant::<()> { v: () };\n-   |                            ^^ type argument not allowed\n+   |                 --------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:75:23\n    |\n LL |     Alias::SVariant::<()> { v: () };\n-   |                       ^^ type argument not allowed\n+   |            --------   ^^ type argument not allowed\n+   |            |\n+   |            not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     Alias::SVariant::<()> { v: () };\n+LL +     Alias::<()>::SVariant { v: () };\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:77:29\n    |\n LL |     Alias::<()>::SVariant::<()> { v: () };\n-   |                             ^^ type argument not allowed\n+   |                  --------   ^^ type argument not allowed\n+   |                  |\n+   |                  not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     Alias::<()>::SVariant::<()> { v: () };\n+LL +     Alias::<()>::SVariant { v: () };\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:80:28\n    |\n LL |     AliasFixed::SVariant::<()> { v: () };\n-   |                            ^^ type argument not allowed\n+   |                 --------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     AliasFixed::SVariant::<()> { v: () };\n+LL +     AliasFixed::<()>::SVariant { v: () };\n+   | \n \n error[E0107]: this type alias takes 0 generic arguments but 1 generic argument was supplied\n   --> $DIR/enum-variant-generic-args.rs:82:5\n@@ -266,35 +423,52 @@ note: type alias defined here, with 0 generic parameters\n LL | type AliasFixed = Enum<()>;\n    |      ^^^^^^^^^^\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:84:34\n    |\n LL |     AliasFixed::<()>::SVariant::<()> { v: () };\n-   |                                  ^^ type argument not allowed\n+   |                       --------   ^^ type argument not allowed\n+   |                       |\n+   |                       not allowed on this\n+   |\n+   = note: enum variants can't have type parameters\n+help: you might have meant to specity type parameters on enum `Enum`\n+   |\n+LL -     AliasFixed::<()>::SVariant::<()> { v: () };\n+LL +     AliasFixed::<()>::SVariant { v: () };\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:90:28\n    |\n LL |     Enum::<()>::UVariant::<()>;\n-   |                            ^^ type argument not allowed\n+   |                 --------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:93:23\n    |\n LL |     Alias::UVariant::<()>;\n-   |                       ^^ type argument not allowed\n+   |            --------   ^^ type argument not allowed\n+   |            |\n+   |            not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:95:29\n    |\n LL |     Alias::<()>::UVariant::<()>;\n-   |                             ^^ type argument not allowed\n+   |                  --------   ^^ type argument not allowed\n+   |                  |\n+   |                  not allowed on this\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:98:28\n    |\n LL |     AliasFixed::UVariant::<()>;\n-   |                            ^^ type argument not allowed\n+   |                 --------   ^^ type argument not allowed\n+   |                 |\n+   |                 not allowed on this\n \n error[E0107]: this type alias takes 0 generic arguments but 1 generic argument was supplied\n   --> $DIR/enum-variant-generic-args.rs:100:5\n@@ -324,11 +498,13 @@ note: type alias defined here, with 0 generic parameters\n LL | type AliasFixed = Enum<()>;\n    |      ^^^^^^^^^^\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/enum-variant-generic-args.rs:102:34\n    |\n LL |     AliasFixed::<()>::UVariant::<()>;\n-   |                                  ^^ type argument not allowed\n+   |                       --------   ^^ type argument not allowed\n+   |                       |\n+   |                       not allowed on this\n \n error: aborting due to 39 previous errors\n "}, {"sha": "872ece0c0f99e4d1dedd99601c33b995ca7b1848", "filename": "src/test/ui/type-alias-enum-variants/no-type-application-on-aliased-enum-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -10,5 +10,5 @@ fn main() {\n     let _ = Option::<u8>::None; // OK\n     let _ = Option::None::<u8>; // OK (Lint in future!)\n     let _ = Alias::<u8>::None; // OK\n-    let _ = Alias::None::<u8>; //~ ERROR type arguments are not allowed for this type\n+    let _ = Alias::None::<u8>; //~ ERROR type arguments are not allowed on this type\n }"}, {"sha": "474548a14a9a6e9e89731a82f10c79f6f7a97055", "filename": "src/test/ui/type-alias-enum-variants/no-type-application-on-aliased-enum-variant.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-enum-variants%2Fno-type-application-on-aliased-enum-variant.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,8 +1,10 @@\n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/no-type-application-on-aliased-enum-variant.rs:13:27\n    |\n LL |     let _ = Alias::None::<u8>;\n-   |                           ^^ type argument not allowed\n+   |                    ----   ^^ type argument not allowed\n+   |                    |\n+   |                    not allowed on this\n \n error: aborting due to previous error\n "}, {"sha": "01ed9ea9e231ff2d73e4996b1cc45b5b2a2b6ec0", "filename": "src/test/ui/type/issue-91268.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype%2Fissue-91268.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype%2Fissue-91268.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fissue-91268.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,7 +1,7 @@\n // error-pattern: this file contains an unclosed delimiter\n // error-pattern: cannot find type `\u0163` in this scope\n // error-pattern: parenthesized type parameters may only be used with a `Fn` trait\n-// error-pattern: type arguments are not allowed for this type\n+// error-pattern: type arguments are not allowed on this type\n // error-pattern: mismatched types\n // ignore-tidy-trailing-newlines\n // `\u0163` must be the last character in this file, it cannot be followed by a newline"}, {"sha": "199fd6a23f75550af2c8c6615523b92cc47ef8c6", "filename": "src/test/ui/type/issue-91268.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype%2Fissue-91268.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftype%2Fissue-91268.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Fissue-91268.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -30,11 +30,19 @@ error[E0214]: parenthesized type parameters may only be used with a `Fn` trait\n LL |     0: u8(\u0163\n    |        ^^^^ only `Fn` traits may use parentheses\n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/issue-91268.rs:9:11\n    |\n LL |     0: u8(\u0163\n-   |           ^ type argument not allowed\n+   |        -- ^ type argument not allowed\n+   |        |\n+   |        not allowed on this\n+   |\n+help: primitive type `u8` doesn't have generic parameters\n+   |\n+LL -     0: u8(\u0163\n+LL +     0: u8\n+   | \n \n error[E0308]: mismatched types\n   --> $DIR/issue-91268.rs:9:5"}, {"sha": "1c5fd7508676a640bf0952ed3ac5fd9309437195", "filename": "src/test/ui/typeck/prim-with-args.fixed", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.fixed?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -0,0 +1,28 @@\n+// run-rustfix\n+fn main() {\n+\n+let _x: isize; //~ ERROR type arguments are not allowed on this type\n+let _x: i8; //~ ERROR type arguments are not allowed on this type\n+let _x: i16; //~ ERROR type arguments are not allowed on this type\n+let _x: i32; //~ ERROR type arguments are not allowed on this type\n+let _x: i64; //~ ERROR type arguments are not allowed on this type\n+let _x: usize; //~ ERROR type arguments are not allowed on this type\n+let _x: u8; //~ ERROR type arguments are not allowed on this type\n+let _x: u16; //~ ERROR type arguments are not allowed on this type\n+let _x: u32; //~ ERROR type arguments are not allowed on this type\n+let _x: u64; //~ ERROR type arguments are not allowed on this type\n+let _x: char; //~ ERROR type arguments are not allowed on this type\n+\n+let _x: isize; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i8; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i16; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i32; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i64; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: usize; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u8; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u16; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u32; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u64; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: char; //~ ERROR lifetime arguments are not allowed on this type\n+\n+}"}, {"sha": "b05d6c1cb4e4a4e190ac03fd6116fd3dc4df4815", "filename": "src/test/ui/typeck/prim-with-args.rs", "status": "modified", "additions": 23, "deletions": 22, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,27 +1,28 @@\n+// run-rustfix\n fn main() {\n \n-let x: isize<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i8<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i16<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i32<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: i64<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: usize<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u8<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u16<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u32<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: u64<isize>; //~ ERROR type arguments are not allowed for this type\n-let x: char<isize>; //~ ERROR type arguments are not allowed for this type\n+let _x: isize<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: i8<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: i16<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: i32<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: i64<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: usize<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: u8<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: u16<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: u32<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: u64<isize>; //~ ERROR type arguments are not allowed on this type\n+let _x: char<isize>; //~ ERROR type arguments are not allowed on this type\n \n-let x: isize<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i8<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i16<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i32<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: i64<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: usize<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u8<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u16<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u32<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: u64<'static>; //~ ERROR lifetime arguments are not allowed for this type\n-let x: char<'static>; //~ ERROR lifetime arguments are not allowed for this type\n+let _x: isize<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i8<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i16<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i32<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: i64<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: usize<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u8<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u16<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u32<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: u64<'static>; //~ ERROR lifetime arguments are not allowed on this type\n+let _x: char<'static>; //~ ERROR lifetime arguments are not allowed on this type\n \n }"}, {"sha": "7e7bc580b3b9535b9edb0e8743e8958e218da76a", "filename": "src/test/ui/typeck/prim-with-args.stderr", "status": "modified", "additions": 259, "deletions": 83, "changes": 342, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Fprim-with-args.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,134 +1,310 @@\n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:3:14\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:4:15\n    |\n-LL | let x: isize<isize>;\n-   |              ^^^^^ type argument not allowed\n-\n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:4:11\n+LL | let _x: isize<isize>;\n+   |         ----- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `isize` doesn't have generic parameters\n    |\n-LL | let x: i8<isize>;\n-   |           ^^^^^ type argument not allowed\n+LL - let _x: isize<isize>;\n+LL + let _x: isize;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:5:12\n    |\n-LL | let x: i16<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL | let _x: i8<isize>;\n+   |         -- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i8` doesn't have generic parameters\n+   |\n+LL - let _x: i8<isize>;\n+LL + let _x: i8;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:6:12\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:6:13\n+   |\n+LL | let _x: i16<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i16` doesn't have generic parameters\n    |\n-LL | let x: i32<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL - let _x: i16<isize>;\n+LL + let _x: i16;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:7:12\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:7:13\n    |\n-LL | let x: i64<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL | let _x: i32<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i32` doesn't have generic parameters\n+   |\n+LL - let _x: i32<isize>;\n+LL + let _x: i32;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:8:14\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:8:13\n+   |\n+LL | let _x: i64<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n    |\n-LL | let x: usize<isize>;\n-   |              ^^^^^ type argument not allowed\n+help: primitive type `i64` doesn't have generic parameters\n+   |\n+LL - let _x: i64<isize>;\n+LL + let _x: i64;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:9:11\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:9:15\n+   |\n+LL | let _x: usize<isize>;\n+   |         ----- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `usize` doesn't have generic parameters\n    |\n-LL | let x: u8<isize>;\n-   |           ^^^^^ type argument not allowed\n+LL - let _x: usize<isize>;\n+LL + let _x: usize;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:10:12\n    |\n-LL | let x: u16<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL | let _x: u8<isize>;\n+   |         -- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u8` doesn't have generic parameters\n+   |\n+LL - let _x: u8<isize>;\n+LL + let _x: u8;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:11:12\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:11:13\n+   |\n+LL | let _x: u16<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n    |\n-LL | let x: u32<isize>;\n-   |            ^^^^^ type argument not allowed\n+help: primitive type `u16` doesn't have generic parameters\n+   |\n+LL - let _x: u16<isize>;\n+LL + let _x: u16;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:12:12\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:12:13\n+   |\n+LL | let _x: u32<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u32` doesn't have generic parameters\n    |\n-LL | let x: u64<isize>;\n-   |            ^^^^^ type argument not allowed\n+LL - let _x: u32<isize>;\n+LL + let _x: u32;\n+   | \n \n-error[E0109]: type arguments are not allowed for this type\n+error[E0109]: type arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:13:13\n    |\n-LL | let x: char<isize>;\n-   |             ^^^^^ type argument not allowed\n+LL | let _x: u64<isize>;\n+   |         --- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u64` doesn't have generic parameters\n+   |\n+LL - let _x: u64<isize>;\n+LL + let _x: u64;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:15:14\n+error[E0109]: type arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:14:14\n+   |\n+LL | let _x: char<isize>;\n+   |         ---- ^^^^^ type argument not allowed\n+   |         |\n+   |         not allowed on this\n    |\n-LL | let x: isize<'static>;\n-   |              ^^^^^^^ lifetime argument not allowed\n+help: primitive type `char` doesn't have generic parameters\n+   |\n+LL - let _x: char<isize>;\n+LL + let _x: char;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:16:11\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:16:15\n+   |\n+LL | let _x: isize<'static>;\n+   |         ----- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n    |\n-LL | let x: i8<'static>;\n-   |           ^^^^^^^ lifetime argument not allowed\n+help: primitive type `isize` doesn't have generic parameters\n+   |\n+LL - let _x: isize<'static>;\n+LL + let _x: isize;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n+error[E0109]: lifetime arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:17:12\n    |\n-LL | let x: i16<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: i8<'static>;\n+   |         -- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i8` doesn't have generic parameters\n+   |\n+LL - let _x: i8<'static>;\n+LL + let _x: i8;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:18:12\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:18:13\n    |\n-LL | let x: i32<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: i16<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i16` doesn't have generic parameters\n+   |\n+LL - let _x: i16<'static>;\n+LL + let _x: i16;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:19:12\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:19:13\n+   |\n+LL | let _x: i32<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n    |\n-LL | let x: i64<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+help: primitive type `i32` doesn't have generic parameters\n+   |\n+LL - let _x: i32<'static>;\n+LL + let _x: i32;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:20:14\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:20:13\n+   |\n+LL | let _x: i64<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `i64` doesn't have generic parameters\n    |\n-LL | let x: usize<'static>;\n-   |              ^^^^^^^ lifetime argument not allowed\n+LL - let _x: i64<'static>;\n+LL + let _x: i64;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:21:11\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:21:15\n    |\n-LL | let x: u8<'static>;\n-   |           ^^^^^^^ lifetime argument not allowed\n+LL | let _x: usize<'static>;\n+   |         ----- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `usize` doesn't have generic parameters\n+   |\n+LL - let _x: usize<'static>;\n+LL + let _x: usize;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n+error[E0109]: lifetime arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:22:12\n    |\n-LL | let x: u16<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: u8<'static>;\n+   |         -- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u8` doesn't have generic parameters\n+   |\n+LL - let _x: u8<'static>;\n+LL + let _x: u8;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:23:12\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:23:13\n+   |\n+LL | let _x: u16<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u16` doesn't have generic parameters\n    |\n-LL | let x: u32<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL - let _x: u16<'static>;\n+LL + let _x: u16;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n-  --> $DIR/prim-with-args.rs:24:12\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:24:13\n    |\n-LL | let x: u64<'static>;\n-   |            ^^^^^^^ lifetime argument not allowed\n+LL | let _x: u32<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u32` doesn't have generic parameters\n+   |\n+LL - let _x: u32<'static>;\n+LL + let _x: u32;\n+   | \n \n-error[E0109]: lifetime arguments are not allowed for this type\n+error[E0109]: lifetime arguments are not allowed on this type\n   --> $DIR/prim-with-args.rs:25:13\n    |\n-LL | let x: char<'static>;\n-   |             ^^^^^^^ lifetime argument not allowed\n+LL | let _x: u64<'static>;\n+   |         --- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `u64` doesn't have generic parameters\n+   |\n+LL - let _x: u64<'static>;\n+LL + let _x: u64;\n+   | \n+\n+error[E0109]: lifetime arguments are not allowed on this type\n+  --> $DIR/prim-with-args.rs:26:14\n+   |\n+LL | let _x: char<'static>;\n+   |         ---- ^^^^^^^ lifetime argument not allowed\n+   |         |\n+   |         not allowed on this\n+   |\n+help: primitive type `char` doesn't have generic parameters\n+   |\n+LL - let _x: char<'static>;\n+LL + let _x: char;\n+   | \n \n error: aborting due to 22 previous errors\n "}, {"sha": "6d17ba9b5b26199c599edc7686bfc3c150b36d80", "filename": "src/test/ui/usize-generic-argument-parent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fusize-generic-argument-parent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fusize-generic-argument-parent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fusize-generic-argument-parent.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,5 +1,5 @@\n fn foo() {\n-    let x: usize<foo>; //~ ERROR const arguments are not allowed for this type\n+    let x: usize<foo>; //~ ERROR const arguments are not allowed on this type\n }\n \n fn main() {}"}, {"sha": "c657f0faa0b98a64ba2a0252ad8e9d6cf579759a", "filename": "src/test/ui/usize-generic-argument-parent.stderr", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fusize-generic-argument-parent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftest%2Fui%2Fusize-generic-argument-parent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fusize-generic-argument-parent.stderr?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -1,8 +1,16 @@\n-error[E0109]: const arguments are not allowed for this type\n+error[E0109]: const arguments are not allowed on this type\n   --> $DIR/usize-generic-argument-parent.rs:2:18\n    |\n LL |     let x: usize<foo>;\n-   |                  ^^^ const argument not allowed\n+   |            ----- ^^^ const argument not allowed\n+   |            |\n+   |            not allowed on this\n+   |\n+help: primitive type `usize` doesn't have generic parameters\n+   |\n+LL -     let x: usize<foo>;\n+LL +     let x: usize;\n+   | \n \n error: aborting due to previous error\n "}, {"sha": "070c7e591420d49128fea3160076391425d2c615", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -371,7 +371,7 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n         if let Some(ref lt) = *lifetime {\n             if lt.name == LifetimeName::Static {\n                 self.lts.push(RefLt::Static);\n-            } else if let LifetimeName::Param(ParamName::Fresh(_)) = lt.name {\n+            } else if let LifetimeName::Param(_, ParamName::Fresh) = lt.name {\n                 // Fresh lifetimes generated should be ignored.\n             } else if lt.is_elided() {\n                 self.lts.push(RefLt::Unnamed);"}, {"sha": "0b96f6ff6835800aec2f42ec9614c88319c8425a", "filename": "src/tools/clippy/clippy_lints/src/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fptr.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -343,7 +343,7 @@ impl fmt::Display for RefPrefix {\n         use fmt::Write;\n         f.write_char('&')?;\n         match self.lt {\n-            LifetimeName::Param(ParamName::Plain(name)) => {\n+            LifetimeName::Param(_, ParamName::Plain(name)) => {\n                 name.fmt(f)?;\n                 f.write_char(' ')?;\n             },"}, {"sha": "fc1a4e1f6025555bb7c472d6c4c0968676bf3a9b", "filename": "src/tools/clippy/clippy_utils/src/hir_utils.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a74608543d499bcc7dd505e195e8bfab9447315/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fhir_utils.rs?ref=9a74608543d499bcc7dd505e195e8bfab9447315", "patch": "@@ -902,16 +902,14 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n \n     pub fn hash_lifetime(&mut self, lifetime: Lifetime) {\n         std::mem::discriminant(&lifetime.name).hash(&mut self.s);\n-        if let LifetimeName::Param(ref name) = lifetime.name {\n+        if let LifetimeName::Param(param_id, ref name) = lifetime.name {\n             std::mem::discriminant(name).hash(&mut self.s);\n+            param_id.hash(&mut self.s);\n             match name {\n                 ParamName::Plain(ref ident) => {\n                     ident.name.hash(&mut self.s);\n                 },\n-                ParamName::Fresh(ref size) => {\n-                    size.hash(&mut self.s);\n-                },\n-                ParamName::Error => {},\n+                ParamName::Fresh | ParamName::Error => {},\n             }\n         }\n     }"}]}