{"sha": "f381a962550436f74dd6e9021e4df2fdefb96cfa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYzODFhOTYyNTUwNDM2Zjc0ZGQ2ZTkwMjFlNGRmMmZkZWZiOTZjZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-04T19:39:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-04T19:39:24Z"}, "message": "Auto merge of #56897 - euclio:parse-fatal, r=estebank\n\nmake `panictry!` private to libsyntax\n\nThis commit completely removes usage of the `panictry!` macro from\noutside libsyntax. The macro causes parse errors to be fatal, so using\nit in libsyntax_ext caused parse failures *within* a syntax extension to\nbe fatal, which is probably not intended.\n\nFurthermore, this commit adds spans to diagnostics emitted by empty\nextensions if they were missing, \u00e0 la #56491.", "tree": {"sha": "77fa25a202ad750cac637116d2d01a9298b81d70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/77fa25a202ad750cac637116d2d01a9298b81d70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f381a962550436f74dd6e9021e4df2fdefb96cfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f381a962550436f74dd6e9021e4df2fdefb96cfa", "html_url": "https://github.com/rust-lang/rust/commit/f381a962550436f74dd6e9021e4df2fdefb96cfa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f381a962550436f74dd6e9021e4df2fdefb96cfa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6d32ac25df2984f66b6abd14c1096880e04179a", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6d32ac25df2984f66b6abd14c1096880e04179a", "html_url": "https://github.com/rust-lang/rust/commit/d6d32ac25df2984f66b6abd14c1096880e04179a"}, {"sha": "0a6fb8473872b2a6dd7fe66697f90dceac667ec4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a6fb8473872b2a6dd7fe66697f90dceac667ec4", "html_url": "https://github.com/rust-lang/rust/commit/0a6fb8473872b2a6dd7fe66697f90dceac667ec4"}], "stats": {"total": 585, "additions": 451, "deletions": 134}, "files": [{"sha": "032b0fc974845cac2c0a08dbff1626335602b4f9", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -23,7 +23,7 @@ use syntax::json::JsonEmitter;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax_pos::DUMMY_SP;\n-use errors;\n+use errors::{self, FatalError};\n use errors::emitter::{Emitter, EmitterWriter};\n use parking_lot::ReentrantMutex;\n \n@@ -429,7 +429,13 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n \n         let control = &driver::CompileController::basic();\n \n-        let krate = panictry!(driver::phase_1_parse_input(control, &sess, &input));\n+        let krate = match driver::phase_1_parse_input(control, &sess, &input) {\n+            Ok(krate) => krate,\n+            Err(mut e) => {\n+                e.emit();\n+                FatalError.raise();\n+            }\n+        };\n \n         let name = match crate_name {\n             Some(ref crate_name) => crate_name.clone(),"}, {"sha": "1b6d7e87192d6f12eb82e120ac20ba0e01c52335", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -32,7 +32,7 @@ extern crate rustc_metadata;\n extern crate rustc_target;\n extern crate rustc_typeck;\n extern crate serialize;\n-#[macro_use] extern crate syntax;\n+extern crate syntax;\n extern crate syntax_pos;\n extern crate test as testing;\n #[macro_use] extern crate log;"}, {"sha": "dd9fbbb254662cc52d67020c30f134ad7949f833", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -1,4 +1,4 @@\n-use errors;\n+use errors::{self, FatalError};\n use errors::emitter::ColorConfig;\n use rustc_data_structures::sync::Lrc;\n use rustc_lint;\n@@ -84,9 +84,14 @@ pub fn run(mut options: Options) -> isize {\n         target_features::add_configuration(&mut cfg, &sess, &*codegen_backend);\n         sess.parse_sess.config = cfg;\n \n-        let krate = panictry!(driver::phase_1_parse_input(&driver::CompileController::basic(),\n-                                                        &sess,\n-                                                        &input));\n+        let krate =\n+            match driver::phase_1_parse_input(&driver::CompileController::basic(), &sess, &input) {\n+                Ok(krate) => krate,\n+                Err(mut e) => {\n+                    e.emit();\n+                    FatalError.raise();\n+                }\n+            };\n         let driver::ExpansionResult { defs, mut hir_forest, .. } = {\n             phase_2_configure_and_expand(\n                 &sess,"}, {"sha": "ea943e16a46e841aa63c1c9845e73fcd0b42f1ef", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -44,8 +44,6 @@ use ast::AttrId;\n // way towards a non-panic!-prone parser. It should be used for fatal parsing\n // errors; eventually we plan to convert all code using panictry to just use\n // normal try.\n-// Exported for syntax_ext, not meant for general use.\n-#[macro_export]\n macro_rules! panictry {\n     ($e:expr) => ({\n         use std::result::Result::{Ok, Err};"}, {"sha": "41ee6e91b3dc96f03e70a4b9bdee35364dd28587", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 71, "deletions": 45, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -4,6 +4,7 @@ use self::State::*;\n \n use rustc_data_structures::thin_vec::ThinVec;\n \n+use errors::DiagnosticBuilder;\n use syntax::ast;\n use syntax::ext::base;\n use syntax::ext::base::*;\n@@ -51,6 +52,34 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                                        feature_gate::EXPLAIN_ASM);\n     }\n \n+    let mut inline_asm = match parse_inline_asm(cx, sp, tts) {\n+        Ok(Some(inline_asm)) => inline_asm,\n+        Ok(None) => return DummyResult::expr(sp),\n+        Err(mut err) => {\n+            err.emit();\n+            return DummyResult::expr(sp);\n+        }\n+    };\n+\n+    // If there are no outputs, the inline assembly is executed just for its side effects,\n+    // so ensure that it is volatile\n+    if inline_asm.outputs.is_empty() {\n+        inline_asm.volatile = true;\n+    }\n+\n+    MacEager::expr(P(ast::Expr {\n+        id: ast::DUMMY_NODE_ID,\n+        node: ast::ExprKind::InlineAsm(P(inline_asm)),\n+        span: sp,\n+        attrs: ThinVec::new(),\n+    }))\n+}\n+\n+fn parse_inline_asm<'a>(\n+    cx: &mut ExtCtxt<'a>,\n+    sp: Span,\n+    tts: &[tokenstream::TokenTree],\n+) -> Result<Option<ast::InlineAsm>, DiagnosticBuilder<'a>> {\n     // Split the tts before the first colon, to avoid `asm!(\"x\": y)`  being\n     // parsed as `asm!(z)` with `z = \"x\": y` which is type ascription.\n     let first_colon = tts.iter()\n@@ -80,22 +109,33 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                 if asm_str_style.is_some() {\n                     // If we already have a string with instructions,\n                     // ending up in Asm state again is an error.\n-                    span_err!(cx, sp, E0660, \"malformed inline assembly\");\n-                    return DummyResult::expr(sp);\n+                    return Err(struct_span_err!(\n+                        cx.parse_sess.span_diagnostic,\n+                        sp,\n+                        E0660,\n+                        \"malformed inline assembly\"\n+                    ));\n                 }\n                 // Nested parser, stop before the first colon (see above).\n                 let mut p2 = cx.new_parser_from_tts(&tts[..first_colon]);\n-                let (s, style) = match expr_to_string(cx,\n-                                                      panictry!(p2.parse_expr()),\n-                                                      \"inline assembly must be a string literal\") {\n-                    Some((s, st)) => (s, st),\n-                    // let compilation continue\n-                    None => return DummyResult::expr(sp),\n-                };\n+\n+                if p2.token == token::Eof {\n+                    let mut err =\n+                        cx.struct_span_err(sp, \"macro requires a string literal as an argument\");\n+                    err.span_label(sp, \"string literal required\");\n+                    return Err(err);\n+                }\n+\n+                let expr = p2.parse_expr()?;\n+                let (s, style) =\n+                    match expr_to_string(cx, expr, \"inline assembly must be a string literal\") {\n+                        Some((s, st)) => (s, st),\n+                        None => return Ok(None),\n+                    };\n \n                 // This is most likely malformed.\n                 if p2.token != token::Eof {\n-                    let mut extra_tts = panictry!(p2.parse_all_token_trees());\n+                    let mut extra_tts = p2.parse_all_token_trees()?;\n                     extra_tts.extend(tts[first_colon..].iter().cloned());\n                     p = parse::stream_to_parser(cx.parse_sess, extra_tts.into_iter().collect());\n                 }\n@@ -105,18 +145,17 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n             }\n             Outputs => {\n                 while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n-\n                     if !outputs.is_empty() {\n                         p.eat(&token::Comma);\n                     }\n \n-                    let (constraint, _str_style) = panictry!(p.parse_str());\n+                    let (constraint, _) = p.parse_str()?;\n \n                     let span = p.prev_span;\n \n-                    panictry!(p.expect(&token::OpenDelim(token::Paren)));\n-                    let out = panictry!(p.parse_expr());\n-                    panictry!(p.expect(&token::CloseDelim(token::Paren)));\n+                    p.expect(&token::OpenDelim(token::Paren))?;\n+                    let expr = p.parse_expr()?;\n+                    p.expect(&token::CloseDelim(token::Paren))?;\n \n                     // Expands a read+write operand into two operands.\n                     //\n@@ -143,20 +182,19 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                     let is_indirect = constraint_str.contains(\"*\");\n                     outputs.push(ast::InlineAsmOutput {\n                         constraint: output.unwrap_or(constraint),\n-                        expr: out,\n+                        expr,\n                         is_rw,\n                         is_indirect,\n                     });\n                 }\n             }\n             Inputs => {\n                 while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n-\n                     if !inputs.is_empty() {\n                         p.eat(&token::Comma);\n                     }\n \n-                    let (constraint, _str_style) = panictry!(p.parse_str());\n+                    let (constraint, _) = p.parse_str()?;\n \n                     if constraint.as_str().starts_with(\"=\") {\n                         span_err!(cx, p.prev_span, E0662,\n@@ -166,21 +204,20 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                                                 \"input operand constraint contains '+'\");\n                     }\n \n-                    panictry!(p.expect(&token::OpenDelim(token::Paren)));\n-                    let input = panictry!(p.parse_expr());\n-                    panictry!(p.expect(&token::CloseDelim(token::Paren)));\n+                    p.expect(&token::OpenDelim(token::Paren))?;\n+                    let input = p.parse_expr()?;\n+                    p.expect(&token::CloseDelim(token::Paren))?;\n \n                     inputs.push((constraint, input));\n                 }\n             }\n             Clobbers => {\n                 while p.token != token::Eof && p.token != token::Colon && p.token != token::ModSep {\n-\n                     if !clobs.is_empty() {\n                         p.eat(&token::Comma);\n                     }\n \n-                    let (s, _str_style) = panictry!(p.parse_str());\n+                    let (s, _) = p.parse_str()?;\n \n                     if OPTIONS.iter().any(|&opt| s == opt) {\n                         cx.span_warn(p.prev_span, \"expected a clobber, found an option\");\n@@ -193,7 +230,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n                 }\n             }\n             Options => {\n-                let (option, _str_style) = panictry!(p.parse_str());\n+                let (option, _) = p.parse_str()?;\n \n                 if option == \"volatile\" {\n                     // Indicates that the inline assembly has side effects\n@@ -234,26 +271,15 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt,\n         }\n     }\n \n-    // If there are no outputs, the inline assembly is executed just for its side effects,\n-    // so ensure that it is volatile\n-    if outputs.is_empty() {\n-        volatile = true;\n-    }\n-\n-    MacEager::expr(P(ast::Expr {\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ExprKind::InlineAsm(P(ast::InlineAsm {\n-            asm,\n-            asm_str_style: asm_str_style.unwrap(),\n-            outputs,\n-            inputs,\n-            clobbers: clobs,\n-            volatile,\n-            alignstack,\n-            dialect,\n-            ctxt: cx.backtrace(),\n-        })),\n-        span: sp,\n-        attrs: ThinVec::new(),\n+    Ok(Some(ast::InlineAsm {\n+        asm,\n+        asm_str_style: asm_str_style.unwrap(),\n+        outputs,\n+        inputs,\n+        clobbers: clobs,\n+        volatile,\n+        alignstack,\n+        dialect,\n+        ctxt: cx.backtrace(),\n     }))\n }"}, {"sha": "b27f495322a42c8ab834ea24d9e33519c56209ae", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 44, "deletions": 24, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -1,9 +1,11 @@\n-use syntax::ast::*;\n+use errors::DiagnosticBuilder;\n+use syntax::ast::{self, *};\n use syntax::source_map::Spanned;\n use syntax::ext::base::*;\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token;\n use syntax::print::pprust;\n+use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax::tokenstream::{TokenStream, TokenTree};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -13,33 +15,18 @@ pub fn expand_assert<'cx>(\n     sp: Span,\n     tts: &[TokenTree],\n ) -> Box<dyn MacResult + 'cx> {\n-    let mut parser = cx.new_parser_from_tts(tts);\n-\n-    if parser.token == token::Eof {\n-        cx.struct_span_err(sp, \"macro requires a boolean expression as an argument\")\n-            .span_label(sp, \"boolean expression required\")\n-            .emit();\n-        return DummyResult::expr(sp);\n-    }\n-\n-    let cond_expr = panictry!(parser.parse_expr());\n-    let custom_msg_args = if parser.eat(&token::Comma) {\n-        let ts = parser.parse_tokens();\n-        if !ts.is_empty() {\n-            Some(ts)\n-        } else {\n-            None\n+    let Assert { cond_expr, custom_message } = match parse_assert(cx, sp, tts) {\n+        Ok(assert) => assert,\n+        Err(mut err) => {\n+            err.emit();\n+            return DummyResult::expr(sp);\n         }\n-    } else {\n-        None\n     };\n \n     let sp = sp.apply_mark(cx.current_expansion.mark);\n     let panic_call = Mac_ {\n         path: Path::from_ident(Ident::new(Symbol::intern(\"panic\"), sp)),\n-        tts: if let Some(ts) = custom_msg_args {\n-            ts.into()\n-        } else {\n+        tts: custom_message.unwrap_or_else(|| {\n             TokenStream::from(TokenTree::Token(\n                 DUMMY_SP,\n                 token::Literal(\n@@ -49,8 +36,8 @@ pub fn expand_assert<'cx>(\n                     ))),\n                     None,\n                 ),\n-            )).into()\n-        },\n+            ))\n+        }).into(),\n         delim: MacDelimiter::Parenthesis,\n     };\n     let if_expr = cx.expr_if(\n@@ -67,3 +54,36 @@ pub fn expand_assert<'cx>(\n     );\n     MacEager::expr(if_expr)\n }\n+\n+struct Assert {\n+    cond_expr: P<ast::Expr>,\n+    custom_message: Option<TokenStream>,\n+}\n+\n+fn parse_assert<'a>(\n+    cx: &mut ExtCtxt<'a>,\n+    sp: Span,\n+    tts: &[TokenTree]\n+) -> Result<Assert, DiagnosticBuilder<'a>> {\n+    let mut parser = cx.new_parser_from_tts(tts);\n+\n+    if parser.token == token::Eof {\n+        let mut err = cx.struct_span_err(sp, \"macro requires a boolean expression as an argument\");\n+        err.span_label(sp, \"boolean expression required\");\n+        return Err(err);\n+    }\n+\n+    Ok(Assert {\n+        cond_expr: parser.parse_expr()?,\n+        custom_message: if parser.eat(&token::Comma) {\n+            let ts = parser.parse_tokens();\n+            if !ts.is_empty() {\n+                Some(ts)\n+            } else {\n+                None\n+            }\n+        } else {\n+            None\n+        },\n+    })\n+}"}, {"sha": "3b47b03cbe8dcbe665fe75375dfb2ed460a1a88c", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -2,6 +2,8 @@\n /// a literal `true` or `false` based on whether the given cfg matches the\n /// current compilation environment.\n \n+use errors::DiagnosticBuilder;\n+use syntax::ast;\n use syntax::ext::base::*;\n use syntax::ext::base;\n use syntax::ext::build::AstBuilder;\n@@ -15,16 +17,39 @@ pub fn expand_cfg<'cx>(cx: &mut ExtCtxt,\n                        tts: &[tokenstream::TokenTree])\n                        -> Box<dyn base::MacResult + 'static> {\n     let sp = sp.apply_mark(cx.current_expansion.mark);\n+\n+    match parse_cfg(cx, sp, tts) {\n+        Ok(cfg) => {\n+            let matches_cfg = attr::cfg_matches(&cfg, cx.parse_sess, cx.ecfg.features);\n+            MacEager::expr(cx.expr_bool(sp, matches_cfg))\n+        }\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::expr(sp)\n+        }\n+    }\n+}\n+\n+fn parse_cfg<'a>(\n+    cx: &mut ExtCtxt<'a>,\n+    sp: Span,\n+    tts: &[tokenstream::TokenTree],\n+) -> Result<ast::MetaItem, DiagnosticBuilder<'a>> {\n     let mut p = cx.new_parser_from_tts(tts);\n-    let cfg = panictry!(p.parse_meta_item());\n+\n+    if p.token == token::Eof {\n+        let mut err = cx.struct_span_err(sp, \"macro requires a cfg-pattern as an argument\");\n+        err.span_label(sp, \"cfg-pattern required\");\n+        return Err(err);\n+    }\n+\n+    let cfg = p.parse_meta_item()?;\n \n     let _ = p.eat(&token::Comma);\n \n     if !p.eat(&token::Eof) {\n-        cx.span_err(sp, \"expected 1 cfg-pattern\");\n-        return DummyResult::expr(sp);\n+        return Err(cx.struct_span_err(sp, \"expected 1 cfg-pattern\"));\n     }\n \n-    let matches_cfg = attr::cfg_matches(&cfg, cx.parse_sess, cx.ecfg.features);\n-    MacEager::expr(cx.expr_bool(sp, matches_cfg))\n+    Ok(cfg)\n }"}, {"sha": "61722ba5516535a9ec5e3f3eea5bd2b3b4d8f7ef", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 27, "deletions": 21, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -3,6 +3,7 @@ use self::Position::*;\n \n use fmt_macros as parse;\n \n+use errors::DiagnosticBuilder;\n use syntax::ast;\n use syntax::ext::base::{self, *};\n use syntax::ext::build::AstBuilder;\n@@ -112,7 +113,7 @@ struct Context<'a, 'b: 'a> {\n     is_literal: bool,\n }\n \n-/// Parses the arguments from the given list of tokens, returning None\n+/// Parses the arguments from the given list of tokens, returning the diagnostic\n /// if there's a parse error so we can continue parsing other format!\n /// expressions.\n ///\n@@ -121,27 +122,26 @@ struct Context<'a, 'b: 'a> {\n /// ```text\n /// Some((fmtstr, parsed arguments, index map for named arguments))\n /// ```\n-fn parse_args(ecx: &mut ExtCtxt,\n-              sp: Span,\n-              tts: &[tokenstream::TokenTree])\n-              -> Option<(P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<String, usize>)> {\n+fn parse_args<'a>(\n+    ecx: &mut ExtCtxt<'a>,\n+    sp: Span,\n+    tts: &[tokenstream::TokenTree]\n+) -> Result<(P<ast::Expr>, Vec<P<ast::Expr>>, FxHashMap<String, usize>), DiagnosticBuilder<'a>> {\n     let mut args = Vec::<P<ast::Expr>>::new();\n     let mut names = FxHashMap::<String, usize>::default();\n \n     let mut p = ecx.new_parser_from_tts(tts);\n \n     if p.token == token::Eof {\n-        ecx.span_err(sp, \"requires at least a format string argument\");\n-        return None;\n+        return Err(ecx.struct_span_err(sp, \"requires at least a format string argument\"));\n     }\n \n-    let fmtstr = panictry!(p.parse_expr());\n+    let fmtstr = p.parse_expr()?;\n     let mut named = false;\n \n     while p.token != token::Eof {\n         if !p.eat(&token::Comma) {\n-            ecx.span_err(p.span, \"expected token: `,`\");\n-            return None;\n+            return Err(ecx.struct_span_err(p.span, \"expected token: `,`\"));\n         }\n         if p.token == token::Eof {\n             break;\n@@ -152,16 +152,15 @@ fn parse_args(ecx: &mut ExtCtxt,\n                 p.bump();\n                 i\n             } else {\n-                ecx.span_err(\n+                return Err(ecx.struct_span_err(\n                     p.span,\n                     \"expected ident, positional arguments cannot follow named arguments\",\n-                );\n-                return None;\n+                ));\n             };\n             let name: &str = &ident.as_str();\n \n-            panictry!(p.expect(&token::Eq));\n-            let e = panictry!(p.parse_expr());\n+            p.expect(&token::Eq).unwrap();\n+            let e = p.parse_expr()?;\n             if let Some(prev) = names.get(name) {\n                 ecx.struct_span_err(e.span, &format!(\"duplicate argument named `{}`\", name))\n                     .span_note(args[*prev].span, \"previously here\")\n@@ -177,10 +176,11 @@ fn parse_args(ecx: &mut ExtCtxt,\n             names.insert(name.to_string(), slot);\n             args.push(e);\n         } else {\n-            args.push(panictry!(p.parse_expr()));\n+            let e = p.parse_expr()?;\n+            args.push(e);\n         }\n     }\n-    Some((fmtstr, args, names))\n+    Ok((fmtstr, args, names))\n }\n \n impl<'a, 'b> Context<'a, 'b> {\n@@ -689,10 +689,13 @@ pub fn expand_format_args<'cx>(ecx: &'cx mut ExtCtxt,\n                                -> Box<dyn base::MacResult + 'cx> {\n     sp = sp.apply_mark(ecx.current_expansion.mark);\n     match parse_args(ecx, sp, tts) {\n-        Some((efmt, args, names)) => {\n+        Ok((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names, false))\n         }\n-        None => DummyResult::expr(sp),\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::expr(sp)\n+        }\n     }\n }\n \n@@ -716,10 +719,13 @@ pub fn expand_format_args_nl<'cx>(\n     }\n     sp = sp.apply_mark(ecx.current_expansion.mark);\n     match parse_args(ecx, sp, tts) {\n-        Some((efmt, args, names)) => {\n+        Ok((efmt, args, names)) => {\n             MacEager::expr(expand_preparsed_format_args(ecx, sp, efmt, args, names, true))\n         }\n-        None => DummyResult::expr(sp),\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::expr(sp)\n+        }\n     }\n }\n "}, {"sha": "0a12e27c4fc219d94639401c004d3e1aa0aa1519", "filename": "src/libsyntax_ext/global_asm.rs", "status": "modified", "additions": 41, "deletions": 16, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fglobal_asm.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -8,11 +8,13 @@\n /// LLVM's `module asm \"some assembly here\"`. All of LLVM's caveats\n /// therefore apply.\n \n+use errors::DiagnosticBuilder;\n use syntax::ast;\n use syntax::source_map::respan;\n use syntax::ext::base;\n use syntax::ext::base::*;\n use syntax::feature_gate;\n+use syntax::parse::token;\n use syntax::ptr::P;\n use syntax::symbol::Symbol;\n use syntax_pos::Span;\n@@ -31,24 +33,47 @@ pub fn expand_global_asm<'cx>(cx: &'cx mut ExtCtxt,\n                                        feature_gate::EXPLAIN_GLOBAL_ASM);\n     }\n \n+    match parse_global_asm(cx, sp, tts) {\n+        Ok(Some(global_asm)) => {\n+            MacEager::items(smallvec![P(ast::Item {\n+                ident: ast::Ident::with_empty_ctxt(Symbol::intern(\"\")),\n+                attrs: Vec::new(),\n+                id: ast::DUMMY_NODE_ID,\n+                node: ast::ItemKind::GlobalAsm(P(global_asm)),\n+                vis: respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n+                span: sp,\n+                tokens: None,\n+            })])\n+        }\n+        Ok(None) => DummyResult::any(sp),\n+        Err(mut err) => {\n+            err.emit();\n+            DummyResult::any(sp)\n+        }\n+    }\n+}\n+\n+fn parse_global_asm<'a>(\n+    cx: &mut ExtCtxt<'a>,\n+    sp: Span,\n+    tts: &[tokenstream::TokenTree]\n+) -> Result<Option<ast::GlobalAsm>, DiagnosticBuilder<'a>> {\n     let mut p = cx.new_parser_from_tts(tts);\n-    let (asm, _) = match expr_to_string(cx,\n-                                        panictry!(p.parse_expr()),\n-                                        \"inline assembly must be a string literal\") {\n+\n+    if p.token == token::Eof {\n+        let mut err = cx.struct_span_err(sp, \"macro requires a string literal as an argument\");\n+        err.span_label(sp, \"string literal required\");\n+        return Err(err);\n+    }\n+\n+    let expr = p.parse_expr()?;\n+    let (asm, _) = match expr_to_string(cx, expr, \"inline assembly must be a string literal\") {\n         Some((s, st)) => (s, st),\n-        None => return DummyResult::any(sp),\n+        None => return Ok(None),\n     };\n \n-    MacEager::items(smallvec![P(ast::Item {\n-        ident: ast::Ident::with_empty_ctxt(Symbol::intern(\"\")),\n-        attrs: Vec::new(),\n-        id: ast::DUMMY_NODE_ID,\n-        node: ast::ItemKind::GlobalAsm(P(ast::GlobalAsm {\n-            asm,\n-            ctxt: cx.backtrace(),\n-        })),\n-        vis: respan(sp.shrink_to_lo(), ast::VisibilityKind::Inherited),\n-        span: sp,\n-        tokens: None,\n-    })])\n+    Ok(Some(ast::GlobalAsm {\n+        asm,\n+        ctxt: cx.backtrace(),\n+    }))\n }"}, {"sha": "9fd46e94f030a2c0e5002ced92cad94d79ea7634", "filename": "src/test/rustdoc-ui/failed-doctest-output.stdout", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Ffailed-doctest-output.stdout?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -12,7 +12,7 @@ error[E0425]: cannot find value `no` in this scope\n 3 | no\n   | ^^ not found in this scope\n \n-thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:316:13\n+thread '$DIR/failed-doctest-output.rs - OtherStruct (line 17)' panicked at 'couldn't compile the test', src/librustdoc/test.rs:321:13\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n ---- $DIR/failed-doctest-output.rs - SomeStruct (line 11) stdout ----\n@@ -21,7 +21,7 @@ thread '$DIR/failed-doctest-output.rs - SomeStruct (line 11)' panicked at 'test\n thread 'main' panicked at 'oh no', $DIR/failed-doctest-output.rs:3:1\n note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.\n \n-', src/librustdoc/test.rs:351:17\n+', src/librustdoc/test.rs:356:17\n \n \n failures:"}, {"sha": "e712ac5826e2ccefb3aef0f77f9a28cd3bc7cee3", "filename": "src/test/ui/asm/asm-parse-errors.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fasm%2Fasm-parse-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fasm%2Fasm-parse-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fasm-parse-errors.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -0,0 +1,15 @@\n+#![feature(asm)]\n+\n+fn main() {\n+    asm!(); //~ ERROR requires a string literal as an argument\n+    asm!(\"nop\" : struct); //~ ERROR expected string literal\n+    asm!(\"mov %eax, $$0x2\" : struct); //~ ERROR expected string literal\n+    asm!(\"mov %eax, $$0x2\" : \"={eax}\" struct); //~ ERROR expected `(`\n+    asm!(\"mov %eax, $$0x2\" : \"={eax}\"(struct)); //~ ERROR expected expression\n+    asm!(\"in %dx, %al\" : \"={al}\"(result) : struct); //~ ERROR expected string literal\n+    asm!(\"in %dx, %al\" : \"={al}\"(result) : \"{dx}\" struct); //~ ERROR expected `(`\n+    asm!(\"in %dx, %al\" : \"={al}\"(result) : \"{dx}\"(struct)); //~ ERROR expected expression\n+    asm!(\"mov $$0x200, %eax\" : : : struct); //~ ERROR expected string literal\n+    asm!(\"mov eax, 2\" : \"={eax}\"(foo) : : : struct); //~ ERROR expected string literal\n+    asm!(123); //~ ERROR inline assembly must be a string literal\n+}"}, {"sha": "37b61b80b2b8938d86cd69bd6357a5cc8468f62d", "filename": "src/test/ui/asm/asm-parse-errors.stderr", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fasm%2Fasm-parse-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fasm%2Fasm-parse-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasm%2Fasm-parse-errors.stderr?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -0,0 +1,68 @@\n+error: macro requires a string literal as an argument\n+  --> $DIR/asm-parse-errors.rs:4:5\n+   |\n+LL |     asm!(); //~ ERROR requires a string literal as an argument\n+   |     ^^^^^^^ string literal required\n+\n+error: expected string literal\n+  --> $DIR/asm-parse-errors.rs:5:18\n+   |\n+LL |     asm!(\"nop\" : struct); //~ ERROR expected string literal\n+   |                  ^^^^^^ expected string literal\n+\n+error: expected string literal\n+  --> $DIR/asm-parse-errors.rs:6:30\n+   |\n+LL |     asm!(\"mov %eax, $$0x2\" : struct); //~ ERROR expected string literal\n+   |                              ^^^^^^ expected string literal\n+\n+error: expected `(`, found keyword `struct`\n+  --> $DIR/asm-parse-errors.rs:7:39\n+   |\n+LL |     asm!(\"mov %eax, $$0x2\" : \"={eax}\" struct); //~ ERROR expected `(`\n+   |                                       ^^^^^^ expected `(`\n+\n+error: expected expression, found keyword `struct`\n+  --> $DIR/asm-parse-errors.rs:8:39\n+   |\n+LL |     asm!(\"mov %eax, $$0x2\" : \"={eax}\"(struct)); //~ ERROR expected expression\n+   |                                       ^^^^^^ expected expression\n+\n+error: expected string literal\n+  --> $DIR/asm-parse-errors.rs:9:44\n+   |\n+LL |     asm!(\"in %dx, %al\" : \"={al}\"(result) : struct); //~ ERROR expected string literal\n+   |                                            ^^^^^^ expected string literal\n+\n+error: expected `(`, found keyword `struct`\n+  --> $DIR/asm-parse-errors.rs:10:51\n+   |\n+LL |     asm!(\"in %dx, %al\" : \"={al}\"(result) : \"{dx}\" struct); //~ ERROR expected `(`\n+   |                                                   ^^^^^^ expected `(`\n+\n+error: expected expression, found keyword `struct`\n+  --> $DIR/asm-parse-errors.rs:11:51\n+   |\n+LL |     asm!(\"in %dx, %al\" : \"={al}\"(result) : \"{dx}\"(struct)); //~ ERROR expected expression\n+   |                                                   ^^^^^^ expected expression\n+\n+error: expected string literal\n+  --> $DIR/asm-parse-errors.rs:12:36\n+   |\n+LL |     asm!(\"mov $$0x200, %eax\" : : : struct); //~ ERROR expected string literal\n+   |                                    ^^^^^^ expected string literal\n+\n+error: expected string literal\n+  --> $DIR/asm-parse-errors.rs:13:45\n+   |\n+LL |     asm!(\"mov eax, 2\" : \"={eax}\"(foo) : : : struct); //~ ERROR expected string literal\n+   |                                             ^^^^^^ expected string literal\n+\n+error: inline assembly must be a string literal\n+  --> $DIR/asm-parse-errors.rs:14:10\n+   |\n+LL |     asm!(123); //~ ERROR inline assembly must be a string literal\n+   |          ^^^\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "9244ff5931d3e93adb75e41222e6f22ac866324c", "filename": "src/test/ui/issues/issue-22644.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fissues%2Fissue-22644.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fissues%2Fissue-22644.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22644.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -1,5 +1,7 @@\n+#![feature(type_ascription)]\n+\n fn main() {\n-    let a : u32 = 0;\n+    let a : usize = 0;\n     let long_name : usize = 0;\n \n     println!(\"{}\", a as usize > long_name);"}, {"sha": "de97b2271b10aa2d278232c15f86e5f3de5c27b5", "filename": "src/test/ui/issues/issue-22644.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22644.stderr?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -1,5 +1,5 @@\n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:6:31\n+  --> $DIR/issue-22644.rs:8:31\n    |\n LL |     println!(\"{}\", a as usize < long_name); //~ ERROR `<` is interpreted as a start of generic\n    |                    ---------- ^ --------- interpreted as generic arguments\n@@ -8,7 +8,7 @@ LL |     println!(\"{}\", a as usize < long_name); //~ ERROR `<` is interpreted as\n    |                    help: try comparing the cast value: `(a as usize)`\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:7:33\n+  --> $DIR/issue-22644.rs:9:33\n    |\n LL |     println!(\"{}{}\", a as usize < long_name, long_name);\n    |                      ---------- ^ -------------------- interpreted as generic arguments\n@@ -17,7 +17,7 @@ LL |     println!(\"{}{}\", a as usize < long_name, long_name);\n    |                      help: try comparing the cast value: `(a as usize)`\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:9:31\n+  --> $DIR/issue-22644.rs:11:31\n    |\n LL |     println!(\"{}\", a as usize < 4); //~ ERROR `<` is interpreted as a start of generic\n    |                    ---------- ^ - interpreted as generic arguments\n@@ -26,7 +26,7 @@ LL |     println!(\"{}\", a as usize < 4); //~ ERROR `<` is interpreted as a start\n    |                    help: try comparing the cast value: `(a as usize)`\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:11:31\n+  --> $DIR/issue-22644.rs:13:31\n    |\n LL |     println!(\"{}{}\", a: usize < long_name, long_name);\n    |                      -------- ^ -------------------- interpreted as generic arguments\n@@ -35,7 +35,7 @@ LL |     println!(\"{}{}\", a: usize < long_name, long_name);\n    |                      help: try comparing the cast value: `(a: usize)`\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:13:29\n+  --> $DIR/issue-22644.rs:15:29\n    |\n LL |     println!(\"{}\", a: usize < 4); //~ ERROR `<` is interpreted as a start of generic\n    |                    -------- ^ - interpreted as generic arguments\n@@ -44,7 +44,7 @@ LL |     println!(\"{}\", a: usize < 4); //~ ERROR `<` is interpreted as a start o\n    |                    help: try comparing the cast value: `(a: usize)`\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:18:20\n+  --> $DIR/issue-22644.rs:20:20\n    |\n LL |                    < //~ ERROR `<` is interpreted as a start of generic\n    |                    ^ not interpreted as comparison\n@@ -58,7 +58,7 @@ LL |                    usize)\n    |\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a comparison\n-  --> $DIR/issue-22644.rs:27:20\n+  --> $DIR/issue-22644.rs:29:20\n    |\n LL |                    < //~ ERROR `<` is interpreted as a start of generic\n    |                    ^ not interpreted as comparison\n@@ -75,7 +75,7 @@ LL |\n  ...\n \n error: `<` is interpreted as a start of generic arguments for `usize`, not a shift\n-  --> $DIR/issue-22644.rs:30:31\n+  --> $DIR/issue-22644.rs:32:31\n    |\n LL |     println!(\"{}\", a as usize << long_name); //~ ERROR `<` is interpreted as a start of generic\n    |                    ---------- ^^ --------- interpreted as generic arguments\n@@ -84,7 +84,7 @@ LL |     println!(\"{}\", a as usize << long_name); //~ ERROR `<` is interpreted a\n    |                    help: try shifting the cast value: `(a as usize)`\n \n error: expected type, found `4`\n-  --> $DIR/issue-22644.rs:32:28\n+  --> $DIR/issue-22644.rs:34:28\n    |\n LL |     println!(\"{}\", a: &mut 4); //~ ERROR expected type, found `4`\n    |                            ^ expecting a type here because of type ascription"}, {"sha": "71b0dbb19e262869116448602260028d2a000d1a", "filename": "src/test/ui/macros/assert.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -1,4 +1,6 @@\n fn main() {\n     assert!();  //~ ERROR requires a boolean expression\n+    assert!(struct); //~ ERROR expected expression\n     debug_assert!(); //~ ERROR requires a boolean expression\n+    debug_assert!(struct); //~ ERROR expected expression\n }"}, {"sha": "2cfcebabcb931619318312c39b9f54c9f430750a", "filename": "src/test/ui/macros/assert.stderr", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fassert.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fassert.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fassert.stderr?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -4,13 +4,25 @@ error: macro requires a boolean expression as an argument\n LL |     assert!();  //~ ERROR requires a boolean expression\n    |     ^^^^^^^^^^ boolean expression required\n \n+error: expected expression, found keyword `struct`\n+  --> $DIR/assert.rs:3:13\n+   |\n+LL |     assert!(struct); //~ ERROR expected expression\n+   |             ^^^^^^ expected expression\n+\n error: macro requires a boolean expression as an argument\n-  --> $DIR/assert.rs:3:5\n+  --> $DIR/assert.rs:4:5\n    |\n LL |     debug_assert!(); //~ ERROR requires a boolean expression\n    |     ^^^^^^^^^^^^^^^^ boolean expression required\n    |\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: aborting due to 2 previous errors\n+error: expected expression, found keyword `struct`\n+  --> $DIR/assert.rs:5:19\n+   |\n+LL |     debug_assert!(struct); //~ ERROR expected expression\n+   |                   ^^^^^^ expected expression\n+\n+error: aborting due to 4 previous errors\n "}, {"sha": "222161a8183a28043d27491816000f1b88f17499", "filename": "src/test/ui/macros/cfg.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fcfg.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    cfg!(); //~ ERROR macro requires a cfg-pattern\n+    cfg!(123); //~ ERROR expected identifier\n+    cfg!(foo = 123); //~ ERROR literal in `cfg` predicate value must be a string\n+}"}, {"sha": "a7aca88f3e56e102733ee1553ff6565fc93607eb", "filename": "src/test/ui/macros/cfg.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fcfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fcfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fcfg.stderr?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -0,0 +1,21 @@\n+error: macro requires a cfg-pattern as an argument\n+  --> $DIR/cfg.rs:2:5\n+   |\n+LL |     cfg!(); //~ ERROR macro requires a cfg-pattern\n+   |     ^^^^^^^ cfg-pattern required\n+\n+error: expected identifier, found `123`\n+  --> $DIR/cfg.rs:3:10\n+   |\n+LL |     cfg!(123); //~ ERROR expected identifier\n+   |          ^^^ expected identifier\n+\n+error[E0565]: literal in `cfg` predicate value must be a string\n+  --> $DIR/cfg.rs:4:16\n+   |\n+LL |     cfg!(foo = 123); //~ ERROR literal in `cfg` predicate value must be a string\n+   |                ^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0565`."}, {"sha": "ba1e441fe339fd0eaf87f6a8f9887797a881efb2", "filename": "src/test/ui/macros/format-parse-errors.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -0,0 +1,10 @@\n+fn main() {\n+    format!(); //~ ERROR requires at least a format string argument\n+    format!(struct); //~ ERROR expected expression\n+    format!(\"s\", name =); //~ ERROR expected expression\n+    format!(\"s\", foo = struct); //~ ERROR expected expression\n+    format!(\"s\", struct); //~ ERROR expected expression\n+\n+    // This error should come after parsing errors to ensure they are non-fatal.\n+    format!(123); //~ ERROR format argument must be a string literal\n+}"}, {"sha": "0463c54890177f1a5e70300df81cce3ae536d3d9", "filename": "src/test/ui/macros/format-parse-errors.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fformat-parse-errors.stderr?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -0,0 +1,44 @@\n+error: requires at least a format string argument\n+  --> $DIR/format-parse-errors.rs:2:5\n+   |\n+LL |     format!(); //~ ERROR requires at least a format string argument\n+   |     ^^^^^^^^^^\n+   |\n+   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+\n+error: expected expression, found keyword `struct`\n+  --> $DIR/format-parse-errors.rs:3:13\n+   |\n+LL |     format!(struct); //~ ERROR expected expression\n+   |             ^^^^^^ expected expression\n+\n+error: expected expression, found `<eof>`\n+  --> $DIR/format-parse-errors.rs:4:23\n+   |\n+LL |     format!(\"s\", name =); //~ ERROR expected expression\n+   |                       ^ expected expression\n+\n+error: expected expression, found keyword `struct`\n+  --> $DIR/format-parse-errors.rs:5:24\n+   |\n+LL |     format!(\"s\", foo = struct); //~ ERROR expected expression\n+   |                        ^^^^^^ expected expression\n+\n+error: expected expression, found keyword `struct`\n+  --> $DIR/format-parse-errors.rs:6:18\n+   |\n+LL |     format!(\"s\", struct); //~ ERROR expected expression\n+   |                  ^^^^^^ expected expression\n+\n+error: format argument must be a string literal\n+  --> $DIR/format-parse-errors.rs:9:13\n+   |\n+LL |     format!(123); //~ ERROR format argument must be a string literal\n+   |             ^^^\n+help: you might be missing a string literal to format with\n+   |\n+LL |     format!(\"{}\", 123); //~ ERROR format argument must be a string literal\n+   |             ^^^^^\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "8402afa50857af3e9d12a5fe112bde6ca93892cd", "filename": "src/test/ui/macros/global-asm.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.rs?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -0,0 +1,7 @@\n+#![feature(global_asm)]\n+\n+fn main() {\n+    global_asm!();  //~ ERROR requires a string literal as an argument\n+    global_asm!(struct); //~ ERROR expected expression\n+    global_asm!(123); //~ ERROR inline assembly must be a string literal\n+}"}, {"sha": "94664c96db3913c2eb695c91490a7d73392471b4", "filename": "src/test/ui/macros/global-asm.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f381a962550436f74dd6e9021e4df2fdefb96cfa/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fglobal-asm.stderr?ref=f381a962550436f74dd6e9021e4df2fdefb96cfa", "patch": "@@ -0,0 +1,20 @@\n+error: macro requires a string literal as an argument\n+  --> $DIR/global-asm.rs:4:5\n+   |\n+LL |     global_asm!();  //~ ERROR requires a string literal as an argument\n+   |     ^^^^^^^^^^^^^^ string literal required\n+\n+error: expected expression, found keyword `struct`\n+  --> $DIR/global-asm.rs:5:17\n+   |\n+LL |     global_asm!(struct); //~ ERROR expected expression\n+   |                 ^^^^^^ expected expression\n+\n+error: inline assembly must be a string literal\n+  --> $DIR/global-asm.rs:6:17\n+   |\n+LL |     global_asm!(123); //~ ERROR inline assembly must be a string literal\n+   |                 ^^^\n+\n+error: aborting due to 3 previous errors\n+"}]}