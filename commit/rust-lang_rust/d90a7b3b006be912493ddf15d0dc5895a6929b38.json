{"sha": "d90a7b3b006be912493ddf15d0dc5895a6929b38", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5MGE3YjNiMDA2YmU5MTI0OTNkZGYxNWQwZGM1ODk1YTY5MjliMzg=", "commit": {"author": {"name": "f001", "email": "changchun.fan@qq.com", "date": "2017-02-05T09:39:52Z"}, "committer": {"name": "f001", "email": "changchun.fan@qq.com", "date": "2017-02-08T13:43:24Z"}, "message": "std: Add retain method for HashMap and HashSet\n\nFix #36648", "tree": {"sha": "0c15b2df0f09c7913ebb142e54e0261a5f0ed325", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0c15b2df0f09c7913ebb142e54e0261a5f0ed325"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d90a7b3b006be912493ddf15d0dc5895a6929b38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d90a7b3b006be912493ddf15d0dc5895a6929b38", "html_url": "https://github.com/rust-lang/rust/commit/d90a7b3b006be912493ddf15d0dc5895a6929b38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d90a7b3b006be912493ddf15d0dc5895a6929b38/comments", "author": {"login": "F001", "id": 3314340, "node_id": "MDQ6VXNlcjMzMTQzNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/3314340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/F001", "html_url": "https://github.com/F001", "followers_url": "https://api.github.com/users/F001/followers", "following_url": "https://api.github.com/users/F001/following{/other_user}", "gists_url": "https://api.github.com/users/F001/gists{/gist_id}", "starred_url": "https://api.github.com/users/F001/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/F001/subscriptions", "organizations_url": "https://api.github.com/users/F001/orgs", "repos_url": "https://api.github.com/users/F001/repos", "events_url": "https://api.github.com/users/F001/events{/privacy}", "received_events_url": "https://api.github.com/users/F001/received_events", "type": "User", "site_admin": false}, "committer": {"login": "F001", "id": 3314340, "node_id": "MDQ6VXNlcjMzMTQzNDA=", "avatar_url": "https://avatars.githubusercontent.com/u/3314340?v=4", "gravatar_id": "", "url": "https://api.github.com/users/F001", "html_url": "https://github.com/F001", "followers_url": "https://api.github.com/users/F001/followers", "following_url": "https://api.github.com/users/F001/following{/other_user}", "gists_url": "https://api.github.com/users/F001/gists{/gist_id}", "starred_url": "https://api.github.com/users/F001/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/F001/subscriptions", "organizations_url": "https://api.github.com/users/F001/orgs", "repos_url": "https://api.github.com/users/F001/repos", "events_url": "https://api.github.com/users/F001/events{/privacy}", "received_events_url": "https://api.github.com/users/F001/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ea7a6486a26af085862cd7a5596bb69e83d85e12", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea7a6486a26af085862cd7a5596bb69e83d85e12", "html_url": "https://github.com/rust-lang/rust/commit/ea7a6486a26af085862cd7a5596bb69e83d85e12"}], "stats": {"total": 228, "additions": 182, "deletions": 46}, "files": [{"sha": "f689589dfa25fadc24a3f168462e99043593525e", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 75, "deletions": 39, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/d90a7b3b006be912493ddf15d0dc5895a6929b38/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90a7b3b006be912493ddf15d0dc5895a6929b38/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=d90a7b3b006be912493ddf15d0dc5895a6929b38", "patch": "@@ -416,22 +416,26 @@ fn search_hashed<K, V, M, F>(table: M, hash: SafeHash, mut is_match: F) -> Inter\n     }\n }\n \n-fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>) -> (K, V) {\n+fn pop_internal<K, V>(starting_bucket: FullBucketMut<K, V>)\n+    -> (K, V, &mut RawTable<K, V>)\n+{\n     let (empty, retkey, retval) = starting_bucket.take();\n     let mut gap = match empty.gap_peek() {\n-        Some(b) => b,\n-        None => return (retkey, retval),\n+        Ok(b) => b,\n+        Err(b) => return (retkey, retval, b.into_table()),\n     };\n \n     while gap.full().displacement() != 0 {\n         gap = match gap.shift() {\n-            Some(b) => b,\n-            None => break,\n+            Ok(b) => b,\n+            Err(b) => {\n+                return (retkey, retval, b.into_table());\n+            },\n         };\n     }\n \n     // Now we've done all our shifting. Return the value we grabbed earlier.\n-    (retkey, retval)\n+    (retkey, retval, gap.into_bucket().into_table())\n }\n \n /// Perform robin hood bucket stealing at the given `bucket`. You must\n@@ -721,38 +725,7 @@ impl<K, V, S> HashMap<K, V, S>\n             return;\n         }\n \n-        // Grow the table.\n-        // Specialization of the other branch.\n-        let mut bucket = Bucket::first(&mut old_table);\n-\n-        // \"So a few of the first shall be last: for many be called,\n-        // but few chosen.\"\n-        //\n-        // We'll most likely encounter a few buckets at the beginning that\n-        // have their initial buckets near the end of the table. They were\n-        // placed at the beginning as the probe wrapped around the table\n-        // during insertion. We must skip forward to a bucket that won't\n-        // get reinserted too early and won't unfairly steal others spot.\n-        // This eliminates the need for robin hood.\n-        loop {\n-            bucket = match bucket.peek() {\n-                Full(full) => {\n-                    if full.displacement() == 0 {\n-                        // This bucket occupies its ideal spot.\n-                        // It indicates the start of another \"cluster\".\n-                        bucket = full.into_bucket();\n-                        break;\n-                    }\n-                    // Leaving this bucket in the last cluster for later.\n-                    full.into_bucket()\n-                }\n-                Empty(b) => {\n-                    // Encountered a hole between clusters.\n-                    b.into_bucket()\n-                }\n-            };\n-            bucket.next();\n-        }\n+        let mut bucket = Bucket::head_bucket(&mut old_table);\n \n         // This is how the buckets might be laid out in memory:\n         // ($ marks an initialized bucket)\n@@ -1208,6 +1181,57 @@ impl<K, V, S> HashMap<K, V, S>\n \n         self.search_mut(k).into_occupied_bucket().map(|bucket| pop_internal(bucket).1)\n     }\n+\n+    /// Retains only the elements specified by the predicate.\n+    ///\n+    /// In other words, remove all pairs `(k, v)` such that `f(&k,&mut v)` returns `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(retain_hash_collection)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<isize, isize> = (0..8).map(|x|(x, x*10)).collect();\n+    /// map.retain(|&k, _| k % 2 == 0);\n+    /// assert_eq!(map.len(), 4);\n+    /// ```\n+    #[unstable(feature = \"retain_hash_collection\", issue = \"36648\")]\n+    pub fn retain<F>(&mut self, mut f: F)\n+        where F: FnMut(&K, &mut V) -> bool\n+    {\n+        if self.table.capacity() == 0 || self.table.size() == 0 {\n+            return;\n+        }\n+        let mut bucket = Bucket::head_bucket(&mut self.table);\n+        bucket.prev();\n+        let tail = bucket.index();\n+        loop {\n+            bucket = match bucket.peek() {\n+                Full(mut full) => {\n+                    let should_remove = {\n+                        let (k, v) = full.read_mut();\n+                        !f(k, v)\n+                    };\n+                    if should_remove {\n+                        let prev_idx = full.index();\n+                        let prev_raw = full.raw();\n+                        let (_, _, t) = pop_internal(full);\n+                        Bucket::new_from(prev_raw, prev_idx, t)\n+                    } else {\n+                        full.into_bucket()\n+                    }\n+                },\n+                Empty(b) => {\n+                    b.into_bucket()\n+                }\n+            };\n+            bucket.prev();  // reverse iteration\n+            if bucket.index() == tail {\n+                break;\n+            }\n+        }\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1862,7 +1886,8 @@ impl<'a, K, V> OccupiedEntry<'a, K, V> {\n     /// ```\n     #[stable(feature = \"map_entry_recover_keys2\", since = \"1.12.0\")]\n     pub fn remove_entry(self) -> (K, V) {\n-        pop_internal(self.elem)\n+        let (k, v, _) = pop_internal(self.elem);\n+        (k, v)\n     }\n \n     /// Gets a reference to the value in the entry.\n@@ -3156,4 +3181,15 @@ mod test_map {\n         assert_eq!(a.len(), 1);\n         assert_eq!(a[key], value);\n     }\n+\n+    #[test]\n+    fn test_retain() {\n+        let mut map: HashMap<isize, isize> = (0..100).map(|x|(x, x*10)).collect();\n+\n+        map.retain(|&k, _| k % 2 == 0);\n+        assert_eq!(map.len(), 50);\n+        assert_eq!(map[&2], 20);\n+        assert_eq!(map[&4], 40);\n+        assert_eq!(map[&6], 60);\n+    }\n }"}, {"sha": "8de742db461104ab3499f4986b0f001318b370dc", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d90a7b3b006be912493ddf15d0dc5895a6929b38/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90a7b3b006be912493ddf15d0dc5895a6929b38/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=d90a7b3b006be912493ddf15d0dc5895a6929b38", "patch": "@@ -624,6 +624,28 @@ impl<T, S> HashSet<T, S>\n     {\n         Recover::take(&mut self.map, value)\n     }\n+\n+    /// Retains only the elements specified by the predicate.\n+    ///\n+    /// In other words, remove all elements `e` such that `f(&e)` returns `false`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(retain_hash_collection)]\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let xs = [1,2,3,4,5,6];\n+    /// let mut set: HashSet<isize> = xs.iter().cloned().collect();\n+    /// set.retain(|&k| k % 2 == 0);\n+    /// assert_eq!(set.len(), 3);\n+    /// ```\n+    #[unstable(feature = \"retain_hash_collection\", issue = \"36648\")]\n+    pub fn retain<F>(&mut self, mut f: F)\n+        where F: FnMut(&T) -> bool\n+    {\n+        self.map.retain(|k, _| f(k));\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1605,4 +1627,15 @@ mod test_set {\n         assert!(a.contains(&5));\n         assert!(a.contains(&6));\n     }\n+\n+    #[test]\n+    fn test_retain() {\n+        let xs = [1,2,3,4,5,6];\n+        let mut set: HashSet<isize> = xs.iter().cloned().collect();\n+        set.retain(|&k| k % 2 == 0);\n+        assert_eq!(set.len(), 3);\n+        assert!(set.contains(&2));\n+        assert!(set.contains(&4));\n+        assert!(set.contains(&6));\n+    }\n }"}, {"sha": "9e92b4750145e79b31ea9949214c7a51e407a840", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/d90a7b3b006be912493ddf15d0dc5895a6929b38/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d90a7b3b006be912493ddf15d0dc5895a6929b38/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=d90a7b3b006be912493ddf15d0dc5895a6929b38", "patch": "@@ -85,7 +85,7 @@ pub struct RawTable<K, V> {\n unsafe impl<K: Send, V: Send> Send for RawTable<K, V> {}\n unsafe impl<K: Sync, V: Sync> Sync for RawTable<K, V> {}\n \n-struct RawBucket<K, V> {\n+pub struct RawBucket<K, V> {\n     hash: *mut HashUint,\n     // We use *const to ensure covariance with respect to K and V\n     pair: *const (K, V),\n@@ -216,6 +216,10 @@ impl<K, V, M> FullBucket<K, V, M> {\n     pub fn index(&self) -> usize {\n         self.idx\n     }\n+    /// Get the raw bucket.\n+    pub fn raw(&self) -> RawBucket<K, V> {\n+        self.raw\n+    }\n }\n \n impl<K, V, M> EmptyBucket<K, V, M> {\n@@ -230,6 +234,10 @@ impl<K, V, M> Bucket<K, V, M> {\n     pub fn index(&self) -> usize {\n         self.idx\n     }\n+    /// get the table.\n+    pub fn into_table(self) -> M {\n+        self.table\n+    }\n }\n \n impl<K, V, M> Deref for FullBucket<K, V, M>\n@@ -275,6 +283,16 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n         Bucket::at_index(table, hash.inspect() as usize)\n     }\n \n+    pub fn new_from(r: RawBucket<K, V>, i: usize, t: M)\n+        -> Bucket<K, V, M>\n+    {\n+        Bucket {\n+            raw: r,\n+            idx: i,\n+            table: t,\n+        }\n+    }\n+\n     pub fn at_index(table: M, ib_index: usize) -> Bucket<K, V, M> {\n         // if capacity is 0, then the RawBucket will be populated with bogus pointers.\n         // This is an uncommon case though, so avoid it in release builds.\n@@ -296,6 +314,40 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n         }\n     }\n \n+    // \"So a few of the first shall be last: for many be called,\n+    // but few chosen.\"\n+    //\n+    // We'll most likely encounter a few buckets at the beginning that\n+    // have their initial buckets near the end of the table. They were\n+    // placed at the beginning as the probe wrapped around the table\n+    // during insertion. We must skip forward to a bucket that won't\n+    // get reinserted too early and won't unfairly steal others spot.\n+    // This eliminates the need for robin hood.\n+    pub fn head_bucket(table: M) -> Bucket<K, V, M> {\n+        let mut bucket = Bucket::first(table);\n+\n+        loop {\n+            bucket = match bucket.peek() {\n+                Full(full) => {\n+                    if full.displacement() == 0 {\n+                        // This bucket occupies its ideal spot.\n+                        // It indicates the start of another \"cluster\".\n+                        bucket = full.into_bucket();\n+                        break;\n+                    }\n+                    // Leaving this bucket in the last cluster for later.\n+                    full.into_bucket()\n+                }\n+                Empty(b) => {\n+                    // Encountered a hole between clusters.\n+                    b.into_bucket()\n+                }\n+            };\n+            bucket.next();\n+        }\n+        bucket\n+    }\n+\n     /// Reads a bucket at a given index, returning an enum indicating whether\n     /// it's initialized or not. You need to match on this enum to get\n     /// the appropriate types to call most of the other functions in\n@@ -333,6 +385,17 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> Bucket<K, V, M> {\n             self.raw = self.raw.offset(dist);\n         }\n     }\n+\n+    /// Modifies the bucket pointer in place to make it point to the previous slot.\n+    pub fn prev(&mut self) {\n+        let range = self.table.capacity();\n+        let new_idx = self.idx.wrapping_sub(1) & (range - 1);\n+        let dist = (new_idx as isize).wrapping_sub(self.idx as isize);\n+        self.idx = new_idx;\n+        unsafe {\n+            self.raw = self.raw.offset(dist);\n+        }\n+    }\n }\n \n impl<K, V, M: Deref<Target = RawTable<K, V>>> EmptyBucket<K, V, M> {\n@@ -352,7 +415,7 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> EmptyBucket<K, V, M> {\n         }\n     }\n \n-    pub fn gap_peek(self) -> Option<GapThenFull<K, V, M>> {\n+    pub fn gap_peek(self) -> Result<GapThenFull<K, V, M>, Bucket<K, V, M>> {\n         let gap = EmptyBucket {\n             raw: self.raw,\n             idx: self.idx,\n@@ -361,12 +424,12 @@ impl<K, V, M: Deref<Target = RawTable<K, V>>> EmptyBucket<K, V, M> {\n \n         match self.next().peek() {\n             Full(bucket) => {\n-                Some(GapThenFull {\n+                Ok(GapThenFull {\n                     gap: gap,\n                     full: bucket,\n                 })\n             }\n-            Empty(..) => None,\n+            Empty(e) => Err(e.into_bucket()),\n         }\n     }\n }\n@@ -529,7 +592,11 @@ impl<K, V, M> GapThenFull<K, V, M>\n         &self.full\n     }\n \n-    pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n+    pub fn into_bucket(self) -> Bucket<K, V, M> {\n+        self.full.into_bucket()\n+    }\n+\n+    pub fn shift(mut self) -> Result<GapThenFull<K, V, M>, Bucket<K, V, M>> {\n         unsafe {\n             *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n             ptr::copy_nonoverlapping(self.full.raw.pair, self.gap.raw.pair as *mut (K, V), 1);\n@@ -544,9 +611,9 @@ impl<K, V, M> GapThenFull<K, V, M>\n \n                 self.full = bucket;\n \n-                Some(self)\n+                Ok(self)\n             }\n-            Empty(..) => None,\n+            Empty(b) => Err(b.into_bucket()),\n         }\n     }\n }"}]}