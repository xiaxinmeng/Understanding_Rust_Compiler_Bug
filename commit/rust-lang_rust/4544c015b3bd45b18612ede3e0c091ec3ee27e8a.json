{"sha": "4544c015b3bd45b18612ede3e0c091ec3ee27e8a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NDRjMDE1YjNiZDQ1YjE4NjEyZWRlM2UwYzA5MWVjM2VlMjdlOGE=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-06T17:33:31Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-06T20:25:34Z"}, "message": "Fill out rust docs for pipes some more.", "tree": {"sha": "c0db37ca4f489028e0189acfdb61bdabdec91029", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0db37ca4f489028e0189acfdb61bdabdec91029"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4544c015b3bd45b18612ede3e0c091ec3ee27e8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4544c015b3bd45b18612ede3e0c091ec3ee27e8a", "html_url": "https://github.com/rust-lang/rust/commit/4544c015b3bd45b18612ede3e0c091ec3ee27e8a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4544c015b3bd45b18612ede3e0c091ec3ee27e8a/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bff512a90facf2b0064f13737d44c716863f644d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bff512a90facf2b0064f13737d44c716863f644d", "html_url": "https://github.com/rust-lang/rust/commit/bff512a90facf2b0064f13737d44c716863f644d"}], "stats": {"total": 64, "additions": 56, "deletions": 8}, "files": [{"sha": "ce72a6edca92bc0ca2b5a99c4c8b6a279506c1af", "filename": "src/libcore/pipes.rs", "status": "modified", "additions": 56, "deletions": 8, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/4544c015b3bd45b18612ede3e0c091ec3ee27e8a/src%2Flibcore%2Fpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4544c015b3bd45b18612ede3e0c091ec3ee27e8a/src%2Flibcore%2Fpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpipes.rs?ref=4544c015b3bd45b18612ede3e0c091ec3ee27e8a", "patch": "@@ -162,6 +162,7 @@ type packet<T: send> = {\n     mut payload: option<T>,\n };\n \n+#[doc(hidden)]\n trait has_buffer {\n     fn set_buffer(b: *libc::c_void);\n }\n@@ -172,13 +173,15 @@ impl methods<T: send> of has_buffer for packet<T> {\n     }\n }\n \n+#[doc(hidden)]\n fn mk_packet<T: send>() -> packet<T> {\n     {\n         header: packet_header(),\n         mut payload: none\n     }\n }\n \n+#[doc(hidden)]\n fn unibuffer<T: send>() -> ~buffer<packet<T>> {\n     let b = ~{\n         header: buffer_header(),\n@@ -216,6 +219,7 @@ fn entangle_buffer<T: send, Tstart: send>(\n }\n \n #[abi = \"rust-intrinsic\"]\n+#[doc(hidden)]\n extern mod rusti {\n     fn atomic_xchng(&dst: int, src: int) -> int;\n     fn atomic_xchng_acq(&dst: int, src: int) -> int;\n@@ -256,6 +260,7 @@ fn swap_task(&dst: *rust_task, src: *rust_task) -> *rust_task {\n #[doc(hidden)]\n type rust_task = libc::c_void;\n \n+#[doc(hidden)]\n extern mod rustrt {\n     #[rust_stack]\n     fn rust_get_task() -> *rust_task;\n@@ -614,14 +619,17 @@ fn select2<A: send, Ab: send, B: send, Bb: send>(\n     }\n }\n \n+#[doc(hidden)]\n trait selectable {\n     pure fn header() -> *packet_header;\n }\n \n+/// Returns the index of an endpoint that is ready to receive.\n fn selecti<T: selectable>(endpoints: &[T]) -> uint {\n     wait_many(endpoints.map(|p| p.header()))\n }\n \n+/// Returns 0 or 1 depending on which endpoint is ready to receive\n fn select2i<A: selectable, B: selectable>(a: A, b: B) -> either<(), ()> {\n     alt wait_many([a.header(), b.header()]/_) {\n       0 => left(()),\n@@ -630,8 +638,10 @@ fn select2i<A: selectable, B: selectable>(a: A, b: B) -> either<(), ()> {\n     }\n }\n \n-#[doc = \"Waits on a set of endpoints. Returns a message, its index,\n- and a list of the remaining endpoints.\"]\n+/** Waits on a set of endpoints. Returns a message, its index, and a\n+ list of the remaining endpoints.\n+\n+*/\n fn select<T: send, Tb: send>(+endpoints: ~[recv_packet_buffered<T, Tb>])\n     -> (uint, option<T>, ~[recv_packet_buffered<T, Tb>])\n {\n@@ -650,8 +660,10 @@ fn select<T: send, Tb: send>(+endpoints: ~[recv_packet_buffered<T, Tb>])\n     (ready, result, remaining)\n }\n \n-/// The sending end of a pipe. It can be used to send exactly one\n-/// message.\n+/** The sending end of a pipe. It can be used to send exactly one\n+message.\n+\n+*/\n type send_packet<T: send> = send_packet_buffered<T, packet<T>>;\n \n #[doc(hidden)]\n@@ -778,6 +790,13 @@ fn entangle<T: send>() -> (send_packet<T>, recv_packet<T>) {\n     (send_packet(p), recv_packet(p))\n }\n \n+/** Spawn a task to provide a service.\n+\n+It takes an initialization function that produces a send and receive\n+endpoint. The send endpoint is returned to the caller and the receive\n+endpoint is passed to the new task.\n+\n+*/\n fn spawn_service<T: send, Tb: send>(\n     init: extern fn() -> (send_packet_buffered<T, Tb>,\n                           recv_packet_buffered<T, Tb>),\n@@ -798,6 +817,10 @@ fn spawn_service<T: send, Tb: send>(\n     client\n }\n \n+/** Like `spawn_service_recv`, but for protocols that start in the\n+receive state.\n+\n+*/\n fn spawn_service_recv<T: send, Tb: send>(\n     init: extern fn() -> (recv_packet_buffered<T, Tb>,\n                           send_packet_buffered<T, Tb>),\n@@ -826,33 +849,54 @@ proto! streamp {\n     }\n }\n \n-// It'd be nice to call this send, but it'd conflict with the built in\n-// send kind.\n+/// A trait for things that can send multiple messages.\n trait channel<T: send> {\n+    // It'd be nice to call this send, but it'd conflict with the\n+    // built in send kind.\n+\n+    /// Sends a message.\n     fn send(+x: T);\n }\n \n+/// A trait for things that can receive multiple messages.\n trait recv<T: send> {\n+    /// Receives a message, or fails if the connection closes.\n     fn recv() -> T;\n+\n+    /** Receives a message if one is available, or returns `none` if\n+    the connection is closed.\n+\n+    */\n     fn try_recv() -> option<T>;\n-    // This should perhaps be a new trait\n+\n+    /** Returns true if a message is available or the connection is\n+    closed.\n+\n+    */\n     pure fn peek() -> bool;\n }\n \n #[doc(hidden)]\n type chan_<T:send> = { mut endp: option<streamp::client::open<T>> };\n \n+/// An endpoint that can send many messages.\n enum chan<T:send> {\n     chan_(chan_<T>)\n }\n \n #[doc(hidden)]\n type port_<T:send> = { mut endp: option<streamp::server::open<T>> };\n \n+/// An endpoint that can receive many messages.\n enum port<T:send> {\n     port_(port_<T>)\n }\n \n+/** Creates a `(chan, port)` pair.\n+\n+These allow sending or receiving an unlimited number of messages.\n+\n+*/\n fn stream<T:send>() -> (chan<T>, port<T>) {\n     let (c, s) = streamp::init();\n \n@@ -970,7 +1014,7 @@ impl<T: send> of selectable for port<T> {\n     }\n }\n \n-\n+/// A channel that can be shared between many senders.\n type shared_chan<T: send> = arc::exclusive<chan<T>>;\n \n impl chan<T: send> of channel<T> for shared_chan<T> {\n@@ -984,12 +1028,16 @@ impl chan<T: send> of channel<T> for shared_chan<T> {\n     }\n }\n \n+/// Converts a `chan` into a `shared_chan`.\n fn shared_chan<T:send>(+c: chan<T>) -> shared_chan<T> {\n     arc::exclusive(c)\n }\n \n+/// Receive a message from one of two endpoints.\n trait select2<T: send, U: send> {\n+    /// Receive a message or return `none` if a connection closes.\n     fn try_select() -> either<option<T>, option<U>>;\n+    /// Receive a message or fail if a connection closes.\n     fn select() -> either<T, U>;\n }\n "}]}