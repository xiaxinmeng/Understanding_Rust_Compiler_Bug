{"sha": "6c37e3b7f82b16229d7595b17cbefc5ed9339511", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjMzdlM2I3ZjgyYjE2MjI5ZDc1OTViMTdjYmVmYzVlZDkzMzk1MTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-23T21:34:00Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2013-08-28T01:47:59Z"}, "message": "librustc: Implement basic lazy implementation loading.\n\nThis is only for implementations defined in the same crate as the trait they\nimplement.", "tree": {"sha": "d7f31698b6d1b7dc261c0d1e851bdc802d39964b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7f31698b6d1b7dc261c0d1e851bdc802d39964b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c37e3b7f82b16229d7595b17cbefc5ed9339511", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c37e3b7f82b16229d7595b17cbefc5ed9339511", "html_url": "https://github.com/rust-lang/rust/commit/6c37e3b7f82b16229d7595b17cbefc5ed9339511", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c37e3b7f82b16229d7595b17cbefc5ed9339511/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff7b8d6d88b67e2839ebbbc487d650e1bd137785", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff7b8d6d88b67e2839ebbbc487d650e1bd137785", "html_url": "https://github.com/rust-lang/rust/commit/ff7b8d6d88b67e2839ebbbc487d650e1bd137785"}], "stats": {"total": 463, "additions": 384, "deletions": 79}, "files": [{"sha": "8af535865941f0a9da58577e2b2bcae6b71ee308", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -185,6 +185,9 @@ pub static tag_item_impl_vtables: uint = 0x82;\n pub static tag_impls: uint = 0x83;\n pub static tag_impls_impl: uint = 0x84;\n \n+pub static tag_items_data_item_inherent_impl: uint = 0x85;\n+pub static tag_items_data_item_extension_impl: uint = 0x86;\n+\n pub struct LinkMeta {\n     name: @str,\n     vers: @str,"}, {"sha": "3ad69ff4da03dd53d77ae160eddc2e25efd4a4c0", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -272,3 +272,28 @@ pub fn each_impl(cstore: @mut cstore::CStore,\n     decoder::each_impl(cdata, callback)\n }\n \n+pub fn each_implementation_for_type(cstore: @mut cstore::CStore,\n+                                    def_id: ast::def_id,\n+                                    callback: &fn(ast::def_id)) {\n+    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    decoder::each_implementation_for_type(cdata, def_id.node, callback)\n+}\n+\n+pub fn each_implementation_for_trait(cstore: @mut cstore::CStore,\n+                                     def_id: ast::def_id,\n+                                     callback: &fn(ast::def_id)) {\n+    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    decoder::each_implementation_for_trait(cdata, def_id.node, callback)\n+}\n+\n+/// If the given def ID describes a method belonging to a trait (either a\n+/// default method or an implementation of a trait method), returns the ID of\n+/// the trait that the method belongs to. Otherwise, returns `None`.\n+pub fn get_trait_of_method(cstore: @mut cstore::CStore,\n+                           def_id: ast::def_id,\n+                           tcx: ty::ctxt)\n+                           -> Option<ast::def_id> {\n+    let cdata = cstore::get_crate_data(cstore, def_id.crate);\n+    decoder::get_trait_of_method(cdata, def_id.node, tcx)\n+}\n+"}, {"sha": "4eea99293be1582caa7d94dbf04f134c2377dbaa", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -20,6 +20,7 @@ use metadata::decoder;\n use metadata::tydecode::{parse_ty_data, parse_def_id,\n                          parse_type_param_def_data,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n+use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty;\n use middle::typeck;\n use middle::astencode::vtable_decoder_helpers;\n@@ -958,8 +959,15 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n {\n     let method_doc = lookup_item(id, cdata.data);\n     let def_id = item_def_id(method_doc, cdata);\n+\n     let container_id = item_reqd_and_translated_parent_item(cdata.cnum,\n                                                             method_doc);\n+    let container_doc = lookup_item(container_id.node, cdata.data);\n+    let container = match item_family(container_doc) {\n+        Trait => TraitContainer(container_id),\n+        _ => ImplContainer(container_id),\n+    };\n+\n     let name = item_name(intr, method_doc);\n     let type_param_defs = item_ty_param_defs(method_doc, tcx, cdata,\n                                              tag_item_method_tps);\n@@ -980,7 +988,7 @@ pub fn get_method(intr: @ident_interner, cdata: cmd, id: ast::NodeId,\n         explicit_self,\n         vis,\n         def_id,\n-        container_id,\n+        container,\n         provided_source\n     )\n }\n@@ -1391,4 +1399,56 @@ pub fn each_impl(cdata: cmd, callback: &fn(ast::def_id)) {\n     };\n }\n \n+pub fn each_implementation_for_type(cdata: cmd,\n+                                    id: ast::NodeId,\n+                                    callback: &fn(ast::def_id)) {\n+    let item_doc = lookup_item(id, cdata.data);\n+    /*println(fmt!(\">>> reading inherent impls from %s\",\n+                 token::ident_to_str(&item_name(token::get_ident_interner(),\n+                                                item_doc))));*/\n+    do reader::tagged_docs(item_doc, tag_items_data_item_inherent_impl)\n+            |impl_doc| {\n+        let implementation_def_id = item_def_id(impl_doc, cdata);\n+        /*println(fmt!(\">>>>> read inherent impl: %d:%d\",\n+                     implementation_def_id.crate,\n+                     implementation_def_id.node));*/\n+        callback(implementation_def_id);\n+        true\n+    };\n+}\n+\n+pub fn each_implementation_for_trait(cdata: cmd,\n+                                     id: ast::NodeId,\n+                                     callback: &fn(ast::def_id)) {\n+    let item_doc = lookup_item(id, cdata.data);\n+\n+    let _ = do reader::tagged_docs(item_doc,\n+                                   tag_items_data_item_extension_impl)\n+            |impl_doc| {\n+        let implementation_def_id = item_def_id(impl_doc, cdata);\n+        callback(implementation_def_id);\n+        true\n+    };\n+}\n+\n+pub fn get_trait_of_method(cdata: cmd, id: ast::NodeId, tcx: ty::ctxt)\n+                           -> Option<ast::def_id> {\n+    let item_doc = lookup_item(id, cdata.data);\n+    let parent_item_id = match item_parent_item(item_doc) {\n+        None => return None,\n+        Some(item_id) => item_id,\n+    };\n+    let parent_item_id = translate_def_id(cdata, parent_item_id);\n+    let parent_item_doc = lookup_item(parent_item_id.node, cdata.data);\n+    match item_family(parent_item_doc) {\n+        Trait => Some(item_def_id(parent_item_doc, cdata)),\n+        Impl => {\n+            do reader::maybe_get_doc(parent_item_doc, tag_item_trait_ref).map\n+                    |_| {\n+                item_trait_ref(parent_item_doc, tcx, cdata).def_id\n+            }\n+        }\n+        _ => None\n+    }\n+}\n "}, {"sha": "1b7010925516e7e9a1e1c2f14e1239c1bb86ecb5", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 69, "deletions": 4, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -799,6 +799,38 @@ fn should_inline(attrs: &[Attribute]) -> bool {\n     }\n }\n \n+// Encodes the inherent implementations of a structure, enumeration, or trait.\n+fn encode_inherent_implementations(ecx: &EncodeContext,\n+                                   ebml_w: &mut writer::Encoder,\n+                                   def_id: def_id) {\n+    match ecx.tcx.inherent_impls.find(&def_id) {\n+        None => {}\n+        Some(&implementations) => {\n+            for implementation in implementations.iter() {\n+                ebml_w.start_tag(tag_items_data_item_inherent_impl);\n+                encode_def_id(ebml_w, implementation.did);\n+                ebml_w.end_tag();\n+            }\n+        }\n+    }\n+}\n+\n+// Encodes the implementations of a trait defined in this crate.\n+fn encode_extension_implementations(ecx: &EncodeContext,\n+                                    ebml_w: &mut writer::Encoder,\n+                                    trait_def_id: def_id) {\n+    match ecx.tcx.trait_impls.find(&trait_def_id) {\n+        None => {}\n+        Some(&implementations) => {\n+            for implementation in implementations.iter() {\n+                ebml_w.start_tag(tag_items_data_item_extension_impl);\n+                encode_def_id(ebml_w, implementation.did);\n+                ebml_w.end_tag();\n+            }\n+        }\n+    }\n+}\n+\n fn encode_info_for_item(ecx: &EncodeContext,\n                         ebml_w: &mut writer::Encoder,\n                         item: @item,\n@@ -902,6 +934,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         (ecx.encode_inlined_item)(ecx, ebml_w, path, ii_item(item));\n         encode_path(ecx, ebml_w, path, ast_map::path_name(item.ident));\n         encode_region_param(ecx, ebml_w, item);\n+\n+        // Encode inherent implementations for this enumeration.\n+        encode_inherent_implementations(ecx, ebml_w, def_id);\n+\n         ebml_w.end_tag();\n \n         encode_enum_variant_info(ecx,\n@@ -954,6 +990,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n         }\n \n+        // Encode inherent implementations for this structure.\n+        encode_inherent_implementations(ecx, ebml_w, def_id);\n+\n         /* Each class has its own index -- encode it */\n         let bkts = create_index(idx);\n         encode_index(ebml_w, bkts, write_i64);\n@@ -1069,6 +1108,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             let trait_ref = ty::node_id_to_trait_ref(ecx.tcx, ast_trait_ref.ref_id);\n             encode_trait_ref(ebml_w, ecx, trait_ref, tag_item_super_trait_ref);\n         }\n+\n+        // Encode the implementations of this trait.\n+        encode_extension_implementations(ecx, ebml_w, def_id);\n+\n         ebml_w.end_tag();\n \n         // Now output the method info for each method.\n@@ -1130,6 +1173,9 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             ebml_w.end_tag();\n         }\n+\n+        // Encode inherent implementations for this trait.\n+        encode_inherent_implementations(ecx, ebml_w, def_id);\n       }\n       item_mac(*) => fail!(\"item macros unimplemented\")\n     }\n@@ -1523,17 +1569,36 @@ struct ImplVisitor<'self> {\n impl<'self> Visitor<()> for ImplVisitor<'self> {\n     fn visit_item(&mut self, item: @item, _: ()) {\n         match item.node {\n-            item_impl(*) => {\n-                self.ebml_w.start_tag(tag_impls_impl);\n-                encode_def_id(self.ebml_w, local_def(item.id));\n-                self.ebml_w.end_tag();\n+            item_impl(_, Some(ref trait_ref), _, _) => {\n+                let def_map = self.ecx.tcx.def_map;\n+                let trait_def = def_map.get_copy(&trait_ref.ref_id);\n+                let def_id = ast_util::def_id_of_def(trait_def);\n+\n+                // Load eagerly if this is an implementation of the Drop trait\n+                // or if the trait is not defined in this crate.\n+                if def_id == self.ecx.tcx.lang_items.drop_trait().unwrap() ||\n+                        def_id.crate != LOCAL_CRATE {\n+                    self.ebml_w.start_tag(tag_impls_impl);\n+                    encode_def_id(self.ebml_w, local_def(item.id));\n+                    self.ebml_w.end_tag();\n+                }\n             }\n             _ => {}\n         }\n         visit::walk_item(self, item, ());\n     }\n }\n \n+/// Encodes implementations that are eagerly loaded.\n+///\n+/// None of this is necessary in theory; we can load all implementations\n+/// lazily. However, in two cases the optimizations to lazily load\n+/// implementations are not yet implemented. These two cases, which require us\n+/// to load implementations eagerly, are:\n+///\n+/// * Destructors (implementations of the Drop trait).\n+///\n+/// * Implementations of traits not defined in this crate.\n fn encode_impls(ecx: &EncodeContext,\n                 crate: &Crate,\n                 ebml_w: &mut writer::Encoder) {"}, {"sha": "ccb62252e5d88ee0f26b283bffe62d2eed5ff588", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -225,7 +225,7 @@ impl PrivacyVisitor {\n \n         if method_id.crate == LOCAL_CRATE {\n             let is_private = self.method_is_private(span, method_id.node);\n-            let container_id = ty::method(self.tcx, method_id).container_id;\n+            let container_id = ty::method(self.tcx, method_id).container_id();\n             if is_private &&\n                     (container_id.crate != LOCAL_CRATE ||\n                      !self.privileged_items.iter().any(|x| x == &(container_id.node))) {"}, {"sha": "9502e02c27945c687d59d48b1366e58aeff9a386", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -283,6 +283,14 @@ pub fn trans_fn_ref_with_vtables(\n                               self_ty: None,\n                               tps: /*bad*/ type_params.to_owned() };\n \n+    // Load the info for the appropriate trait if necessary.\n+    match ty::trait_of_method(tcx, def_id) {\n+        None => {}\n+        Some(trait_id) => {\n+            ty::populate_implementations_for_trait_if_necessary(tcx, trait_id)\n+        }\n+    }\n+\n     // We need to do a bunch of special handling for default methods.\n     // We need to modify the def_id and our substs in order to monomorphize\n     // the function.\n@@ -303,7 +311,7 @@ pub fn trans_fn_ref_with_vtables(\n             // So, what we need to do is find this substitution and\n             // compose it with the one we already have.\n \n-            let impl_id = ty::method(tcx, def_id).container_id;\n+            let impl_id = ty::method(tcx, def_id).container_id();\n             let method = ty::method(tcx, source_id);\n             let trait_ref = ty::impl_trait_ref(tcx, impl_id)\n                 .expect(\"could not find trait_ref for impl with \\"}, {"sha": "717dfbb67845396e7561dea48bd44fa6b07125b9", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -176,6 +176,10 @@ pub fn trans_method_callee(bcx: @mut Block,\n         }) => {\n             match bcx.fcx.param_substs {\n                 Some(substs) => {\n+                    ty::populate_implementations_for_trait_if_necessary(\n+                        bcx.tcx(),\n+                        trait_id);\n+\n                     let vtbl = find_vtable(bcx.tcx(), substs,\n                                            p, b);\n                     trans_monomorphized_callee(bcx, callee_id, this, mentry,\n@@ -210,6 +214,8 @@ pub fn trans_static_method_callee(bcx: @mut Block,\n            callee_id);\n     let _indenter = indenter();\n \n+    ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trait_id);\n+\n     // When we translate a static fn defined in a trait like:\n     //\n     //   trait<T1...Tn> Trait {\n@@ -575,6 +581,8 @@ fn emit_vtable_methods(bcx: @mut Block,\n                                     make a vtable for a type impl!\")\n     };\n \n+    ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);\n+\n     let trait_method_def_ids = ty::trait_method_def_ids(tcx, trt_id);\n     do trait_method_def_ids.map |method_def_id| {\n         let ident = ty::method(tcx, *method_def_id).ident;"}, {"sha": "6f90953cd413ab2c3274cc257759178e48e32cec", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 160, "deletions": 6, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -60,6 +60,12 @@ pub struct field {\n     mt: mt\n }\n \n+#[deriving(Clone)]\n+pub enum MethodContainer {\n+    TraitContainer(ast::def_id),\n+    ImplContainer(ast::def_id),\n+}\n+\n #[deriving(Clone)]\n pub struct Method {\n     ident: ast::ident,\n@@ -69,7 +75,7 @@ pub struct Method {\n     explicit_self: ast::explicit_self_,\n     vis: ast::visibility,\n     def_id: ast::def_id,\n-    container_id: ast::def_id,\n+    container: MethodContainer,\n \n     // If this method is provided, we need to know where it came from\n     provided_source: Option<ast::def_id>\n@@ -83,7 +89,7 @@ impl Method {\n                explicit_self: ast::explicit_self_,\n                vis: ast::visibility,\n                def_id: ast::def_id,\n-               container_id: ast::def_id,\n+               container: MethodContainer,\n                provided_source: Option<ast::def_id>)\n                -> Method {\n         // Check the invariants.\n@@ -101,10 +107,17 @@ impl Method {\n             explicit_self: explicit_self,\n             vis: vis,\n             def_id: def_id,\n-            container_id: container_id,\n+            container: container,\n             provided_source: provided_source\n         }\n     }\n+\n+    pub fn container_id(&self) -> ast::def_id {\n+        match self.container {\n+            TraitContainer(id) => id,\n+            ImplContainer(id) => id,\n+        }\n+    }\n }\n \n pub struct Impl {\n@@ -324,7 +337,15 @@ struct ctxt_ {\n     used_mut_nodes: @mut HashSet<ast::NodeId>,\n \n     // vtable resolution information for impl declarations\n-    impl_vtables: typeck::impl_vtable_map\n+    impl_vtables: typeck::impl_vtable_map,\n+\n+    // The set of external nominal types whose implementations have been read.\n+    // This is used for lazy resolution of methods.\n+    populated_external_types: @mut HashSet<ast::def_id>,\n+\n+    // The set of external traits whose implementations have been read. This\n+    // is used for lazy resolution of traits.\n+    populated_external_traits: @mut HashSet<ast::def_id>,\n }\n \n pub enum tbox_flag {\n@@ -938,6 +959,8 @@ pub fn mk_ctxt(s: session::Session,\n         used_unsafe: @mut HashSet::new(),\n         used_mut_nodes: @mut HashSet::new(),\n         impl_vtables: @mut HashMap::new(),\n+        populated_external_types: @mut HashSet::new(),\n+        populated_external_traits: @mut HashSet::new(),\n      }\n }\n \n@@ -3612,8 +3635,7 @@ pub fn def_has_ty_params(def: ast::def) -> bool {\n     }\n }\n \n-pub fn provided_source(cx: ctxt, id: ast::def_id)\n-    -> Option<ast::def_id> {\n+pub fn provided_source(cx: ctxt, id: ast::def_id) -> Option<ast::def_id> {\n     cx.provided_method_sources.find(&id).map_move(|x| *x)\n }\n \n@@ -4553,3 +4575,135 @@ pub fn visitor_object_ty(tcx: ctxt,\n                  ast::m_imm,\n                  EmptyBuiltinBounds())))\n }\n+\n+/// Records a trait-to-implementation mapping.\n+fn record_trait_implementation(tcx: ctxt,\n+                               trait_def_id: def_id,\n+                               implementation: @Impl) {\n+    let implementation_list;\n+    match tcx.trait_impls.find(&trait_def_id) {\n+        None => {\n+            implementation_list = @mut ~[];\n+            tcx.trait_impls.insert(trait_def_id, implementation_list);\n+        }\n+        Some(&existing_implementation_list) => {\n+            implementation_list = existing_implementation_list\n+        }\n+    }\n+\n+    implementation_list.push(implementation);\n+}\n+\n+/// Populates the type context with all the implementations for the given type\n+/// if necessary.\n+pub fn populate_implementations_for_type_if_necessary(tcx: ctxt,\n+                                                      type_id: ast::def_id) {\n+    if type_id.crate == LOCAL_CRATE {\n+        return\n+    }\n+    if tcx.populated_external_types.contains(&type_id) {\n+        return\n+    }\n+\n+    do csearch::each_implementation_for_type(tcx.sess.cstore, type_id)\n+            |implementation_def_id| {\n+        let implementation = @csearch::get_impl(tcx, implementation_def_id);\n+\n+        // Record the trait->implementation mappings, if applicable.\n+        let associated_traits = csearch::get_impl_trait(tcx,\n+                                                        implementation.did);\n+        for trait_ref in associated_traits.iter() {\n+            record_trait_implementation(tcx,\n+                                        trait_ref.def_id,\n+                                        implementation);\n+        }\n+\n+        // For any methods that use a default implementation, add them to\n+        // the map. This is a bit unfortunate.\n+        for method in implementation.methods.iter() {\n+            for source in method.provided_source.iter() {\n+                tcx.provided_method_sources.insert(method.def_id, *source);\n+            }\n+        }\n+\n+        // If this is an inherent implementation, record it.\n+        if associated_traits.is_none() {\n+            let implementation_list;\n+            match tcx.inherent_impls.find(&type_id) {\n+                None => {\n+                    implementation_list = @mut ~[];\n+                    tcx.inherent_impls.insert(type_id, implementation_list);\n+                }\n+                Some(&existing_implementation_list) => {\n+                    implementation_list = existing_implementation_list;\n+                }\n+            }\n+            implementation_list.push(implementation);\n+        }\n+\n+        // Store the implementation info.\n+        tcx.impls.insert(implementation_def_id, implementation);\n+    }\n+\n+    tcx.populated_external_types.insert(type_id);\n+}\n+\n+/// Populates the type context with all the implementations for the given\n+/// trait if necessary.\n+pub fn populate_implementations_for_trait_if_necessary(\n+        tcx: ctxt,\n+        trait_id: ast::def_id) {\n+    if trait_id.crate == LOCAL_CRATE {\n+        return\n+    }\n+    if tcx.populated_external_traits.contains(&trait_id) {\n+        return\n+    }\n+\n+    do csearch::each_implementation_for_trait(tcx.sess.cstore, trait_id)\n+            |implementation_def_id| {\n+        let implementation = @csearch::get_impl(tcx, implementation_def_id);\n+\n+        // Record the trait->implementation mapping.\n+        record_trait_implementation(tcx, trait_id, implementation);\n+\n+        // For any methods that use a default implementation, add them to\n+        // the map. This is a bit unfortunate.\n+        for method in implementation.methods.iter() {\n+            for source in method.provided_source.iter() {\n+                tcx.provided_method_sources.insert(method.def_id, *source);\n+            }\n+        }\n+\n+        // Store the implementation info.\n+        tcx.impls.insert(implementation_def_id, implementation);\n+    }\n+\n+    tcx.populated_external_traits.insert(trait_id);\n+}\n+\n+/// If the given def ID describes a trait method, returns the ID of the trait\n+/// that the method belongs to. Otherwise, returns `None`.\n+pub fn trait_of_method(tcx: ctxt, def_id: ast::def_id)\n+                       -> Option<ast::def_id> {\n+    match tcx.methods.find(&def_id) {\n+        Some(method_descriptor) => {\n+            match method_descriptor.container {\n+                TraitContainer(id) => return Some(id),\n+                _ => {}\n+            }\n+        }\n+        None => {}\n+    }\n+\n+    // If the method was in the local crate, then if we got here we know the\n+    // answer is negative.\n+    if def_id.crate == LOCAL_CRATE {\n+        return None\n+    }\n+\n+    let result = csearch::get_trait_of_method(tcx.cstore, def_id, tcx);\n+\n+    result\n+}\n+"}, {"sha": "c20ccafe82c4e6c3bc05f98dbe372232b5a2af0b", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -350,6 +350,10 @@ impl<'self> LookupContext<'self> {\n         let opt_applicable_traits = trait_map.find(&self.expr.id);\n         for applicable_traits in opt_applicable_traits.iter() {\n             for trait_did in applicable_traits.iter() {\n+                ty::populate_implementations_for_trait_if_necessary(\n+                    self.tcx(),\n+                    *trait_did);\n+\n                 // Look for explicit implementations.\n                 let opt_impl_infos = self.tcx().trait_impls.find(trait_did);\n                 for impl_infos in opt_impl_infos.iter() {\n@@ -534,6 +538,10 @@ impl<'self> LookupContext<'self> {\n \n \n     fn push_inherent_impl_candidates_for_type(&self, did: def_id) {\n+        // Read the inherent implementation candidates for this type from the\n+        // metadata if necessary.\n+        ty::populate_implementations_for_type_if_necessary(self.tcx(), did);\n+\n         let opt_impl_infos = self.tcx().inherent_impls.find(&did);\n         for impl_infos in opt_impl_infos.iter() {\n             for impl_info in impl_infos.iter() {"}, {"sha": "670553f569a1105f3e5926db77d618e17da35a00", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -136,6 +136,9 @@ fn lookup_vtables_for_param(vcx: &VtableContext,\n         // ...and here trait_ref is each bound that was declared on A,\n         // expressed in terms of the type parameters.\n \n+        ty::populate_implementations_for_trait_if_necessary(tcx,\n+                                                            trait_ref.def_id);\n+\n         // Substitute the values of the type parameters that may\n         // appear in the bound.\n         let trait_ref = substs.map_default(trait_ref, |substs| {\n@@ -321,6 +324,10 @@ fn search_for_vtable(vcx: &VtableContext,\n     let mut found = ~[];\n     let mut impls_seen = HashSet::new();\n \n+    // Load the implementations from external metadata if necessary.\n+    ty::populate_implementations_for_trait_if_necessary(tcx,\n+                                                        trait_ref.def_id);\n+\n     // XXX: this is a bad way to do this, since we do\n     // pointless allocations.\n     let impls = tcx.trait_impls.find(&trait_ref.def_id)"}, {"sha": "2aa4e28f1a4de4fcfde84e772334793b2436708c", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 8, "deletions": 52, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -19,7 +19,7 @@ use metadata::csearch::{each_impl, get_impl_trait};\n use metadata::csearch;\n use metadata::cstore::iter_crate_data;\n use middle::ty::get;\n-use middle::ty::{lookup_item_type, subst};\n+use middle::ty::{ImplContainer, lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_estr, ty_evec, ty_float, ty_infer, ty_int, ty_nil};\n use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n@@ -42,13 +42,12 @@ use syntax::ast;\n use syntax::ast_map::node_item;\n use syntax::ast_map;\n use syntax::ast_util::{def_id_of_def, local_def};\n-use syntax::codemap::{span, dummy_sp};\n+use syntax::codemap::span;\n use syntax::opt_vec;\n use syntax::visit;\n use syntax::parse;\n-use util::ppaux::ty_to_str;\n \n-use std::hashmap::{HashMap, HashSet};\n+use std::hashmap::HashSet;\n use std::result::Ok;\n use std::vec;\n \n@@ -149,19 +148,12 @@ pub fn CoherenceChecker(crate_context: @mut CrateCtxt) -> CoherenceChecker {\n     CoherenceChecker {\n         crate_context: crate_context,\n         inference_context: new_infer_ctxt(crate_context.tcx),\n-\n-        base_type_def_ids: @mut HashMap::new(),\n     }\n }\n \n pub struct CoherenceChecker {\n     crate_context: @mut CrateCtxt,\n     inference_context: @mut InferCtxt,\n-\n-    // A mapping from implementations to the corresponding base type\n-    // definition ID.\n-\n-    base_type_def_ids: @mut HashMap<def_id,def_id>,\n }\n \n struct CoherenceCheckVisitor { cc: CoherenceChecker }\n@@ -320,9 +312,6 @@ impl CoherenceChecker {\n                 if associated_traits.len() == 0 {\n                     self.add_inherent_impl(base_type_def_id, implementation);\n                 }\n-\n-                self.base_type_def_ids.insert(local_def(item.id),\n-                                              base_type_def_id);\n             }\n         }\n \n@@ -686,25 +675,11 @@ impl CoherenceChecker {\n         }\n         // Good. Continue.\n \n-        let self_type = lookup_item_type(tcx, implementation.did);\n-        let associated_traits = get_impl_trait(tcx,\n-                                               implementation.did);\n+        let _ = lookup_item_type(tcx, implementation.did);\n+        let associated_traits = get_impl_trait(tcx, implementation.did);\n \n-        // Do a sanity check to make sure that inherent methods have base\n-        // types.\n-        if associated_traits.is_none() {\n-            match get_base_type_def_id(self.inference_context,\n-                                       dummy_sp(),\n-                                       self_type.ty) {\n-                None => {\n-                    tcx.sess.bug(fmt!(\"no base type for external impl with no \\\n-                                      trait: %s (type %s)!\",\n-                                     tcx.sess.str_of(implementation.ident),\n-                                     ty_to_str(tcx, self_type.ty)));\n-                }\n-                Some(_) => {} // Nothing to do.\n-            }\n-        }\n+        // Do a sanity check.\n+        assert!(associated_traits.is_some());\n \n         // Record all the trait methods.\n         for trait_ref in associated_traits.iter() {\n@@ -719,25 +694,6 @@ impl CoherenceChecker {\n             }\n         }\n \n-        // Add the implementation to the mapping from implementation to base\n-        // type def ID, if there is a base type for this implementation.\n-        match get_base_type_def_id(self.inference_context,\n-                                   dummy_sp(),\n-                                   self_type.ty) {\n-            None => {} // Nothing to do.\n-            Some(base_type_def_id) => {\n-                // inherent methods apply to `impl Type` but not\n-                // `impl Trait for Type`:\n-                if associated_traits.is_none() {\n-                    self.add_inherent_impl(base_type_def_id,\n-                                           implementation);\n-                }\n-\n-                self.base_type_def_ids.insert(implementation.did,\n-                                              base_type_def_id);\n-            }\n-        }\n-\n         tcx.impls.insert(implementation.did, implementation);\n     }\n \n@@ -883,7 +839,7 @@ fn subst_receiver_types_in_method_ty(tcx: ty::ctxt,\n         method.explicit_self,\n         method.vis,\n         new_def_id,\n-        impl_id,\n+        ImplContainer(impl_id),\n         provided_source\n     )\n }"}, {"sha": "63317d4ca5c91bb04915e3cd9e734475684ea767", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c37e3b7f82b16229d7595b17cbefc5ed9339511/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=6c37e3b7f82b16229d7595b17cbefc5ed9339511", "patch": "@@ -32,7 +32,8 @@ are represented as `ty_param()` instances.\n \n \n use metadata::csearch;\n-use middle::ty::{substs, ty_param_bounds_and_ty};\n+use middle::ty::{ImplContainer, MethodContainer, TraitContainer, substs};\n+use middle::ty::{ty_param_bounds_and_ty};\n use middle::ty;\n use middle::subst::Subst;\n use middle::typeck::astconv::{AstConv, ty_of_arg};\n@@ -388,7 +389,7 @@ pub fn ensure_trait_methods(ccx: &CrateCtxt,\n             // assume public, because this is only invoked on trait methods\n             ast::public,\n             local_def(*m_id),\n-            local_def(trait_id),\n+            TraitContainer(local_def(trait_id)),\n             None\n         )\n     }\n@@ -744,7 +745,7 @@ pub struct ConvertedMethod {\n }\n \n pub fn convert_methods(ccx: &CrateCtxt,\n-                       container_id: ast::NodeId,\n+                       container: MethodContainer,\n                        ms: &[@ast::method],\n                        untransformed_rcvr_ty: ty::t,\n                        rcvr_ty_generics: &ty::Generics,\n@@ -758,11 +759,14 @@ pub fn convert_methods(ccx: &CrateCtxt,\n         let m_ty_generics =\n             ty_generics(ccx, rcvr_ty_generics.region_param, &m.generics,\n                         num_rcvr_ty_params);\n-        let mty =\n-            @ty_of_method(ccx, container_id, *m, rcvr_ty_generics.region_param,\n-                          untransformed_rcvr_ty,\n-                          rcvr_ast_generics, rcvr_visibility,\n-                          &m.generics);\n+        let mty = @ty_of_method(ccx,\n+                                container,\n+                                *m,\n+                                rcvr_ty_generics.region_param,\n+                                untransformed_rcvr_ty,\n+                                rcvr_ast_generics,\n+                                rcvr_visibility,\n+                                &m.generics);\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n         tcx.tcache.insert(\n             local_def(m.id),\n@@ -785,7 +789,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n     }).collect();\n \n     fn ty_of_method(ccx: &CrateCtxt,\n-                    container_id: ast::NodeId,\n+                    container: MethodContainer,\n                     m: &ast::method,\n                     rp: Option<ty::region_variance>,\n                     untransformed_rcvr_ty: ty::t,\n@@ -817,7 +821,7 @@ pub fn convert_methods(ccx: &CrateCtxt,\n             m.explicit_self.node,\n             method_vis,\n             local_def(m.id),\n-            local_def(container_id),\n+            container,\n             None\n         )\n     }\n@@ -877,8 +881,12 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n             it.vis\n         };\n \n-        let cms = convert_methods(ccx, it.id, *ms, selfty,\n-                                  &i_ty_generics, generics,\n+        let cms = convert_methods(ccx,\n+                                  ImplContainer(local_def(it.id)),\n+                                  *ms,\n+                                  selfty,\n+                                  &i_ty_generics,\n+                                  generics,\n                                   parent_visibility);\n         for t in opt_trait_ref.iter() {\n             // Prevent the builtin kind traits from being manually implemented.\n@@ -901,9 +909,12 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::item) {\n           let untransformed_rcvr_ty = ty::mk_self(tcx, local_def(it.id));\n           let (ty_generics, _) = mk_item_substs(ccx, generics, rp,\n                                                 Some(untransformed_rcvr_ty));\n-          let _ = convert_methods(ccx, it.id, provided_methods,\n+          let _ = convert_methods(ccx,\n+                                  TraitContainer(local_def(it.id)),\n+                                  provided_methods,\n                                   untransformed_rcvr_ty,\n-                                  &ty_generics, generics,\n+                                  &ty_generics,\n+                                  generics,\n                                   it.vis);\n \n           // We need to do this *after* converting methods, since"}]}