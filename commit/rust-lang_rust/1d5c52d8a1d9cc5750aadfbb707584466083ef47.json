{"sha": "1d5c52d8a1d9cc5750aadfbb707584466083ef47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNWM1MmQ4YTFkOWNjNTc1MGFhZGZiYjcwNzU4NDQ2NjA4M2VmNDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-12T16:11:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-12T16:11:46Z"}, "message": "auto merge of #12204 : alexcrichton/rust/seek, r=pcwalton\n\nThis adopts the rules posted in #10432:\r\n\r\n1. If a seek position is negative, then an error is generated\r\n2. Seeks beyond the end-of-file are allowed. Future writes will fill the gap\r\n   with data and future reads will return errors.\r\n3. Seeks within the bounds of a file are fine.\r\n\r\nCloses #10432", "tree": {"sha": "654b8b58f223975b36650cb8e873462f607ac869", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/654b8b58f223975b36650cb8e873462f607ac869"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d5c52d8a1d9cc5750aadfbb707584466083ef47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d5c52d8a1d9cc5750aadfbb707584466083ef47", "html_url": "https://github.com/rust-lang/rust/commit/1d5c52d8a1d9cc5750aadfbb707584466083ef47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d5c52d8a1d9cc5750aadfbb707584466083ef47/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d394a48e731453528b3e77a171cce43084d1f73f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d394a48e731453528b3e77a171cce43084d1f73f", "html_url": "https://github.com/rust-lang/rust/commit/d394a48e731453528b3e77a171cce43084d1f73f"}, {"sha": "1b6a1e98a887d0c698db09d521bc68bc3a47207d", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b6a1e98a887d0c698db09d521bc68bc3a47207d", "html_url": "https://github.com/rust-lang/rust/commit/1b6a1e98a887d0c698db09d521bc68bc3a47207d"}], "stats": {"total": 111, "additions": 80, "deletions": 31}, "files": [{"sha": "ff61ef15fa519e2a768f55a18a6387c470720993", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 73, "deletions": 26, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/1d5c52d8a1d9cc5750aadfbb707584466083ef47/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5c52d8a1d9cc5750aadfbb707584466083ef47/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=1d5c52d8a1d9cc5750aadfbb707584466083ef47", "patch": "@@ -10,7 +10,6 @@\n \n //! Readers and Writers for in-memory buffers\n \n-use cmp::max;\n use cmp::min;\n use container::Container;\n use option::None;\n@@ -20,6 +19,25 @@ use io::{Reader, Writer, Seek, Buffer, IoError, SeekStyle, IoResult};\n use vec;\n use vec::{Vector, ImmutableVector, MutableVector, OwnedCloneableVector};\n \n+fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64> {\n+    // compute offset as signed and clamp to prevent overflow\n+    let pos = match seek {\n+        SeekSet => 0,\n+        SeekEnd => end,\n+        SeekCur => cur,\n+    } as i64;\n+\n+    if offset + pos < 0 {\n+        Err(IoError {\n+            kind: io::InvalidInput,\n+            desc: \"invalid seek to a negative offset\",\n+            detail: None\n+        })\n+    } else {\n+        Ok((offset + pos) as u64)\n+    }\n+}\n+\n /// Writes to an owned, growable byte vector\n ///\n /// # Example\n@@ -92,19 +110,11 @@ impl Writer for MemWriter {\n     }\n }\n \n-// FIXME(#10432)\n impl Seek for MemWriter {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        // compute offset as signed and clamp to prevent overflow\n-        let offset = match style {\n-            SeekSet => { 0 }\n-            SeekEnd => { self.buf.len() }\n-            SeekCur => { self.pos }\n-        } as i64;\n-\n-        self.pos = max(0, offset+pos) as uint;\n+        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        self.pos = new as uint;\n         Ok(())\n     }\n }\n@@ -139,7 +149,7 @@ impl MemReader {\n     /// Tests whether this reader has read all bytes in its buffer.\n     ///\n     /// If `true`, then this will no longer return bytes from `read`.\n-    pub fn eof(&self) -> bool { self.pos == self.buf.len() }\n+    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n \n     /// Acquires an immutable reference to the underlying buffer of this\n     /// `MemReader`.\n@@ -172,7 +182,11 @@ impl Reader for MemReader {\n \n impl Seek for MemReader {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) -> IoResult<()> { fail!() }\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n+        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        self.pos = new as uint;\n+        Ok(())\n+    }\n }\n \n impl Buffer for MemReader {\n@@ -236,24 +250,15 @@ impl<'a> Writer for BufWriter<'a> {\n     }\n }\n \n-// FIXME(#10432)\n impl<'a> Seek for BufWriter<'a> {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n-        // compute offset as signed and clamp to prevent overflow\n-        let offset = match style {\n-            SeekSet => { 0 }\n-            SeekEnd => { self.buf.len() }\n-            SeekCur => { self.pos }\n-        } as i64;\n-\n-        self.pos = max(0, offset+pos) as uint;\n+        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        self.pos = new as uint;\n         Ok(())\n     }\n }\n \n-\n /// Reads from a fixed-size byte slice\n ///\n /// # Example\n@@ -284,7 +289,7 @@ impl<'a> BufReader<'a> {\n     /// Tests whether this reader has read all bytes in its buffer.\n     ///\n     /// If `true`, then this will no longer return bytes from `read`.\n-    pub fn eof(&self) -> bool { self.pos == self.buf.len() }\n+    pub fn eof(&self) -> bool { self.pos >= self.buf.len() }\n }\n \n impl<'a> Reader for BufReader<'a> {\n@@ -307,7 +312,11 @@ impl<'a> Reader for BufReader<'a> {\n \n impl<'a> Seek for BufReader<'a> {\n     fn tell(&self) -> IoResult<u64> { Ok(self.pos as u64) }\n-    fn seek(&mut self, _pos: i64, _style: SeekStyle) -> IoResult<()> { fail!() }\n+    fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()> {\n+        let new = if_ok!(combine(style, self.pos, self.buf.len(), pos));\n+        self.pos = new as uint;\n+        Ok(())\n+    }\n }\n \n impl<'a> Buffer for BufReader<'a> {\n@@ -506,4 +515,42 @@ mod test {\n             Err(..) => {}\n         }\n     }\n+\n+    #[test]\n+    fn seek_past_end() {\n+        let buf = [0xff];\n+        let mut r = BufReader::new(buf);\n+        r.seek(10, SeekSet).unwrap();\n+        assert!(r.read(&mut []).is_err());\n+\n+        let mut r = MemReader::new(~[10]);\n+        r.seek(10, SeekSet).unwrap();\n+        assert!(r.read(&mut []).is_err());\n+\n+        let mut r = MemWriter::new();\n+        r.seek(10, SeekSet).unwrap();\n+        assert!(r.write([3]).is_ok());\n+\n+        let mut buf = [0];\n+        let mut r = BufWriter::new(buf);\n+        r.seek(10, SeekSet).unwrap();\n+        assert!(r.write([3]).is_err());\n+    }\n+\n+    #[test]\n+    fn seek_before_0() {\n+        let buf = [0xff];\n+        let mut r = BufReader::new(buf);\n+        assert!(r.seek(-1, SeekSet).is_err());\n+\n+        let mut r = MemReader::new(~[10]);\n+        assert!(r.seek(-1, SeekSet).is_err());\n+\n+        let mut r = MemWriter::new();\n+        assert!(r.seek(-1, SeekSet).is_err());\n+\n+        let mut buf = [0];\n+        let mut r = BufWriter::new(buf);\n+        assert!(r.seek(-1, SeekSet).is_err());\n+    }\n }"}, {"sha": "24b3d1cc4de70a3d73cb51e6e7453d366444308c", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1d5c52d8a1d9cc5750aadfbb707584466083ef47/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d5c52d8a1d9cc5750aadfbb707584466083ef47/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=1d5c52d8a1d9cc5750aadfbb707584466083ef47", "patch": "@@ -1200,19 +1200,21 @@ pub enum SeekStyle {\n     SeekCur,\n }\n \n-/// # FIXME\n-/// * Are `u64` and `i64` the right choices?\n pub trait Seek {\n     /// Return position of file cursor in the stream\n     fn tell(&self) -> IoResult<u64>;\n \n     /// Seek to an offset in a stream\n     ///\n-    /// A successful seek clears the EOF indicator.\n+    /// A successful seek clears the EOF indicator. Seeking beyond EOF is\n+    /// allowed, but seeking before position 0 is not allowed.\n     ///\n-    /// # FIXME\n+    /// # Errors\n     ///\n-    /// * What is the behavior when seeking past the end of a stream?\n+    /// * Seeking to a negative offset is considered an error\n+    /// * Seeking past the end of the stream does not modify the underlying\n+    ///   stream, but the next write may cause the previous data to be filled in\n+    ///   with a bit pattern.\n     fn seek(&mut self, pos: i64, style: SeekStyle) -> IoResult<()>;\n }\n "}]}