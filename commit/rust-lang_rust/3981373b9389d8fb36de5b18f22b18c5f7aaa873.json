{"sha": "3981373b9389d8fb36de5b18f22b18c5f7aaa873", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5ODEzNzNiOTM4OWQ4ZmIzNmRlNWIxOGYyMmIxOGM1ZjdhYWE4NzM=", "commit": {"author": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-06-06T18:41:15Z"}, "committer": {"name": "Dawer", "email": "7803845+iDawer@users.noreply.github.com", "date": "2021-08-04T14:04:21Z"}, "message": "internal: add implicit `Sized` bounds to type parameters.", "tree": {"sha": "b6e09550d89ced90d7eef3f9b5d9131a12b9a81c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b6e09550d89ced90d7eef3f9b5d9131a12b9a81c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3981373b9389d8fb36de5b18f22b18c5f7aaa873", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3981373b9389d8fb36de5b18f22b18c5f7aaa873", "html_url": "https://github.com/rust-lang/rust/commit/3981373b9389d8fb36de5b18f22b18c5f7aaa873", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3981373b9389d8fb36de5b18f22b18c5f7aaa873/comments", "author": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "iDawer", "id": 7803845, "node_id": "MDQ6VXNlcjc4MDM4NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7803845?v=4", "gravatar_id": "", "url": "https://api.github.com/users/iDawer", "html_url": "https://github.com/iDawer", "followers_url": "https://api.github.com/users/iDawer/followers", "following_url": "https://api.github.com/users/iDawer/following{/other_user}", "gists_url": "https://api.github.com/users/iDawer/gists{/gist_id}", "starred_url": "https://api.github.com/users/iDawer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/iDawer/subscriptions", "organizations_url": "https://api.github.com/users/iDawer/orgs", "repos_url": "https://api.github.com/users/iDawer/repos", "events_url": "https://api.github.com/users/iDawer/events{/privacy}", "received_events_url": "https://api.github.com/users/iDawer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a8431133e1d859fe6a168cc20288d48957d97fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a8431133e1d859fe6a168cc20288d48957d97fe", "html_url": "https://github.com/rust-lang/rust/commit/8a8431133e1d859fe6a168cc20288d48957d97fe"}], "stats": {"total": 120, "additions": 99, "deletions": 21}, "files": [{"sha": "98c1f1c227c9d453f3004211d8f3b1d2c4a03cc0", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=3981373b9389d8fb36de5b18f22b18c5f7aaa873", "patch": "@@ -93,7 +93,7 @@ impl HirDisplay for Function {\n         } else {\n             match &*data.ret_type {\n                 TypeRef::ImplTrait(bounds) => match bounds[0].as_ref() {\n-                    TypeBound::Path(path) => {\n+                    TypeBound::Path(path, _) => {\n                         path.segments().iter().last().unwrap().args_and_bindings.unwrap().bindings\n                             [0]\n                         .type_ref"}, {"sha": "40104833db3089b971db8c79a3596b40bdd2cd57", "filename": "crates/hir_def/src/generics.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fgenerics.rs?ref=3981373b9389d8fb36de5b18f22b18c5f7aaa873", "patch": "@@ -338,10 +338,6 @@ impl GenericParams {\n         hrtb_lifetimes: Option<&Box<[Name]>>,\n         target: Either<TypeRef, LifetimeRef>,\n     ) {\n-        if bound.question_mark_token().is_some() {\n-            // FIXME: remove this bound\n-            return;\n-        }\n         let bound = TypeBound::from_ast(lower_ctx, bound);\n         let predicate = match (target, bound) {\n             (Either::Left(type_ref), bound) => match hrtb_lifetimes {"}, {"sha": "2f9e33b6adc8e3b4f8c9e950cb55ff7f33a206e2", "filename": "crates/hir_def/src/item_tree/lower.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=3981373b9389d8fb36de5b18f22b18c5f7aaa873", "patch": "@@ -10,7 +10,7 @@ use syntax::{\n \n use crate::{\n     generics::{GenericParams, TypeParamData, TypeParamProvenance},\n-    type_ref::{LifetimeRef, TraitRef},\n+    type_ref::{LifetimeRef, TraitBoundModifier, TraitRef},\n };\n \n use super::*;\n@@ -369,7 +369,7 @@ impl<'a> Ctx<'a> {\n         let (ret_type, async_ret_type) = if func.async_token().is_some() {\n             let async_ret_type = ret_type.clone();\n             let future_impl = desugar_future_path(ret_type);\n-            let ty_bound = Interned::new(TypeBound::Path(future_impl));\n+            let ty_bound = Interned::new(TypeBound::Path(future_impl, TraitBoundModifier::None));\n             (TypeRef::ImplTrait(vec![ty_bound]), Some(async_ret_type))\n         } else {\n             (ret_type, None)"}, {"sha": "24cc2408de2ffa7f3b5a4404371a9c7c877b3356", "filename": "crates/hir_def/src/item_tree/pretty.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=3981373b9389d8fb36de5b18f22b18c5f7aaa873", "patch": "@@ -8,6 +8,7 @@ use crate::{\n     attr::RawAttrs,\n     generics::{WherePredicate, WherePredicateTypeTarget},\n     path::GenericArg,\n+    type_ref::TraitBoundModifier,\n     visibility::RawVisibility,\n };\n \n@@ -543,7 +544,13 @@ impl<'a> Printer<'a> {\n             }\n \n             match bound.as_ref() {\n-                TypeBound::Path(path) => self.print_path(path),\n+                TypeBound::Path(path, modifier) => {\n+                    match modifier {\n+                        TraitBoundModifier::None => (),\n+                        TraitBoundModifier::Maybe => w!(self, \"?\"),\n+                    }\n+                    self.print_path(path)\n+                }\n                 TypeBound::ForLifetime(lifetimes, path) => {\n                     w!(self, \"for<{}> \", lifetimes.iter().format(\", \"));\n                     self.print_path(path);"}, {"sha": "34abe9e07249fa52fae2dae50ba9741307630362", "filename": "crates/hir_def/src/type_ref.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Ftype_ref.rs?ref=3981373b9389d8fb36de5b18f22b18c5f7aaa873", "patch": "@@ -118,12 +118,20 @@ impl LifetimeRef {\n \n #[derive(Clone, PartialEq, Eq, Hash, Debug)]\n pub enum TypeBound {\n-    Path(Path),\n+    Path(Path, TraitBoundModifier),\n     ForLifetime(Box<[Name]>, Path),\n     Lifetime(LifetimeRef),\n     Error,\n }\n \n+/// A modifier on a bound, currently this is only used for `?Sized`, where the\n+/// modifier is `Maybe`.\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TraitBoundModifier {\n+    None,\n+    Maybe,\n+}\n+\n impl TypeRef {\n     /// Converts an `ast::TypeRef` to a `hir::TypeRef`.\n     pub fn from_ast(ctx: &LowerCtx, node: ast::Type) -> Self {\n@@ -233,7 +241,7 @@ impl TypeRef {\n                 TypeRef::ImplTrait(bounds) | TypeRef::DynTrait(bounds) => {\n                     for bound in bounds {\n                         match bound.as_ref() {\n-                            TypeBound::Path(path) | TypeBound::ForLifetime(_, path) => {\n+                            TypeBound::Path(path, _) | TypeBound::ForLifetime(_, path) => {\n                                 go_path(path, f)\n                             }\n                             TypeBound::Lifetime(_) | TypeBound::Error => (),\n@@ -265,7 +273,7 @@ impl TypeRef {\n                         }\n                         for bound in &binding.bounds {\n                             match bound.as_ref() {\n-                                TypeBound::Path(path) | TypeBound::ForLifetime(_, path) => {\n+                                TypeBound::Path(path, _) | TypeBound::ForLifetime(_, path) => {\n                                     go_path(path, f)\n                                 }\n                                 TypeBound::Lifetime(_) | TypeBound::Error => (),\n@@ -295,7 +303,11 @@ impl TypeBound {\n \n         match node.kind() {\n             ast::TypeBoundKind::PathType(path_type) => {\n-                lower_path_type(path_type).map(TypeBound::Path).unwrap_or(TypeBound::Error)\n+                let m = match node.question_mark_token() {\n+                    Some(_) => TraitBoundModifier::Maybe,\n+                    None => TraitBoundModifier::None,\n+                };\n+                lower_path_type(path_type).map(|p| TypeBound::Path(p, m)).unwrap_or(TypeBound::Error)\n             }\n             ast::TypeBoundKind::ForType(for_type) => {\n                 let lt_refs = match for_type.generic_param_list() {\n@@ -322,7 +334,7 @@ impl TypeBound {\n \n     pub fn as_path(&self) -> Option<&Path> {\n         match self {\n-            TypeBound::Path(p) | TypeBound::ForLifetime(_, p) => Some(p),\n+            TypeBound::Path(p, _) | TypeBound::ForLifetime(_, p) => Some(p),\n             TypeBound::Lifetime(_) | TypeBound::Error => None,\n         }\n     }"}, {"sha": "d074c19a3e4ce00f4280338c6d5c91277a2a9909", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=3981373b9389d8fb36de5b18f22b18c5f7aaa873", "patch": "@@ -13,7 +13,7 @@ use hir_def::{\n     intern::{Internable, Interned},\n     item_scope::ItemInNs,\n     path::{Path, PathKind},\n-    type_ref::{TypeBound, TypeRef},\n+    type_ref::{TraitBoundModifier, TypeBound, TypeRef},\n     visibility::Visibility,\n     AssocContainerId, Lookup, ModuleId, TraitId,\n };\n@@ -1026,7 +1026,14 @@ impl HirDisplay for TypeRef {\n impl HirDisplay for TypeBound {\n     fn hir_fmt(&self, f: &mut HirFormatter) -> Result<(), HirDisplayError> {\n         match self {\n-            TypeBound::Path(path) => path.hir_fmt(f),\n+            TypeBound::Path(path, modifier) => {\n+                // todo don't print implicit Sized; implicit ?Sized on Self of a trait\n+                match modifier {\n+                    TraitBoundModifier::None => (),\n+                    TraitBoundModifier::Maybe => write!(f, \"?\")?,\n+                }\n+                path.hir_fmt(f)\n+            }\n             TypeBound::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n             TypeBound::ForLifetime(lifetimes, path) => {\n                 write!(f, \"for<{}> \", lifetimes.iter().format(\", \"))?;"}, {"sha": "2eb9a21ddd2c793830ae599eae699544bb2f22a6", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 62, "deletions": 6, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3981373b9389d8fb36de5b18f22b18c5f7aaa873/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=3981373b9389d8fb36de5b18f22b18c5f7aaa873", "patch": "@@ -18,13 +18,14 @@ use hir_def::{\n     generics::{TypeParamProvenance, WherePredicate, WherePredicateTypeTarget},\n     path::{GenericArg, Path, PathSegment, PathSegments},\n     resolver::{HasResolver, Resolver, TypeNs},\n-    type_ref::{TraitRef as HirTraitRef, TypeBound, TypeRef},\n+    type_ref::{TraitBoundModifier, TraitRef as HirTraitRef, TypeBound, TypeRef},\n     AdtId, AssocContainerId, AssocItemId, ConstId, ConstParamId, EnumId, EnumVariantId, FunctionId,\n     GenericDefId, HasModule, ImplId, LocalFieldId, Lookup, StaticId, StructId, TraitId,\n     TypeAliasId, TypeParamId, UnionId, VariantId,\n };\n use hir_expand::{name::Name, ExpandResult};\n use la_arena::ArenaMap;\n+use rustc_hash::FxHashSet;\n use smallvec::SmallVec;\n use stdx::impl_from;\n use syntax::ast;\n@@ -65,6 +66,8 @@ pub struct TyLoweringContext<'a> {\n     /// Splitting this up would be a possible fix.\n     opaque_type_data: RefCell<Vec<ReturnTypeImplTrait>>,\n     expander: RefCell<Option<Expander>>,\n+    /// Keeps tracking types with explicit `?Sized` bounds.\n+    unsized_types: RefCell<FxHashSet<Ty>>,\n }\n \n impl<'a> TyLoweringContext<'a> {\n@@ -83,6 +86,7 @@ impl<'a> TyLoweringContext<'a> {\n             type_param_mode,\n             opaque_type_data,\n             expander: RefCell::new(None),\n+            unsized_types: RefCell::default(),\n         }\n     }\n \n@@ -93,17 +97,20 @@ impl<'a> TyLoweringContext<'a> {\n     ) -> T {\n         let opaque_ty_data_vec = self.opaque_type_data.replace(Vec::new());\n         let expander = self.expander.replace(None);\n+        let unsized_types = self.unsized_types.replace(Default::default());\n         let new_ctx = Self {\n             in_binders: debruijn,\n             impl_trait_counter: Cell::new(self.impl_trait_counter.get()),\n             opaque_type_data: RefCell::new(opaque_ty_data_vec),\n             expander: RefCell::new(expander),\n+            unsized_types: RefCell::new(unsized_types),\n             ..*self\n         };\n         let result = f(&new_ctx);\n         self.impl_trait_counter.set(new_ctx.impl_trait_counter.get());\n         self.opaque_type_data.replace(new_ctx.opaque_type_data.into_inner());\n         self.expander.replace(new_ctx.expander.into_inner());\n+        self.unsized_types.replace(new_ctx.unsized_types.into_inner());\n         result\n     }\n \n@@ -778,10 +785,27 @@ impl<'a> TyLoweringContext<'a> {\n     ) -> impl Iterator<Item = QuantifiedWhereClause> + 'a {\n         let mut bindings = None;\n         let trait_ref = match bound {\n-            TypeBound::Path(path) => {\n+            TypeBound::Path(path, TraitBoundModifier::None) => {\n                 bindings = self.lower_trait_ref_from_path(path, Some(self_ty));\n                 bindings.clone().map(WhereClause::Implemented).map(crate::wrap_empty_binders)\n             }\n+            TypeBound::Path(path, TraitBoundModifier::Maybe) => {\n+                let sized_trait = self\n+                    .resolver\n+                    .krate()\n+                    .and_then(|krate| self.db.lang_item(krate, \"sized\".into()))\n+                    .and_then(|lang_item| lang_item.as_trait());\n+                // Don't lower associated type bindings as the only possible relaxed trait bound\n+                // `?Sized` has none of them.\n+                // If we got another trait here ignore the bound completely.\n+                let trait_id = self\n+                    .lower_trait_ref_from_path(path, Some(self_ty.clone()))\n+                    .map(|trait_ref| trait_ref.hir_trait_id());\n+                if trait_id == sized_trait {\n+                    self.unsized_types.borrow_mut().insert(self_ty);\n+                }\n+                None\n+            }\n             TypeBound::ForLifetime(_, path) => {\n                 // FIXME Don't silently drop the hrtb lifetimes here\n                 bindings = self.lower_trait_ref_from_path(path, Some(self_ty));\n@@ -804,8 +828,10 @@ impl<'a> TyLoweringContext<'a> {\n         trait_ref: TraitRef,\n     ) -> impl Iterator<Item = QuantifiedWhereClause> + 'a {\n         let last_segment = match bound {\n-            TypeBound::Path(path) | TypeBound::ForLifetime(_, path) => path.segments().last(),\n-            TypeBound::Error | TypeBound::Lifetime(_) => None,\n+            TypeBound::Path(path, TraitBoundModifier::None) | TypeBound::ForLifetime(_, path) => path.segments().last(),\n+            TypeBound::Path(_, TraitBoundModifier::Maybe)\n+            | TypeBound::Error\n+            | TypeBound::Lifetime(_) => None,\n         };\n         last_segment\n             .into_iter()\n@@ -1053,10 +1079,40 @@ pub(crate) fn generic_predicates_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     let generics = generics(db.upcast(), def);\n-    resolver\n+\n+    let mut predicates = resolver\n         .where_predicates_in_scope()\n         .flat_map(|pred| ctx.lower_where_predicate(pred, false).map(|p| make_binders(&generics, p)))\n-        .collect()\n+        .collect::<Vec<_>>();\n+\n+    // Generate implicit `: Sized` predicates for all generics that has no `?Sized` bound.\n+    // Exception is Self of a trait.\n+    let is_trait_def = matches!(def, GenericDefId::TraitId(..));\n+    let explicitly_unsized_tys = ctx.unsized_types.into_inner();\n+    let subtsts = generics.bound_vars_subst(DebruijnIndex::INNERMOST);\n+    let generic_args = &subtsts.as_slice(&Interner)[is_trait_def as usize..];\n+    let sized_trait = resolver\n+        .krate()\n+        .and_then(|krate| db.lang_item(krate, \"sized\".into()))\n+        .and_then(|lang_item| lang_item.as_trait().map(to_chalk_trait_id));\n+    let sized_predicates = sized_trait\n+        .into_iter()\n+        .flat_map(|sized_trait| {\n+            let implicitly_sized_tys = generic_args\n+                .iter()\n+                .filter_map(|generic_arg| generic_arg.ty(&Interner))\n+                .filter(|&self_ty| !explicitly_unsized_tys.contains(self_ty));\n+            implicitly_sized_tys.map(move |self_ty| {\n+                WhereClause::Implemented(TraitRef {\n+                    trait_id: sized_trait,\n+                    substitution: Substitution::from1(&Interner, self_ty.clone()),\n+                })\n+            })\n+        })\n+        .map(|p| make_binders(&generics, crate::wrap_empty_binders(p)));\n+\n+    predicates.extend(sized_predicates);\n+    predicates.into()\n }\n \n /// Resolve the default type params from generics"}]}