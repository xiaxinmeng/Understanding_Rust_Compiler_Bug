{"sha": "06c9fef822b890054fcefa9a567b57eb6edfe638", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2YzlmZWY4MjJiODkwMDU0ZmNlZmE5YTU2N2I1N2ViNmVkZmU2Mzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-21T11:46:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-21T11:46:51Z"}, "message": "Auto merge of #72422 - RalfJung:rollup-u81z4mw, r=RalfJung\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #71854 (Make `std::char` functions and constants associated to `char`.)\n - #72111 (rustc-book: Document `-Z strip=val` option)\n - #72272 (Fix going back in history to a search result page on firefox)\n - #72296 (Suggest installing VS Build Tools in more situations)\n - #72365 (Remove unused `StableHashingContext::node_to_hir_id` method)\n - #72371 (FIX - Char documentation for unexperienced users)\n - #72397 (llvm: Expose tiny code model to users)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "c5013e43d75a33c85ac401ed12640c4f1eb1e9b5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5013e43d75a33c85ac401ed12640c4f1eb1e9b5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06c9fef822b890054fcefa9a567b57eb6edfe638", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06c9fef822b890054fcefa9a567b57eb6edfe638", "html_url": "https://github.com/rust-lang/rust/commit/06c9fef822b890054fcefa9a567b57eb6edfe638", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06c9fef822b890054fcefa9a567b57eb6edfe638/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f79e98c0356642db62e5113327e436c951e843d", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f79e98c0356642db62e5113327e436c951e843d", "html_url": "https://github.com/rust-lang/rust/commit/7f79e98c0356642db62e5113327e436c951e843d"}, {"sha": "e5a455086944fc6ef95b33248de2894d10076139", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5a455086944fc6ef95b33248de2894d10076139", "html_url": "https://github.com/rust-lang/rust/commit/e5a455086944fc6ef95b33248de2894d10076139"}], "stats": {"total": 330, "additions": 318, "deletions": 12}, "files": [{"sha": "0b4bb05c1db23e66ead131d085b9ced6d7bf9141", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=06c9fef822b890054fcefa9a567b57eb6edfe638", "patch": "@@ -21,7 +21,7 @@ specification.\n \n Supported values for this option are:\n \n-<!-- - `tiny` - Tiny code model. -->\n+- `tiny` - Tiny code model.\n - `small` - Small code model. This is the default model for majority of supported targets.\n - `kernel` - Kernel code model.\n - `medium` - Medium code model."}, {"sha": "52cb98113c0c13296221f34d0daa6bfee04231cf", "filename": "src/doc/unstable-book/src/compiler-flags/strip.md", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md", "raw_url": "https://github.com/rust-lang/rust/raw/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Fstrip.md?ref=06c9fef822b890054fcefa9a567b57eb6edfe638", "patch": "@@ -0,0 +1,17 @@\n+# `strip`\n+\n+The tracking issue for this feature is: [#72110](https://github.com/rust-lang/rust/issues/72110).\n+\n+------------------------\n+\n+Option `-Z strip=val` controls stripping of debuginfo and similar auxiliary data from binaries\n+during linking.\n+\n+Supported values for this option are:\n+\n+- `none` - debuginfo and symbols (if they exist) are copied to the produced binary or separate files\n+depending on the target (e.g. `.pdb` files in case of MSVC).\n+- `debuginfo` - debuginfo sections and debuginfo symbols from the symbol table section\n+are stripped at link time and are not copied to the produced binary or separate files.\n+- `symbols` - same as `debuginfo`, but the rest of the symbol table section is stripped as well\n+if the linker supports it."}, {"sha": "5c5bc9adb5df29fbed1e0338cfbea2ba3e26764d", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 241, "deletions": 2, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=06c9fef822b890054fcefa9a567b57eb6edfe638", "patch": "@@ -9,6 +9,243 @@ use super::*;\n \n #[lang = \"char\"]\n impl char {\n+    /// The highest valid code point a `char` can have.\n+    ///\n+    /// A `char` is a [Unicode Scalar Value], which means that it is a [Code\n+    /// Point], but only ones within a certain range. `MAX` is the highest valid\n+    /// code point that's a valid [Unicode Scalar Value].\n+    ///\n+    /// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n+    /// [Code Point]: http://www.unicode.org/glossary/#code_point\n+    #[unstable(feature = \"assoc_char_consts\", reason = \"recently added\", issue = \"71763\")]\n+    pub const MAX: char = '\\u{10ffff}';\n+\n+    /// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n+    /// decoding error.\n+    ///\n+    /// It can occur, for example, when giving ill-formed UTF-8 bytes to\n+    /// [`String::from_utf8_lossy`](string/struct.String.html#method.from_utf8_lossy).\n+    #[unstable(feature = \"assoc_char_consts\", reason = \"recently added\", issue = \"71763\")]\n+    pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n+\n+    /// The version of [Unicode](http://www.unicode.org/) that the Unicode parts of\n+    /// `char` and `str` methods are based on.\n+    ///\n+    /// New versions of Unicode are released regularly and subsequently all methods\n+    /// in the standard library depending on Unicode are updated. Therefore the\n+    /// behavior of some `char` and `str` methods and the value of this constant\n+    /// changes over time. This is *not* considered to be a breaking change.\n+    ///\n+    /// The version numbering scheme is explained in\n+    /// [Unicode 11.0 or later, Section 3.1 Versions of the Unicode Standard](https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf#page=4).\n+    #[unstable(feature = \"assoc_char_consts\", reason = \"recently added\", issue = \"71763\")]\n+    pub const UNICODE_VERSION: (u8, u8, u8) = crate::unicode::UNICODE_VERSION;\n+\n+    /// Creates an iterator over the UTF-16 encoded code points in `iter`,\n+    /// returning unpaired surrogates as `Err`s.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char::decode_utf16;\n+    ///\n+    /// // \ud834\udd1emus<invalid>ic<invalid>\n+    /// let v = [\n+    ///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+    /// ];\n+    ///\n+    /// assert_eq!(\n+    ///     decode_utf16(v.iter().cloned())\n+    ///         .map(|r| r.map_err(|e| e.unpaired_surrogate()))\n+    ///         .collect::<Vec<_>>(),\n+    ///     vec![\n+    ///         Ok('\ud834\udd1e'),\n+    ///         Ok('m'), Ok('u'), Ok('s'),\n+    ///         Err(0xDD1E),\n+    ///         Ok('i'), Ok('c'),\n+    ///         Err(0xD834)\n+    ///     ]\n+    /// );\n+    /// ```\n+    ///\n+    /// A lossy decoder can be obtained by replacing `Err` results with the replacement character:\n+    ///\n+    /// ```\n+    /// use std::char::{decode_utf16, REPLACEMENT_CHARACTER};\n+    ///\n+    /// // \ud834\udd1emus<invalid>ic<invalid>\n+    /// let v = [\n+    ///     0xD834, 0xDD1E, 0x006d, 0x0075, 0x0073, 0xDD1E, 0x0069, 0x0063, 0xD834,\n+    /// ];\n+    ///\n+    /// assert_eq!(\n+    ///     decode_utf16(v.iter().cloned())\n+    ///        .map(|r| r.unwrap_or(REPLACEMENT_CHARACTER))\n+    ///        .collect::<String>(),\n+    ///     \"\ud834\udd1emus\ufffdic\ufffd\"\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub fn decode_utf16<I: IntoIterator<Item = u16>>(iter: I) -> DecodeUtf16<I::IntoIter> {\n+        super::decode::decode_utf16(iter)\n+    }\n+\n+    /// Converts a `u32` to a `char`.\n+    ///\n+    /// Note that all `char`s are valid [`u32`]s, and can be cast to one with\n+    /// `as`:\n+    ///\n+    /// ```\n+    /// let c = '\ud83d\udcaf';\n+    /// let i = c as u32;\n+    ///\n+    /// assert_eq!(128175, i);\n+    /// ```\n+    ///\n+    /// However, the reverse is not true: not all valid [`u32`]s are valid\n+    /// `char`s. `from_u32()` will return `None` if the input is not a valid value\n+    /// for a `char`.\n+    ///\n+    /// [`u32`]: primitive.u32.html\n+    ///\n+    /// For an unsafe version of this function which ignores these checks, see\n+    /// [`from_u32_unchecked`].\n+    ///\n+    /// [`from_u32_unchecked`]: #method.from_u32_unchecked\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_u32(0x2764);\n+    ///\n+    /// assert_eq!(Some('\u2764'), c);\n+    /// ```\n+    ///\n+    /// Returning `None` when the input is not a valid `char`:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_u32(0x110000);\n+    ///\n+    /// assert_eq!(None, c);\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub fn from_u32(i: u32) -> Option<char> {\n+        super::convert::from_u32(i)\n+    }\n+\n+    /// Converts a `u32` to a `char`, ignoring validity.\n+    ///\n+    /// Note that all `char`s are valid [`u32`]s, and can be cast to one with\n+    /// `as`:\n+    ///\n+    /// ```\n+    /// let c = '\ud83d\udcaf';\n+    /// let i = c as u32;\n+    ///\n+    /// assert_eq!(128175, i);\n+    /// ```\n+    ///\n+    /// However, the reverse is not true: not all valid [`u32`]s are valid\n+    /// `char`s. `from_u32_unchecked()` will ignore this, and blindly cast to\n+    /// `char`, possibly creating an invalid one.\n+    ///\n+    /// [`u32`]: primitive.u32.html\n+    ///\n+    /// # Safety\n+    ///\n+    /// This function is unsafe, as it may construct invalid `char` values.\n+    ///\n+    /// For a safe version of this function, see the [`from_u32`] function.\n+    ///\n+    /// [`from_u32`]: #method.from_u32\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = unsafe { char::from_u32_unchecked(0x2764) };\n+    ///\n+    /// assert_eq!('\u2764', c);\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub unsafe fn from_u32_unchecked(i: u32) -> char {\n+        super::convert::from_u32_unchecked(i)\n+    }\n+\n+    /// Converts a digit in the given radix to a `char`.\n+    ///\n+    /// A 'radix' here is sometimes also called a 'base'. A radix of two\n+    /// indicates a binary number, a radix of ten, decimal, and a radix of\n+    /// sixteen, hexadecimal, to give some common values. Arbitrary\n+    /// radices are supported.\n+    ///\n+    /// `from_digit()` will return `None` if the input is not a digit in\n+    /// the given radix.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if given a radix larger than 36.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_digit(4, 10);\n+    ///\n+    /// assert_eq!(Some('4'), c);\n+    ///\n+    /// // Decimal 11 is a single digit in base 16\n+    /// let c = char::from_digit(11, 16);\n+    ///\n+    /// assert_eq!(Some('b'), c);\n+    /// ```\n+    ///\n+    /// Returning `None` when the input is not a digit:\n+    ///\n+    /// ```\n+    /// use std::char;\n+    ///\n+    /// let c = char::from_digit(20, 10);\n+    ///\n+    /// assert_eq!(None, c);\n+    /// ```\n+    ///\n+    /// Passing a large radix, causing a panic:\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    /// use std::char;\n+    ///\n+    /// let result = thread::spawn(|| {\n+    ///     // this panics\n+    ///     let c = char::from_digit(1, 37);\n+    /// }).join();\n+    ///\n+    /// assert!(result.is_err());\n+    /// ```\n+    #[unstable(feature = \"assoc_char_funcs\", reason = \"recently added\", issue = \"71763\")]\n+    #[inline]\n+    pub fn from_digit(num: u32, radix: u32) -> Option<char> {\n+        super::convert::from_digit(num, radix)\n+    }\n+\n     /// Checks if a `char` is a digit in the given radix.\n     ///\n     /// A 'radix' here is sometimes also called a 'base'. A radix of two\n@@ -575,8 +812,9 @@ impl char {\n     /// assert!(!'A'.is_lowercase());\n     /// assert!(!'\u0394'.is_lowercase());\n     ///\n-    /// // The various Chinese scripts do not have case, and so:\n+    /// // The various Chinese scripts and punctuation do not have case, and so:\n     /// assert!(!'\u4e2d'.is_lowercase());\n+    /// assert!(!' '.is_lowercase());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n@@ -606,8 +844,9 @@ impl char {\n     /// assert!('A'.is_uppercase());\n     /// assert!('\u0394'.is_uppercase());\n     ///\n-    /// // The various Chinese scripts do not have case, and so:\n+    /// // The various Chinese scripts and punctuation do not have case, and so:\n     /// assert!(!'\u4e2d'.is_uppercase());\n+    /// assert!(!' '.is_uppercase());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]"}, {"sha": "bf65c31e135975826e856cbbe6a41f02783fd403", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=06c9fef822b890054fcefa9a567b57eb6edfe638", "patch": "@@ -92,15 +92,15 @@ const MAX_THREE_B: u32 = 0x10000;\n /// [Unicode Scalar Value]: http://www.unicode.org/glossary/#unicode_scalar_value\n /// [Code Point]: http://www.unicode.org/glossary/#code_point\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub const MAX: char = '\\u{10ffff}';\n+pub const MAX: char = char::MAX;\n \n /// `U+FFFD REPLACEMENT CHARACTER` (\ufffd) is used in Unicode to represent a\n /// decoding error.\n ///\n /// It can occur, for example, when giving ill-formed UTF-8 bytes to\n /// [`String::from_utf8_lossy`](../../std/string/struct.String.html#method.from_utf8_lossy).\n #[stable(feature = \"decode_utf16\", since = \"1.9.0\")]\n-pub const REPLACEMENT_CHARACTER: char = '\\u{FFFD}';\n+pub const REPLACEMENT_CHARACTER: char = char::REPLACEMENT_CHARACTER;\n \n /// Returns an iterator that yields the hexadecimal Unicode escape of a\n /// character, as `char`s."}, {"sha": "55ee660d9f7005e99b783b85b6de565b96308d51", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=06c9fef822b890054fcefa9a567b57eb6edfe638", "patch": "@@ -208,7 +208,7 @@ impl CodegenBackend for LlvmCodegenBackend {\n             }\n             PrintRequest::CodeModels => {\n                 println!(\"Available code models:\");\n-                for name in &[\"small\", \"kernel\", \"medium\", \"large\"] {\n+                for name in &[\"tiny\", \"small\", \"kernel\", \"medium\", \"large\"] {\n                     println!(\"    {}\", name);\n                 }\n                 println!();"}, {"sha": "aa4b51f1acb091b19ade42c9f58398050b38a69b", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=06c9fef822b890054fcefa9a567b57eb6edfe638", "patch": "@@ -611,6 +611,55 @@ fn link_natively<'a, B: ArchiveBuilder<'a>>(\n                 .note(&format!(\"{:?}\", &cmd))\n                 .note(&escape_string(&output))\n                 .emit();\n+\n+                // If MSVC's `link.exe` was expected but the return code\n+                // is not a Microsoft LNK error then suggest a way to fix or\n+                // install the Visual Studio build tools.\n+                if let Some(code) = prog.status.code() {\n+                    if sess.target.target.options.is_like_msvc\n+                        && flavor == LinkerFlavor::Msvc\n+                        // Respect the command line override\n+                        && sess.opts.cg.linker.is_none()\n+                        // Match exactly \"link.exe\"\n+                        && linker_path.to_str() == Some(\"link.exe\")\n+                        // All Microsoft `link.exe` linking error codes are\n+                        // four digit numbers in the range 1000 to 9999 inclusive\n+                        && (code < 1000 || code > 9999)\n+                    {\n+                        let is_vs_installed = windows_registry::find_vs_version().is_ok();\n+                        let has_linker = windows_registry::find_tool(\n+                            &sess.opts.target_triple.triple(),\n+                            \"link.exe\",\n+                        )\n+                        .is_some();\n+\n+                        sess.note_without_error(\"`link.exe` returned an unexpected error\");\n+                        if is_vs_installed && has_linker {\n+                            // the linker is broken\n+                            sess.note_without_error(\n+                                \"the Visual Studio build tools may need to be repaired \\\n+                                using the Visual Studio installer\",\n+                            );\n+                            sess.note_without_error(\n+                                \"or a necessary component may be missing from the \\\n+                                \\\"C++ build tools\\\" workload\",\n+                            );\n+                        } else if is_vs_installed {\n+                            // the linker is not installed\n+                            sess.note_without_error(\n+                                \"in the Visual Studio installer, ensure the \\\n+                                \\\"C++ build tools\\\" workload is selected\",\n+                            );\n+                        } else {\n+                            // visual studio is not installed\n+                            sess.note_without_error(\n+                                \"you may need to install Visual Studio build tools with the \\\n+                                \\\"C++ build tools\\\" workload\",\n+                            );\n+                        }\n+                    }\n+                }\n+\n                 sess.abort_if_errors();\n             }\n             info!(\"linker stderr:\\n{}\", escape_string(&prog.stderr));"}, {"sha": "69b4adb3a0e1d7ed2e5b1f8f7ea5d2b843d32401", "filename": "src/librustc_middle/ich/hcx.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibrustc_middle%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibrustc_middle%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fich%2Fhcx.rs?ref=06c9fef822b890054fcefa9a567b57eb6edfe638", "patch": "@@ -135,11 +135,6 @@ impl<'a> StableHashingContext<'a> {\n         self.definitions.def_path_hash(def_id)\n     }\n \n-    #[inline]\n-    pub fn node_to_hir_id(&self, node_id: ast::NodeId) -> hir::HirId {\n-        self.definitions.node_id_to_hir_id(node_id)\n-    }\n-\n     #[inline]\n     pub fn hash_bodies(&self) -> bool {\n         self.hash_bodies"}, {"sha": "8770e033e059661cee183695c180594c5f6df0a0", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=06c9fef822b890054fcefa9a567b57eb6edfe638", "patch": "@@ -322,7 +322,7 @@ impl FromStr for CodeModel {\n \n     fn from_str(s: &str) -> Result<CodeModel, ()> {\n         Ok(match s {\n-            // \"tiny\" => CodeModel::Tiny, // Not exposed to users right now.\n+            \"tiny\" => CodeModel::Tiny,\n             \"small\" => CodeModel::Small,\n             \"kernel\" => CodeModel::Kernel,\n             \"medium\" => CodeModel::Medium,"}, {"sha": "9869c50fbb0cf10a7f8096d66dabb8f3aa3fdc5d", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/06c9fef822b890054fcefa9a567b57eb6edfe638/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=06c9fef822b890054fcefa9a567b57eb6edfe638", "patch": "@@ -2787,3 +2787,9 @@ function focusSearchBar() {\n function defocusSearchBar() {\n     getSearchInput().blur();\n }\n+\n+// This is required in firefox. Explanations: when going back in the history, firefox doesn't re-run\n+// the JS, therefore preventing rustdoc from setting a few things required to be able to reload the\n+// previous search results (if you navigated to a search result with the keyboard, pressed enter on\n+// it to navigate to that result, and then came back to this page).\n+window.onunload = function(){};"}]}