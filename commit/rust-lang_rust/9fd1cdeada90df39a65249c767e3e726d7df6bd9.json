{"sha": "9fd1cdeada90df39a65249c767e3e726d7df6bd9", "node_id": "C_kwDOAAsO6NoAKDlmZDFjZGVhZGE5MGRmMzlhNjUyNDljNzY3ZTNlNzI2ZDdkZjZiZDk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-04T18:47:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-04-04T18:47:27Z"}, "message": "Auto merge of #8632 - Jarcho:cast_ptr_alignment, r=llogiq\n\nDon't lint `cast_ptr_alignment` when used for unaligned reads and writes\n\nfixes #2881\n\nIdeally this would trace the usage of the value rather than only looking at the parent expression, but that would require dataflow analysis. e.g.\n```rust\nlet x = ptr as *const u16;\nc.read_unaligned(x);\n```\n\nArch specific intrinsic functions need to be checked for ones which could take an unaligned pointer. This can be another PR.\n\nchangelog: Don't lint `cast_ptr_alignment` when used for unaligned reads and writes", "tree": {"sha": "51d1dce50e74f3efb57bd208c90d8a7d9e39cc30", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51d1dce50e74f3efb57bd208c90d8a7d9e39cc30"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fd1cdeada90df39a65249c767e3e726d7df6bd9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fd1cdeada90df39a65249c767e3e726d7df6bd9", "html_url": "https://github.com/rust-lang/rust/commit/9fd1cdeada90df39a65249c767e3e726d7df6bd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fd1cdeada90df39a65249c767e3e726d7df6bd9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "190f0deac83174de23ff21f980ab514c90e0e59e", "url": "https://api.github.com/repos/rust-lang/rust/commits/190f0deac83174de23ff21f980ab514c90e0e59e", "html_url": "https://github.com/rust-lang/rust/commit/190f0deac83174de23ff21f980ab514c90e0e59e"}, {"sha": "e4fc15e6467826d1c59219f3963904c776ce7f13", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4fc15e6467826d1c59219f3963904c776ce7f13", "html_url": "https://github.com/rust-lang/rust/commit/e4fc15e6467826d1c59219f3963904c776ce7f13"}], "stats": {"total": 124, "additions": 86, "deletions": 38}, "files": [{"sha": "d476a1a7646c01e24bd8ea9b3df3297ec980fdba", "filename": "clippy_lints/src/casts/cast_ptr_alignment.rs", "status": "modified", "additions": 66, "deletions": 34, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9fd1cdeada90df39a65249c767e3e726d7df6bd9/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd1cdeada90df39a65249c767e3e726d7df6bd9/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcasts%2Fcast_ptr_alignment.rs?ref=9fd1cdeada90df39a65249c767e3e726d7df6bd9", "patch": "@@ -1,7 +1,6 @@\n use clippy_utils::diagnostics::span_lint;\n-use clippy_utils::is_hir_ty_cfg_dependant;\n use clippy_utils::ty::is_c_void;\n-use if_chain::if_chain;\n+use clippy_utils::{get_parent_expr, is_hir_ty_cfg_dependant, match_any_def_paths, paths};\n use rustc_hir::{Expr, ExprKind, GenericArg};\n use rustc_lint::LateContext;\n use rustc_middle::ty::layout::LayoutOf;\n@@ -20,45 +19,78 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         );\n         lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n     } else if let ExprKind::MethodCall(method_path, [self_arg, ..], _) = &expr.kind {\n-        if_chain! {\n-            if method_path.ident.name == sym!(cast);\n-            if let Some(generic_args) = method_path.args;\n-            if let [GenericArg::Type(cast_to)] = generic_args.args;\n+        if method_path.ident.name == sym!(cast)\n+            && let Some(generic_args) = method_path.args\n+            && let [GenericArg::Type(cast_to)] = generic_args.args\n             // There probably is no obvious reason to do this, just to be consistent with `as` cases.\n-            if !is_hir_ty_cfg_dependant(cx, cast_to);\n-            then {\n-                let (cast_from, cast_to) =\n-                    (cx.typeck_results().expr_ty(self_arg), cx.typeck_results().expr_ty(expr));\n-                lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n-            }\n+            && !is_hir_ty_cfg_dependant(cx, cast_to)\n+        {\n+            let (cast_from, cast_to) =\n+                (cx.typeck_results().expr_ty(self_arg), cx.typeck_results().expr_ty(expr));\n+            lint_cast_ptr_alignment(cx, expr, cast_from, cast_to);\n         }\n     }\n }\n \n fn lint_cast_ptr_alignment<'tcx>(cx: &LateContext<'tcx>, expr: &Expr<'_>, cast_from: Ty<'tcx>, cast_to: Ty<'tcx>) {\n-    if_chain! {\n-        if let ty::RawPtr(from_ptr_ty) = &cast_from.kind();\n-        if let ty::RawPtr(to_ptr_ty) = &cast_to.kind();\n-        if let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty);\n-        if let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty);\n-        if from_layout.align.abi < to_layout.align.abi;\n+    if let ty::RawPtr(from_ptr_ty) = &cast_from.kind()\n+        && let ty::RawPtr(to_ptr_ty) = &cast_to.kind()\n+        && let Ok(from_layout) = cx.layout_of(from_ptr_ty.ty)\n+        && let Ok(to_layout) = cx.layout_of(to_ptr_ty.ty)\n+        && from_layout.align.abi < to_layout.align.abi\n         // with c_void, we inherently need to trust the user\n-        if !is_c_void(cx, from_ptr_ty.ty);\n+        && !is_c_void(cx, from_ptr_ty.ty)\n         // when casting from a ZST, we don't know enough to properly lint\n-        if !from_layout.is_zst();\n-        then {\n-            span_lint(\n-                cx,\n-                CAST_PTR_ALIGNMENT,\n-                expr.span,\n-                &format!(\n-                    \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n-                    cast_from,\n-                    cast_to,\n-                    from_layout.align.abi.bytes(),\n-                    to_layout.align.abi.bytes(),\n-                ),\n-            );\n-        }\n+        && !from_layout.is_zst()\n+        && !is_used_as_unaligned(cx, expr)\n+    {\n+        span_lint(\n+            cx,\n+            CAST_PTR_ALIGNMENT,\n+            expr.span,\n+            &format!(\n+                \"casting from `{}` to a more-strictly-aligned pointer (`{}`) ({} < {} bytes)\",\n+                cast_from,\n+                cast_to,\n+                from_layout.align.abi.bytes(),\n+                to_layout.align.abi.bytes(),\n+            ),\n+        );\n+    }\n+}\n+\n+fn is_used_as_unaligned(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n+    let Some(parent) = get_parent_expr(cx, e) else {\n+        return false;\n+    };\n+    match parent.kind {\n+        ExprKind::MethodCall(name, [self_arg, ..], _) if self_arg.hir_id == e.hir_id => {\n+            if matches!(name.ident.as_str(), \"read_unaligned\" | \"write_unaligned\")\n+                && let Some(def_id) = cx.typeck_results().type_dependent_def_id(parent.hir_id)\n+                && let Some(def_id) = cx.tcx.impl_of_method(def_id)\n+                && cx.tcx.type_of(def_id).is_unsafe_ptr()\n+            {\n+                true\n+            } else {\n+                false\n+            }\n+        },\n+        ExprKind::Call(func, [arg, ..]) if arg.hir_id == e.hir_id => {\n+            static PATHS: &[&[&str]] = &[\n+                paths::PTR_READ_UNALIGNED.as_slice(),\n+                paths::PTR_WRITE_UNALIGNED.as_slice(),\n+                paths::PTR_UNALIGNED_VOLATILE_LOAD.as_slice(),\n+                paths::PTR_UNALIGNED_VOLATILE_STORE.as_slice(),\n+            ];\n+            if let ExprKind::Path(path) = &func.kind\n+                && let Some(def_id) = cx.qpath_res(path, func.hir_id).opt_def_id()\n+                && match_any_def_paths(cx, def_id, PATHS).is_some()\n+            {\n+                true\n+            } else {\n+                false\n+            }\n+        },\n+        _ => false,\n     }\n }"}, {"sha": "79e6e92dc0aaf3a2506db51edaeaf6cc47fcb1df", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fd1cdeada90df39a65249c767e3e726d7df6bd9/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd1cdeada90df39a65249c767e3e726d7df6bd9/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=9fd1cdeada90df39a65249c767e3e726d7df6bd9", "patch": "@@ -105,6 +105,8 @@ pub const PTR_READ_UNALIGNED: [&str; 3] = [\"core\", \"ptr\", \"read_unaligned\"];\n pub const PTR_READ_VOLATILE: [&str; 3] = [\"core\", \"ptr\", \"read_volatile\"];\n pub const PTR_REPLACE: [&str; 3] = [\"core\", \"ptr\", \"replace\"];\n pub const PTR_SWAP: [&str; 3] = [\"core\", \"ptr\", \"swap\"];\n+pub const PTR_UNALIGNED_VOLATILE_LOAD: [&str; 3] = [\"core\", \"intrinsics\", \"unaligned_volatile_load\"];\n+pub const PTR_UNALIGNED_VOLATILE_STORE: [&str; 3] = [\"core\", \"intrinsics\", \"unaligned_volatile_store\"];\n pub const PTR_WRITE: [&str; 3] = [\"core\", \"ptr\", \"write\"];\n pub const PTR_WRITE_BYTES: [&str; 3] = [\"core\", \"intrinsics\", \"write_bytes\"];\n pub const PTR_WRITE_UNALIGNED: [&str; 3] = [\"core\", \"ptr\", \"write_unaligned\"];"}, {"sha": "e4e7290a30e9e711c911c34d96a1239af8e0d19a", "filename": "tests/ui/cast_alignment.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9fd1cdeada90df39a65249c767e3e726d7df6bd9/tests%2Fui%2Fcast_alignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fd1cdeada90df39a65249c767e3e726d7df6bd9/tests%2Fui%2Fcast_alignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_alignment.rs?ref=9fd1cdeada90df39a65249c767e3e726d7df6bd9", "patch": "@@ -1,6 +1,7 @@\n //! Test casts for alignment issues\n \n #![feature(rustc_private)]\n+#![feature(core_intrinsics)]\n extern crate libc;\n \n #[warn(clippy::cast_ptr_alignment)]\n@@ -34,4 +35,17 @@ fn main() {\n     (&1u32 as *const u32 as *const libc::c_void) as *const u32;\n     // For ZST, we should trust the user. See #4256\n     (&1u32 as *const u32 as *const ()) as *const u32;\n+\n+    // Issue #2881\n+    let mut data = [0u8, 0u8];\n+    unsafe {\n+        let ptr = &data as *const [u8; 2] as *const u8;\n+        let _ = (ptr as *const u16).read_unaligned();\n+        let _ = core::ptr::read_unaligned(ptr as *const u16);\n+        let _ = core::intrinsics::unaligned_volatile_load(ptr as *const u16);\n+        let ptr = &mut data as *mut [u8; 2] as *mut u8;\n+        let _ = (ptr as *mut u16).write_unaligned(0);\n+        let _ = core::ptr::write_unaligned(ptr as *mut u16, 0);\n+        let _ = core::intrinsics::unaligned_volatile_store(ptr as *mut u16, 0);\n+    }\n }"}, {"sha": "5df2b5b1094be2b96bd552184326695820fb6b6d", "filename": "tests/ui/cast_alignment.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9fd1cdeada90df39a65249c767e3e726d7df6bd9/tests%2Fui%2Fcast_alignment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fd1cdeada90df39a65249c767e3e726d7df6bd9/tests%2Fui%2Fcast_alignment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcast_alignment.stderr?ref=9fd1cdeada90df39a65249c767e3e726d7df6bd9", "patch": "@@ -1,25 +1,25 @@\n error: casting from `*const u8` to a more-strictly-aligned pointer (`*const u16`) (1 < 2 bytes)\n-  --> $DIR/cast_alignment.rs:18:5\n+  --> $DIR/cast_alignment.rs:19:5\n    |\n LL |     (&1u8 as *const u8) as *const u16;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::cast-ptr-alignment` implied by `-D warnings`\n \n error: casting from `*mut u8` to a more-strictly-aligned pointer (`*mut u16`) (1 < 2 bytes)\n-  --> $DIR/cast_alignment.rs:19:5\n+  --> $DIR/cast_alignment.rs:20:5\n    |\n LL |     (&mut 1u8 as *mut u8) as *mut u16;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: casting from `*const u8` to a more-strictly-aligned pointer (`*const u16`) (1 < 2 bytes)\n-  --> $DIR/cast_alignment.rs:22:5\n+  --> $DIR/cast_alignment.rs:23:5\n    |\n LL |     (&1u8 as *const u8).cast::<u16>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: casting from `*mut u8` to a more-strictly-aligned pointer (`*mut u16`) (1 < 2 bytes)\n-  --> $DIR/cast_alignment.rs:23:5\n+  --> $DIR/cast_alignment.rs:24:5\n    |\n LL |     (&mut 1u8 as *mut u8).cast::<u16>();\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}]}