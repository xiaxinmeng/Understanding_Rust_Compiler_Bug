{"sha": "eb7e9dce4d58953d832b33897afd07307997fc51", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViN2U5ZGNlNGQ1ODk1M2Q4MzJiMzM4OTdhZmQwNzMwNzk5N2ZjNTE=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-08T21:26:58Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-08-08T21:33:06Z"}, "message": "rt: Stub the shape-based cmp upcall", "tree": {"sha": "cf6015a274cb77eef6e2345aaab1250e37c86d29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf6015a274cb77eef6e2345aaab1250e37c86d29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb7e9dce4d58953d832b33897afd07307997fc51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb7e9dce4d58953d832b33897afd07307997fc51", "html_url": "https://github.com/rust-lang/rust/commit/eb7e9dce4d58953d832b33897afd07307997fc51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb7e9dce4d58953d832b33897afd07307997fc51/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d4a4224d1b08e306a2abc0db5e1408456f9f5e66", "url": "https://api.github.com/repos/rust-lang/rust/commits/d4a4224d1b08e306a2abc0db5e1408456f9f5e66", "html_url": "https://github.com/rust-lang/rust/commit/d4a4224d1b08e306a2abc0db5e1408456f9f5e66"}], "stats": {"total": 130, "additions": 121, "deletions": 9}, "files": [{"sha": "daa649cc621377a44dca7688b2af794b141f1e60", "filename": "src/rt/rust_shape.cpp", "status": "modified", "additions": 120, "deletions": 9, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/eb7e9dce4d58953d832b33897afd07307997fc51/src%2Frt%2Frust_shape.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/eb7e9dce4d58953d832b33897afd07307997fc51/src%2Frt%2Frust_shape.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_shape.cpp?ref=eb7e9dce4d58953d832b33897afd07307997fc51", "patch": "@@ -69,7 +69,7 @@ const uint8_t CMP_LE = 2u;\n // of two.\n template<typename T>\n static inline T\n-round_up(T size, size_t alignment) {\n+align_to(T size, size_t alignment) {\n     assert(alignment);\n     T x = (T)(((uintptr_t)size + alignment - 1) & ~(alignment - 1));\n     return x;\n@@ -133,10 +133,17 @@ struct tag_info {\n     const type_param *params;               // Array of type parameters.\n };\n \n+\n+// Pointer pairs for structural comparison\n+\n template<typename T>\n class data_pair {\n public:\n     T fst, snd;\n+\n+    data_pair() {}\n+    data_pair(T &in_fst, T &in_snd) : fst(in_fst), snd(in_snd) {}\n+\n     inline void operator=(const T rhs) { fst = snd = rhs; }\n };\n \n@@ -145,7 +152,7 @@ class ptr_pair {\n     uint8_t *fst, *snd;\n \n     template<typename T>\n-    class data { typedef data_pair<T> t; };\n+    struct data { typedef data_pair<T> t; };\n \n     ptr_pair(uint8_t *in_fst, uint8_t *in_snd) : fst(in_fst), snd(in_snd) {}\n \n@@ -155,12 +162,36 @@ class ptr_pair {\n         return make(fst + n, snd + n);\n     }\n \n+    inline ptr_pair operator+=(size_t n) {\n+        fst += n; snd += n;\n+        return *this;\n+    }\n+\n+    inline ptr_pair operator-(size_t n) const {\n+        return make(fst - n, snd - n);\n+    }\n+\n     static inline ptr_pair make(uint8_t *fst, uint8_t *snd) {\n         ptr_pair self(fst, snd);\n         return self;\n     }\n };\n \n+inline ptr_pair\n+align_to(const ptr_pair const &pair, size_t n) {\n+    return ptr_pair::make(align_to(pair.fst, n), align_to(pair.snd, n));\n+}\n+\n+// NB: This function does not align.\n+template<typename T>\n+inline data_pair<T>\n+bump_dp(ptr_pair &ptr) {\n+    data_pair<T> data(*reinterpret_cast<T *>(ptr.fst),\n+                      *reinterpret_cast<T *>(ptr.snd));\n+    ptr += sizeof(T);\n+    return data;\n+}\n+\n \n // Contexts\n \n@@ -174,6 +205,12 @@ class ctxt {\n     const rust_shape_tables *tables;\n     rust_task *task;\n \n+    ctxt(rust_task *in_task,\n+         const uint8_t *in_sp,\n+         const type_param *in_params,\n+         const rust_shape_tables *in_tables)\n+    : sp(in_sp), params(in_params), tables(in_tables), task(in_task) {}\n+\n     template<typename U>\n     ctxt(const ctxt<U> &other,\n          const uint8_t *in_sp = NULL,\n@@ -665,7 +702,7 @@ class size_of : public ctxt<size_of> {\n \n     template<typename T>\n     static size_align get(const ctxt<T> &other_cx, unsigned back_up = 0) {\n-        size_of cx(other_cx, other_cx->sp - back_up);\n+        size_of cx(other_cx, other_cx.sp - back_up);\n         cx.walk(false);\n         assert(cx.sa.alignment > 0);\n         return cx.sa;\n@@ -696,7 +733,7 @@ size_of::compute_tag_size(tag_info &tinfo) {\n         bool first = true;\n         while (sub.sp != variant_end) {\n             if (!first)\n-                variant_sa.size = round_up(variant_sa.size, sub.sa.alignment);\n+                variant_sa.size = align_to(variant_sa.size, sub.sa.alignment);\n             sub.walk(!first);\n             first = false;\n \n@@ -729,7 +766,7 @@ size_of::walk_struct(bool align, const uint8_t *end_sp) {\n     bool first = true;\n     while (sp != end_sp) {\n         if (!first)\n-            struct_sa.size = round_up(struct_sa.size, sa.alignment);\n+            struct_sa.size = align_to(struct_sa.size, sa.alignment);\n         walk(!first);\n         first = false;\n \n@@ -764,6 +801,13 @@ class data : public ctxt< data<T,U> > {\n public:\n     U dp;\n \n+    data(rust_task *in_task,\n+         const uint8_t *in_sp,\n+         const type_param *in_params,\n+         const rust_shape_tables *in_tables,\n+         U const &in_dp)\n+    : ctxt< data<T,U> >(in_task, in_sp, in_params, in_tables), dp(in_dp) {}\n+\n     void walk_tag(bool align, tag_info &tinfo);\n     void walk_ivec(bool align, bool is_pod, size_align &elem_sa);\n \n@@ -796,12 +840,19 @@ class data : public ctxt< data<T,U> > {\n         dp += sizeof(void *) * 2;\n     }\n \n+    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n+                  const uint8_t *ty_params_sp) {\n+        // Delegate to the implementation.\n+        static_cast<T *>(this)->walk_res(align, dtor, n_ty_params,\n+                                         ty_params_sp);\n+    }\n+\n     void walk_var(bool align, uint8_t param_index) {\n         static_cast<T *>(this)->walk_var(align, param_index);\n     }\n \n     template<typename W>\n-    void walk_number(bool align) { DATA_SIMPLE(W, walk_number<W>(align)); }\n+    void walk_number(bool align) { DATA_SIMPLE(W, walk_number<W>()); }\n };\n \n template<typename T,typename U>\n@@ -825,12 +876,12 @@ data<T,U>::walk_ivec(bool align, bool is_pod, size_align &elem_sa) {\n template<typename T,typename U>\n void\n data<T,U>::walk_tag(bool align, tag_info &tinfo) {\n-    size_of::compute_tag_size(tinfo);\n+    size_of::compute_tag_size(*this, tinfo);\n \n     if (tinfo.variant_count > 1 && align)\n         dp = align_to(dp, ALIGNOF(uint32_t));\n \n-    U end_dp = tinfo.tag_sa.size;\n+    U end_dp = dp + tinfo.tag_sa.size;\n \n     typename U::template data<uint32_t>::t tag_variant;\n     if (tinfo.variant_count > 1)\n@@ -846,7 +897,7 @@ data<T,U>::walk_tag(bool align, tag_info &tinfo) {\n \n #if 0\n \n-class copy : public data<copy> {\n+class copy : public data<copy,uint8_t *> {\n     // TODO\n };\n \n@@ -856,7 +907,67 @@ class copy : public data<copy> {\n // Structural comparison glue.\n \n class cmp : public data<cmp,ptr_pair> {\n+private:\n+    template<typename T>\n+    int cmp_number(ptr_pair &ptrs);\n+\n+public:\n+    int result;\n+\n+    cmp(rust_task *in_task,\n+        const uint8_t *in_sp,\n+        const type_param *in_params,\n+        const rust_shape_tables *in_tables,\n+        uint8_t *in_data_0,\n+        uint8_t *in_data_1)\n+    : data<cmp,ptr_pair>(in_task, in_sp, in_params, in_tables,\n+                         ptr_pair::make(in_data_0, in_data_1)) {}\n+\n+    void walk_tag(bool align, tag_info &tinfo,\n+                  data_pair<uint32_t> &tag_variants);\n+    void walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n+                  const uint8_t *ty_params_sp);\n+\n+    template<typename T>\n+    void walk_number() { result = cmp_number<T>(dp); }\n };\n \n+void\n+cmp::walk_tag(bool align, tag_info &tinfo,\n+              data_pair<uint32_t> &tag_variants) {\n+    abort();    // TODO\n+}\n+\n+void\n+cmp::walk_res(bool align, const rust_fn *dtor, uint16_t n_ty_params,\n+              const uint8_t *ty_params_sp) {\n+    abort();    // TODO\n+}\n+\n+template<typename T>\n+int\n+cmp::cmp_number(ptr_pair &ptrs) {\n+    T a = *(reinterpret_cast<T *>(dp.fst));\n+    T b = *(reinterpret_cast<T *>(dp.snd));\n+    return (a < b) ? -1 : (a == b) ? 0 : 1;\n+}\n+\n } // end namespace shape\n \n+extern \"C\" void\n+upcall_cmp_type(int8_t *result, rust_task *task, type_desc *tydesc,\n+                const type_desc **subtydescs, uint8_t *data_0,\n+                uint8_t *data_1, uint8_t cmp_type) {\n+    shape::arena arena;\n+    shape::type_param *params = shape::type_param::make(tydesc, arena);\n+    shape::cmp cmp(task, tydesc->shape, params, tydesc->shape_tables, data_0,\n+                   data_1);\n+    cmp.walk(true);\n+\n+    switch (cmp_type) {\n+    case shape::CMP_EQ: *result = cmp.result == 0;  break;\n+    case shape::CMP_LT: *result = cmp.result < 0;   break;\n+    case shape::CMP_LE: *result = cmp.result <= 0;  break;\n+    }\n+}\n+"}, {"sha": "a51d533dcd1c1c2b1922e7cd7ce1460084d92027", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/eb7e9dce4d58953d832b33897afd07307997fc51/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/eb7e9dce4d58953d832b33897afd07307997fc51/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=eb7e9dce4d58953d832b33897afd07307997fc51", "patch": "@@ -77,6 +77,7 @@ unsafe_vec_to_mut\n unsupervise\n upcall_chan_target_task\n upcall_clone_chan\n+upcall_cmp_type\n upcall_del_chan\n upcall_del_port\n upcall_drop_chan"}]}