{"sha": "2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkOWRmYzY0NzkyZDE0YmE0NmIzNDViN2U3ZjI5MTNjNmE5YjI4Y2E=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-04-18T16:15:09Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2014-04-19T00:44:08Z"}, "message": "Reorder Float methods in trait definition and make consistent in impls", "tree": {"sha": "929e42fd16354934387c4ef115500760bf9b2436", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/929e42fd16354934387c4ef115500760bf9b2436"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca", "html_url": "https://github.com/rust-lang/rust/commit/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42450ef02231f60f7ed41d78d04968b78f155404", "url": "https://api.github.com/repos/rust-lang/rust/commits/42450ef02231f60f7ed41d78d04968b78f155404", "html_url": "https://github.com/rust-lang/rust/commit/42450ef02231f60f7ed41d78d04968b78f155404"}], "stats": {"total": 561, "additions": 268, "deletions": 293}, "files": [{"sha": "5da03898f05d4f084b33c837f6a97163a6cfacb3", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 105, "deletions": 100, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca", "patch": "@@ -218,8 +218,9 @@ impl Signed for f32 {\n         unsafe { intrinsics::fabsf32(*self) }\n     }\n \n-    /// The positive difference of two numbers. Returns `0.0` if the number is less than or\n-    /// equal to `other`, otherwise the difference between`self` and `other` is returned.\n+    /// The positive difference of two numbers. Returns `0.0` if the number is\n+    /// less than or equal to `other`, otherwise the difference between`self`\n+    /// and `other` is returned.\n     #[inline]\n     fn abs_sub(&self, other: &f32) -> f32 {\n         unsafe { cmath::fdimf(*self, *other) }\n@@ -257,20 +258,6 @@ impl Bounded for f32 {\n impl Primitive for f32 {}\n \n impl Float for f32 {\n-    fn powi(self, n: i32) -> f32 {\n-        unsafe { intrinsics::powif32(self, n) }\n-    }\n-\n-    #[inline]\n-    fn max(self, other: f32) -> f32 {\n-        unsafe { cmath::fmaxf(self, other) }\n-    }\n-\n-    #[inline]\n-    fn min(self, other: f32) -> f32 {\n-        unsafe { cmath::fminf(self, other) }\n-    }\n-\n     #[inline]\n     fn nan() -> f32 { 0.0 / 0.0 }\n \n@@ -305,8 +292,9 @@ impl Float for f32 {\n         self.classify() == FPNormal\n     }\n \n-    /// Returns the floating point category of the number. If only one property is going to\n-    /// be tested, it is generally faster to use the specific predicate instead.\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n     fn classify(self) -> FPCategory {\n         static EXP_MASK: u32 = 0x7f800000;\n         static MAN_MASK: u32 = 0x007fffff;\n@@ -342,13 +330,15 @@ impl Float for f32 {\n     #[inline]\n     fn max_10_exp(_: Option<f32>) -> int { 38 }\n \n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n+    /// Constructs a floating point number by multiplying `x` by 2 raised to the\n+    /// power of `exp`\n     #[inline]\n     fn ldexp(x: f32, exp: int) -> f32 {\n         unsafe { cmath::ldexpf(x, exp as c_int) }\n     }\n \n-    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    /// Breaks the number into a normalized fraction and a base-2 exponent,\n+    /// satisfying:\n     ///\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n@@ -361,34 +351,6 @@ impl Float for f32 {\n         }\n     }\n \n-    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n-    /// even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(self) -> f32 {\n-        unsafe { cmath::expm1f(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n-    /// than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(self) -> f32 {\n-        unsafe { cmath::log1pf(self) }\n-    }\n-\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n-    /// produces a more accurate result with better performance than a separate multiplication\n-    /// operation followed by an add.\n-    #[inline]\n-    fn mul_add(self, a: f32, b: f32) -> f32 {\n-        unsafe { intrinsics::fmaf32(self, a, b) }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline]\n-    fn next_after(self, other: f32) -> f32 {\n-        unsafe { cmath::nextafterf(self, other) }\n-    }\n-\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u32 = unsafe { cast::transmute(self) };\n@@ -404,6 +366,13 @@ impl Float for f32 {\n         (mantissa as u64, exponent, sign)\n     }\n \n+    /// Returns the next representable floating-point value in the direction of\n+    /// `other`.\n+    #[inline]\n+    fn next_after(self, other: f32) -> f32 {\n+        unsafe { cmath::nextafterf(self, other) }\n+    }\n+\n     /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n     fn floor(self) -> f32 {\n@@ -437,100 +406,102 @@ impl Float for f32 {\n     #[inline]\n     fn fract(self) -> f32 { self - self.trunc() }\n \n-    /// Archimedes' constant\n-    #[inline]\n-    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n-\n-    /// 2.0 * pi\n     #[inline]\n-    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n+    fn max(self, other: f32) -> f32 {\n+        unsafe { cmath::fmaxf(self, other) }\n+    }\n \n-    /// pi / 2.0\n     #[inline]\n-    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n+    fn min(self, other: f32) -> f32 {\n+        unsafe { cmath::fminf(self, other) }\n+    }\n \n-    /// pi / 3.0\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n     #[inline]\n-    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n+    fn mul_add(self, a: f32, b: f32) -> f32 {\n+        unsafe { intrinsics::fmaf32(self, a, b) }\n+    }\n \n-    /// pi / 4.0\n+    /// The reciprocal (multiplicative inverse) of the number\n     #[inline]\n-    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n+    fn recip(self) -> f32 { 1.0 / self }\n \n-    /// pi / 6.0\n-    #[inline]\n-    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n+    fn powi(self, n: i32) -> f32 {\n+        unsafe { intrinsics::powif32(self, n) }\n+    }\n \n-    /// pi / 8.0\n     #[inline]\n-    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n+    fn powf(self, n: f32) -> f32 {\n+        unsafe { intrinsics::powf32(self, n) }\n+    }\n \n-    /// 1 .0/ pi\n+    /// sqrt(2.0)\n     #[inline]\n-    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n+    fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n \n-    /// 2.0 / pi\n+    /// 1.0 / sqrt(2.0)\n     #[inline]\n-    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n+    fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n \n-    /// 2.0 / sqrt(pi)\n     #[inline]\n-    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n+    fn sqrt(self) -> f32 {\n+        unsafe { intrinsics::sqrtf32(self) }\n+    }\n \n-    /// sqrt(2.0)\n     #[inline]\n-    fn sqrt2() -> f32 { 1.41421356237309504880168872420969808 }\n+    fn rsqrt(self) -> f32 { self.sqrt().recip() }\n \n-    /// 1.0 / sqrt(2.0)\n     #[inline]\n-    fn frac_1_sqrt2() -> f32 { 0.707106781186547524400844362104849039 }\n+    fn cbrt(self) -> f32 {\n+        unsafe { cmath::cbrtf(self) }\n+    }\n \n-    /// Euler's number\n     #[inline]\n-    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n+    fn hypot(self, other: f32) -> f32 {\n+        unsafe { cmath::hypotf(self, other) }\n+    }\n \n-    /// log2(e)\n+    /// Archimedes' constant\n     #[inline]\n-    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n+    fn pi() -> f32 { 3.14159265358979323846264338327950288 }\n \n-    /// log10(e)\n+    /// 2.0 * pi\n     #[inline]\n-    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n+    fn two_pi() -> f32 { 6.28318530717958647692528676655900576 }\n \n-    /// ln(2.0)\n+    /// pi / 2.0\n     #[inline]\n-    fn ln_2() -> f32 { 0.693147180559945309417232121458176568 }\n+    fn frac_pi_2() -> f32 { 1.57079632679489661923132169163975144 }\n \n-    /// ln(10.0)\n+    /// pi / 3.0\n     #[inline]\n-    fn ln_10() -> f32 { 2.30258509299404568401799145468436421 }\n+    fn frac_pi_3() -> f32 { 1.04719755119659774615421446109316763 }\n \n-    /// The reciprocal (multiplicative inverse) of the number\n+    /// pi / 4.0\n     #[inline]\n-    fn recip(self) -> f32 { 1.0 / self }\n+    fn frac_pi_4() -> f32 { 0.785398163397448309615660845819875721 }\n \n+    /// pi / 6.0\n     #[inline]\n-    fn powf(self, n: f32) -> f32 {\n-        unsafe { intrinsics::powf32(self, n) }\n-    }\n+    fn frac_pi_6() -> f32 { 0.52359877559829887307710723054658381 }\n \n+    /// pi / 8.0\n     #[inline]\n-    fn sqrt(self) -> f32 {\n-        unsafe { intrinsics::sqrtf32(self) }\n-    }\n+    fn frac_pi_8() -> f32 { 0.39269908169872415480783042290993786 }\n \n+    /// 1 .0/ pi\n     #[inline]\n-    fn rsqrt(self) -> f32 { self.sqrt().recip() }\n+    fn frac_1_pi() -> f32 { 0.318309886183790671537767526745028724 }\n \n+    /// 2.0 / pi\n     #[inline]\n-    fn cbrt(self) -> f32 {\n-        unsafe { cmath::cbrtf(self) }\n-    }\n+    fn frac_2_pi() -> f32 { 0.636619772367581343075535053490057448 }\n \n+    /// 2.0 / sqrt(pi)\n     #[inline]\n-    fn hypot(self, other: f32) -> f32 {\n-        unsafe { cmath::hypotf(self, other) }\n-    }\n+    fn frac_2_sqrtpi() -> f32 { 1.12837916709551257389615890312154517 }\n \n     #[inline]\n     fn sin(self) -> f32 {\n@@ -573,6 +544,26 @@ impl Float for f32 {\n         (self.sin(), self.cos())\n     }\n \n+    /// Euler's number\n+    #[inline]\n+    fn e() -> f32 { 2.71828182845904523536028747135266250 }\n+\n+    /// log2(e)\n+    #[inline]\n+    fn log2_e() -> f32 { 1.44269504088896340735992468100189214 }\n+\n+    /// log10(e)\n+    #[inline]\n+    fn log10_e() -> f32 { 0.434294481903251827651128918916605082 }\n+\n+    /// ln(2.0)\n+    #[inline]\n+    fn ln_2() -> f32 { 0.693147180559945309417232121458176568 }\n+\n+    /// ln(10.0)\n+    #[inline]\n+    fn ln_10() -> f32 { 2.30258509299404568401799145468436421 }\n+\n     /// Returns the exponential of the number\n     #[inline]\n     fn exp(self) -> f32 {\n@@ -585,6 +576,13 @@ impl Float for f32 {\n         unsafe { intrinsics::exp2f32(self) }\n     }\n \n+    /// Returns the exponential of the number, minus `1`, in a way that is\n+    /// accurate even if the number is close to zero\n+    #[inline]\n+    fn exp_m1(self) -> f32 {\n+        unsafe { cmath::expm1f(self) }\n+    }\n+\n     /// Returns the natural logarithm of the number\n     #[inline]\n     fn ln(self) -> f32 {\n@@ -607,6 +605,13 @@ impl Float for f32 {\n         unsafe { intrinsics::log10f32(self) }\n     }\n \n+    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n+    /// accurately than if the operations were performed separately\n+    #[inline]\n+    fn ln_1p(self) -> f32 {\n+        unsafe { cmath::log1pf(self) }\n+    }\n+\n     #[inline]\n     fn sinh(self) -> f32 {\n         unsafe { cmath::sinhf(self) }"}, {"sha": "a2b63968569b4d0c76be575b8528ba7888a62380", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 102, "deletions": 98, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca", "patch": "@@ -265,16 +265,6 @@ impl Bounded for f64 {\n impl Primitive for f64 {}\n \n impl Float for f64 {\n-    #[inline]\n-    fn max(self, other: f64) -> f64 {\n-        unsafe { cmath::fmax(self, other) }\n-    }\n-\n-    #[inline]\n-    fn min(self, other: f64) -> f64 {\n-        unsafe { cmath::fmin(self, other) }\n-    }\n-\n     #[inline]\n     fn nan() -> f64 { 0.0 / 0.0 }\n \n@@ -309,8 +299,9 @@ impl Float for f64 {\n         self.classify() == FPNormal\n     }\n \n-    /// Returns the floating point category of the number. If only one property is going to\n-    /// be tested, it is generally faster to use the specific predicate instead.\n+    /// Returns the floating point category of the number. If only one property\n+    /// is going to be tested, it is generally faster to use the specific\n+    /// predicate instead.\n     fn classify(self) -> FPCategory {\n         static EXP_MASK: u64 = 0x7ff0000000000000;\n         static MAN_MASK: u64 = 0x000fffffffffffff;\n@@ -346,13 +337,15 @@ impl Float for f64 {\n     #[inline]\n     fn max_10_exp(_: Option<f64>) -> int { 308 }\n \n-    /// Constructs a floating point number by multiplying `x` by 2 raised to the power of `exp`\n+    /// Constructs a floating point number by multiplying `x` by 2 raised to the\n+    /// power of `exp`\n     #[inline]\n     fn ldexp(x: f64, exp: int) -> f64 {\n         unsafe { cmath::ldexp(x, exp as c_int) }\n     }\n \n-    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    /// Breaks the number into a normalized fraction and a base-2 exponent,\n+    /// satisfying:\n     ///\n     /// - `self = x * pow(2, exp)`\n     /// - `0.5 <= abs(x) < 1.0`\n@@ -365,34 +358,6 @@ impl Float for f64 {\n         }\n     }\n \n-    /// Returns the exponential of the number, minus `1`, in a way that is accurate\n-    /// even if the number is close to zero\n-    #[inline]\n-    fn exp_m1(self) -> f64 {\n-        unsafe { cmath::expm1(self) }\n-    }\n-\n-    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more accurately\n-    /// than if the operations were performed separately\n-    #[inline]\n-    fn ln_1p(self) -> f64 {\n-        unsafe { cmath::log1p(self) }\n-    }\n-\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This\n-    /// produces a more accurate result with better performance than a separate multiplication\n-    /// operation followed by an add.\n-    #[inline]\n-    fn mul_add(self, a: f64, b: f64) -> f64 {\n-        unsafe { intrinsics::fmaf64(self, a, b) }\n-    }\n-\n-    /// Returns the next representable floating-point value in the direction of `other`\n-    #[inline]\n-    fn next_after(self, other: f64) -> f64 {\n-        unsafe { cmath::nextafter(self, other) }\n-    }\n-\n     /// Returns the mantissa, exponent and sign as integers.\n     fn integer_decode(self) -> (u64, i16, i8) {\n         let bits: u64 = unsafe { cast::transmute(self) };\n@@ -408,6 +373,13 @@ impl Float for f64 {\n         (mantissa, exponent, sign)\n     }\n \n+    /// Returns the next representable floating-point value in the direction of\n+    /// `other`.\n+    #[inline]\n+    fn next_after(self, other: f64) -> f64 {\n+        unsafe { cmath::nextafter(self, other) }\n+    }\n+\n     /// Round half-way cases toward `NEG_INFINITY`\n     #[inline]\n     fn floor(self) -> f64 {\n@@ -441,45 +413,37 @@ impl Float for f64 {\n     #[inline]\n     fn fract(self) -> f64 { self - self.trunc() }\n \n-    /// Archimedes' constant\n-    #[inline]\n-    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n-\n-    /// 2.0 * pi\n-    #[inline]\n-    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n-\n-    /// pi / 2.0\n-    #[inline]\n-    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n-\n-    /// pi / 3.0\n     #[inline]\n-    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n-\n-    /// pi / 4.0\n-    #[inline]\n-    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n+    fn max(self, other: f64) -> f64 {\n+        unsafe { cmath::fmax(self, other) }\n+    }\n \n-    /// pi / 6.0\n     #[inline]\n-    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n+    fn min(self, other: f64) -> f64 {\n+        unsafe { cmath::fmin(self, other) }\n+    }\n \n-    /// pi / 8.0\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n     #[inline]\n-    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n+    fn mul_add(self, a: f64, b: f64) -> f64 {\n+        unsafe { intrinsics::fmaf64(self, a, b) }\n+    }\n \n-    /// 1.0 / pi\n+    /// The reciprocal (multiplicative inverse) of the number\n     #[inline]\n-    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n+    fn recip(self) -> f64 { 1.0 / self }\n \n-    /// 2.0 / pi\n     #[inline]\n-    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n+    fn powf(self, n: f64) -> f64 {\n+        unsafe { intrinsics::powf64(self, n) }\n+    }\n \n-    /// 2.0 / sqrt(pi)\n     #[inline]\n-    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n+    fn powi(self, n: i32) -> f64 {\n+        unsafe { intrinsics::powif64(self, n) }\n+    }\n \n     /// sqrt(2.0)\n     #[inline]\n@@ -489,57 +453,63 @@ impl Float for f64 {\n     #[inline]\n     fn frac_1_sqrt2() -> f64 { 0.707106781186547524400844362104849039 }\n \n-    /// Euler's number\n     #[inline]\n-    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n+    fn sqrt(self) -> f64 {\n+        unsafe { intrinsics::sqrtf64(self) }\n+    }\n \n-    /// log2(e)\n     #[inline]\n-    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n+    fn rsqrt(self) -> f64 { self.sqrt().recip() }\n \n-    /// log10(e)\n     #[inline]\n-    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n+    fn cbrt(self) -> f64 {\n+        unsafe { cmath::cbrt(self) }\n+    }\n \n-    /// ln(2.0)\n     #[inline]\n-    fn ln_2() -> f64 { 0.693147180559945309417232121458176568 }\n+    fn hypot(self, other: f64) -> f64 {\n+        unsafe { cmath::hypot(self, other) }\n+    }\n \n-    /// ln(10.0)\n+    /// Archimedes' constant\n     #[inline]\n-    fn ln_10() -> f64 { 2.30258509299404568401799145468436421 }\n+    fn pi() -> f64 { 3.14159265358979323846264338327950288 }\n \n-    /// The reciprocal (multiplicative inverse) of the number\n+    /// 2.0 * pi\n     #[inline]\n-    fn recip(self) -> f64 { 1.0 / self }\n+    fn two_pi() -> f64 { 6.28318530717958647692528676655900576 }\n \n+    /// pi / 2.0\n     #[inline]\n-    fn powf(self, n: f64) -> f64 {\n-        unsafe { intrinsics::powf64(self, n) }\n-    }\n+    fn frac_pi_2() -> f64 { 1.57079632679489661923132169163975144 }\n \n+    /// pi / 3.0\n     #[inline]\n-    fn powi(self, n: i32) -> f64 {\n-        unsafe { intrinsics::powif64(self, n) }\n-    }\n+    fn frac_pi_3() -> f64 { 1.04719755119659774615421446109316763 }\n \n+    /// pi / 4.0\n     #[inline]\n-    fn sqrt(self) -> f64 {\n-        unsafe { intrinsics::sqrtf64(self) }\n-    }\n+    fn frac_pi_4() -> f64 { 0.785398163397448309615660845819875721 }\n \n+    /// pi / 6.0\n     #[inline]\n-    fn rsqrt(self) -> f64 { self.sqrt().recip() }\n+    fn frac_pi_6() -> f64 { 0.52359877559829887307710723054658381 }\n \n+    /// pi / 8.0\n     #[inline]\n-    fn cbrt(self) -> f64 {\n-        unsafe { cmath::cbrt(self) }\n-    }\n+    fn frac_pi_8() -> f64 { 0.39269908169872415480783042290993786 }\n \n+    /// 1.0 / pi\n     #[inline]\n-    fn hypot(self, other: f64) -> f64 {\n-        unsafe { cmath::hypot(self, other) }\n-    }\n+    fn frac_1_pi() -> f64 { 0.318309886183790671537767526745028724 }\n+\n+    /// 2.0 / pi\n+    #[inline]\n+    fn frac_2_pi() -> f64 { 0.636619772367581343075535053490057448 }\n+\n+    /// 2.0 / sqrt(pi)\n+    #[inline]\n+    fn frac_2_sqrtpi() -> f64 { 1.12837916709551257389615890312154517 }\n \n     #[inline]\n     fn sin(self) -> f64 {\n@@ -582,6 +552,26 @@ impl Float for f64 {\n         (self.sin(), self.cos())\n     }\n \n+    /// Euler's number\n+    #[inline]\n+    fn e() -> f64 { 2.71828182845904523536028747135266250 }\n+\n+    /// log2(e)\n+    #[inline]\n+    fn log2_e() -> f64 { 1.44269504088896340735992468100189214 }\n+\n+    /// log10(e)\n+    #[inline]\n+    fn log10_e() -> f64 { 0.434294481903251827651128918916605082 }\n+\n+    /// ln(2.0)\n+    #[inline]\n+    fn ln_2() -> f64 { 0.693147180559945309417232121458176568 }\n+\n+    /// ln(10.0)\n+    #[inline]\n+    fn ln_10() -> f64 { 2.30258509299404568401799145468436421 }\n+\n     /// Returns the exponential of the number\n     #[inline]\n     fn exp(self) -> f64 {\n@@ -594,6 +584,13 @@ impl Float for f64 {\n         unsafe { intrinsics::exp2f64(self) }\n     }\n \n+    /// Returns the exponential of the number, minus `1`, in a way that is\n+    /// accurate even if the number is close to zero\n+    #[inline]\n+    fn exp_m1(self) -> f64 {\n+        unsafe { cmath::expm1(self) }\n+    }\n+\n     /// Returns the natural logarithm of the number\n     #[inline]\n     fn ln(self) -> f64 {\n@@ -616,6 +613,13 @@ impl Float for f64 {\n         unsafe { intrinsics::log10f64(self) }\n     }\n \n+    /// Returns the natural logarithm of the number plus `1` (`ln(1+n)`) more\n+    /// accurately than if the operations were performed separately\n+    #[inline]\n+    fn ln_1p(self) -> f64 {\n+        unsafe { cmath::log1p(self) }\n+    }\n+\n     #[inline]\n     fn sinh(self) -> f64 {\n         unsafe { cmath::sinh(self) }"}, {"sha": "75cf02034b9920ebbd078487e88c7ba7d2c82c71", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 61, "deletions": 95, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=2d9dfc64792d14ba46b345b7e7f2913c6a9b28ca", "patch": "@@ -329,177 +329,126 @@ pub enum FPCategory {\n // FIXME(#8888): Several of these functions have a parameter named\n //               `unused_self`. Removing it requires #8888 to be fixed.\n pub trait Float: Signed + Primitive {\n-    /// Returns the maximum of the two numbers.\n-    fn max(self, other: Self) -> Self;\n-    /// Returns the minimum of the two numbers.\n-    fn min(self, other: Self) -> Self;\n-\n     /// Returns the NaN value.\n     fn nan() -> Self;\n-\n     /// Returns the infinite value.\n     fn infinity() -> Self;\n-\n     /// Returns the negative infinite value.\n     fn neg_infinity() -> Self;\n-\n     /// Returns -0.0.\n     fn neg_zero() -> Self;\n \n     /// Returns true if this value is NaN and false otherwise.\n     fn is_nan(self) -> bool;\n-\n-    /// Returns true if this value is positive infinity or negative infinity and false otherwise.\n+    /// Returns true if this value is positive infinity or negative infinity and\n+    /// false otherwise.\n     fn is_infinite(self) -> bool;\n-\n     /// Returns true if this number is neither infinite nor NaN.\n     fn is_finite(self) -> bool;\n-\n     /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n     fn is_normal(self) -> bool;\n-\n     /// Returns the category that this number falls into.\n     fn classify(self) -> FPCategory;\n \n     /// Returns the number of binary digits of mantissa that this type supports.\n     fn mantissa_digits(unused_self: Option<Self>) -> uint;\n-\n     /// Returns the number of binary digits of exponent that this type supports.\n     fn digits(unused_self: Option<Self>) -> uint;\n-\n     /// Returns the smallest positive number that this type can represent.\n     fn epsilon() -> Self;\n-\n     /// Returns the minimum binary exponent that this type can represent.\n     fn min_exp(unused_self: Option<Self>) -> int;\n-\n     /// Returns the maximum binary exponent that this type can represent.\n     fn max_exp(unused_self: Option<Self>) -> int;\n-\n     /// Returns the minimum base-10 exponent that this type can represent.\n     fn min_10_exp(unused_self: Option<Self>) -> int;\n-\n     /// Returns the maximum base-10 exponent that this type can represent.\n     fn max_10_exp(unused_self: Option<Self>) -> int;\n \n-    /// Constructs a floating point number created by multiplying `x` by 2 raised to the power of\n-    /// `exp`.\n+    /// Constructs a floating point number created by multiplying `x` by 2\n+    /// raised to the power of `exp`.\n     fn ldexp(x: Self, exp: int) -> Self;\n-\n-    /// Breaks the number into a normalized fraction and a base-2 exponent, satisfying:\n+    /// Breaks the number into a normalized fraction and a base-2 exponent,\n+    /// satisfying:\n     ///\n     ///  * `self = x * pow(2, exp)`\n     ///\n     ///  * `0.5 <= abs(x) < 1.0`\n     fn frexp(self) -> (Self, int);\n-\n-    /// Returns the exponential of the number, minus 1, in a way that is accurate even if the\n-    /// number is close to zero.\n-    fn exp_m1(self) -> Self;\n-\n-    /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more accurately than if the\n-    /// operations were performed separately.\n-    fn ln_1p(self) -> Self;\n-\n-    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding error. This produces a\n-    /// more accurate result with better performance than a separate multiplication operation\n-    /// followed by an add.\n-    fn mul_add(self, a: Self, b: Self) -> Self;\n-\n-    /// Returns the next representable floating-point value in the direction of `other`.\n-    fn next_after(self, other: Self) -> Self;\n-\n     /// Returns the mantissa, exponent and sign as integers, respectively.\n     fn integer_decode(self) -> (u64, i16, i8);\n \n+    /// Returns the next representable floating-point value in the direction of\n+    /// `other`.\n+    fn next_after(self, other: Self) -> Self;\n+\n     /// Return the largest integer less than or equal to a number.\n     fn floor(self) -> Self;\n-\n     /// Return the smallest integer greater than or equal to a number.\n     fn ceil(self) -> Self;\n-\n     /// Return the nearest integer to a number. Round half-way cases away from\n     /// `0.0`.\n     fn round(self) -> Self;\n-\n     /// Return the integer part of a number.\n     fn trunc(self) -> Self;\n-\n     /// Return the fractional part of a number.\n     fn fract(self) -> Self;\n \n+    /// Returns the maximum of the two numbers.\n+    fn max(self, other: Self) -> Self;\n+    /// Returns the minimum of the two numbers.\n+    fn min(self, other: Self) -> Self;\n+\n+    /// Fused multiply-add. Computes `(self * a) + b` with only one rounding\n+    /// error. This produces a more accurate result with better performance than\n+    /// a separate multiplication operation followed by an add.\n+    fn mul_add(self, a: Self, b: Self) -> Self;\n+    /// Take the reciprocal (inverse) of a number, `1/x`.\n+    fn recip(self) -> Self;\n+\n+    /// Raise a number to an integer power.\n+    ///\n+    /// Using this function is generally faster than using `powf`\n+    fn powi(self, n: i32) -> Self;\n+    /// Raise a number to a floating point power.\n+    fn powf(self, n: Self) -> Self;\n+\n+    /// sqrt(2.0).\n+    fn sqrt2() -> Self;\n+    /// 1.0 / sqrt(2.0).\n+    fn frac_1_sqrt2() -> Self;\n+\n+    /// Take the square root of a number.\n+    fn sqrt(self) -> Self;\n+    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n+    fn rsqrt(self) -> Self;\n+    /// Take the cubic root of a number.\n+    fn cbrt(self) -> Self;\n+    /// Calculate the length of the hypotenuse of a right-angle triangle given\n+    /// legs of length `x` and `y`.\n+    fn hypot(self, other: Self) -> Self;\n+\n     /// Archimedes' constant.\n     fn pi() -> Self;\n-\n     /// 2.0 * pi.\n     fn two_pi() -> Self;\n-\n     /// pi / 2.0.\n     fn frac_pi_2() -> Self;\n-\n     /// pi / 3.0.\n     fn frac_pi_3() -> Self;\n-\n     /// pi / 4.0.\n     fn frac_pi_4() -> Self;\n-\n     /// pi / 6.0.\n     fn frac_pi_6() -> Self;\n-\n     /// pi / 8.0.\n     fn frac_pi_8() -> Self;\n-\n     /// 1.0 / pi.\n     fn frac_1_pi() -> Self;\n-\n     /// 2.0 / pi.\n     fn frac_2_pi() -> Self;\n-\n     /// 2.0 / sqrt(pi).\n     fn frac_2_sqrtpi() -> Self;\n \n-    /// sqrt(2.0).\n-    fn sqrt2() -> Self;\n-\n-    /// 1.0 / sqrt(2.0).\n-    fn frac_1_sqrt2() -> Self;\n-\n-    /// Euler's number.\n-    fn e() -> Self;\n-\n-    /// log2(e).\n-    fn log2_e() -> Self;\n-\n-    /// log10(e).\n-    fn log10_e() -> Self;\n-\n-    /// ln(2.0).\n-    fn ln_2() -> Self;\n-\n-    /// ln(10.0).\n-    fn ln_10() -> Self;\n-\n-    /// Take the reciprocal (inverse) of a number, `1/x`.\n-    fn recip(self) -> Self;\n-\n-    /// Raise a number to a power.\n-    fn powf(self, n: Self) -> Self;\n-\n-    /// Raise a number to an integer power.\n-    ///\n-    /// Using this function is generally faster than using `powf`\n-    fn powi(self, n: i32) -> Self;\n-\n-    /// Take the square root of a number.\n-    fn sqrt(self) -> Self;\n-    /// Take the reciprocal (inverse) square root of a number, `1/sqrt(x)`.\n-    fn rsqrt(self) -> Self;\n-    /// Take the cubic root of a number.\n-    fn cbrt(self) -> Self;\n-    /// Calculate the length of the hypotenuse of a right-angle triangle given\n-    /// legs of length `x` and `y`.\n-    fn hypot(self, other: Self) -> Self;\n-\n     /// Computes the sine of a number (in radians).\n     fn sin(self) -> Self;\n     /// Computes the cosine of a number (in radians).\n@@ -525,10 +474,24 @@ pub trait Float: Signed + Primitive {\n     /// `(sin(x), cos(x))`.\n     fn sin_cos(self) -> (Self, Self);\n \n+    /// Euler's number.\n+    fn e() -> Self;\n+    /// log2(e).\n+    fn log2_e() -> Self;\n+    /// log10(e).\n+    fn log10_e() -> Self;\n+    /// ln(2.0).\n+    fn ln_2() -> Self;\n+    /// ln(10.0).\n+    fn ln_10() -> Self;\n+\n     /// Returns `e^(self)`, (the exponential function).\n     fn exp(self) -> Self;\n     /// Returns 2 raised to the power of the number, `2^(self)`.\n     fn exp2(self) -> Self;\n+    /// Returns the exponential of the number, minus 1, in a way that is\n+    /// accurate even if the number is close to zero.\n+    fn exp_m1(self) -> Self;\n     /// Returns the natural logarithm of the number.\n     fn ln(self) -> Self;\n     /// Returns the logarithm of the number with respect to an arbitrary base.\n@@ -537,6 +500,9 @@ pub trait Float: Signed + Primitive {\n     fn log2(self) -> Self;\n     /// Returns the base 10 logarithm of the number.\n     fn log10(self) -> Self;\n+    /// Returns the natural logarithm of the number plus 1 (`ln(1+n)`) more\n+    /// accurately than if the operations were performed separately.\n+    fn ln_1p(self) -> Self;\n \n     /// Hyperbolic sine function.\n     fn sinh(self) -> Self;"}]}