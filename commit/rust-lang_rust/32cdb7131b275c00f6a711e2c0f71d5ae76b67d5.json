{"sha": "32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMyY2RiNzEzMWIyNzVjMDBmNmE3MTFlMmMwZjcxZDVhZTc2YjY3ZDU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-18T11:10:18Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-18T11:10:18Z"}, "message": "support panic=abort", "tree": {"sha": "fd88d78d5806d5fbf105c0ce78a4116c1e4a3199", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd88d78d5806d5fbf105c0ce78a4116c1e4a3199"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "html_url": "https://github.com/rust-lang/rust/commit/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce29fbf406df9185931c61bbd662c4b613fed108", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce29fbf406df9185931c61bbd662c4b613fed108", "html_url": "https://github.com/rust-lang/rust/commit/ce29fbf406df9185931c61bbd662c4b613fed108"}], "stats": {"total": 87, "additions": 59, "deletions": 28}, "files": [{"sha": "22823f5bf8bf81f63e9b8dfd6a8efd2904e11429", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "patch": "@@ -244,6 +244,8 @@ different Miri binaries, and as such worth documenting:\n * `MIRI_BE_RUSTC` when set to any value tells the Miri driver to actually not\n   interpret the code but compile it like rustc would. This is useful to be sure\n   that the compiled `rlib`s are compatible with Miri.\n+  When set while running `cargo-miri`, it indicates that we are part of a sysroot\n+  build (for which some crates need special treatment).\n * `MIRI_CWD` when set to any value tells the Miri driver to change to the given\n   directory after loading all the source files, but before commencing\n   interpretation. This is useful if the interpreted program wants a different"}, {"sha": "2eefc105abb78bf1e203f7feabdd4c8d33ef8b08", "filename": "cargo-miri/bin.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/cargo-miri%2Fbin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/cargo-miri%2Fbin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-miri%2Fbin.rs?ref=32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "patch": "@@ -295,8 +295,7 @@ fn setup(subcommand: MiriCommand) {\n             br#\"\n [dependencies.std]\n default_features = false\n-# We need the `panic_unwind` feature because we use the `unwind` panic strategy.\n-# Using `abort` works for libstd, but then libtest will not compile.\n+# We support unwinding, so enable that panic runtime.\n features = [\"panic_unwind\"]\n \n [dependencies.test]\n@@ -338,10 +337,14 @@ path = \"lib.rs\"\n     // because we still need bootstrap to distinguish between host and target crates.\n     // In that case we overwrite `RUSTC_REAL` instead which determines the rustc used\n     // for target crates.\n+    // We set ourselves (`cargo-miri`) instead of Miri directly to be able to patch the flags\n+    // for `libpanic_abort` (usually this is done by bootstrap but we have to do it ourselves).\n+    // The `MIRI_BE_RUSTC` will mean we dispatch to `phase_setup_rustc`.\n+    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n     if env::var_os(\"RUSTC_STAGE\").is_some() {\n-        command.env(\"RUSTC_REAL\", find_miri());\n+        command.env(\"RUSTC_REAL\", &cargo_miri_path);\n     } else {\n-        command.env(\"RUSTC\", find_miri());\n+        command.env(\"RUSTC\", &cargo_miri_path);\n     }\n     command.env(\"MIRI_BE_RUSTC\", \"1\");\n     // Make sure there are no other wrappers or flags getting in our way\n@@ -370,6 +373,21 @@ path = \"lib.rs\"\n     }\n }\n \n+fn phase_setup_rustc(args: env::Args) {\n+    // Mostly we just forward everything.\n+    // `MIRI_BE_RUST` is already set.\n+    let mut cmd = miri();\n+    cmd.args(args);\n+\n+    // Patch the panic runtime for `libpanic_abort` (mirroring what bootstrap usually does).\n+    if get_arg_flag_value(\"--crate-name\").as_deref() == Some(\"panic_abort\") {\n+        cmd.arg(\"-C\").arg(\"panic=abort\");\n+    }\n+\n+    // Run it!\n+    exec(cmd);\n+}\n+\n fn phase_cargo_miri(mut args: env::Args) {\n     // Check for version and help flags even when invoked as `cargo-miri`.\n     if has_arg_flag(\"--help\") || has_arg_flag(\"-h\") {\n@@ -402,7 +420,7 @@ fn phase_cargo_miri(mut args: env::Args) {\n     // <https://github.com/rust-lang/miri/pull/1540#issuecomment-693553191> describes an alternative\n     // approach that uses `cargo check`, making that part easier but target and binary handling\n     // harder.\n-    let miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n+    let cargo_miri_path = std::env::current_exe().expect(\"current executable path invalid\");\n     let cargo_cmd = match subcommand {\n         MiriCommand::Test => \"test\",\n         MiriCommand::Run => \"run\",\n@@ -470,22 +488,22 @@ fn phase_cargo_miri(mut args: env::Args) {\n     if env::var_os(\"RUSTC_WRAPPER\").is_some() {\n         println!(\"WARNING: Ignoring `RUSTC_WRAPPER` environment variable, Miri does not support wrapping.\");\n     }\n-    cmd.env(\"RUSTC_WRAPPER\", &miri_path);\n-    if verbose {\n-        eprintln!(\"+ RUSTC_WRAPPER={:?}\", miri_path);\n-    }\n+    cmd.env(\"RUSTC_WRAPPER\", &cargo_miri_path);\n \n     // Set the runner for the current target to us as well, so we can interpret the binaries.\n     let runner_env_name = format!(\"CARGO_TARGET_{}_RUNNER\", target.to_uppercase().replace('-', \"_\"));\n-    cmd.env(runner_env_name, &miri_path);\n+    cmd.env(&runner_env_name, &cargo_miri_path);\n \n     // Set rustdoc to us as well, so we can make it do nothing (see issue #584).\n-    cmd.env(\"RUSTDOC\", &miri_path);\n+    cmd.env(\"RUSTDOC\", &cargo_miri_path);\n \n     // Run cargo.\n     if verbose {\n-        cmd.env(\"MIRI_VERBOSE\", \"\"); // This makes the other phases verbose.\n+        eprintln!(\"[cargo-miri miri] RUSTC_WRAPPER={:?}\", cargo_miri_path);\n+        eprintln!(\"[cargo-miri miri] {}={:?}\", runner_env_name, cargo_miri_path);\n+        eprintln!(\"[cargo-miri miri] RUSTDOC={:?}\", cargo_miri_path);\n         eprintln!(\"[cargo-miri miri] {:?}\", cmd);\n+        cmd.env(\"MIRI_VERBOSE\", \"\"); // This makes the other phases verbose.\n     }\n     exec(cmd)\n }\n@@ -699,6 +717,12 @@ fn main() {\n     // Skip binary name.\n     args.next().unwrap();\n \n+    // Dispatch running as part of sysroot compilation.\n+    if env::var_os(\"MIRI_BE_RUSTC\").is_some() {\n+        phase_setup_rustc(args);\n+        return;\n+    }\n+\n     // Dispatch to `cargo-miri` phase. There are three phases:\n     // - When we are called via `cargo miri`, we run as the frontend and invoke the underlying\n     //   cargo. We set RUSTC_WRAPPER and CARGO_TARGET_RUNNER to ourselves."}, {"sha": "a2ff39d0b4e9c5e31ec7ed3717ac335cd0950584", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "patch": "@@ -4,7 +4,7 @@ use log::trace;\n \n use rustc_hir::def_id::DefId;\n use rustc_middle::{mir, ty};\n-use rustc_target::abi::{Align, Size};\n+use rustc_target::{abi::{Align, Size}, spec::PanicStrategy};\n use rustc_apfloat::Float;\n use rustc_span::symbol::sym;\n \n@@ -146,6 +146,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     let code = this.read_scalar(code)?.to_i32()?;\n                     throw_machine_stop!(TerminationInfo::Exit(code.into()));\n                 }\n+                \"abort\" => {\n+                    throw_machine_stop!(TerminationInfo::Abort(None))\n+                }\n                 _ => throw_unsup_format!(\"can't call (diverging) foreign function: {}\", link_name),\n             },\n             Some(p) => p,\n@@ -160,13 +163,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Normally, this will be either `libpanic_unwind` or `libpanic_abort`, but it could\n             // also be a custom user-provided implementation via `#![feature(panic_runtime)]`\n             \"__rust_start_panic\" | \"__rust_panic_cleanup\"=> {\n-                // FIXME we might want to cache this... but it's not really performance-critical.\n-                let panic_runtime = tcx\n-                    .crates()\n-                    .iter()\n-                    .find(|cnum| tcx.is_panic_runtime(**cnum))\n-                    .expect(\"No panic runtime found!\");\n-                let panic_runtime = tcx.crate_name(*panic_runtime);\n+                // This replicates some of the logic in `inject_panic_runtime`.\n+                // FIXME: is there a way to reuse that logic?\n+                let panic_runtime = match this.tcx.sess.panic_strategy() {\n+                    PanicStrategy::Unwind => sym::panic_unwind,\n+                    PanicStrategy::Abort => sym::panic_abort,\n+                };\n                 let start_panic_instance =\n                     this.resolve_path(&[&*panic_runtime.as_str(), link_name]);\n                 return Ok(Some(&*this.load_mir(start_panic_instance.def, None)?));"}, {"sha": "52d27a1bb5c2d091f4ed5615c8c29e22c0833824", "filename": "src/shims/panic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "patch": "@@ -44,6 +44,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let this = self.eval_context_mut();\n \n         trace!(\"miri_start_panic: {:?}\", this.frame().instance);\n+        // Make sure we only start unwinding when this matches our panic strategy.\n+        assert_eq!(this.tcx.sess.panic_strategy(), PanicStrategy::Unwind);\n \n         // Get the raw pointer stored in arg[0] (the panic payload).\n         let &[payload] = check_arg_count(args)?;"}, {"sha": "ee1d5b312d5471a41cfe88e905afc8d158c9868e", "filename": "tests/compile-fail/panic/panic_abort1.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort1.rs?ref=32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "patch": "@@ -1,6 +1,7 @@\n-// ignore-test: Abort panics are not yet supported\n-// error-pattern: the evaluated program panicked\n+// error-pattern: the evaluated program aborted execution\n // compile-flags: -C panic=abort\n+// ignore-windows: windows panics via inline assembly (FIXME)\n+\n fn main() {\n     std::panic!(\"panicking from libstd\");\n }"}, {"sha": "4c08ab4ddcb716840e0e1db4c593b87c8837e1fc", "filename": "tests/compile-fail/panic/panic_abort2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort2.rs?ref=32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "patch": "@@ -1,6 +1,6 @@\n-// ignore-test: Abort panics are not yet supported\n-// error-pattern: the evaluated program panicked\n+// error-pattern: the evaluated program aborted execution\n // compile-flags: -C panic=abort\n+// ignore-windows: windows panics via inline assembly (FIXME)\n \n fn main() {\n     std::panic!(\"{}-panicking from libstd\", 42);"}, {"sha": "81a603d5e369064f214f55774c59f40966e0e706", "filename": "tests/compile-fail/panic/panic_abort3.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort3.rs?ref=32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "patch": "@@ -1,6 +1,6 @@\n-// ignore-test: Abort panics are not yet supported\n-//error-pattern: the evaluated program panicked\n+// error-pattern: the evaluated program aborted execution\n // compile-flags: -C panic=abort\n+// ignore-windows: windows panics via inline assembly (FIXME)\n \n fn main() {\n     core::panic!(\"panicking from libcore\");"}, {"sha": "d015316ef26337fece8351698bc181111d7eb0d5", "filename": "tests/compile-fail/panic/panic_abort4.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32cdb7131b275c00f6a711e2c0f71d5ae76b67d5/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic%2Fpanic_abort4.rs?ref=32cdb7131b275c00f6a711e2c0f71d5ae76b67d5", "patch": "@@ -1,6 +1,6 @@\n-// ignore-test: Abort panics are not yet supported\n-//error-pattern: the evaluated program panicked\n+// error-pattern: the evaluated program aborted execution\n // compile-flags: -C panic=abort\n+// ignore-windows: windows panics via inline assembly (FIXME)\n \n fn main() {\n     core::panic!(\"{}-panicking from libcore\", 42);"}]}