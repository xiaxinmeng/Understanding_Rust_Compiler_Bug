{"sha": "59347388541388347e86de9718bd69994c113203", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5MzQ3Mzg4NTQxMzg4MzQ3ZTg2ZGU5NzE4YmQ2OTk5NGMxMTMyMDM=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T14:16:02Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-01-31T20:23:30Z"}, "message": "first test sort-of passes", "tree": {"sha": "a0d1a61062a0e247526ee3b44545cd20df26fc91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0d1a61062a0e247526ee3b44545cd20df26fc91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59347388541388347e86de9718bd69994c113203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59347388541388347e86de9718bd69994c113203", "html_url": "https://github.com/rust-lang/rust/commit/59347388541388347e86de9718bd69994c113203", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59347388541388347e86de9718bd69994c113203/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "be03aa5ee79241a6d22a79625e37f2ce5559a345", "url": "https://api.github.com/repos/rust-lang/rust/commits/be03aa5ee79241a6d22a79625e37f2ce5559a345", "html_url": "https://github.com/rust-lang/rust/commit/be03aa5ee79241a6d22a79625e37f2ce5559a345"}], "stats": {"total": 255, "additions": 215, "deletions": 40}, "files": [{"sha": "a9bc80c4011468807ea70fd9ef07e094ad3d1edb", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59347388541388347e86de9718bd69994c113203/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/59347388541388347e86de9718bd69994c113203/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=59347388541388347e86de9718bd69994c113203", "patch": "@@ -1022,6 +1022,7 @@ dependencies = [\n name = \"ra_macros\"\n version = \"0.1.0\"\n dependencies = [\n+ \"join_to_string 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"smol_str 0.1.9 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]"}, {"sha": "059543bf2aa2c743557fa06273e89fbbccf253bb", "filename": "crates/ra_hir/src/macros.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/59347388541388347e86de9718bd69994c113203/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59347388541388347e86de9718bd69994c113203/crates%2Fra_hir%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmacros.rs?ref=59347388541388347e86de9718bd69994c113203", "patch": "@@ -254,7 +254,7 @@ fn convert_tt(tt: &SyntaxNode) -> Option<tt::Subtree> {\n \n #[test]\n fn test_convert_tt() {\n-    let text = r#\"\n+    let macro_defenition = r#\"\n macro_rules! impl_froms {\n     ($e:ident: $($v:ident),*) => {\n         $(\n@@ -267,13 +267,32 @@ macro_rules! impl_froms {\n     }\n }\n \"#;\n-    let source_file = ast::SourceFile::parse(text);\n-    let maco_call = source_file\n+\n+    let macro_invocation = r#\"\n+impl_froms!(TokenTree: Leaf, Subtree);\n+\"#;\n+\n+    let source_file = ast::SourceFile::parse(macro_defenition);\n+    let macro_defenition = source_file\n         .syntax()\n         .descendants()\n         .find_map(ast::MacroCall::cast)\n         .unwrap();\n-    let tt = macro_call_to_tt(maco_call).unwrap();\n-    let tt = mbe::parse(&tt);\n-    assert!(tt.is_some());\n+\n+    let source_file = ast::SourceFile::parse(macro_invocation);\n+    let macro_invocation = source_file\n+        .syntax()\n+        .descendants()\n+        .find_map(ast::MacroCall::cast)\n+        .unwrap();\n+\n+    let defenition_tt = macro_call_to_tt(macro_defenition).unwrap();\n+    let invocation_tt = macro_call_to_tt(macro_invocation).unwrap();\n+    let mbe = mbe::parse(&defenition_tt).unwrap();\n+    let expansion = mbe::exapnd(&mbe, &invocation_tt).unwrap();\n+    assert_eq!(\n+        expansion.to_string(),\n+        \"{(impl From < Leaf > for TokenTree {fn from (it : Leaf) - > TokenTree {TokenTree : : Leaf (it)}}) \\\n+          (impl From < Subtree > for TokenTree {fn from (it : Subtree) - > TokenTree {TokenTree : : Subtree (it)}})}\"\n+    )\n }"}, {"sha": "1c9cc9e92aa5cf4e0798b54241fb0b4c2f77fb06", "filename": "crates/ra_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2FCargo.toml?ref=59347388541388347e86de9718bd69994c113203", "patch": "@@ -7,3 +7,4 @@ authors = [\"Aleksey Kladov <aleksey.kladov@gmail.com>\"]\n [dependencies]\n rustc-hash = \"1.0.0\"\n smol_str = \"0.1.9\"\n+join_to_string = \"0.1.3\""}, {"sha": "ac76d64e4e9f28c107dcfdc1a1adf3e4b4a5ab3b", "filename": "crates/ra_macros/src/mbe.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2Fsrc%2Fmbe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2Fsrc%2Fmbe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Fmbe.rs?ref=59347388541388347e86de9718bd69994c113203", "patch": "@@ -1,6 +1,6 @@\n use smol_str::SmolStr;\n \n-use crate::tt::Delimiter;\n+pub(crate) use crate::tt::{Delimiter, Punct};\n \n pub use crate::{\n     mbe_parser::parse,\n@@ -60,11 +60,6 @@ pub(crate) struct Literal {\n     pub(crate) text: SmolStr,\n }\n \n-#[derive(Debug)]\n-pub(crate) struct Punct {\n-    pub(crate) char: char,\n-}\n-\n #[derive(Debug)]\n pub(crate) struct Ident {\n     pub(crate) text: SmolStr,"}, {"sha": "5d53632618ac0443bb0a64c1f420452eab76e5b2", "filename": "crates/ra_macros/src/mbe_expander.rs", "status": "modified", "additions": 124, "deletions": 21, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Fmbe_expander.rs?ref=59347388541388347e86de9718bd69994c113203", "patch": "@@ -1,15 +1,16 @@\n use rustc_hash::FxHashMap;\n use smol_str::SmolStr;\n \n-use crate::{mbe, tt};\n+use crate::{mbe, tt, tt_cursor::TtCursor};\n \n pub fn exapnd(rules: &mbe::MacroRules, input: &tt::Subtree) -> Option<tt::Subtree> {\n     rules.rules.iter().find_map(|it| expand_rule(it, input))\n }\n \n fn expand_rule(rule: &mbe::Rule, input: &tt::Subtree) -> Option<tt::Subtree> {\n-    let bindings = match_lhs(&rule.lhs, input)?;\n-    expand_rhs(&rule.rhs, &bindings)\n+    let mut input = TtCursor::new(input);\n+    let bindings = match_lhs(&rule.lhs, &mut input)?;\n+    expand_subtree(&rule.rhs, &bindings, &mut Vec::new())\n }\n \n #[derive(Debug, Default)]\n@@ -23,44 +24,146 @@ enum Binding {\n     Nested(Vec<Binding>),\n }\n \n-/*\n-\n-macro_rules! impl_froms {\n-    ($e:ident: $($v:ident),*) => {\n-        $(\n-            impl From<$v> for $e {\n-                fn from(it: $v) -> $e {\n-                    $e::$v(it)\n-                }\n+impl Bindings {\n+    fn get(&self, name: &SmolStr, nesting: &[usize]) -> Option<&tt::TokenTree> {\n+        let mut b = self.inner.get(name)?;\n+        for &idx in nesting.iter() {\n+            b = match b {\n+                Binding::Simple(_) => break,\n+                Binding::Nested(bs) => bs.get(idx)?,\n+            };\n+        }\n+        match b {\n+            Binding::Simple(it) => Some(it),\n+            Binding::Nested(_) => None,\n+        }\n+    }\n+    fn push_nested(&mut self, nested: Bindings) -> Option<()> {\n+        for (key, value) in nested.inner {\n+            if !self.inner.contains_key(&key) {\n+                self.inner.insert(key.clone(), Binding::Nested(Vec::new()));\n             }\n-        )*\n+            match self.inner.get_mut(&key) {\n+                Some(Binding::Nested(it)) => it.push(value),\n+                _ => return None,\n+            }\n+        }\n+        Some(())\n     }\n }\n \n-impl_froms! (Foo: Bar, Baz)\n-\n-*/\n-\n-fn match_lhs(pattern: &mbe::Subtree, input: &tt::Subtree) -> Option<Bindings> {\n+fn match_lhs(pattern: &mbe::Subtree, input: &mut TtCursor) -> Option<Bindings> {\n     let mut res = Bindings::default();\n     for pat in pattern.token_trees.iter() {\n         match pat {\n             mbe::TokenTree::Leaf(leaf) => match leaf {\n                 mbe::Leaf::Var(mbe::Var { text, kind }) => {\n                     let kind = kind.clone()?;\n                     match kind.as_str() {\n-                        \"ident\" => (),\n+                        \"ident\" => {\n+                            let ident = input.eat_ident()?.clone();\n+                            res.inner.insert(\n+                                text.clone(),\n+                                Binding::Simple(tt::Leaf::from(ident).into()),\n+                            );\n+                        }\n                         _ => return None,\n                     }\n                 }\n+                mbe::Leaf::Punct(punct) => {\n+                    if input.eat_punct()? != punct {\n+                        return None;\n+                    }\n+                }\n                 _ => return None,\n             },\n+            mbe::TokenTree::Repeat(mbe::Repeat {\n+                subtree,\n+                kind: _,\n+                separator,\n+            }) => {\n+                while let Some(nested) = match_lhs(subtree, input) {\n+                    res.push_nested(nested)?;\n+                    if separator.is_some() && !input.is_eof() {\n+                        input.eat_punct()?;\n+                    }\n+                }\n+            }\n             _ => {}\n         }\n     }\n     Some(res)\n }\n \n-fn expand_rhs(template: &mbe::Subtree, bindings: &Bindings) -> Option<tt::Subtree> {\n-    None\n+/*\n+\n+macro_rules! impl_froms {\n+    ($e:ident: $($v:ident),*) => {\n+        $(\n+            impl From<$v> for $e {\n+                fn from(it: $v) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl_froms! (Foo: Bar, Baz)\n+\n+*/\n+\n+fn expand_subtree(\n+    template: &mbe::Subtree,\n+    bindings: &Bindings,\n+    nesting: &mut Vec<usize>,\n+) -> Option<tt::Subtree> {\n+    let token_trees = template\n+        .token_trees\n+        .iter()\n+        .map(|it| expand_tt(it, bindings, nesting))\n+        .collect::<Option<Vec<_>>>()?;\n+\n+    Some(tt::Subtree {\n+        token_trees,\n+        delimiter: template.delimiter,\n+    })\n+}\n+\n+fn expand_tt(\n+    template: &mbe::TokenTree,\n+    bindings: &Bindings,\n+    nesting: &mut Vec<usize>,\n+) -> Option<tt::TokenTree> {\n+    let res: tt::TokenTree = match template {\n+        mbe::TokenTree::Subtree(subtree) => expand_subtree(subtree, bindings, nesting)?.into(),\n+        mbe::TokenTree::Repeat(repeat) => {\n+            let mut token_trees = Vec::new();\n+            nesting.push(0);\n+            while let Some(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n+                let idx = nesting.pop().unwrap();\n+                nesting.push(idx + 1);\n+                token_trees.push(t.into())\n+            }\n+            nesting.pop().unwrap();\n+            tt::Subtree {\n+                token_trees,\n+                delimiter: tt::Delimiter::None,\n+            }\n+            .into()\n+        }\n+        mbe::TokenTree::Leaf(leaf) => match leaf {\n+            mbe::Leaf::Ident(ident) => tt::Leaf::from(tt::Ident {\n+                text: ident.text.clone(),\n+            })\n+            .into(),\n+            mbe::Leaf::Punct(punct) => tt::Leaf::from(punct.clone()).into(),\n+            mbe::Leaf::Var(v) => bindings.get(&v.text, nesting)?.clone(),\n+            mbe::Leaf::Literal(l) => tt::Leaf::from(tt::Literal {\n+                text: l.text.clone(),\n+            })\n+            .into(),\n+        },\n+    };\n+    Some(res)\n }"}, {"sha": "279ab2f25576e8dc9c54bd9098cf99c828653db9", "filename": "crates/ra_macros/src/mbe_parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2Fsrc%2Fmbe_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2Fsrc%2Fmbe_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Fmbe_parser.rs?ref=59347388541388347e86de9718bd69994c113203", "patch": "@@ -84,7 +84,7 @@ fn parse_repeat(p: &mut TtCursor) -> Option<mbe::Repeat> {\n     let kind = match rep {\n         '*' => mbe::RepeatKind::ZeroOrMore,\n         '+' => mbe::RepeatKind::OneOrMore,\n-        '?' => mbe::RepeatKind::ZeroOrMore,\n+        '?' => mbe::RepeatKind::ZeroOrOne,\n         _ => return None,\n     };\n     p.bump();"}, {"sha": "56e930f000288482365f4d44684ecb70abf7f3e7", "filename": "crates/ra_macros/src/tt.rs", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2Fsrc%2Ftt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2Fsrc%2Ftt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Ftt.rs?ref=59347388541388347e86de9718bd69994c113203", "patch": "@@ -1,21 +1,24 @@\n+use std::fmt;\n+\n use smol_str::SmolStr;\n+use join_to_string::join;\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum TokenTree {\n     Leaf(Leaf),\n     Subtree(Subtree),\n }\n impl_froms!(TokenTree: Leaf, Subtree);\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub enum Leaf {\n     Literal(Literal),\n     Punct(Punct),\n     Ident(Ident),\n }\n impl_froms!(Leaf: Literal, Punct, Ident);\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct Subtree {\n     pub delimiter: Delimiter,\n     pub token_trees: Vec<TokenTree>,\n@@ -29,17 +32,69 @@ pub enum Delimiter {\n     None,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct Literal {\n     pub text: SmolStr,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone, PartialEq, Eq)]\n pub struct Punct {\n     pub char: char,\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub struct Ident {\n     pub text: SmolStr,\n }\n+\n+impl fmt::Display for TokenTree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            TokenTree::Leaf(it) => fmt::Display::fmt(it, f),\n+            TokenTree::Subtree(it) => fmt::Display::fmt(it, f),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Subtree {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        let (l, r) = match self.delimiter {\n+            Delimiter::Parenthesis => (\"(\", \")\"),\n+            Delimiter::Brace => (\"{\", \"}\"),\n+            Delimiter::Bracket => (\"[\", \"]\"),\n+            Delimiter::None => (\"\", \"\"),\n+        };\n+        join(self.token_trees.iter())\n+            .separator(\" \")\n+            .surround_with(l, r)\n+            .to_fmt(f)\n+    }\n+}\n+\n+impl fmt::Display for Leaf {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            Leaf::Ident(it) => fmt::Display::fmt(it, f),\n+            Leaf::Literal(it) => fmt::Display::fmt(it, f),\n+            Leaf::Punct(it) => fmt::Display::fmt(it, f),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Ident {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.text, f)\n+    }\n+}\n+\n+impl fmt::Display for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.text, f)\n+    }\n+}\n+\n+impl fmt::Display for Punct {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.char, f)\n+    }\n+}"}, {"sha": "6dc9f400dc8b4d6f825ef93c244de7c249017e12", "filename": "crates/ra_macros/src/tt_cursor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59347388541388347e86de9718bd69994c113203/crates%2Fra_macros%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_macros%2Fsrc%2Ftt_cursor.rs?ref=59347388541388347e86de9718bd69994c113203", "patch": "@@ -1,5 +1,6 @@\n use crate::tt;\n \n+#[derive(Clone)]\n pub(crate) struct TtCursor<'a> {\n     subtree: &'a tt::Subtree,\n     pos: usize,"}]}