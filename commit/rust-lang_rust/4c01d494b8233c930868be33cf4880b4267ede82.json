{"sha": "4c01d494b8233c930868be33cf4880b4267ede82", "node_id": "C_kwDOAAsO6NoAKDRjMDFkNDk0YjgyMzNjOTMwODY4YmUzM2NmNDg4MGI0MjY3ZWRlODI", "commit": {"author": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-03-06T14:14:55Z"}, "committer": {"name": "Deadbeef", "email": "ent3rm4n@gmail.com", "date": "2023-05-02T10:32:07Z"}, "message": "refactor unescape", "tree": {"sha": "ea42da6952970ab807fa0fa7a4767b20be9612ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea42da6952970ab807fa0fa7a4767b20be9612ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c01d494b8233c930868be33cf4880b4267ede82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c01d494b8233c930868be33cf4880b4267ede82", "html_url": "https://github.com/rust-lang/rust/commit/4c01d494b8233c930868be33cf4880b4267ede82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c01d494b8233c930868be33cf4880b4267ede82/comments", "author": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fee1-dead", "id": 43851243, "node_id": "MDQ6VXNlcjQzODUxMjQz", "avatar_url": "https://avatars.githubusercontent.com/u/43851243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fee1-dead", "html_url": "https://github.com/fee1-dead", "followers_url": "https://api.github.com/users/fee1-dead/followers", "following_url": "https://api.github.com/users/fee1-dead/following{/other_user}", "gists_url": "https://api.github.com/users/fee1-dead/gists{/gist_id}", "starred_url": "https://api.github.com/users/fee1-dead/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fee1-dead/subscriptions", "organizations_url": "https://api.github.com/users/fee1-dead/orgs", "repos_url": "https://api.github.com/users/fee1-dead/repos", "events_url": "https://api.github.com/users/fee1-dead/events{/privacy}", "received_events_url": "https://api.github.com/users/fee1-dead/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d5e7206ca674661a13d7bbe03284b81031e1ac33", "url": "https://api.github.com/repos/rust-lang/rust/commits/d5e7206ca674661a13d7bbe03284b81031e1ac33", "html_url": "https://github.com/rust-lang/rust/commit/d5e7206ca674661a13d7bbe03284b81031e1ac33"}], "stats": {"total": 113, "additions": 75, "deletions": 38}, "files": [{"sha": "c9ad54d8d980609d15416e4bdcda83df88b3b3c5", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4c01d494b8233c930868be33cf4880b4267ede82/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c01d494b8233c930868be33cf4880b4267ede82/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=4c01d494b8233c930868be33cf4880b4267ede82", "patch": "@@ -86,14 +86,16 @@ where\n             let res = unescape_char_or_byte(&mut chars, mode == Mode::Byte);\n             callback(0..(src.len() - chars.as_str().len()), res);\n         }\n-        Mode::Str | Mode::ByteStr => unescape_str_or_byte_str(src, mode == Mode::ByteStr, callback),\n+        Mode::Str | Mode::ByteStr => unescape_str_common(src, mode, callback),\n+\n         Mode::RawStr | Mode::RawByteStr => {\n             unescape_raw_str_or_raw_byte_str(src, mode == Mode::RawByteStr, callback)\n         }\n         Mode::CStr | Mode::RawCStr => unreachable!(),\n     }\n }\n \n+/// A unit within CStr. Must not be a nul character.\n pub enum CStrUnit {\n     Byte(u8),\n     Char(char),\n@@ -164,24 +166,52 @@ impl Mode {\n         }\n     }\n \n-    pub fn is_byte(self) -> bool {\n+    /// Non-byte literals should have `\\xXX` escapes that are within the ASCII range.\n+    pub fn ascii_escapes_should_be_ascii(self) -> bool {\n+        match self {\n+            Mode::Char | Mode::Str | Mode::RawStr => true,\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    /// Whether characters within the literal must be within the ASCII range\n+    pub fn characters_should_be_ascii(self) -> bool {\n+        match self {\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n+            Mode::Char | Mode::Str | Mode::RawStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    /// Byte literals do not allow unicode escape.\n+    pub fn is_unicode_escape_disallowed(self) -> bool {\n         match self {\n-            Mode::Byte | Mode::ByteStr | Mode::RawByteStr | Mode::CStr | Mode::RawCStr => true,\n-            Mode::Char | Mode::Str | Mode::RawStr => false,\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => true,\n+            Mode::Char | Mode::Str | Mode::RawStr | Mode::CStr | Mode::RawCStr => false,\n+        }\n+    }\n+\n+    pub fn prefix_noraw(self) -> &'static str {\n+        match self {\n+            Mode::Byte | Mode::ByteStr | Mode::RawByteStr => \"b\",\n+            Mode::CStr | Mode::RawCStr => \"c\",\n+            Mode::Char | Mode::Str | Mode::RawStr => \"\",\n         }\n     }\n }\n \n-fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n+fn scan_escape<T: From<u8> + From<char>>(\n+    chars: &mut Chars<'_>,\n+    mode: Mode,\n+) -> Result<T, EscapeError> {\n     // Previous character was '\\\\', unescape what follows.\n     let res = match chars.next().ok_or(EscapeError::LoneSlash)? {\n-        '\"' => '\"',\n-        'n' => '\\n',\n-        'r' => '\\r',\n-        't' => '\\t',\n-        '\\\\' => '\\\\',\n-        '\\'' => '\\'',\n-        '0' => '\\0',\n+        '\"' => b'\"',\n+        'n' => b'\\n',\n+        'r' => b'\\r',\n+        't' => b'\\t',\n+        '\\\\' => b'\\\\',\n+        '\\'' => b'\\'',\n+        '0' => b'\\0',\n \n         'x' => {\n             // Parse hexadecimal character code.\n@@ -194,22 +224,23 @@ fn scan_escape(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError\n \n             let value = hi * 16 + lo;\n \n-            // For a non-byte literal verify that it is within ASCII range.\n-            if !is_byte && !is_ascii(value) {\n+            if mode.ascii_escapes_should_be_ascii() && !is_ascii(value) {\n                 return Err(EscapeError::OutOfRangeHexEscape);\n             }\n-            let value = value as u8;\n \n-            value as char\n+            value as u8\n         }\n \n-        'u' => scan_unicode(chars, is_byte)?,\n+        'u' => return scan_unicode(chars, mode.is_unicode_escape_disallowed()).map(Into::into),\n         _ => return Err(EscapeError::InvalidEscape),\n     };\n-    Ok(res)\n+    Ok(res.into())\n }\n \n-fn scan_unicode(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n+fn scan_unicode(\n+    chars: &mut Chars<'_>,\n+    is_unicode_escape_disallowed: bool,\n+) -> Result<char, EscapeError> {\n     // We've parsed '\\u', now we have to parse '{..}'.\n \n     if chars.next() != Some('{') {\n@@ -237,7 +268,7 @@ fn scan_unicode(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeErro\n \n                 // Incorrect syntax has higher priority for error reporting\n                 // than unallowed value for a literal.\n-                if is_byte {\n+                if is_unicode_escape_disallowed {\n                     return Err(EscapeError::UnicodeEscapeInByte);\n                 }\n \n@@ -263,8 +294,8 @@ fn scan_unicode(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeErro\n }\n \n #[inline]\n-fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n-    if is_byte && !c.is_ascii() {\n+fn ascii_check(c: char, characters_should_be_ascii: bool) -> Result<char, EscapeError> {\n+    if characters_should_be_ascii && !c.is_ascii() {\n         // Byte literal can't be a non-ascii character.\n         Err(EscapeError::NonAsciiCharInByte)\n     } else {\n@@ -275,7 +306,7 @@ fn ascii_check(c: char, is_byte: bool) -> Result<char, EscapeError> {\n fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, EscapeError> {\n     let c = chars.next().ok_or(EscapeError::ZeroChars)?;\n     let res = match c {\n-        '\\\\' => scan_escape(chars, is_byte),\n+        '\\\\' => scan_escape(chars, if is_byte { Mode::Byte } else { Mode::Char }),\n         '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n         '\\r' => Err(EscapeError::BareCarriageReturn),\n         _ => ascii_check(c, is_byte),\n@@ -288,9 +319,9 @@ fn unescape_char_or_byte(chars: &mut Chars<'_>, is_byte: bool) -> Result<char, E\n \n /// Takes a contents of a string literal (without quotes) and produces a\n /// sequence of escaped characters or errors.\n-fn unescape_str_or_byte_str<F>(src: &str, is_byte: bool, callback: &mut F)\n+fn unescape_str_common<F, T: From<u8> + From<char>>(src: &str, mode: Mode, callback: &mut F)\n where\n-    F: FnMut(Range<usize>, Result<char, EscapeError>),\n+    F: FnMut(Range<usize>, Result<T, EscapeError>),\n {\n     let mut chars = src.chars();\n \n@@ -312,17 +343,17 @@ where\n                         });\n                         continue;\n                     }\n-                    _ => scan_escape(&mut chars, is_byte),\n+                    _ => scan_escape::<T>(&mut chars, mode),\n                 }\n             }\n-            '\\n' => Ok('\\n'),\n-            '\\t' => Ok('\\t'),\n+            '\\n' => Ok(b'\\n'.into()),\n+            '\\t' => Ok(b'\\t'.into()),\n             '\"' => Err(EscapeError::EscapeOnlyChar),\n             '\\r' => Err(EscapeError::BareCarriageReturn),\n-            _ => ascii_check(c, is_byte),\n+            _ => ascii_check(c, mode.characters_should_be_ascii()).map(Into::into),\n         };\n         let end = src.len() - chars.as_str().len();\n-        callback(start..end, res);\n+        callback(start..end, res.map(Into::into));\n     }\n }\n "}, {"sha": "2e4c798ab22596b35440b88b99e9b020e751c2a1", "filename": "compiler/rustc_parse/src/lexer/unescape_error_reporting.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4c01d494b8233c930868be33cf4880b4267ede82/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c01d494b8233c930868be33cf4880b4267ede82/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Funescape_error_reporting.rs?ref=4c01d494b8233c930868be33cf4880b4267ede82", "patch": "@@ -78,8 +78,7 @@ pub(crate) fn emit_unescape_error(\n                 }\n             };\n             let sugg = sugg.unwrap_or_else(|| {\n-                let is_byte = mode.is_byte();\n-                let prefix = if is_byte { \"b\" } else { \"\" };\n+                let prefix = mode.prefix_noraw();\n                 let mut escaped = String::with_capacity(lit.len());\n                 let mut chrs = lit.chars().peekable();\n                 while let Some(first) = chrs.next() {\n@@ -97,7 +96,11 @@ pub(crate) fn emit_unescape_error(\n                     };\n                 }\n                 let sugg = format!(\"{prefix}\\\"{escaped}\\\"\");\n-                MoreThanOneCharSugg::Quotes { span: span_with_quotes, is_byte, sugg }\n+                MoreThanOneCharSugg::Quotes {\n+                    span: span_with_quotes,\n+                    is_byte: mode == Mode::Byte,\n+                    sugg,\n+                }\n             });\n             handler.emit_err(UnescapeError::MoreThanOneChar {\n                 span: span_with_quotes,\n@@ -112,7 +115,7 @@ pub(crate) fn emit_unescape_error(\n                 char_span,\n                 escaped_sugg: c.escape_default().to_string(),\n                 escaped_msg: escaped_char(c),\n-                byte: mode.is_byte(),\n+                byte: mode == Mode::Byte,\n             });\n         }\n         EscapeError::BareCarriageReturn => {\n@@ -126,12 +129,15 @@ pub(crate) fn emit_unescape_error(\n         EscapeError::InvalidEscape => {\n             let (c, span) = last_char();\n \n-            let label =\n-                if mode.is_byte() { \"unknown byte escape\" } else { \"unknown character escape\" };\n+            let label = if mode == Mode::Byte || mode == Mode::ByteStr {\n+                \"unknown byte escape\"\n+            } else {\n+                \"unknown character escape\"\n+            };\n             let ec = escaped_char(c);\n             let mut diag = handler.struct_span_err(span, &format!(\"{}: `{}`\", label, ec));\n             diag.span_label(span, label);\n-            if c == '{' || c == '}' && !mode.is_byte() {\n+            if c == '{' || c == '}' && matches!(mode, Mode::Str | Mode::RawStr) {\n                 diag.help(\n                     \"if used in a formatting string, curly braces are escaped with `{{` and `}}`\",\n                 );\n@@ -141,7 +147,7 @@ pub(crate) fn emit_unescape_error(\n                      version control settings\",\n                 );\n             } else {\n-                if !mode.is_byte() {\n+                if mode == Mode::Str || mode == Mode::Char {\n                     diag.span_suggestion(\n                         span_with_quotes,\n                         \"if you meant to write a literal backslash (perhaps escaping in a regular expression), consider a raw string literal\","}]}