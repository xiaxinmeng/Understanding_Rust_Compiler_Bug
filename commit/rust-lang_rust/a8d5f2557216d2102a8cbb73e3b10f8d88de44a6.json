{"sha": "a8d5f2557216d2102a8cbb73e3b10f8d88de44a6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4ZDVmMjU1NzIxNmQyMTAyYThjYmI3M2UzYjEwZjhkODhkZTQ0YTY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-09T01:02:14Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "chains: split handling of chains in block and visual cases\n\nJust refactoring, lots of code dup here, but it should get better...", "tree": {"sha": "433a93a30a4399e4b18676b4daf6593939fb9f48", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/433a93a30a4399e4b18676b4daf6593939fb9f48"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8d5f2557216d2102a8cbb73e3b10f8d88de44a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8d5f2557216d2102a8cbb73e3b10f8d88de44a6", "html_url": "https://github.com/rust-lang/rust/commit/a8d5f2557216d2102a8cbb73e3b10f8d88de44a6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8d5f2557216d2102a8cbb73e3b10f8d88de44a6/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "728b0182c5ba5e6b98981c523868a23cbaf88719", "url": "https://api.github.com/repos/rust-lang/rust/commits/728b0182c5ba5e6b98981c523868a23cbaf88719", "html_url": "https://github.com/rust-lang/rust/commit/728b0182c5ba5e6b98981c523868a23cbaf88719"}], "stats": {"total": 278, "additions": 220, "deletions": 58}, "files": [{"sha": "e0d31e45caaa10933681d2ccdf73d38cf0f79207", "filename": "src/chains.rs", "status": "modified", "additions": 220, "deletions": 58, "changes": 278, "blob_url": "https://github.com/rust-lang/rust/blob/a8d5f2557216d2102a8cbb73e3b10f8d88de44a6/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8d5f2557216d2102a8cbb73e3b10f8d88de44a6/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=a8d5f2557216d2102a8cbb73e3b10f8d88de44a6", "patch": "@@ -84,6 +84,13 @@ use syntax::{ast, ptr};\n \n pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n     debug!(\"rewrite_chain {:?}\", shape);\n+    match context.config.indent_style() {\n+        IndentStyle::Block => rewrite_chain_block(expr, context, shape),\n+        IndentStyle::Visual => rewrite_chain_visual(expr, context, shape),\n+    }\n+}\n+\n+fn rewrite_chain_block(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n     let total_span = expr.span;\n     let (parent, subexpr_list) = make_subexpr_list(expr, context);\n \n@@ -96,14 +103,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let prefix_try_num = subexpr_list.iter().rev().take_while(|e| is_try(e)).count();\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n-    let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n-        match context.config.indent_style() {\n-            IndentStyle::Block => shape,\n-            IndentStyle::Visual => shape.visual_indent(0),\n-        }\n-    } else {\n-        shape\n-    };\n+    let parent_shape = shape;\n     let parent_rewrite = parent\n         .rewrite(context, parent_shape)\n         .map(|parent_rw| parent_rw + &\"?\".repeat(prefix_try_num))?;\n@@ -114,29 +114,14 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     // Decide how to layout the rest of the chain. `extend` is true if we can\n     // put the first non-parent item on the same line as the parent.\n     let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n-        match context.config.indent_style() {\n-            IndentStyle::Block => {\n-                // TODO this is naive since if the first child is on the same line\n-                // as the parent, then we should look at that, instead of the parent.\n-                // Can we make the parent the first two things then?\n-                let shape = if parent_is_block {\n-                    shape\n-                } else {\n-                    chain_indent(context, shape.add_offset(parent_rewrite.len()))\n-                };\n-                (shape, is_small_parent)\n-            }\n-            // TODO is this right?\n-            IndentStyle::Visual => (chain_indent(context, shape.add_offset(parent_rewrite.len())), true),\n-        }\n+        let shape = if parent_is_block {\n+            shape\n+        } else {\n+            chain_indent(context, shape.add_offset(parent_rewrite.len()))\n+        };\n+        (shape, is_small_parent)\n     } else if parent_is_block {\n-        match context.config.indent_style() {\n-            // Try to put the first child on the same line with parent's last line\n-            IndentStyle::Block => (parent_shape, true),\n-            // The parent is a block, so align the rest of the chain with the closing\n-            // brace.\n-            IndentStyle::Visual => (parent_shape, false),\n-        }\n+        (parent_shape, true)\n     } else {\n         (\n             chain_indent(context, shape.add_offset(parent_rewrite.len())),\n@@ -147,21 +132,13 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let other_child_shape = nested_shape.with_max_width(context.config);\n \n     let first_child_shape = if extend {\n-        match context.config.indent_style() {\n-            IndentStyle::Block => {\n-                let offset = trimmed_last_line_width(&parent_rewrite) + prefix_try_num;\n-                if parent_is_block {\n-                    parent_shape.offset_left(offset)?\n-                } else {\n-                    parent_shape\n-                        .block_indent(context.config.tab_spaces())\n-                        .offset_left(offset)?\n-                }\n-            }\n-            IndentStyle::Visual => {\n-                let overhead = last_line_width(&parent_rewrite);\n-                parent_shape.offset_left(overhead)?\n-            }\n+        let offset = trimmed_last_line_width(&parent_rewrite) + prefix_try_num;\n+        if parent_is_block {\n+            parent_shape.offset_left(offset)?\n+        } else {\n+            parent_shape\n+                .block_indent(context.config.tab_spaces())\n+                .offset_left(offset)?\n         }\n     } else {\n         other_child_shape\n@@ -179,9 +156,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let mut is_block_like = Vec::with_capacity(subexpr_list.len());\n     is_block_like.push(true);\n     for (i, expr) in subexpr_list.iter().skip(1).rev().enumerate() {\n-        // TODO should only use first_child_shape if expr is block like\n         let shape = if *is_block_like.last().unwrap() && !(extend && i == 0) {\n-            // TODO change the name of the shapes\n             first_child_shape\n         } else {\n             other_child_shape\n@@ -303,7 +278,6 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     let first_connector = if is_small_parent\n         || fits_single_line\n         || last_line_extendable(&parent_rewrite)\n-        || context.config.indent_style() == IndentStyle::Visual\n     {\n         \"\"\n     } else {\n@@ -314,7 +288,6 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         let second_connector = if fits_single_line\n             || rewrites[1] == \"?\"\n             || last_line_extendable(&rewrites[0])\n-            || context.config.indent_style() == IndentStyle::Visual\n         {\n             \"\"\n         } else {\n@@ -337,11 +310,203 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         )\n     };\n     let result = format!(\"{}{}\", result, \"?\".repeat(suffix_try_num));\n-    if context.config.indent_style() == IndentStyle::Visual {\n-        wrap_str(result, context.config.max_width(), shape)\n+    Some(result)\n+}\n+\n+fn rewrite_chain_visual(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    let total_span = expr.span;\n+    let (parent, subexpr_list) = make_subexpr_list(expr, context);\n+\n+    // Bail out if the chain is just try sugar, i.e., an expression followed by\n+    // any number of `?`s.\n+    if chain_only_try(&subexpr_list) {\n+        return rewrite_try(&parent, subexpr_list.len(), context, shape);\n+    }\n+    let suffix_try_num = subexpr_list.iter().take_while(|e| is_try(e)).count();\n+    let prefix_try_num = subexpr_list.iter().rev().take_while(|e| is_try(e)).count();\n+\n+    // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n+    let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n+        shape.visual_indent(0)\n+    } else {\n+        shape\n+    };\n+    let parent_rewrite = parent\n+        .rewrite(context, parent_shape)\n+        .map(|parent_rw| parent_rw + &\"?\".repeat(prefix_try_num))?;\n+    let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n+    let is_small_parent = shape.offset + parent_rewrite.len() <= context.config.tab_spaces();\n+    let parent_is_block = is_block_expr(context, &parent, &parent_rewrite);\n+\n+    // Decide how to layout the rest of the chain. `extend` is true if we can\n+    // put the first non-parent item on the same line as the parent.\n+    let (nested_shape, extend) = if !parent_rewrite_contains_newline && is_continuable(&parent) {\n+        (shape.visual_indent(0), true)\n+    } else if parent_is_block {\n+        (parent_shape, false)\n+    } else {\n+        (\n+            shape.visual_indent(0),\n+            false,\n+        )\n+    };\n+\n+    let other_child_shape = nested_shape.with_max_width(context.config);\n+\n+    let first_child_shape = if extend {\n+        let overhead = last_line_width(&parent_rewrite);\n+        parent_shape.offset_left(overhead)?\n     } else {\n-        Some(result)\n+        other_child_shape\n+    };\n+    debug!(\n+        \"child_shapes {:?} {:?}\",\n+        first_child_shape, other_child_shape\n+    );\n+\n+    let subexpr_num = subexpr_list.len();\n+    let last_subexpr = &subexpr_list[suffix_try_num];\n+    let subexpr_list = &subexpr_list[suffix_try_num..subexpr_num - prefix_try_num];\n+\n+    let mut rewrites: Vec<String> = Vec::with_capacity(subexpr_list.len());\n+    let mut is_block_like = Vec::with_capacity(subexpr_list.len());\n+    is_block_like.push(true);\n+    for (i, expr) in subexpr_list.iter().skip(1).rev().enumerate() {\n+        let shape = if *is_block_like.last().unwrap() && !(extend && i == 0) {\n+            first_child_shape\n+        } else {\n+            other_child_shape\n+        };\n+        let rewrite = rewrite_chain_subexpr(expr, total_span, context, shape)?;\n+        is_block_like.push(is_block_expr(context, expr, &rewrite));\n+        rewrites.push(rewrite);\n     }\n+\n+    // Total of all items excluding the last.\n+    let extend_last_subexpr = if is_small_parent {\n+        rewrites.len() == 1 && last_line_extendable(&rewrites[0])\n+    } else {\n+        rewrites.is_empty() && last_line_extendable(&parent_rewrite)\n+    };\n+    let almost_total = if extend_last_subexpr {\n+        last_line_width(&parent_rewrite)\n+    } else {\n+        rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len()\n+    } + suffix_try_num;\n+    let one_line_budget = if rewrites.is_empty() {\n+        shape.width\n+    } else {\n+        min(shape.width, context.config.width_heuristics().chain_width)\n+    };\n+    let all_in_one_line = !parent_rewrite_contains_newline\n+        && rewrites.iter().all(|s| !s.contains('\\n'))\n+        && almost_total < one_line_budget;\n+    let last_shape = if is_block_like[rewrites.len()] {\n+        first_child_shape\n+    } else {\n+        other_child_shape\n+    }.sub_width(shape.rhs_overhead(context.config) + suffix_try_num)?;\n+\n+    // Rewrite the last child. The last child of a chain requires special treatment. We need to\n+    // know whether 'overflowing' the last child make a better formatting:\n+    //\n+    // A chain with overflowing the last child:\n+    // ```\n+    // parent.child1.child2.last_child(\n+    //     a,\n+    //     b,\n+    //     c,\n+    // )\n+    // ```\n+    //\n+    // A chain without overflowing the last child (in vertical layout):\n+    // ```\n+    // parent\n+    //     .child1\n+    //     .child2\n+    //     .last_child(a, b, c)\n+    // ```\n+    //\n+    // In particular, overflowing is effective when the last child is a method with a multi-lined\n+    // block-like argument (e.g. closure):\n+    // ```\n+    // parent.child1.child2.last_child(|a, b, c| {\n+    //     let x = foo(a, b, c);\n+    //     let y = bar(a, b, c);\n+    //\n+    //     // ...\n+    //\n+    //     result\n+    // })\n+    // ```\n+\n+    // `rewrite_last` rewrites the last child on its own line. We use a closure here instead of\n+    // directly calling `rewrite_chain_subexpr()` to avoid exponential blowup.\n+    let rewrite_last = || rewrite_chain_subexpr(last_subexpr, total_span, context, last_shape);\n+    let (last_subexpr_str, fits_single_line) = if all_in_one_line || extend_last_subexpr {\n+        // First we try to 'overflow' the last child and see if it looks better than using\n+        // vertical layout.\n+        parent_shape.offset_left(almost_total).map(|shape| {\n+            if let Some(rw) = rewrite_chain_subexpr(last_subexpr, total_span, context, shape) {\n+                // We allow overflowing here only if both of the following conditions match:\n+                // 1. The entire chain fits in a single line except the last child.\n+                // 2. `last_child_str.lines().count() >= 5`.\n+                let line_count = rw.lines().count();\n+                let fits_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n+                if fits_single_line && line_count >= 5 {\n+                    (Some(rw), true)\n+                } else {\n+                    // We could not know whether overflowing is better than using vertical layout,\n+                    // just by looking at the overflowed rewrite. Now we rewrite the last child\n+                    // on its own line, and compare two rewrites to choose which is better.\n+                    match rewrite_last() {\n+                        Some(ref new_rw) if !fits_single_line => (Some(new_rw.clone()), false),\n+                        Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n+                            (Some(rw), fits_single_line)\n+                        }\n+                        new_rw @ Some(..) => (new_rw, false),\n+                        _ => (Some(rw), fits_single_line),\n+                    }\n+                }\n+            } else {\n+                (rewrite_last(), false)\n+            }\n+        })?\n+    } else {\n+        (rewrite_last(), false)\n+    };\n+    rewrites.push(last_subexpr_str?);\n+    // We should never look at this, since we only look at the block-ness of the\n+    // previous item in the chain.\n+    is_block_like.push(false);\n+\n+    let connector = if fits_single_line && !parent_rewrite_contains_newline {\n+        // Yay, we can put everything on one line.\n+        Cow::from(\"\")\n+    } else {\n+        // Use new lines.\n+        if *context.force_one_line_chain.borrow() {\n+            return None;\n+        }\n+        nested_shape.indent.to_string_with_newline(context.config)\n+    };\n+\n+    let result = if is_small_parent && rewrites.len() > 1 {\n+        format!(\n+            \"{}{}{}\",\n+            parent_rewrite,\n+            rewrites[0],\n+            join_rewrites(&rewrites[1..], &is_block_like[2..], &connector),\n+        )\n+    } else {\n+        format!(\n+            \"{}{}\",\n+            parent_rewrite,\n+            join_rewrites(&rewrites, &is_block_like[1..], &connector),\n+        )\n+    };\n+    let result = format!(\"{}{}\", result, \"?\".repeat(suffix_try_num));\n+    wrap_str(result, context.config.max_width(), shape)\n }\n \n // True if the chain is only `?`s.\n@@ -421,12 +586,9 @@ fn make_subexpr_list(expr: &ast::Expr, context: &RewriteContext) -> (ast::Expr,\n }\n \n fn chain_indent(context: &RewriteContext, shape: Shape) -> Shape {\n-    match context.config.indent_style() {\n-        IndentStyle::Visual => shape.visual_indent(0),\n-        IndentStyle::Block => shape\n-            .block_indent(context.config.tab_spaces())\n-            .with_max_width(context.config),\n-    }\n+    IndentStyle::Block => shape\n+        .block_indent(context.config.tab_spaces())\n+        .with_max_width(context.config),\n }\n \n // Returns the expression's subexpression, if it exists. When the subexpr"}]}