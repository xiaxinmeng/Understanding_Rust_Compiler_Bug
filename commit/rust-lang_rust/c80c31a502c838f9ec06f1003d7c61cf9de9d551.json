{"sha": "c80c31a502c838f9ec06f1003d7c61cf9de9d551", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MGMzMWE1MDJjODM4ZjllYzA2ZjEwMDNkN2M2MWNmOWRlOWQ1NTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-02T15:06:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-02T15:06:36Z"}, "message": "Auto merge of #38053 - eddyb:lazy-9, r=nikomatsakis\n\n[9/n] rustc: move type information out of AdtDef and TraitDef.\n\n_This is part of a series ([prev](https://github.com/rust-lang/rust/pull/37688) | [next]()) of patches designed to rework rustc into an out-of-order on-demand pipeline model for both better feature support (e.g. [MIR-based](https://github.com/solson/miri) early constant evaluation) and incremental execution of compiler passes (e.g. type-checking), with beneficial consequences to IDE support as well.\nIf any motivation is unclear, please ask for additional PR description clarifications or code comments._\n\n<hr>\n\nBoth `AdtDef` and `TraitDef` contained type information (field types, generics and predicates) which was required to create them, preventing their use before that type information exists, or in the case of field types, *mutation* was required, leading to a variance-magicking implementation of `ivar`s.\n\nThis PR takes that information out and the resulting cleaner setup could even eventually end up merged with HIR, because, just like `AssociatedItem` before it, there's no dependency on types anymore.\n(With one exception, variant discriminants should probably be moved into their own map later.)", "tree": {"sha": "5573f4f27717588860e27018aa81a29409cf060b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5573f4f27717588860e27018aa81a29409cf060b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c80c31a502c838f9ec06f1003d7c61cf9de9d551", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c80c31a502c838f9ec06f1003d7c61cf9de9d551", "html_url": "https://github.com/rust-lang/rust/commit/c80c31a502c838f9ec06f1003d7c61cf9de9d551", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c80c31a502c838f9ec06f1003d7c61cf9de9d551/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f8fd533ac8391fa848c3a637ca05fd60993f79e", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8fd533ac8391fa848c3a637ca05fd60993f79e", "html_url": "https://github.com/rust-lang/rust/commit/2f8fd533ac8391fa848c3a637ca05fd60993f79e"}, {"sha": "07ff914be1c5e0702893191827b0c13308898b45", "url": "https://api.github.com/repos/rust-lang/rust/commits/07ff914be1c5e0702893191827b0c13308898b45", "html_url": "https://github.com/rust-lang/rust/commit/07ff914be1c5e0702893191827b0c13308898b45"}], "stats": {"total": 886, "additions": 322, "deletions": 564}, "files": [{"sha": "e261c699b6ac60a03a16d5a340f1cef80a3491bc", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -110,7 +110,6 @@ pub enum DepNode<D: Clone + Debug> {\n     // predicates for an item wind up in `ItemSignature`).\n     AssociatedItems(D),\n     ItemSignature(D),\n-    FieldTy(D),\n     SizedConstraint(D),\n     AssociatedItemDefIds(D),\n     InherentImpls(D),\n@@ -161,7 +160,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             TypeckItemBody,\n             AssociatedItems,\n             ItemSignature,\n-            FieldTy,\n             AssociatedItemDefIds,\n             InherentImpls,\n             TraitImpls,\n@@ -229,7 +227,6 @@ impl<D: Clone + Debug> DepNode<D> {\n             TransInlinedItem(ref d) => op(d).map(TransInlinedItem),\n             AssociatedItems(ref d) => op(d).map(AssociatedItems),\n             ItemSignature(ref d) => op(d).map(ItemSignature),\n-            FieldTy(ref d) => op(d).map(FieldTy),\n             SizedConstraint(ref d) => op(d).map(SizedConstraint),\n             AssociatedItemDefIds(ref d) => op(d).map(AssociatedItemDefIds),\n             InherentImpls(ref d) => op(d).map(InherentImpls),"}, {"sha": "822fb4d6770f0142e16fffcf7101399825800187", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -278,8 +278,8 @@ pub trait CrateStore<'tcx> {\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx>;\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute>;\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>;\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>;\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef;\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef;\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name>;\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId>;\n \n@@ -425,9 +425,9 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     fn item_generics<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)\n                          -> ty::Generics<'tcx> { bug!(\"item_generics\") }\n     fn item_attrs(&self, def_id: DefId) -> Vec<ast::Attribute> { bug!(\"item_attrs\") }\n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId)-> ty::TraitDef\n         { bug!(\"trait_def\") }\n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef\n         { bug!(\"adt_def\") }\n     fn fn_arg_names(&self, did: DefId) -> Vec<ast::Name> { bug!(\"fn_arg_names\") }\n     fn inherent_implementations_for_type(&self, def_id: DefId) -> Vec<DefId> { vec![] }"}, {"sha": "b3e61f1e5706772c1eeffc77f0c19c3d9fa6c399", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -701,7 +701,7 @@ impl<'a, 'gcx, 'tcx> ExprUseVisitor<'a, 'gcx, 'tcx> {\n         // are properly handled.\n         self.walk_expr(with_expr);\n \n-        fn contains_field_named(field: ty::FieldDef,\n+        fn contains_field_named(field: &ty::FieldDef,\n                                 fields: &[hir::Field])\n                                 -> bool\n         {"}, {"sha": "3cd35804732926d9689679b5c5d0dde745b6406b", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -462,7 +462,7 @@ pub enum TerminatorKind<'tcx> {\n     /// lvalue evaluates to some enum; jump depending on the branch\n     Switch {\n         discr: Lvalue<'tcx>,\n-        adt_def: AdtDef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n         targets: Vec<BasicBlock>,\n     },\n \n@@ -866,7 +866,7 @@ pub enum ProjectionElem<'tcx, V> {\n     /// \"Downcast\" to a variant of an ADT. Currently, we only introduce\n     /// this for ADTs with more than one variant. It may be better to\n     /// just introduce it always, or always for enums.\n-    Downcast(AdtDef<'tcx>, usize),\n+    Downcast(&'tcx AdtDef, usize),\n }\n \n /// Alias for projections as they appear in lvalues, where the base is an lvalue\n@@ -1035,7 +1035,7 @@ pub enum AggregateKind<'tcx> {\n     /// The second field is variant number (discriminant), it's equal to 0\n     /// for struct and union expressions. The fourth field is active field\n     /// number and is present only for union expressions.\n-    Adt(AdtDef<'tcx>, usize, &'tcx Substs<'tcx>, Option<usize>),\n+    Adt(&'tcx AdtDef, usize, &'tcx Substs<'tcx>, Option<usize>),\n     Closure(DefId, ClosureSubsts<'tcx>),\n }\n "}, {"sha": "03530945e046df3651199a4438ffed8f80610f3d", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -25,7 +25,7 @@ pub enum LvalueTy<'tcx> {\n     Ty { ty: Ty<'tcx> },\n \n     /// Downcast to a particular variant of an enum.\n-    Downcast { adt_def: AdtDef<'tcx>,\n+    Downcast { adt_def: &'tcx AdtDef,\n                substs: &'tcx Substs<'tcx>,\n                variant_index: usize },\n }"}, {"sha": "76a5e2764f2646f01f3735c43493e2ddd477d617", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -244,11 +244,11 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         for item in self.tcx.get_attrs(def_id).iter() {\n             if item.check_name(\"rustc_on_unimplemented\") {\n                 let err_sp = item.meta().span.substitute_dummy(span);\n-                let def = self.tcx.lookup_trait_def(trait_ref.def_id);\n-                let trait_str = def.trait_ref.to_string();\n+                let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n                 if let Some(istring) = item.value_str() {\n                     let istring = &*istring.as_str();\n-                    let generic_map = def.generics.types.iter().map(|param| {\n+                    let generics = self.tcx.item_generics(trait_ref.def_id);\n+                    let generic_map = generics.types.iter().map(|param| {\n                         (param.name.as_str().to_string(),\n                          trait_ref.substs.type_for_def(param).to_string())\n                     }).collect::<FxHashMap<String, String>>();"}, {"sha": "ceee6c236e4e3dba250c6364d3a5ef6e5fc796ab", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -21,7 +21,8 @@ use super::elaborate_predicates;\n \n use hir::def_id::DefId;\n use traits;\n-use ty::{self, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::subst::Substs;\n use syntax::ast;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n@@ -126,9 +127,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn supertraits_reference_self(self, trait_def_id: DefId) -> bool {\n-        let trait_def = self.lookup_trait_def(trait_def_id);\n-        let trait_ref = trait_def.trait_ref.clone();\n-        let trait_ref = trait_ref.to_poly_trait_ref();\n+        let trait_ref = ty::Binder(ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: Substs::identity_for_item(self, trait_def_id)\n+        });\n         let predicates = self.item_super_predicates(trait_def_id);\n         predicates\n             .predicates\n@@ -317,8 +319,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n                     // Compute supertraits of current trait lazily.\n                     if supertraits.is_none() {\n-                        let trait_def = self.lookup_trait_def(trait_def_id);\n-                        let trait_ref = ty::Binder(trait_def.trait_ref.clone());\n+                        let trait_ref = ty::Binder(ty::TraitRef {\n+                            def_id: trait_def_id,\n+                            substs: Substs::identity_for_item(self, trait_def_id)\n+                        });\n                         supertraits = Some(traits::supertraits(self, trait_ref).collect());\n                     }\n "}, {"sha": "c54c0bf74ef7a36f07a95384f06558d2821639b6", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -2544,7 +2544,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             (&ty::TyAdt(def, substs_a), &ty::TyAdt(_, substs_b)) => {\n                 let fields = def\n                     .all_fields()\n-                    .map(|f| f.unsubst_ty())\n+                    .map(|f| tcx.item_type(f.did))\n                     .collect::<Vec<_>>();\n \n                 // The last field of the structure has to exist and contain type parameters."}, {"sha": "a41523f2def76385d1cc323bf6ff103781ac4c6a", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -297,18 +297,18 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n }\n \n-pub struct Ancestors<'a, 'tcx: 'a> {\n-    trait_def: &'a TraitDef<'tcx>,\n+pub struct Ancestors<'a> {\n+    trait_def: &'a TraitDef,\n     current_source: Option<Node>,\n }\n \n-impl<'a, 'tcx> Iterator for Ancestors<'a, 'tcx> {\n+impl<'a> Iterator for Ancestors<'a> {\n     type Item = Node;\n     fn next(&mut self) -> Option<Node> {\n         let cur = self.current_source.take();\n         if let Some(Node::Impl(cur_impl)) = cur {\n             let parent = self.trait_def.specialization_graph.borrow().parent(cur_impl);\n-            if parent == self.trait_def.def_id() {\n+            if parent == self.trait_def.def_id {\n                 self.current_source = Some(Node::Trait(parent));\n             } else {\n                 self.current_source = Some(Node::Impl(parent));\n@@ -332,7 +332,7 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n+impl<'a, 'gcx, 'tcx> Ancestors<'a> {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n@@ -347,9 +347,7 @@ impl<'a, 'gcx, 'tcx> Ancestors<'a, 'tcx> {\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n /// impl itself.\n-pub fn ancestors<'a, 'tcx>(trait_def: &'a TraitDef<'tcx>,\n-                           start_from_impl: DefId)\n-                           -> Ancestors<'a, 'tcx> {\n+pub fn ancestors<'a>(trait_def: &'a TraitDef, start_from_impl: DefId) -> Ancestors<'a> {\n     Ancestors {\n         trait_def: trait_def,\n         current_source: Some(Node::Impl(start_from_impl)),"}, {"sha": "17c335fc9c72fca33060562042fd7cb6a0a6f2c0", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 13, "deletions": 32, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -68,8 +68,8 @@ pub struct CtxtArenas<'tcx> {\n \n     // references\n     generics: TypedArena<ty::Generics<'tcx>>,\n-    trait_def: TypedArena<ty::TraitDef<'tcx>>,\n-    adt_def: TypedArena<ty::AdtDefData<'tcx, 'tcx>>,\n+    trait_def: TypedArena<ty::TraitDef>,\n+    adt_def: TypedArena<ty::AdtDef>,\n     mir: TypedArena<RefCell<Mir<'tcx>>>,\n }\n \n@@ -425,6 +425,7 @@ pub struct GlobalCtxt<'tcx> {\n     pub impl_trait_refs: RefCell<DepTrackingMap<maps::ImplTraitRefs<'tcx>>>,\n     pub trait_defs: RefCell<DepTrackingMap<maps::TraitDefs<'tcx>>>,\n     pub adt_defs: RefCell<DepTrackingMap<maps::AdtDefs<'tcx>>>,\n+    pub adt_sized_constraint: RefCell<DepTrackingMap<maps::AdtSizedConstraint<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n     /// associated generics and predicates.\n@@ -688,38 +689,17 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.global_interners.arenas.mir.alloc(RefCell::new(mir))\n     }\n \n-    pub fn intern_trait_def(self, def: ty::TraitDef<'gcx>)\n-                            -> &'gcx ty::TraitDef<'gcx> {\n-        let did = def.trait_ref.def_id;\n-        let interned = self.alloc_trait_def(def);\n-        if let Some(prev) = self.trait_defs.borrow_mut().insert(did, interned) {\n-            bug!(\"Tried to overwrite interned TraitDef: {:?}\", prev)\n-        }\n-        self.generics.borrow_mut().insert(did, interned.generics);\n-        interned\n-    }\n-\n-    pub fn alloc_trait_def(self, def: ty::TraitDef<'gcx>)\n-                           -> &'gcx ty::TraitDef<'gcx> {\n+    pub fn alloc_trait_def(self, def: ty::TraitDef) -> &'gcx ty::TraitDef {\n         self.global_interners.arenas.trait_def.alloc(def)\n     }\n \n-    pub fn insert_adt_def(self, did: DefId, adt_def: ty::AdtDefMaster<'gcx>) {\n-        // this will need a transmute when reverse-variance is removed\n-        if let Some(prev) = self.adt_defs.borrow_mut().insert(did, adt_def) {\n-            bug!(\"Tried to overwrite interned AdtDef: {:?}\", prev)\n-        }\n-    }\n-\n-    pub fn intern_adt_def(self,\n-                          did: DefId,\n-                          kind: AdtKind,\n-                          variants: Vec<ty::VariantDefData<'gcx, 'gcx>>)\n-                          -> ty::AdtDefMaster<'gcx> {\n-        let def = ty::AdtDefData::new(self, did, kind, variants);\n-        let interned = self.global_interners.arenas.adt_def.alloc(def);\n-        self.insert_adt_def(did, interned);\n-        interned\n+    pub fn alloc_adt_def(self,\n+                         did: DefId,\n+                         kind: AdtKind,\n+                         variants: Vec<ty::VariantDef>)\n+                         -> &'gcx ty::AdtDef {\n+        let def = ty::AdtDef::new(self, did, kind, variants);\n+        self.global_interners.arenas.adt_def.alloc(def)\n     }\n \n     pub fn intern_stability(self, stab: attr::Stability) -> &'gcx attr::Stability {\n@@ -815,6 +795,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             impl_trait_refs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             trait_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             adt_defs: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n+            adt_sized_constraint: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             generics: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n             super_predicates: RefCell::new(DepTrackingMap::new(dep_graph.clone())),\n@@ -1392,7 +1373,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.mk_imm_ref(self.mk_region(ty::ReStatic), self.mk_str())\n     }\n \n-    pub fn mk_adt(self, def: AdtDef<'tcx>, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n+    pub fn mk_adt(self, def: &'tcx AdtDef, substs: &'tcx Substs<'tcx>) -> Ty<'tcx> {\n         // take a copy of substs so that we own the vectors inside\n         self.mk_ty(TyAdt(def, substs))\n     }"}, {"sha": "634599406afb2fc49627a734559fccb5e0c4abc1", "filename": "src/librustc/ty/ivar.rs", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2f8fd533ac8391fa848c3a637ca05fd60993f79e/src%2Flibrustc%2Fty%2Fivar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f8fd533ac8391fa848c3a637ca05fd60993f79e/src%2Flibrustc%2Fty%2Fivar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fivar.rs?ref=2f8fd533ac8391fa848c3a637ca05fd60993f79e", "patch": "@@ -1,90 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use dep_graph::DepNode;\n-use hir::def_id::DefId;\n-use ty::{Ty, TyS};\n-use ty::tls;\n-\n-use rustc_data_structures::ivar;\n-\n-use std::fmt;\n-use std::marker::PhantomData;\n-use core::nonzero::NonZero;\n-\n-/// An IVar that contains a Ty. 'lt is a (reverse-variant) upper bound\n-/// on the lifetime of the IVar. This is required because of variance\n-/// problems: the IVar needs to be variant with respect to 'tcx (so\n-/// it can be referred to from Ty) but can only be modified if its\n-/// lifetime is exactly 'tcx.\n-///\n-/// Safety invariants:\n-///     (A) self.0, if fulfilled, is a valid Ty<'tcx>\n-///     (B) no aliases to this value with a 'tcx longer than this\n-///         value's 'lt exist\n-///\n-/// Dependency tracking: each ivar does not know what node in the\n-/// dependency graph it is associated with, so when you get/fulfill\n-/// you must supply a `DepNode` id. This should always be the same id!\n-///\n-/// NonZero is used rather than Unique because Unique isn't Copy.\n-pub struct TyIVar<'tcx, 'lt: 'tcx>(ivar::Ivar<NonZero<*const TyS<'static>>>,\n-                                   PhantomData<fn(TyS<'lt>)->TyS<'tcx>>);\n-\n-impl<'tcx, 'lt> TyIVar<'tcx, 'lt> {\n-    #[inline]\n-    pub fn new() -> Self {\n-        // Invariant (A) satisfied because the IVar is unfulfilled\n-        // Invariant (B) because 'lt : 'tcx\n-        TyIVar(ivar::Ivar::new(), PhantomData)\n-    }\n-\n-    #[inline]\n-    pub fn get(&self, dep_node: DepNode<DefId>) -> Option<Ty<'tcx>> {\n-        tls::with(|tcx| tcx.dep_graph.read(dep_node));\n-        self.untracked_get()\n-    }\n-\n-    /// Reads the ivar without registered a dep-graph read. Use with\n-    /// caution.\n-    #[inline]\n-    pub fn untracked_get(&self) -> Option<Ty<'tcx>> {\n-        match self.0.get() {\n-            None => None,\n-            // valid because of invariant (A)\n-            Some(v) => Some(unsafe { &*(*v as *const TyS<'tcx>) })\n-        }\n-    }\n-\n-    #[inline]\n-    pub fn unwrap(&self, dep_node: DepNode<DefId>) -> Ty<'tcx> {\n-        self.get(dep_node).unwrap()\n-    }\n-\n-    pub fn fulfill(&self, dep_node: DepNode<DefId>, value: Ty<'lt>) {\n-        tls::with(|tcx| tcx.dep_graph.write(dep_node));\n-\n-        // Invariant (A) is fulfilled, because by (B), every alias\n-        // of this has a 'tcx longer than 'lt.\n-        let value: *const TyS<'lt> = value;\n-        // FIXME(27214): unneeded [as *const ()]\n-        let value = value as *const () as *const TyS<'static>;\n-        self.0.fulfill(unsafe { NonZero::new(value) })\n-    }\n-}\n-\n-impl<'tcx, 'lt> fmt::Debug for TyIVar<'tcx, 'lt> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.untracked_get() {\n-            Some(val) => write!(f, \"TyIVar({:?})\", val),\n-            None => f.write_str(\"TyIVar(<unfulfilled>)\")\n-        }\n-    }\n-}"}, {"sha": "42b3544421f8b01362b8efafff7104b6c5571fe2", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -39,8 +39,9 @@ dep_map_ty! { Predicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { SuperPredicates: ItemSignature(DefId) -> ty::GenericPredicates<'tcx> }\n dep_map_ty! { AssociatedItemDefIds: AssociatedItemDefIds(DefId) -> Rc<Vec<DefId>> }\n dep_map_ty! { ImplTraitRefs: ItemSignature(DefId) -> Option<ty::TraitRef<'tcx>> }\n-dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef<'tcx> }\n-dep_map_ty! { AdtDefs: ItemSignature(DefId) -> ty::AdtDefMaster<'tcx> }\n+dep_map_ty! { TraitDefs: ItemSignature(DefId) -> &'tcx ty::TraitDef }\n+dep_map_ty! { AdtDefs: ItemSignature(DefId) -> &'tcx ty::AdtDef }\n+dep_map_ty! { AdtSizedConstraint: SizedConstraint(DefId) -> Ty<'tcx> }\n dep_map_ty! { ItemVariances: ItemSignature(DefId) -> Rc<Vec<ty::Variance>> }\n dep_map_ty! { InherentImpls: InherentImpls(DefId) -> Vec<DefId> }\n dep_map_ty! { ReprHints: ReprHints(DefId) -> Rc<Vec<attr::ReprAttr>> }"}, {"sha": "df12c252907a5a5f319ef34f8e2d10c21b3514c5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 78, "deletions": 170, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -93,7 +93,6 @@ pub mod util;\n mod contents;\n mod context;\n mod flags;\n-mod ivar;\n mod structural_impls;\n mod sty;\n \n@@ -623,10 +622,6 @@ pub struct RegionParameterDef<'tcx> {\n }\n \n impl<'tcx> RegionParameterDef<'tcx> {\n-    pub fn to_early_bound_region(&self) -> ty::Region {\n-        ty::ReEarlyBound(self.to_early_bound_region_data())\n-    }\n-\n     pub fn to_early_bound_region_data(&self) -> ty::EarlyBoundRegion {\n         ty::EarlyBoundRegion {\n             index: self.index,\n@@ -1313,106 +1308,64 @@ bitflags! {\n     }\n }\n \n-pub type AdtDef<'tcx> = &'tcx AdtDefData<'tcx, 'static>;\n-pub type VariantDef<'tcx> = &'tcx VariantDefData<'tcx, 'static>;\n-pub type FieldDef<'tcx> = &'tcx FieldDefData<'tcx, 'static>;\n-\n-// See comment on AdtDefData for explanation\n-pub type AdtDefMaster<'tcx> = &'tcx AdtDefData<'tcx, 'tcx>;\n-pub type VariantDefMaster<'tcx> = &'tcx VariantDefData<'tcx, 'tcx>;\n-pub type FieldDefMaster<'tcx> = &'tcx FieldDefData<'tcx, 'tcx>;\n-\n-pub struct VariantDefData<'tcx, 'container: 'tcx> {\n+pub struct VariantDef {\n     /// The variant's DefId. If this is a tuple-like struct,\n     /// this is the DefId of the struct's ctor.\n     pub did: DefId,\n     pub name: Name, // struct's name if this is a struct\n     pub disr_val: Disr,\n-    pub fields: Vec<FieldDefData<'tcx, 'container>>,\n+    pub fields: Vec<FieldDef>,\n     pub ctor_kind: CtorKind,\n }\n \n-pub struct FieldDefData<'tcx, 'container: 'tcx> {\n+pub struct FieldDef {\n     pub did: DefId,\n     pub name: Name,\n     pub vis: Visibility,\n-    /// TyIVar is used here to allow for variance (see the doc at\n-    /// AdtDefData).\n-    ///\n-    /// Note: direct accesses to `ty` must also add dep edges.\n-    ty: ivar::TyIVar<'tcx, 'container>\n }\n \n /// The definition of an abstract data type - a struct or enum.\n ///\n /// These are all interned (by intern_adt_def) into the adt_defs\n /// table.\n-///\n-/// Because of the possibility of nested tcx-s, this type\n-/// needs 2 lifetimes: the traditional variant lifetime ('tcx)\n-/// bounding the lifetime of the inner types is of course necessary.\n-/// However, it is not sufficient - types from a child tcx must\n-/// not be leaked into the master tcx by being stored in an AdtDefData.\n-///\n-/// The 'container lifetime ensures that by outliving the container\n-/// tcx and preventing shorter-lived types from being inserted. When\n-/// write access is not needed, the 'container lifetime can be\n-/// erased to 'static, which can be done by the AdtDef wrapper.\n-pub struct AdtDefData<'tcx, 'container: 'tcx> {\n+pub struct AdtDef {\n     pub did: DefId,\n-    pub variants: Vec<VariantDefData<'tcx, 'container>>,\n+    pub variants: Vec<VariantDef>,\n     destructor: Cell<Option<DefId>>,\n-    flags: Cell<AdtFlags>,\n-    sized_constraint: ivar::TyIVar<'tcx, 'container>,\n+    flags: Cell<AdtFlags>\n }\n \n-impl<'tcx, 'container> PartialEq for AdtDefData<'tcx, 'container> {\n-    // AdtDefData are always interned and this is part of TyS equality\n+impl PartialEq for AdtDef {\n+    // AdtDef are always interned and this is part of TyS equality\n     #[inline]\n     fn eq(&self, other: &Self) -> bool { self as *const _ == other as *const _ }\n }\n \n-impl<'tcx, 'container> Eq for AdtDefData<'tcx, 'container> {}\n+impl Eq for AdtDef {}\n \n-impl<'tcx, 'container> Hash for AdtDefData<'tcx, 'container> {\n+impl Hash for AdtDef {\n     #[inline]\n     fn hash<H: Hasher>(&self, s: &mut H) {\n-        (self as *const AdtDefData).hash(s)\n+        (self as *const AdtDef).hash(s)\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedEncodable for AdtDef<'tcx> {\n+impl<'tcx> serialize::UseSpecializedEncodable for &'tcx AdtDef {\n     fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         self.did.encode(s)\n     }\n }\n \n-impl<'tcx> serialize::UseSpecializedDecodable for AdtDef<'tcx> {}\n-\n-impl<'a, 'gcx, 'tcx> AdtDefData<'tcx, 'static> {\n-    #[inline]\n-    pub fn is_uninhabited_recurse(&'tcx self,\n-                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n-                                  block: Option<NodeId>,\n-                                  cx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  substs: &'tcx Substs<'tcx>) -> bool {\n-        if !visited.insert((self.did, substs)) {\n-            return false;\n-        };\n-        self.variants.iter().all(|v| {\n-            v.is_uninhabited_recurse(visited, block, cx, substs, self.is_union())\n-        })\n-    }\n-}\n+impl<'tcx> serialize::UseSpecializedDecodable for &'tcx AdtDef {}\n \n #[derive(Copy, Clone, Debug, Eq, PartialEq)]\n pub enum AdtKind { Struct, Union, Enum }\n \n-impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n+impl<'a, 'gcx, 'tcx> AdtDef {\n     fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n            did: DefId,\n            kind: AdtKind,\n-           variants: Vec<VariantDefData<'gcx, 'container>>) -> Self {\n+           variants: Vec<VariantDef>) -> Self {\n         let mut flags = AdtFlags::NO_ADT_FLAGS;\n         let attrs = tcx.get_attrs(did);\n         if attr::contains_name(&attrs, \"fundamental\") {\n@@ -1429,12 +1382,11 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             AdtKind::Union => flags = flags | AdtFlags::IS_UNION,\n             AdtKind::Struct => {}\n         }\n-        AdtDefData {\n+        AdtDef {\n             did: did,\n             variants: variants,\n             flags: Cell::new(flags),\n             destructor: Cell::new(None),\n-            sized_constraint: ivar::TyIVar::new(),\n         }\n     }\n \n@@ -1445,6 +1397,20 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n         self.flags.set(self.flags.get() | AdtFlags::IS_DTORCK_VALID)\n     }\n \n+    #[inline]\n+    pub fn is_uninhabited_recurse(&self,\n+                                  visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n+                                  block: Option<NodeId>,\n+                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  substs: &'tcx Substs<'tcx>) -> bool {\n+        if !visited.insert((self.did, substs)) {\n+            return false;\n+        };\n+        self.variants.iter().all(|v| {\n+            v.is_uninhabited_recurse(visited, block, tcx, substs, self.is_union())\n+        })\n+    }\n+\n     #[inline]\n     pub fn is_struct(&self) -> bool {\n         !self.is_union() && !self.is_enum()\n@@ -1524,7 +1490,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n \n     /// Asserts this is a struct and returns the struct's unique\n     /// variant.\n-    pub fn struct_variant(&self) -> &VariantDefData<'gcx, 'container> {\n+    pub fn struct_variant(&self) -> &VariantDef {\n         assert!(!self.is_enum());\n         &self.variants[0]\n     }\n@@ -1537,14 +1503,8 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n     /// Returns an iterator over all fields contained\n     /// by this ADT.\n     #[inline]\n-    pub fn all_fields(&self) ->\n-            iter::FlatMap<\n-                slice::Iter<VariantDefData<'gcx, 'container>>,\n-                slice::Iter<FieldDefData<'gcx, 'container>>,\n-                for<'s> fn(&'s VariantDefData<'gcx, 'container>)\n-                    -> slice::Iter<'s, FieldDefData<'gcx, 'container>>\n-            > {\n-        self.variants.iter().flat_map(VariantDefData::fields_iter)\n+    pub fn all_fields<'s>(&'s self) -> impl Iterator<Item = &'s FieldDef> {\n+        self.variants.iter().flat_map(|v| v.fields.iter())\n     }\n \n     #[inline]\n@@ -1557,7 +1517,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n-    pub fn variant_with_id(&self, vid: DefId) -> &VariantDefData<'gcx, 'container> {\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n         self.variants\n             .iter()\n             .find(|v| v.did == vid)\n@@ -1571,7 +1531,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             .expect(\"variant_index_with_id: unknown variant\")\n     }\n \n-    pub fn variant_of_def(&self, def: Def) -> &VariantDefData<'gcx, 'container> {\n+    pub fn variant_of_def(&self, def: Def) -> &VariantDef {\n         match def {\n             Def::Variant(vid) | Def::VariantCtor(vid, ..) => self.variant_with_id(vid),\n             Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n@@ -1594,9 +1554,7 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'gcx, 'container> {\n             None => NoDtor,\n         }\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Returns a simpler type such that `Self: Sized` if and only\n     /// if that type is Sized, or `TyErr` if this type is recursive.\n     ///\n@@ -1615,19 +1573,9 @@ impl<'a, 'gcx, 'tcx, 'container> AdtDefData<'tcx, 'container> {\n     /// Due to normalization being eager, this applies even if\n     /// the associated type is behind a pointer, e.g. issue #31299.\n     pub fn sized_constraint(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Ty<'tcx> {\n-        match self.sized_constraint.get(DepNode::SizedConstraint(self.did)) {\n-            None => {\n-                let global_tcx = tcx.global_tcx();\n-                let this = global_tcx.lookup_adt_def_master(self.did);\n-                this.calculate_sized_constraint_inner(global_tcx, &mut Vec::new());\n-                self.sized_constraint(tcx)\n-            }\n-            Some(ty) => ty\n-        }\n+        self.calculate_sized_constraint_inner(tcx.global_tcx(), &mut Vec::new())\n     }\n-}\n \n-impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     /// Calculates the Sized-constraint.\n     ///\n     /// As the Sized-constraint of enums can be a *set* of types,\n@@ -1643,42 +1591,41 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     ///       such.\n     ///     - a TyError, if a type contained itself. The representability\n     ///       check should catch this case.\n-    fn calculate_sized_constraint_inner(&'tcx self,\n+    fn calculate_sized_constraint_inner(&self,\n                                         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        stack: &mut Vec<AdtDefMaster<'tcx>>)\n+                                        stack: &mut Vec<DefId>)\n+                                        -> Ty<'tcx>\n     {\n-        let dep_node = || DepNode::SizedConstraint(self.did);\n+        if let Some(ty) = tcx.adt_sized_constraint.borrow().get(&self.did) {\n+            return ty;\n+        }\n \n         // Follow the memoization pattern: push the computation of\n         // DepNode::SizedConstraint as our current task.\n-        let _task = tcx.dep_graph.in_task(dep_node());\n-        if self.sized_constraint.untracked_get().is_some() {\n-            //                   ---------------\n-            // can skip the dep-graph read since we just pushed the task\n-            return;\n-        }\n+        let _task = tcx.dep_graph.in_task(DepNode::SizedConstraint(self.did));\n \n-        if stack.contains(&self) {\n+        if stack.contains(&self.did) {\n             debug!(\"calculate_sized_constraint: {:?} is recursive\", self);\n             // This should be reported as an error by `check_representable`.\n             //\n             // Consider the type as Sized in the meanwhile to avoid\n             // further errors.\n-            self.sized_constraint.fulfill(dep_node(), tcx.types.err);\n-            return;\n+            tcx.adt_sized_constraint.borrow_mut().insert(self.did, tcx.types.err);\n+            return tcx.types.err;\n         }\n \n-        stack.push(self);\n+        stack.push(self.did);\n \n         let tys : Vec<_> =\n             self.variants.iter().flat_map(|v| {\n                 v.fields.last()\n             }).flat_map(|f| {\n-                self.sized_constraint_for_ty(tcx, stack, f.unsubst_ty())\n+                let ty = tcx.item_type(f.did);\n+                self.sized_constraint_for_ty(tcx, stack, ty)\n             }).collect();\n \n         let self_ = stack.pop().unwrap();\n-        assert_eq!(self_, self);\n+        assert_eq!(self_, self.did);\n \n         let ty = match tys.len() {\n             _ if tys.references_error() => tcx.types.err,\n@@ -1687,24 +1634,26 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n             _ => tcx.intern_tup(&tys[..])\n         };\n \n-        match self.sized_constraint.get(dep_node()) {\n+        let old = tcx.adt_sized_constraint.borrow().get(&self.did).cloned();\n+        match old {\n             Some(old_ty) => {\n                 debug!(\"calculate_sized_constraint: {:?} recurred\", self);\n-                assert_eq!(old_ty, tcx.types.err)\n+                assert_eq!(old_ty, tcx.types.err);\n+                old_ty\n             }\n             None => {\n                 debug!(\"calculate_sized_constraint: {:?} => {:?}\", self, ty);\n-                self.sized_constraint.fulfill(dep_node(), ty)\n+                tcx.adt_sized_constraint.borrow_mut().insert(self.did, ty);\n+                ty\n             }\n         }\n     }\n \n-    fn sized_constraint_for_ty(\n-        &'tcx self,\n-        tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-        stack: &mut Vec<AdtDefMaster<'tcx>>,\n-        ty: Ty<'tcx>\n-    ) -> Vec<Ty<'tcx>> {\n+    fn sized_constraint_for_ty(&self,\n+                               tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                               stack: &mut Vec<DefId>,\n+                               ty: Ty<'tcx>)\n+                               -> Vec<Ty<'tcx>> {\n         let result = match ty.sty {\n             TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n             TyBox(..) | TyRawPtr(..) | TyRef(..) | TyFnDef(..) | TyFnPtr(_) |\n@@ -1726,12 +1675,9 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n \n             TyAdt(adt, substs) => {\n                 // recursive case\n-                let adt = tcx.lookup_adt_def_master(adt.did);\n-                adt.calculate_sized_constraint_inner(tcx, stack);\n                 let adt_ty =\n-                    adt.sized_constraint\n-                    .unwrap(DepNode::SizedConstraint(adt.did))\n-                    .subst(tcx, substs);\n+                    adt.calculate_sized_constraint_inner(tcx, stack)\n+                       .subst(tcx, substs);\n                 debug!(\"sized_constraint_for_ty({:?}) intermediate = {:?}\",\n                        ty, adt_ty);\n                 if let ty::TyTuple(ref tys) = adt_ty.sty {\n@@ -1780,16 +1726,11 @@ impl<'a, 'tcx> AdtDefData<'tcx, 'tcx> {\n     }\n }\n \n-impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n-    #[inline]\n-    fn fields_iter(&self) -> slice::Iter<FieldDefData<'tcx, 'container>> {\n-        self.fields.iter()\n-    }\n-\n+impl<'a, 'gcx, 'tcx> VariantDef {\n     #[inline]\n     pub fn find_field_named(&self,\n                             name: ast::Name)\n-                            -> Option<&FieldDefData<'tcx, 'container>> {\n+                            -> Option<&FieldDef> {\n         self.fields.iter().find(|f| f.name == name)\n     }\n \n@@ -1801,55 +1742,32 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n     }\n \n     #[inline]\n-    pub fn field_named(&self, name: ast::Name) -> &FieldDefData<'tcx, 'container> {\n+    pub fn field_named(&self, name: ast::Name) -> &FieldDef {\n         self.find_field_named(name).unwrap()\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> VariantDefData<'tcx, 'static> {\n     #[inline]\n-    pub fn is_uninhabited_recurse(&'tcx self,\n+    pub fn is_uninhabited_recurse(&self,\n                                   visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                                   block: Option<NodeId>,\n-                                  cx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                  tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                                   substs: &'tcx Substs<'tcx>,\n                                   is_union: bool) -> bool {\n         if is_union {\n-            self.fields.iter().all(|f| f.is_uninhabited_recurse(visited, block, cx, substs))\n+            self.fields.iter().all(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n         } else {\n-            self.fields.iter().any(|f| f.is_uninhabited_recurse(visited, block, cx, substs))\n+            self.fields.iter().any(|f| f.is_uninhabited_recurse(visited, block, tcx, substs))\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx, 'container> FieldDefData<'tcx, 'container> {\n-    pub fn new(did: DefId,\n-               name: Name,\n-               vis: Visibility) -> Self {\n-        FieldDefData {\n-            did: did,\n-            name: name,\n-            vis: vis,\n-            ty: ivar::TyIVar::new()\n-        }\n-    }\n-\n+impl<'a, 'gcx, 'tcx> FieldDef {\n     pub fn ty(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, subst: &Substs<'tcx>) -> Ty<'tcx> {\n-        self.unsubst_ty().subst(tcx, subst)\n-    }\n-\n-    pub fn unsubst_ty(&self) -> Ty<'tcx> {\n-        self.ty.unwrap(DepNode::FieldTy(self.did))\n-    }\n-\n-    pub fn fulfill_ty(&self, ty: Ty<'container>) {\n-        self.ty.fulfill(DepNode::FieldTy(self.did), ty);\n+        tcx.item_type(self.did).subst(tcx, subst)\n     }\n-}\n \n-impl<'a, 'gcx, 'tcx> FieldDefData<'tcx, 'static> {\n     #[inline]\n-    pub fn is_uninhabited_recurse(&'tcx self,\n+    pub fn is_uninhabited_recurse(&self,\n                                   visited: &mut FxHashSet<(DefId, &'tcx Substs<'tcx>)>,\n                                   block: Option<NodeId>,\n                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n@@ -2295,7 +2213,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     // Returns `ty::VariantDef` if `def` refers to a struct,\n     // or variant or their constructors, panics otherwise.\n-    pub fn expect_variant_def(self, def: Def) -> VariantDef<'tcx> {\n+    pub fn expect_variant_def(self, def: Def) -> &'tcx VariantDef {\n         match def {\n             Def::Variant(did) | Def::VariantCtor(did, ..) => {\n                 let enum_did = self.parent_def_id(did).unwrap();\n@@ -2398,28 +2316,18 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     /// Given the did of a trait, returns its canonical trait ref.\n-    pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef<'gcx> {\n+    pub fn lookup_trait_def(self, did: DefId) -> &'gcx TraitDef {\n         lookup_locally_or_in_crate_store(\n             \"trait_defs\", did, &self.trait_defs,\n             || self.alloc_trait_def(self.sess.cstore.trait_def(self.global_tcx(), did))\n         )\n     }\n \n-    /// Given the did of an ADT, return a master reference to its\n-    /// definition. Unless you are planning on fulfilling the ADT's fields,\n-    /// use lookup_adt_def instead.\n-    pub fn lookup_adt_def_master(self, did: DefId) -> AdtDefMaster<'gcx> {\n+    /// Given the did of an ADT, return a reference to its definition.\n+    pub fn lookup_adt_def(self, did: DefId) -> &'gcx AdtDef {\n         lookup_locally_or_in_crate_store(\n             \"adt_defs\", did, &self.adt_defs,\n-            || self.sess.cstore.adt_def(self.global_tcx(), did)\n-        )\n-    }\n-\n-    /// Given the did of an ADT, return a reference to its definition.\n-    pub fn lookup_adt_def(self, did: DefId) -> AdtDef<'gcx> {\n-        // when reverse-variance goes away, a transmute::<AdtDefMaster,AdtDef>\n-        // would be needed here.\n-        self.lookup_adt_def_master(did)\n+            || self.sess.cstore.adt_def(self.global_tcx(), did))\n     }\n \n     /// Given the did of an item, returns its generics."}, {"sha": "59f774b954cf9017ed508ea8a38f88f43e756172", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -113,7 +113,7 @@ pub enum TypeVariants<'tcx> {\n     /// That is, even after substitution it is possible that there are type\n     /// variables. This happens when the `TyAdt` corresponds to an ADT\n     /// definition and not a concrete use of it.\n-    TyAdt(AdtDef<'tcx>, &'tcx Substs<'tcx>),\n+    TyAdt(&'tcx AdtDef, &'tcx Substs<'tcx>),\n \n     /// `Box<T>`; this is nominally a struct in the documentation, but is\n     /// special-cased internally. For example, it is possible to implicitly\n@@ -1267,7 +1267,7 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n         }\n     }\n \n-    pub fn ty_adt_def(&self) -> Option<AdtDef<'tcx>> {\n+    pub fn ty_adt_def(&self) -> Option<&'tcx AdtDef> {\n         match self.sty {\n             TyAdt(adt, _) => Some(adt),\n             _ => None"}, {"sha": "d6f61a12a3c6eb2ca8ad84ab7f6ec6d0303e33aa", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -165,6 +165,14 @@ impl<'tcx> Decodable for Kind<'tcx> {\n pub type Substs<'tcx> = Slice<Kind<'tcx>>;\n \n impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n+    /// Creates a Substs that maps each generic parameter to itself.\n+    pub fn identity_for_item(tcx: TyCtxt<'a, 'gcx, 'tcx>, def_id: DefId)\n+                             -> &'tcx Substs<'tcx> {\n+        Substs::for_item(tcx, def_id, |def, _| {\n+            tcx.mk_region(ty::ReEarlyBound(def.to_early_bound_region_data()))\n+        }, |def, _| tcx.mk_param_from_def(def))\n+    }\n+\n     /// Creates a Substs for generic parameter definitions,\n     /// by calling closures to obtain each region and type.\n     /// The closures get to observe the Substs as they're"}, {"sha": "c6d862b23bd5e393fc2bc67da607d37c730e7e7d", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -19,7 +19,9 @@ use hir;\n use util::nodemap::FxHashMap;\n \n /// A trait's definition with type information.\n-pub struct TraitDef<'tcx> {\n+pub struct TraitDef {\n+    pub def_id: DefId,\n+\n     pub unsafety: hir::Unsafety,\n \n     /// If `true`, then this trait had the `#[rustc_paren_sugar]`\n@@ -28,15 +30,6 @@ pub struct TraitDef<'tcx> {\n     /// be usable with the sugar (or without it).\n     pub paren_sugar: bool,\n \n-    /// Generic type definitions. Note that `Self` is listed in here\n-    /// as having a single bound, the trait itself (e.g., in the trait\n-    /// `Eq`, there is a single bound `Self : Eq`). This is so that\n-    /// default methods get to assume that the `Self` parameters\n-    /// implements the trait.\n-    pub generics: &'tcx ty::Generics<'tcx>,\n-\n-    pub trait_ref: ty::TraitRef<'tcx>,\n-\n     // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n     // simplified version of their `Self` type: impls with a simplifiable `Self`\n     // are stored in `nonblanket_impls` keyed by it, while all other impls are\n@@ -72,18 +65,16 @@ pub struct TraitDef<'tcx> {\n     pub def_path_hash: u64,\n }\n \n-impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n-    pub fn new(unsafety: hir::Unsafety,\n+impl<'a, 'gcx, 'tcx> TraitDef {\n+    pub fn new(def_id: DefId,\n+               unsafety: hir::Unsafety,\n                paren_sugar: bool,\n-               generics: &'tcx ty::Generics<'tcx>,\n-               trait_ref: ty::TraitRef<'tcx>,\n                def_path_hash: u64)\n-               -> TraitDef<'tcx> {\n+               -> TraitDef {\n         TraitDef {\n+            def_id: def_id,\n             paren_sugar: paren_sugar,\n             unsafety: unsafety,\n-            generics: generics,\n-            trait_ref: trait_ref,\n             nonblanket_impls: RefCell::new(FxHashMap()),\n             blanket_impls: RefCell::new(vec![]),\n             flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n@@ -92,10 +83,6 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n         }\n     }\n \n-    pub fn def_id(&self) -> DefId {\n-        self.trait_ref.def_id\n-    }\n-\n     // returns None if not yet calculated\n     pub fn object_safety(&self) -> Option<bool> {\n         if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n@@ -117,11 +104,11 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     }\n \n     fn write_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.write(DepNode::TraitImpls(self.trait_ref.def_id));\n+        tcx.dep_graph.write(DepNode::TraitImpls(self.def_id));\n     }\n \n     fn read_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.read(DepNode::TraitImpls(self.trait_ref.def_id));\n+        tcx.dep_graph.read(DepNode::TraitImpls(self.def_id));\n     }\n \n     /// Records a basic trait-to-implementation mapping.\n@@ -203,13 +190,13 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n             .insert(tcx, impl_def_id)\n     }\n \n-    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a, 'tcx> {\n+    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a> {\n         specialization_graph::ancestors(self, of_impl)\n     }\n \n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n         self.read_trait_impls(tcx);\n-        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n+        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n             f(impl_def_id);\n@@ -231,7 +218,7 @@ impl<'a, 'gcx, 'tcx> TraitDef<'tcx> {\n     {\n         self.read_trait_impls(tcx);\n \n-        tcx.populate_implementations_for_trait_if_necessary(self.trait_ref.def_id);\n+        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n \n         for &impl_def_id in self.blanket_impls.borrow().iter() {\n             f(impl_def_id);"}, {"sha": "6bb9d67db6f6579c2fca495fb01e162c22b8ee53", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -366,7 +366,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// `adt` that do not strictly outlive the adt value itself.\n     /// (This allows programs to make cyclic structures without\n     /// resorting to unasfe means; see RFCs 769 and 1238).\n-    pub fn is_adt_dtorck(self, adt: ty::AdtDef) -> bool {\n+    pub fn is_adt_dtorck(self, adt: &ty::AdtDef) -> bool {\n         let dtor_method = match adt.destructor() {\n             Some(dtor) => dtor,\n             None => return false\n@@ -773,7 +773,7 @@ impl<'a, 'tcx> ty::TyS<'tcx> {\n             }\n         }\n \n-        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: ty::AdtDef<'tcx>) -> bool {\n+        fn same_struct_or_enum<'tcx>(ty: Ty<'tcx>, def: &'tcx ty::AdtDef) -> bool {\n             match ty.sty {\n                 TyAdt(ty_def, _) => {\n                      ty_def == def"}, {"sha": "b4c87e0ce426e18515c7b7bdcb6d7b252e3abd3f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -388,14 +388,15 @@ impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitDef<'tcx> {\n+impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TraitDef(generics={:?}, trait_ref={:?})\",\n-               self.generics, self.trait_ref)\n+        ty::tls::with(|tcx| {\n+            write!(f, \"{}\", tcx.item_path_str(self.def_id))\n+        })\n     }\n }\n \n-impl<'tcx, 'container> fmt::Debug for ty::AdtDefData<'tcx, 'container> {\n+impl fmt::Debug for ty::AdtDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| {\n             write!(f, \"{}\", tcx.item_path_str(self.did))"}, {"sha": "4f49bfc9725b345078da7699fe1b680b9a5cfd31", "filename": "src/librustc_borrowck/borrowck/mir/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Felaborate_drops.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -442,7 +442,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn move_paths_for_fields(&self,\n                              base_lv: &Lvalue<'tcx>,\n                              variant_path: MovePathIndex,\n-                             variant: ty::VariantDef<'tcx>,\n+                             variant: &'tcx ty::VariantDef,\n                              substs: &'tcx Substs<'tcx>)\n                              -> Vec<(Lvalue<'tcx>, Option<MovePathIndex>)>\n     {\n@@ -619,7 +619,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     fn open_drop_for_variant<'a>(&mut self,\n                                  c: &DropCtxt<'a, 'tcx>,\n                                  drop_block: &mut Option<BasicBlock>,\n-                                 adt: ty::AdtDef<'tcx>,\n+                                 adt: &'tcx ty::AdtDef,\n                                  substs: &'tcx Substs<'tcx>,\n                                  variant_index: usize)\n                                  -> BasicBlock\n@@ -652,7 +652,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn open_drop_for_adt<'a>(&mut self, c: &DropCtxt<'a, 'tcx>,\n-                             adt: ty::AdtDef<'tcx>, substs: &'tcx Substs<'tcx>)\n+                             adt: &'tcx ty::AdtDef, substs: &'tcx Substs<'tcx>)\n                              -> BasicBlock {\n         debug!(\"open_drop_for_adt({:?}, {:?}, {:?})\", c, adt, substs);\n "}, {"sha": "23771f4bae3dc109cb81e6b0383443c421f344ba", "filename": "src/librustc_const_eval/_match.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -223,10 +223,8 @@ pub enum Constructor {\n     Slice(usize),\n }\n \n-impl Constructor {\n-    fn variant_for_adt<'tcx, 'container, 'a>(&self,\n-                                             adt: &'a ty::AdtDefData<'tcx, 'container>)\n-                                             -> &'a ty::VariantDefData<'tcx, 'container> {\n+impl<'tcx> Constructor {\n+    fn variant_for_adt(&self, adt: &'tcx ty::AdtDef) -> &'tcx ty::VariantDef {\n         match self {\n             &Variant(vid) => adt.variant_with_id(vid),\n             &Single => {"}, {"sha": "e93178c89c22b865b20cc054b73883b806c4ea19", "filename": "src/librustc_const_eval/pattern.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_const_eval%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_const_eval%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fpattern.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -66,7 +66,7 @@ pub enum PatternKind<'tcx> {\n \n     /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n     Variant {\n-        adt_def: AdtDef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n         variant_index: usize,\n         subpatterns: Vec<FieldPattern<'tcx>>,\n     },\n@@ -487,32 +487,22 @@ impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Option<T> {\n     }\n }\n \n-macro_rules! CopyImpls {\n-    ($($ty:ty),+) => {\n+macro_rules! CloneImpls {\n+    (<$lt_tcx:tt> $($ty:ty),+) => {\n         $(\n-            impl<'tcx> PatternFoldable<'tcx> for $ty {\n-                fn super_fold_with<F: PatternFolder<'tcx>>(&self, _: &mut F) -> Self {\n-                    self.clone()\n-                }\n-            }\n-            )+\n-    }\n-}\n-\n-macro_rules! TcxCopyImpls {\n-    ($($ty:ident),+) => {\n-        $(\n-            impl<'tcx> PatternFoldable<'tcx> for $ty<'tcx> {\n-                fn super_fold_with<F: PatternFolder<'tcx>>(&self, _: &mut F) -> Self {\n-                    *self\n+            impl<$lt_tcx> PatternFoldable<$lt_tcx> for $ty {\n+                fn super_fold_with<F: PatternFolder<$lt_tcx>>(&self, _: &mut F) -> Self {\n+                    Clone::clone(self)\n                 }\n             }\n         )+\n     }\n }\n \n-CopyImpls!{ Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal }\n-TcxCopyImpls!{ Ty, BindingMode, AdtDef }\n+CloneImpls!{ <'tcx>\n+    Span, Field, Mutability, ast::Name, ast::NodeId, usize, ConstVal,\n+    Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef\n+}\n \n impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n     fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {"}, {"sha": "bba31c8237d18a721a0881659995487125ee2ac9", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -396,7 +396,7 @@ enum FfiResult {\n /// expanded to cover NonZero raw pointers and newtypes.\n /// FIXME: This duplicates code in trans.\n fn is_repr_nullable_ptr<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  def: ty::AdtDef<'tcx>,\n+                                  def: &'tcx ty::AdtDef,\n                                   substs: &Substs<'tcx>)\n                                   -> bool {\n     if def.variants.len() == 2 {"}, {"sha": "3150f74e61e7c9f1c9fb4f120a9ee7123d7305dc", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -115,13 +115,13 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         self.get_crate_data(def_id.krate).get_item_attrs(def_id.index)\n     }\n \n-    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef<'tcx>\n+    fn trait_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::TraitDef\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_trait_def(def.index, tcx)\n     }\n \n-    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> ty::AdtDefMaster<'tcx>\n+    fn adt_def<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>, def: DefId) -> &'tcx ty::AdtDef\n     {\n         self.dep_graph.read(DepNode::MetaData(def));\n         self.get_crate_data(def.krate).get_adt_def(def.index, tcx)"}, {"sha": "fe536b69c61d5a94d7d782f5c1137316e10840ec", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 22, "deletions": 41, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -422,8 +422,8 @@ impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::BareFnTy<'tcx>> for DecodeContext<'a\n     }\n }\n \n-impl<'a, 'tcx> SpecializedDecoder<ty::AdtDef<'tcx>> for DecodeContext<'a, 'tcx> {\n-    fn specialized_decode(&mut self) -> Result<ty::AdtDef<'tcx>, Self::Error> {\n+impl<'a, 'tcx> SpecializedDecoder<&'tcx ty::AdtDef> for DecodeContext<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n         let def_id = DefId::decode(self)?;\n         Ok(self.tcx().lookup_adt_def(def_id))\n     }\n@@ -557,52 +557,49 @@ impl<'a, 'tcx> CrateMetadata {\n     pub fn get_trait_def(&self,\n                          item_id: DefIndex,\n                          tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                         -> ty::TraitDef<'tcx> {\n+                         -> ty::TraitDef {\n         let data = match self.entry(item_id).kind {\n             EntryKind::Trait(data) => data.decode(self),\n             _ => bug!(),\n         };\n \n-        ty::TraitDef::new(data.unsafety,\n+        ty::TraitDef::new(self.local_def_id(item_id),\n+                          data.unsafety,\n                           data.paren_sugar,\n-                          tcx.item_generics(self.local_def_id(item_id)),\n-                          data.trait_ref.decode((self, tcx)),\n                           self.def_path(item_id).unwrap().deterministic_hash(tcx))\n     }\n \n     fn get_variant(&self,\n                    item: &Entry<'tcx>,\n                    index: DefIndex)\n-                   -> (ty::VariantDefData<'tcx, 'tcx>, Option<DefIndex>) {\n+                   -> (ty::VariantDef, Option<DefIndex>) {\n         let data = match item.kind {\n             EntryKind::Variant(data) |\n             EntryKind::Struct(data) |\n             EntryKind::Union(data) => data.decode(self),\n             _ => bug!(),\n         };\n \n-        let fields = item.children\n-            .decode(self)\n-            .map(|index| {\n+        (ty::VariantDef {\n+            did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n+            name: self.item_name(item),\n+            fields: item.children.decode(self).map(|index| {\n                 let f = self.entry(index);\n-                ty::FieldDefData::new(self.local_def_id(index), self.item_name(&f), f.visibility)\n-            })\n-            .collect();\n-\n-        (ty::VariantDefData {\n-             did: self.local_def_id(data.struct_ctor.unwrap_or(index)),\n-             name: self.item_name(item),\n-             fields: fields,\n-             disr_val: ConstInt::Infer(data.disr),\n-             ctor_kind: data.ctor_kind,\n-         },\n-         data.struct_ctor)\n+                ty::FieldDef {\n+                    did: self.local_def_id(index),\n+                    name: self.item_name(&f),\n+                    vis: f.visibility\n+                }\n+            }).collect(),\n+            disr_val: ConstInt::Infer(data.disr),\n+            ctor_kind: data.ctor_kind,\n+        }, data.struct_ctor)\n     }\n \n     pub fn get_adt_def(&self,\n                        item_id: DefIndex,\n                        tcx: TyCtxt<'a, 'tcx, 'tcx>)\n-                       -> ty::AdtDefMaster<'tcx> {\n+                       -> &'tcx ty::AdtDef {\n         let item = self.entry(item_id);\n         let did = self.local_def_id(item_id);\n         let mut ctor_index = None;\n@@ -627,26 +624,10 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => bug!(\"get_adt_def called on a non-ADT {:?}\", did),\n         };\n \n-        let adt = tcx.intern_adt_def(did, kind, variants);\n+        let adt = tcx.alloc_adt_def(did, kind, variants);\n         if let Some(ctor_index) = ctor_index {\n             // Make adt definition available through constructor id as well.\n-            tcx.insert_adt_def(self.local_def_id(ctor_index), adt);\n-        }\n-\n-        // this needs to be done *after* the variant is interned,\n-        // to support recursive structures\n-        for variant in &adt.variants {\n-            for field in &variant.fields {\n-                debug!(\"evaluating the type of {:?}::{:?}\",\n-                       variant.name,\n-                       field.name);\n-                let ty = self.get_type(field.did.index, tcx);\n-                field.fulfill_ty(ty);\n-                debug!(\"evaluating the type of {:?}::{:?}: {:?}\",\n-                       variant.name,\n-                       field.name,\n-                       ty);\n-            }\n+            tcx.adt_defs.borrow_mut().insert(self.local_def_id(ctor_index), adt);\n         }\n \n         adt"}, {"sha": "83904b24de328f02d1a87fa84104416b1a5800bd", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -736,7 +736,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     unsafety: trait_def.unsafety,\n                     paren_sugar: trait_def.paren_sugar,\n                     has_default_impl: tcx.trait_has_default_impl(def_id),\n-                    trait_ref: self.lazy(&trait_def.trait_ref),\n                     super_predicates: self.lazy(&tcx.item_super_predicates(def_id)),\n                 };\n "}, {"sha": "00c3709435de5de033f07be927dfa9747a1b1522", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -276,7 +276,6 @@ pub struct TraitData<'tcx> {\n     pub unsafety: hir::Unsafety,\n     pub paren_sugar: bool,\n     pub has_default_impl: bool,\n-    pub trait_ref: Lazy<ty::TraitRef<'tcx>>,\n     pub super_predicates: Lazy<ty::GenericPredicates<'tcx>>,\n }\n "}, {"sha": "e06d940de7e58238713e82d98a13846ae6ccb87f", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -301,7 +301,7 @@ pub struct MatchPair<'pat, 'tcx:'pat> {\n enum TestKind<'tcx> {\n     // test the branches of enum\n     Switch {\n-        adt_def: AdtDef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n         variants: BitVector,\n     },\n "}, {"sha": "cb449037aeba3eb9f610ec8ae32c8c095fd29b3c", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -615,7 +615,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     fn candidate_after_variant_switch<'pat>(&mut self,\n                                             match_pair_index: usize,\n-                                            adt_def: ty::AdtDef<'tcx>,\n+                                            adt_def: &'tcx ty::AdtDef,\n                                             variant_index: usize,\n                                             subpatterns: &'pat [FieldPattern<'tcx>],\n                                             candidate: &Candidate<'pat, 'tcx>)"}, {"sha": "e850f6c4b045cab7a9fcbdfa6d2921dc293dba0a", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -1003,7 +1003,7 @@ fn capture_freevar<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n }\n \n /// Converts a list of named fields (i.e. for struct-like struct/enum ADTs) into FieldExprRef.\n-fn field_refs<'tcx>(variant: VariantDef<'tcx>,\n+fn field_refs<'tcx>(variant: &'tcx VariantDef,\n                     fields: &'tcx [hir::Field])\n                     -> Vec<FieldExprRef<'tcx>>\n {"}, {"sha": "e7a6b40c830bdf4fbaf8be7ac228692b68ff67c2", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -155,11 +155,11 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         bug!(\"found no method `{}` in `{:?}`\", method_name, trait_def_id);\n     }\n \n-    pub fn num_variants(&mut self, adt_def: ty::AdtDef) -> usize {\n+    pub fn num_variants(&mut self, adt_def: &ty::AdtDef) -> usize {\n         adt_def.variants.len()\n     }\n \n-    pub fn all_fields(&mut self, adt_def: ty::AdtDef, variant_index: usize) -> Vec<Field> {\n+    pub fn all_fields(&mut self, adt_def: &ty::AdtDef, variant_index: usize) -> Vec<Field> {\n         (0..adt_def.variants[variant_index].fields.len())\n             .map(Field::new)\n             .collect()"}, {"sha": "22c07f1903bacf4fbba9fef9c00ee6db88b4386e", "filename": "src/librustc_mir/hair/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_mir%2Fhair%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fmod.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -221,7 +221,7 @@ pub enum ExprKind<'tcx> {\n         fields: Vec<ExprRef<'tcx>>,\n     },\n     Adt {\n-        adt_def: AdtDef<'tcx>,\n+        adt_def: &'tcx AdtDef,\n         variant_index: usize,\n         substs: &'tcx Substs<'tcx>,\n         fields: Vec<FieldExprRef<'tcx>>,"}, {"sha": "145b9176f6b131cf5de102db4b118e05ef77ce6d", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -405,7 +405,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     }\n \n     // Checks that a field is in scope.\n-    fn check_field(&mut self, span: Span, def: ty::AdtDef<'tcx>, field: ty::FieldDef<'tcx>) {\n+    fn check_field(&mut self, span: Span, def: &'tcx ty::AdtDef, field: &'tcx ty::FieldDef) {\n         if !def.is_enum() && !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n             struct_span_err!(self.tcx.sess, span, E0451, \"field `{}` of {} `{}` is private\",\n                       field.name, def.variant_descr(), self.tcx.item_path_str(def.did))"}, {"sha": "4cd28e0a46daf4b6f1752a37360c1aea85bead19", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -941,7 +941,7 @@ impl<'l, 'tcx: 'l, 'll, D: Dump + 'll> DumpVisitor<'l, 'tcx, 'll, D> {\n                           ex: &ast::Expr,\n                           path: &ast::Path,\n                           fields: &Vec<ast::Field>,\n-                          variant: ty::VariantDef,\n+                          variant: &ty::VariantDef,\n                           base: &Option<P<ast::Expr>>) {\n         self.write_sub_paths_truncated(path, false);\n "}, {"sha": "33b9f8c9034e884c79d65f893fbd71c753bf1269", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -621,7 +621,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n \n     pub fn get_field_ref_data(&self,\n                               field_ref: &ast::Field,\n-                              variant: ty::VariantDef,\n+                              variant: &ty::VariantDef,\n                               parent: NodeId)\n                               -> Option<VariableRefData> {\n         let f = variant.field_named(field_ref.ident.node.name);"}, {"sha": "087fe4decbf1d768c2bb7edaf991575182c4435f", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -803,9 +803,10 @@ fn find_drop_glue_neighbors<'a, 'tcx>(scx: &SharedCrateContext<'a, 'tcx>,\n         }\n         ty::TyAdt(adt_def, substs) => {\n             for field in adt_def.all_fields() {\n+                let field_type = scx.tcx().item_type(field.did);\n                 let field_type = monomorphize::apply_param_substs(scx,\n                                                                   substs,\n-                                                                  &field.unsubst_ty());\n+                                                                  &field_type);\n                 let field_type = glue::get_drop_glue_type(scx.tcx(), field_type);\n \n                 if glue::type_needs_drop(scx.tcx(), field_type) {"}, {"sha": "df0e1f1fc052a373da2ee905b47672ab7488bbf6", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -882,7 +882,7 @@ impl<'tcx> MemberDescriptionFactory<'tcx> {\n \n // Creates MemberDescriptions for the fields of a struct\n struct StructMemberDescriptionFactory<'tcx> {\n-    variant: ty::VariantDef<'tcx>,\n+    variant: &'tcx ty::VariantDef,\n     substs: &'tcx Substs<'tcx>,\n     is_simd: bool,\n     span: Span,\n@@ -1024,7 +1024,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n //=-----------------------------------------------------------------------------\n \n struct UnionMemberDescriptionFactory<'tcx> {\n-    variant: ty::VariantDef<'tcx>,\n+    variant: &'tcx ty::VariantDef,\n     substs: &'tcx Substs<'tcx>,\n     span: Span,\n }\n@@ -1338,7 +1338,7 @@ enum EnumDiscriminantInfo {\n fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    enum_type: Ty<'tcx>,\n                                    struct_def: &layout::Struct,\n-                                   variant: ty::VariantDef<'tcx>,\n+                                   variant: &'tcx ty::VariantDef,\n                                    discriminant_info: EnumDiscriminantInfo,\n                                    containing_scope: DIScope,\n                                    span: Span)\n@@ -1357,7 +1357,7 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ref l @ _ => bug!(\"This should be unreachable. Type is {:#?} layout is {:#?}\", enum_type, l)\n     };\n \n-    let mut field_tys = variant.fields.iter().map(|f: ty::FieldDef<'tcx>| {\n+    let mut field_tys = variant.fields.iter().map(|f| {\n         monomorphize::field_ty(cx.tcx(), &substs, f)\n     }).collect::<Vec<_>>();\n "}, {"sha": "90bc29c39e9b50ed7fd60ed531330feccb72ab8a", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -504,7 +504,7 @@ fn drop_structural_ty<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     fn iter_variant<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                 t: Ty<'tcx>,\n                                 av: adt::MaybeSizedValue,\n-                                variant: ty::VariantDef<'tcx>,\n+                                variant: &'tcx ty::VariantDef,\n                                 substs: &Substs<'tcx>)\n                                 -> Block<'blk, 'tcx> {\n         let _icx = push_ctxt(\"iter_variant\");"}, {"sha": "8f05cc793ef224f73b35f4eed64d3273b706874d", "filename": "src/librustc_trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_trans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_trans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmonomorphize.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -60,7 +60,7 @@ pub fn apply_param_substs<'a, 'tcx, T>(scx: &SharedCrateContext<'a, 'tcx>,\n /// Returns the normalized type of a struct field\n pub fn field_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                           param_substs: &Substs<'tcx>,\n-                          f: ty::FieldDef<'tcx>)\n+                          f: &'tcx ty::FieldDef)\n                           -> Ty<'tcx>\n {\n     tcx.normalize_associated_type(&f.ty(tcx, param_substs))"}, {"sha": "7d2019280e34a5c592a18a2dcabe94205c318461", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -93,7 +93,7 @@ pub trait AstConv<'gcx, 'tcx> {\n     /// Returns the `TraitDef` for a given trait. This allows you to\n     /// figure out the set of type parameters defined on the trait.\n     fn get_trait_def(&self, span: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>;\n+                     -> Result<&'tcx ty::TraitDef, ErrorReported>;\n \n     /// Ensure that the super-predicates for the trait with the given\n     /// id are available and also for the transitive set of"}, {"sha": "15f383c5787d534d22c8ab84b587b49c04dc53ed", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -626,7 +626,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                adt_ty: Ty<'tcx>,\n                                pat_id: ast::NodeId,\n                                span: Span,\n-                               variant: ty::VariantDef<'tcx>,\n+                               variant: &'tcx ty::VariantDef,\n                                fields: &'gcx [Spanned<hir::FieldPat>],\n                                etc: bool) {\n         let tcx = self.tcx;"}, {"sha": "e13c4ea314f06255634495d0d12ecaf5c28b456c", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -589,7 +589,7 @@ fn has_dtor_of_interest<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n //\n // then revises input: `Foo<'r,i64,&'r i64>` to: `Foo<'static,i64,()>`\n fn revise_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                  adt_def: ty::AdtDef<'tcx>,\n+                                  adt_def: &'tcx ty::AdtDef,\n                                   impl_def_id: DefId,\n                                   substs: &Substs<'tcx>)\n                                   -> Ty<'tcx> {"}, {"sha": "2e66f6290a022deb523097ab40adfbc17bdadd20", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -192,13 +192,6 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                m_name,\n                trait_def_id);\n \n-        let trait_def = self.tcx.lookup_trait_def(trait_def_id);\n-\n-        if let Some(ref input_types) = opt_input_types {\n-            assert_eq!(trait_def.generics.types.len() - 1, input_types.len());\n-        }\n-        assert!(trait_def.generics.regions.is_empty());\n-\n         // Construct a trait-reference `self_ty : Trait<input_tys>`\n         let substs = Substs::for_item(self.tcx,\n                                       trait_def_id,"}, {"sha": "1099d5b060ef56dafcd60303fbcd1487ab5b39de", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -1041,7 +1041,7 @@ fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                           trait_def: &ty::TraitDef<'tcx>,\n+                                           trait_def: &ty::TraitDef,\n                                            impl_id: DefId,\n                                            impl_item: &hir::ImplItem)\n {\n@@ -1401,7 +1401,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn get_trait_def(&self, _: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n+                     -> Result<&'tcx ty::TraitDef, ErrorReported>\n     {\n         Ok(self.tcx().lookup_trait_def(id))\n     }\n@@ -1987,7 +1987,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     // Indifferent to privacy flags\n     pub fn field_ty(&self,\n                     span: Span,\n-                    field: ty::FieldDef<'tcx>,\n+                    field: &'tcx ty::FieldDef,\n                     substs: &Substs<'tcx>)\n                     -> Ty<'tcx>\n     {\n@@ -3073,7 +3073,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     // Return an hint about the closest match in field names\n-    fn suggest_field_name(variant: ty::VariantDef<'tcx>,\n+    fn suggest_field_name(variant: &'tcx ty::VariantDef,\n                           field: &Spanned<ast::Name>,\n                           skip : Vec<InternedString>)\n                           -> Option<Symbol> {\n@@ -3166,7 +3166,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn report_unknown_field(&self,\n                             ty: Ty<'tcx>,\n-                            variant: ty::VariantDef<'tcx>,\n+                            variant: &'tcx ty::VariantDef,\n                             field: &hir::Field,\n                             skip_fields: &[hir::Field],\n                             kind_name: &str) {\n@@ -3210,7 +3210,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                 adt_ty: Ty<'tcx>,\n                                 expr_id: ast::NodeId,\n                                 span: Span,\n-                                variant: ty::VariantDef<'tcx>,\n+                                variant: &'tcx ty::VariantDef,\n                                 ast_fields: &'gcx [hir::Field],\n                                 check_completeness: bool) {\n         let tcx = self.tcx;\n@@ -3326,7 +3326,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn check_struct_path(&self,\n                              qpath: &hir::QPath,\n                              node_id: ast::NodeId)\n-                             -> Option<(ty::VariantDef<'tcx>,  Ty<'tcx>)> {\n+                             -> Option<(&'tcx ty::VariantDef,  Ty<'tcx>)> {\n         let path_span = match *qpath {\n             hir::QPath::Resolved(_, ref path) => path.span,\n             hir::QPath::TypeRelative(ref qself, _) => qself.span"}, {"sha": "7870b3677d0d0b53d3e1b2fa30886bdeadcc9095", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -285,12 +285,7 @@ impl<'ccx, 'gcx> CheckTypeWellFormedVisitor<'ccx, 'gcx> {\n                 }\n             });\n \n-        let trait_def = self.tcx().lookup_trait_def(trait_def_id);\n-\n-        let has_ty_params =\n-            trait_def.generics\n-                      .types\n-                      .len() > 1;\n+        let has_ty_params = self.tcx().item_generics(trait_def_id).types.len() > 1;\n \n         // We use an if-else here, since the generics will also trigger\n         // an extraneous error message when we find predicates like"}, {"sha": "f575d4d8bab7a5ddd51e48e549ba22e98808be0a", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -395,7 +395,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                             .filter_map(|(i, f)| {\n                                 let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n \n-                                if f.unsubst_ty().is_phantom_data() {\n+                                if tcx.item_type(f.did).is_phantom_data() {\n                                     // Ignore PhantomData fields\n                                     return None;\n                                 }"}, {"sha": "3bb7d6a77ba5c2efef02019d9e9ca79d9d305121", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 78, "deletions": 73, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -329,20 +329,21 @@ impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n     }\n \n     /// Loads the trait def for a given trait, returning ErrorReported if a cycle arises.\n-    fn get_trait_def(&self, trait_id: DefId)\n-                     -> &'tcx ty::TraitDef<'tcx>\n+    fn get_trait_def(&self, def_id: DefId)\n+                     -> &'tcx ty::TraitDef\n     {\n         let tcx = self.tcx;\n \n-        if let Some(trait_id) = tcx.map.as_local_node_id(trait_id) {\n+        if let Some(trait_id) = tcx.map.as_local_node_id(def_id) {\n             let item = match tcx.map.get(trait_id) {\n                 hir_map::NodeItem(item) => item,\n                 _ => bug!(\"get_trait_def({:?}): not an item\", trait_id)\n             };\n \n+            generics_of_def_id(self, def_id);\n             trait_def_of_item(self, &item)\n         } else {\n-            tcx.lookup_trait_def(trait_id)\n+            tcx.lookup_trait_def(def_id)\n         }\n     }\n \n@@ -392,7 +393,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n     }\n \n     fn get_trait_def(&self, span: Span, id: DefId)\n-                     -> Result<&'tcx ty::TraitDef<'tcx>, ErrorReported>\n+                     -> Result<&'tcx ty::TraitDef, ErrorReported>\n     {\n         self.ccx.cycle_check(span, AstConvRequest::GetTraitDef(id), || {\n             Ok(self.ccx.get_trait_def(id))\n@@ -616,10 +617,10 @@ fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            struct_generics: &'tcx ty::Generics<'tcx>,\n                            struct_predicates: &ty::GenericPredicates<'tcx>,\n                            field: &hir::StructField,\n-                           ty_f: ty::FieldDefMaster<'tcx>)\n+                           ty_f: &'tcx ty::FieldDef)\n {\n     let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &field.ty);\n-    ty_f.fulfill_ty(tt);\n+    ccx.tcx.item_types.borrow_mut().insert(ty_f.did, tt);\n \n     let def_id = ccx.tcx.map.local_def_id(field.id);\n     ccx.tcx.item_types.borrow_mut().insert(def_id, tt);\n@@ -716,6 +717,7 @@ fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", it.name, it.id);\n+    let def_id = ccx.tcx.map.local_def_id(it.id);\n     match it.node {\n         // These don't define types.\n         hir::ItemExternCrate(_) | hir::ItemUse(..) | hir::ItemMod(_) => {\n@@ -726,12 +728,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             }\n         }\n         hir::ItemEnum(ref enum_definition, _) => {\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n             let ty = type_of_def_id(ccx, def_id);\n             let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n             convert_enum_variant_types(ccx,\n-                                       tcx.lookup_adt_def_master(ccx.tcx.map.local_def_id(it.id)),\n+                                       tcx.lookup_adt_def(ccx.tcx.map.local_def_id(it.id)),\n                                        ty,\n                                        generics,\n                                        predicates,\n@@ -756,7 +757,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                       _) => {\n             // Create generics from the generics specified in the impl head.\n             debug!(\"convert: ast_generics={:?}\", generics);\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n             generics_of_def_id(ccx, def_id);\n             let mut ty_predicates =\n                 ty_generic_predicates(ccx, generics, None, vec![], false);\n@@ -786,8 +786,8 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n         },\n         hir::ItemTrait(.., ref trait_items) => {\n-            let trait_def = trait_def_of_item(ccx, it);\n-            let def_id = trait_def.trait_ref.def_id;\n+            generics_of_def_id(ccx, def_id);\n+            trait_def_of_item(ccx, it);\n             let _: Result<(), ErrorReported> = // any error is already reported, can ignore\n                 ccx.ensure_super_predicates(it.span, def_id);\n             convert_trait_predicates(ccx, it);\n@@ -838,12 +838,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         },\n         hir::ItemStruct(ref struct_def, _) |\n         hir::ItemUnion(ref struct_def, _) => {\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n             let ty = type_of_def_id(ccx, def_id);\n             let generics = generics_of_def_id(ccx, def_id);\n             let predicates = predicates_of_item(ccx, it);\n \n-            let variant = tcx.lookup_adt_def_master(def_id).struct_variant();\n+            let variant = tcx.lookup_adt_def(def_id).struct_variant();\n \n             for (f, ty_f) in struct_def.fields().iter().zip(variant.fields.iter()) {\n                 convert_field(ccx, generics, &predicates, f, ty_f)\n@@ -855,13 +854,11 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n         },\n         hir::ItemTy(_, ref generics) => {\n             ensure_no_ty_param_bounds(ccx, it.span, generics, \"type\");\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n             type_of_def_id(ccx, def_id);\n             generics_of_def_id(ccx, def_id);\n             predicates_of_item(ccx, it);\n         },\n         _ => {\n-            let def_id = ccx.tcx.map.local_def_id(it.id);\n             type_of_def_id(ccx, def_id);\n             generics_of_def_id(ccx, def_id);\n             predicates_of_item(ccx, it);\n@@ -914,7 +911,7 @@ fn convert_impl_item(ccx: &CrateCtxt, impl_item: &hir::ImplItem) {\n \n fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   ctor_id: ast::NodeId,\n-                                  variant: ty::VariantDef<'tcx>,\n+                                  variant: &'tcx ty::VariantDef,\n                                   ty: Ty<'tcx>,\n                                   predicates: ty::GenericPredicates<'tcx>) {\n     let tcx = ccx.tcx;\n@@ -926,7 +923,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             let inputs: Vec<_> =\n                 variant.fields\n                 .iter()\n-                .map(|field| field.unsubst_ty())\n+                .map(|field| tcx.item_type(field.did))\n                 .collect();\n             let substs = mk_item_substs(&ccx.icx(&predicates),\n                                         ccx.tcx.map.span(ctor_id), def_id);\n@@ -946,7 +943,7 @@ fn convert_variant_ctor<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n }\n \n fn convert_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                                        def: ty::AdtDefMaster<'tcx>,\n+                                        def: &'tcx ty::AdtDef,\n                                         ty: Ty<'tcx>,\n                                         generics: &'tcx ty::Generics<'tcx>,\n                                         predicates: ty::GenericPredicates<'tcx>,\n@@ -974,7 +971,7 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     name: ast::Name,\n                                     disr_val: ty::Disr,\n                                     def: &hir::VariantData)\n-                                    -> ty::VariantDefData<'tcx, 'tcx> {\n+                                    -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<ast::Name, Span> = FxHashMap();\n     let node_id = ccx.tcx.map.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n@@ -991,10 +988,13 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             seen_fields.insert(f.name, f.span);\n         }\n \n-        ty::FieldDefData::new(fid, f.name,\n-            ty::Visibility::from_hir(&f.vis, node_id, ccx.tcx))\n+        ty::FieldDef {\n+            did: fid,\n+            name: f.name,\n+            vis: ty::Visibility::from_hir(&f.vis, node_id, ccx.tcx)\n+        }\n     }).collect();\n-    ty::VariantDefData {\n+    ty::VariantDef {\n         did: did,\n         name: name,\n         disr_val: disr_val,\n@@ -1006,29 +1006,34 @@ fn convert_struct_variant<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn convert_struct_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &hir::Item,\n                                 def: &hir::VariantData)\n-                                -> ty::AdtDefMaster<'tcx>\n+                                -> &'tcx ty::AdtDef\n {\n     let did = ccx.tcx.map.local_def_id(it.id);\n     // Use separate constructor id for unit/tuple structs and reuse did for braced structs.\n     let ctor_id = if !def.is_struct() { Some(ccx.tcx.map.local_def_id(def.id())) } else { None };\n     let variants = vec![convert_struct_variant(ccx, ctor_id.unwrap_or(did), it.name,\n                                                ConstInt::Infer(0), def)];\n-    let adt = ccx.tcx.intern_adt_def(did, AdtKind::Struct, variants);\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Struct, variants);\n     if let Some(ctor_id) = ctor_id {\n         // Make adt definition available through constructor id as well.\n-        ccx.tcx.insert_adt_def(ctor_id, adt);\n+        ccx.tcx.adt_defs.borrow_mut().insert(ctor_id, adt);\n     }\n+\n+    ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n     adt\n }\n \n fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &hir::Item,\n                                 def: &hir::VariantData)\n-                                -> ty::AdtDefMaster<'tcx>\n+                                -> &'tcx ty::AdtDef\n {\n     let did = ccx.tcx.map.local_def_id(it.id);\n     let variants = vec![convert_struct_variant(ccx, did, it.name, ConstInt::Infer(0), def)];\n-    ccx.tcx.intern_adt_def(did, AdtKind::Union, variants)\n+\n+    let adt = ccx.tcx.alloc_adt_def(did, AdtKind::Union, variants);\n+    ccx.tcx.adt_defs.borrow_mut().insert(did, adt);\n+    adt\n }\n \n     fn evaluate_disr_expr(ccx: &CrateCtxt, repr_ty: attr::IntType, e: &hir::Expr)\n@@ -1082,7 +1087,7 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               it: &hir::Item,\n                               def: &hir::EnumDef)\n-                              -> ty::AdtDefMaster<'tcx>\n+                              -> &'tcx ty::AdtDef\n {\n     let tcx = ccx.tcx;\n     let did = tcx.map.local_def_id(it.id);\n@@ -1110,7 +1115,10 @@ fn convert_enum_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         let did = tcx.map.local_def_id(v.node.data.id());\n         convert_struct_variant(ccx, did, v.node.name, disr, &v.node.data)\n     }).collect();\n-    tcx.intern_adt_def(tcx.map.local_def_id(it.id), AdtKind::Enum, variants)\n+\n+    let adt = tcx.alloc_adt_def(did, AdtKind::Enum, variants);\n+    tcx.adt_defs.borrow_mut().insert(did, adt);\n+    adt\n }\n \n /// Ensures that the super-predicates of the trait with def-id\n@@ -1155,10 +1163,15 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n         // In-scope when converting the superbounds for `Trait` are\n         // that `Self:Trait` as well as any bounds that appear on the\n         // generic types:\n-        let trait_def = trait_def_of_item(ccx, item);\n+        generics_of_def_id(ccx, trait_def_id);\n+        trait_def_of_item(ccx, item);\n+        let trait_ref = ty::TraitRef {\n+            def_id: trait_def_id,\n+            substs: Substs::identity_for_item(tcx, trait_def_id)\n+        };\n         let self_predicate = ty::GenericPredicates {\n             parent: None,\n-            predicates: vec![trait_def.trait_ref.to_predicate()]\n+            predicates: vec![trait_ref.to_predicate()]\n         };\n         let scope = &(generics, &self_predicate);\n \n@@ -1203,54 +1216,41 @@ fn ensure_super_predicates_step(ccx: &CrateCtxt,\n     def_ids\n }\n \n-fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n-                               it: &hir::Item)\n-                               -> &'tcx ty::TraitDef<'tcx>\n-{\n+fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) -> &'tcx ty::TraitDef {\n     let def_id = ccx.tcx.map.local_def_id(it.id);\n     let tcx = ccx.tcx;\n \n-    if let Some(def) = tcx.trait_defs.borrow().get(&def_id) {\n-        return def.clone();\n-    }\n+    tcx.trait_defs.memoize(def_id, || {\n+        let unsafety = match it.node {\n+            hir::ItemTrait(unsafety, ..) => unsafety,\n+            _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n+        };\n \n-    let (unsafety, generics) = match it.node {\n-        hir::ItemTrait(unsafety, ref generics, _, _) => {\n-            (unsafety, generics)\n+        let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n+        if paren_sugar && !ccx.tcx.sess.features.borrow().unboxed_closures {\n+            let mut err = ccx.tcx.sess.struct_span_err(\n+                it.span,\n+                \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n+                which traits can use parenthetical notation\");\n+            help!(&mut err,\n+                \"add `#![feature(unboxed_closures)]` to \\\n+                the crate attributes to use it\");\n+            err.emit();\n         }\n-        _ => span_bug!(it.span, \"trait_def_of_item invoked on non-trait\"),\n-    };\n-\n-    let paren_sugar = tcx.has_attr(def_id, \"rustc_paren_sugar\");\n-    if paren_sugar && !ccx.tcx.sess.features.borrow().unboxed_closures {\n-        let mut err = ccx.tcx.sess.struct_span_err(\n-            it.span,\n-            \"the `#[rustc_paren_sugar]` attribute is a temporary means of controlling \\\n-             which traits can use parenthetical notation\");\n-        help!(&mut err,\n-            \"add `#![feature(unboxed_closures)]` to \\\n-             the crate attributes to use it\");\n-        err.emit();\n-    }\n-\n-    let ty_generics = generics_of_def_id(ccx, def_id);\n-    let substs = mk_item_substs(&ccx.icx(generics), it.span, def_id);\n-\n-    let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n \n-    let trait_ref = ty::TraitRef::new(def_id, substs);\n-    let trait_def = ty::TraitDef::new(unsafety, paren_sugar, ty_generics, trait_ref,\n-                                      def_path_hash);\n-\n-    tcx.intern_trait_def(trait_def)\n+        let def_path_hash = tcx.def_path(def_id).deterministic_hash(tcx);\n+        tcx.alloc_trait_def(ty::TraitDef::new(def_id, unsafety, paren_sugar, def_path_hash))\n+    })\n }\n \n fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item) {\n     let tcx = ccx.tcx;\n-    let trait_def = trait_def_of_item(ccx, it);\n \n     let def_id = ccx.tcx.map.local_def_id(it.id);\n \n+    generics_of_def_id(ccx, def_id);\n+    trait_def_of_item(ccx, it);\n+\n     let (generics, items) = match it.node {\n         hir::ItemTrait(_, ref generics, _, ref items) => (generics, items),\n         ref s => {\n@@ -1272,7 +1272,11 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n \n     // Add in a predicate that `Self:Trait` (where `Trait` is the\n     // current trait).  This is needed for builtin bounds.\n-    let self_predicate = trait_def.trait_ref.to_poly_trait_ref().to_predicate();\n+    let trait_ref = ty::TraitRef {\n+        def_id: def_id,\n+        substs: Substs::identity_for_item(tcx, def_id)\n+    };\n+    let self_predicate = trait_ref.to_poly_trait_ref().to_predicate();\n     base_predicates.push(self_predicate);\n \n     // add in the explicit where-clauses\n@@ -1282,7 +1286,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &hir::Item)\n     let assoc_predicates = predicates_for_associated_types(ccx,\n                                                            generics,\n                                                            &trait_predicates,\n-                                                           trait_def.trait_ref,\n+                                                           trait_ref,\n                                                            items);\n     trait_predicates.predicates.extend(assoc_predicates);\n \n@@ -1581,7 +1585,10 @@ fn type_of_def_id<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n             NodeExpr(&hir::Expr { node: hir::ExprClosure(..), .. }) => {\n                 ccx.tcx.mk_closure(def_id, Substs::for_item(\n                     ccx.tcx, def_id,\n-                    |def, _| ccx.tcx.mk_region(def.to_early_bound_region()),\n+                    |def, _| {\n+                        let region = def.to_early_bound_region_data();\n+                        ccx.tcx.mk_region(ty::ReEarlyBound(region))\n+                    },\n                     |def, _| ccx.tcx.mk_param_from_def(def)\n                 ))\n             }\n@@ -2096,7 +2103,5 @@ pub fn mk_item_substs<'gcx: 'tcx, 'tcx>(astconv: &AstConv<'gcx, 'tcx>,\n         bug!(\"ErrorReported returned, but no errors reports?\")\n     }\n \n-    Substs::for_item(tcx, def_id,\n-                     |def, _| tcx.mk_region(def.to_early_bound_region()),\n-                     |def, _| tcx.mk_param_from_def(def))\n+    Substs::identity_for_item(tcx, def_id)\n }"}, {"sha": "ded9df25d5c665e96472c6c476931ec3892c7feb", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -92,14 +92,18 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n \n                 for field in tcx.lookup_adt_def(did).all_fields() {\n                     self.add_constraints_from_ty(generics,\n-                                                 field.unsubst_ty(),\n+                                                 tcx.item_type(field.did),\n                                                  self.covariant);\n                 }\n             }\n             hir::ItemTrait(..) => {\n-                let trait_def = tcx.lookup_trait_def(did);\n-                self.add_constraints_from_trait_ref(&trait_def.generics,\n-                                                    trait_def.trait_ref,\n+                let generics = tcx.item_generics(did);\n+                let trait_ref = ty::TraitRef {\n+                    def_id: did,\n+                    substs: Substs::identity_for_item(tcx, did)\n+                };\n+                self.add_constraints_from_trait_ref(generics,\n+                                                    trait_ref,\n                                                     self.invariant);\n             }\n \n@@ -279,7 +283,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                trait_ref,\n                variance);\n \n-        let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n+        let trait_generics = self.tcx().item_generics(trait_ref.def_id);\n \n         // This edge is actually implied by the call to\n         // `lookup_trait_def`, but I'm trying to be future-proof. See\n@@ -288,8 +292,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n         self.add_constraints_from_substs(generics,\n                                          trait_ref.def_id,\n-                                         &trait_def.generics.types,\n-                                         &trait_def.generics.regions,\n+                                         &trait_generics.types,\n+                                         &trait_generics.regions,\n                                          trait_ref.substs,\n                                          variance);\n     }\n@@ -356,7 +360,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::TyProjection(ref data) => {\n                 let trait_ref = &data.trait_ref;\n-                let trait_def = self.tcx().lookup_trait_def(trait_ref.def_id);\n+                let trait_generics = self.tcx().item_generics(trait_ref.def_id);\n \n                 // This edge is actually implied by the call to\n                 // `lookup_trait_def`, but I'm trying to be future-proof. See\n@@ -365,8 +369,8 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n                 self.add_constraints_from_substs(generics,\n                                                  trait_ref.def_id,\n-                                                 &trait_def.generics.types,\n-                                                 &trait_def.generics.regions,\n+                                                 &trait_generics.types,\n+                                                 &trait_generics.regions,\n                                                  trait_ref.substs,\n                                                  variance);\n             }"}, {"sha": "94e9fdbfc3e2ce703ef67bd07c1d82820e5ff1b8", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -151,14 +151,13 @@ pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n }\n \n pub fn build_external_trait(cx: &DocContext, did: DefId) -> clean::Trait {\n-    let def = cx.tcx.lookup_trait_def(did);\n     let trait_items = cx.tcx.associated_items(did).map(|item| item.clean(cx)).collect();\n     let predicates = cx.tcx.item_predicates(did);\n-    let generics = (def.generics, &predicates).clean(cx);\n+    let generics = (cx.tcx.item_generics(did), &predicates).clean(cx);\n     let generics = filter_non_trait_generics(did, generics);\n     let (generics, supertrait_bounds) = separate_supertrait_bounds(generics);\n     clean::Trait {\n-        unsafety: def.unsafety,\n+        unsafety: cx.tcx.lookup_trait_def(did).unsafety,\n         generics: generics,\n         items: trait_items,\n         bounds: supertrait_bounds,"}, {"sha": "bc8472bb6b76023654fe002daf73b62d2c73b7d1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c80c31a502c838f9ec06f1003d7c61cf9de9d551/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c80c31a502c838f9ec06f1003d7c61cf9de9d551", "patch": "@@ -1395,9 +1395,8 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                     // are actually located on the trait/impl itself, so we need to load\n                     // all of the generics from there and then look for bounds that are\n                     // applied to this associated type in question.\n-                    let def = cx.tcx.lookup_trait_def(did);\n                     let predicates = cx.tcx.item_predicates(did);\n-                    let generics = (def.generics, &predicates).clean(cx);\n+                    let generics = (cx.tcx.item_generics(did), &predicates).clean(cx);\n                     generics.where_predicates.iter().filter_map(|pred| {\n                         let (name, self_type, trait_, bounds) = match *pred {\n                             WherePredicate::BoundPredicate {\n@@ -1927,7 +1926,7 @@ impl Clean<Item> for hir::StructField {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n+impl<'tcx> Clean<Item> for ty::FieldDef {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {\n             name: Some(self.name).clean(cx),\n@@ -1937,7 +1936,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n-            inner: StructFieldItem(self.unsubst_ty().clean(cx)),\n+            inner: StructFieldItem(cx.tcx.item_type(self.did).clean(cx)),\n         }\n     }\n }\n@@ -2084,13 +2083,13 @@ impl Clean<Item> for doctree::Variant {\n     }\n }\n \n-impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n+impl<'tcx> Clean<Item> for ty::VariantDef {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => VariantKind::CLike,\n             CtorKind::Fn => {\n                 VariantKind::Tuple(\n-                    self.fields.iter().map(|f| f.unsubst_ty().clean(cx)).collect()\n+                    self.fields.iter().map(|f| cx.tcx.item_type(f.did).clean(cx)).collect()\n                 )\n             }\n             CtorKind::Fictive => {\n@@ -2106,7 +2105,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n                             deprecation: get_deprecation(cx, field.did),\n-                            inner: StructFieldItem(field.unsubst_ty().clean(cx))\n+                            inner: StructFieldItem(cx.tcx.item_type(field.did).clean(cx))\n                         }\n                     }).collect()\n                 })"}]}