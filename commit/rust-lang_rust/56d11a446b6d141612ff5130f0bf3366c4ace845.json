{"sha": "56d11a446b6d141612ff5130f0bf3366c4ace845", "node_id": "C_kwDOAAsO6NoAKDU2ZDExYTQ0NmI2ZDE0MTYxMmZmNTEzMGYwYmYzMzY2YzRhY2U4NDU", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-05T14:05:44Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-05T14:05:44Z"}, "message": "Rollup merge of #92092 - saethlin:fix-sort-guards-sb, r=danielhenrymantilla\n\nDrop guards in slice sorting derive src pointers from &mut T, which is invalidated by interior mutation in comparison\n\nI tried to run https://github.com/rust-lang/miri-test-libstd on `alloc` with `-Zmiri-track-raw-pointers`, and got a failure on the test `slice::panic_safe`. The test failure has nothing to do with panic safety, it's from how the test tests for panic safety.\n\nI minimized the test failure into this very silly program:\n```rust\nuse std::cell::Cell;\nuse std::cmp::Ordering;\n\n#[derive(Clone)]\nstruct Evil(Cell<usize>);\n\nfn main() {\n    let mut input = vec![Evil(Cell::new(0)); 3];\n\n    // Hits the bug pattern via CopyOnDrop in core\n    input.sort_unstable_by(|a, _b| {\n        a.0.set(0);\n        Ordering::Less\n    });\n\n    // Hits the bug pattern via InsertionHole in alloc\n    input.sort_by(|_a, b| {\n        b.0.set(0);\n        Ordering::Less\n    });\n}\n```\n\nTo fix this, I'm just removing the mutability/uniqueness where it wasn't required.", "tree": {"sha": "5e0c434aa8ae68a695fb339a5535ac5e171f2520", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5e0c434aa8ae68a695fb339a5535ac5e171f2520"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56d11a446b6d141612ff5130f0bf3366c4ace845", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1aW5CRBK7hj4Ov3rIwAAtosIAGFR+SGd9DZ3cCY9gxMibyZo\niD6R4PufM8xh+6VNKTZSEeOqFjPXVvwjohBTqk+hM3UsORsvMcA1nXgYenFXOLHk\n3ntSZGJLbyb4y0zb/UNO+njpAEpkhJzdD0WPhMN8h7YM/U9ztii14WpEEbv6SSyr\nmkEHgoDmWQKc2F9Vr8K33aVYPky+V+35FznGRCQ1r6M2vzhxGAOhzkGMQDJT0RQn\nw+pm49hWPrrv9V7wMRtc/+viPCW+1U2wAgyvRjP5+xwnN+R0Z3GHnOwmAKTvInds\n8AML2AfBMKtitnmduAmJ7YuKb2RodVrmcmvDHvDX12O8Vno1xOCLtNIuj8GQhv8=\n=fAlF\n-----END PGP SIGNATURE-----\n", "payload": "tree 5e0c434aa8ae68a695fb339a5535ac5e171f2520\nparent 936ce3dab7fd042101767c439362310f8355e859\nparent a5a91c8e0732753de7c028182cbb02901fe1b608\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641391544 +0100\ncommitter GitHub <noreply@github.com> 1641391544 +0100\n\nRollup merge of #92092 - saethlin:fix-sort-guards-sb, r=danielhenrymantilla\n\nDrop guards in slice sorting derive src pointers from &mut T, which is invalidated by interior mutation in comparison\n\nI tried to run https://github.com/rust-lang/miri-test-libstd on `alloc` with `-Zmiri-track-raw-pointers`, and got a failure on the test `slice::panic_safe`. The test failure has nothing to do with panic safety, it's from how the test tests for panic safety.\n\nI minimized the test failure into this very silly program:\n```rust\nuse std::cell::Cell;\nuse std::cmp::Ordering;\n\n#[derive(Clone)]\nstruct Evil(Cell<usize>);\n\nfn main() {\n    let mut input = vec![Evil(Cell::new(0)); 3];\n\n    // Hits the bug pattern via CopyOnDrop in core\n    input.sort_unstable_by(|a, _b| {\n        a.0.set(0);\n        Ordering::Less\n    });\n\n    // Hits the bug pattern via InsertionHole in alloc\n    input.sort_by(|_a, b| {\n        b.0.set(0);\n        Ordering::Less\n    });\n}\n```\n\nTo fix this, I'm just removing the mutability/uniqueness where it wasn't required.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56d11a446b6d141612ff5130f0bf3366c4ace845", "html_url": "https://github.com/rust-lang/rust/commit/56d11a446b6d141612ff5130f0bf3366c4ace845", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56d11a446b6d141612ff5130f0bf3366c4ace845/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "936ce3dab7fd042101767c439362310f8355e859", "url": "https://api.github.com/repos/rust-lang/rust/commits/936ce3dab7fd042101767c439362310f8355e859", "html_url": "https://github.com/rust-lang/rust/commit/936ce3dab7fd042101767c439362310f8355e859"}, {"sha": "a5a91c8e0732753de7c028182cbb02901fe1b608", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5a91c8e0732753de7c028182cbb02901fe1b608", "html_url": "https://github.com/rust-lang/rust/commit/a5a91c8e0732753de7c028182cbb02901fe1b608"}], "stats": {"total": 24, "additions": 12, "deletions": 12}, "files": [{"sha": "8853577371ad6d7dd62e1d65bba4c851eea5bbc6", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56d11a446b6d141612ff5130f0bf3366c4ace845/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56d11a446b6d141612ff5130f0bf3366c4ace845/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=56d11a446b6d141612ff5130f0bf3366c4ace845", "patch": "@@ -892,7 +892,7 @@ where\n             //    performance than with the 2nd method.\n             //\n             // All methods were benchmarked, and the 3rd showed best results. So we chose that one.\n-            let mut tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n+            let tmp = mem::ManuallyDrop::new(ptr::read(&v[0]));\n \n             // Intermediate state of the insertion process is always tracked by `hole`, which\n             // serves two purposes:\n@@ -904,7 +904,7 @@ where\n             // If `is_less` panics at any point during the process, `hole` will get dropped and\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n-            let mut hole = InsertionHole { src: &mut *tmp, dest: &mut v[1] };\n+            let mut hole = InsertionHole { src: &*tmp, dest: &mut v[1] };\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n@@ -920,7 +920,7 @@ where\n \n     // When dropped, copies from `src` into `dest`.\n     struct InsertionHole<T> {\n-        src: *mut T,\n+        src: *const T,\n         dest: *mut T,\n     }\n "}, {"sha": "8f58e8897b34bc493ce01a38fbda4d0ad838d0e5", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/56d11a446b6d141612ff5130f0bf3366c4ace845/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56d11a446b6d141612ff5130f0bf3366c4ace845/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=56d11a446b6d141612ff5130f0bf3366c4ace845", "patch": "@@ -12,7 +12,7 @@ use crate::ptr;\n \n /// When dropped, copies from `src` into `dest`.\n struct CopyOnDrop<T> {\n-    src: *mut T,\n+    src: *const T,\n     dest: *mut T,\n }\n \n@@ -54,9 +54,9 @@ where\n             // Read the first element into a stack-allocated variable. If a following comparison\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n-            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n+            let tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(0)));\n             let v = v.as_mut_ptr();\n-            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.add(1) };\n+            let mut hole = CopyOnDrop { src: &*tmp, dest: v.add(1) };\n             ptr::copy_nonoverlapping(v.add(1), v.add(0), 1);\n \n             for i in 2..len {\n@@ -100,9 +100,9 @@ where\n             // Read the last element into a stack-allocated variable. If a following comparison\n             // operation panics, `hole` will get dropped and automatically write the element back\n             // into the slice.\n-            let mut tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n+            let tmp = mem::ManuallyDrop::new(ptr::read(v.get_unchecked(len - 1)));\n             let v = v.as_mut_ptr();\n-            let mut hole = CopyOnDrop { src: &mut *tmp, dest: v.add(len - 2) };\n+            let mut hole = CopyOnDrop { src: &*tmp, dest: v.add(len - 2) };\n             ptr::copy_nonoverlapping(v.add(len - 2), v.add(len - 1), 1);\n \n             for i in (0..len - 2).rev() {\n@@ -498,8 +498,8 @@ where\n         // operation panics, the pivot will be automatically written back into the slice.\n \n         // SAFETY: `pivot` is a reference to the first element of `v`, so `ptr::read` is safe.\n-        let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-        let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n+        let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n+        let _pivot_guard = CopyOnDrop { src: &*tmp, dest: pivot };\n         let pivot = &*tmp;\n \n         // Find the first pair of out-of-order elements.\n@@ -551,8 +551,8 @@ where\n     // Read the pivot into a stack-allocated variable for efficiency. If a following comparison\n     // operation panics, the pivot will be automatically written back into the slice.\n     // SAFETY: The pointer here is valid because it is obtained from a reference to a slice.\n-    let mut tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n-    let _pivot_guard = CopyOnDrop { src: &mut *tmp, dest: pivot };\n+    let tmp = mem::ManuallyDrop::new(unsafe { ptr::read(pivot) });\n+    let _pivot_guard = CopyOnDrop { src: &*tmp, dest: pivot };\n     let pivot = &*tmp;\n \n     // Now partition the slice."}]}