{"sha": "18f9758c4f5bb951e6ee7f928b0b884e942686bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4Zjk3NThjNGY1YmI5NTFlNmVlN2Y5MjhiMGI4ODRlOTQyNjg2YmM=", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume1.gomez@gmail.com", "date": "2016-10-21T23:21:58Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-10-21T23:21:58Z"}, "message": "Rollup merge of #37043 - GuillaumeGomez:vec_urls, r=frewsxcv\n\nAdd missing urls on Vec docs\n\nr? @steveklabnik", "tree": {"sha": "0d18b161c0c81eeb7044dc362dfc3a424d52f679", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0d18b161c0c81eeb7044dc362dfc3a424d52f679"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/18f9758c4f5bb951e6ee7f928b0b884e942686bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/18f9758c4f5bb951e6ee7f928b0b884e942686bc", "html_url": "https://github.com/rust-lang/rust/commit/18f9758c4f5bb951e6ee7f928b0b884e942686bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/18f9758c4f5bb951e6ee7f928b0b884e942686bc/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5509ae399e4ed6f041b95bf948751f35b7d65517", "url": "https://api.github.com/repos/rust-lang/rust/commits/5509ae399e4ed6f041b95bf948751f35b7d65517", "html_url": "https://github.com/rust-lang/rust/commit/5509ae399e4ed6f041b95bf948751f35b7d65517"}, {"sha": "599ad8ed61be39289457e97378e20442777326d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/599ad8ed61be39289457e97378e20442777326d7", "html_url": "https://github.com/rust-lang/rust/commit/599ad8ed61be39289457e97378e20442777326d7"}], "stats": {"total": 137, "additions": 85, "deletions": 52}, "files": [{"sha": "f41f9b2c45a28085086822bc916bdf5edfb8b372", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 85, "deletions": 52, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/18f9758c4f5bb951e6ee7f928b0b884e942686bc/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/18f9758c4f5bb951e6ee7f928b0b884e942686bc/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=18f9758c4f5bb951e6ee7f928b0b884e942686bc", "patch": "@@ -16,13 +16,13 @@\n //!\n //! # Examples\n //!\n-//! You can explicitly create a `Vec<T>` with `new()`:\n+//! You can explicitly create a [`Vec<T>`] with [`new()`]:\n //!\n //! ```\n //! let v: Vec<i32> = Vec::new();\n //! ```\n //!\n-//! ...or by using the `vec!` macro:\n+//! ...or by using the [`vec!`] macro:\n //!\n //! ```\n //! let v: Vec<i32> = vec![];\n@@ -32,7 +32,7 @@\n //! let v = vec![0; 10]; // ten zeroes\n //! ```\n //!\n-//! You can `push` values onto the end of a vector (which will grow the vector\n+//! You can [`push`] values onto the end of a vector (which will grow the vector\n //! as needed):\n //!\n //! ```\n@@ -49,13 +49,20 @@\n //! let two = v.pop();\n //! ```\n //!\n-//! Vectors also support indexing (through the `Index` and `IndexMut` traits):\n+//! Vectors also support indexing (through the [`Index`] and [`IndexMut`] traits):\n //!\n //! ```\n //! let mut v = vec![1, 2, 3];\n //! let three = v[2];\n //! v[1] = v[1] + 5;\n //! ```\n+//!\n+//! [`Vec<T>`]: ../../std/vec/struct.Vec.html\n+//! [`new()`]: ../../std/vec/struct.Vec.html#method.new\n+//! [`push`]: ../../std/vec/struct.Vec.html#method.push\n+//! [`Index`]: ../../std/ops/trait.Index.html\n+//! [`IndexMut`]: ../../std/ops/trait.IndexMut.html\n+//! [`vec!`]: ../../std/macro.vec.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -79,7 +86,7 @@ use core::slice;\n use super::SpecExtend;\n use super::range::RangeArgument;\n \n-/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector.'\n+/// A contiguous growable array type, written `Vec<T>` but pronounced 'vector'.\n ///\n /// # Examples\n ///\n@@ -105,7 +112,7 @@ use super::range::RangeArgument;\n /// assert_eq!(vec, [7, 1, 2, 3]);\n /// ```\n ///\n-/// The `vec!` macro is provided to make initialization more convenient:\n+/// The [`vec!`] macro is provided to make initialization more convenient:\n ///\n /// ```\n /// let mut vec = vec![1, 2, 3];\n@@ -137,15 +144,15 @@ use super::range::RangeArgument;\n ///\n /// # Indexing\n ///\n-/// The Vec type allows to access values by index, because it implements the\n-/// `Index` trait. An example will be more explicit:\n+/// The `Vec` type allows to access values by index, because it implements the\n+/// [`Index`] trait. An example will be more explicit:\n ///\n /// ```\n /// let v = vec!(0, 2, 4, 6);\n /// println!(\"{}\", v[1]); // it will display '2'\n /// ```\n ///\n-/// However be careful: if you try to access an index which isn't in the Vec,\n+/// However be careful: if you try to access an index which isn't in the `Vec`,\n /// your software will panic! You cannot do this:\n ///\n /// ```ignore\n@@ -158,7 +165,7 @@ use super::range::RangeArgument;\n ///\n /// # Slicing\n ///\n-/// A Vec can be mutable. Slices, on the other hand, are read-only objects.\n+/// A `Vec` can be mutable. Slices, on the other hand, are read-only objects.\n /// To get a slice, use \"&\". Example:\n ///\n /// ```\n@@ -175,8 +182,8 @@ use super::range::RangeArgument;\n /// ```\n ///\n /// In Rust, it's more common to pass slices as arguments rather than vectors\n-/// when you just want to provide a read access. The same goes for String and\n-/// &str.\n+/// when you just want to provide a read access. The same goes for [`String`] and\n+/// [`&str`].\n ///\n /// # Capacity and reallocation\n ///\n@@ -191,7 +198,7 @@ use super::range::RangeArgument;\n /// with space for 10 more elements. Pushing 10 or fewer elements onto the\n /// vector will not change its capacity or cause reallocation to occur. However,\n /// if the vector's length is increased to 11, it will have to reallocate, which\n-/// can be slow. For this reason, it is recommended to use `Vec::with_capacity`\n+/// can be slow. For this reason, it is recommended to use [`Vec::with_capacity`]\n /// whenever possible to specify how big the vector is expected to get.\n ///\n /// # Guarantees\n@@ -209,65 +216,83 @@ use super::range::RangeArgument;\n /// The pointer will never be null, so this type is null-pointer-optimized.\n ///\n /// However, the pointer may not actually point to allocated memory. In particular,\n-/// if you construct a Vec with capacity 0 via `Vec::new()`, `vec![]`,\n-/// `Vec::with_capacity(0)`, or by calling `shrink_to_fit()` on an empty Vec, it\n-/// will not allocate memory. Similarly, if you store zero-sized types inside\n-/// a Vec, it will not allocate space for them. *Note that in this case the\n-/// Vec may not report a `capacity()` of 0*. Vec will allocate if and only\n-/// if `mem::size_of::<T>() * capacity() > 0`. In general, Vec's allocation\n+/// if you construct a Vec with capacity 0 via [`Vec::new()`], [`vec![]`][`vec!`],\n+/// [`Vec::with_capacity(0)`][`Vec::with_capacity`], or by calling [`shrink_to_fit()`]\n+/// on an empty Vec, it will not allocate memory. Similarly, if you store zero-sized\n+/// types inside a `Vec`, it will not allocate space for them. *Note that in this case\n+/// the `Vec` may not report a [`capacity()`] of 0*. Vec will allocate if and only\n+/// if [`mem::size_of::<T>()`]` * capacity() > 0`. In general, `Vec`'s allocation\n /// details are subtle enough that it is strongly recommended that you only\n /// free memory allocated by a Vec by creating a new Vec and dropping it.\n ///\n-/// If a Vec *has* allocated memory, then the memory it points to is on the heap\n+/// If a `Vec` *has* allocated memory, then the memory it points to is on the heap\n /// (as defined by the allocator Rust is configured to use by default), and its\n-/// pointer points to `len()` initialized elements in order (what you would see\n-/// if you coerced it to a slice), followed by `capacity() - len()` logically\n-/// uninitialized elements.\n+/// pointer points to [`len()`] initialized elements in order (what you would see\n+/// if you coerced it to a slice), followed by `[capacity()][`capacity()`] -\n+/// [len()][`len()`]` logically uninitialized elements.\n ///\n-/// Vec will never perform a \"small optimization\" where elements are actually\n+/// `Vec` will never perform a \"small optimization\" where elements are actually\n /// stored on the stack for two reasons:\n ///\n /// * It would make it more difficult for unsafe code to correctly manipulate\n-///   a Vec. The contents of a Vec wouldn't have a stable address if it were\n-///   only moved, and it would be more difficult to determine if a Vec had\n+///   a `Vec`. The contents of a `Vec` wouldn't have a stable address if it were\n+///   only moved, and it would be more difficult to determine if a `Vec` had\n ///   actually allocated memory.\n ///\n /// * It would penalize the general case, incurring an additional branch\n ///   on every access.\n ///\n-/// Vec will never automatically shrink itself, even if completely empty. This\n-/// ensures no unnecessary allocations or deallocations occur. Emptying a Vec\n-/// and then filling it back up to the same `len()` should incur no calls to\n-/// the allocator. If you wish to free up unused memory, use `shrink_to_fit`.\n+/// `Vec` will never automatically shrink itself, even if completely empty. This\n+/// ensures no unnecessary allocations or deallocations occur. Emptying a `Vec`\n+/// and then filling it back up to the same [`len()`] should incur no calls to\n+/// the allocator. If you wish to free up unused memory, use\n+/// [`shrink_to_fit`][`shrink_to_fit()`].\n ///\n-/// `push` and `insert` will never (re)allocate if the reported capacity is\n-/// sufficient. `push` and `insert` *will* (re)allocate if `len() == capacity()`.\n-/// That is, the reported capacity is completely accurate, and can be relied on.\n-/// It can even be used to manually free the memory allocated by a Vec if\n-/// desired. Bulk insertion methods *may* reallocate, even when not necessary.\n+/// [`push`] and [`insert`] will never (re)allocate if the reported capacity is\n+/// sufficient. [`push`] and [`insert`] *will* (re)allocate if `[len()][`len()`]\n+/// == [capacity()][`capacity()`]`. That is, the reported capacity is completely\n+/// accurate, and can be relied on. It can even be used to manually free the memory\n+/// allocated by a `Vec` if desired. Bulk insertion methods *may* reallocate, even\n+/// when not necessary.\n ///\n-/// Vec does not guarantee any particular growth strategy when reallocating\n-/// when full, nor when `reserve` is called. The current strategy is basic\n+/// `Vec` does not guarantee any particular growth strategy when reallocating\n+/// when full, nor when [`reserve`] is called. The current strategy is basic\n /// and it may prove desirable to use a non-constant growth factor. Whatever\n-/// strategy is used will of course guarantee `O(1)` amortized `push`.\n+/// strategy is used will of course guarantee `O(1)` amortized [`push`].\n ///\n-/// `vec![x; n]`, `vec![a, b, c, d]`, and `Vec::with_capacity(n)`, will all\n-/// produce a Vec with exactly the requested capacity. If `len() == capacity()`,\n-/// (as is the case for the `vec!` macro), then a `Vec<T>` can be converted\n-/// to and from a `Box<[T]>` without reallocating or moving the elements.\n+/// `vec![x; n]`, `vec![a, b, c, d]`, and\n+/// [`Vec::with_capacity(n)`][`Vec::with_capacity`], will all\n+/// produce a `Vec` with exactly the requested capacity. If `[len()][`len()`] ==\n+/// [capacity()][`capacity()`]`, (as is the case for the [`vec!`] macro), then a\n+/// `Vec<T>` can be converted to and from a [`Box<[T]>`] without reallocating or\n+/// moving the elements.\n ///\n-/// Vec will not specifically overwrite any data that is removed from it,\n+/// `Vec` will not specifically overwrite any data that is removed from it,\n /// but also won't specifically preserve it. Its uninitialized memory is\n /// scratch space that it may use however it wants. It will generally just do\n /// whatever is most efficient or otherwise easy to implement. Do not rely on\n-/// removed data to be erased for security purposes. Even if you drop a Vec, its\n-/// buffer may simply be reused by another Vec. Even if you zero a Vec's memory\n+/// removed data to be erased for security purposes. Even if you drop a `Vec`, its\n+/// buffer may simply be reused by another `Vec`. Even if you zero a `Vec`'s memory\n /// first, that may not actually happen because the optimizer does not consider\n /// this a side-effect that must be preserved.\n ///\n-/// Vec does not currently guarantee the order in which elements are dropped\n+/// `Vec` does not currently guarantee the order in which elements are dropped\n /// (the order has changed in the past, and may change again).\n ///\n+/// [`vec!`]: ../../std/macro.vec.html\n+/// [`Index`]: ../../std/ops/trait.Index.html\n+/// [`String`]: ../../std/string/struct.String.html\n+/// [`&str`]: ../../std/primitive.str.html\n+/// [`Vec::with_capacity`]: ../../std/vec/struct.Vec.html#method.with_capacity\n+/// [`Vec::new()`]: ../../std/vec/struct.Vec.html#method.new\n+/// [`shrink_to_fit()`]: ../../std/vec/struct.Vec.html#method.shrink_to_fit\n+/// [`capacity()`]: ../../std/vec/struct.Vec.html#method.capacity\n+/// [`mem::size_of::<T>()`]: ../../std/mem/fn.size_of.html\n+/// [`len()`]: ../../std/vec/struct.Vec.html#method.len\n+/// [`push`]: ../../std/vec/struct.Vec.html#method.push\n+/// [`insert`]: ../../std/vec/struct.Vec.html#method.insert\n+/// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n+/// [`Box<[T]>`]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n@@ -340,7 +365,7 @@ impl<T> Vec<T> {\n     /// This is highly unsafe, due to the number of invariants that aren't\n     /// checked:\n     ///\n-    /// * `ptr` needs to have been previously allocated via `String`/`Vec<T>`\n+    /// * `ptr` needs to have been previously allocated via [`String`]/`Vec<T>`\n     ///   (at least, it's highly likely to be incorrect if it wasn't).\n     /// * `length` needs to be less than or equal to `capacity`.\n     /// * `capacity` needs to be the capacity that the pointer was allocated with.\n@@ -354,6 +379,8 @@ impl<T> Vec<T> {\n     /// that nothing else uses the pointer after calling this\n     /// function.\n     ///\n+    /// [`String`]: ../../std/string/struct.String.html\n+    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -470,11 +497,15 @@ impl<T> Vec<T> {\n         self.buf.shrink_to_fit(self.len);\n     }\n \n-    /// Converts the vector into Box<[T]>.\n+    /// Converts the vector into [`Box<[T]>`].\n     ///\n     /// Note that this will drop any excess capacity. Calling this and\n-    /// converting back to a vector with `into_vec()` is equivalent to calling\n-    /// `shrink_to_fit()`.\n+    /// converting back to a vector with [`into_vec()`] is equivalent to calling\n+    /// [`shrink_to_fit()`].\n+    ///\n+    /// [`Box<[T]>`]: ../../std/boxed/struct.Box.html\n+    /// [`into_vec()`]: ../../std/primitive.slice.html#method.into_vec\n+    /// [`shrink_to_fit()`]: #method.shrink_to_fit\n     ///\n     /// # Examples\n     ///\n@@ -673,7 +704,7 @@ impl<T> Vec<T> {\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `index` is greater than the vector's length.\n+    /// Panics if `index` is out of bounds.\n     ///\n     /// # Examples\n     ///\n@@ -933,9 +964,11 @@ impl<T> Vec<T> {\n         }\n     }\n \n-    /// Removes the last element from a vector and returns it, or `None` if it\n+    /// Removes the last element from a vector and returns it, or [`None`] if it\n     /// is empty.\n     ///\n+    /// [`None`]: ../../std/option/enum.Option.html#variant.None\n+    ///\n     /// # Examples\n     ///\n     /// ```"}]}