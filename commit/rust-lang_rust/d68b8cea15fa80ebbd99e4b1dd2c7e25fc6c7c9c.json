{"sha": "d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2OGI4Y2VhMTVmYTgwZWJiZDk5ZTRiMWRkMmM3ZTI1ZmM2YzdjOWM=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-06-08T05:15:02Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-06-08T05:15:02Z"}, "message": "Merge pull request #2811 from fanzier/checked_unwrap\n\nImplement lint that checks for unidiomatic unwrap() (closes #1770)", "tree": {"sha": "dfa1b73390cb6b343c85359e37e28f647d8e2c6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dfa1b73390cb6b343c85359e37e28f647d8e2c6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbGhDWCRBK7hj4Ov3rIwAAdHIIAJjVf7s0boA1A6pqWVKR2zgc\nFCth2hq9397dsinGl7LK0WxphYrGgG0t06FhdFTGu517FFuV2tKAoPN+zReKO35Y\nFtV3zgmQzuzfcW6DFDnqKE8CypuI2k+kLAMDyvcwQn/1fXrNSbylVfUiipBEME79\n5H7ZL+APfoVps9dbraeADsUM99ci5DT8iNLrE9d8TjqjIegsuqUnzy7kk38OVr36\n/cuZ2NroBU6PWOEzMbSSSJ7R12nOg/vUW+TEZU9qF3khxLfdIRZ1EB3r/2iC+GtP\nlssEamf8JWLnYkQcBGjur2h5I1KB8oAqBjoJfj1gF1bycndMcU+yEbNBB0Fqy3g=\n=IQok\n-----END PGP SIGNATURE-----\n", "payload": "tree dfa1b73390cb6b343c85359e37e28f647d8e2c6d\nparent d0620ae4ebeeb5270165ddbacb8e936e3fdb66a9\nparent 54826cf72e409ab32d56778ada783657171730a6\nauthor Oliver Schneider <github35764891676564198441@oli-obk.de> 1528434902 +0200\ncommitter GitHub <noreply@github.com> 1528434902 +0200\n\nMerge pull request #2811 from fanzier/checked_unwrap\n\nImplement lint that checks for unidiomatic unwrap() (closes #1770)"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "html_url": "https://github.com/rust-lang/rust/commit/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d0620ae4ebeeb5270165ddbacb8e936e3fdb66a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0620ae4ebeeb5270165ddbacb8e936e3fdb66a9", "html_url": "https://github.com/rust-lang/rust/commit/d0620ae4ebeeb5270165ddbacb8e936e3fdb66a9"}, {"sha": "54826cf72e409ab32d56778ada783657171730a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/54826cf72e409ab32d56778ada783657171730a6", "html_url": "https://github.com/rust-lang/rust/commit/54826cf72e409ab32d56778ada783657171730a6"}], "stats": {"total": 576, "additions": 510, "deletions": 66}, "files": [{"sha": "c4dfc1f0168d62dc2b5d50704b2b3c13c0c64350", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "patch": "@@ -200,6 +200,7 @@ pub mod unicode;\n pub mod unsafe_removed_from_name;\n pub mod unused_io_amount;\n pub mod unused_label;\n+pub mod unwrap;\n pub mod use_self;\n pub mod vec;\n pub mod write;\n@@ -421,6 +422,8 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box infallible_destructuring_match::Pass);\n     reg.register_late_lint_pass(box inherent_impl::Pass::default());\n     reg.register_late_lint_pass(box neg_cmp_op_on_partial_ord::NoNegCompOpForPartialOrd);\n+    reg.register_late_lint_pass(box unwrap::Pass);\n+\n \n     reg.register_lint_group(\"clippy_restriction\", vec![\n         arithmetic::FLOAT_ARITHMETIC,\n@@ -837,6 +840,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         types::UNIT_ARG,\n         types::UNNECESSARY_CAST,\n         unused_label::UNUSED_LABEL,\n+        unwrap::UNNECESSARY_UNWRAP,\n         zero_div_zero::ZERO_DIVIDED_BY_ZERO,\n     ]);\n "}, {"sha": "20b10db0d6643d255cfe64feaad55de1812031f3", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 17, "deletions": 66, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "patch": "@@ -18,6 +18,7 @@ use std::iter::{once, Iterator};\n use syntax::ast;\n use syntax::codemap::Span;\n use crate::utils::{sugg, sext};\n+use crate::utils::usage::mutated_variables;\n use crate::consts::{constant, Constant};\n \n use crate::utils::{get_enclosing_block, get_parent_expr, higher, in_external_macro, is_integer_literal, is_refutable,\n@@ -504,8 +505,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         // check for while loops which conditions never change\n-        if let ExprWhile(ref cond, ref block, _) = expr.node {\n-            check_infinite_loop(cx, cond, block, expr);\n+        if let ExprWhile(ref cond, _, _) = expr.node {\n+            check_infinite_loop(cx, cond, expr);\n         }\n     }\n \n@@ -2145,35 +2146,30 @@ fn path_name(e: &Expr) -> Option<Name> {\n     None\n }\n \n-fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, block: &'tcx Block, expr: &'tcx Expr) {\n+fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, expr: &'tcx Expr) {\n     if constant(cx, cx.tables, cond).is_some() {\n         // A pure constant condition (e.g. while false) is not linted.\n         return;\n     }\n \n-    let mut mut_var_visitor = VarCollectorVisitor {\n+    let mut var_visitor = VarCollectorVisitor {\n         cx,\n-        ids: HashMap::new(),\n+        ids: HashSet::new(),\n         def_ids: HashMap::new(),\n         skip: false,\n     };\n-    mut_var_visitor.visit_expr(cond);\n-    if mut_var_visitor.skip {\n+    var_visitor.visit_expr(cond);\n+    if var_visitor.skip {\n         return;\n     }\n-\n-    let mut delegate = MutVarsDelegate {\n-        used_mutably: mut_var_visitor.ids,\n-        skip: false,\n+    let used_in_condition = &var_visitor.ids;\n+    let no_cond_variable_mutated = if let Some(used_mutably) = mutated_variables(expr, cx) {\n+        used_in_condition.is_disjoint(&used_mutably)\n+    } else {\n+        return\n     };\n-    let def_id = def_id::DefId::local(block.hir_id.owner);\n-    let region_scope_tree = &cx.tcx.region_scope_tree(def_id);\n-    ExprUseVisitor::new(&mut delegate, cx.tcx, cx.param_env, region_scope_tree, cx.tables, None).walk_expr(expr);\n-\n-    if delegate.skip {\n-        return;\n-    }\n-    if !(delegate.used_mutably.iter().any(|(_, v)| *v) || mut_var_visitor.def_ids.iter().any(|(_, v)| *v)) {\n+    let mutable_static_in_cond = var_visitor.def_ids.iter().any(|(_, v)| *v);\n+    if no_cond_variable_mutated && !mutable_static_in_cond {\n         span_lint(\n             cx,\n             WHILE_IMMUTABLE_CONDITION,\n@@ -2189,7 +2185,7 @@ fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, b\n /// All variables definition IDs are collected\n struct VarCollectorVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    ids: HashMap<NodeId, bool>,\n+    ids: HashSet<NodeId>,\n     def_ids: HashMap<def_id::DefId, bool>,\n     skip: bool,\n }\n@@ -2203,7 +2199,7 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n             then {\n                 match def {\n                     Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n-                        self.ids.insert(node_id, false);\n+                        self.ids.insert(node_id);\n                     },\n                     Def::Static(def_id, mutable) => {\n                         self.def_ids.insert(def_id, mutable);\n@@ -2230,48 +2226,3 @@ impl<'a, 'tcx> Visitor<'tcx> for VarCollectorVisitor<'a, 'tcx> {\n         NestedVisitorMap::None\n     }\n }\n-\n-struct MutVarsDelegate {\n-    used_mutably: HashMap<NodeId, bool>,\n-    skip: bool,\n-}\n-\n-impl<'tcx> MutVarsDelegate {\n-    fn update(&mut self, cat: &'tcx Categorization) {\n-        match *cat {\n-            Categorization::Local(id) =>\n-                if let Some(used) = self.used_mutably.get_mut(&id) {\n-                    *used = true;\n-                },\n-            Categorization::Upvar(_) => {\n-                //FIXME: This causes false negatives. We can't get the `NodeId` from\n-                //`Categorization::Upvar(_)`. So we search for any `Upvar`s in the\n-                //`while`-body, not just the ones in the condition.\n-                self.skip = true\n-            },\n-            Categorization::Deref(ref cmt, _) | Categorization::Interior(ref cmt, _) => self.update(&cmt.cat),\n-            _ => {}\n-        }\n-    }\n-}\n-\n-\n-impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n-    fn consume(&mut self, _: NodeId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n-\n-    fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n-\n-    fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n-\n-    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n-        if let ty::BorrowKind::MutBorrow = bk {\n-            self.update(&cmt.cat)\n-        }\n-    }\n-\n-    fn mutate(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n-        self.update(&cmt.cat)\n-    }\n-\n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n-}"}, {"sha": "db840c79a290be5210bfb8f5f634cfc74fe1e1e2", "filename": "clippy_lints/src/unwrap.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/clippy_lints%2Fsrc%2Funwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/clippy_lints%2Fsrc%2Funwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funwrap.rs?ref=d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "patch": "@@ -0,0 +1,176 @@\n+use rustc::lint::*;\n+\n+use crate::utils::{in_macro, match_type, paths, span_lint_and_then, usage::is_potentially_mutated};\n+use rustc::hir::intravisit::*;\n+use rustc::hir::*;\n+use syntax::ast::NodeId;\n+use syntax::codemap::Span;\n+\n+/// **What it does:** Checks for calls of unwrap[_err]() that cannot fail.\n+///\n+/// **Why is this bad?** Using `if let` or `match` is more idiomatic.\n+///\n+/// **Known problems:** Limitations of the borrow checker might make unwrap() necessary sometimes?\n+///\n+/// **Example:**\n+/// ```rust\n+/// if option.is_some() {\n+///     do_something_with(option.unwrap())\n+/// }\n+/// ```\n+///\n+/// Could be written:\n+///\n+/// ```rust\n+/// if let Some(value) = option {\n+///     do_something_with(value)\n+/// }\n+/// ```\n+declare_clippy_lint! {\n+    pub UNNECESSARY_UNWRAP,\n+    nursery,\n+    \"checks for calls of unwrap[_err]() that cannot fail\"\n+}\n+\n+pub struct Pass;\n+\n+/// Visitor that keeps track of which variables are unwrappable.\n+struct UnwrappableVariablesVisitor<'a, 'tcx: 'a> {\n+    unwrappables: Vec<UnwrapInfo<'tcx>>,\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n+/// Contains information about whether a variable can be unwrapped.\n+#[derive(Copy, Clone, Debug)]\n+struct UnwrapInfo<'tcx> {\n+    /// The variable that is checked\n+    ident: &'tcx Path,\n+    /// The check, like `x.is_ok()`\n+    check: &'tcx Expr,\n+    /// Whether `is_some()` or `is_ok()` was called (as opposed to `is_err()` or `is_none()`).\n+    safe_to_unwrap: bool,\n+}\n+\n+/// Collects the information about unwrappable variables from an if condition\n+/// The `invert` argument tells us whether the condition is negated.\n+fn collect_unwrap_info<'a, 'tcx: 'a>(\n+    cx: &'a LateContext<'a, 'tcx>,\n+    expr: &'tcx Expr,\n+    invert: bool,\n+) -> Vec<UnwrapInfo<'tcx>> {\n+    if let Expr_::ExprBinary(op, left, right) = &expr.node {\n+        match (invert, op.node) {\n+            (false, BinOp_::BiAnd) | (false, BinOp_::BiBitAnd) | (true, BinOp_::BiOr) | (true, BinOp_::BiBitOr) => {\n+                let mut unwrap_info = collect_unwrap_info(cx, left, invert);\n+                unwrap_info.append(&mut collect_unwrap_info(cx, right, invert));\n+                return unwrap_info;\n+            },\n+            _ => (),\n+        }\n+    } else if let Expr_::ExprUnary(UnNot, expr) = &expr.node {\n+        return collect_unwrap_info(cx, expr, !invert);\n+    } else {\n+        if_chain! {\n+            if let Expr_::ExprMethodCall(method_name, _, args) = &expr.node;\n+            if let Expr_::ExprPath(QPath::Resolved(None, path)) = &args[0].node;\n+            let ty = cx.tables.expr_ty(&args[0]);\n+            if match_type(cx, ty, &paths::OPTION) || match_type(cx, ty, &paths::RESULT);\n+            let name = method_name.name.as_str();\n+            if [\"is_some\", \"is_none\", \"is_ok\", \"is_err\"].contains(&&*name);\n+            then {\n+                assert!(args.len() == 1);\n+                let unwrappable = match name.as_ref() {\n+                    \"is_some\" | \"is_ok\" => true,\n+                    \"is_err\" | \"is_none\" => false,\n+                    _ => unreachable!(),\n+                };\n+                let safe_to_unwrap = unwrappable != invert;\n+                return vec![UnwrapInfo { ident: path, check: expr, safe_to_unwrap }];\n+            }\n+        }\n+    }\n+    Vec::new()\n+}\n+\n+impl<'a, 'tcx: 'a> UnwrappableVariablesVisitor<'a, 'tcx> {\n+    fn visit_branch(&mut self, cond: &'tcx Expr, branch: &'tcx Expr, else_branch: bool) {\n+        let prev_len = self.unwrappables.len();\n+        for unwrap_info in collect_unwrap_info(self.cx, cond, else_branch) {\n+            if is_potentially_mutated(unwrap_info.ident, cond, self.cx)\n+                || is_potentially_mutated(unwrap_info.ident, branch, self.cx)\n+            {\n+                // if the variable is mutated, we don't know whether it can be unwrapped:\n+                continue;\n+            }\n+            self.unwrappables.push(unwrap_info);\n+        }\n+        walk_expr(self, branch);\n+        self.unwrappables.truncate(prev_len);\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for UnwrappableVariablesVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let Expr_::ExprIf(cond, then, els) = &expr.node {\n+            walk_expr(self, cond);\n+            self.visit_branch(cond, then, false);\n+            if let Some(els) = els {\n+                self.visit_branch(cond, els, true);\n+            }\n+        } else {\n+            // find `unwrap[_err]()` calls:\n+            if_chain! {\n+                if let Expr_::ExprMethodCall(ref method_name, _, ref args) = expr.node;\n+                if let Expr_::ExprPath(QPath::Resolved(None, ref path)) = args[0].node;\n+                if [\"unwrap\", \"unwrap_err\"].contains(&&*method_name.name.as_str());\n+                let call_to_unwrap = method_name.name == \"unwrap\";\n+                if let Some(unwrappable) = self.unwrappables.iter()\n+                    .find(|u| u.ident.def == path.def && call_to_unwrap == u.safe_to_unwrap);\n+                then {\n+                    span_lint_and_then(\n+                        self.cx,\n+                        UNNECESSARY_UNWRAP,\n+                        expr.span,\n+                        &format!(\"You checked before that `{}()` cannot fail. \\\n+                        Instead of checking and unwrapping, it's better to use `if let` or `match`.\",\n+                        method_name.name),\n+                        |db| { db.span_label(unwrappable.check.span, \"the check is happening here\"); },\n+                    );\n+                }\n+            }\n+            walk_expr(self, expr);\n+        }\n+    }\n+\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::OnlyBodies(&self.cx.tcx.hir)\n+    }\n+}\n+\n+impl<'a> LintPass for Pass {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNNECESSARY_UNWRAP)\n+    }\n+}\n+\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        body: &'tcx Body,\n+        span: Span,\n+        fn_id: NodeId,\n+    ) {\n+        if in_macro(span) {\n+            return;\n+        }\n+\n+        let mut v = UnwrappableVariablesVisitor {\n+            cx,\n+            unwrappables: Vec::new(),\n+        };\n+\n+        walk_fn(&mut v, kind, decl, body.id(), span, fn_id);\n+    }\n+}"}, {"sha": "6c3f0c25a3ec653010e0fce88a47b3fe01894679", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "patch": "@@ -32,6 +32,7 @@ pub mod inspector;\n pub mod internal_lints;\n pub mod author;\n pub mod ptr;\n+pub mod usage;\n pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n pub type MethodArgs = HirVec<P<Expr>>;"}, {"sha": "6d75dfb486dc12a7c243f445443a5e9cc43a6d96", "filename": "clippy_lints/src/utils/usage.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "patch": "@@ -0,0 +1,82 @@\n+use rustc::lint::*;\n+\n+use rustc::hir::def::Def;\n+use rustc::hir::*;\n+use rustc::middle::expr_use_visitor::*;\n+use rustc::middle::mem_categorization::cmt_;\n+use rustc::middle::mem_categorization::Categorization;\n+use rustc::ty;\n+use std::collections::HashSet;\n+use syntax::ast::NodeId;\n+use syntax::codemap::Span;\n+\n+/// Returns a set of mutated local variable ids or None if mutations could not be determined.\n+pub fn mutated_variables<'a, 'tcx: 'a>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<HashSet<NodeId>> {\n+    let mut delegate = MutVarsDelegate {\n+        used_mutably: HashSet::new(),\n+        skip: false,\n+    };\n+    let def_id = def_id::DefId::local(expr.hir_id.owner);\n+    let region_scope_tree = &cx.tcx.region_scope_tree(def_id);\n+    ExprUseVisitor::new(&mut delegate, cx.tcx, cx.param_env, region_scope_tree, cx.tables, None).walk_expr(expr);\n+\n+    if delegate.skip {\n+        return None;\n+    }\n+    Some(delegate.used_mutably)\n+}\n+\n+pub fn is_potentially_mutated<'a, 'tcx: 'a>(\n+    variable: &'tcx Path,\n+    expr: &'tcx Expr,\n+    cx: &'a LateContext<'a, 'tcx>,\n+) -> bool {\n+    let id = match variable.def {\n+        Def::Local(id) | Def::Upvar(id, ..) => id,\n+        _ => return true,\n+    };\n+    mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&id))\n+}\n+\n+struct MutVarsDelegate {\n+    used_mutably: HashSet<NodeId>,\n+    skip: bool,\n+}\n+\n+impl<'tcx> MutVarsDelegate {\n+    fn update(&mut self, cat: &'tcx Categorization) {\n+        match *cat {\n+            Categorization::Local(id) => {\n+                self.used_mutably.insert(id);\n+            },\n+            Categorization::Upvar(_) => {\n+                //FIXME: This causes false negatives. We can't get the `NodeId` from\n+                //`Categorization::Upvar(_)`. So we search for any `Upvar`s in the\n+                //`while`-body, not just the ones in the condition.\n+                self.skip = true\n+            },\n+            Categorization::Deref(ref cmt, _) | Categorization::Interior(ref cmt, _) => self.update(&cmt.cat),\n+            _ => {},\n+        }\n+    }\n+}\n+\n+impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n+    fn consume(&mut self, _: NodeId, _: Span, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+\n+    fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n+\n+    fn consume_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: ConsumeMode) {}\n+\n+    fn borrow(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: ty::Region, bk: ty::BorrowKind, _: LoanCause) {\n+        if let ty::BorrowKind::MutBorrow = bk {\n+            self.update(&cmt.cat)\n+        }\n+    }\n+\n+    fn mutate(&mut self, _: NodeId, _: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n+        self.update(&cmt.cat)\n+    }\n+\n+    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+}"}, {"sha": "fec52940614dcda921f23a1ae8520e17c0868837", "filename": "tests/ui/checked_unwrap.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/tests%2Fui%2Fchecked_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/tests%2Fui%2Fchecked_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap.rs?ref=d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "patch": "@@ -0,0 +1,75 @@\n+#![deny(unnecessary_unwrap)]\n+\n+fn main() {\n+    let x = Some(());\n+    if x.is_some() {\n+        x.unwrap();\n+    }\n+    if x.is_none() {\n+        // nothing to do here\n+    } else {\n+        x.unwrap();\n+    }\n+    let mut x: Result<(), ()> = Ok(());\n+    if x.is_ok() {\n+        x.unwrap();\n+    } else {\n+        x.unwrap_err();\n+    }\n+    if x.is_err() {\n+        x.unwrap_err();\n+    } else {\n+        x.unwrap();\n+    }\n+    if x.is_ok() {\n+        x = Err(());\n+        x.unwrap();\n+    } else {\n+        x = Ok(());\n+        x.unwrap_err();\n+    }\n+}\n+\n+fn test_complex_conditions() {\n+    let x: Result<(), ()> = Ok(());\n+    let y: Result<(), ()> = Ok(());\n+    if x.is_ok() && y.is_err() {\n+        x.unwrap();\n+        y.unwrap_err();\n+    } else {\n+        // not clear whether unwrappable:\n+        x.unwrap_err();\n+        y.unwrap();\n+    }\n+\n+    if x.is_ok() || y.is_ok() {\n+        // not clear whether unwrappable:\n+        x.unwrap();\n+        y.unwrap();\n+    } else {\n+        x.unwrap_err();\n+        y.unwrap_err();\n+    }\n+    let z: Result<(), ()> = Ok(());\n+    if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+        x.unwrap();\n+        y.unwrap_err();\n+        z.unwrap();\n+    }\n+    if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+        // not clear what's unwrappable\n+    } else {\n+        x.unwrap_err();\n+        y.unwrap();\n+        z.unwrap_err();\n+    }\n+}\n+\n+fn test_nested() {\n+    fn nested() {\n+        let x = Some(());\n+        if x.is_some() {\n+            x.unwrap();\n+        }\n+    }\n+}"}, {"sha": "bfa5ec08f2e9e917d7dcdbbabb9bc9b31dd4ff4b", "filename": "tests/ui/checked_unwrap.stderr", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/tests%2Fui%2Fchecked_unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c/tests%2Fui%2Fchecked_unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fchecked_unwrap.stderr?ref=d68b8cea15fa80ebbd99e4b1dd2c7e25fc6c7c9c", "patch": "@@ -0,0 +1,155 @@\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+ --> $DIR/checked_unwrap.rs:6:9\n+  |\n+5 |     if x.is_some() {\n+  |        ----------- the check is happening here\n+6 |         x.unwrap();\n+  |         ^^^^^^^^^^\n+  |\n+note: lint level defined here\n+ --> $DIR/checked_unwrap.rs:1:9\n+  |\n+1 | #![deny(unnecessary_unwrap)]\n+  |         ^^^^^^^^^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:11:9\n+   |\n+8  |     if x.is_none() {\n+   |        ----------- the check is happening here\n+...\n+11 |         x.unwrap();\n+   |         ^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:15:9\n+   |\n+14 |     if x.is_ok() {\n+   |        --------- the check is happening here\n+15 |         x.unwrap();\n+   |         ^^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:17:9\n+   |\n+14 |     if x.is_ok() {\n+   |        --------- the check is happening here\n+...\n+17 |         x.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:20:9\n+   |\n+19 |     if x.is_err() {\n+   |        ---------- the check is happening here\n+20 |         x.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:22:9\n+   |\n+19 |     if x.is_err() {\n+   |        ---------- the check is happening here\n+...\n+22 |         x.unwrap();\n+   |         ^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:37:9\n+   |\n+36 |     if x.is_ok() && y.is_err() {\n+   |        --------- the check is happening here\n+37 |         x.unwrap();\n+   |         ^^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:38:9\n+   |\n+36 |     if x.is_ok() && y.is_err() {\n+   |                     ---------- the check is happening here\n+37 |         x.unwrap();\n+38 |         y.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:50:9\n+   |\n+45 |     if x.is_ok() || y.is_ok() {\n+   |        --------- the check is happening here\n+...\n+50 |         x.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:51:9\n+   |\n+45 |     if x.is_ok() || y.is_ok() {\n+   |                     --------- the check is happening here\n+...\n+51 |         y.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:55:9\n+   |\n+54 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+   |        --------- the check is happening here\n+55 |         x.unwrap();\n+   |         ^^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:56:9\n+   |\n+54 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+   |                       --------- the check is happening here\n+55 |         x.unwrap();\n+56 |         y.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:57:9\n+   |\n+54 |     if x.is_ok() && !(y.is_ok() || z.is_err()) {\n+   |                                    ---------- the check is happening here\n+...\n+57 |         z.unwrap();\n+   |         ^^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:62:9\n+   |\n+59 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+   |        --------- the check is happening here\n+...\n+62 |         x.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:63:9\n+   |\n+59 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+   |                       --------- the check is happening here\n+...\n+63 |         y.unwrap();\n+   |         ^^^^^^^^^^\n+\n+error: You checked before that `unwrap_err()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:64:9\n+   |\n+59 |     if x.is_ok() || !(y.is_ok() && z.is_err()) {\n+   |                                    ---------- the check is happening here\n+...\n+64 |         z.unwrap_err();\n+   |         ^^^^^^^^^^^^^^\n+\n+error: You checked before that `unwrap()` cannot fail. Instead of checking and unwrapping, it's better to use `if let` or `match`.\n+  --> $DIR/checked_unwrap.rs:72:13\n+   |\n+71 |         if x.is_some() {\n+   |            ----------- the check is happening here\n+72 |             x.unwrap();\n+   |             ^^^^^^^^^^\n+\n+error: aborting due to 17 previous errors\n+"}]}