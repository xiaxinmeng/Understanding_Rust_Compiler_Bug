{"sha": "d2657769a22f15098343f9272f52a01145698786", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyNjU3NzY5YTIyZjE1MDk4MzQzZjkyNzJmNTJhMDExNDU2OTg3ODY=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-29T17:29:58Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-29T20:10:37Z"}, "message": "Improve `clone_on_copy`\nLint on `_.clone().method()` when method takes self by value\nSet applicability correctly\nCorrect suggestion when the cloned value is a macro call. e.g. `m!(x).clone()`\nDon't lint when not using the `Clone` trait", "tree": {"sha": "6cf09d1db6aa03017013baedc2157f8a82d53e66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6cf09d1db6aa03017013baedc2157f8a82d53e66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2657769a22f15098343f9272f52a01145698786", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmBiNEgACgkQ2lnoZDo37QbbBwD/Q2L1HpvHdedjZ8bsi90VzP1k\nNGmc9MW/T0zBoCPJIBcA/0uNzrFOx3K9LNALkDOSFZaRGw/0XvOA5WeHFgsxcj4C\n=lNAc\n-----END PGP SIGNATURE-----", "payload": "tree 6cf09d1db6aa03017013baedc2157f8a82d53e66\nparent 8e56a2b27f005e7f81756ccc281eca69900dddd7\nauthor Jason Newcomb <jsnewcomb@pm.me> 1617038998 -0400\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1617048637 -0400\n\nImprove `clone_on_copy`\nLint on `_.clone().method()` when method takes self by value\nSet applicability correctly\nCorrect suggestion when the cloned value is a macro call. e.g. `m!(x).clone()`\nDon't lint when not using the `Clone` trait\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2657769a22f15098343f9272f52a01145698786", "html_url": "https://github.com/rust-lang/rust/commit/d2657769a22f15098343f9272f52a01145698786", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2657769a22f15098343f9272f52a01145698786/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e56a2b27f005e7f81756ccc281eca69900dddd7", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e56a2b27f005e7f81756ccc281eca69900dddd7", "html_url": "https://github.com/rust-lang/rust/commit/8e56a2b27f005e7f81756ccc281eca69900dddd7"}], "stats": {"total": 234, "additions": 157, "deletions": 77}, "files": [{"sha": "ce2e8fa8b1074aaa8b9324a4554e6ff63b249658", "filename": "clippy_lints/src/methods/clone_on_copy.rs", "status": "modified", "additions": 67, "deletions": 51, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/d2657769a22f15098343f9272f52a01145698786/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2657769a22f15098343f9272f52a01145698786/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fclone_on_copy.rs?ref=d2657769a22f15098343f9272f52a01145698786", "patch": "@@ -1,23 +1,39 @@\n-use clippy_utils::diagnostics::span_lint_and_then;\n+use clippy_utils::diagnostics::{span_lint_and_sugg, span_lint_and_then};\n+use clippy_utils::get_parent_node;\n+use clippy_utils::source::snippet_with_context;\n use clippy_utils::sugg;\n use clippy_utils::ty::is_copy;\n use rustc_errors::Applicability;\n-use rustc_hir as hir;\n+use rustc_hir::{BindingAnnotation, Expr, ExprKind, MatchSource, Node, PatKind};\n use rustc_lint::LateContext;\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, adjustment::Adjust};\n use rustc_span::symbol::{sym, Symbol};\n use std::iter;\n \n use super::CLONE_DOUBLE_REF;\n use super::CLONE_ON_COPY;\n \n /// Checks for the `CLONE_ON_COPY` lint.\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Symbol, args: &[hir::Expr<'_>]) {\n-    if !(args.len() == 1 && method_name == sym::clone) {\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check(cx: &LateContext<'_>, expr: &Expr<'_>, method_name: Symbol, args: &[Expr<'_>]) {\n+    let arg = match args {\n+        [arg] if method_name == sym::clone => arg,\n+        _ => return,\n+    };\n+    if cx\n+        .typeck_results()\n+        .type_dependent_def_id(expr.hir_id)\n+        .and_then(|id| cx.tcx.trait_of_item(id))\n+        .zip(cx.tcx.lang_items().clone_trait())\n+        .map_or(true, |(x, y)| x != y)\n+    {\n         return;\n     }\n-    let arg = &args[0];\n-    let arg_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let arg_adjustments = cx.typeck_results().expr_adjustments(arg);\n+    let arg_ty = arg_adjustments\n+        .last()\n+        .map_or_else(|| cx.typeck_results().expr_ty(arg), |a| a.target);\n+\n     let ty = cx.typeck_results().expr_ty(expr);\n     if let ty::Ref(_, inner, _) = arg_ty.kind() {\n         if let ty::Ref(_, innermost, _) = inner.kind() {\n@@ -61,57 +77,57 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_name: Sym\n     }\n \n     if is_copy(cx, ty) {\n-        let snip;\n-        if let Some(snippet) = sugg::Sugg::hir_opt(cx, arg) {\n-            let parent = cx.tcx.hir().get_parent_node(expr.hir_id);\n-            match &cx.tcx.hir().get(parent) {\n-                hir::Node::Expr(parent) => match parent.kind {\n-                    // &*x is a nop, &x.clone() is not\n-                    hir::ExprKind::AddrOf(..) => return,\n-                    // (*x).func() is useless, x.clone().func() can work in case func borrows mutably\n-                    hir::ExprKind::MethodCall(_, _, parent_args, _) if expr.hir_id == parent_args[0].hir_id => {\n-                        return;\n-                    },\n-\n-                    _ => {},\n-                },\n-                hir::Node::Stmt(stmt) => {\n-                    if let hir::StmtKind::Local(ref loc) = stmt.kind {\n-                        if let hir::PatKind::Ref(..) = loc.pat.kind {\n-                            // let ref y = *x borrows x, let ref y = x.clone() does not\n-                            return;\n-                        }\n-                    }\n-                },\n-                _ => {},\n+        let parent_is_suffix_expr = match get_parent_node(cx.tcx, expr.hir_id) {\n+            Some(Node::Expr(parent)) => match parent.kind {\n+                // &*x is a nop, &x.clone() is not\n+                ExprKind::AddrOf(..) => return,\n+                // (*x).func() is useless, x.clone().func() can work in case func borrows self\n+                ExprKind::MethodCall(_, _, [self_arg, ..], _)\n+                    if expr.hir_id == self_arg.hir_id && ty != cx.typeck_results().expr_ty_adjusted(expr) =>\n+                {\n+                    return;\n+                }\n+                ExprKind::MethodCall(_, _, [self_arg, ..], _) if expr.hir_id == self_arg.hir_id => true,\n+                ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n+                | ExprKind::Field(..)\n+                | ExprKind::Index(..) => true,\n+                _ => false,\n+            },\n+            // local binding capturing a reference\n+            Some(Node::Local(l))\n+                if matches!(\n+                    l.pat.kind,\n+                    PatKind::Binding(BindingAnnotation::Ref | BindingAnnotation::RefMut, ..)\n+                ) =>\n+            {\n+                return;\n             }\n+            _ => false,\n+        };\n \n-            // x.clone() might have dereferenced x, possibly through Deref impls\n-            if cx.typeck_results().expr_ty(arg) == ty {\n-                snip = Some((\"try removing the `clone` call\", format!(\"{}\", snippet)));\n-            } else {\n-                let deref_count = cx\n-                    .typeck_results()\n-                    .expr_adjustments(arg)\n-                    .iter()\n-                    .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n-                    .count();\n-                let derefs: String = iter::repeat('*').take(deref_count).collect();\n-                snip = Some((\"try dereferencing it\", format!(\"{}{}\", derefs, snippet)));\n-            }\n+        let mut app = Applicability::MachineApplicable;\n+        let snip = snippet_with_context(cx, arg.span, expr.span.ctxt(), \"_\", &mut app).0;\n+\n+        let deref_count = arg_adjustments\n+            .iter()\n+            .take_while(|adj| matches!(adj.kind, Adjust::Deref(_)))\n+            .count();\n+        let (help, sugg) = if deref_count == 0 {\n+            (\"try removing the `clone` call\", snip.into())\n+        } else if parent_is_suffix_expr {\n+            (\"try dereferencing it\", format!(\"({}{})\", \"*\".repeat(deref_count), snip))\n         } else {\n-            snip = None;\n-        }\n-        span_lint_and_then(\n+            (\"try dereferencing it\", format!(\"{}{}\", \"*\".repeat(deref_count), snip))\n+        };\n+\n+        span_lint_and_sugg(\n             cx,\n             CLONE_ON_COPY,\n             expr.span,\n             &format!(\"using `clone` on type `{}` which implements the `Copy` trait\", ty),\n-            |diag| {\n-                if let Some((text, snip)) = snip {\n-                    diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n-                }\n-            },\n+            help,\n+            sugg,\n+            app,\n         );\n     }\n }"}, {"sha": "8d43f64768d417f3b7323ce95dcfe4bf490b2279", "filename": "tests/ui/clone_on_copy.fixed", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d2657769a22f15098343f9272f52a01145698786/tests%2Fui%2Fclone_on_copy.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/d2657769a22f15098343f9272f52a01145698786/tests%2Fui%2Fclone_on_copy.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.fixed?ref=d2657769a22f15098343f9272f52a01145698786", "patch": "@@ -6,7 +6,8 @@\n     clippy::deref_addrof,\n     clippy::no_effect,\n     clippy::unnecessary_operation,\n-    clippy::vec_init_then_push\n+    clippy::vec_init_then_push,\n+    clippy::toplevel_ref_arg\n )]\n \n use std::cell::RefCell;\n@@ -29,6 +30,37 @@ fn clone_on_copy() {\n     let rc = RefCell::new(0);\n     *rc.borrow();\n \n+    let x = 0u32;\n+    x.rotate_left(1);\n+\n+    #[derive(Clone, Copy)]\n+    struct Foo;\n+    impl Foo {\n+        fn clone(&self) -> u32 {\n+            0\n+        }\n+    }\n+    Foo.clone(); // ok, this is not the clone trait\n+\n+    macro_rules! m {\n+        ($e:expr) => {{ $e }};\n+    }\n+    m!(42);\n+\n+    struct Wrap([u32; 2]);\n+    impl core::ops::Deref for Wrap {\n+        type Target = [u32; 2];\n+        fn deref(&self) -> &[u32; 2] {\n+            &self.0\n+        }\n+    }\n+    let x = Wrap([0, 0]);\n+    (*x)[0];\n+\n+    let x = 42;\n+    let ref y = x.clone(); // ok, binds by reference\n+    let ref mut y = x.clone(); // ok, binds by reference\n+\n     // Issue #4348\n     let mut x = 43;\n     let _ = &x.clone(); // ok, getting a ref"}, {"sha": "f15501f71844f0ceb1b9f4a59acd5e5952e30540", "filename": "tests/ui/clone_on_copy.rs", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d2657769a22f15098343f9272f52a01145698786/tests%2Fui%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2657769a22f15098343f9272f52a01145698786/tests%2Fui%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.rs?ref=d2657769a22f15098343f9272f52a01145698786", "patch": "@@ -6,7 +6,8 @@\n     clippy::deref_addrof,\n     clippy::no_effect,\n     clippy::unnecessary_operation,\n-    clippy::vec_init_then_push\n+    clippy::vec_init_then_push,\n+    clippy::toplevel_ref_arg\n )]\n \n use std::cell::RefCell;\n@@ -29,6 +30,37 @@ fn clone_on_copy() {\n     let rc = RefCell::new(0);\n     rc.borrow().clone();\n \n+    let x = 0u32;\n+    x.clone().rotate_left(1);\n+\n+    #[derive(Clone, Copy)]\n+    struct Foo;\n+    impl Foo {\n+        fn clone(&self) -> u32 {\n+            0\n+        }\n+    }\n+    Foo.clone(); // ok, this is not the clone trait\n+\n+    macro_rules! m {\n+        ($e:expr) => {{ $e }};\n+    }\n+    m!(42).clone();\n+\n+    struct Wrap([u32; 2]);\n+    impl core::ops::Deref for Wrap {\n+        type Target = [u32; 2];\n+        fn deref(&self) -> &[u32; 2] {\n+            &self.0\n+        }\n+    }\n+    let x = Wrap([0, 0]);\n+    x.clone()[0];\n+\n+    let x = 42;\n+    let ref y = x.clone(); // ok, binds by reference\n+    let ref mut y = x.clone(); // ok, binds by reference\n+\n     // Issue #4348\n     let mut x = 43;\n     let _ = &x.clone(); // ok, getting a ref"}, {"sha": "e7d28b4320bc862691b54709ed4e8bbe605d04ac", "filename": "tests/ui/clone_on_copy.stderr", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d2657769a22f15098343f9272f52a01145698786/tests%2Fui%2Fclone_on_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d2657769a22f15098343f9272f52a01145698786/tests%2Fui%2Fclone_on_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy.stderr?ref=d2657769a22f15098343f9272f52a01145698786", "patch": "@@ -1,34 +1,52 @@\n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:23:5\n+  --> $DIR/clone_on_copy.rs:24:5\n    |\n LL |     42.clone();\n    |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n    |\n    = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:27:5\n+  --> $DIR/clone_on_copy.rs:28:5\n    |\n LL |     (&42).clone();\n    |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:30:5\n+  --> $DIR/clone_on_copy.rs:31:5\n    |\n LL |     rc.borrow().clone();\n    |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n \n+error: using `clone` on type `u32` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:34:5\n+   |\n+LL |     x.clone().rotate_left(1);\n+   |     ^^^^^^^^^ help: try removing the `clone` call: `x`\n+\n+error: using `clone` on type `i32` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:48:5\n+   |\n+LL |     m!(42).clone();\n+   |     ^^^^^^^^^^^^^^ help: try removing the `clone` call: `m!(42)`\n+\n+error: using `clone` on type `[u32; 2]` which implements the `Copy` trait\n+  --> $DIR/clone_on_copy.rs:58:5\n+   |\n+LL |     x.clone()[0];\n+   |     ^^^^^^^^^ help: try dereferencing it: `(*x)`\n+\n error: using `clone` on type `char` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:36:14\n+  --> $DIR/clone_on_copy.rs:68:14\n    |\n LL |     is_ascii('z'.clone());\n    |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n \n error: using `clone` on type `i32` which implements the `Copy` trait\n-  --> $DIR/clone_on_copy.rs:40:14\n+  --> $DIR/clone_on_copy.rs:72:14\n    |\n LL |     vec.push(42.clone());\n    |              ^^^^^^^^^^ help: try removing the `clone` call: `42`\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 8 previous errors\n "}, {"sha": "5bfa256623b6bbcd5b56bb93421b655e417f0d68", "filename": "tests/ui/clone_on_copy_mut.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e56a2b27f005e7f81756ccc281eca69900dddd7/tests%2Fui%2Fclone_on_copy_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e56a2b27f005e7f81756ccc281eca69900dddd7/tests%2Fui%2Fclone_on_copy_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclone_on_copy_mut.rs?ref=8e56a2b27f005e7f81756ccc281eca69900dddd7", "patch": "@@ -1,18 +0,0 @@\n-pub fn dec_read_dec(i: &mut i32) -> i32 {\n-    *i -= 1;\n-    let ret = *i;\n-    *i -= 1;\n-    ret\n-}\n-\n-pub fn minus_1(i: &i32) -> i32 {\n-    dec_read_dec(&mut i.clone())\n-}\n-\n-fn main() {\n-    let mut i = 10;\n-    assert_eq!(minus_1(&i), 9);\n-    assert_eq!(i, 10);\n-    assert_eq!(dec_read_dec(&mut i), 9);\n-    assert_eq!(i, 8);\n-}"}]}