{"sha": "0e5edc9f1611e5c13864e4f66a9e69ce7776ea91", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlNWVkYzlmMTYxMWU1YzEzODY0ZTRmNjZhOWU2OWNlNzc3NmVhOTE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-06-06T20:27:23Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-06-06T20:27:23Z"}, "message": "Add intrinsics for floating-point min and max", "tree": {"sha": "318c9ca1854557a859b08ef2687fe23a62c545bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/318c9ca1854557a859b08ef2687fe23a62c545bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91", "html_url": "https://github.com/rust-lang/rust/commit/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a31848350b1ccee5039c8e64fa3c6ea3edcbb1b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/a31848350b1ccee5039c8e64fa3c6ea3edcbb1b0", "html_url": "https://github.com/rust-lang/rust/commit/a31848350b1ccee5039c8e64fa3c6ea3edcbb1b0"}], "stats": {"total": 119, "additions": 82, "deletions": 37}, "files": [{"sha": "b609af16ffe5bd2ae51abbe7aeb9a7bae6d29252", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=0e5edc9f1611e5c13864e4f66a9e69ce7776ea91", "patch": "@@ -1051,6 +1051,19 @@ extern \"rust-intrinsic\" {\n     /// Returns the absolute value of an `f64`.\n     pub fn fabsf64(x: f64) -> f64;\n \n+    /// Returns the minimum of two `f32` values.\n+    #[cfg(not(bootstrap))]\n+    pub fn minnumf32(x: f32, y: f32) -> f32;\n+    /// Returns the minimum of two `f64` values.\n+    #[cfg(not(bootstrap))]\n+    pub fn minnumf64(x: f64, y: f64) -> f64;\n+    /// Returns the maximum of two `f32` values.\n+    #[cfg(not(bootstrap))]\n+    pub fn maxnumf32(x: f32, y: f32) -> f32;\n+    /// Returns the maximum of two `f64` values.\n+    #[cfg(not(bootstrap))]\n+    pub fn maxnumf64(x: f64, y: f64) -> f64;\n+\n     /// Copies the sign from `y` to `x` for `f32` values.\n     pub fn copysignf32(x: f32, y: f32) -> f32;\n     /// Copies the sign from `y` to `x` for `f64` values.\n@@ -1561,3 +1574,47 @@ pub unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n pub unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n     real_intrinsics::write_bytes(dst, val, count)\n }\n+\n+// Simple bootstrap implementations of minnum/maxnum for stage0 compilation.\n+\n+/// Returns the minimum of two `f32` values.\n+#[cfg(bootstrap)]\n+pub fn minnumf32(x: f32, y: f32) -> f32 {\n+    // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n+    // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+    // is either x or y, canonicalized (this means results might differ among implementations).\n+    // When either x or y is a signaling NaN, then the result is according to 6.2.\n+    //\n+    // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+    // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+    // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+    (if x < y || y != y { x } else { y }) * 1.0\n+}\n+\n+/// Returns the minimum of two `f64` values.\n+#[cfg(bootstrap)]\n+pub fn minnumf64(x: f64, y: f64) -> f64 {\n+    // Identical to the `f32` case.\n+    (if x < y || y != y { x } else { y }) * 1.0\n+}\n+\n+/// Returns the maximum of two `f32` values.\n+#[cfg(bootstrap)]\n+pub fn maxnumf32(x: f32, y: f32) -> f32 {\n+    // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n+    // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n+    // is either x or y, canonicalized (this means results might differ among implementations).\n+    // When either x or y is a signaling NaN, then the result is according to 6.2.\n+    //\n+    // Since we do not support sNaN in Rust yet, we do not need to handle them.\n+    // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n+    // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n+    (if x < y || x != x { y } else { x }) * 1.0\n+}\n+\n+/// Returns the maximum of two `f64` values.\n+#[cfg(bootstrap)]\n+pub fn maxnumf64(x: f64, y: f64) -> f64 {\n+    // Identical to the `f32` case.\n+    (if x < y || x != x { y } else { x }) * 1.0\n+}"}, {"sha": "0bcd371b528e43b5a0bd1a235cc36f8d9e98f35f", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=0e5edc9f1611e5c13864e4f66a9e69ce7776ea91", "patch": "@@ -7,6 +7,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(test))]\n+use crate::intrinsics;\n+\n use crate::mem;\n use crate::num::FpCategory;\n \n@@ -372,15 +375,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f32) -> f32 {\n-        // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n-        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n-        // is either x or y, canonicalized (this means results might differ among implementations).\n-        // When either x or y is a signalingNaN, then the result is according to 6.2.\n-        //\n-        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n-        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n-        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n-        (if self.is_nan() || self < other { other } else { self }) * 1.0\n+        intrinsics::maxnumf32(self, other)\n     }\n \n     /// Returns the minimum of the two numbers.\n@@ -396,15 +391,7 @@ impl f32 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f32) -> f32 {\n-        // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n-        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n-        // is either x or y, canonicalized (this means results might differ among implementations).\n-        // When either x or y is a signalingNaN, then the result is according to 6.2.\n-        //\n-        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n-        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n-        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n-        (if other.is_nan() || self < other { self } else { other }) * 1.0\n+        intrinsics::minnumf32(self, other)\n     }\n \n     /// Raw transmutation to `u32`."}, {"sha": "4d4a2c9c5a97cc7c63cd642ae25ea02125b98469", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 5, "deletions": 18, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=0e5edc9f1611e5c13864e4f66a9e69ce7776ea91", "patch": "@@ -7,6 +7,9 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+#[cfg(not(test))]\n+use crate::intrinsics;\n+\n use crate::mem;\n use crate::num::FpCategory;\n \n@@ -385,15 +388,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn max(self, other: f64) -> f64 {\n-        // IEEE754 says: maxNum(x, y) is the canonicalized number y if x < y, x if y < x, the\n-        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n-        // is either x or y, canonicalized (this means results might differ among implementations).\n-        // When either x or y is a signalingNaN, then the result is according to 6.2.\n-        //\n-        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n-        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n-        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n-        (if self.is_nan() || self < other { other } else { self }) * 1.0\n+        intrinsics::maxnumf64(self, other)\n     }\n \n     /// Returns the minimum of the two numbers.\n@@ -409,15 +404,7 @@ impl f64 {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn min(self, other: f64) -> f64 {\n-        // IEEE754 says: minNum(x, y) is the canonicalized number x if x < y, y if y < x, the\n-        // canonicalized number if one operand is a number and the other a quiet NaN. Otherwise it\n-        // is either x or y, canonicalized (this means results might differ among implementations).\n-        // When either x or y is a signalingNaN, then the result is according to 6.2.\n-        //\n-        // Since we do not support sNaN in Rust yet, we do not need to handle them.\n-        // FIXME(nagisa): due to https://bugs.llvm.org/show_bug.cgi?id=33303 we canonicalize by\n-        // multiplying by 1.0. Should switch to the `canonicalize` when it works.\n-        (if other.is_nan() || self < other { self } else { other }) * 1.0\n+        intrinsics::minnumf64(self, other)\n     }\n \n     /// Raw transmutation to `u64`."}, {"sha": "2bc46334555ec88eaa0ce628b94611c28a0d69e1", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=0e5edc9f1611e5c13864e4f66a9e69ce7776ea91", "patch": "@@ -645,6 +645,11 @@ impl CodegenCx<'b, 'tcx> {\n         ifn!(\"llvm.fabs.v4f64\", fn(t_v4f64) -> t_v4f64);\n         ifn!(\"llvm.fabs.v8f64\", fn(t_v8f64) -> t_v8f64);\n \n+        ifn!(\"llvm.minnum.f32\", fn(t_f32, t_f32) -> t_f32);\n+        ifn!(\"llvm.minnum.f64\", fn(t_f64, t_f64) -> t_f64);\n+        ifn!(\"llvm.maxnum.f32\", fn(t_f32, t_f32) -> t_f32);\n+        ifn!(\"llvm.maxnum.f64\", fn(t_f64, t_f64) -> t_f64);\n+\n         ifn!(\"llvm.floor.f32\", fn(t_f32) -> t_f32);\n         ifn!(\"llvm.floor.v2f32\", fn(t_v2f32) -> t_v2f32);\n         ifn!(\"llvm.floor.v4f32\", fn(t_v4f32) -> t_v4f32);"}, {"sha": "875f1d0940a3a1a740aafab96f8470abf1d5f425", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=0e5edc9f1611e5c13864e4f66a9e69ce7776ea91", "patch": "@@ -55,6 +55,10 @@ fn get_simple_intrinsic(cx: &CodegenCx<'ll, '_>, name: &str) -> Option<&'ll Valu\n         \"fmaf64\" => \"llvm.fma.f64\",\n         \"fabsf32\" => \"llvm.fabs.f32\",\n         \"fabsf64\" => \"llvm.fabs.f64\",\n+        \"minnumf32\" => \"llvm.minnum.f32\",\n+        \"minnumf64\" => \"llvm.minnum.f64\",\n+        \"maxnumf32\" => \"llvm.maxnum.f32\",\n+        \"maxnumf64\" => \"llvm.maxnum.f64\",\n         \"copysignf32\" => \"llvm.copysign.f32\",\n         \"copysignf64\" => \"llvm.copysign.f64\",\n         \"floorf32\" => \"llvm.floor.f32\","}, {"sha": "11598ad4c9c02dcbbe4f4d4179d05f12089bd107", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e5edc9f1611e5c13864e4f66a9e69ce7776ea91/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=0e5edc9f1611e5c13864e4f66a9e69ce7776ea91", "patch": "@@ -70,7 +70,8 @@ pub fn intrisic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n         \"overflowing_add\" | \"overflowing_sub\" | \"overflowing_mul\" |\n         \"saturating_add\" | \"saturating_sub\" |\n         \"rotate_left\" | \"rotate_right\" |\n-        \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" | \"bitreverse\"\n+        \"ctpop\" | \"ctlz\" | \"cttz\" | \"bswap\" | \"bitreverse\" |\n+        \"minnumf32\" | \"minnumf64\" | \"maxnumf32\" | \"maxnumf64\"\n         => hir::Unsafety::Normal,\n         _ => hir::Unsafety::Unsafe,\n     }\n@@ -272,6 +273,10 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             }\n             \"fabsf32\"      => (0, vec![ tcx.types.f32 ], tcx.types.f32),\n             \"fabsf64\"      => (0, vec![ tcx.types.f64 ], tcx.types.f64),\n+            \"minnumf32\"    => (0, vec![ tcx.types.f32, tcx.types.f32 ], tcx.types.f32),\n+            \"minnumf64\"    => (0, vec![ tcx.types.f64, tcx.types.f64 ], tcx.types.f64),\n+            \"maxnumf32\"    => (0, vec![ tcx.types.f32, tcx.types.f32 ], tcx.types.f32),\n+            \"maxnumf64\"    => (0, vec![ tcx.types.f64, tcx.types.f64 ], tcx.types.f64),\n             \"copysignf32\"  => (0, vec![ tcx.types.f32, tcx.types.f32 ], tcx.types.f32),\n             \"copysignf64\"  => (0, vec![ tcx.types.f64, tcx.types.f64 ], tcx.types.f64),\n             \"floorf32\"     => (0, vec![ tcx.types.f32 ], tcx.types.f32),"}]}