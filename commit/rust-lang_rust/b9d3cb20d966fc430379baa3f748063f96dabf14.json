{"sha": "b9d3cb20d966fc430379baa3f748063f96dabf14", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5ZDNjYjIwZDk2NmZjNDMwMzc5YmFhM2Y3NDgwNjNmOTZkYWJmMTQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-05-12T01:08:11Z"}, "committer": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2015-05-12T01:08:11Z"}, "message": "Merge pull request #65 from marcusklaas/required-methods\n\nFormat required methods on traits", "tree": {"sha": "34e53295f52b7c669a973d7fc9b2aab3dbea7735", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34e53295f52b7c669a973d7fc9b2aab3dbea7735"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9d3cb20d966fc430379baa3f748063f96dabf14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9d3cb20d966fc430379baa3f748063f96dabf14", "html_url": "https://github.com/rust-lang/rust/commit/b9d3cb20d966fc430379baa3f748063f96dabf14", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9d3cb20d966fc430379baa3f748063f96dabf14/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6b1494885c724a4875daa0e6f56e2499647e1e59", "url": "https://api.github.com/repos/rust-lang/rust/commits/6b1494885c724a4875daa0e6f56e2499647e1e59", "html_url": "https://github.com/rust-lang/rust/commit/6b1494885c724a4875daa0e6f56e2499647e1e59"}, {"sha": "4aa35187035b551d27045b6c712979b6fecbd74f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4aa35187035b551d27045b6c712979b6fecbd74f", "html_url": "https://github.com/rust-lang/rust/commit/4aa35187035b551d27045b6c712979b6fecbd74f"}], "stats": {"total": 129, "additions": 110, "deletions": 19}, "files": [{"sha": "32c38ea15e4de617265f0e7d0857815f562eef67", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3cb20d966fc430379baa3f748063f96dabf14/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3cb20d966fc430379baa3f748063f96dabf14/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=b9d3cb20d966fc430379baa3f748063f96dabf14", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#![cfg(not(test))]\n #![feature(exit_status)]\n \n extern crate rustfmt;"}, {"sha": "2133b7c44184a2c6f681c2bc6c0a0e4b49eac72a", "filename": "src/functions.rs", "status": "modified", "additions": 72, "deletions": 17, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3cb20d966fc430379baa3f748063f96dabf14/src%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3cb20d966fc430379baa3f748063f96dabf14/src%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffunctions.rs?ref=b9d3cb20d966fc430379baa3f748063f96dabf14", "patch": "@@ -28,15 +28,79 @@ impl<'a> FmtVisitor<'a> {\n                       unsafety: &ast::Unsafety,\n                       abi: &abi::Abi,\n                       vis: ast::Visibility,\n-                      next_span: Span) // next_span is a nasty hack, its a loose upper\n-                                       // bound on any comments after the where clause.\n+                      span_end: BytePos)\n+        -> String\n+    {\n+        let newline_brace = self.newline_for_brace(&generics.where_clause);\n+\n+        let mut result = self.rewrite_fn_base(indent,\n+                                              ident,\n+                                              fd,\n+                                              explicit_self,\n+                                              generics,\n+                                              unsafety,\n+                                              abi,\n+                                              vis,\n+                                              span_end,\n+                                              newline_brace);\n+\n+        // Prepare for the function body by possibly adding a newline and indent.\n+        // FIXME we'll miss anything between the end of the signature and the start\n+        // of the body, but we need more spans from the compiler to solve this.\n+        if newline_brace {\n+            result.push('\\n');\n+            result.push_str(&make_indent(indent));\n+        } else {\n+            result.push(' ');\n+        }\n+\n+        result\n+    }\n+\n+    pub fn rewrite_required_fn(&mut self,\n+                               indent: usize,\n+                               ident: ast::Ident,\n+                               sig: &ast::MethodSig,\n+                               span: Span)\n+        -> String\n+    {\n+        // Drop semicolon or it will be interpreted as comment\n+        let span_end = span.hi - BytePos(1);\n+\n+        let mut result = self.rewrite_fn_base(indent,\n+                                              ident,\n+                                              &sig.decl,\n+                                              Some(&sig.explicit_self),\n+                                              &sig.generics,\n+                                              &sig.unsafety,\n+                                              &sig.abi,\n+                                              ast::Visibility::Inherited,\n+                                              span_end,\n+                                              false);\n+\n+        // Re-attach semicolon\n+        result.push(';');\n+\n+        result\n+    }\n+\n+    fn rewrite_fn_base(&mut self,\n+                       indent: usize,\n+                       ident: ast::Ident,\n+                       fd: &ast::FnDecl,\n+                       explicit_self: Option<&ast::ExplicitSelf>,\n+                       generics: &ast::Generics,\n+                       unsafety: &ast::Unsafety,\n+                       abi: &abi::Abi,\n+                       vis: ast::Visibility,\n+                       span_end: BytePos,\n+                       newline_brace: bool)\n         -> String\n     {\n         // FIXME we'll lose any comments in between parts of the function decl, but anyone\n         // who comments there probably deserves what they get.\n \n         let where_clause = &generics.where_clause;\n-        let newline_brace = self.newline_for_brace(where_clause);\n \n         let mut result = String::with_capacity(1024);\n         // Vis unsafety abi.\n@@ -104,7 +168,7 @@ impl<'a> FmtVisitor<'a> {\n             // Comment between return type and the end of the decl.\n             let snippet_lo = fd.output.span().hi;\n             if where_clause.predicates.len() == 0 {\n-                let snippet_hi = next_span.lo;\n+                let snippet_hi = span_end;\n                 let snippet = self.snippet(codemap::mk_sp(snippet_lo, snippet_hi));\n                 let snippet = snippet.trim();\n                 if snippet.len() > 0 {\n@@ -119,17 +183,7 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         // Where clause.\n-        result.push_str(&self.rewrite_where_clause(where_clause, indent, next_span));\n-\n-        // Prepare for the function body by possibly adding a newline and indent.\n-        // FIXME we'll miss anything between the end of the signature and the start\n-        // of the body, but we need more spans from the compiler to solve this.\n-        if newline_brace {\n-            result.push('\\n');\n-            result.push_str(&make_indent(self.block_indent));\n-        } else {\n-            result.push(' ');\n-        }\n+        result.push_str(&self.rewrite_where_clause(where_clause, indent, span_end));\n \n         result\n     }\n@@ -396,7 +450,7 @@ impl<'a> FmtVisitor<'a> {\n     fn rewrite_where_clause(&self,\n                             where_clause: &ast::WhereClause,\n                             indent: usize,\n-                            next_span: Span)\n+                            span_end: BytePos)\n         -> String\n     {\n         let mut result = String::new();\n@@ -414,7 +468,8 @@ impl<'a> FmtVisitor<'a> {\n                                                    \"{\",\n                                                    |pred| span_for_where_pred(pred).lo,\n                                                    |pred| span_for_where_pred(pred).hi,\n-                                                   next_span.lo);\n+                                                   span_end);\n+\n         let where_strs: Vec<_> = where_clause.predicates.iter()\n                                                         .map(|p| (self.rewrite_pred(p)))\n                                                         .zip(comments.into_iter())"}, {"sha": "3cc9b36222bbbd031c82460cbc62be046158ab05", "filename": "src/visitor.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3cb20d966fc430379baa3f748063f96dabf14/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3cb20d966fc430379baa3f748063f96dabf14/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=b9d3cb20d966fc430379baa3f748063f96dabf14", "patch": "@@ -107,7 +107,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                              unsafety,\n                                              abi,\n                                              vis,\n-                                             b.span);\n+                                             b.span.lo);\n                 self.changes.push_str_span(s, &new_fn);\n             }\n             visit::FkMethod(ident, ref sig, vis) => {\n@@ -119,7 +119,7 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                                              &sig.unsafety,\n                                              &sig.abi,\n                                              vis.unwrap_or(ast::Visibility::Inherited),\n-                                             b.span);\n+                                             b.span.lo);\n                 self.changes.push_str_span(s, &new_fn);\n             }\n             visit::FkFnBlock(..) => {}\n@@ -190,6 +190,21 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n         if self.visit_attrs(&ti.attrs) {\n             return;\n         }\n+\n+        if let ast::TraitItem_::MethodTraitItem(ref sig, None) = ti.node {\n+            self.format_missing_with_indent(ti.span.lo);\n+\n+            let indent = self.block_indent;\n+            let new_fn = self.rewrite_required_fn(indent,\n+                                                  ti.ident,\n+                                                  sig,\n+                                                  ti.span);\n+\n+            self.changes.push_str_span(ti.span, &new_fn);\n+            self.last_pos = ti.span.hi;\n+        }\n+        // TODO format trait types\n+\n         visit::walk_trait_item(self, ti)\n     }\n "}, {"sha": "8f7f4be67c9ba3044c6b50e6c3383a84c6a478d4", "filename": "tests/idem/trait.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b9d3cb20d966fc430379baa3f748063f96dabf14/tests%2Fidem%2Ftrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d3cb20d966fc430379baa3f748063f96dabf14/tests%2Fidem%2Ftrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fidem%2Ftrait.rs?ref=b9d3cb20d966fc430379baa3f748063f96dabf14", "patch": "@@ -0,0 +1,20 @@\n+// Test traits\n+\n+trait Foo {\n+    fn bar(x: i32) -> Baz<U> {\n+        Baz::new()\n+    }\n+\n+    fn baz(a: AAAAAAAAAAAAAAAAAAAAAA, b: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB) -> RetType;\n+\n+    fn foo(a: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA, // Another comment\n+           b: BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB)\n+           -> RetType; // Some comment\n+\n+    fn baz(&mut self) -> i32;\n+\n+    fn increment(&mut self, x: i32);\n+\n+    fn read(&mut self, x: BufReader<R> /* Used to be MemReader */)\n+        where R: Read;\n+}"}]}