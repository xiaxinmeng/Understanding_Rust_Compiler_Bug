{"sha": "03dcf5111ad23700335d25ef02749666bbd08cca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZGNmNTExMWFkMjM3MDAzMzVkMjVlZjAyNzQ5NjY2YmJkMDhjY2E=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-10-02T19:02:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-10-02T19:02:03Z"}, "message": "Merge #6125\n\n6125: Simplify ast_transform r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "4e8effd1f7c43cfd29d0a8ec3b951fe0e26c6c01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e8effd1f7c43cfd29d0a8ec3b951fe0e26c6c01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03dcf5111ad23700335d25ef02749666bbd08cca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfd3krCRBK7hj4Ov3rIwAAdHIIAHjJdCwBv/6n4reLEP4QPrz0\n0T+Z0M2DSRlSupNuEYXqULWMP1C2kc+rAjmB3wb4k46bXgV/b+CO+Im7kuOeQhnC\n8Hxf8sLiRrRNO7nGtmFNQq2KkhFOPGI4JgoZz/yjAOPNndiR1CMflOr93sBfZO0T\nDglhfhchy377ydyf8mAkOYpMJGc8p9lIDqyU4OOJk1rrVcL5FePi3od0wMhu9zmf\nGJYpBryiOdqniZ/IJNOYOyHvreRhQKcn8ZZ1twKbS9B1xZFgJUZAkY33pbKx2RkD\nMh37ZlFujqJWkapUIT+mhE3PKpRddfeC8QQX93zLdVfvvoHe1N6iSaojf+21kNI=\n=UAD0\n-----END PGP SIGNATURE-----\n", "payload": "tree 4e8effd1f7c43cfd29d0a8ec3b951fe0e26c6c01\nparent 673e1ddb9ae12c565f966549ba7ea8c306cfba87\nparent 3290bb4112e7988f98b108e3c590d39c881f00e0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1601665323 +0000\ncommitter GitHub <noreply@github.com> 1601665323 +0000\n\nMerge #6125\n\n6125: Simplify ast_transform r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03dcf5111ad23700335d25ef02749666bbd08cca", "html_url": "https://github.com/rust-lang/rust/commit/03dcf5111ad23700335d25ef02749666bbd08cca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03dcf5111ad23700335d25ef02749666bbd08cca/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "673e1ddb9ae12c565f966549ba7ea8c306cfba87", "url": "https://api.github.com/repos/rust-lang/rust/commits/673e1ddb9ae12c565f966549ba7ea8c306cfba87", "html_url": "https://github.com/rust-lang/rust/commit/673e1ddb9ae12c565f966549ba7ea8c306cfba87"}, {"sha": "3290bb4112e7988f98b108e3c590d39c881f00e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/3290bb4112e7988f98b108e3c590d39c881f00e0", "html_url": "https://github.com/rust-lang/rust/commit/3290bb4112e7988f98b108e3c590d39c881f00e0"}], "stats": {"total": 74, "additions": 34, "deletions": 40}, "files": [{"sha": "4307e019188509d24643dfe04ada94ca1227e97e", "filename": "crates/assists/src/ast_transform.rs", "status": "modified", "additions": 34, "deletions": 40, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/03dcf5111ad23700335d25ef02749666bbd08cca/crates%2Fassists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03dcf5111ad23700335d25ef02749666bbd08cca/crates%2Fassists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fassists%2Fsrc%2Fast_transform.rs?ref=03dcf5111ad23700335d25ef02749666bbd08cca", "patch": "@@ -5,12 +5,13 @@ use hir::{HirDisplay, PathResolution, SemanticsScope};\n use syntax::{\n     algo::SyntaxRewriter,\n     ast::{self, AstNode},\n+    SyntaxNode,\n };\n \n pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n     SyntaxRewriter::from_fn(|element| match element {\n         syntax::SyntaxElement::Node(n) => {\n-            let replacement = transformer.get_substitution(&n)?;\n+            let replacement = transformer.get_substitution(&n, transformer)?;\n             Some(replacement.into())\n         }\n         _ => None,\n@@ -47,32 +48,35 @@ pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n /// We'd want to somehow express this concept simpler, but so far nobody got to\n /// simplifying this!\n pub trait AstTransform<'a> {\n-    fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode>;\n+    fn get_substitution(\n+        &self,\n+        node: &SyntaxNode,\n+        recur: &dyn AstTransform<'a>,\n+    ) -> Option<SyntaxNode>;\n \n-    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a>;\n     fn or<T: AstTransform<'a> + 'a>(self, other: T) -> Box<dyn AstTransform<'a> + 'a>\n     where\n         Self: Sized + 'a,\n     {\n-        self.chain_before(Box::new(other))\n+        Box::new(Or(Box::new(self), Box::new(other)))\n     }\n }\n \n-struct NullTransformer;\n+struct Or<'a>(Box<dyn AstTransform<'a> + 'a>, Box<dyn AstTransform<'a> + 'a>);\n \n-impl<'a> AstTransform<'a> for NullTransformer {\n-    fn get_substitution(&self, _node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n-        None\n-    }\n-    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n-        other\n+impl<'a> AstTransform<'a> for Or<'a> {\n+    fn get_substitution(\n+        &self,\n+        node: &SyntaxNode,\n+        recur: &dyn AstTransform<'a>,\n+    ) -> Option<SyntaxNode> {\n+        self.0.get_substitution(node, recur).or_else(|| self.1.get_substitution(node, recur))\n     }\n }\n \n pub struct SubstituteTypeParams<'a> {\n     source_scope: &'a SemanticsScope<'a>,\n     substs: FxHashMap<hir::TypeParam, ast::Type>,\n-    previous: Box<dyn AstTransform<'a> + 'a>,\n }\n \n impl<'a> SubstituteTypeParams<'a> {\n@@ -111,11 +115,7 @@ impl<'a> SubstituteTypeParams<'a> {\n                 }\n             })\n             .collect();\n-        return SubstituteTypeParams {\n-            source_scope,\n-            substs: substs_by_param,\n-            previous: Box::new(NullTransformer),\n-        };\n+        return SubstituteTypeParams { source_scope, substs: substs_by_param };\n \n         // FIXME: It would probably be nicer if we could get this via HIR (i.e. get the\n         // trait ref, and then go from the types in the substs back to the syntax).\n@@ -140,7 +140,14 @@ impl<'a> SubstituteTypeParams<'a> {\n             Some(result)\n         }\n     }\n-    fn get_substitution_inner(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n+}\n+\n+impl<'a> AstTransform<'a> for SubstituteTypeParams<'a> {\n+    fn get_substitution(\n+        &self,\n+        node: &SyntaxNode,\n+        _recur: &dyn AstTransform<'a>,\n+    ) -> Option<SyntaxNode> {\n         let type_ref = ast::Type::cast(node.clone())?;\n         let path = match &type_ref {\n             ast::Type::PathType(path_type) => path_type.path()?,\n@@ -154,27 +161,23 @@ impl<'a> SubstituteTypeParams<'a> {\n     }\n }\n \n-impl<'a> AstTransform<'a> for SubstituteTypeParams<'a> {\n-    fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n-        self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))\n-    }\n-    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n-        Box::new(SubstituteTypeParams { previous: other, ..self })\n-    }\n-}\n-\n pub struct QualifyPaths<'a> {\n     target_scope: &'a SemanticsScope<'a>,\n     source_scope: &'a SemanticsScope<'a>,\n-    previous: Box<dyn AstTransform<'a> + 'a>,\n }\n \n impl<'a> QualifyPaths<'a> {\n     pub fn new(target_scope: &'a SemanticsScope<'a>, source_scope: &'a SemanticsScope<'a>) -> Self {\n-        Self { target_scope, source_scope, previous: Box::new(NullTransformer) }\n+        Self { target_scope, source_scope }\n     }\n+}\n \n-    fn get_substitution_inner(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n+impl<'a> AstTransform<'a> for QualifyPaths<'a> {\n+    fn get_substitution(\n+        &self,\n+        node: &SyntaxNode,\n+        recur: &dyn AstTransform<'a>,\n+    ) -> Option<SyntaxNode> {\n         // FIXME handle value ns?\n         let from = self.target_scope.module()?;\n         let p = ast::Path::cast(node.clone())?;\n@@ -191,7 +194,7 @@ impl<'a> QualifyPaths<'a> {\n                 let type_args = p\n                     .segment()\n                     .and_then(|s| s.generic_arg_list())\n-                    .map(|arg_list| apply(self, arg_list));\n+                    .map(|arg_list| apply(recur, arg_list));\n                 if let Some(type_args) = type_args {\n                     let last_segment = path.segment().unwrap();\n                     path = path.with_segment(last_segment.with_generic_args(type_args))\n@@ -208,15 +211,6 @@ impl<'a> QualifyPaths<'a> {\n     }\n }\n \n-impl<'a> AstTransform<'a> for QualifyPaths<'a> {\n-    fn get_substitution(&self, node: &syntax::SyntaxNode) -> Option<syntax::SyntaxNode> {\n-        self.get_substitution_inner(node).or_else(|| self.previous.get_substitution(node))\n-    }\n-    fn chain_before(self, other: Box<dyn AstTransform<'a> + 'a>) -> Box<dyn AstTransform<'a> + 'a> {\n-        Box::new(QualifyPaths { previous: other, ..self })\n-    }\n-}\n-\n pub(crate) fn path_to_ast(path: hir::ModPath) -> ast::Path {\n     let parse = ast::SourceFile::parse(&path.to_string());\n     parse"}]}