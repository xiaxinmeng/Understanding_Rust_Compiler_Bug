{"sha": "198dfceb80e62dfe62f5f3fdbedcd9ffbe25c93b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5OGRmY2ViODBlNjJkZmU2MmY1ZjNmZGJlZGNkOWZmYmUyNWM5M2I=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-18T13:17:26Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2019-03-18T13:19:52Z"}, "message": "Preprocess query modifiers", "tree": {"sha": "61ec095c49c97360f1a6bde4bfa3d543c3e564df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61ec095c49c97360f1a6bde4bfa3d543c3e564df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/198dfceb80e62dfe62f5f3fdbedcd9ffbe25c93b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/198dfceb80e62dfe62f5f3fdbedcd9ffbe25c93b", "html_url": "https://github.com/rust-lang/rust/commit/198dfceb80e62dfe62f5f3fdbedcd9ffbe25c93b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/198dfceb80e62dfe62f5f3fdbedcd9ffbe25c93b/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f49fff019c50d70240116090a2720a8a2dd5c34", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f49fff019c50d70240116090a2720a8a2dd5c34", "html_url": "https://github.com/rust-lang/rust/commit/4f49fff019c50d70240116090a2720a8a2dd5c34"}], "stats": {"total": 113, "additions": 82, "deletions": 31}, "files": [{"sha": "3849e47d40365befd090493944a98d328cc2f899", "filename": "src/librustc_macros/src/query.rs", "status": "modified", "additions": 82, "deletions": 31, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/198dfceb80e62dfe62f5f3fdbedcd9ffbe25c93b/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/198dfceb80e62dfe62f5f3fdbedcd9ffbe25c93b/src%2Flibrustc_macros%2Fsrc%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_macros%2Fsrc%2Fquery.rs?ref=198dfceb80e62dfe62f5f3fdbedcd9ffbe25c93b", "patch": "@@ -1,5 +1,4 @@\n use proc_macro::TokenStream;\n-use proc_macro2::Span;\n use syn::{\n     Token, Ident, Type, Attribute, ReturnType, Expr, Block, Error,\n     braced, parenthesized, parse_macro_input,\n@@ -21,8 +20,8 @@ struct IdentOrWild(Ident);\n impl Parse for IdentOrWild {\n     fn parse(input: ParseStream<'_>) -> Result<Self> {\n         Ok(if input.peek(Token![_]) {\n-            input.parse::<Token![_]>()?;\n-            IdentOrWild(Ident::new(\"_\", Span::call_site()))\n+            let underscore = input.parse::<Token![_]>()?;\n+            IdentOrWild(Ident::new(\"_\", underscore.span()))\n         } else {\n             IdentOrWild(input.parse()?)\n         })\n@@ -31,7 +30,7 @@ impl Parse for IdentOrWild {\n \n /// A modifier for a query\n enum QueryModifier {\n-    /// The description of the query\n+    /// The description of the query.\n     Desc(Option<Ident>, Punctuated<Expr, Token![,]>),\n \n     /// Cache the query to disk if the `Expr` returns true.\n@@ -107,7 +106,7 @@ fn check_attributes(attrs: Vec<Attribute>) -> Result<()> {\n \n /// A compiler query. `query ... { ... }`\n struct Query {\n-    attrs: List<QueryModifier>,\n+    modifiers: List<QueryModifier>,\n     name: Ident,\n     key: IdentOrWild,\n     arg: Type,\n@@ -131,10 +130,10 @@ impl Parse for Query {\n         // Parse the query modifiers\n         let content;\n         braced!(content in input);\n-        let attrs = content.parse()?;\n+        let modifiers = content.parse()?;\n \n         Ok(Query {\n-            attrs,\n+            modifiers,\n             name,\n             key,\n             arg,\n@@ -174,24 +173,76 @@ impl Parse for Group {\n     }\n }\n \n+struct QueryModifiers {\n+    /// The description of the query.\n+    desc: Option<(Option<Ident>, Punctuated<Expr, Token![,]>)>,\n+\n+    /// Cache the query to disk if the `Expr` returns true.\n+    cache: Option<(Option<Ident>, Expr)>,\n+\n+    /// Custom code to load the query from disk.\n+    load_cached: Option<(Ident, Ident, Block)>,\n+\n+    /// A cycle error for this query aborting the compilation with a fatal error.\n+    fatal_cycle: bool,\n+}\n+\n+/// Process query modifiers into a struct, erroring on duplicates\n+fn process_modifiers(query: &mut Query) -> QueryModifiers {\n+    let mut load_cached = None;\n+    let mut cache = None;\n+    let mut desc = None;\n+    let mut fatal_cycle = false;\n+    for modifier in query.modifiers.0.drain(..) {\n+        match modifier {\n+            QueryModifier::LoadCached(tcx, id, block) => {\n+                if load_cached.is_some() {\n+                    panic!(\"duplicate modifier `load_cached` for query `{}`\", query.name);\n+                }\n+                load_cached = Some((tcx, id, block));\n+            }\n+            QueryModifier::Cache(tcx, expr) => {\n+                if cache.is_some() {\n+                    panic!(\"duplicate modifier `cache` for query `{}`\", query.name);\n+                }\n+                cache = Some((tcx, expr));\n+            }\n+            QueryModifier::Desc(tcx, list) => {\n+                if desc.is_some() {\n+                    panic!(\"duplicate modifier `desc` for query `{}`\", query.name);\n+                }\n+                desc = Some((tcx, list));\n+            }\n+            QueryModifier::FatalCycle => {\n+                if fatal_cycle {\n+                    panic!(\"duplicate modifier `fatal_cycle` for query `{}`\", query.name);\n+                }\n+                fatal_cycle = true;\n+            }\n+        }\n+    }\n+    QueryModifiers {\n+        load_cached,\n+        cache,\n+        desc,\n+        fatal_cycle,\n+    }\n+}\n+\n /// Add the impl of QueryDescription for the query to `impls` if one is requested\n-fn add_query_description_impl(query: &Query, impls: &mut proc_macro2::TokenStream) {\n+fn add_query_description_impl(\n+    query: &Query,\n+    modifiers: QueryModifiers,\n+    impls: &mut proc_macro2::TokenStream\n+) {\n     let name = &query.name;\n     let arg = &query.arg;\n     let key = &query.key.0;\n \n-    // Find custom code to load the query from disk\n-    let load_cached = query.attrs.0.iter().find_map(|attr| match attr {\n-        QueryModifier::LoadCached(tcx, id, block) => Some((tcx, id, block)),\n-        _ => None,\n-    });\n-\n     // Find out if we should cache the query on disk\n-    let cache = query.attrs.0.iter().find_map(|attr| match attr {\n-        QueryModifier::Cache(tcx, expr) => Some((tcx, expr)),\n-        _ => None,\n-    }).map(|(tcx, expr)| {\n-        let try_load_from_disk = if let Some((tcx, id, block)) = load_cached {\n+    let cache = modifiers.cache.as_ref().map(|(tcx, expr)| {\n+        let try_load_from_disk = if let Some((tcx, id, block)) = modifiers.load_cached.as_ref() {\n+            // Use custom code to load the query from disk\n             quote! {\n                 #[inline]\n                 fn try_load_from_disk(\n@@ -202,6 +253,7 @@ fn add_query_description_impl(query: &Query, impls: &mut proc_macro2::TokenStrea\n                 }\n             }\n         } else {\n+            // Use the default code to load the query from disk\n             quote! {\n                 #[inline]\n                 fn try_load_from_disk(\n@@ -224,14 +276,11 @@ fn add_query_description_impl(query: &Query, impls: &mut proc_macro2::TokenStrea\n         }\n     });\n \n-    if cache.is_none() && load_cached.is_some() {\n+    if cache.is_none() && modifiers.load_cached.is_some() {\n         panic!(\"load_cached modifier on query `{}` without a cache modifier\", name);\n     }\n \n-    let desc = query.attrs.0.iter().find_map(|attr| match attr {\n-        QueryModifier::Desc(tcx, desc) => Some((tcx, desc)),\n-        _ => None,\n-    }).map(|(tcx, desc)| {\n+    let desc = modifiers.desc.as_ref().map(|(tcx, desc)| {\n         let tcx = tcx.as_ref().map(|t| quote! { #t }).unwrap_or(quote! { _ });\n         quote! {\n             fn describe(\n@@ -266,7 +315,8 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n \n     for group in groups.0 {\n         let mut group_stream = quote! {};\n-        for query in &group.queries.0 {\n+        for mut query in group.queries.0 {\n+            let modifiers = process_modifiers(&mut query);\n             let name = &query.name;\n             let arg = &query.arg;\n             let result_full = &query.result;\n@@ -275,18 +325,19 @@ pub fn rustc_queries(input: TokenStream) -> TokenStream {\n                 _ => quote! { #result_full },\n             };\n \n-            // Look for a fatal_cycle modifier to pass on\n-            let fatal_cycle = query.attrs.0.iter().find_map(|attr| match attr {\n-                QueryModifier::FatalCycle => Some(()),\n-                _ => None,\n-            }).map(|_| quote! { fatal_cycle }).unwrap_or(quote! {});\n+            // Pass on the fatal_cycle modifier\n+            let fatal_cycle = if modifiers.fatal_cycle {\n+                quote! { fatal_cycle }\n+            } else {\n+                quote! {}\n+            };\n \n             // Add the query to the group\n             group_stream.extend(quote! {\n                 [#fatal_cycle] fn #name: #name(#arg) #result,\n             });\n \n-            add_query_description_impl(query, &mut query_description_stream);\n+            add_query_description_impl(&query, modifiers, &mut query_description_stream);\n \n             // Create a dep node for the query\n             dep_node_def_stream.extend(quote! {"}]}