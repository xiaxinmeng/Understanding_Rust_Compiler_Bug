{"sha": "0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiMmYyYjk0MTMzMjk1NGM1YmQ4MGU2MWVhYmNlM2VlMjE2MWE3ZjU=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-02-17T22:51:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-17T22:51:19Z"}, "message": "Rollup merge of #82007 - sexxi-goose:reborrow, r=nikomatsakis\n\nImplement reborrow for closure captures\n\nThe strategy for captures is detailed here with examples: https://hackmd.io/PzxYMPY4RF-B9iH9uj9GTA\n\nKey points:\n- We only need to reborrow a capture in case of move closures.\n  - If we mutate something via a `&mut` we store it as a `MutBorrow`/`UniqueMuBorrow` of the path containing the `&mut`,\n  - Similarly, if it's read via `&` ref we just store it as a `ImmBorrow` of the path containing the `&` ref.\n  - If a path doesn't deref a `&mut`, `&`, then that path is captured by Move.\n  - If the use of a path results in a move when the closure is called, then that path is truncated before any deref and the truncated path is moved into the closure.\n\n- In the case of non-move closure if a use of a path results in a move, then the path is truncated before any deref and the truncated path is moved into the closure.\n\nNote that the implementation differs a bit from the document to allow for truncated path to be used in the ClosureKind analysis that happens as part of the first capture analysis pass.\n\nCloses: https://github.com/rust-lang/project-rfc-2229/issues/31\n\nr? ````@nikomatsakis````", "tree": {"sha": "589fbb4f268b617baf3e4ca1099ad7d5fda1c98a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/589fbb4f268b617baf3e4ca1099ad7d5fda1c98a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgLZ3oCRBK7hj4Ov3rIwAAdHIIAGFbr/3k2imSntszG7Nc0aYB\npKEn3Pm9PkXyWbJWV2uuIa4R0F/2uNuKfE14Ng9oFPVL6S6vf99WyiDBDA4ajGEe\nJT8zqlvRFiCyXvQdOEGYdTWfM3xZc4ORgUhS81WszDD5FGLKzfjw+WSk0C9rExTx\nm8eY4mURfKcEXkeZB3kUTQ1hi/rJnn2mkd6ms2crVEOg36C5UMijZIPGyKPB/SVN\n2pLD5FzUiRNot+qFvBcSi4/cwVlucS/ZpFUfaUL1w6gc6ZsN3rMboJ99rvzLioCx\nJqmY+0Gds41rZ/Va3XXQEARMyBQATw4tcYKc4QWcEu0N9ZYaGwQvIMwEntiANvM=\n=xfqC\n-----END PGP SIGNATURE-----\n", "payload": "tree 589fbb4f268b617baf3e4ca1099ad7d5fda1c98a\nparent cdd93fd3e2f6fb03717db137196a371f6b5c55f7\nparent f99e152e5a02d75e5df1a10b33d4e8592cd25fee\nauthor Dylan DPC <dylan.dpc@gmail.com> 1613602279 +0100\ncommitter GitHub <noreply@github.com> 1613602279 +0100\n\nRollup merge of #82007 - sexxi-goose:reborrow, r=nikomatsakis\n\nImplement reborrow for closure captures\n\nThe strategy for captures is detailed here with examples: https://hackmd.io/PzxYMPY4RF-B9iH9uj9GTA\n\nKey points:\n- We only need to reborrow a capture in case of move closures.\n  - If we mutate something via a `&mut` we store it as a `MutBorrow`/`UniqueMuBorrow` of the path containing the `&mut`,\n  - Similarly, if it's read via `&` ref we just store it as a `ImmBorrow` of the path containing the `&` ref.\n  - If a path doesn't deref a `&mut`, `&`, then that path is captured by Move.\n  - If the use of a path results in a move when the closure is called, then that path is truncated before any deref and the truncated path is moved into the closure.\n\n- In the case of non-move closure if a use of a path results in a move, then the path is truncated before any deref and the truncated path is moved into the closure.\n\nNote that the implementation differs a bit from the document to allow for truncated path to be used in the ClosureKind analysis that happens as part of the first capture analysis pass.\n\nCloses: https://github.com/rust-lang/project-rfc-2229/issues/31\n\nr? ````@nikomatsakis````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "html_url": "https://github.com/rust-lang/rust/commit/0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cdd93fd3e2f6fb03717db137196a371f6b5c55f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cdd93fd3e2f6fb03717db137196a371f6b5c55f7", "html_url": "https://github.com/rust-lang/rust/commit/cdd93fd3e2f6fb03717db137196a371f6b5c55f7"}, {"sha": "f99e152e5a02d75e5df1a10b33d4e8592cd25fee", "url": "https://api.github.com/repos/rust-lang/rust/commits/f99e152e5a02d75e5df1a10b33d4e8592cd25fee", "html_url": "https://github.com/rust-lang/rust/commit/f99e152e5a02d75e5df1a10b33d4e8592cd25fee"}], "stats": {"total": 497, "additions": 408, "deletions": 89}, "files": [{"sha": "69c09528662d37d5c2f7535679e6be9935670461", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 62, "deletions": 43, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "patch": "@@ -180,7 +180,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     debug!(\"seed place {:?}\", place);\n \n                     let upvar_id = ty::UpvarId::new(*var_hir_id, local_def_id);\n-                    let capture_kind = self.init_capture_kind(capture_clause, upvar_id, span);\n+                    let capture_kind =\n+                        self.init_capture_kind_for_place(&place, capture_clause, upvar_id, span);\n                     let fake_info = ty::CaptureInfo {\n                         capture_kind_expr_id: None,\n                         path_expr_id: None,\n@@ -205,11 +206,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // If we have an origin, store it.\n             if let Some(origin) = delegate.current_origin.clone() {\n                 let origin = if self.tcx.features().capture_disjoint_fields {\n-                    origin\n+                    (origin.0, restrict_capture_precision(origin.1))\n                 } else {\n-                    // FIXME(project-rfc-2229#31): Once the changes to support reborrowing are\n-                    //                             made, make sure we are selecting and restricting\n-                    //                             the origin correctly.\n                     (origin.0, Place { projections: vec![], ..origin.1 })\n                 };\n \n@@ -449,7 +447,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 base => bug!(\"Expected upvar, found={:?}\", base),\n             };\n \n-            let place = restrict_capture_precision(place, capture_info.capture_kind);\n+            let place = restrict_capture_precision(place);\n \n             let min_cap_list = match root_var_min_capture_list.get_mut(&var_hir_id) {\n                 None => {\n@@ -897,15 +895,24 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn init_capture_kind(\n+    fn init_capture_kind_for_place(\n         &self,\n+        place: &Place<'tcx>,\n         capture_clause: hir::CaptureBy,\n         upvar_id: ty::UpvarId,\n         closure_span: Span,\n     ) -> ty::UpvarCapture<'tcx> {\n         match capture_clause {\n-            hir::CaptureBy::Value => ty::UpvarCapture::ByValue(None),\n-            hir::CaptureBy::Ref => {\n+            // In case of a move closure if the data is accessed through a reference we\n+            // want to capture by ref to allow precise capture using reborrows.\n+            //\n+            // If the data will be moved out of this place, then the place will be truncated\n+            // at the first Deref in `adjust_upvar_borrow_kind_for_consume` and then moved into\n+            // the closure.\n+            hir::CaptureBy::Value if !place.deref_tys().any(ty::TyS::is_ref) => {\n+                ty::UpvarCapture::ByValue(None)\n+            }\n+            hir::CaptureBy::Value | hir::CaptureBy::Ref => {\n                 let origin = UpvarRegion(upvar_id, closure_span);\n                 let upvar_region = self.next_region_var(origin);\n                 let upvar_borrow = ty::UpvarBorrow { kind: ty::ImmBorrow, region: upvar_region };\n@@ -1109,12 +1116,25 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n             place_with_id, diag_expr_id, mode\n         );\n \n-        // we only care about moves\n-        match mode {\n-            euv::Copy => {\n+        match (self.capture_clause, mode) {\n+            // In non-move closures, we only care about moves\n+            (hir::CaptureBy::Ref, euv::Copy) => return,\n+\n+            // We want to capture Copy types that read through a ref via a reborrow\n+            (hir::CaptureBy::Value, euv::Copy)\n+                if place_with_id.place.deref_tys().any(ty::TyS::is_ref) =>\n+            {\n                 return;\n             }\n-            euv::Move => {}\n+\n+            (hir::CaptureBy::Ref, euv::Move) | (hir::CaptureBy::Value, euv::Move | euv::Copy) => {}\n+        };\n+\n+        let place = truncate_capture_for_move(place_with_id.place.clone());\n+        let place_with_id = PlaceWithHirId { place: place.clone(), hir_id: place_with_id.hir_id };\n+\n+        if !self.capture_information.contains_key(&place) {\n+            self.init_capture_info_for_place(&place_with_id, diag_expr_id);\n         }\n \n         let tcx = self.fcx.tcx;\n@@ -1128,13 +1148,15 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n \n         let usage_span = tcx.hir().span(diag_expr_id);\n \n-        // To move out of an upvar, this must be a FnOnce closure\n-        self.adjust_closure_kind(\n-            upvar_id.closure_expr_id,\n-            ty::ClosureKind::FnOnce,\n-            usage_span,\n-            place_with_id.place.clone(),\n-        );\n+        if matches!(mode, euv::Move) {\n+            // To move out of an upvar, this must be a FnOnce closure\n+            self.adjust_closure_kind(\n+                upvar_id.closure_expr_id,\n+                ty::ClosureKind::FnOnce,\n+                usage_span,\n+                place.clone(),\n+            );\n+        }\n \n         let capture_info = ty::CaptureInfo {\n             capture_kind_expr_id: Some(diag_expr_id),\n@@ -1317,8 +1339,12 @@ impl<'a, 'tcx> InferBorrowKind<'a, 'tcx> {\n         if let PlaceBase::Upvar(upvar_id) = place_with_id.place.base {\n             assert_eq!(self.closure_def_id.expect_local(), upvar_id.closure_expr_id);\n \n-            let capture_kind =\n-                self.fcx.init_capture_kind(self.capture_clause, upvar_id, self.closure_span);\n+            let capture_kind = self.fcx.init_capture_kind_for_place(\n+                &place_with_id.place,\n+                self.capture_clause,\n+                upvar_id,\n+                self.closure_span,\n+            );\n \n             let expr_id = Some(diag_expr_id);\n             let capture_info = ty::CaptureInfo {\n@@ -1392,15 +1418,10 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for InferBorrowKind<'a, 'tcx> {\n }\n \n /// Truncate projections so that following rules are obeyed by the captured `place`:\n-///\n-/// - No Derefs in move closure, this will result in value behind a reference getting moved.\n /// - No projections are applied to raw pointers, since these require unsafe blocks. We capture\n ///   them completely.\n /// - No Index projections are captured, since arrays are captured completely.\n-fn restrict_capture_precision<'tcx>(\n-    mut place: Place<'tcx>,\n-    capture_kind: ty::UpvarCapture<'tcx>,\n-) -> Place<'tcx> {\n+fn restrict_capture_precision<'tcx>(mut place: Place<'tcx>) -> Place<'tcx> {\n     if place.projections.is_empty() {\n         // Nothing to do here\n         return place;\n@@ -1412,7 +1433,6 @@ fn restrict_capture_precision<'tcx>(\n     }\n \n     let mut truncated_length = usize::MAX;\n-    let mut first_deref_projection = usize::MAX;\n \n     for (i, proj) in place.projections.iter().enumerate() {\n         if proj.ty.is_unsafe_ptr() {\n@@ -1426,31 +1446,30 @@ fn restrict_capture_precision<'tcx>(\n                 truncated_length = truncated_length.min(i);\n                 break;\n             }\n-            ProjectionKind::Deref => {\n-                // We only drop Derefs in case of move closures\n-                // There might be an index projection or raw ptr ahead, so we don't stop here.\n-                first_deref_projection = first_deref_projection.min(i);\n-            }\n+            ProjectionKind::Deref => {}\n             ProjectionKind::Field(..) => {} // ignore\n             ProjectionKind::Subslice => {}  // We never capture this\n         }\n     }\n \n-    let length = place\n-        .projections\n-        .len()\n-        .min(truncated_length)\n-        // In case of capture `ByValue` we want to not capture derefs\n-        .min(match capture_kind {\n-            ty::UpvarCapture::ByValue(..) => first_deref_projection,\n-            ty::UpvarCapture::ByRef(..) => usize::MAX,\n-        });\n+    let length = place.projections.len().min(truncated_length);\n \n     place.projections.truncate(length);\n \n     place\n }\n \n+/// Truncates a place so that the resultant capture doesn't move data out of a reference\n+fn truncate_capture_for_move(mut place: Place<'tcx>) -> Place<'tcx> {\n+    if let Some(i) = place.projections.iter().position(|proj| proj.kind == ProjectionKind::Deref) {\n+        // We only drop Derefs in case of move closures\n+        // There might be an index projection or raw ptr ahead, so we don't stop here.\n+        place.projections.truncate(i);\n+    }\n+\n+    place\n+}\n+\n fn construct_place_string(tcx: TyCtxt<'_>, place: &Place<'tcx>) -> String {\n     let variable_name = match place.base {\n         PlaceBase::Upvar(upvar_id) => var_name(tcx, upvar_id.var_path.hir_id).to_string(),"}, {"sha": "27c8fb1363f17a03144b1707cece124c012c1769", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.rs?ref=0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "patch": "@@ -26,7 +26,8 @@ fn big_box() {\n     //~^ First Pass analysis includes:\n     //~| Min Capture analysis includes:\n         let p = t.0.0;\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Capturing t[(0, 0)] -> ByValue\n         //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n         println!(\"{} {:?}\", t.1, p);\n         //~^ NOTE: Capturing t[(1, 0)] -> ImmBorrow"}, {"sha": "944e4c40a78ef6707a21e7b35bf1f11544235829", "filename": "src/test/ui/closures/2229_closure_analysis/by_value.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fby_value.stderr?ref=0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "patch": "@@ -28,13 +28,18 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/by_value.rs:28:17\n+   |\n+LL |         let p = t.0.0;\n+   |                 ^^^^^\n+note: Capturing t[(0, 0)] -> ByValue\n   --> $DIR/by_value.rs:28:17\n    |\n LL |         let p = t.0.0;\n    |                 ^^^^^\n note: Capturing t[(1, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:31:29\n+  --> $DIR/by_value.rs:32:29\n    |\n LL |         println!(\"{} {:?}\", t.1, p);\n    |                             ^^^\n@@ -57,7 +62,7 @@ note: Min Capture t[(0, 0)] -> ByValue\n LL |         let p = t.0.0;\n    |                 ^^^^^\n note: Min Capture t[(1, 0)] -> ImmBorrow\n-  --> $DIR/by_value.rs:31:29\n+  --> $DIR/by_value.rs:32:29\n    |\n LL |         println!(\"{} {:?}\", t.1, p);\n    |                             ^^^"}, {"sha": "cd7c25620a7c43bccf5020fa0e36270e6d2352b6", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-array-diagnostics.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.rs?ref=0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "patch": "@@ -0,0 +1,16 @@\n+#![feature(capture_disjoint_fields)]\n+//~^ WARNING: the feature `capture_disjoint_fields` is incomplete\n+//~| `#[warn(incomplete_features)]` on by default\n+//~| see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n+\n+// Test that array access is not stored as part of closure kind origin\n+\n+fn expect_fn<F: Fn()>(_f: F) {}\n+\n+fn main() {\n+    let s = [format!(\"s\"), format!(\"s\")];\n+    let c = || { //~ ERROR expected a closure that implements the `Fn`\n+        let [_, _s] = s;\n+    };\n+    expect_fn(c);\n+}"}, {"sha": "bd9428771f4c5b5816d91791e97ced2499b8c346", "filename": "src/test/ui/closures/2229_closure_analysis/diagnostics/closure-origin-array-diagnostics.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fdiagnostics%2Fclosure-origin-array-diagnostics.stderr?ref=0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "patch": "@@ -0,0 +1,23 @@\n+warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/closure-origin-array-diagnostics.rs:1:12\n+   |\n+LL | #![feature(capture_disjoint_fields)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+   = note: see issue #53488 <https://github.com/rust-lang/rust/issues/53488> for more information\n+\n+error[E0525]: expected a closure that implements the `Fn` trait, but this closure only implements `FnOnce`\n+  --> $DIR/closure-origin-array-diagnostics.rs:12:13\n+   |\n+LL |     let c = || {\n+   |             ^^ this closure implements `FnOnce`, not `Fn`\n+LL |         let [_, _s] = s;\n+   |                       - closure is `FnOnce` because it moves the variable `s` out of its environment\n+LL |     };\n+LL |     expect_fn(c);\n+   |     --------- the requirement to implement `Fn` derives from here\n+\n+error: aborting due to previous error; 1 warning emitted\n+\n+For more information about this error, try `rustc --explain E0525`."}, {"sha": "1c574da5f48bc24bc182d975425e72eaf1226466", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.rs", "status": "modified", "additions": 85, "deletions": 16, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.rs?ref=0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "patch": "@@ -6,7 +6,25 @@\n //~| NOTE: see issue #53488 <https://github.com/rust-lang/rust/issues/53488>\n #![feature(rustc_attrs)]\n \n-// Test we truncate derefs properly\n+fn simple_move_closure() {\n+    struct S(String);\n+    struct T(S);\n+\n+    let t = T(S(\"s\".into()));\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        t.0.0 = \"new S\".into();\n+        //~^ NOTE: Capturing t[(0, 0),(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0),(0, 0)] -> ByValue\n+    };\n+    c();\n+}\n+\n+// Test move closure use reborrows when using references\n fn simple_ref() {\n     let mut s = 10;\n     let ref_s = &mut s;\n@@ -18,14 +36,14 @@ fn simple_ref() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         *ref_s += 10;\n-        //~^ NOTE: Capturing ref_s[Deref] -> ByValue\n-        //~| NOTE: Min Capture ref_s[] -> ByValue\n+        //~^ NOTE: Capturing ref_s[Deref] -> UniqueImmBorrow\n+        //~| NOTE: Min Capture ref_s[Deref] -> UniqueImmBorrow\n     };\n     c();\n }\n \n-// Test we truncate derefs properly\n-fn struct_contains_ref_to_another_struct() {\n+// Test move closure use reborrows when using references\n+fn struct_contains_ref_to_another_struct_1() {\n     struct S(String);\n     struct T<'a>(&'a mut S);\n \n@@ -39,34 +57,85 @@ fn struct_contains_ref_to_another_struct() {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n         t.0.0 = \"new s\".into();\n-        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n-        //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n+        //~| NOTE: Min Capture t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n     };\n \n     c();\n }\n \n-// Test that we don't reduce precision when there is nothing deref.\n-fn no_ref() {\n+// Test that we can use reborrows to read data of Copy types\n+// i.e. without truncating derefs\n+fn struct_contains_ref_to_another_struct_2() {\n+    struct S(i32);\n+    struct T<'a>(&'a S);\n+\n+    let s = S(0);\n+    let t = T(&s);\n+\n+    let mut c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let _t = t.0.0;\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Min Capture t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+    };\n+\n+    c();\n+}\n+\n+// Test that we can use truncate to move out of !Copy types\n+fn struct_contains_ref_to_another_struct_3() {\n     struct S(String);\n-    struct T(S);\n+    struct T<'a>(&'a S);\n+\n+    let s = S(\"s\".into());\n+    let t = T(&s);\n \n-    let t = T(S(\"s\".into()));\n     let mut c = #[rustc_capture_analysis]\n     //~^ ERROR: attributes on expressions are experimental\n     //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n     move || {\n     //~^ ERROR: First Pass analysis includes:\n     //~| ERROR: Min Capture analysis includes:\n-        t.0.0 = \"new S\".into();\n-        //~^ NOTE: Capturing t[(0, 0),(0, 0)] -> ByValue\n-        //~| NOTE: Min Capture t[(0, 0),(0, 0)] -> ByValue\n+        let _t = t.0.0;\n+        //~^ NOTE: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+        //~| NOTE: Capturing t[(0, 0)] -> ByValue\n+        //~| NOTE: Min Capture t[(0, 0)] -> ByValue\n     };\n+\n+    c();\n+}\n+\n+// Test that derefs of box are truncated in move closures\n+fn truncate_box_derefs() {\n+    struct S(i32);\n+\n+    let b = Box::new(S(10));\n+\n+    let c = #[rustc_capture_analysis]\n+    //~^ ERROR: attributes on expressions are experimental\n+    //~| NOTE: see issue #15701 <https://github.com/rust-lang/rust/issues/15701>\n+    move || {\n+    //~^ ERROR: First Pass analysis includes:\n+    //~| ERROR: Min Capture analysis includes:\n+        let _t = b.0;\n+        //~^ NOTE: Capturing b[Deref,(0, 0)] -> ByValue\n+        //~| NOTE: Capturing b[] -> ByValue\n+        //~| NOTE: Min Capture b[] -> ByValue\n+    };\n+\n     c();\n }\n \n fn main() {\n+    simple_move_closure();\n     simple_ref();\n-    struct_contains_ref_to_another_struct();\n-    no_ref();\n+    struct_contains_ref_to_another_struct_1();\n+    struct_contains_ref_to_another_struct_2();\n+    struct_contains_ref_to_another_struct_3();\n+    truncate_box_derefs();\n }"}, {"sha": "b91ef4dd85c487118d3ac1509fb9c2fc0c11054d", "filename": "src/test/ui/closures/2229_closure_analysis/move_closure.stderr", "status": "modified", "additions": 171, "deletions": 26, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmove_closure.stderr?ref=0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "patch": "@@ -8,7 +8,7 @@ LL |     let mut c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:35:17\n+  --> $DIR/move_closure.rs:32:17\n    |\n LL |     let mut c = #[rustc_capture_analysis]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -17,14 +17,41 @@ LL |     let mut c = #[rustc_capture_analysis]\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n error[E0658]: attributes on expressions are experimental\n-  --> $DIR/move_closure.rs:55:17\n+  --> $DIR/move_closure.rs:53:17\n    |\n LL |     let mut c = #[rustc_capture_analysis]\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n    = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n \n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:76:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:98:17\n+   |\n+LL |     let mut c = #[rustc_capture_analysis]\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n+error[E0658]: attributes on expressions are experimental\n+  --> $DIR/move_closure.rs:119:13\n+   |\n+LL |     let c = #[rustc_capture_analysis]\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #15701 <https://github.com/rust-lang/rust/issues/15701> for more information\n+   = help: add `#![feature(stmt_expr_attributes)]` to the crate attributes to enable\n+\n warning: the feature `capture_disjoint_fields` is incomplete and may not be safe to use and/or cause compiler crashes\n   --> $DIR/move_closure.rs:3:12\n    |\n@@ -40,20 +67,56 @@ error: First Pass analysis includes:\n LL | /     move || {\n LL | |\n LL | |\n-LL | |         *ref_s += 10;\n+LL | |         t.0.0 = \"new S\".into();\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:20:9\n+   |\n+LL |         t.0.0 = \"new S\".into();\n+   |         ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:17:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         t.0.0 = \"new S\".into();\n LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing ref_s[Deref] -> ByValue\n+note: Min Capture t[(0, 0),(0, 0)] -> ByValue\n   --> $DIR/move_closure.rs:20:9\n    |\n+LL |         t.0.0 = \"new S\".into();\n+   |         ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:35:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         *ref_s += 10;\n+LL | |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing ref_s[Deref] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:38:9\n+   |\n LL |         *ref_s += 10;\n    |         ^^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:17:5\n+  --> $DIR/move_closure.rs:35:5\n    |\n LL | /     move || {\n LL | |\n@@ -64,14 +127,14 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture ref_s[] -> ByValue\n-  --> $DIR/move_closure.rs:20:9\n+note: Min Capture ref_s[Deref] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:38:9\n    |\n LL |         *ref_s += 10;\n    |         ^^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:38:5\n+  --> $DIR/move_closure.rs:56:5\n    |\n LL | /     move || {\n LL | |\n@@ -82,14 +145,14 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),Deref,(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:41:9\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:59:9\n    |\n LL |         t.0.0 = \"new s\".into();\n    |         ^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:38:5\n+  --> $DIR/move_closure.rs:56:5\n    |\n LL | /     move || {\n LL | |\n@@ -100,48 +163,130 @@ LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture t[(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:41:9\n+note: Min Capture t[(0, 0),Deref,(0, 0)] -> UniqueImmBorrow\n+  --> $DIR/move_closure.rs:59:9\n    |\n LL |         t.0.0 = \"new s\".into();\n    |         ^^^^^\n \n error: First Pass analysis includes:\n-  --> $DIR/move_closure.rs:58:5\n+  --> $DIR/move_closure.rs:79:5\n    |\n LL | /     move || {\n LL | |\n LL | |\n-LL | |         t.0.0 = \"new S\".into();\n+LL | |         let _t = t.0.0;\n LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Capturing t[(0, 0),(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:61:9\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:82:18\n    |\n-LL |         t.0.0 = \"new S\".into();\n-   |         ^^^^^\n+LL |         let _t = t.0.0;\n+   |                  ^^^^^\n \n error: Min Capture analysis includes:\n-  --> $DIR/move_closure.rs:58:5\n+  --> $DIR/move_closure.rs:79:5\n    |\n LL | /     move || {\n LL | |\n LL | |\n-LL | |         t.0.0 = \"new S\".into();\n+LL | |         let _t = t.0.0;\n LL | |\n LL | |\n LL | |     };\n    | |_____^\n    |\n-note: Min Capture t[(0, 0),(0, 0)] -> ByValue\n-  --> $DIR/move_closure.rs:61:9\n+note: Min Capture t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:82:18\n    |\n-LL |         t.0.0 = \"new S\".into();\n-   |         ^^^^^\n+LL |         let _t = t.0.0;\n+   |                  ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:101:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         let _t = t.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing t[(0, 0),Deref,(0, 0)] -> ImmBorrow\n+  --> $DIR/move_closure.rs:104:18\n+   |\n+LL |         let _t = t.0.0;\n+   |                  ^^^^^\n+note: Capturing t[(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:104:18\n+   |\n+LL |         let _t = t.0.0;\n+   |                  ^^^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:101:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         let _t = t.0.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture t[(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:104:18\n+   |\n+LL |         let _t = t.0.0;\n+   |                  ^^^^^\n+\n+error: First Pass analysis includes:\n+  --> $DIR/move_closure.rs:122:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         let _t = b.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Capturing b[Deref,(0, 0)] -> ByValue\n+  --> $DIR/move_closure.rs:125:18\n+   |\n+LL |         let _t = b.0;\n+   |                  ^^^\n+note: Capturing b[] -> ByValue\n+  --> $DIR/move_closure.rs:125:18\n+   |\n+LL |         let _t = b.0;\n+   |                  ^^^\n+\n+error: Min Capture analysis includes:\n+  --> $DIR/move_closure.rs:122:5\n+   |\n+LL | /     move || {\n+LL | |\n+LL | |\n+LL | |         let _t = b.0;\n+...  |\n+LL | |\n+LL | |     };\n+   | |_____^\n+   |\n+note: Min Capture b[] -> ByValue\n+  --> $DIR/move_closure.rs:125:18\n+   |\n+LL |         let _t = b.0;\n+   |                  ^^^\n \n-error: aborting due to 9 previous errors; 1 warning emitted\n+error: aborting due to 18 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "afaafbda018774feb36039447a98ec1feae56170", "filename": "src/test/ui/closures/2229_closure_analysis/run_pass/move_closure.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b2f2b941332954c5bd80e61eabce3ee2161a7f5/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Frun_pass%2Fmove_closure.rs?ref=0b2f2b941332954c5bd80e61eabce3ee2161a7f5", "patch": "@@ -56,9 +56,50 @@ fn no_ref_nested() {\n     c();\n }\n \n+struct A<'a>(&'a mut String,  &'a mut String);\n+// Test that reborrowing works as expected for move closures\n+// by attempting a disjoint capture through a reference.\n+fn disjoint_via_ref() {\n+    let mut x = String::new();\n+    let mut y = String::new();\n+\n+    let mut a = A(&mut x, &mut y);\n+    let a = &mut a;\n+\n+    let mut c1 = move || {\n+        a.0.truncate(0);\n+    };\n+\n+    let mut c2 = move || {\n+        a.1.truncate(0);\n+    };\n+\n+    c1();\n+    c2();\n+}\n+\n+// Test that even if a path is moved into the closure, the closure is not FnOnce\n+// if the path is not moved by the closure call.\n+fn data_moved_but_not_fn_once() {\n+    let x = Box::new(10i32);\n+\n+    let c = move || {\n+        // *x has type i32 which is Copy. So even though the box `x` will be moved\n+        // into the closure, `x` is never moved when the closure is called, i.e. the\n+        // ownership stays with the closure and therefore we can call the function multiple times.\n+        let _x = *x;\n+    };\n+\n+    c();\n+    c();\n+}\n+\n fn main() {\n     simple_ref();\n     struct_contains_ref_to_another_struct();\n     no_ref();\n     no_ref_nested();\n+\n+    disjoint_via_ref();\n+    data_moved_but_not_fn_once();\n }"}]}