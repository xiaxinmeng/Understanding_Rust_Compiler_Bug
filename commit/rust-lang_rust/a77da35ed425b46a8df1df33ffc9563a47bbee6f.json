{"sha": "a77da35ed425b46a8df1df33ffc9563a47bbee6f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3N2RhMzVlZDQyNWI0NmE4ZGYxZGYzM2ZmYzk1NjNhNDdiYmVlNmY=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-01-22T08:01:22Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2020-02-05T07:44:07Z"}, "message": "Move traits::select datatypes to traits::types.", "tree": {"sha": "39492314469a264bb53e216393a816e79394f918", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/39492314469a264bb53e216393a816e79394f918"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a77da35ed425b46a8df1df33ffc9563a47bbee6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a77da35ed425b46a8df1df33ffc9563a47bbee6f", "html_url": "https://github.com/rust-lang/rust/commit/a77da35ed425b46a8df1df33ffc9563a47bbee6f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a77da35ed425b46a8df1df33ffc9563a47bbee6f/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a2cd0715fd3b3121512887e2a1e84e26cd6706f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a2cd0715fd3b3121512887e2a1e84e26cd6706f4", "html_url": "https://github.com/rust-lang/rust/commit/a2cd0715fd3b3121512887e2a1e84e26cd6706f4"}], "stats": {"total": 585, "additions": 290, "deletions": 295}, "files": [{"sha": "e88f4e65c7eb11fca4c8327a8bb23435e925943a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a77da35ed425b46a8df1df33ffc9563a47bbee6f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77da35ed425b46a8df1df33ffc9563a47bbee6f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a77da35ed425b46a8df1df33ffc9563a47bbee6f", "patch": "@@ -52,8 +52,7 @@ pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot};\n-pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n-pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n+pub use self::select::{IntercrateAmbiguityCause, SelectionContext};\n pub use self::specialize::find_associated_item;\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;"}, {"sha": "ca4a2aa5935a5f47b5638034cf1085a6264e6362", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 293, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/a77da35ed425b46a8df1df33ffc9563a47bbee6f/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77da35ed425b46a8df1df33ffc9563a47bbee6f/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=a77da35ed425b46a8df1df33ffc9563a47bbee6f", "patch": "@@ -41,7 +41,6 @@ use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, Wit\n use rustc_hir::def_id::DefId;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync::Lock;\n use rustc_hir as hir;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::symbol::sym;\n@@ -53,6 +52,8 @@ use std::iter;\n use std::rc::Rc;\n use syntax::{ast, attr};\n \n+pub use rustc::traits::types::select::*;\n+\n pub struct SelectionContext<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n@@ -181,146 +182,6 @@ struct TraitObligationStack<'prev, 'tcx> {\n     dfn: usize,\n }\n \n-#[derive(Clone, Default)]\n-pub struct SelectionCache<'tcx> {\n-    hashmap: Lock<\n-        FxHashMap<\n-            ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n-            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>,\n-        >,\n-    >,\n-}\n-\n-/// The selection process begins by considering all impls, where\n-/// clauses, and so forth that might resolve an obligation. Sometimes\n-/// we'll be able to say definitively that (e.g.) an impl does not\n-/// apply to the obligation: perhaps it is defined for `usize` but the\n-/// obligation is for `int`. In that case, we drop the impl out of the\n-/// list. But the other cases are considered *candidates*.\n-///\n-/// For selection to succeed, there must be exactly one matching\n-/// candidate. If the obligation is fully known, this is guaranteed\n-/// by coherence. However, if the obligation contains type parameters\n-/// or variables, there may be multiple such impls.\n-///\n-/// It is not a real problem if multiple matching impls exist because\n-/// of type variables - it just means the obligation isn't sufficiently\n-/// elaborated. In that case we report an ambiguity, and the caller can\n-/// try again after more type information has been gathered or report a\n-/// \"type annotations needed\" error.\n-///\n-/// However, with type parameters, this can be a real problem - type\n-/// parameters don't unify with regular types, but they *can* unify\n-/// with variables from blanket impls, and (unless we know its bounds\n-/// will always be satisfied) picking the blanket impl will be wrong\n-/// for at least *some* substitutions. To make this concrete, if we have\n-///\n-///    trait AsDebug { type Out : fmt::Debug; fn debug(self) -> Self::Out; }\n-///    impl<T: fmt::Debug> AsDebug for T {\n-///        type Out = T;\n-///        fn debug(self) -> fmt::Debug { self }\n-///    }\n-///    fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n-///\n-/// we can't just use the impl to resolve the `<T as AsDebug>` obligation\n-/// -- a type from another crate (that doesn't implement `fmt::Debug`) could\n-/// implement `AsDebug`.\n-///\n-/// Because where-clauses match the type exactly, multiple clauses can\n-/// only match if there are unresolved variables, and we can mostly just\n-/// report this ambiguity in that case. This is still a problem - we can't\n-/// *do anything* with ambiguities that involve only regions. This is issue\n-/// #21974.\n-///\n-/// If a single where-clause matches and there are no inference\n-/// variables left, then it definitely matches and we can just select\n-/// it.\n-///\n-/// In fact, we even select the where-clause when the obligation contains\n-/// inference variables. The can lead to inference making \"leaps of logic\",\n-/// for example in this situation:\n-///\n-///    pub trait Foo<T> { fn foo(&self) -> T; }\n-///    impl<T> Foo<()> for T { fn foo(&self) { } }\n-///    impl Foo<bool> for bool { fn foo(&self) -> bool { *self } }\n-///\n-///    pub fn foo<T>(t: T) where T: Foo<bool> {\n-///       println!(\"{:?}\", <T as Foo<_>>::foo(&t));\n-///    }\n-///    fn main() { foo(false); }\n-///\n-/// Here the obligation `<T as Foo<$0>>` can be matched by both the blanket\n-/// impl and the where-clause. We select the where-clause and unify `$0=bool`,\n-/// so the program prints \"false\". However, if the where-clause is omitted,\n-/// the blanket impl is selected, we unify `$0=()`, and the program prints\n-/// \"()\".\n-///\n-/// Exactly the same issues apply to projection and object candidates, except\n-/// that we can have both a projection candidate and a where-clause candidate\n-/// for the same obligation. In that case either would do (except that\n-/// different \"leaps of logic\" would occur if inference variables are\n-/// present), and we just pick the where-clause. This is, for example,\n-/// required for associated types to work in default impls, as the bounds\n-/// are visible both as projection bounds and as where-clauses from the\n-/// parameter environment.\n-#[derive(PartialEq, Eq, Debug, Clone, TypeFoldable)]\n-enum SelectionCandidate<'tcx> {\n-    BuiltinCandidate {\n-        /// `false` if there are no *further* obligations.\n-        has_nested: bool,\n-    },\n-    ParamCandidate(ty::PolyTraitRef<'tcx>),\n-    ImplCandidate(DefId),\n-    AutoImplCandidate(DefId),\n-\n-    /// This is a trait matching with a projected type as `Self`, and\n-    /// we found an applicable bound in the trait definition.\n-    ProjectionCandidate,\n-\n-    /// Implementation of a `Fn`-family trait by one of the anonymous types\n-    /// generated for a `||` expression.\n-    ClosureCandidate,\n-\n-    /// Implementation of a `Generator` trait by one of the anonymous types\n-    /// generated for a generator.\n-    GeneratorCandidate,\n-\n-    /// Implementation of a `Fn`-family trait by one of the anonymous\n-    /// types generated for a fn pointer type (e.g., `fn(int) -> int`)\n-    FnPointerCandidate,\n-\n-    TraitAliasCandidate(DefId),\n-\n-    ObjectCandidate,\n-\n-    BuiltinObjectCandidate,\n-\n-    BuiltinUnsizeCandidate,\n-}\n-\n-impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n-    type Lifted = SelectionCandidate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        Some(match *self {\n-            BuiltinCandidate { has_nested } => BuiltinCandidate { has_nested },\n-            ImplCandidate(def_id) => ImplCandidate(def_id),\n-            AutoImplCandidate(def_id) => AutoImplCandidate(def_id),\n-            ProjectionCandidate => ProjectionCandidate,\n-            ClosureCandidate => ClosureCandidate,\n-            GeneratorCandidate => GeneratorCandidate,\n-            FnPointerCandidate => FnPointerCandidate,\n-            TraitAliasCandidate(def_id) => TraitAliasCandidate(def_id),\n-            ObjectCandidate => ObjectCandidate,\n-            BuiltinObjectCandidate => BuiltinObjectCandidate,\n-            BuiltinUnsizeCandidate => BuiltinUnsizeCandidate,\n-\n-            ParamCandidate(ref trait_ref) => {\n-                return tcx.lift(trait_ref).map(ParamCandidate);\n-            }\n-        })\n-    }\n-}\n-\n struct SelectionCandidateSet<'tcx> {\n     // A list of candidates that definitely apply to the current\n     // obligation (meaning: types unify).\n@@ -350,134 +211,6 @@ enum BuiltinImplConditions<'tcx> {\n     Ambiguous,\n }\n \n-/// The result of trait evaluation. The order is important\n-/// here as the evaluation of a list is the maximum of the\n-/// evaluations.\n-///\n-/// The evaluation results are ordered:\n-///     - `EvaluatedToOk` implies `EvaluatedToOkModuloRegions`\n-///       implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n-///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n-///     - the \"union\" of evaluation results is equal to their maximum -\n-///     all the \"potential success\" candidates can potentially succeed,\n-///     so they are noops when unioned with a definite error, and within\n-///     the categories it's easy to see that the unions are correct.\n-#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq, HashStable)]\n-pub enum EvaluationResult {\n-    /// Evaluation successful.\n-    EvaluatedToOk,\n-    /// Evaluation successful, but there were unevaluated region obligations.\n-    EvaluatedToOkModuloRegions,\n-    /// Evaluation is known to be ambiguous -- it *might* hold for some\n-    /// assignment of inference variables, but it might not.\n-    ///\n-    /// While this has the same meaning as `EvaluatedToUnknown` -- we can't\n-    /// know whether this obligation holds or not -- it is the result we\n-    /// would get with an empty stack, and therefore is cacheable.\n-    EvaluatedToAmbig,\n-    /// Evaluation failed because of recursion involving inference\n-    /// variables. We are somewhat imprecise there, so we don't actually\n-    /// know the real result.\n-    ///\n-    /// This can't be trivially cached for the same reason as `EvaluatedToRecur`.\n-    EvaluatedToUnknown,\n-    /// Evaluation failed because we encountered an obligation we are already\n-    /// trying to prove on this branch.\n-    ///\n-    /// We know this branch can't be a part of a minimal proof-tree for\n-    /// the \"root\" of our cycle, because then we could cut out the recursion\n-    /// and maintain a valid proof tree. However, this does not mean\n-    /// that all the obligations on this branch do not hold -- it's possible\n-    /// that we entered this branch \"speculatively\", and that there\n-    /// might be some other way to prove this obligation that does not\n-    /// go through this cycle -- so we can't cache this as a failure.\n-    ///\n-    /// For example, suppose we have this:\n-    ///\n-    /// ```rust,ignore (pseudo-Rust)\n-    /// pub trait Trait { fn xyz(); }\n-    /// // This impl is \"useless\", but we can still have\n-    /// // an `impl Trait for SomeUnsizedType` somewhere.\n-    /// impl<T: Trait + Sized> Trait for T { fn xyz() {} }\n-    ///\n-    /// pub fn foo<T: Trait + ?Sized>() {\n-    ///     <T as Trait>::xyz();\n-    /// }\n-    /// ```\n-    ///\n-    /// When checking `foo`, we have to prove `T: Trait`. This basically\n-    /// translates into this:\n-    ///\n-    /// ```plain,ignore\n-    /// (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n-    /// ```\n-    ///\n-    /// When we try to prove it, we first go the first option, which\n-    /// recurses. This shows us that the impl is \"useless\" -- it won't\n-    /// tell us that `T: Trait` unless it already implemented `Trait`\n-    /// by some other means. However, that does not prevent `T: Trait`\n-    /// does not hold, because of the bound (which can indeed be satisfied\n-    /// by `SomeUnsizedType` from another crate).\n-    //\n-    // FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n-    // ought to convert it to an `EvaluatedToErr`, because we know\n-    // there definitely isn't a proof tree for that obligation. Not\n-    // doing so is still sound -- there isn't any proof tree, so the\n-    // branch still can't be a part of a minimal one -- but does not re-enable caching.\n-    EvaluatedToRecur,\n-    /// Evaluation failed.\n-    EvaluatedToErr,\n-}\n-\n-impl EvaluationResult {\n-    /// Returns `true` if this evaluation result is known to apply, even\n-    /// considering outlives constraints.\n-    pub fn must_apply_considering_regions(self) -> bool {\n-        self == EvaluatedToOk\n-    }\n-\n-    /// Returns `true` if this evaluation result is known to apply, ignoring\n-    /// outlives constraints.\n-    pub fn must_apply_modulo_regions(self) -> bool {\n-        self <= EvaluatedToOkModuloRegions\n-    }\n-\n-    pub fn may_apply(self) -> bool {\n-        match self {\n-            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToUnknown => {\n-                true\n-            }\n-\n-            EvaluatedToErr | EvaluatedToRecur => false,\n-        }\n-    }\n-\n-    fn is_stack_dependent(self) -> bool {\n-        match self {\n-            EvaluatedToUnknown | EvaluatedToRecur => true,\n-\n-            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToErr => false,\n-        }\n-    }\n-}\n-\n-/// Indicates that trait evaluation caused overflow.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n-pub struct OverflowError;\n-\n-impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n-    fn from(OverflowError: OverflowError) -> SelectionError<'tcx> {\n-        SelectionError::Overflow\n-    }\n-}\n-\n-#[derive(Clone, Default)]\n-pub struct EvaluationCache<'tcx> {\n-    hashmap: Lock<\n-        FxHashMap<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, WithDepNode<EvaluationResult>>,\n-    >,\n-}\n-\n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n@@ -3827,13 +3560,6 @@ impl<'tcx> TraitObligation<'tcx> {\n     }\n }\n \n-impl<'tcx> SelectionCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n-\n impl<'tcx> EvaluationCache<'tcx> {\n     /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n     pub fn clear(&self) {\n@@ -4126,20 +3852,3 @@ impl<'o, 'tcx> fmt::Debug for TraitObligationStack<'o, 'tcx> {\n         write!(f, \"TraitObligationStack({:?})\", self.obligation)\n     }\n }\n-\n-#[derive(Clone, Eq, PartialEq)]\n-pub struct WithDepNode<T> {\n-    dep_node: DepNodeIndex,\n-    cached_value: T,\n-}\n-\n-impl<T: Clone> WithDepNode<T> {\n-    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n-        WithDepNode { dep_node, cached_value }\n-    }\n-\n-    pub fn get(&self, tcx: TyCtxt<'_>) -> T {\n-        tcx.dep_graph.read_index(self.dep_node);\n-        self.cached_value.clone()\n-    }\n-}"}, {"sha": "05fd02d6aa6cfa6d132f3c1677162c2c6ee14e9d", "filename": "src/librustc/traits/types/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a77da35ed425b46a8df1df33ffc9563a47bbee6f/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77da35ed425b46a8df1df33ffc9563a47bbee6f/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs?ref=a77da35ed425b46a8df1df33ffc9563a47bbee6f", "patch": "@@ -2,6 +2,8 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n \n+pub mod select;\n+\n use crate::mir::interpret::ErrorHandled;\n use crate::ty::fold::{TypeFolder, TypeVisitor};\n use crate::ty::subst::SubstsRef;\n@@ -15,6 +17,8 @@ use syntax::ast;\n use std::fmt::Debug;\n use std::rc::Rc;\n \n+pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n+\n pub use self::ObligationCauseCode::*;\n pub use self::SelectionError::*;\n pub use self::Vtable::*;"}, {"sha": "9e5bd4cbb9a053fa8cb8a4a7b44fbc476d668bfd", "filename": "src/librustc/traits/types/select.rs", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/a77da35ed425b46a8df1df33ffc9563a47bbee6f/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a77da35ed425b46a8df1df33ffc9563a47bbee6f/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs?ref=a77da35ed425b46a8df1df33ffc9563a47bbee6f", "patch": "@@ -0,0 +1,283 @@\n+//! Candidate selection. See the [rustc guide] for more information on how this works.\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html#selection\n+\n+use self::EvaluationResult::*;\n+\n+use super::{SelectionError, SelectionResult};\n+\n+use crate::dep_graph::DepNodeIndex;\n+use crate::ty::{self, TyCtxt};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lock;\n+use rustc_hir::def_id::DefId;\n+\n+#[derive(Clone, Default)]\n+pub struct SelectionCache<'tcx> {\n+    pub hashmap: Lock<\n+        FxHashMap<\n+            ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n+            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>,\n+        >,\n+    >,\n+}\n+\n+impl<'tcx> SelectionCache<'tcx> {\n+    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n+    pub fn clear(&self) {\n+        *self.hashmap.borrow_mut() = Default::default();\n+    }\n+}\n+\n+/// The selection process begins by considering all impls, where\n+/// clauses, and so forth that might resolve an obligation. Sometimes\n+/// we'll be able to say definitively that (e.g.) an impl does not\n+/// apply to the obligation: perhaps it is defined for `usize` but the\n+/// obligation is for `int`. In that case, we drop the impl out of the\n+/// list. But the other cases are considered *candidates*.\n+///\n+/// For selection to succeed, there must be exactly one matching\n+/// candidate. If the obligation is fully known, this is guaranteed\n+/// by coherence. However, if the obligation contains type parameters\n+/// or variables, there may be multiple such impls.\n+///\n+/// It is not a real problem if multiple matching impls exist because\n+/// of type variables - it just means the obligation isn't sufficiently\n+/// elaborated. In that case we report an ambiguity, and the caller can\n+/// try again after more type information has been gathered or report a\n+/// \"type annotations needed\" error.\n+///\n+/// However, with type parameters, this can be a real problem - type\n+/// parameters don't unify with regular types, but they *can* unify\n+/// with variables from blanket impls, and (unless we know its bounds\n+/// will always be satisfied) picking the blanket impl will be wrong\n+/// for at least *some* substitutions. To make this concrete, if we have\n+///\n+///    trait AsDebug { type Out : fmt::Debug; fn debug(self) -> Self::Out; }\n+///    impl<T: fmt::Debug> AsDebug for T {\n+///        type Out = T;\n+///        fn debug(self) -> fmt::Debug { self }\n+///    }\n+///    fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n+///\n+/// we can't just use the impl to resolve the `<T as AsDebug>` obligation\n+/// -- a type from another crate (that doesn't implement `fmt::Debug`) could\n+/// implement `AsDebug`.\n+///\n+/// Because where-clauses match the type exactly, multiple clauses can\n+/// only match if there are unresolved variables, and we can mostly just\n+/// report this ambiguity in that case. This is still a problem - we can't\n+/// *do anything* with ambiguities that involve only regions. This is issue\n+/// #21974.\n+///\n+/// If a single where-clause matches and there are no inference\n+/// variables left, then it definitely matches and we can just select\n+/// it.\n+///\n+/// In fact, we even select the where-clause when the obligation contains\n+/// inference variables. The can lead to inference making \"leaps of logic\",\n+/// for example in this situation:\n+///\n+///    pub trait Foo<T> { fn foo(&self) -> T; }\n+///    impl<T> Foo<()> for T { fn foo(&self) { } }\n+///    impl Foo<bool> for bool { fn foo(&self) -> bool { *self } }\n+///\n+///    pub fn foo<T>(t: T) where T: Foo<bool> {\n+///       println!(\"{:?}\", <T as Foo<_>>::foo(&t));\n+///    }\n+///    fn main() { foo(false); }\n+///\n+/// Here the obligation `<T as Foo<$0>>` can be matched by both the blanket\n+/// impl and the where-clause. We select the where-clause and unify `$0=bool`,\n+/// so the program prints \"false\". However, if the where-clause is omitted,\n+/// the blanket impl is selected, we unify `$0=()`, and the program prints\n+/// \"()\".\n+///\n+/// Exactly the same issues apply to projection and object candidates, except\n+/// that we can have both a projection candidate and a where-clause candidate\n+/// for the same obligation. In that case either would do (except that\n+/// different \"leaps of logic\" would occur if inference variables are\n+/// present), and we just pick the where-clause. This is, for example,\n+/// required for associated types to work in default impls, as the bounds\n+/// are visible both as projection bounds and as where-clauses from the\n+/// parameter environment.\n+#[derive(PartialEq, Eq, Debug, Clone, TypeFoldable)]\n+pub enum SelectionCandidate<'tcx> {\n+    BuiltinCandidate {\n+        /// `false` if there are no *further* obligations.\n+        has_nested: bool,\n+    },\n+    ParamCandidate(ty::PolyTraitRef<'tcx>),\n+    ImplCandidate(DefId),\n+    AutoImplCandidate(DefId),\n+\n+    /// This is a trait matching with a projected type as `Self`, and\n+    /// we found an applicable bound in the trait definition.\n+    ProjectionCandidate,\n+\n+    /// Implementation of a `Fn`-family trait by one of the anonymous types\n+    /// generated for a `||` expression.\n+    ClosureCandidate,\n+\n+    /// Implementation of a `Generator` trait by one of the anonymous types\n+    /// generated for a generator.\n+    GeneratorCandidate,\n+\n+    /// Implementation of a `Fn`-family trait by one of the anonymous\n+    /// types generated for a fn pointer type (e.g., `fn(int) -> int`)\n+    FnPointerCandidate,\n+\n+    TraitAliasCandidate(DefId),\n+\n+    ObjectCandidate,\n+\n+    BuiltinObjectCandidate,\n+\n+    BuiltinUnsizeCandidate,\n+}\n+\n+/// The result of trait evaluation. The order is important\n+/// here as the evaluation of a list is the maximum of the\n+/// evaluations.\n+///\n+/// The evaluation results are ordered:\n+///     - `EvaluatedToOk` implies `EvaluatedToOkModuloRegions`\n+///       implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n+///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n+///     - the \"union\" of evaluation results is equal to their maximum -\n+///     all the \"potential success\" candidates can potentially succeed,\n+///     so they are noops when unioned with a definite error, and within\n+///     the categories it's easy to see that the unions are correct.\n+#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq, HashStable)]\n+pub enum EvaluationResult {\n+    /// Evaluation successful.\n+    EvaluatedToOk,\n+    /// Evaluation successful, but there were unevaluated region obligations.\n+    EvaluatedToOkModuloRegions,\n+    /// Evaluation is known to be ambiguous -- it *might* hold for some\n+    /// assignment of inference variables, but it might not.\n+    ///\n+    /// While this has the same meaning as `EvaluatedToUnknown` -- we can't\n+    /// know whether this obligation holds or not -- it is the result we\n+    /// would get with an empty stack, and therefore is cacheable.\n+    EvaluatedToAmbig,\n+    /// Evaluation failed because of recursion involving inference\n+    /// variables. We are somewhat imprecise there, so we don't actually\n+    /// know the real result.\n+    ///\n+    /// This can't be trivially cached for the same reason as `EvaluatedToRecur`.\n+    EvaluatedToUnknown,\n+    /// Evaluation failed because we encountered an obligation we are already\n+    /// trying to prove on this branch.\n+    ///\n+    /// We know this branch can't be a part of a minimal proof-tree for\n+    /// the \"root\" of our cycle, because then we could cut out the recursion\n+    /// and maintain a valid proof tree. However, this does not mean\n+    /// that all the obligations on this branch do not hold -- it's possible\n+    /// that we entered this branch \"speculatively\", and that there\n+    /// might be some other way to prove this obligation that does not\n+    /// go through this cycle -- so we can't cache this as a failure.\n+    ///\n+    /// For example, suppose we have this:\n+    ///\n+    /// ```rust,ignore (pseudo-Rust)\n+    /// pub trait Trait { fn xyz(); }\n+    /// // This impl is \"useless\", but we can still have\n+    /// // an `impl Trait for SomeUnsizedType` somewhere.\n+    /// impl<T: Trait + Sized> Trait for T { fn xyz() {} }\n+    ///\n+    /// pub fn foo<T: Trait + ?Sized>() {\n+    ///     <T as Trait>::xyz();\n+    /// }\n+    /// ```\n+    ///\n+    /// When checking `foo`, we have to prove `T: Trait`. This basically\n+    /// translates into this:\n+    ///\n+    /// ```plain,ignore\n+    /// (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n+    /// ```\n+    ///\n+    /// When we try to prove it, we first go the first option, which\n+    /// recurses. This shows us that the impl is \"useless\" -- it won't\n+    /// tell us that `T: Trait` unless it already implemented `Trait`\n+    /// by some other means. However, that does not prevent `T: Trait`\n+    /// does not hold, because of the bound (which can indeed be satisfied\n+    /// by `SomeUnsizedType` from another crate).\n+    //\n+    // FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n+    // ought to convert it to an `EvaluatedToErr`, because we know\n+    // there definitely isn't a proof tree for that obligation. Not\n+    // doing so is still sound -- there isn't any proof tree, so the\n+    // branch still can't be a part of a minimal one -- but does not re-enable caching.\n+    EvaluatedToRecur,\n+    /// Evaluation failed.\n+    EvaluatedToErr,\n+}\n+\n+impl EvaluationResult {\n+    /// Returns `true` if this evaluation result is known to apply, even\n+    /// considering outlives constraints.\n+    pub fn must_apply_considering_regions(self) -> bool {\n+        self == EvaluatedToOk\n+    }\n+\n+    /// Returns `true` if this evaluation result is known to apply, ignoring\n+    /// outlives constraints.\n+    pub fn must_apply_modulo_regions(self) -> bool {\n+        self <= EvaluatedToOkModuloRegions\n+    }\n+\n+    pub fn may_apply(self) -> bool {\n+        match self {\n+            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToUnknown => {\n+                true\n+            }\n+\n+            EvaluatedToErr | EvaluatedToRecur => false,\n+        }\n+    }\n+\n+    pub fn is_stack_dependent(self) -> bool {\n+        match self {\n+            EvaluatedToUnknown | EvaluatedToRecur => true,\n+\n+            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToErr => false,\n+        }\n+    }\n+}\n+\n+/// Indicates that trait evaluation caused overflow.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n+pub struct OverflowError;\n+\n+impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n+    fn from(OverflowError: OverflowError) -> SelectionError<'tcx> {\n+        SelectionError::Overflow\n+    }\n+}\n+\n+#[derive(Clone, Default)]\n+pub struct EvaluationCache<'tcx> {\n+    pub hashmap: Lock<\n+        FxHashMap<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, WithDepNode<EvaluationResult>>,\n+    >,\n+}\n+\n+#[derive(Clone, Eq, PartialEq)]\n+pub struct WithDepNode<T> {\n+    dep_node: DepNodeIndex,\n+    cached_value: T,\n+}\n+\n+impl<T: Clone> WithDepNode<T> {\n+    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n+        WithDepNode { dep_node, cached_value }\n+    }\n+\n+    pub fn get(&self, tcx: TyCtxt<'_>) -> T {\n+        tcx.dep_graph.read_index(self.dep_node);\n+        self.cached_value.clone()\n+    }\n+}"}]}