{"sha": "15db1652f88dc8c20c5cb157978a1ac3ec447b9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1ZGIxNjUyZjg4ZGM4YzIwYzVjYjE1Nzk3OGExYWMzZWM0NDdiOWU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-14T11:03:57Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-11-14T11:03:57Z"}, "message": "incr.comp.: Implement TyDecoder for on_disk_cache::CacheDecoder.", "tree": {"sha": "29f9f166b7a5afad1adf7be82b7fc0af4ddc240a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/29f9f166b7a5afad1adf7be82b7fc0af4ddc240a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15db1652f88dc8c20c5cb157978a1ac3ec447b9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15db1652f88dc8c20c5cb157978a1ac3ec447b9e", "html_url": "https://github.com/rust-lang/rust/commit/15db1652f88dc8c20c5cb157978a1ac3ec447b9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15db1652f88dc8c20c5cb157978a1ac3ec447b9e/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bd333c988d479c11d5da18463d4c9f020f4f56e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd333c988d479c11d5da18463d4c9f020f4f56e", "html_url": "https://github.com/rust-lang/rust/commit/3bd333c988d479c11d5da18463d4c9f020f4f56e"}], "stats": {"total": 276, "additions": 263, "deletions": 13}, "files": [{"sha": "b2eefca7fe2321123f66cfd9b7fccde36817fae1", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15db1652f88dc8c20c5cb157978a1ac3ec447b9e/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15db1652f88dc8c20c5cb157978a1ac3ec447b9e/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=15db1652f88dc8c20c5cb157978a1ac3ec447b9e", "patch": "@@ -32,6 +32,10 @@ newtype_index!(CrateNum\n \n         /// A CrateNum value that indicates that something is wrong.\n         const INVALID_CRATE = u32::MAX - 1,\n+\n+        /// A special CrateNum that we use for the tcx.rcache when decoding from\n+        /// the incr. comp. cache.\n+        const RESERVED_FOR_INCR_COMP_CACHE = u32::MAX - 2,\n     });\n \n impl CrateNum {"}, {"sha": "3bc2736586f45a17eca9a8fbb44b17e064ed29d6", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 27, "deletions": 2, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/15db1652f88dc8c20c5cb157978a1ac3ec447b9e/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15db1652f88dc8c20c5cb157978a1ac3ec447b9e/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=15db1652f88dc8c20c5cb157978a1ac3ec447b9e", "patch": "@@ -45,6 +45,7 @@ use ty::AdtKind;\n \n use rustc_data_structures::indexed_vec;\n \n+use serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::BTreeMap;\n use std::fmt;\n \n@@ -85,13 +86,37 @@ pub mod svh;\n /// the local_id part of the HirId changing, which is a very useful property in\n /// incremental compilation where we have to persist things through changes to\n /// the code base.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug,\n-         RustcEncodable, RustcDecodable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n pub struct HirId {\n     pub owner: DefIndex,\n     pub local_id: ItemLocalId,\n }\n \n+impl serialize::UseSpecializedEncodable for HirId {\n+    fn default_encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        let HirId {\n+            owner,\n+            local_id,\n+        } = *self;\n+\n+        owner.encode(s)?;\n+        local_id.encode(s)\n+    }\n+}\n+\n+impl serialize::UseSpecializedDecodable for HirId {\n+    fn default_decode<D: Decoder>(d: &mut D) -> Result<HirId, D::Error> {\n+        let owner = DefIndex::decode(d)?;\n+        let local_id = ItemLocalId::decode(d)?;\n+\n+        Ok(HirId {\n+            owner,\n+            local_id\n+        })\n+    }\n+}\n+\n+\n /// An `ItemLocalId` uniquely identifies something within a given \"item-like\",\n /// that is within a hir::Item, hir::TraitItem, or hir::ImplItem. There is no\n /// guarantee that the numerical value of a given `ItemLocalId` corresponds to"}, {"sha": "20bddb15603572ae1566d621516a4feadddf8233", "filename": "src/librustc/ty/maps/on_disk_cache.rs", "status": "modified", "additions": 232, "deletions": 11, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/15db1652f88dc8c20c5cb157978a1ac3ec447b9e/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15db1652f88dc8c20c5cb157978a1ac3ec447b9e/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps%2Fon_disk_cache.rs?ref=15db1652f88dc8c20c5cb157978a1ac3ec447b9e", "patch": "@@ -9,21 +9,29 @@\n // except according to those terms.\n \n use dep_graph::{DepNodeIndex, SerializedDepNodeIndex};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_vec::Idx;\n use errors::Diagnostic;\n+use hir;\n+use hir::def_id::{CrateNum, DefIndex, DefId, RESERVED_FOR_INCR_COMP_CACHE,\n+                  LOCAL_CRATE};\n+use hir::map::definitions::{Definitions, DefPathTable};\n+use middle::const_val::ByteArray;\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n-                      SpecializedDecoder, SpecializedEncoder};\n+                      SpecializedDecoder, SpecializedEncoder,\n+                      UseSpecializedDecodable};\n use session::Session;\n use std::borrow::Cow;\n use std::cell::RefCell;\n use std::collections::BTreeMap;\n use std::mem;\n+use syntax::ast::NodeId;\n use syntax::codemap::{CodeMap, StableFilemapId};\n use syntax_pos::{BytePos, Span, NO_EXPANSION, DUMMY_SP};\n use ty;\n-use ty::codec::{self as ty_codec};\n+use ty::codec::{self as ty_codec, TyDecoder};\n use ty::context::TyCtxt;\n+use ty::subst::Substs;\n \n /// `OnDiskCache` provides an interface to incr. comp. data cached from the\n /// previous compilation session. This data will eventually include the results\n@@ -65,9 +73,12 @@ impl<'sess> OnDiskCache<'sess> {\n \n         let prev_diagnostics = {\n             let mut decoder = CacheDecoder {\n+                tcx: None,\n                 opaque: decoder,\n                 codemap: sess.codemap(),\n                 prev_filemap_starts: &header.prev_filemap_starts,\n+                cnum_map: &IndexVec::new(),\n+                prev_def_path_tables: &Vec::new(),\n             };\n \n             let prev_diagnostics: FxHashMap<_, _> = {\n@@ -110,6 +121,7 @@ impl<'sess> OnDiskCache<'sess> {\n             encoder,\n             type_shorthands: FxHashMap(),\n             predicate_shorthands: FxHashMap(),\n+            definitions: tcx.hir.definitions(),\n         };\n \n         let prev_filemap_starts: BTreeMap<_, _> = self\n@@ -174,13 +186,16 @@ impl<'sess> OnDiskCache<'sess> {\n /// A decoder that can read the incr. comp. cache. It is similar to the one\n /// we use for crate metadata decoding in that it can rebase spans and\n /// eventually will also handle things that contain `Ty` instances.\n-struct CacheDecoder<'a> {\n-    opaque: opaque::Decoder<'a>,\n-    codemap: &'a CodeMap,\n-    prev_filemap_starts: &'a BTreeMap<BytePos, StableFilemapId>,\n+struct CacheDecoder<'a, 'tcx: 'a, 'x> {\n+    tcx: Option<TyCtxt<'a, 'tcx, 'tcx>>,\n+    opaque: opaque::Decoder<'x>,\n+    codemap: &'x CodeMap,\n+    prev_filemap_starts: &'x BTreeMap<BytePos, StableFilemapId>,\n+    cnum_map: &'x IndexVec<CrateNum, Option<CrateNum>>,\n+    prev_def_path_tables: &'x Vec<DefPathTable>,\n }\n \n-impl<'a> CacheDecoder<'a> {\n+impl<'a, 'tcx, 'x> CacheDecoder<'a, 'tcx, 'x> {\n     fn find_filemap_prev_bytepos(&self,\n                                  prev_bytepos: BytePos)\n                                  -> Option<(BytePos, StableFilemapId)> {\n@@ -200,7 +215,7 @@ macro_rules! decoder_methods {\n     }\n }\n \n-impl<'sess> Decoder for CacheDecoder<'sess> {\n+impl<'a, 'tcx, 'x> Decoder for CacheDecoder<'a, 'tcx, 'x> {\n     type Error = String;\n \n     decoder_methods! {\n@@ -232,7 +247,65 @@ impl<'sess> Decoder for CacheDecoder<'sess> {\n     }\n }\n \n-impl<'a> SpecializedDecoder<Span> for CacheDecoder<'a> {\n+impl<'a, 'tcx: 'a, 'x> ty_codec::TyDecoder<'a, 'tcx> for CacheDecoder<'a, 'tcx, 'x> {\n+\n+    #[inline]\n+    fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n+        self.tcx.expect(\"missing TyCtxt in CacheDecoder\")\n+    }\n+\n+    #[inline]\n+    fn position(&self) -> usize {\n+        self.opaque.position()\n+    }\n+\n+    #[inline]\n+    fn peek_byte(&self) -> u8 {\n+        self.opaque.data[self.opaque.position()]\n+    }\n+\n+    fn cached_ty_for_shorthand<F>(&mut self,\n+                                  shorthand: usize,\n+                                  or_insert_with: F)\n+                                  -> Result<ty::Ty<'tcx>, Self::Error>\n+        where F: FnOnce(&mut Self) -> Result<ty::Ty<'tcx>, Self::Error>\n+    {\n+        let tcx = self.tcx();\n+\n+        let cache_key = ty::CReaderCacheKey {\n+            cnum: RESERVED_FOR_INCR_COMP_CACHE,\n+            pos: shorthand,\n+        };\n+\n+        if let Some(&ty) = tcx.rcache.borrow().get(&cache_key) {\n+            return Ok(ty);\n+        }\n+\n+        let ty = or_insert_with(self)?;\n+        tcx.rcache.borrow_mut().insert(cache_key, ty);\n+        Ok(ty)\n+    }\n+\n+    fn with_position<F, R>(&mut self, pos: usize, f: F) -> R\n+        where F: FnOnce(&mut Self) -> R\n+    {\n+        debug_assert!(pos < self.opaque.data.len());\n+\n+        let new_opaque = opaque::Decoder::new(self.opaque.data, pos);\n+        let old_opaque = mem::replace(&mut self.opaque, new_opaque);\n+        let r = f(self);\n+        self.opaque = old_opaque;\n+        r\n+    }\n+\n+    fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n+        self.cnum_map[cnum].unwrap_or_else(|| {\n+            bug!(\"Could not find new CrateNum for {:?}\", cnum)\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx, 'x> {\n     fn specialized_decode(&mut self) -> Result<Span, Self::Error> {\n         let lo = BytePos::decode(self)?;\n         let hi = BytePos::decode(self)?;\n@@ -249,6 +322,142 @@ impl<'a> SpecializedDecoder<Span> for CacheDecoder<'a> {\n     }\n }\n \n+impl<'a, 'tcx, 'x> SpecializedDecoder<CrateNum> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<CrateNum, Self::Error> {\n+        let cnum = CrateNum::from_u32(u32::decode(self)?);\n+        let mapped = self.map_encoded_cnum_to_current(cnum);\n+        Ok(mapped)\n+    }\n+}\n+\n+// This impl makes sure that we get a runtime error when we try decode a\n+// DefIndex that is not contained in a DefId. Such a case would be problematic\n+// because we would not know how to transform the DefIndex to the current\n+// context.\n+impl<'a, 'tcx, 'x> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n+        bug!(\"Trying to decode DefIndex outside the context of a DefId\")\n+    }\n+}\n+\n+// Both the CrateNum and the DefIndex of a DefId can change in between two\n+// compilation sessions. We use the DefPathHash, which is stable across\n+// sessions, to map the old DefId to the new one.\n+impl<'a, 'tcx, 'x> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n+        // Decode the unmapped CrateNum\n+        let prev_cnum = CrateNum::default_decode(self)?;\n+\n+        // Decode the unmapped DefIndex\n+        let def_index = DefIndex::default_decode(self)?;\n+\n+        // Unmapped CrateNum and DefIndex are valid keys for the *cached*\n+        // DefPathTables, so we use them to look up the DefPathHash.\n+        let def_path_hash = self.prev_def_path_tables[prev_cnum.index()]\n+                                .def_path_hash(def_index);\n+\n+        // Using the DefPathHash, we can lookup the new DefId\n+        Ok(self.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<hir::HirId, Self::Error> {\n+        // Decode the unmapped DefIndex of the HirId.\n+        let def_index = DefIndex::default_decode(self)?;\n+\n+        // Use the unmapped DefIndex to look up the DefPathHash in the cached\n+        // DefPathTable. For HirIds we know that we always have to look in the\n+        // *local* DefPathTable.\n+        let def_path_hash = self.prev_def_path_tables[LOCAL_CRATE.index()]\n+                                .def_path_hash(def_index);\n+\n+        // Use the DefPathHash to map to the current DefId.\n+        let def_id = self.tcx()\n+                         .def_path_hash_to_def_id\n+                         .as_ref()\n+                         .unwrap()[&def_path_hash];\n+\n+        // The ItemLocalId needs no remapping.\n+        let local_id = hir::ItemLocalId::decode(self)?;\n+\n+        // Reconstruct the HirId and look up the corresponding NodeId in the\n+        // context of the current session.\n+        Ok(hir::HirId {\n+            owner: def_id.index,\n+            local_id\n+        })\n+    }\n+}\n+\n+// NodeIds are not stable across compilation sessions, so we store them in their\n+// HirId representation. This allows use to map them to the current NodeId.\n+impl<'a, 'tcx, 'x> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n+        let hir_id = hir::HirId::decode(self)?;\n+        Ok(self.tcx().hir.hir_to_node_id(hir_id))\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<ty::Ty<'tcx>> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<ty::Ty<'tcx>, Self::Error> {\n+        ty_codec::decode_ty(self)\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<ty::GenericPredicates<'tcx>>\n+for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<ty::GenericPredicates<'tcx>, Self::Error> {\n+        ty_codec::decode_predicates(self)\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<&'tcx Substs<'tcx>> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx Substs<'tcx>, Self::Error> {\n+        ty_codec::decode_substs(self)\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<ty::Region<'tcx>> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<ty::Region<'tcx>, Self::Error> {\n+        ty_codec::decode_region(self)\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<&'tcx ty::Slice<ty::Ty<'tcx>>>\n+for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::Slice<ty::Ty<'tcx>>, Self::Error> {\n+        ty_codec::decode_ty_slice(self)\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<&'tcx ty::AdtDef> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::AdtDef, Self::Error> {\n+        ty_codec::decode_adt_def(self)\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>\n+    for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self)\n+        -> Result<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, Self::Error> {\n+        ty_codec::decode_existential_predicate_slice(self)\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<ByteArray<'tcx>> for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<ByteArray<'tcx>, Self::Error> {\n+        ty_codec::decode_byte_array(self)\n+    }\n+}\n+\n+impl<'a, 'tcx, 'x> SpecializedDecoder<&'tcx ty::Const<'tcx>>\n+for CacheDecoder<'a, 'tcx, 'x> {\n+    fn specialized_decode(&mut self) -> Result<&'tcx ty::Const<'tcx>, Self::Error> {\n+        ty_codec::decode_const(self)\n+    }\n+}\n+\n \n //- ENCODING -------------------------------------------------------------------\n \n@@ -258,6 +467,7 @@ struct CacheEncoder<'enc, 'tcx, E>\n     encoder: &'enc mut E,\n     type_shorthands: FxHashMap<ty::Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n+    definitions: &'enc Definitions,\n }\n \n impl<'enc, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'enc, 'tcx, E>\n@@ -289,6 +499,17 @@ impl<'enc, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>>\n     }\n }\n \n+// NodeIds are not stable across compilation sessions, so we store them in their\n+// HirId representation. This allows use to map them to the current NodeId.\n+impl<'enc, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'enc, 'tcx, E>\n+    where E: 'enc + ty_codec::TyEncoder\n+{\n+    fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n+        let hir_id = self.definitions.node_to_hir_id(*node_id);\n+        hir_id.encode(self)\n+    }\n+}\n+\n macro_rules! encoder_methods {\n     ($($name:ident($ty:ty);)*) => {\n         $(fn $name(&mut self, value: $ty) -> Result<(), Self::Error> {"}]}