{"sha": "b820c761744db080ff7a4ba3ac88d259065cb836", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MjBjNzYxNzQ0ZGIwODBmZjdhNGJhM2FjODhkMjU5MDY1Y2I4MzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-06T02:58:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-07-06T02:58:36Z"}, "message": "Auto merge of #62428 - Centril:rollup-2udow5e, r=Centril\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #62151 (Update linked OpenSSL version)\n - #62245 (Miri engine: support extra function (pointer) values)\n - #62257 (forward read_c_str method from Memory to Alloc)\n - #62264 (Fix perf regression from Miri Machine trait changes)\n - #62296 (request at least ptr-size alignment from posix_memalign)\n - #62329 (Remove support for 1-token lookahead from the lexer)\n - #62377 (Add test for ICE #62375)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d3d1512abe1b1b3b5bf5c8f73eff3e54bb0da547", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d3d1512abe1b1b3b5bf5c8f73eff3e54bb0da547"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b820c761744db080ff7a4ba3ac88d259065cb836", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b820c761744db080ff7a4ba3ac88d259065cb836", "html_url": "https://github.com/rust-lang/rust/commit/b820c761744db080ff7a4ba3ac88d259065cb836", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b820c761744db080ff7a4ba3ac88d259065cb836/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "481068a707679257e2a738b40987246e0420e787", "url": "https://api.github.com/repos/rust-lang/rust/commits/481068a707679257e2a738b40987246e0420e787", "html_url": "https://github.com/rust-lang/rust/commit/481068a707679257e2a738b40987246e0420e787"}, {"sha": "46edb516dfc207450d84b89c4914c83e4d82006a", "url": "https://api.github.com/repos/rust-lang/rust/commits/46edb516dfc207450d84b89c4914c83e4d82006a", "html_url": "https://github.com/rust-lang/rust/commit/46edb516dfc207450d84b89c4914c83e4d82006a"}], "stats": {"total": 896, "additions": 511, "deletions": 385}, "files": [{"sha": "d962b134ea2899e309d89d2b4bd8cb83bad8aaf8", "filename": "Cargo.lock", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -1835,7 +1835,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \n [[package]]\n name = \"openssl-src\"\n-version = \"111.1.0+1.1.1a\"\n+version = \"111.3.0+1.1.1c\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -1848,7 +1848,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n dependencies = [\n  \"cc 1.0.35 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"libc 0.2.54 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"openssl-src 111.1.0+1.1.1a (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"openssl-src 111.3.0+1.1.1c (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"pkg-config 0.3.14 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"vcpkg 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4384,7 +4384,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum opener 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"998c59e83d9474c01127a96e023b7a04bb061dd286bf8bb939d31dc8d31a7448\"\n \"checksum openssl 0.10.16 (registry+https://github.com/rust-lang/crates.io-index)\" = \"ec7bd7ca4cce6dbdc77e7c1230682740d307d1218a87fb0349a571272be749f9\"\n \"checksum openssl-probe 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n-\"checksum openssl-src 111.1.0+1.1.1a (registry+https://github.com/rust-lang/crates.io-index)\" = \"26bb632127731bf4ac49bf86a5dde12d2ca0918c2234fc39d79d4da2ccbc6da7\"\n+\"checksum openssl-src 111.3.0+1.1.1c (registry+https://github.com/rust-lang/crates.io-index)\" = \"53ed5f31d294bdf5f7a4ba0a206c2754b0f60e9a63b7e3076babc5317873c797\"\n \"checksum openssl-sys 0.9.43 (registry+https://github.com/rust-lang/crates.io-index)\" = \"33c86834957dd5b915623e94f2f4ab2c70dd8f6b70679824155d5ae21dbd495d\"\n \"checksum ordermap 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\" = \"a86ed3f5f244b372d6b1a00b72ef7f8876d0bc6a78a4c9985c53614041512063\"\n \"checksum ordslice 0.3.0 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dd20eec3dbe4376829cb7d80ae6ac45e0a766831dca50202ff2d40db46a8a024\""}, {"sha": "904b3e7e1b07cc4f23bd2ddae5e3063d1e335752", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -1,6 +1,6 @@\n use std::alloc::{Global, Alloc, Layout, System};\n \n-/// Issue #45955.\n+/// Issue #45955 and #62251.\n #[test]\n fn alloc_system_overaligned_request() {\n     check_overalign_requests(System)\n@@ -12,21 +12,23 @@ fn std_heap_overaligned_request() {\n }\n \n fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n-    let size = 8;\n-    let align = 16; // greater than size\n-    let iterations = 100;\n-    unsafe {\n-        let pointers: Vec<_> = (0..iterations).map(|_| {\n-            allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n-        }).collect();\n-        for &ptr in &pointers {\n-            assert_eq!((ptr.as_ptr() as usize) % align, 0,\n-                       \"Got a pointer less aligned than requested\")\n-        }\n+    for &align in &[4, 8, 16, 32] { // less than and bigger than `MIN_ALIGN`\n+        for &size in &[align/2, align-1] { // size less than alignment\n+            let iterations = 128;\n+            unsafe {\n+                let pointers: Vec<_> = (0..iterations).map(|_| {\n+                    allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n+                }).collect();\n+                for &ptr in &pointers {\n+                    assert_eq!((ptr.as_ptr() as usize) % align, 0,\n+                               \"Got a pointer less aligned than requested\")\n+                }\n \n-        // Clean up\n-        for &ptr in &pointers {\n-            allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n+                // Clean up\n+                for &ptr in &pointers {\n+                    allocator.dealloc(ptr, Layout::from_size_align(size, align).unwrap())\n+                }\n+            }\n         }\n     }\n }"}, {"sha": "f8de1cfaea0980361e6b770489c59a2a02e1a22d", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -11,7 +11,7 @@ use rustc::hir::def::DefKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{ConstEvalErr, ErrorHandled, ScalarMaybeUndef};\n use rustc::mir;\n-use rustc::ty::{self, TyCtxt, query::TyCtxtAt};\n+use rustc::ty::{self, TyCtxt};\n use rustc::ty::layout::{self, LayoutOf, VariantIdx};\n use rustc::ty::subst::Subst;\n use rustc::traits::Reveal;\n@@ -23,7 +23,7 @@ use crate::interpret::{self,\n     PlaceTy, MPlaceTy, OpTy, ImmTy, Immediate, Scalar,\n     RawConst, ConstValue,\n     InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpCx, StackPopCleanup,\n-    Allocation, AllocId, MemoryKind, Memory,\n+    Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking, intern_const_alloc_recursive,\n };\n \n@@ -316,6 +316,7 @@ impl interpret::MayLeak for ! {\n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n     type MemoryKinds = !;\n     type PointerTag = ();\n+    type ExtraFnVal = !;\n \n     type FrameExtra = ();\n     type MemoryExtra = ();\n@@ -370,6 +371,16 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }))\n     }\n \n+    fn call_extra_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        fn_val: !,\n+        _args: &[OpTy<'tcx>],\n+        _dest: Option<PlaceTy<'tcx>>,\n+        _ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        match fn_val {}\n+    }\n+\n     fn call_intrinsic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n@@ -398,27 +409,27 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn find_foreign_static(\n+        _tcx: TyCtxt<'tcx>,\n         _def_id: DefId,\n-        _tcx: TyCtxtAt<'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n         err!(ReadForeignStatic)\n     }\n \n     #[inline(always)]\n     fn tag_allocation<'b>(\n+        _memory_extra: &(),\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<!>>,\n-        _memory: &Memory<'mir, 'tcx, Self>,\n     ) -> (Cow<'b, Allocation<Self::PointerTag>>, Self::PointerTag) {\n         // We do not use a tag so we can just cheaply forward the allocation\n         (alloc, ())\n     }\n \n     #[inline(always)]\n     fn tag_static_base_pointer(\n+        _memory_extra: &(),\n         _id: AllocId,\n-        _memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag {\n         ()\n     }"}, {"sha": "3ef525979f8c9ecce2f61480797957cc8557d081", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n use rustc::mir::CastKind;\n \n-use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate};\n+use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate, FnVal};\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n@@ -86,7 +86,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             def_id,\n                             substs,\n                         ).ok_or_else(|| InterpError::TooGeneric.into());\n-                        let fn_ptr = self.memory.create_fn_alloc(instance?);\n+                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance?));\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n                     _ => bug!(\"reify fn pointer on {:?}\", src.layout.ty),\n@@ -115,7 +115,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             substs,\n                             ty::ClosureKind::FnOnce,\n                         );\n-                        let fn_ptr = self.memory.create_fn_alloc(instance);\n+                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                         let val = Immediate::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n                         self.write_immediate(val, dest)?;\n                     }"}, {"sha": "007ec8cb2db5c50ff070f73bc21511bd2bdf4d8a", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -222,6 +222,23 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &mut self.memory\n     }\n \n+    #[inline(always)]\n+    pub fn force_ptr(\n+        &self,\n+        scalar: Scalar<M::PointerTag>,\n+    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n+        self.memory.force_ptr(scalar)\n+    }\n+\n+    #[inline(always)]\n+    pub fn force_bits(\n+        &self,\n+        scalar: Scalar<M::PointerTag>,\n+        size: Size\n+    ) -> InterpResult<'tcx, u128> {\n+        self.memory.force_bits(scalar, size)\n+    }\n+\n     #[inline(always)]\n     pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n         self.memory.tag_static_base_pointer(ptr)\n@@ -253,6 +270,27 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         self.frame().body\n     }\n \n+    #[inline(always)]\n+    pub fn sign_extend(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n+        assert!(ty.abi.is_signed());\n+        sign_extend(value, ty.size)\n+    }\n+\n+    #[inline(always)]\n+    pub fn truncate(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n+        truncate(value, ty.size)\n+    }\n+\n+    #[inline]\n+    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_sized(self.tcx, self.param_env)\n+    }\n+\n+    #[inline]\n+    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n+        ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n+    }\n+\n     pub(super) fn subst_and_normalize_erasing_regions<T: TypeFoldable<'tcx>>(\n         &self,\n         substs: T,\n@@ -288,14 +326,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ).ok_or_else(|| InterpError::TooGeneric.into())\n     }\n \n-    pub fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_sized(self.tcx, self.param_env)\n-    }\n-\n-    pub fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        ty.is_freeze(*self.tcx, self.param_env, DUMMY_SP)\n-    }\n-\n     pub fn load_mir(\n         &self,\n         instance: ty::InstanceDef<'tcx>,\n@@ -766,32 +796,4 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         trace!(\"generate stacktrace: {:#?}, {:?}\", frames, explicit_span);\n         frames\n     }\n-\n-    #[inline(always)]\n-    pub fn sign_extend(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n-        assert!(ty.abi.is_signed());\n-        sign_extend(value, ty.size)\n-    }\n-\n-    #[inline(always)]\n-    pub fn truncate(&self, value: u128, ty: TyLayout<'_>) -> u128 {\n-        truncate(value, ty.size)\n-    }\n-\n-    #[inline(always)]\n-    pub fn force_ptr(\n-        &self,\n-        scalar: Scalar<M::PointerTag>,\n-    ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        self.memory.force_ptr(scalar)\n-    }\n-\n-    #[inline(always)]\n-    pub fn force_bits(\n-        &self,\n-        scalar: Scalar<M::PointerTag>,\n-        size: Size\n-    ) -> InterpResult<'tcx, u128> {\n-        self.memory.force_bits(scalar, size)\n-    }\n }"}, {"sha": "f37c474fa4fff23a20c02a7302775227a8a18697", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -7,11 +7,11 @@ use std::hash::Hash;\n \n use rustc::hir::def_id::DefId;\n use rustc::mir;\n-use rustc::ty::{self, query::TyCtxtAt};\n+use rustc::ty::{self, TyCtxt};\n \n use super::{\n-    Allocation, AllocId, InterpResult, Scalar, AllocationExtra,\n-    InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory\n+    Allocation, AllocId, InterpResult, InterpError, Scalar, AllocationExtra,\n+    InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -67,6 +67,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// The `default()` is used for pointers to consts, statics, vtables and functions.\n     type PointerTag: ::std::fmt::Debug + Copy + Eq + Hash + 'static;\n \n+    /// Machines can define extra (non-instance) things that represent values of function pointers.\n+    /// For example, Miri uses this to return a fucntion pointer from `dlsym`\n+    /// that can later be called to execute the right thing.\n+    type ExtraFnVal: ::std::fmt::Debug + Copy;\n+\n     /// Extra data stored in every call frame.\n     type FrameExtra;\n \n@@ -119,6 +124,16 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n+    /// Execute `fn_val`.  it is the hook's responsibility to advance the instruction\n+    /// pointer as appropriate.\n+    fn call_extra_fn(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        fn_val: Self::ExtraFnVal,\n+        args: &[OpTy<'tcx, Self::PointerTag>],\n+        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx>;\n+\n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic(\n@@ -136,8 +151,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ///\n     /// This allocation will then be fed to `tag_allocation` to initialize the \"extra\" state.\n     fn find_foreign_static(\n+        tcx: TyCtxt<'tcx>,\n         def_id: DefId,\n-        tcx: TyCtxtAt<'tcx>,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation>>;\n \n     /// Called for all binary operations on integer(-like) types when one operand is a pointer\n@@ -174,10 +189,10 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// For static allocations, the tag returned must be the same as the one returned by\n     /// `tag_static_base_pointer`.\n     fn tag_allocation<'b>(\n+        memory_extra: &Self::MemoryExtra,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKinds>>,\n-        memory: &Memory<'mir, 'tcx, Self>,\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag);\n \n     /// Return the \"base\" tag for the given static allocation: the one that is used for direct\n@@ -186,8 +201,8 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Be aware that requesting the `Allocation` for that `id` will lead to cycles\n     /// for cyclic statics!\n     fn tag_static_base_pointer(\n+        memory_extra: &Self::MemoryExtra,\n         id: AllocId,\n-        memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag;\n \n     /// Executes a retagging operation\n@@ -209,20 +224,22 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         extra: Self::FrameExtra,\n     ) -> InterpResult<'tcx>;\n \n+    #[inline(always)]\n     fn int_to_ptr(\n-        int: u64,\n         _mem: &Memory<'mir, 'tcx, Self>,\n+        int: u64,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n-        if int == 0 {\n-            err!(InvalidNullPointerUsage)\n+        Err((if int == 0 {\n+            InterpError::InvalidNullPointerUsage\n         } else {\n-            err!(ReadBytesAsPointer)\n-        }\n+            InterpError::ReadBytesAsPointer\n+        }).into())\n     }\n \n+    #[inline(always)]\n     fn ptr_to_int(\n-        _ptr: Pointer<Self::PointerTag>,\n         _mem: &Memory<'mir, 'tcx, Self>,\n+        _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n         err!(ReadPointerAsBytes)\n     }"}, {"sha": "33cd7330069e394ebd2801ed18b2c54f4ab594f2", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 105, "deletions": 47, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -54,6 +54,26 @@ pub enum AllocCheck {\n     MaybeDead,\n }\n \n+/// The value of a function pointer.\n+#[derive(Debug, Copy, Clone)]\n+pub enum FnVal<'tcx, Other> {\n+    Instance(Instance<'tcx>),\n+    Other(Other),\n+}\n+\n+impl<'tcx, Other> FnVal<'tcx, Other> {\n+    pub fn as_instance(self) -> InterpResult<'tcx, Instance<'tcx>> {\n+        match self {\n+            FnVal::Instance(instance) =>\n+                Ok(instance),\n+            FnVal::Other(_) =>\n+                err!(MachineError(\n+                    format!(\"Expected instance function pointer, got 'other' pointer\")\n+                )),\n+        }\n+    }\n+}\n+\n // `Memory` has to depend on the `Machine` because some of its operations\n // (e.g., `get`) call a `Machine` hook.\n pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -69,16 +89,20 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     // FIXME: this should not be public, but interning currently needs access to it\n     pub(super) alloc_map: M::MemoryMap,\n \n+    /// Map for \"extra\" function pointers.\n+    extra_fn_ptr_map: FxHashMap<AllocId, M::ExtraFnVal>,\n+\n     /// To be able to compare pointers with NULL, and to check alignment for accesses\n     /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n     /// that do not exist any more.\n+    // FIXME: this should not be public, but interning currently needs access to it\n     pub(super) dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n \n     /// Extra data added by the machine.\n     pub extra: M::MemoryExtra,\n \n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub(super) tcx: TyCtxtAt<'tcx>,\n+    pub tcx: TyCtxtAt<'tcx>,\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n@@ -98,6 +122,7 @@ where\n     fn clone(&self) -> Self {\n         Memory {\n             alloc_map: self.alloc_map.clone(),\n+            extra_fn_ptr_map: self.extra_fn_ptr_map.clone(),\n             dead_alloc_map: self.dead_alloc_map.clone(),\n             extra: (),\n             tcx: self.tcx,\n@@ -109,6 +134,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'tcx>, extra: M::MemoryExtra) -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n+            extra_fn_ptr_map: FxHashMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n             extra,\n             tcx,\n@@ -117,11 +143,24 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     #[inline]\n     pub fn tag_static_base_pointer(&self, ptr: Pointer) -> Pointer<M::PointerTag> {\n-        ptr.with_tag(M::tag_static_base_pointer(ptr.alloc_id, &self))\n+        ptr.with_tag(M::tag_static_base_pointer(&self.extra, ptr.alloc_id))\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer<M::PointerTag> {\n-        let id = self.tcx.alloc_map.lock().create_fn_alloc(instance);\n+    pub fn create_fn_alloc(\n+        &mut self,\n+        fn_val: FnVal<'tcx, M::ExtraFnVal>,\n+    ) -> Pointer<M::PointerTag>\n+    {\n+        let id = match fn_val {\n+            FnVal::Instance(instance) => self.tcx.alloc_map.lock().create_fn_alloc(instance),\n+            FnVal::Other(extra) => {\n+                // FIXME(RalfJung): Should we have a cache here?\n+                let id = self.tcx.alloc_map.lock().reserve();\n+                let old = self.extra_fn_ptr_map.insert(id, extra);\n+                assert!(old.is_none());\n+                id\n+            }\n+        };\n         self.tag_static_base_pointer(Pointer::from(id))\n     }\n \n@@ -150,7 +189,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> Pointer<M::PointerTag> {\n         let id = self.tcx.alloc_map.lock().reserve();\n-        let (alloc, tag) = M::tag_allocation(id, Cow::Owned(alloc), Some(kind), &self);\n+        let (alloc, tag) = M::tag_allocation(&self.extra, id, Cow::Owned(alloc), Some(kind));\n         self.alloc_map.insert(id, (kind, alloc.into_owned()));\n         Pointer::from(id).with_tag(tag)\n     }\n@@ -368,9 +407,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// contains a reference to memory that was created during its evaluation (i.e., not to\n     /// another static), those inner references only exist in \"resolved\" form.\n     fn get_static_alloc(\n-        id: AllocId,\n+        memory_extra: &M::MemoryExtra,\n         tcx: TyCtxtAt<'tcx>,\n-        memory: &Memory<'mir, 'tcx, M>,\n+        id: AllocId,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<M::PointerTag, M::AllocExtra>>> {\n         let alloc = tcx.alloc_map.lock().get(id);\n         let alloc = match alloc {\n@@ -384,7 +423,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n                     trace!(\"static_alloc: foreign item {:?}\", def_id);\n-                    M::find_foreign_static(def_id, tcx)?\n+                    M::find_foreign_static(tcx.tcx, def_id)?\n                 } else {\n                     trace!(\"static_alloc: Need to compute {:?}\", def_id);\n                     let instance = Instance::mono(tcx.tcx, def_id);\n@@ -414,10 +453,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // We got tcx memory. Let the machine figure out whether and how to\n         // turn that into memory with the right pointer tag.\n         Ok(M::tag_allocation(\n+            memory_extra,\n             id, // always use the ID we got as input, not the \"hidden\" one.\n             alloc,\n             M::STATIC_KIND.map(MemoryKind::Machine),\n-            memory\n         ).0)\n     }\n \n@@ -430,7 +469,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // `get_static_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n         let a = self.alloc_map.get_or(id, || {\n-            let alloc = Self::get_static_alloc(id, self.tcx, &self).map_err(Err)?;\n+            let alloc = Self::get_static_alloc(&self.extra, self.tcx, id).map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n                     // We got a ref, cheaply return that as an \"error\" so that the\n@@ -459,11 +498,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n     ) -> InterpResult<'tcx, &mut Allocation<M::PointerTag, M::AllocExtra>> {\n         let tcx = self.tcx;\n-        let alloc = Self::get_static_alloc(id, tcx, &self);\n+        let memory_extra = &self.extra;\n         let a = self.alloc_map.get_mut_or(id, || {\n             // Need to make a copy, even if `get_static_alloc` is able\n             // to give us a cheap reference.\n-            let alloc = alloc?;\n+            let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Immutable {\n                 return err!(ModifiedConstantMemory);\n             }\n@@ -495,56 +534,65 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n+        // Regular allocations.\n         if let Ok(alloc) = self.get(id) {\n             return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n         }\n-        // can't do this in the match argument, we may get cycle errors since the lock would get\n-        // dropped after the match.\n+        // Function pointers.\n+        if let Ok(_) = self.get_fn_alloc(id) {\n+            return if let AllocCheck::Dereferencable = liveness {\n+                // The caller requested no function pointers.\n+                err!(DerefFunctionPointer)\n+            } else {\n+                Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n+            };\n+        }\n+        // Foreign statics.\n+        // Can't do this in the match argument, we may get cycle errors since the lock would\n+        // be held throughout the match.\n         let alloc = self.tcx.alloc_map.lock().get(id);\n-        // Could also be a fn ptr or extern static\n         match alloc {\n-            Some(GlobalAlloc::Function(..)) => {\n-                if let AllocCheck::Dereferencable = liveness {\n-                    // The caller requested no function pointers.\n-                    err!(DerefFunctionPointer)\n-                } else {\n-                    Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n-                }\n-            }\n-            // `self.get` would also work, but can cause cycles if a static refers to itself\n             Some(GlobalAlloc::Static(did)) => {\n-                // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n                 // Use size and align of the type\n                 let ty = self.tcx.type_of(did);\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                Ok((layout.size, layout.align.abi))\n+                return Ok((layout.size, layout.align.abi));\n             }\n-            _ => {\n-                if let Ok(alloc) = self.get(id) {\n-                    Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align))\n-                }\n-                else if let AllocCheck::MaybeDead = liveness {\n-                    // Deallocated pointers are allowed, we should be able to find\n-                    // them in the map.\n-                    Ok(*self.dead_alloc_map.get(&id)\n-                        .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n-                } else {\n-                    err!(DanglingPointerDeref)\n-                }\n-            },\n+            _ => {}\n+        }\n+        // The rest must be dead.\n+        if let AllocCheck::MaybeDead = liveness {\n+            // Deallocated pointers are allowed, we should be able to find\n+            // them in the map.\n+            Ok(*self.dead_alloc_map.get(&id)\n+                .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n+        } else {\n+            err!(DanglingPointerDeref)\n         }\n     }\n \n-    pub fn get_fn(&self, ptr: Pointer<M::PointerTag>) -> InterpResult<'tcx, Instance<'tcx>> {\n+    fn get_fn_alloc(&self, id: AllocId) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n+        trace!(\"reading fn ptr: {}\", id);\n+        if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n+            Ok(FnVal::Other(*extra))\n+        } else {\n+            match self.tcx.alloc_map.lock().get(id) {\n+                Some(GlobalAlloc::Function(instance)) => Ok(FnVal::Instance(instance)),\n+                _ => Err(InterpError::ExecuteMemory.into()),\n+            }\n+        }\n+    }\n+\n+    pub fn get_fn(\n+        &self,\n+        ptr: Scalar<M::PointerTag>,\n+    ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n+        let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n         if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n-        trace!(\"reading fn ptr: {}\", ptr.alloc_id);\n-        match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-            Some(GlobalAlloc::Function(instance)) => Ok(instance),\n-            _ => Err(InterpError::ExecuteMemory.into()),\n-        }\n+        self.get_fn_alloc(ptr.alloc_id)\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n@@ -680,6 +728,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n /// Reading and writing.\n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+    /// Reads the given number of bytes from memory. Returns them as a slice.\n+    ///\n     /// Performs appropriate bounds checks.\n     pub fn read_bytes(\n         &self,\n@@ -693,6 +743,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.get(ptr.alloc_id)?.get_bytes(self, ptr, size)\n     }\n \n+    /// Reads a 0-terminated sequence of bytes from memory. Returns them as a slice.\n+    ///\n+    /// Performs appropriate bounds checks.\n+    pub fn read_c_str(&self, ptr: Scalar<M::PointerTag>) -> InterpResult<'tcx, &[u8]> {\n+        let ptr = self.force_ptr(ptr)?; // We need to read at least 1 byte, so we *need* a ptr.\n+        self.get(ptr.alloc_id)?.read_c_str(self, ptr)\n+    }\n+\n     /// Performs appropriate bounds checks.\n     pub fn copy(\n         &mut self,\n@@ -890,7 +948,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         match scalar {\n             Scalar::Ptr(ptr) => Ok(ptr),\n-            _ => M::int_to_ptr(scalar.to_usize(self)?, self)\n+            _ => M::int_to_ptr(&self, scalar.to_usize(self)?)\n         }\n     }\n \n@@ -901,7 +959,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, u128> {\n         match scalar.to_bits_or_ptr(size, self) {\n             Ok(bits) => Ok(bits),\n-            Err(ptr) => Ok(M::ptr_to_int(ptr, self)? as u128)\n+            Err(ptr) => Ok(M::ptr_to_int(&self, ptr)? as u128)\n         }\n     }\n }"}, {"sha": "45d24347e4efd45618c3a5ff2eb41b80beefc01c", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -24,7 +24,7 @@ pub use self::eval_context::{\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n-pub use self::memory::{Memory, MemoryKind, AllocCheck};\n+pub use self::memory::{Memory, MemoryKind, AllocCheck, FnVal};\n \n pub use self::machine::{Machine, AllocMap, MayLeak};\n "}, {"sha": "0ab428628de688d12ee78c08ee383225453ad839", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -6,9 +6,9 @@ use rustc::ty::layout::{self, TyLayout, LayoutOf};\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{InterpResult, PointerArithmetic, InterpError, Scalar};\n use super::{\n-    InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n+    InterpResult, PointerArithmetic, InterpError, Scalar,\n+    InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -76,16 +76,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n \n                 let func = self.eval_operand(func, None)?;\n-                let (fn_def, abi) = match func.layout.ty.sty {\n+                let (fn_val, abi) = match func.layout.ty.sty {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n-                        let fn_ptr = self.force_ptr(self.read_scalar(func)?.not_undef()?)?;\n-                        let instance = self.memory.get_fn(fn_ptr)?;\n-                        (instance, caller_abi)\n+                        let fn_ptr = self.read_scalar(func)?.not_undef()?;\n+                        let fn_val = self.memory.get_fn(fn_ptr)?;\n+                        (fn_val, caller_abi)\n                     }\n                     ty::FnDef(def_id, substs) => {\n                         let sig = func.layout.ty.fn_sig(*self.tcx);\n-                        (self.resolve(def_id, substs)?, sig.abi())\n+                        (FnVal::Instance(self.resolve(def_id, substs)?), sig.abi())\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n@@ -94,7 +94,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let args = self.eval_operands(args)?;\n                 self.eval_fn_call(\n-                    fn_def,\n+                    fn_val,\n                     terminator.source_info.span,\n                     abi,\n                     &args[..],\n@@ -228,14 +228,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Call this function -- pushing the stack frame and initializing the arguments.\n     fn eval_fn_call(\n         &mut self,\n-        instance: ty::Instance<'tcx>,\n+        fn_val: FnVal<'tcx, M::ExtraFnVal>,\n         span: Span,\n         caller_abi: Abi,\n         args: &[OpTy<'tcx, M::PointerTag>],\n         dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"eval_fn_call: {:#?}\", instance);\n+        trace!(\"eval_fn_call: {:#?}\", fn_val);\n+\n+        let instance = match fn_val {\n+            FnVal::Instance(instance) => instance,\n+            FnVal::Other(extra) => {\n+                return M::call_extra_fn(self, extra, args, dest, ret);\n+            }\n+        };\n \n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n@@ -431,8 +438,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.tcx.data_layout.pointer_align.abi,\n                 )?.expect(\"cannot be a ZST\");\n                 let fn_ptr = self.memory.get(vtable_slot.alloc_id)?\n-                    .read_ptr_sized(self, vtable_slot)?.to_ptr()?;\n-                let instance = self.memory.get_fn(fn_ptr)?;\n+                    .read_ptr_sized(self, vtable_slot)?.not_undef()?;\n+                let drop_fn = self.memory.get_fn(fn_ptr)?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want\n@@ -447,7 +454,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(instance, span, caller_abi, &args, dest, ret)\n+                self.eval_fn_call(drop_fn, span, caller_abi, &args, dest, ret)\n             }\n         }\n     }\n@@ -482,7 +489,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let dest = MPlaceTy::dangling(self.layout_of(ty)?, self);\n \n         self.eval_fn_call(\n-            instance,\n+            FnVal::Instance(instance),\n             span,\n             Abi::Rust,\n             &[arg.into()],"}, {"sha": "e7363f6876c28ce7abeb9a2370d4eeb60fb685e0", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -2,7 +2,7 @@ use rustc::ty::{self, Ty, Instance};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic};\n \n-use super::{InterpCx, InterpError, Machine, MemoryKind};\n+use super::{InterpCx, InterpError, Machine, MemoryKind, FnVal};\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -56,7 +56,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tcx = &*self.tcx;\n \n         let drop = Instance::resolve_drop_in_place(*tcx, ty);\n-        let drop = self.memory.create_fn_alloc(drop);\n+        let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n         // no need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n@@ -84,7 +84,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     def_id,\n                     substs,\n                 ).ok_or_else(|| InterpError::TooGeneric)?;\n-                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n                 self.memory\n                     .get_mut(method_ptr.alloc_id)?\n@@ -112,8 +112,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let drop_fn = self.memory\n             .get(vtable.alloc_id)?\n             .read_ptr_sized(self, vtable)?\n-            .to_ptr()?;\n-        let drop_instance = self.memory.get_fn(drop_fn)?;\n+            .not_undef()?;\n+        // We *need* an instance here, no other kind of function value, to be able\n+        // to determine the type.\n+        let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);"}, {"sha": "34892f5b8ca01bda2f702e94523609fdf6e423f5", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -6,13 +6,11 @@ use rustc::hir;\n use rustc::ty::layout::{self, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc::mir::interpret::{\n-    GlobalAlloc, InterpResult, InterpError,\n-};\n \n use std::hash::Hash;\n \n use super::{\n+    GlobalAlloc, InterpResult, InterpError,\n     OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n };\n \n@@ -153,15 +151,16 @@ fn wrapping_range_format(r: &RangeInclusive<u128>, max_hi: u128) -> String {\n     debug_assert!(hi <= max_hi);\n     if lo > hi {\n         format!(\"less or equal to {}, or greater or equal to {}\", hi, lo)\n+    } else if lo == hi {\n+        format!(\"equal to {}\", lo)\n+    } else if lo == 0 {\n+        debug_assert!(hi < max_hi, \"should not be printing if the range covers everything\");\n+        format!(\"less or equal to {}\", hi)\n+    } else if hi == max_hi {\n+        debug_assert!(lo > 0, \"should not be printing if the range covers everything\");\n+        format!(\"greater or equal to {}\", lo)\n     } else {\n-        if lo == 0 {\n-            debug_assert!(hi < max_hi, \"should not be printing if the range covers everything\");\n-            format!(\"less or equal to {}\", hi)\n-        } else if hi == max_hi {\n-            format!(\"greater or equal to {}\", lo)\n-        } else {\n-            format!(\"in the range {:?}\", r)\n-        }\n+        format!(\"in the range {:?}\", r)\n     }\n }\n \n@@ -457,10 +456,10 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             }\n             ty::FnPtr(_sig) => {\n                 let value = value.to_scalar_or_undef();\n-                let ptr = try_validation!(value.to_ptr(),\n-                    value, self.path, \"a pointer\");\n-                let _fn = try_validation!(self.ecx.memory.get_fn(ptr),\n-                    value, self.path, \"a function pointer\");\n+                let _fn = try_validation!(\n+                    value.not_undef().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n+                    value, self.path, \"a function pointer\"\n+                );\n                 // FIXME: Check if the signature matches\n             }\n             // This should be all the primitive types\n@@ -504,20 +503,18 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 if lo == 1 && hi == max_hi {\n                     // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n-                        // These conditions are just here to improve the diagnostics so we can\n-                        // differentiate between null pointers and dangling pointers\n-                        if self.ref_tracking_for_consts.is_some() &&\n-                            self.ecx.memory.get(ptr.alloc_id).is_err() &&\n-                            self.ecx.memory.get_fn(ptr).is_err() {\n-                            return validation_failure!(\n-                                \"encountered dangling pointer\", self.path\n-                            );\n-                        }\n-                        return validation_failure!(\"a potentially NULL pointer\", self.path);\n+                        return validation_failure!(\n+                            \"a potentially NULL pointer\",\n+                            self.path,\n+                            format!(\n+                                \"something that cannot possibly fail to be {}\",\n+                                wrapping_range_format(&layout.valid_range, max_hi)\n+                            )\n+                        );\n                     }\n                     return Ok(());\n                 } else {\n-                    // Conservatively, we reject, because the pointer *could* have this\n+                    // Conservatively, we reject, because the pointer *could* have a bad\n                     // value.\n                     return validation_failure!(\n                         \"a pointer\","}, {"sha": "fb9919d777db17da75d88f1f78eb2a3806291840", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -53,7 +53,7 @@ impl<'a> SpanUtils<'a> {\n     pub fn sub_span_of_token(&self, span: Span, tok: TokenKind) -> Option<Span> {\n         let mut toks = self.retokenise_span(span);\n         loop {\n-            let next = toks.real_token();\n+            let next = toks.next_token();\n             if next == token::Eof {\n                 return None;\n             }"}, {"sha": "8132074d6e0e7dd1fc307d6e61b929ec1a2de66e", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 31, "deletions": 20, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -38,17 +38,17 @@ pub fn render_with_highlighting(\n         FileName::Custom(String::from(\"rustdoc-highlighting\")),\n         src.to_owned(),\n     );\n-    let highlight_result =\n-        lexer::StringReader::new_or_buffered_errs(&sess, fm, None).and_then(|lexer| {\n-            let mut classifier = Classifier::new(lexer, sess.source_map());\n-\n-            let mut highlighted_source = vec![];\n-            if classifier.write_source(&mut highlighted_source).is_err() {\n-                Err(classifier.lexer.buffer_fatal_errors())\n-            } else {\n-                Ok(String::from_utf8_lossy(&highlighted_source).into_owned())\n-            }\n-        });\n+    let highlight_result = {\n+        let lexer = lexer::StringReader::new(&sess, fm, None);\n+        let mut classifier = Classifier::new(lexer, sess.source_map());\n+\n+        let mut highlighted_source = vec![];\n+        if classifier.write_source(&mut highlighted_source).is_err() {\n+            Err(classifier.lexer.buffer_fatal_errors())\n+        } else {\n+            Ok(String::from_utf8_lossy(&highlighted_source).into_owned())\n+        }\n+    };\n \n     match highlight_result {\n         Ok(highlighted_source) => {\n@@ -79,6 +79,7 @@ pub fn render_with_highlighting(\n /// each span of text in sequence.\n struct Classifier<'a> {\n     lexer: lexer::StringReader<'a>,\n+    peek_token: Option<Token>,\n     source_map: &'a SourceMap,\n \n     // State of the classifier.\n@@ -178,6 +179,7 @@ impl<'a> Classifier<'a> {\n     fn new(lexer: lexer::StringReader<'a>, source_map: &'a SourceMap) -> Classifier<'a> {\n         Classifier {\n             lexer,\n+            peek_token: None,\n             source_map,\n             in_attribute: false,\n             in_macro: false,\n@@ -187,10 +189,19 @@ impl<'a> Classifier<'a> {\n \n     /// Gets the next token out of the lexer.\n     fn try_next_token(&mut self) -> Result<Token, HighlightError> {\n-        match self.lexer.try_next_token() {\n-            Ok(token) => Ok(token),\n-            Err(_) => Err(HighlightError::LexError),\n+        if let Some(token) = self.peek_token.take() {\n+            return Ok(token);\n+        }\n+        self.lexer.try_next_token().map_err(|()| HighlightError::LexError)\n+    }\n+\n+    fn peek(&mut self) -> Result<&Token, HighlightError> {\n+        if self.peek_token.is_none() {\n+            self.peek_token = Some(\n+                self.lexer.try_next_token().map_err(|()| HighlightError::LexError)?\n+            );\n         }\n+        Ok(self.peek_token.as_ref().unwrap())\n     }\n \n     /// Exhausts the `lexer` writing the output into `out`.\n@@ -234,7 +245,7 @@ impl<'a> Classifier<'a> {\n             // reference or dereference operator or a reference or pointer type, instead of the\n             // bit-and or multiplication operator.\n             token::BinOp(token::And) | token::BinOp(token::Star)\n-                if self.lexer.peek() != &token::Whitespace => Class::RefKeyWord,\n+                if self.peek()? != &token::Whitespace => Class::RefKeyWord,\n \n             // Consider this as part of a macro invocation if there was a\n             // leading identifier.\n@@ -257,7 +268,7 @@ impl<'a> Classifier<'a> {\n             token::Question => Class::QuestionMark,\n \n             token::Dollar => {\n-                if self.lexer.peek().is_ident() {\n+                if self.peek()?.is_ident() {\n                     self.in_macro_nonterminal = true;\n                     Class::MacroNonTerminal\n                 } else {\n@@ -280,9 +291,9 @@ impl<'a> Classifier<'a> {\n                 // as an attribute.\n \n                 // Case 1: #![inner_attribute]\n-                if self.lexer.peek() == &token::Not {\n+                if self.peek()? == &token::Not {\n                     self.try_next_token()?; // NOTE: consumes `!` token!\n-                    if self.lexer.peek() == &token::OpenDelim(token::Bracket) {\n+                    if self.peek()? == &token::OpenDelim(token::Bracket) {\n                         self.in_attribute = true;\n                         out.enter_span(Class::Attribute)?;\n                     }\n@@ -292,7 +303,7 @@ impl<'a> Classifier<'a> {\n                 }\n \n                 // Case 2: #[outer_attribute]\n-                if self.lexer.peek() == &token::OpenDelim(token::Bracket) {\n+                if self.peek()? == &token::OpenDelim(token::Bracket) {\n                     self.in_attribute = true;\n                     out.enter_span(Class::Attribute)?;\n                 }\n@@ -341,7 +352,7 @@ impl<'a> Classifier<'a> {\n                         if self.in_macro_nonterminal {\n                             self.in_macro_nonterminal = false;\n                             Class::MacroNonTerminal\n-                        } else if self.lexer.peek() == &token::Not {\n+                        } else if self.peek()? == &token::Not {\n                             self.in_macro = true;\n                             Class::Macro\n                         } else {"}, {"sha": "0488153e7cb732e418d7a0ee36dab956d26c3a5c", "filename": "src/librustdoc/passes/check_code_block_syntax.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_code_block_syntax.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -32,7 +32,8 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             dox[code_block.code].to_owned(),\n         );\n \n-        let errors = Lexer::new_or_buffered_errs(&sess, source_file, None).and_then(|mut lexer| {\n+        let errors = {\n+            let mut lexer = Lexer::new(&sess, source_file, None);\n             while let Ok(token::Token { kind, .. }) = lexer.try_next_token() {\n                 if kind == token::Eof {\n                     break;\n@@ -46,7 +47,7 @@ impl<'a, 'tcx> SyntaxChecker<'a, 'tcx> {\n             } else {\n                 Ok(())\n             }\n-        });\n+        };\n \n         if let Err(errors) = errors {\n             let mut diag = if let Some(sp) ="}, {"sha": "2c2dd3b77eae9791d31a7b3cb2c5ed6a9d95a3d9", "filename": "src/libstd/sys/unix/alloc.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibstd%2Fsys%2Funix%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Falloc.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -6,6 +6,10 @@ use crate::alloc::{GlobalAlloc, Layout, System};\n unsafe impl GlobalAlloc for System {\n     #[inline]\n     unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        // jemalloc provides alignment less than MIN_ALIGN for small allocations.\n+        // So only rely on MIN_ALIGN if size >= align.\n+        // Also see <https://github.com/rust-lang/rust/issues/45955> and\n+        // <https://github.com/rust-lang/rust/issues/62251#issuecomment-507580914>.\n         if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n             libc::malloc(layout.size()) as *mut u8\n         } else {\n@@ -21,6 +25,7 @@ unsafe impl GlobalAlloc for System {\n \n     #[inline]\n     unsafe fn alloc_zeroed(&self, layout: Layout) -> *mut u8 {\n+        // See the comment above in `alloc` for why this check looks the way it does.\n         if layout.align() <= MIN_ALIGN && layout.align() <= layout.size() {\n             libc::calloc(layout.size(), 1) as *mut u8\n         } else {\n@@ -80,7 +85,10 @@ unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n #[inline]\n unsafe fn aligned_malloc(layout: &Layout) -> *mut u8 {\n     let mut out = ptr::null_mut();\n-    let ret = libc::posix_memalign(&mut out, layout.align(), layout.size());\n+    // posix_memalign requires that the alignment be a multiple of `sizeof(void*)`.\n+    // Since these are all powers of 2, we can just use max.\n+    let align = layout.align().max(crate::mem::size_of::<usize>());\n+    let ret = libc::posix_memalign(&mut out, align, layout.size());\n     if ret != 0 {\n         ptr::null_mut()\n     } else {"}, {"sha": "988f1aa38d926e814e9df631d7b4b1f118cb3e6a", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -268,7 +268,7 @@ fn read_block_comment(rdr: &mut StringReader<'_>,\n         while level > 0 {\n             debug!(\"=== block comment level {}\", level);\n             if rdr.is_eof() {\n-                rdr.fatal(\"unterminated block comment\").raise();\n+                rdr.fatal_span_(rdr.pos, rdr.pos, \"unterminated block comment\").raise();\n             }\n             if rdr.ch_is('\\n') {\n                 trim_whitespace_prefix_and_push_line(&mut lines, curr_line, col);\n@@ -346,7 +346,7 @@ pub fn gather_comments(sess: &ParseSess, path: FileName, srdr: &mut dyn Read) ->\n     srdr.read_to_string(&mut src).unwrap();\n     let cm = SourceMap::new(sess.source_map().path_mapping().clone());\n     let source_file = cm.new_source_file(path, src);\n-    let mut rdr = lexer::StringReader::new_raw(sess, source_file, None);\n+    let mut rdr = lexer::StringReader::new(sess, source_file, None);\n \n     let mut comments: Vec<Comment> = Vec::new();\n     let mut code_to_the_left = false; // Only code"}, {"sha": "1abbf0ff1eeb7798e24a36e30e6e0a9eb7daea74", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 74, "deletions": 144, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -38,9 +38,6 @@ pub struct StringReader<'a> {\n     crate source_file: Lrc<syntax_pos::SourceFile>,\n     /// Stop reading src at this index.\n     crate end_src_index: usize,\n-    // cached:\n-    peek_token: Token,\n-    peek_span_src_raw: Span,\n     fatal_errs: Vec<DiagnosticBuilder<'a>>,\n     // cache a direct reference to the source text, so that we don't have to\n     // retrieve it via `self.source_file.src.as_ref().unwrap()` all the time.\n@@ -49,15 +46,59 @@ pub struct StringReader<'a> {\n }\n \n impl<'a> StringReader<'a> {\n-    fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n-        self.mk_sp_and_raw(lo, hi).0\n+    pub fn new(sess: &'a ParseSess,\n+               source_file: Lrc<syntax_pos::SourceFile>,\n+               override_span: Option<Span>) -> Self {\n+        let mut sr = StringReader::new_internal(sess, source_file, override_span);\n+        sr.bump();\n+        sr\n+    }\n+\n+    pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n+        let begin = sess.source_map().lookup_byte_offset(span.lo());\n+        let end = sess.source_map().lookup_byte_offset(span.hi());\n+\n+        // Make the range zero-length if the span is invalid.\n+        if span.lo() > span.hi() || begin.sf.start_pos != end.sf.start_pos {\n+            span = span.shrink_to_lo();\n+        }\n+\n+        let mut sr = StringReader::new_internal(sess, begin.sf, None);\n+\n+        // Seek the lexer to the right byte range.\n+        sr.next_pos = span.lo();\n+        sr.end_src_index = sr.src_index(span.hi());\n+\n+        sr.bump();\n+\n+        sr\n     }\n \n-    fn mk_sp_and_raw(&self, lo: BytePos, hi: BytePos) -> (Span, Span) {\n-        let raw = Span::new(lo, hi, NO_EXPANSION);\n-        let real = self.override_span.unwrap_or(raw);\n+    fn new_internal(sess: &'a ParseSess, source_file: Lrc<syntax_pos::SourceFile>,\n+        override_span: Option<Span>) -> Self\n+    {\n+        if source_file.src.is_none() {\n+            sess.span_diagnostic.bug(&format!(\"Cannot lex source_file without source: {}\",\n+                                              source_file.name));\n+        }\n+\n+        let src = (*source_file.src.as_ref().unwrap()).clone();\n+\n+        StringReader {\n+            sess,\n+            next_pos: source_file.start_pos,\n+            pos: source_file.start_pos,\n+            ch: Some('\\n'),\n+            source_file,\n+            end_src_index: src.len(),\n+            src,\n+            fatal_errs: Vec::new(),\n+            override_span,\n+        }\n+    }\n \n-        (real, raw)\n+    fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n+        self.override_span.unwrap_or_else(|| Span::new(lo, hi, NO_EXPANSION))\n     }\n \n     fn unwrap_or_abort(&mut self, res: Result<Token, ()>) -> Token {\n@@ -70,35 +111,32 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    fn next_token(&mut self) -> Token where Self: Sized {\n-        let res = self.try_next_token();\n-        self.unwrap_or_abort(res)\n-    }\n-\n-    /// Returns the next token. EFFECT: advances the string_reader.\n+    /// Returns the next token, including trivia like whitespace or comments.\n+    ///\n+    /// `Err(())` means that some errors were encountered, which can be\n+    /// retrieved using `buffer_fatal_errors`.\n     pub fn try_next_token(&mut self) -> Result<Token, ()> {\n         assert!(self.fatal_errs.is_empty());\n-        let ret_val = self.peek_token.take();\n-        self.advance_token()?;\n-        Ok(ret_val)\n-    }\n-\n-    fn try_real_token(&mut self) -> Result<Token, ()> {\n-        let mut t = self.try_next_token()?;\n-        loop {\n-            match t.kind {\n-                token::Whitespace | token::Comment | token::Shebang(_) => {\n-                    t = self.try_next_token()?;\n-                }\n-                _ => break,\n+        match self.scan_whitespace_or_comment() {\n+            Some(comment) => Ok(comment),\n+            None => {\n+                let (kind, start_pos, end_pos) = if self.is_eof() {\n+                    (token::Eof, self.source_file.end_pos, self.source_file.end_pos)\n+                } else {\n+                    let start_pos = self.pos;\n+                    (self.next_token_inner()?, start_pos, self.pos)\n+                };\n+                let span = self.mk_sp(start_pos, end_pos);\n+                Ok(Token::new(kind, span))\n             }\n         }\n-\n-        Ok(t)\n     }\n \n-    pub fn real_token(&mut self) -> Token {\n-        let res = self.try_real_token();\n+    /// Returns the next token, including trivia like whitespace or comments.\n+    ///\n+    /// Aborts in case of an error.\n+    pub fn next_token(&mut self) -> Token {\n+        let res = self.try_next_token();\n         self.unwrap_or_abort(res)\n     }\n \n@@ -120,10 +158,6 @@ impl<'a> StringReader<'a> {\n         FatalError.raise();\n     }\n \n-    fn fatal(&self, m: &str) -> FatalError {\n-        self.fatal_span(self.peek_token.span, m)\n-    }\n-\n     crate fn emit_fatal_errors(&mut self) {\n         for err in &mut self.fatal_errs {\n             err.emit();\n@@ -142,81 +176,6 @@ impl<'a> StringReader<'a> {\n         buffer\n     }\n \n-    pub fn peek(&self) -> &Token {\n-        &self.peek_token\n-    }\n-\n-    /// For comments.rs, which hackily pokes into next_pos and ch\n-    fn new_raw(sess: &'a ParseSess,\n-               source_file: Lrc<syntax_pos::SourceFile>,\n-               override_span: Option<Span>) -> Self {\n-        let mut sr = StringReader::new_raw_internal(sess, source_file, override_span);\n-        sr.bump();\n-\n-        sr\n-    }\n-\n-    fn new_raw_internal(sess: &'a ParseSess, source_file: Lrc<syntax_pos::SourceFile>,\n-        override_span: Option<Span>) -> Self\n-    {\n-        if source_file.src.is_none() {\n-            sess.span_diagnostic.bug(&format!(\"Cannot lex source_file without source: {}\",\n-                                              source_file.name));\n-        }\n-\n-        let src = (*source_file.src.as_ref().unwrap()).clone();\n-\n-        StringReader {\n-            sess,\n-            next_pos: source_file.start_pos,\n-            pos: source_file.start_pos,\n-            ch: Some('\\n'),\n-            source_file,\n-            end_src_index: src.len(),\n-            peek_token: Token::dummy(),\n-            peek_span_src_raw: syntax_pos::DUMMY_SP,\n-            src,\n-            fatal_errs: Vec::new(),\n-            override_span,\n-        }\n-    }\n-\n-    pub fn new_or_buffered_errs(sess: &'a ParseSess,\n-                                source_file: Lrc<syntax_pos::SourceFile>,\n-                                override_span: Option<Span>) -> Result<Self, Vec<Diagnostic>> {\n-        let mut sr = StringReader::new_raw(sess, source_file, override_span);\n-        if sr.advance_token().is_err() {\n-            Err(sr.buffer_fatal_errors())\n-        } else {\n-            Ok(sr)\n-        }\n-    }\n-\n-    pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n-        let begin = sess.source_map().lookup_byte_offset(span.lo());\n-        let end = sess.source_map().lookup_byte_offset(span.hi());\n-\n-        // Make the range zero-length if the span is invalid.\n-        if span.lo() > span.hi() || begin.sf.start_pos != end.sf.start_pos {\n-            span = span.shrink_to_lo();\n-        }\n-\n-        let mut sr = StringReader::new_raw_internal(sess, begin.sf, None);\n-\n-        // Seek the lexer to the right byte range.\n-        sr.next_pos = span.lo();\n-        sr.end_src_index = sr.src_index(span.hi());\n-\n-        sr.bump();\n-\n-        if sr.advance_token().is_err() {\n-            sr.emit_fatal_errors();\n-            FatalError.raise();\n-        }\n-\n-        sr\n-    }\n-\n     #[inline]\n     fn ch_is(&self, c: char) -> bool {\n         self.ch == Some(c)\n@@ -269,30 +228,6 @@ impl<'a> StringReader<'a> {\n         self.sess.span_diagnostic.struct_span_fatal(self.mk_sp(from_pos, to_pos), &m[..])\n     }\n \n-    /// Advance peek_token to refer to the next token, and\n-    /// possibly update the interner.\n-    fn advance_token(&mut self) -> Result<(), ()> {\n-        match self.scan_whitespace_or_comment() {\n-            Some(comment) => {\n-                self.peek_span_src_raw = comment.span;\n-                self.peek_token = comment;\n-            }\n-            None => {\n-                let (kind, start_pos, end_pos) = if self.is_eof() {\n-                    (token::Eof, self.source_file.end_pos, self.source_file.end_pos)\n-                } else {\n-                    let start_pos = self.pos;\n-                    (self.next_token_inner()?, start_pos, self.pos)\n-                };\n-                let (real, raw) = self.mk_sp_and_raw(start_pos, end_pos);\n-                self.peek_token = Token::new(kind, real);\n-                self.peek_span_src_raw = raw;\n-            }\n-        }\n-\n-        Ok(())\n-    }\n-\n     #[inline]\n     fn src_index(&self, pos: BytePos) -> usize {\n         (pos - self.source_file.start_pos).to_usize()\n@@ -1462,12 +1397,7 @@ mod tests {\n                  teststr: String)\n                  -> StringReader<'a> {\n         let sf = sm.new_source_file(PathBuf::from(teststr.clone()).into(), teststr);\n-        let mut sr = StringReader::new_raw(sess, sf, None);\n-        if sr.advance_token().is_err() {\n-            sr.emit_fatal_errors();\n-            FatalError.raise();\n-        }\n-        sr\n+        StringReader::new(sess, sf, None)\n     }\n \n     #[test]\n@@ -1489,17 +1419,17 @@ mod tests {\n             assert_eq!(tok1.kind, tok2.kind);\n             assert_eq!(tok1.span, tok2.span);\n             assert_eq!(string_reader.next_token(), token::Whitespace);\n-            // the 'main' id is already read:\n-            assert_eq!(string_reader.pos.clone(), BytePos(28));\n             // read another token:\n             let tok3 = string_reader.next_token();\n+            assert_eq!(string_reader.pos.clone(), BytePos(28));\n             let tok4 = Token::new(\n                 mk_ident(\"main\"),\n                 Span::new(BytePos(24), BytePos(28), NO_EXPANSION),\n             );\n             assert_eq!(tok3.kind, tok4.kind);\n             assert_eq!(tok3.span, tok4.span);\n-            // the lparen is already read:\n+\n+            assert_eq!(string_reader.next_token(), token::OpenDelim(token::Paren));\n             assert_eq!(string_reader.pos.clone(), BytePos(29))\n         })\n     }"}, {"sha": "830fbec58ded952c109184007741491d7a17aaa2", "filename": "src/libsyntax/parse/lexer/tokentrees.rs", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -4,13 +4,14 @@ use crate::print::pprust::token_to_string;\n use crate::parse::lexer::{StringReader, UnmatchedBrace};\n use crate::parse::token::{self, Token};\n use crate::parse::PResult;\n-use crate::tokenstream::{DelimSpan, IsJoint::*, TokenStream, TokenTree, TreeAndJoint};\n+use crate::tokenstream::{DelimSpan, IsJoint::{self, *}, TokenStream, TokenTree, TreeAndJoint};\n \n impl<'a> StringReader<'a> {\n     crate fn into_token_trees(self) -> (PResult<'a, TokenStream>, Vec<UnmatchedBrace>) {\n         let mut tt_reader = TokenTreesReader {\n             string_reader: self,\n             token: Token::dummy(),\n+            joint_to_prev: Joint,\n             open_braces: Vec::new(),\n             unmatched_braces: Vec::new(),\n             matching_delim_spans: Vec::new(),\n@@ -24,6 +25,7 @@ impl<'a> StringReader<'a> {\n struct TokenTreesReader<'a> {\n     string_reader: StringReader<'a>,\n     token: Token,\n+    joint_to_prev: IsJoint,\n     /// Stack of open delimiters and their spans. Used for error message.\n     open_braces: Vec<(token::DelimToken, Span)>,\n     unmatched_braces: Vec<UnmatchedBrace>,\n@@ -203,21 +205,26 @@ impl<'a> TokenTreesReader<'a> {\n             },\n             _ => {\n                 let tt = TokenTree::Token(self.token.take());\n-                // Note that testing for joint-ness here is done via the raw\n-                // source span as the joint-ness is a property of the raw source\n-                // rather than wanting to take `override_span` into account.\n-                // Additionally, we actually check if the *next* pair of tokens\n-                // is joint, but this is equivalent to checking the current pair.\n-                let raw = self.string_reader.peek_span_src_raw;\n                 self.real_token();\n-                let is_joint = raw.hi() == self.string_reader.peek_span_src_raw.lo()\n-                    && self.token.is_op();\n+                let is_joint = self.joint_to_prev == Joint && self.token.is_op();\n                 Ok((tt, if is_joint { Joint } else { NonJoint }))\n             }\n         }\n     }\n \n     fn real_token(&mut self) {\n-        self.token = self.string_reader.real_token();\n+        self.joint_to_prev = Joint;\n+        loop {\n+            let token = self.string_reader.next_token();\n+            match token.kind {\n+                token::Whitespace | token::Comment | token::Shebang(_) => {\n+                    self.joint_to_prev = NonJoint;\n+                }\n+                _ => {\n+                    self.token = token;\n+                    return;\n+                },\n+            }\n+        }\n     }\n }"}, {"sha": "4c4551b1757acefd44615353243d9ae937f961ea", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -308,7 +308,7 @@ pub fn maybe_file_to_stream(\n     source_file: Lrc<SourceFile>,\n     override_span: Option<Span>,\n ) -> Result<(TokenStream, Vec<lexer::UnmatchedBrace>), Vec<Diagnostic>> {\n-    let srdr = lexer::StringReader::new_or_buffered_errs(sess, source_file, override_span)?;\n+    let srdr = lexer::StringReader::new(sess, source_file, override_span);\n     let (token_trees, unmatched_braces) = srdr.into_token_trees();\n \n     match token_trees {"}, {"sha": "d4b2220695102aa87ae61c857d08412951ec4fa4", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -1,17 +1,31 @@\n #![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n+\n+#[repr(transparent)]\n+#[derive(Copy, Clone)]\n+struct Wrap<T>(T);\n+\n #[repr(usize)]\n #[derive(Copy, Clone)]\n enum Enum {\n     A = 0,\n }\n union TransmuteEnum {\n     in1: &'static u8,\n+    in2: usize,\n     out1: Enum,\n+    out2: Wrap<Enum>,\n }\n \n-// A pointer is guaranteed non-null\n-const BAD_ENUM: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n+const GOOD_ENUM: Enum = unsafe { TransmuteEnum { in2: 0 }.out1 };\n+\n+const BAD_ENUM: Enum = unsafe { TransmuteEnum { in2: 1 }.out1 };\n+//~^ ERROR is undefined behavior\n+\n+const BAD_ENUM_PTR: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n+//~^ ERROR is undefined behavior\n+\n+const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { TransmuteEnum { in1: &1 }.out2 };\n //~^ ERROR is undefined behavior\n \n // (Potentially) invalid enum discriminant\n@@ -20,9 +34,7 @@ const BAD_ENUM: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n enum Enum2 {\n     A = 2,\n }\n-#[repr(transparent)]\n-#[derive(Copy, Clone)]\n-struct Wrap<T>(T);\n+\n union TransmuteEnum2 {\n     in1: usize,\n     in2: &'static u8,\n@@ -33,17 +45,17 @@ union TransmuteEnum2 {\n }\n const BAD_ENUM2: Enum2 = unsafe { TransmuteEnum2 { in1: 0 }.out1 };\n //~^ ERROR is undefined behavior\n-const BAD_ENUM3: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n+const BAD_ENUM2_PTR: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n //~^ ERROR is undefined behavior\n-const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n+const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n //~^ ERROR is undefined behavior\n \n // Undef enum discriminant.\n-const BAD_ENUM_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n+const BAD_ENUM2_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n //~^ ERROR is undefined behavior\n \n // Pointer value in an enum with a niche that is not just 0.\n-const BAD_ENUM_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n+const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n //~^ ERROR is undefined behavior\n \n // Invalid enum field content (mostly to test printing of paths for enum tuple\n@@ -53,7 +65,7 @@ union TransmuteChar {\n     b: char,\n }\n // Need to create something which does not clash with enum layout optimizations.\n-const BAD_ENUM_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n+const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n //~^ ERROR is undefined behavior\n \n fn main() {"}, {"sha": "8ecb1aabdd0f72a55a2e6b0de0c1681403fd3a55", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -1,59 +1,75 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:14:1\n+  --> $DIR/ub-enum.rs:22:1\n    |\n-LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { in2: 1 }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 1, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:34:1\n+  --> $DIR/ub-enum.rs:25:1\n+   |\n+LL | const BAD_ENUM_PTR: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:28:1\n+   |\n+LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { TransmuteEnum { in1: &1 }.out2 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be equal to 0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { TransmuteEnum2 { in1: 0 }.out1 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:36:1\n+  --> $DIR/ub-enum.rs:48:1\n    |\n-LL | const BAD_ENUM3: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+LL | const BAD_ENUM2_PTR: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:38:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n-LL | const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be in the range 2..=2\n+LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be equal to 2\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:42:1\n+  --> $DIR/ub-enum.rs:54:1\n    |\n-LL | const BAD_ENUM_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected a valid enum discriminant\n+LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:46:1\n+  --> $DIR/ub-enum.rs:58:1\n    |\n-LL | const BAD_ENUM_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:56:1\n+  --> $DIR/ub-enum.rs:68:1\n    |\n-LL | const BAD_ENUM_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected something less or equal to 1114111\n+LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected something less or equal to 1114111\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 9 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "bcbb4358aec03823682766573052a389ad4d2eba", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -5,9 +5,19 @@ use std::mem;\n use std::ptr::NonNull;\n use std::num::{NonZeroU8, NonZeroUsize};\n \n+const NON_NULL: NonNull<u8> = unsafe { mem::transmute(1usize) };\n+const NON_NULL_PTR: NonNull<u8> = unsafe { mem::transmute(&1) };\n+\n const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n+const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n+//~^ ERROR it is undefined behavior to use this value\n+    let ptr: &(u8, u8, u8) = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n+    let out_of_bounds_ptr = &ptr.2; // use address-of-field for pointer arithmetic\n+    mem::transmute(out_of_bounds_ptr)\n+} };\n+\n const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n //~^ ERROR it is undefined behavior to use this value\n const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };"}, {"sha": "2f9423fed3530389b6f1a4b726d852cc56030050", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -1,51 +1,64 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:8:1\n+  --> $DIR/ub-nonnull.rs:11:1\n    |\n LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:11:1\n+  --> $DIR/ub-nonnull.rs:14:1\n+   |\n+LL | / const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n+LL | |\n+LL | |     let ptr: &(u8, u8, u8) = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n+LL | |     let out_of_bounds_ptr = &ptr.2; // use address-of-field for pointer arithmetic\n+LL | |     mem::transmute(out_of_bounds_ptr)\n+LL | | } };\n+   | |____^ type validation failed: encountered a potentially NULL pointer, but expected something that cannot possibly fail to be greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-nonnull.rs:21:1\n    |\n LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:13:1\n+  --> $DIR/ub-nonnull.rs:23:1\n    |\n LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:20:1\n+  --> $DIR/ub-nonnull.rs:30:1\n    |\n LL | const UNINIT: NonZeroU8 = unsafe { Transmute { uninit: () }.out };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:28:1\n+  --> $DIR/ub-nonnull.rs:38:1\n    |\n LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something in the range 10..=30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:34:1\n+  --> $DIR/ub-nonnull.rs:44:1\n    |\n LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "a2c8fe551bb03d378c919c7c2cdd18894801eef4", "filename": "src/test/ui/issues/issue-62375.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fissues%2Fissue-62375.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fissues%2Fissue-62375.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-62375.rs?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -0,0 +1,9 @@\n+enum A {\n+    Value(())\n+}\n+\n+fn main() {\n+    let a = A::Value(());\n+    a == A::Value;\n+    //~^ ERROR binary operation `==` cannot be applied to type `A`\n+}"}, {"sha": "6db45630b9437473b7f1c1167db961004ef3c556", "filename": "src/test/ui/issues/issue-62375.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fissues%2Fissue-62375.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b820c761744db080ff7a4ba3ac88d259065cb836/src%2Ftest%2Fui%2Fissues%2Fissue-62375.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-62375.stderr?ref=b820c761744db080ff7a4ba3ac88d259065cb836", "patch": "@@ -0,0 +1,13 @@\n+error[E0369]: binary operation `==` cannot be applied to type `A`\n+  --> $DIR/issue-62375.rs:7:7\n+   |\n+LL |     a == A::Value;\n+   |     - ^^ -------- fn(()) -> A {A::Value}\n+   |     |\n+   |     A\n+   |\n+   = note: an implementation of `std::cmp::PartialEq` might be missing for `A`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0369`."}]}