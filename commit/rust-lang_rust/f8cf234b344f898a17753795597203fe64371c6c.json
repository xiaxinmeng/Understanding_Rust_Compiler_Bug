{"sha": "f8cf234b344f898a17753795597203fe64371c6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4Y2YyMzRiMzQ0Zjg5OGExNzc1Mzc5NTU5NzIwM2ZlNjQzNzFjNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-06T05:38:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-06T05:38:15Z"}, "message": "auto merge of #8265 : blake2-ppc/rust/std-iter, r=thestinger\n\nFix #8228 by replacing .iter() and .iter_err() in Result by external iterators.\r\n\r\nImplement random access for `iterator::Invert` and `vec::ChunkIter` (and bidirectionality).\r\n\r\nImplement Repeat iterator.", "tree": {"sha": "eea99cd99a1c3fc75bd23069413b59f3bc17fbc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eea99cd99a1c3fc75bd23069413b59f3bc17fbc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f8cf234b344f898a17753795597203fe64371c6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f8cf234b344f898a17753795597203fe64371c6c", "html_url": "https://github.com/rust-lang/rust/commit/f8cf234b344f898a17753795597203fe64371c6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f8cf234b344f898a17753795597203fe64371c6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6f88f4dea559157c690688721cff6761172db6c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f88f4dea559157c690688721cff6761172db6c3", "html_url": "https://github.com/rust-lang/rust/commit/6f88f4dea559157c690688721cff6761172db6c3"}, {"sha": "45085b9f8dc70f3b24eb9317b2d6bb2911ffb0a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/45085b9f8dc70f3b24eb9317b2d6bb2911ffb0a6", "html_url": "https://github.com/rust-lang/rust/commit/45085b9f8dc70f3b24eb9317b2d6bb2911ffb0a6"}], "stats": {"total": 362, "additions": 198, "deletions": 164}, "files": [{"sha": "6dedd9ee4dd266f95da9777cf67bd7737e8edc18", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 22, "deletions": 48, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=f8cf234b344f898a17753795597203fe64371c6c", "patch": "@@ -13,7 +13,7 @@\n \n use std::cmp;\n use std::iterator::RandomAccessIterator;\n-use std::iterator::{Invert, Enumerate};\n+use std::iterator::{Invert, Enumerate, Repeat, Map, Zip};\n use std::num;\n use std::ops;\n use std::uint;\n@@ -206,14 +206,13 @@ impl BigBitv {\n     #[inline]\n     pub fn equals(&self, b: &BigBitv, nbits: uint) -> bool {\n         let len = b.storage.len();\n-        do uint::iterate(0, len) |i| {\n+        for i in range(0, len) {\n             let mask = big_mask(nbits, i);\n             if mask & self.storage[i] != mask & b.storage[i] {\n-                false\n-            } else {\n-                true\n+                return false;\n             }\n         }\n+        true\n     }\n }\n \n@@ -864,13 +863,12 @@ impl BitvSet {\n     /// w1, w2) where the bit location is the number of bits offset so far,\n     /// and w1/w2 are the words coming from the two vectors self, other.\n     fn common_iter<'a>(&'a self, other: &'a BitvSet)\n-        -> MapE<(uint,&uint),(uint,uint,uint), &'a ~[uint],Enumerate<vec::VecIterator<'a,uint>>> {\n-        let min = num::min(self.bitv.storage.len(),\n-                            other.bitv.storage.len());\n-        MapE{iter: self.bitv.storage.slice(0, min).iter().enumerate(),\n-             env: &other.bitv.storage,\n-             f: |(i, &w): (uint, &uint), o_store| (i * uint::bits, w, o_store[i])\n-        }\n+        -> Map<'static, ((uint, &'a uint), &'a ~[uint]), (uint, uint, uint),\n+               Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<&'a ~[uint]>>> {\n+        let min = num::min(self.bitv.storage.len(), other.bitv.storage.len());\n+        self.bitv.storage.slice(0, min).iter().enumerate()\n+            .zip(Repeat::new(&other.bitv.storage))\n+            .transform(|((i, &w), o_store)| (i * uint::bits, w, o_store[i]))\n     }\n \n     /// Visits each word in self or other that extends beyond the other. This\n@@ -881,45 +879,21 @@ impl BitvSet {\n     /// is true if the word comes from 'self', and false if it comes from\n     /// 'other'.\n     fn outlier_iter<'a>(&'a self, other: &'a BitvSet)\n-        -> MapE<(uint, &uint),(bool, uint, uint), uint, Enumerate<vec::VecIterator<'a, uint>>> {\n-        let len1 = self.bitv.storage.len();\n-        let len2 = other.bitv.storage.len();\n-        let min = num::min(len1, len2);\n-\n-        if min < len1 {\n-            MapE{iter: self.bitv.storage.slice(min, len1).iter().enumerate(),\n-                 env: min,\n-                 f: |(i, &w): (uint, &uint), min| (true, (i + min) * uint::bits, w)\n-            }\n+        -> Map<'static, ((uint, &'a uint), uint), (bool, uint, uint),\n+               Zip<Enumerate<vec::VecIterator<'a, uint>>, Repeat<uint>>> {\n+        let slen = self.bitv.storage.len();\n+        let olen = other.bitv.storage.len();\n+\n+        if olen < slen {\n+            self.bitv.storage.slice_from(olen).iter().enumerate()\n+                .zip(Repeat::new(olen))\n+                .transform(|((i, &w), min)| (true, (i + min) * uint::bits, w))\n         } else {\n-            MapE{iter: other.bitv.storage.slice(min, len2).iter().enumerate(),\n-                 env: min,\n-                 f: |(i, &w): (uint, &uint), min| (false, (i + min) * uint::bits, w)\n-            }\n-        }\n-    }\n-}\n-\n-/// Like iterator::Map with explicit env capture\n-struct MapE<A, B, Env, I> {\n-    priv env: Env,\n-    priv f: &'static fn(A, Env) -> B,\n-    priv iter: I,\n-}\n-\n-impl<'self, A, B, Env: Clone, I: Iterator<A>> Iterator<B> for MapE<A, B, Env, I> {\n-    #[inline]\n-    fn next(&mut self) -> Option<B> {\n-        match self.iter.next() {\n-            Some(elt) => Some((self.f)(elt, self.env.clone())),\n-            None => None\n+            other.bitv.storage.slice_from(slen).iter().enumerate()\n+                .zip(Repeat::new(slen))\n+                .transform(|((i, &w), min)| (false, (i + min) * uint::bits, w))\n         }\n     }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        self.iter.size_hint()\n-    }\n }\n \n pub struct BitvSetIterator<'self> {"}, {"sha": "fbc471c0ae05d4b289235134ec8366d040459437", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 17, "deletions": 37, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=f8cf234b344f898a17753795597203fe64371c6c", "patch": "@@ -19,7 +19,8 @@ use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use clone::Clone;\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use iterator::{Iterator, IteratorUtil, FromIterator, Extendable, Chain, range};\n+use iterator::{Iterator, IteratorUtil, FromIterator, Extendable, range};\n+use iterator::{FilterMap, Chain, Repeat, Zip};\n use num;\n use option::{None, Option, Some};\n use rand::RngUtil;\n@@ -712,10 +713,12 @@ impl<T:Hash + Eq> HashSet<T> {\n     }\n \n     /// Visit the values representing the difference\n-    pub fn difference_iter<'a>(&'a self, other: &'a HashSet<T>)\n-        -> SetAlgebraIter<'a, T> {\n-        EnvFilterIterator{iter: self.iter(), env: other,\n-                          filter: |elt, other| !other.contains(elt) }\n+    pub fn difference_iter<'a>(&'a self, other: &'a HashSet<T>) -> SetAlgebraIter<'a, T> {\n+        Repeat::new(other)\n+            .zip(self.iter())\n+            .filter_map(|(other, elt)| {\n+                if !other.contains(elt) { Some(elt) } else { None }\n+            })\n     }\n \n     /// Visit the values representing the symmetric difference\n@@ -727,8 +730,11 @@ impl<T:Hash + Eq> HashSet<T> {\n     /// Visit the values representing the intersection\n     pub fn intersection_iter<'a>(&'a self, other: &'a HashSet<T>)\n         -> SetAlgebraIter<'a, T> {\n-        EnvFilterIterator{iter: self.iter(), env: other,\n-                          filter: |elt, other| other.contains(elt) }\n+        Repeat::new(other)\n+            .zip(self.iter())\n+            .filter_map(|(other, elt)| {\n+                if other.contains(elt) { Some(elt) } else { None }\n+            })\n     }\n \n     /// Visit the values representing the union\n@@ -756,38 +762,12 @@ impl<K: Eq + Hash, T: Iterator<K>> Extendable<K, T> for HashSet<K> {\n     }\n }\n \n-// FIXME #7814: use std::iterator::FilterIterator\n-/// Building block for Set operation iterators\n-pub struct EnvFilterIterator<A, Env, I> {\n-    priv env: Env,\n-    priv filter: &'static fn(&A, Env) -> bool,\n-    priv iter: I,\n-}\n-\n-impl<'self, A, Env: Clone, I: Iterator<&'self A>> Iterator<&'self A>\n-        for EnvFilterIterator<A, Env, I> {\n-    #[inline]\n-    fn next(&mut self) -> Option<&'self A> {\n-        loop {\n-            match self.iter.next() {\n-                Some(elt) => if (self.filter)(elt, self.env.clone()) {\n-                    return Some(elt)\n-                },\n-                None => return None,\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        let (_, upper) = self.iter.size_hint();\n-        (0, upper)\n-    }\n-}\n-\n+// `Repeat` is used to feed the filter closure an explicit capture\n+// of a reference to the other set\n /// Set operations iterator\n pub type SetAlgebraIter<'self, T> =\n-    EnvFilterIterator<T, &'self HashSet<T>, HashSetIterator<'self, T>>;\n+    FilterMap<'static,(&'self HashSet<T>, &'self T), &'self T,\n+              Zip<Repeat<&'self HashSet<T>>,HashSetIterator<'self,T>>>;\n \n \n #[cfg(test)]"}, {"sha": "56a0dca56679ccf3a34d89038944614d0c497263", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=f8cf234b344f898a17753795597203fe64371c6c", "patch": "@@ -82,6 +82,17 @@ pub trait DoubleEndedIteratorUtil {\n /// In the future these will be default methods instead of a utility trait.\n impl<A, T: DoubleEndedIterator<A>> DoubleEndedIteratorUtil for T {\n     /// Flip the direction of the iterator\n+    ///\n+    /// The inverted iterator flips the ends on an iterator that can already\n+    /// be iterated from the front and from the back.\n+    ///\n+    ///\n+    /// If the iterator also implements RandomAccessIterator, the inverted\n+    /// iterator is also random access, with the indices starting at the back\n+    /// of the original iterator.\n+    ///\n+    /// Note: Random access with inverted indices still only applies to the first\n+    /// `uint::max_value` elements of the original iterator.\n     #[inline]\n     fn invert(self) -> Invert<T> {\n         Invert{iter: self}\n@@ -106,6 +117,16 @@ impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Invert<T> {\n     fn next_back(&mut self) -> Option<A> { self.iter.next() }\n }\n \n+impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterator<A>\n+    for Invert<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint { self.iter.indexable() }\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        self.iter.idx(self.indexable() - index - 1)\n+    }\n+}\n+\n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n /// implementations of the `Iterator` trait.\n ///\n@@ -1555,6 +1576,39 @@ impl<A: Add<A, A> + Clone> Iterator<A> for Counter<A> {\n     }\n }\n \n+/// An iterator that repeats an element endlessly\n+#[deriving(Clone, DeepClone)]\n+pub struct Repeat<A> {\n+    priv element: A\n+}\n+\n+impl<A: Clone> Repeat<A> {\n+    /// Create a new `Repeat` that enlessly repeats the element `elt`.\n+    #[inline]\n+    pub fn new(elt: A) -> Repeat<A> {\n+        Repeat{element: elt}\n+    }\n+}\n+\n+impl<A: Clone> Iterator<A> for Repeat<A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { self.idx(0) }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { (uint::max_value, None) }\n+}\n+\n+impl<A: Clone> DoubleEndedIterator<A> for Repeat<A> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { self.idx(0) }\n+}\n+\n+impl<A: Clone> RandomAccessIterator<A> for Repeat<A> {\n+    #[inline]\n+    fn indexable(&self) -> uint { uint::max_value }\n+    #[inline]\n+    fn idx(&self, _: uint) -> Option<A> { Some(self.element.clone()) }\n+}\n+\n #[cfg(test)]\n mod tests {\n     use super::*;\n@@ -2017,6 +2071,17 @@ mod tests {\n         check_randacc_iter(xs.iter().enumerate(), xs.len());\n     }\n \n+    #[test]\n+    fn test_random_access_invert() {\n+        let xs = [1, 2, 3, 4, 5];\n+        check_randacc_iter(xs.iter().invert(), xs.len());\n+        let mut it = xs.iter().invert();\n+        it.next();\n+        it.next_back();\n+        it.next();\n+        check_randacc_iter(it, xs.len() - 3);\n+    }\n+\n     #[test]\n     fn test_random_access_zip() {\n         let xs = [1, 2, 3, 4, 5];"}, {"sha": "86bc98e53fcb6605cca989137c733653f47326df", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=f8cf234b344f898a17753795597203fe64371c6c", "patch": "@@ -70,30 +70,6 @@ pub fn div_round(x: uint, y: uint) -> uint {\n ///\n pub fn div_floor(x: uint, y: uint) -> uint { return x / y; }\n \n-///\n-/// Iterate over the range [`lo`..`hi`), or stop when requested\n-///\n-/// # Arguments\n-///\n-/// * lo - The integer at which to start the loop (included)\n-/// * hi - The integer at which to stop the loop (excluded)\n-/// * it - A block to execute with each consecutive integer of the range.\n-///        Return `true` to continue, `false` to stop.\n-///\n-/// # Return value\n-///\n-/// `true` If execution proceeded correctly, `false` if it was interrupted,\n-/// that is if `it` returned `false` at any point.\n-///\n-pub fn iterate(lo: uint, hi: uint, it: &fn(uint) -> bool) -> bool {\n-    let mut i = lo;\n-    while i < hi {\n-        if (!it(i)) { return false; }\n-        i += 1u;\n-    }\n-    return true;\n-}\n-\n impl iter::Times for uint {\n     #[inline]\n     ///"}, {"sha": "ea1bddcdb4b9d60aba0138494219519e120d5317", "filename": "src/libstd/option.rs", "status": "modified", "additions": 18, "deletions": 28, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=f8cf234b344f898a17753795597203fe64371c6c", "patch": "@@ -116,7 +116,7 @@ impl<T: ToStr> ToStr for Option<T> {\n impl<T> Option<T> {\n     /// Return an iterator over the possibly contained value\n     #[inline]\n-    pub fn iter<'r>(&'r self) -> OptionIterator<'r, T> {\n+    pub fn iter<'r>(&'r self) -> OptionIterator<&'r T> {\n         match *self {\n             Some(ref x) => OptionIterator{opt: Some(x)},\n             None => OptionIterator{opt: None}\n@@ -125,13 +125,19 @@ impl<T> Option<T> {\n \n     /// Return a mutable iterator over the possibly contained value\n     #[inline]\n-    pub fn mut_iter<'r>(&'r mut self) -> OptionMutIterator<'r, T> {\n+    pub fn mut_iter<'r>(&'r mut self) -> OptionIterator<&'r mut T> {\n         match *self {\n-            Some(ref mut x) => OptionMutIterator{opt: Some(x)},\n-            None => OptionMutIterator{opt: None}\n+            Some(ref mut x) => OptionIterator{opt: Some(x)},\n+            None => OptionIterator{opt: None}\n         }\n     }\n \n+    /// Return a consuming iterator over the possibly contained value\n+    #[inline]\n+    pub fn consume(self) -> OptionIterator<T> {\n+        OptionIterator{opt: self}\n+    }\n+\n     /// Returns true if the option equals `None`\n     #[inline]\n     pub fn is_none(&self) -> bool {\n@@ -404,34 +410,18 @@ impl<T> Zero for Option<T> {\n     fn is_zero(&self) -> bool { self.is_none() }\n }\n \n-/// Immutable iterator over an `Option<A>`\n-pub struct OptionIterator<'self, A> {\n-    priv opt: Option<&'self A>\n-}\n-\n-impl<'self, A> Iterator<&'self A> for OptionIterator<'self, A> {\n-    fn next(&mut self) -> Option<&'self A> {\n-        util::replace(&mut self.opt, None)\n-    }\n-\n-    fn size_hint(&self) -> (uint, Option<uint>) {\n-        match self.opt {\n-            Some(_) => (1, Some(1)),\n-            None => (0, Some(0)),\n-        }\n-    }\n-}\n-\n-/// Mutable iterator over an `Option<A>`\n-pub struct OptionMutIterator<'self, A> {\n-    priv opt: Option<&'self mut A>\n+/// An iterator that yields either one or zero elements\n+pub struct OptionIterator<A> {\n+    priv opt: Option<A>\n }\n \n-impl<'self, A> Iterator<&'self mut A> for OptionMutIterator<'self, A> {\n-    fn next(&mut self) -> Option<&'self mut A> {\n-        util::replace(&mut self.opt, None)\n+impl<A> Iterator<A> for OptionIterator<A> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        self.opt.take()\n     }\n \n+    #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) {\n         match self.opt {\n             Some(_) => (1, Some(1)),"}, {"sha": "dfd11f9227d413e5b37725b91a34e54d024f3eea", "filename": "src/libstd/ptr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fptr.rs?ref=f8cf234b344f898a17753795597203fe64371c6c", "patch": "@@ -12,6 +12,7 @@\n \n use cast;\n use clone::Clone;\n+use iterator::{range, Iterator};\n use option::{Option, Some, None};\n use unstable::intrinsics;\n use util::swap;\n@@ -20,7 +21,6 @@ use util::swap;\n #[cfg(not(test))] use num::Int;\n \n #[cfg(not(test))] use cmp::{Eq, Ord};\n-use uint;\n \n /// Calculate the offset from a pointer\n #[inline]\n@@ -240,11 +240,10 @@ pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n         fail!(\"ptr::array_each_with_len failure: arr input is null pointer\");\n     }\n     //let start_ptr = *arr;\n-    uint::iterate(0, len, |e| {\n+    for e in range(0, len) {\n         let n = offset(arr, e as int);\n         cb(*n);\n-        true\n-    });\n+    }\n     debug!(\"array_each_with_len: after iterate\");\n }\n "}, {"sha": "91f42edf0aecd46e33efafc41fa7fccf43032be4", "filename": "src/libstd/result.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fresult.rs?ref=f8cf234b344f898a17753795597203fe64371c6c", "patch": "@@ -16,7 +16,7 @@ use clone::Clone;\n use cmp::Eq;\n use either;\n use iterator::Iterator;\n-use option::{None, Option, Some};\n+use option::{None, Option, Some, OptionIterator};\n use vec;\n use vec::{OwnedVector, ImmutableVector};\n use container::Container;\n@@ -86,15 +86,15 @@ impl<T, E: ToStr> Result<T, E> {\n     ///\n     /// Example:\n     ///\n-    ///     do read_file(file).iter |buf| {\n+    ///     for buf in read_file(file) {\n     ///         print_buf(buf)\n     ///     }\n     #[inline]\n-    pub fn iter(&self, f: &fn(&T)) {\n+    pub fn iter<'r>(&'r self) -> OptionIterator<&'r T> {\n         match *self {\n-            Ok(ref t) => f(t),\n-            Err(_) => (),\n-        }\n+            Ok(ref t) => Some(t),\n+            Err(*) => None,\n+        }.consume()\n     }\n \n     /// Call a method based on a previous result\n@@ -104,11 +104,11 @@ impl<T, E: ToStr> Result<T, E> {\n     /// immediately returned.  This function can be used to pass through a\n     /// successful result while handling an error.\n     #[inline]\n-    pub fn iter_err(&self, f: &fn(&E)) {\n+    pub fn iter_err<'r>(&'r self) -> OptionIterator<&'r E> {\n         match *self {\n-            Ok(_) => (),\n-            Err(ref e) => f(e),\n-        }\n+            Ok(*) => None,\n+            Err(ref t) => Some(t),\n+        }.consume()\n     }\n \n     /// Unwraps a result, yielding the content of an `Ok`.\n@@ -214,7 +214,7 @@ impl<T, E: Clone + ToStr> Result<T, E> {\n     ///         parse_bytes(buf)\n     ///     };\n     #[inline]\n-    pub fn map<U: Clone>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n+    pub fn map<U>(&self, op: &fn(&T) -> U) -> Result<U,E> {\n         match *self {\n             Ok(ref t) => Ok(op(t)),\n             Err(ref e) => Err(e.clone())\n@@ -335,21 +335,25 @@ mod tests {\n     #[test]\n     pub fn test_impl_iter() {\n         let mut valid = false;\n-        Ok::<~str, ~str>(~\"a\").iter(|_x| valid = true);\n+        let okval = Ok::<~str, ~str>(~\"a\");\n+        do okval.iter().next().map |_| { valid = true; };\n         assert!(valid);\n \n-        Err::<~str, ~str>(~\"b\").iter(|_x| valid = false);\n+        let errval = Err::<~str, ~str>(~\"b\");\n+        do errval.iter().next().map |_| { valid = false; };\n         assert!(valid);\n     }\n \n     #[test]\n     pub fn test_impl_iter_err() {\n         let mut valid = true;\n-        Ok::<~str, ~str>(~\"a\").iter_err(|_x| valid = false);\n+        let okval = Ok::<~str, ~str>(~\"a\");\n+        do okval.iter_err().next().map |_| { valid = false };\n         assert!(valid);\n \n         valid = false;\n-        Err::<~str, ~str>(~\"b\").iter_err(|_x| valid = true);\n+        let errval = Err::<~str, ~str>(~\"b\");\n+        do errval.iter_err().next().map |_| { valid = true };\n         assert!(valid);\n     }\n "}, {"sha": "0259b547ab3f06040f812deaa55144fbb5bded3e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f8cf234b344f898a17753795597203fe64371c6c/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=f8cf234b344f898a17753795597203fe64371c6c", "patch": "@@ -479,6 +479,7 @@ pub fn each_permutation<T:Clone>(values: &[T], fun: &fn(perm : &[T]) -> bool) ->\n \n /// An iterator over the (overlapping) slices of length `size` within\n /// a vector.\n+#[deriving(Clone)]\n pub struct WindowIter<'self, T> {\n     priv v: &'self [T],\n     priv size: uint\n@@ -498,23 +499,60 @@ impl<'self, T> Iterator<&'self [T]> for WindowIter<'self, T> {\n \n /// An iterator over a vector in (non-overlapping) chunks (`size`\n /// elements at a time).\n+///\n+/// When the vector len is not evenly divided by the chunk size,\n+/// the last slice of the iteration will be the remainer.\n+#[deriving(Clone)]\n pub struct ChunkIter<'self, T> {\n     priv v: &'self [T],\n     priv size: uint\n }\n \n impl<'self, T> Iterator<&'self [T]> for ChunkIter<'self, T> {\n     fn next(&mut self) -> Option<&'self [T]> {\n-        if self.size == 0 {\n+        if self.v.len() == 0 {\n             None\n-        } else if self.size >= self.v.len() {\n-            // finished\n-            self.size = 0;\n-            Some(self.v)\n         } else {\n-            let ret = Some(self.v.slice(0, self.size));\n-            self.v = self.v.slice(self.size, self.v.len());\n-            ret\n+            let chunksz = cmp::min(self.v.len(), self.size);\n+            let (fst, snd) = (self.v.slice_to(chunksz),\n+                              self.v.slice_from(chunksz));\n+            self.v = snd;\n+            Some(fst)\n+        }\n+    }\n+}\n+\n+impl<'self, T> DoubleEndedIterator<&'self [T]> for ChunkIter<'self, T> {\n+    fn next_back(&mut self) -> Option<&'self [T]> {\n+        if self.v.len() == 0 {\n+            None\n+        } else {\n+            let remainder = self.v.len() % self.size;\n+            let chunksz = if remainder != 0 { remainder } else { self.size };\n+            let (fst, snd) = (self.v.slice_to(self.v.len() - chunksz),\n+                              self.v.slice_from(self.v.len() - chunksz));\n+            self.v = fst;\n+            Some(snd)\n+        }\n+    }\n+}\n+\n+impl<'self, T> RandomAccessIterator<&'self [T]> for ChunkIter<'self, T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.v.len()/self.size + if self.v.len() % self.size != 0 { 1 } else { 0 }\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<&'self [T]> {\n+        if index < self.indexable() {\n+            let lo = index * self.size;\n+            let mut hi = lo + self.size;\n+            if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n+\n+            Some(self.v.slice(lo, hi))\n+        } else {\n+            None\n         }\n     }\n }\n@@ -3378,6 +3416,14 @@ mod tests {\n         assert_eq!(v.chunk_iter(2).collect::<~[&[int]]>(), ~[&[1i,2], &[3,4], &[5]]);\n         assert_eq!(v.chunk_iter(3).collect::<~[&[int]]>(), ~[&[1i,2,3], &[4,5]]);\n         assert_eq!(v.chunk_iter(6).collect::<~[&[int]]>(), ~[&[1i,2,3,4,5]]);\n+\n+        assert_eq!(v.chunk_iter(2).invert().collect::<~[&[int]]>(), ~[&[5i], &[3,4], &[1,2]]);\n+        let it = v.chunk_iter(2);\n+        assert_eq!(it.indexable(), 3);\n+        assert_eq!(it.idx(0).unwrap(), &[1,2]);\n+        assert_eq!(it.idx(1).unwrap(), &[3,4]);\n+        assert_eq!(it.idx(2).unwrap(), &[5]);\n+        assert_eq!(it.idx(3), None);\n     }\n \n     #[test]"}]}