{"sha": "9677fff0f9327915b62e4f251d3ad95d2912240d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2NzdmZmYwZjkzMjc5MTViNjJlNGYyNTFkM2FkOTVkMjkxMjI0MGQ=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-14T02:23:56Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-12-14T02:24:15Z"}, "message": "Fix benchmarks", "tree": {"sha": "e466e0b464894e38948d8ccfda408cf7975a4b57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e466e0b464894e38948d8ccfda408cf7975a4b57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9677fff0f9327915b62e4f251d3ad95d2912240d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9677fff0f9327915b62e4f251d3ad95d2912240d", "html_url": "https://github.com/rust-lang/rust/commit/9677fff0f9327915b62e4f251d3ad95d2912240d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9677fff0f9327915b62e4f251d3ad95d2912240d/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "786c143a70ac40e5e028eed6b8efaa54076ce41f", "url": "https://api.github.com/repos/rust-lang/rust/commits/786c143a70ac40e5e028eed6b8efaa54076ce41f", "html_url": "https://github.com/rust-lang/rust/commit/786c143a70ac40e5e028eed6b8efaa54076ce41f"}], "stats": {"total": 209, "additions": 1, "deletions": 208}, "files": [{"sha": "a40c87aa3f18dc4d3991b42ad0688204978913ae", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9677fff0f9327915b62e4f251d3ad95d2912240d/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9677fff0f9327915b62e4f251d3ad95d2912240d/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=9677fff0f9327915b62e4f251d3ad95d2912240d", "patch": "@@ -378,7 +378,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     log(info, ~\"Verifying tree and graph edges...\");\n \n-    let status = do par::alli(tree) |u, v| {\n+    let status = do par::alli(tree) |u, v, copy edges| {\n         let u = u as node_id;\n         if *v == -1i64 || u == root {\n             true"}, {"sha": "46dc54df74d831704f2c64d60dac33d744d60688", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "removed", "additions": 0, "deletions": 207, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/786c143a70ac40e5e028eed6b8efaa54076ce41f/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=786c143a70ac40e5e028eed6b8efaa54076ce41f", "patch": "@@ -1,207 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// xfail-pretty (extra blank line is inserted in vec::mapi call)\n-// multi tasking k-nucleotide\n-\n-extern mod std;\n-use std::map;\n-use std::map::HashMap;\n-use std::sort;\n-use io::ReaderUtil;\n-use cmp::Ord;\n-\n-// given a map, print a sorted version of it\n-fn sort_and_fmt(mm: HashMap<~[u8], uint>, total: uint) -> ~str { \n-   fn pct(xx: uint, yy: uint) -> float {\n-      return (xx as float) * 100f / (yy as float);\n-   }\n-\n-   pure fn le_by_val<TT: Copy Ord, UU: Copy Ord>(kv0: &(TT,UU),\n-                                                 kv1: &(TT,UU)) -> bool {\n-      let (_, v0) = *kv0;\n-      let (_, v1) = *kv1;\n-      return v0 >= v1;\n-   }\n-\n-   pure fn le_by_key<TT: Copy Ord, UU: Copy Ord>(kv0: &(TT,UU),\n-                                                 kv1: &(TT,UU)) -> bool {\n-      let (k0, _) = *kv0;\n-      let (k1, _) = *kv1;\n-      return k0 <= k1;\n-   }\n-\n-   // sort by key, then by value\n-   fn sortKV<TT: Copy Ord, UU: Copy Ord>(orig: ~[(TT,UU)]) -> ~[(TT,UU)] {\n-      return sort::merge_sort(sort::merge_sort(orig, le_by_key), le_by_val);\n-   }\n-\n-   let mut pairs = ~[];\n-\n-   // map -> [(k,%)]\n-   mm.each(fn&(key: ~[u8], val: uint) -> bool {\n-      pairs.push((key, pct(val, total)));\n-      return true;\n-   });\n-\n-   let pairs_sorted = sortKV(pairs);\n-\n-   let mut buffer = ~\"\";\n-\n-   for pairs_sorted.each |kv| {\n-      let (k,v) = *kv;\n-      unsafe {\n-          buffer += (fmt!(\"%s %0.3f\\n\", str::to_upper(str::raw::from_bytes(k)), v));\n-      }\n-   }\n-\n-   return buffer;\n-}\n-\n-// given a map, search for the frequency of a pattern\n-fn find(mm: HashMap<~[u8], uint>, key: ~str) -> uint {\n-   match mm.find(str::to_bytes(str::to_lower(key))) {\n-      option::None      => { return 0u; }\n-      option::Some(num) => { return num; }\n-   }\n-}\n-\n-// given a map, increment the counter for a key\n-fn update_freq(mm: HashMap<~[u8], uint>, key: &[u8]) {\n-    let key = vec::slice(key, 0, key.len());\n-    mm.update(key, 1, |v,v1| { v+v1 });\n-}\n-\n-// given a ~[u8], for each window call a function\n-// i.e., for \"hello\" and windows of size four,\n-// run it(\"hell\") and it(\"ello\"), then return \"llo\"\n-fn windows_with_carry(bb: &[u8], nn: uint,\n-                      it: fn(window: &[u8])) -> ~[u8] {\n-   let mut ii = 0u;\n-\n-   let len = vec::len(bb);\n-   while ii < len - (nn - 1u) {\n-      it(vec::view(bb, ii, ii+nn));\n-      ii += 1u;\n-   }\n-\n-   return vec::slice(bb, len - (nn - 1u), len); \n-}\n-\n-fn make_sequence_processor(sz: uint, from_parent: comm::Port<~[u8]>,\n-                           to_parent: comm::Chan<~str>) {\n-   \n-   let freqs: HashMap<~[u8], uint> = map::HashMap();\n-   let mut carry: ~[u8] = ~[];\n-   let mut total: uint = 0u;\n-\n-   let mut line: ~[u8];\n-\n-   loop {\n-\n-      line = comm::recv(from_parent);\n-      if line == ~[] { break; }\n-\n-       carry = windows_with_carry(carry + line, sz, |window| {\n-         update_freq(freqs, window);\n-         total += 1u;\n-      });\n-   }\n-\n-   let buffer = match sz { \n-       1u => { sort_and_fmt(freqs, total) }\n-       2u => { sort_and_fmt(freqs, total) }\n-       3u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGT\"), ~\"GGT\") }\n-       4u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTA\"), ~\"GGTA\") }\n-       6u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTATT\"), ~\"GGTATT\") }\n-      12u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATT\"), ~\"GGTATTTTAATT\") }\n-      18u => { fmt!(\"%u\\t%s\", find(freqs, ~\"GGTATTTTAATTTATAGT\"), ~\"GGTATTTTAATTTATAGT\") }\n-        _ => { ~\"\" }\n-   };\n-\n-   //comm::send(to_parent, fmt!(\"yay{%u}\", sz));\n-   comm::send(to_parent, buffer);\n-}\n-\n-// given a FASTA file on stdin, process sequence THREE\n-fn main() {\n-    let args = os::args();\n-   let rdr = if os::getenv(~\"RUST_BENCH\").is_some() {\n-       // FIXME: Using this compile-time env variable is a crummy way to\n-       // get to this massive data set, but include_bin! chokes on it (#2598)\n-       let path = Path(env!(\"CFG_SRC_DIR\"))\n-           .push_rel(&Path(\"src/test/bench/shootout-k-nucleotide.data\"));\n-       result::get(&io::file_reader(&path))\n-   } else {\n-      io::stdin()\n-   };\n-\n-\n-\n-   // initialize each sequence sorter\n-   let sizes = ~[1u,2u,3u,4u,6u,12u,18u];\n-   let from_child = vec::map (sizes, |_sz| comm::Port() );\n-   let to_parent  = vec::mapi(sizes, |ii, _sz| comm::Chan(&from_child[ii]) );\n-   let to_child   = vec::mapi(sizes, |ii, sz| {\n-       let ii = ii;\n-       let sz = *sz;\n-       do task::spawn_listener |from_parent| {\n-         make_sequence_processor(sz, from_parent, to_parent[ii]);\n-       }\n-   });\n-\n-   // latch stores true after we've started\n-   // reading the sequence of interest\n-   let mut proc_mode = false;\n-\n-   while !rdr.eof() {\n-      let line: ~str = rdr.read_line();\n-\n-      if str::len(line) == 0u { loop; }\n-\n-      match (line[0], proc_mode) {\n-\n-         // start processing if this is the one\n-         ('>' as u8, false) => {\n-            match str::find_str_from(line, ~\"THREE\", 1u) {\n-               option::Some(_) => proc_mode = true,\n-               option::None    => ()\n-            }\n-         }\n-\n-         // break our processing\n-         ('>' as u8, true) => { break; }\n-\n-         // process the sequence for k-mers\n-         (_, true) => {\n-            let line_bytes = str::to_bytes(line);\n-\n-           for sizes.eachi |ii, _sz| {\n-               let mut lb = line_bytes;\n-               comm::send(to_child[ii], lb);\n-            }\n-         }\n-\n-         // whatever\n-         _ => { }\n-      }\n-   }\n-\n-   // finish...\n-    for sizes.eachi |ii, _sz| {\n-      comm::send(to_child[ii], ~[]);\n-   }\n-\n-   // now fetch and print result messages\n-    for sizes.eachi |ii, _sz| {\n-      io::println(comm::recv(from_child[ii]));\n-   }\n-}\n-"}]}