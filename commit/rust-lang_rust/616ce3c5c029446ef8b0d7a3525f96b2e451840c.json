{"sha": "616ce3c5c029446ef8b0d7a3525f96b2e451840c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxNmNlM2M1YzAyOTQ0NmVmOGIwZDdhMzUyNWY5NmIyZTQ1MTg0MGM=", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-06-22T17:20:25Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-13T21:10:56Z"}, "message": "Cache expansion hash.", "tree": {"sha": "8f0248045ab43e37c49d01771f988cd3e8020dd4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f0248045ab43e37c49d01771f988cd3e8020dd4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/616ce3c5c029446ef8b0d7a3525f96b2e451840c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/616ce3c5c029446ef8b0d7a3525f96b2e451840c", "html_url": "https://github.com/rust-lang/rust/commit/616ce3c5c029446ef8b0d7a3525f96b2e451840c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/616ce3c5c029446ef8b0d7a3525f96b2e451840c/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cff0ea5f88cf926a4cb326545ec63ccd27afb846", "url": "https://api.github.com/repos/rust-lang/rust/commits/cff0ea5f88cf926a4cb326545ec63ccd27afb846", "html_url": "https://github.com/rust-lang/rust/commit/cff0ea5f88cf926a4cb326545ec63ccd27afb846"}], "stats": {"total": 480, "additions": 263, "deletions": 217}, "files": [{"sha": "b787158c34368591b889a0b9707614d6d15d92ca", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 43, "deletions": 3, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -48,7 +48,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, CRATE_DEF_ID};\n+use rustc_hir::def_id::{DefId, DefIdMap, DefPathHash, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ParamName};\n@@ -59,7 +59,7 @@ use rustc_session::utils::{FlattenNonterminals, NtToTokenstream};\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::ExpnId;\n-use rustc_span::source_map::{respan, DesugaringKind};\n+use rustc_span::source_map::{respan, CachingSourceMapView, DesugaringKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::spec::abi::Abi;\n@@ -204,6 +204,8 @@ pub trait ResolverAstLowering {\n \n     fn local_def_id(&self, node: NodeId) -> LocalDefId;\n \n+    fn def_path_hash(&self, def_id: DefId) -> DefPathHash;\n+\n     fn create_def(\n         &mut self,\n         parent: LocalDefId,\n@@ -214,6 +216,32 @@ pub trait ResolverAstLowering {\n     ) -> LocalDefId;\n }\n \n+struct LoweringHasher<'a> {\n+    source_map: CachingSourceMapView<'a>,\n+    resolver: &'a dyn ResolverAstLowering,\n+}\n+\n+impl<'a> rustc_span::HashStableContext for LoweringHasher<'a> {\n+    #[inline]\n+    fn hash_spans(&self) -> bool {\n+        true\n+    }\n+\n+    #[inline]\n+    fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n+        self.resolver.def_path_hash(def_id)\n+    }\n+\n+    #[inline]\n+    fn span_data_to_lines_and_cols(\n+        &mut self,\n+        span: &rustc_span::SpanData,\n+    ) -> Option<(Lrc<rustc_span::SourceFile>, usize, rustc_span::BytePos, usize, rustc_span::BytePos)>\n+    {\n+        self.source_map.span_data_to_lines_and_cols(span)\n+    }\n+}\n+\n /// Context of `impl Trait` in code, which determines whether it is allowed in an HIR subtree,\n /// and if so, what meaning it has.\n #[derive(Debug)]\n@@ -565,6 +593,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         lowered\n     }\n \n+    fn create_stable_hashing_context(&self) -> LoweringHasher<'_> {\n+        LoweringHasher {\n+            source_map: CachingSourceMapView::new(self.sess.source_map()),\n+            resolver: self.resolver,\n+        }\n+    }\n+\n     fn lower_node_id_generic(\n         &mut self,\n         ast_node_id: NodeId,\n@@ -684,7 +719,12 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         span: Span,\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n     ) -> Span {\n-        span.mark_with_reason(allow_internal_unstable, reason, self.sess.edition())\n+        span.mark_with_reason(\n+            allow_internal_unstable,\n+            reason,\n+            self.sess.edition(),\n+            self.create_stable_hashing_context(),\n+        )\n     }\n \n     fn with_anonymous_lifetime_mode<R>("}, {"sha": "df673c6084b96d811b6bdf724c742e9adf6fff17", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -506,7 +506,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                 .map(|(path, item, _exts)| {\n                                     // FIXME: Consider using the derive resolutions (`_exts`)\n                                     // instead of enqueuing the derives to be resolved again later.\n-                                    let expn_id = ExpnId::fresh(None);\n+                                    let expn_id = ExpnId::fresh_empty();\n                                     derive_invocations.push((\n                                         Invocation {\n                                             kind: InvocationKind::Derive { path, item },\n@@ -989,7 +989,7 @@ struct InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> InvocationCollector<'a, 'b> {\n     fn collect(&mut self, fragment_kind: AstFragmentKind, kind: InvocationKind) -> AstFragment {\n-        let expn_id = ExpnId::fresh(None);\n+        let expn_id = ExpnId::fresh_empty();\n         let vis = kind.placeholder_visibility();\n         self.invocations.push((\n             Invocation {"}, {"sha": "e9773bac819bd356b04251a0b5ca0b489bf47d61", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -393,12 +393,19 @@ impl<'a, 'tcx> Decodable<DecodeContext<'a, 'tcx>> for ExpnId {\n                 } else {\n                     local_cdata.cstore.get_crate_data(cnum)\n                 };\n-                Ok(crate_data\n+                let expn_data = crate_data\n                     .root\n                     .expn_data\n                     .get(&crate_data, index)\n                     .unwrap()\n-                    .decode((&crate_data, sess)))\n+                    .decode((&crate_data, sess));\n+                let expn_hash = crate_data\n+                    .root\n+                    .expn_hashes\n+                    .get(&crate_data, index)\n+                    .unwrap()\n+                    .decode((&crate_data, sess));\n+                Ok((expn_data, expn_hash))\n             },\n         )\n     }"}, {"sha": "6fac8e595d0adad7f81bb40e7d8bbf2096117208", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -653,7 +653,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         // Therefore, we need to encode the hygiene data last to ensure that we encode\n         // any `SyntaxContext`s that might be used.\n         i = self.position();\n-        let (syntax_contexts, expn_data) = self.encode_hygiene();\n+        let (syntax_contexts, expn_data, expn_hashes) = self.encode_hygiene();\n         let hygiene_bytes = self.position() - i;\n \n         // Encode source_map. This needs to be done last,\n@@ -701,6 +701,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             tables,\n             syntax_contexts,\n             expn_data,\n+            expn_hashes,\n         });\n \n         let total_bytes = self.position();\n@@ -1578,23 +1579,29 @@ impl EncodeContext<'a, 'tcx> {\n         self.lazy(foreign_modules.iter().map(|(_, m)| m).cloned())\n     }\n \n-    fn encode_hygiene(&mut self) -> (SyntaxContextTable, ExpnDataTable) {\n+    fn encode_hygiene(&mut self) -> (SyntaxContextTable, ExpnDataTable, ExpnHashTable) {\n         let mut syntax_contexts: TableBuilder<_, _> = Default::default();\n         let mut expn_data_table: TableBuilder<_, _> = Default::default();\n+        let mut expn_hash_table: TableBuilder<_, _> = Default::default();\n \n         let _: Result<(), !> = self.hygiene_ctxt.encode(\n-            &mut (&mut *self, &mut syntax_contexts, &mut expn_data_table),\n-            |(this, syntax_contexts, _), index, ctxt_data| {\n+            &mut (&mut *self, &mut syntax_contexts, &mut expn_data_table, &mut expn_hash_table),\n+            |(this, syntax_contexts, _, _), index, ctxt_data| {\n                 syntax_contexts.set(index, this.lazy(ctxt_data));\n                 Ok(())\n             },\n-            |(this, _, expn_data_table), index, expn_data| {\n+            |(this, _, expn_data_table, expn_hash_table), index, expn_data, hash| {\n                 expn_data_table.set(index, this.lazy(expn_data));\n+                expn_hash_table.set(index, this.lazy(hash));\n                 Ok(())\n             },\n         );\n \n-        (syntax_contexts.encode(&mut self.opaque), expn_data_table.encode(&mut self.opaque))\n+        (\n+            syntax_contexts.encode(&mut self.opaque),\n+            expn_data_table.encode(&mut self.opaque),\n+            expn_hash_table.encode(&mut self.opaque),\n+        )\n     }\n \n     fn encode_proc_macros(&mut self) -> Option<ProcMacroData> {"}, {"sha": "8cc1935951fe37a40d0be8fbf208ec375fb6731b", "filename": "compiler/rustc_metadata/src/rmeta/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fmod.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -21,7 +21,7 @@ use rustc_session::config::SymbolManglingVersion;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{Ident, Symbol};\n-use rustc_span::{self, ExpnData, ExpnId, Span};\n+use rustc_span::{self, ExpnData, ExpnHash, ExpnId, Span};\n use rustc_target::spec::{PanicStrategy, TargetTriple};\n \n use std::marker::PhantomData;\n@@ -171,6 +171,7 @@ macro_rules! Lazy {\n \n type SyntaxContextTable = Lazy<Table<u32, Lazy<SyntaxContextData>>>;\n type ExpnDataTable = Lazy<Table<u32, Lazy<ExpnData>>>;\n+type ExpnHashTable = Lazy<Table<u32, Lazy<ExpnHash>>>;\n \n #[derive(MetadataEncodable, MetadataDecodable)]\n crate struct ProcMacroData {\n@@ -226,6 +227,7 @@ crate struct CrateRoot<'tcx> {\n \n     syntax_contexts: SyntaxContextTable,\n     expn_data: ExpnDataTable,\n+    expn_hashes: ExpnHashTable,\n \n     source_map: Lazy<[rustc_span::SourceFile]>,\n "}, {"sha": "32ccdafaeb48c926a87609b2d77ae89564a19b9d", "filename": "compiler/rustc_middle/src/ich/hcx.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fhcx.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -16,7 +16,6 @@ use rustc_span::{BytePos, CachingSourceMapView, SourceFile, SpanData};\n \n use smallvec::SmallVec;\n use std::cmp::Ord;\n-use std::thread::LocalKey;\n \n fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n     debug_assert!(!ich::IGNORED_ATTRIBUTES.is_empty());\n@@ -230,13 +229,6 @@ impl<'a> rustc_span::HashStableContext for StableHashingContext<'a> {\n         self.def_path_hash(def_id)\n     }\n \n-    fn expn_id_cache() -> &'static LocalKey<rustc_span::ExpnIdCache> {\n-        thread_local! {\n-            static CACHE: rustc_span::ExpnIdCache = Default::default();\n-        }\n-        &CACHE\n-    }\n-\n     fn span_data_to_lines_and_cols(\n         &mut self,\n         span: &SpanData,"}, {"sha": "e3db0d2cf30a6dd9da7380516cc44efc9efb8036", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -25,7 +25,7 @@ use rustc_span::hygiene::{\n };\n use rustc_span::source_map::{SourceMap, StableSourceFileId};\n use rustc_span::CachingSourceMapView;\n-use rustc_span::{BytePos, ExpnData, SourceFile, Span, DUMMY_SP};\n+use rustc_span::{BytePos, ExpnData, ExpnHash, SourceFile, Span, DUMMY_SP};\n use std::collections::hash_map::Entry;\n use std::mem;\n \n@@ -364,9 +364,9 @@ impl<'sess> OnDiskCache<'sess> {\n                     syntax_contexts.insert(index, pos);\n                     Ok(())\n                 },\n-                |encoder, index, expn_data| -> FileEncodeResult {\n+                |encoder, index, expn_data, hash| -> FileEncodeResult {\n                     let pos = AbsoluteBytePos::new(encoder.position());\n-                    encoder.encode_tagged(TAG_EXPN_DATA, expn_data)?;\n+                    encoder.encode_tagged(TAG_EXPN_DATA, &(expn_data, hash))?;\n                     expn_ids.insert(index, pos);\n                     Ok(())\n                 },\n@@ -804,7 +804,7 @@ impl<'a, 'tcx> Decodable<CacheDecoder<'a, 'tcx>> for ExpnId {\n                     .unwrap_or_else(|| panic!(\"Bad index {:?} (map {:?})\", index, expn_data));\n \n                 this.with_position(pos.to_usize(), |decoder| {\n-                    let data: ExpnData = decode_tagged(decoder, TAG_EXPN_DATA)?;\n+                    let data: (ExpnData, ExpnHash) = decode_tagged(decoder, TAG_EXPN_DATA)?;\n                     Ok(data)\n                 })\n             },"}, {"sha": "7d765cec57578afdbd03a0b0fed5bcfe8c982210", "filename": "compiler/rustc_mir/src/transform/inline.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -839,7 +839,8 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n             ExpnData::default(ExpnKind::Inlined, *span, self.tcx.sess.edition(), None, None);\n         expn_data.def_site = self.body_span;\n         // Make sure that all spans track the fact that they were inlined.\n-        *span = self.callsite_span.fresh_expansion(expn_data);\n+        *span =\n+            self.callsite_span.fresh_expansion(expn_data, self.tcx.create_stable_hashing_context());\n     }\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {"}, {"sha": "4d124152151942fe00d4e9d9baa384d00085e604", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -39,7 +39,7 @@ use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_expand::base::{DeriveResolutions, SyntaxExtension, SyntaxExtensionKind};\n use rustc_hir::def::Namespace::*;\n use rustc_hir::def::{self, CtorOf, DefKind, NonMacroAttrKind, PartialRes};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, LocalDefId, CRATE_DEF_INDEX};\n+use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, DefPathHash, LocalDefId, CRATE_DEF_INDEX};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n use rustc_hir::TraitCandidate;\n use rustc_index::vec::IndexVec;\n@@ -54,7 +54,7 @@ use rustc_session::lint::{BuiltinLintDiagnostics, LintBuffer};\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n use rustc_span::hygiene::{ExpnId, ExpnKind, MacroKind, SyntaxContext, Transparency};\n-use rustc_span::source_map::Spanned;\n+use rustc_span::source_map::{CachingSourceMapView, Spanned};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::{Span, DUMMY_SP};\n \n@@ -1149,6 +1149,13 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.opt_local_def_id(node).unwrap_or_else(|| panic!(\"no entry for node id: `{:?}`\", node))\n     }\n \n+    fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n+        match def_id.as_local() {\n+            Some(def_id) => self.definitions.def_path_hash(def_id),\n+            None => self.cstore().def_path_hash(def_id),\n+        }\n+    }\n+\n     /// Adds a definition with a parent definition.\n     fn create_def(\n         &mut self,\n@@ -1192,6 +1199,32 @@ impl ResolverAstLowering for Resolver<'_> {\n     }\n }\n \n+struct ExpandHasher<'a, 'b> {\n+    source_map: CachingSourceMapView<'a>,\n+    resolver: &'a Resolver<'b>,\n+}\n+\n+impl<'a, 'b> rustc_span::HashStableContext for ExpandHasher<'a, 'b> {\n+    #[inline]\n+    fn hash_spans(&self) -> bool {\n+        true\n+    }\n+\n+    #[inline]\n+    fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n+        self.resolver.def_path_hash(def_id)\n+    }\n+\n+    #[inline]\n+    fn span_data_to_lines_and_cols(\n+        &mut self,\n+        span: &rustc_span::SpanData,\n+    ) -> Option<(Lrc<rustc_span::SourceFile>, usize, rustc_span::BytePos, usize, rustc_span::BytePos)>\n+    {\n+        self.source_map.span_data_to_lines_and_cols(span)\n+    }\n+}\n+\n impl<'a> Resolver<'a> {\n     pub fn new(\n         session: &'a Session,\n@@ -1364,6 +1397,13 @@ impl<'a> Resolver<'a> {\n         resolver\n     }\n \n+    fn create_stable_hashing_context(&self) -> ExpandHasher<'_, 'a> {\n+        ExpandHasher {\n+            source_map: CachingSourceMapView::new(self.session.source_map()),\n+            resolver: self,\n+        }\n+    }\n+\n     pub fn next_node_id(&mut self) -> NodeId {\n         let next = self\n             .next_node_id"}, {"sha": "8686704388fee0489231253cfce03f7c2c73ee3c", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -218,14 +218,17 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         parent_module_id: Option<NodeId>,\n     ) -> ExpnId {\n         let parent_module = parent_module_id.map(|module_id| self.local_def_id(module_id));\n-        let expn_id = ExpnId::fresh(Some(ExpnData::allow_unstable(\n-            ExpnKind::AstPass(pass),\n-            call_site,\n-            self.session.edition(),\n-            features.into(),\n-            None,\n-            parent_module.map(LocalDefId::to_def_id),\n-        )));\n+        let expn_id = ExpnId::fresh(\n+            ExpnData::allow_unstable(\n+                ExpnKind::AstPass(pass),\n+                call_site,\n+                self.session.edition(),\n+                features.into(),\n+                None,\n+                parent_module.map(LocalDefId::to_def_id),\n+            ),\n+            self.create_stable_hashing_context(),\n+        );\n \n         let parent_scope = parent_module\n             .map_or(self.empty_module, |parent_def_id| self.module_map[&parent_def_id]);\n@@ -287,15 +290,18 @@ impl<'a> ResolverExpand for Resolver<'a> {\n         )?;\n \n         let span = invoc.span();\n-        invoc_id.set_expn_data(ext.expn_data(\n-            parent_scope.expansion,\n-            span,\n-            fast_print_path(path),\n-            res.opt_def_id(),\n-            res.opt_def_id().map(|macro_def_id| {\n-                self.macro_def_scope_from_def_id(macro_def_id).nearest_parent_mod\n-            }),\n-        ));\n+        invoc_id.set_expn_data(\n+            ext.expn_data(\n+                parent_scope.expansion,\n+                span,\n+                fast_print_path(path),\n+                res.opt_def_id(),\n+                res.opt_def_id().map(|macro_def_id| {\n+                    self.macro_def_scope_from_def_id(macro_def_id).nearest_parent_mod\n+                }),\n+            ),\n+            self.create_stable_hashing_context(),\n+        );\n \n         if let Res::Def(_, _) = res {\n             // Gate macro attributes in `#[derive]` output."}, {"sha": "9a101169d20b6df275c06ce26066ae23ef0cbf0b", "filename": "compiler/rustc_span/src/hygiene.rs", "status": "modified", "additions": 120, "deletions": 163, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fhygiene.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -27,19 +27,18 @@\n use crate::edition::Edition;\n use crate::symbol::{kw, sym, Symbol};\n use crate::with_session_globals;\n-use crate::{BytePos, CachingSourceMapView, HashStableContext, SourceFile, Span, DUMMY_SP};\n+use crate::{HashStableContext, Span, DUMMY_SP};\n \n-use crate::def_id::{CrateNum, DefId, DefPathHash, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::{Lock, Lrc};\n+use rustc_data_structures::unhash::UnhashMap;\n use rustc_macros::HashStable_Generic;\n use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n-use std::cell::RefCell;\n use std::fmt;\n use std::hash::Hash;\n-use std::thread::LocalKey;\n use tracing::*;\n \n /// A `SyntaxContext` represents a chain of pairs `(ExpnId, Transparency)` named \"marks\".\n@@ -63,6 +62,10 @@ pub struct SyntaxContextData {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub struct ExpnId(u32);\n \n+/// A unique hash value associated to an expansion.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, Encodable, Decodable, HashStable_Generic)]\n+pub struct ExpnHash(Fingerprint);\n+\n /// A property of a macro expansion that determines how identifiers\n /// produced by that expansion are resolved.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Hash, Debug, Encodable, Decodable)]\n@@ -84,12 +87,13 @@ pub enum Transparency {\n }\n \n impl ExpnId {\n-    pub fn fresh(expn_data: Option<ExpnData>) -> Self {\n-        let has_data = expn_data.is_some();\n-        let expn_id = HygieneData::with(|data| data.fresh_expn(expn_data));\n-        if has_data {\n-            update_disambiguator(expn_id);\n-        }\n+    pub fn fresh_empty() -> Self {\n+        HygieneData::with(|data| data.fresh_expn(None))\n+    }\n+\n+    pub fn fresh(expn_data: ExpnData, ctx: impl HashStableContext) -> Self {\n+        let expn_id = HygieneData::with(|data| data.fresh_expn(Some(expn_data)));\n+        update_disambiguator(expn_id, ctx);\n         expn_id\n     }\n \n@@ -109,21 +113,31 @@ impl ExpnId {\n         ExpnId(raw)\n     }\n \n+    #[inline]\n+    pub fn expn_hash(self) -> ExpnHash {\n+        HygieneData::with(|data| data.expn_hash(self))\n+    }\n+\n+    #[inline]\n+    pub fn from_hash(hash: ExpnHash) -> Option<ExpnId> {\n+        HygieneData::with(|data| data.expn_hash_to_expn_id.get(&hash).copied())\n+    }\n+\n     #[inline]\n     pub fn expn_data(self) -> ExpnData {\n         HygieneData::with(|data| data.expn_data(self).clone())\n     }\n \n     #[inline]\n-    pub fn set_expn_data(self, mut expn_data: ExpnData) {\n+    pub fn set_expn_data(self, mut expn_data: ExpnData, ctx: impl HashStableContext) {\n         HygieneData::with(|data| {\n             let old_expn_data = &mut data.expn_data[self.0 as usize];\n             assert!(old_expn_data.is_none(), \"expansion data is reset for an expansion ID\");\n             assert_eq!(expn_data.orig_id, None);\n             expn_data.orig_id = Some(self.as_u32());\n             *old_expn_data = Some(expn_data);\n         });\n-        update_disambiguator(self)\n+        update_disambiguator(self, ctx)\n     }\n \n     pub fn is_descendant_of(self, ancestor: ExpnId) -> bool {\n@@ -162,6 +176,8 @@ pub struct HygieneData {\n     /// between creation of an expansion ID and obtaining its data (e.g. macros are collected\n     /// first and then resolved later), so we use an `Option` here.\n     expn_data: Vec<Option<ExpnData>>,\n+    expn_hashes: Vec<ExpnHash>,\n+    expn_hash_to_expn_id: UnhashMap<ExpnHash, ExpnId>,\n     syntax_context_data: Vec<SyntaxContextData>,\n     syntax_context_map: FxHashMap<(SyntaxContext, ExpnId, Transparency), SyntaxContext>,\n     /// Maps the `Fingerprint` of an `ExpnData` to the next disambiguator value.\n@@ -185,6 +201,9 @@ impl HygieneData {\n \n         HygieneData {\n             expn_data: vec![Some(root_data)],\n+            expn_hashes: vec![ExpnHash(Fingerprint::ZERO)],\n+            expn_hash_to_expn_id: std::iter::once((ExpnHash(Fingerprint::ZERO), ExpnId(0)))\n+                .collect(),\n             syntax_context_data: vec![SyntaxContextData {\n                 outer_expn: ExpnId::root(),\n                 outer_transparency: Transparency::Opaque,\n@@ -209,9 +228,15 @@ impl HygieneData {\n             data.orig_id = Some(raw_id);\n         }\n         self.expn_data.push(expn_data);\n+        self.expn_hashes.push(ExpnHash(Fingerprint::ZERO));\n         ExpnId(raw_id)\n     }\n \n+    #[inline]\n+    fn expn_hash(&self, expn_id: ExpnId) -> ExpnHash {\n+        self.expn_hashes[expn_id.0 as usize]\n+    }\n+\n     fn expn_data(&self, expn_id: ExpnId) -> &ExpnData {\n         self.expn_data[expn_id.0 as usize].as_ref().expect(\"no expansion data for an expansion ID\")\n     }\n@@ -661,16 +686,17 @@ impl Span {\n     /// other compiler-generated code to set per-span properties like allowed unstable features.\n     /// The returned span belongs to the created expansion and has the new properties,\n     /// but its location is inherited from the current span.\n-    pub fn fresh_expansion(self, expn_data: ExpnData) -> Span {\n-        self.fresh_expansion_with_transparency(expn_data, Transparency::Transparent)\n+    pub fn fresh_expansion(self, expn_data: ExpnData, ctx: impl HashStableContext) -> Span {\n+        self.fresh_expansion_with_transparency(expn_data, Transparency::Transparent, ctx)\n     }\n \n     pub fn fresh_expansion_with_transparency(\n         self,\n         expn_data: ExpnData,\n         transparency: Transparency,\n+        ctx: impl HashStableContext,\n     ) -> Span {\n-        let expn_id = ExpnId::fresh(Some(expn_data));\n+        let expn_id = ExpnId::fresh(expn_data, ctx);\n         HygieneData::with(|data| {\n             self.with_ctxt(data.apply_mark(SyntaxContext::root(), expn_id, transparency))\n         })\n@@ -683,11 +709,13 @@ impl Span {\n         allow_internal_unstable: Option<Lrc<[Symbol]>>,\n         reason: DesugaringKind,\n         edition: Edition,\n+        ctx: impl HashStableContext,\n     ) -> Span {\n-        self.fresh_expansion(ExpnData {\n+        let expn_data = ExpnData {\n             allow_internal_unstable,\n             ..ExpnData::default(ExpnKind::Desugaring(reason), self, edition, None, None)\n-        })\n+        };\n+        self.fresh_expansion(expn_data, ctx)\n     }\n }\n \n@@ -839,6 +867,13 @@ impl ExpnData {\n     pub fn is_root(&self) -> bool {\n         matches!(self.kind, ExpnKind::Root)\n     }\n+\n+    #[inline]\n+    fn hash_expn(&self, ctx: &mut impl HashStableContext) -> Fingerprint {\n+        let mut hasher = StableHasher::new();\n+        self.hash_stable(ctx, &mut hasher);\n+        hasher.finish()\n+    }\n }\n \n /// Expansion kind.\n@@ -985,16 +1020,11 @@ pub struct HygieneEncodeContext {\n }\n \n impl HygieneEncodeContext {\n-    pub fn encode<\n-        T,\n-        R,\n-        F: FnMut(&mut T, u32, &SyntaxContextData) -> Result<(), R>,\n-        G: FnMut(&mut T, u32, &ExpnData) -> Result<(), R>,\n-    >(\n+    pub fn encode<T, R>(\n         &self,\n         encoder: &mut T,\n-        mut encode_ctxt: F,\n-        mut encode_expn: G,\n+        mut encode_ctxt: impl FnMut(&mut T, u32, &SyntaxContextData) -> Result<(), R>,\n+        mut encode_expn: impl FnMut(&mut T, u32, ExpnData, ExpnHash) -> Result<(), R>,\n     ) -> Result<(), R> {\n         // When we serialize a `SyntaxContextData`, we may end up serializing\n         // a `SyntaxContext` that we haven't seen before\n@@ -1012,7 +1042,7 @@ impl HygieneEncodeContext {\n             // It's fine to iterate over a HashMap, because the serialization\n             // of the table that we insert data into doesn't depend on insertion\n             // order\n-            for_all_ctxts_in(latest_ctxts.into_iter(), |(index, ctxt, data)| {\n+            for_all_ctxts_in(latest_ctxts.into_iter(), |index, ctxt, data| {\n                 if self.serialized_ctxts.lock().insert(ctxt) {\n                     encode_ctxt(encoder, index, data)?;\n                 }\n@@ -1021,9 +1051,9 @@ impl HygieneEncodeContext {\n \n             let latest_expns = { std::mem::take(&mut *self.latest_expns.lock()) };\n \n-            for_all_expns_in(latest_expns.into_iter(), |index, expn, data| {\n+            for_all_expns_in(latest_expns.into_iter(), |index, expn, data, hash| {\n                 if self.serialized_expns.lock().insert(expn) {\n-                    encode_expn(encoder, index, data)?;\n+                    encode_expn(encoder, index, data, hash)?;\n                 }\n                 Ok(())\n             })?;\n@@ -1046,16 +1076,14 @@ pub struct HygieneDecodeContext {\n     remapped_expns: Lock<Vec<Option<ExpnId>>>,\n }\n \n-pub fn decode_expn_id<\n-    'a,\n-    D: Decoder,\n-    F: FnOnce(&mut D, u32) -> Result<ExpnData, D::Error>,\n-    G: FnOnce(CrateNum) -> &'a HygieneDecodeContext,\n->(\n+pub fn decode_expn_id<'a, D: Decoder, G>(\n     d: &mut D,\n     mode: ExpnDataDecodeMode<'a, G>,\n-    decode_data: F,\n-) -> Result<ExpnId, D::Error> {\n+    decode_data: impl FnOnce(&mut D, u32) -> Result<(ExpnData, ExpnHash), D::Error>,\n+) -> Result<ExpnId, D::Error>\n+where\n+    G: FnOnce(CrateNum) -> &'a HygieneDecodeContext,\n+{\n     let index = u32::decode(d)?;\n     let context = match mode {\n         ExpnDataDecodeMode::IncrComp(context) => context,\n@@ -1083,9 +1111,13 @@ pub fn decode_expn_id<\n \n     // Don't decode the data inside `HygieneData::with`, since we need to recursively decode\n     // other ExpnIds\n-    let mut expn_data = decode_data(d, index)?;\n+    let (mut expn_data, hash) = decode_data(d, index)?;\n \n     let expn_id = HygieneData::with(|hygiene_data| {\n+        if let Some(&expn_id) = hygiene_data.expn_hash_to_expn_id.get(&hash) {\n+            return expn_id;\n+        }\n+\n         let expn_id = ExpnId(hygiene_data.expn_data.len() as u32);\n \n         // If we just deserialized an `ExpnData` owned by\n@@ -1098,6 +1130,9 @@ pub fn decode_expn_id<\n         }\n \n         hygiene_data.expn_data.push(Some(expn_data));\n+        hygiene_data.expn_hashes.push(hash);\n+        let _old_id = hygiene_data.expn_hash_to_expn_id.insert(hash, expn_id);\n+        debug_assert!(_old_id.is_none());\n \n         let mut expns = outer_expns.lock();\n         let new_len = index as usize + 1;\n@@ -1184,28 +1219,34 @@ pub fn decode_syntax_context<\n     Ok(new_ctxt)\n }\n \n-fn for_all_ctxts_in<E, F: FnMut((u32, SyntaxContext, &SyntaxContextData)) -> Result<(), E>>(\n+fn for_all_ctxts_in<E, F: FnMut(u32, SyntaxContext, &SyntaxContextData) -> Result<(), E>>(\n     ctxts: impl Iterator<Item = SyntaxContext>,\n     mut f: F,\n ) -> Result<(), E> {\n     let all_data: Vec<_> = HygieneData::with(|data| {\n         ctxts.map(|ctxt| (ctxt, data.syntax_context_data[ctxt.0 as usize].clone())).collect()\n     });\n     for (ctxt, data) in all_data.into_iter() {\n-        f((ctxt.0, ctxt, &data))?;\n+        f(ctxt.0, ctxt, &data)?;\n     }\n     Ok(())\n }\n \n-fn for_all_expns_in<E, F: FnMut(u32, ExpnId, &ExpnData) -> Result<(), E>>(\n+fn for_all_expns_in<E>(\n     expns: impl Iterator<Item = ExpnId>,\n-    mut f: F,\n+    mut f: impl FnMut(u32, ExpnId, ExpnData, ExpnHash) -> Result<(), E>,\n ) -> Result<(), E> {\n     let all_data: Vec<_> = HygieneData::with(|data| {\n-        expns.map(|expn| (expn, data.expn_data[expn.0 as usize].clone())).collect()\n+        expns\n+            .map(|expn| {\n+                let idx = expn.0 as usize;\n+                (expn, data.expn_data[idx].clone(), data.expn_hashes[idx].clone())\n+            })\n+            .collect()\n     });\n-    for (expn, data) in all_data.into_iter() {\n-        f(expn.0, expn, &data.unwrap_or_else(|| panic!(\"Missing data for {:?}\", expn)))?;\n+    for (expn, data, hash) in all_data.into_iter() {\n+        let data = data.unwrap_or_else(|| panic!(\"Missing data for {:?}\", expn));\n+        f(expn.0, expn, data, hash)?;\n     }\n     Ok(())\n }\n@@ -1306,107 +1347,51 @@ impl<D: Decoder> Decodable<D> for SyntaxContext {\n /// `set_expn_data`). It is *not* called for foreign `ExpnId`s deserialized\n /// from another crate's metadata - since `ExpnData` includes a `krate` field,\n /// collisions are only possible between `ExpnId`s within the same crate.\n-fn update_disambiguator(expn_id: ExpnId) {\n-    /// A `HashStableContext` which hashes the raw id values for `DefId`\n-    /// and `CrateNum`, rather than using their computed stable hash.\n-    ///\n-    /// This allows us to use the `HashStable` implementation on `ExpnId`\n-    /// early on in compilation, before we've constructed a `TyCtxt`.\n-    /// The `Fingerprint`s created by this context are not 'stable', since\n-    /// the raw `CrateNum` and `DefId` values for an item may change between\n-    /// sessions due to unrelated changes (e.g. adding/removing an different item).\n-    ///\n-    /// However, this is fine for our purposes - we only need to detect\n-    /// when two `ExpnData`s have the same `Fingerprint`. Since the hashes produced\n-    /// by this context still obey the properties of `HashStable`, we have\n-    /// that\n-    /// `hash_stable(expn1, DummyHashStableContext) == hash_stable(expn2, DummyHashStableContext)`\n-    /// iff `hash_stable(expn1, StableHashingContext) == hash_stable(expn2, StableHasingContext)`.\n-    ///\n-    /// This is sufficient for determining when we need to update the disambiguator.\n-    struct DummyHashStableContext<'a> {\n-        caching_source_map: CachingSourceMapView<'a>,\n-    }\n-\n-    impl<'a> crate::HashStableContext for DummyHashStableContext<'a> {\n-        #[inline]\n-        fn def_path_hash(&self, def_id: DefId) -> DefPathHash {\n-            DefPathHash(Fingerprint::new(\n-                def_id.krate.as_u32().into(),\n-                def_id.index.as_u32().into(),\n-            ))\n-        }\n-\n-        fn expn_id_cache() -> &'static LocalKey<ExpnIdCache> {\n-            // This cache is only used by `DummyHashStableContext`,\n-            // so we won't pollute the cache values of the normal `StableHashingContext`\n-            thread_local! {\n-                static CACHE: ExpnIdCache = const { ExpnIdCache::new(Vec::new()) };\n-            }\n-\n-            &CACHE\n-        }\n-\n-        fn hash_spans(&self) -> bool {\n-            true\n-        }\n-        fn span_data_to_lines_and_cols(\n-            &mut self,\n-            span: &crate::SpanData,\n-        ) -> Option<(Lrc<SourceFile>, usize, BytePos, usize, BytePos)> {\n-            self.caching_source_map.span_data_to_lines_and_cols(span)\n-        }\n-    }\n-\n-    let source_map = with_session_globals(|session_globals| {\n-        session_globals.source_map.borrow().as_ref().unwrap().clone()\n-    });\n-\n-    let mut ctx =\n-        DummyHashStableContext { caching_source_map: CachingSourceMapView::new(&source_map) };\n-\n-    let mut hasher = StableHasher::new();\n-\n-    let expn_data = expn_id.expn_data();\n+fn update_disambiguator(expn_id: ExpnId, mut ctx: impl HashStableContext) {\n+    let mut expn_data = expn_id.expn_data();\n     // This disambiguator should not have been set yet.\n     assert_eq!(\n         expn_data.disambiguator, 0,\n         \"Already set disambiguator for ExpnData: {:?}\",\n         expn_data\n     );\n-    expn_data.hash_stable(&mut ctx, &mut hasher);\n-    let first_hash = hasher.finish();\n+    let mut expn_hash = expn_data.hash_expn(&mut ctx);\n \n-    let modified = HygieneData::with(|data| {\n+    let disambiguator = HygieneData::with(|data| {\n         // If this is the first ExpnData with a given hash, then keep our\n         // disambiguator at 0 (the default u32 value)\n-        let disambig = data.expn_data_disambiguators.entry(first_hash).or_default();\n-        data.expn_data[expn_id.0 as usize].as_mut().unwrap().disambiguator = *disambig;\n+        let disambig = data.expn_data_disambiguators.entry(expn_hash).or_default();\n+        let disambiguator = *disambig;\n         *disambig += 1;\n-\n-        *disambig != 1\n+        disambiguator\n     });\n \n-    if modified {\n-        debug!(\"Set disambiguator for {:?} (hash {:?})\", expn_id, first_hash);\n-        debug!(\"expn_data = {:?}\", expn_id.expn_data());\n+    if disambiguator != 0 {\n+        debug!(\"Set disambiguator for {:?} (hash {:?})\", expn_id, expn_hash);\n+        debug!(\"expn_data = {:?}\", expn_data);\n+\n+        expn_data.disambiguator = disambiguator;\n+        expn_hash = expn_data.hash_expn(&mut ctx);\n \n         // Verify that the new disambiguator makes the hash unique\n         #[cfg(debug_assertions)]\n-        {\n-            hasher = StableHasher::new();\n-            expn_id.expn_data().hash_stable(&mut ctx, &mut hasher);\n-            let new_hash: Fingerprint = hasher.finish();\n-\n-            HygieneData::with(|data| {\n-                assert_eq!(\n-                    data.expn_data_disambiguators.get(&new_hash),\n-                    None,\n-                    \"Hash collision after disambiguator update!\",\n-                );\n-            });\n-        };\n+        HygieneData::with(|data| {\n+            assert_eq!(\n+                data.expn_data_disambiguators.get(&expn_hash),\n+                None,\n+                \"Hash collision after disambiguator update!\",\n+            );\n+        });\n     }\n+\n+    let expn_hash = ExpnHash(expn_hash);\n+    HygieneData::with(|data| {\n+        data.expn_data[expn_id.0 as usize].as_mut().unwrap().disambiguator = disambiguator;\n+        debug_assert_eq!(data.expn_hashes[expn_id.0 as usize].0, Fingerprint::ZERO);\n+        data.expn_hashes[expn_id.0 as usize] = expn_hash;\n+        let _old_id = data.expn_hash_to_expn_id.insert(expn_hash, expn_id);\n+        debug_assert!(_old_id.is_none());\n+    });\n }\n \n impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {\n@@ -1425,43 +1410,15 @@ impl<CTX: HashStableContext> HashStable<CTX> for SyntaxContext {\n     }\n }\n \n-pub type ExpnIdCache = RefCell<Vec<Option<Fingerprint>>>;\n-\n impl<CTX: HashStableContext> HashStable<CTX> for ExpnId {\n     fn hash_stable(&self, ctx: &mut CTX, hasher: &mut StableHasher) {\n-        const TAG_ROOT: u8 = 0;\n-        const TAG_NOT_ROOT: u8 = 1;\n-\n-        if *self == ExpnId::root() {\n-            TAG_ROOT.hash_stable(ctx, hasher);\n-            return;\n-        }\n-\n-        // Since the same expansion context is usually referenced many\n-        // times, we cache a stable hash of it and hash that instead of\n-        // recursing every time.\n-        let index = self.as_u32() as usize;\n-        let res = CTX::expn_id_cache().with(|cache| cache.borrow().get(index).copied().flatten());\n-\n-        if let Some(res) = res {\n-            res.hash_stable(ctx, hasher);\n+        let hash = if *self == ExpnId::root() {\n+            // Avoid fetching TLS storage for a trivial often-used value.\n+            Fingerprint::ZERO\n         } else {\n-            let new_len = index + 1;\n-\n-            let mut sub_hasher = StableHasher::new();\n-            TAG_NOT_ROOT.hash_stable(ctx, &mut sub_hasher);\n-            self.expn_data().hash_stable(ctx, &mut sub_hasher);\n-            let sub_hash: Fingerprint = sub_hasher.finish();\n+            self.expn_hash().0\n+        };\n \n-            CTX::expn_id_cache().with(|cache| {\n-                let mut cache = cache.borrow_mut();\n-                if cache.len() < new_len {\n-                    cache.resize(new_len, None);\n-                }\n-                let prev = cache[index].replace(sub_hash);\n-                assert_eq!(prev, None, \"Cache slot was filled\");\n-            });\n-            sub_hash.hash_stable(ctx, hasher);\n-        }\n+        hash.hash_stable(ctx, hasher);\n     }\n }"}, {"sha": "7a1ee20ee79518ff4aeb1b794f9393cbbb2b55e0", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616ce3c5c029446ef8b0d7a3525f96b2e451840c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=616ce3c5c029446ef8b0d7a3525f96b2e451840c", "patch": "@@ -37,8 +37,8 @@ pub mod edition;\n use edition::Edition;\n pub mod hygiene;\n use hygiene::Transparency;\n-pub use hygiene::{DesugaringKind, ExpnData, ExpnId, ExpnKind, ForLoopLoc, MacroKind};\n-pub use hygiene::{ExpnIdCache, SyntaxContext};\n+pub use hygiene::{DesugaringKind, ExpnKind, ForLoopLoc, MacroKind};\n+pub use hygiene::{ExpnData, ExpnHash, ExpnId, SyntaxContext};\n pub mod def_id;\n use def_id::{CrateNum, DefId, DefPathHash, LOCAL_CRATE};\n pub mod lev_distance;\n@@ -61,7 +61,6 @@ use std::hash::Hash;\n use std::ops::{Add, Range, Sub};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n-use std::thread::LocalKey;\n \n use md5::Md5;\n use sha1::Digest;\n@@ -1956,11 +1955,6 @@ impl InnerSpan {\n /// instead of implementing everything in rustc_middle.\n pub trait HashStableContext {\n     fn def_path_hash(&self, def_id: DefId) -> DefPathHash;\n-    /// Obtains a cache for storing the `Fingerprint` of an `ExpnId`.\n-    /// This method allows us to have multiple `HashStableContext` implementations\n-    /// that hash things in a different way, without the results of one polluting\n-    /// the cache of the other.\n-    fn expn_id_cache() -> &'static LocalKey<ExpnIdCache>;\n     fn hash_spans(&self) -> bool;\n     fn span_data_to_lines_and_cols(\n         &mut self,"}]}