{"sha": "8c86773fd37b26924d53cea518a136860e620265", "node_id": "C_kwDOAAsO6NoAKDhjODY3NzNmZDM3YjI2OTI0ZDUzY2VhNTE4YTEzNjg2MGU2MjAyNjU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-19T19:04:55Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-12-19T19:04:55Z"}, "message": "Make fast-path for implied  wf lint better", "tree": {"sha": "c458111fa24439aa16343bb21b2709d99df2fcfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c458111fa24439aa16343bb21b2709d99df2fcfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c86773fd37b26924d53cea518a136860e620265", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c86773fd37b26924d53cea518a136860e620265", "html_url": "https://github.com/rust-lang/rust/commit/8c86773fd37b26924d53cea518a136860e620265", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c86773fd37b26924d53cea518a136860e620265/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c40ededa10439e64f20ee45f3cdd50d893f20438", "url": "https://api.github.com/repos/rust-lang/rust/commits/c40ededa10439e64f20ee45f3cdd50d893f20438", "html_url": "https://github.com/rust-lang/rust/commit/c40ededa10439e64f20ee45f3cdd50d893f20438"}], "stats": {"total": 163, "additions": 92, "deletions": 71}, "files": [{"sha": "cddd307c13dbbe72d07c7259a8f41770ac83bef2", "filename": "compiler/rustc_hir_analysis/src/check/compare_method.rs", "status": "modified", "additions": 92, "deletions": 71, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/8c86773fd37b26924d53cea518a136860e620265/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c86773fd37b26924d53cea518a136860e620265/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=8c86773fd37b26924d53cea518a136860e620265", "patch": "@@ -71,8 +71,14 @@ pub(crate) fn compare_impl_method<'tcx>(\n         return;\n     }\n \n-    if let Err(_) = compare_predicate_entailment(tcx, impl_m, impl_m_span, trait_m, impl_trait_ref)\n-    {\n+    if let Err(_) = compare_predicate_entailment(\n+        tcx,\n+        impl_m,\n+        impl_m_span,\n+        trait_m,\n+        impl_trait_ref,\n+        CheckImpliedWfMode::Check,\n+    ) {\n         return;\n     }\n }\n@@ -150,6 +156,7 @@ fn compare_predicate_entailment<'tcx>(\n     impl_m_span: Span,\n     trait_m: &ty::AssocItem,\n     impl_trait_ref: ty::TraitRef<'tcx>,\n+    check_implied_wf: CheckImpliedWfMode,\n ) -> Result<(), ErrorGuaranteed> {\n     let trait_to_impl_substs = impl_trait_ref.substs;\n \n@@ -304,92 +311,106 @@ fn compare_predicate_entailment<'tcx>(\n         return Err(emitted);\n     }\n \n-    // Check that all obligations are satisfied by the implementation's\n-    // version.\n-    let errors = ocx.select_all_or_error();\n-    if !errors.is_empty() {\n-        let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n-        return Err(reported);\n+    if check_implied_wf == CheckImpliedWfMode::Check {\n+        // We need to check that the impl's args are well-formed given\n+        // the hybrid param-env (impl + trait method where-clauses).\n+        ocx.register_obligation(traits::Obligation::new(\n+            infcx.tcx,\n+            ObligationCause::dummy(),\n+            param_env,\n+            ty::Binder::dummy(ty::PredicateKind::WellFormed(unnormalized_impl_fty.into())),\n+        ));\n     }\n-\n-    // FIXME(compiler-errors): This can be removed when IMPLIED_BOUNDS_ENTAILMENT\n-    // becomes a hard error.\n-    let lint_infcx = infcx.fork();\n-\n-    // Finally, resolve all regions. This catches wily misuses of\n-    // lifetime parameters.\n-    let outlives_environment = OutlivesEnvironment::with_bounds(\n-        param_env,\n-        Some(infcx),\n-        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys.clone()),\n-    );\n-    if let Some(guar) = infcx.check_region_obligations_and_report_errors(\n-        impl_m.def_id.expect_local(),\n-        &outlives_environment,\n-    ) {\n-        return Err(guar);\n-    }\n-\n-    // FIXME(compiler-errors): This can be simplified when IMPLIED_BOUNDS_ENTAILMENT\n-    // becomes a hard error (i.e. ideally we'd just register a WF obligation above...)\n-    lint_implied_wf_entailment(\n-        impl_m.def_id.expect_local(),\n-        lint_infcx,\n-        param_env,\n-        unnormalized_impl_fty,\n-        wf_tys,\n-    );\n-\n-    Ok(())\n-}\n-\n-fn lint_implied_wf_entailment<'tcx>(\n-    impl_m_def_id: LocalDefId,\n-    infcx: InferCtxt<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    unnormalized_impl_fty: Ty<'tcx>,\n-    wf_tys: FxIndexSet<Ty<'tcx>>,\n-) {\n-    let ocx = ObligationCtxt::new(&infcx);\n-\n-    // We need to check that the impl's args are well-formed given\n-    // the hybrid param-env (impl + trait method where-clauses).\n-    ocx.register_obligation(traits::Obligation::new(\n-        infcx.tcx,\n-        ObligationCause::dummy(),\n-        param_env,\n-        ty::Binder::dummy(ty::PredicateKind::WellFormed(unnormalized_impl_fty.into())),\n-    ));\n-\n-    let hir_id = infcx.tcx.hir().local_def_id_to_hir_id(impl_m_def_id);\n-    let lint = || {\n+    let emit_implied_wf_lint = || {\n         infcx.tcx.struct_span_lint_hir(\n             rustc_session::lint::builtin::IMPLIED_BOUNDS_ENTAILMENT,\n-            hir_id,\n-            infcx.tcx.def_span(impl_m_def_id),\n+            impl_m_hir_id,\n+            infcx.tcx.def_span(impl_m.def_id),\n             \"impl method assumes more implied bounds than the corresponding trait method\",\n             |lint| lint,\n         );\n     };\n \n+    // Check that all obligations are satisfied by the implementation's\n+    // version.\n     let errors = ocx.select_all_or_error();\n     if !errors.is_empty() {\n-        lint();\n+        match check_implied_wf {\n+            CheckImpliedWfMode::Check => {\n+                return compare_predicate_entailment(\n+                    tcx,\n+                    impl_m,\n+                    impl_m_span,\n+                    trait_m,\n+                    impl_trait_ref,\n+                    CheckImpliedWfMode::Skip,\n+                )\n+                .map(|()| {\n+                    // If the skip-mode was successful, emit a lint.\n+                    emit_implied_wf_lint();\n+                });\n+            }\n+            CheckImpliedWfMode::Skip => {\n+                let reported = infcx.err_ctxt().report_fulfillment_errors(&errors, None);\n+                return Err(reported);\n+            }\n+        }\n     }\n \n-    let outlives_environment = OutlivesEnvironment::with_bounds(\n+    // Finally, resolve all regions. This catches wily misuses of\n+    // lifetime parameters.\n+    let outlives_env = OutlivesEnvironment::with_bounds(\n         param_env,\n-        Some(&infcx),\n-        infcx.implied_bounds_tys(param_env, hir_id, wf_tys.clone()),\n+        Some(infcx),\n+        infcx.implied_bounds_tys(param_env, impl_m_hir_id, wf_tys.clone()),\n     );\n     infcx.process_registered_region_obligations(\n-        outlives_environment.region_bound_pairs(),\n-        param_env,\n+        outlives_env.region_bound_pairs(),\n+        outlives_env.param_env,\n     );\n-\n-    if !infcx.resolve_regions(&outlives_environment).is_empty() {\n-        lint();\n+    let errors = infcx.resolve_regions(&outlives_env);\n+    if !errors.is_empty() {\n+        // FIXME(compiler-errors): This can be simplified when IMPLIED_BOUNDS_ENTAILMENT\n+        // becomes a hard error (i.e. ideally we'd just call `resolve_regions_and_report_errors`\n+        match check_implied_wf {\n+            CheckImpliedWfMode::Check => {\n+                return compare_predicate_entailment(\n+                    tcx,\n+                    impl_m,\n+                    impl_m_span,\n+                    trait_m,\n+                    impl_trait_ref,\n+                    CheckImpliedWfMode::Skip,\n+                )\n+                .map(|()| {\n+                    // If the skip-mode was successful, emit a lint.\n+                    emit_implied_wf_lint();\n+                });\n+            }\n+            CheckImpliedWfMode::Skip => {\n+                if infcx.tainted_by_errors().is_none() {\n+                    infcx.err_ctxt().report_region_errors(impl_m.def_id.expect_local(), &errors);\n+                }\n+                return Err(tcx\n+                    .sess\n+                    .delay_span_bug(rustc_span::DUMMY_SP, \"error should have been emitted\"));\n+            }\n+        }\n     }\n+\n+    Ok(())\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+enum CheckImpliedWfMode {\n+    /// Checks implied well-formedness of the impl method. If it fails, we will\n+    /// re-check with `Skip`, and emit a lint if it succeeds.\n+    Check,\n+    /// Skips checking implied well-formedness of the impl method, but will emit\n+    /// a lint if the `compare_predicate_entailment` succeeded. This means that\n+    /// the reason that we had failed earlier during `Check` was due to the impl\n+    /// having stronger requirements than the trait.\n+    Skip,\n }\n \n fn compare_asyncness<'tcx>("}]}