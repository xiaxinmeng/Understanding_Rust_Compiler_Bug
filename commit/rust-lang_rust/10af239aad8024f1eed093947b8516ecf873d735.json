{"sha": "10af239aad8024f1eed093947b8516ecf873d735", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwYWYyMzlhYWQ4MDI0ZjFlZWQwOTM5NDdiODUxNmVjZjg3M2Q3MzU=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-30T00:13:15Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2015-06-30T00:13:15Z"}, "message": "unwinding start", "tree": {"sha": "e5a810185184833a9ff4f3d2d108340ad994a949", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5a810185184833a9ff4f3d2d108340ad994a949"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/10af239aad8024f1eed093947b8516ecf873d735", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/10af239aad8024f1eed093947b8516ecf873d735", "html_url": "https://github.com/rust-lang/rust/commit/10af239aad8024f1eed093947b8516ecf873d735", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/10af239aad8024f1eed093947b8516ecf873d735/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c6a46b0eee9f991a7ae6e72164550f781654c66", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c6a46b0eee9f991a7ae6e72164550f781654c66", "html_url": "https://github.com/rust-lang/rust/commit/9c6a46b0eee9f991a7ae6e72164550f781654c66"}], "stats": {"total": 116, "additions": 96, "deletions": 20}, "files": [{"sha": "f85562bd809bb41aabb4b4c112c9be5f14a77e1b", "filename": "raii.md", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/10af239aad8024f1eed093947b8516ecf873d735/raii.md", "raw_url": "https://github.com/rust-lang/rust/raw/10af239aad8024f1eed093947b8516ecf873d735/raii.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/raii.md?ref=10af239aad8024f1eed093947b8516ecf873d735", "patch": "@@ -1,6 +1,6 @@\n % The Perils Of RAII\n \n-Ownership Based Resource Management (AKA RAII: Resource Acquisition is Initialization) is\n+Ownership Based Resource Management (AKA RAII: Resource Acquisition Is Initialization) is\n something you'll interact with a lot in Rust. Especially if you use the standard library.\n \n Roughly speaking the pattern is as follows: to acquire a resource, you create an object that\n@@ -38,10 +38,8 @@ treating the old copy as uninitialized -- a no-op.\n \n While Rust provides a `Default` trait for specifying the moral equivalent of a default\n constructor, it's incredibly rare for this trait to be used. This is because variables\n-aren't implicitly initialized (see [working with uninitialized memory][uninit] for details).\n-Default is basically only useful for generic programming.\n-\n-In concrete contexts, a type will provide a static `new` method for any\n+[aren't implicitly initialized][uninit]. Default is basically only useful for generic\n+programming. In concrete contexts, a type will provide a static `new` method for any\n kind of \"default\" constructor. This has no relation to `new` in other\n languages and has no special meaning. It's just a naming convention.\n \n@@ -59,20 +57,16 @@ fn drop(&mut self);\n ```\n \n This method gives the type time to somehow finish what it was doing. **After `drop` is run,\n-Rust will recursively try to drop all of the fields of the `self` struct**. This is a\n+Rust will recursively try to drop all of the fields of `self`**. This is a\n convenience feature so that you don't have to write \"destructor boilerplate\" to drop\n children. If a struct has no special logic for being dropped other than dropping its\n children, then it means `Drop` doesn't need to be implemented at all!\n \n-**There is no way to prevent this behaviour in Rust 1.0**.\n+**There is no stable way to prevent this behaviour in Rust 1.0**.\n \n Note that taking `&mut self` means that even if you *could* suppress recursive Drop,\n Rust will prevent you from e.g. moving fields out of self. For most types, this\n-is totally fine:\n-\n-* They own all their data (they don't contain pointers to elsewhere).\n-* There's no additional state passed into drop to try to send things.\n-* `self` is about to be marked as uninitialized (and therefore inaccessible).\n+is totally fine.\n \n For instance, a custom implementation of `Box` might write `Drop` like this:\n \n@@ -120,7 +114,7 @@ impl<T> Drop for SuperBox<T> {\n }\n ```\n \n-because after we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\n+After we deallocate the `box`'s ptr in SuperBox's destructor, Rust will\n happily proceed to tell the box to Drop itself and everything will blow up with\n use-after-frees and double-frees.\n \n@@ -216,7 +210,7 @@ refers to it. The collection will sit around uselessly, holding on to its\n precious resources until the program terminates (at which point all those\n resources would have been reclaimed by the OS anyway).\n \n-We may consider a more restricted form of leak: failing to free memory that\n+We may consider a more restricted form of leak: failing to drop a value that\n is unreachable. Rust also doesn't prevent this. In fact Rust has a *function\n for doing this*: `mem::forget`. This function consumes the value it is passed\n *and then doesn't run its destructor*.\n@@ -232,26 +226,26 @@ It is reasonable for safe code to assume that destructor leaks do not happen,\n as any program that leaks destructors is probably wrong. However *unsafe* code\n cannot rely on destructors to be run to be *safe*. For most types this doesn't\n matter: if you leak the destructor then the type is *by definition* inaccessible,\n-so it doesn't matter, right? e.g. if you leak a `Box<u8>` then you waste some\n-memory but that's hardly going to violate memory-safety.\n+so it doesn't matter, right? For instance, if you leak a `Box<u8>` then you\n+waste some memory but that's hardly going to violate memory-safety.\n \n However where we must be careful with destructor leaks are *proxy* types.\n These are types which manage access to a distinct object, but don't actually\n own it. Proxy objects are quite rare. Proxy objects you'll need to care about\n-are even rarer. However we'll focus on two interesting examples in the\n+are even rarer. However we'll focus on three interesting examples in the\n standard library:\n \n * `vec::Drain`\n * `Rc`\n-\n+* `thread::scoped::JoinGuard`\n \n \n \n ## Drain\n \n `drain` is a collections API that moves data out of the container without\n consuming the container. This enables us to reuse the allocation of a `Vec`\n-after claiming ownership over all of its contents. drain produces an iterator\n+after claiming ownership over all of its contents. It produces an iterator\n (Drain) that returns the contents of the Vec by-value.\n \n Now, consider Drain in the middle of iteration: some values have been moved out,\n@@ -376,7 +370,7 @@ in memory.\n \n \n \n-## thread::scoped\n+## thread::scoped::JoinGuard\n \n The thread::scoped API intends to allow threads to be spawned that reference\n data on the stack without any synchronization over that data. Usage looked like:"}, {"sha": "cd9ca58304d35a550f2e2294946f6cdd2051715c", "filename": "unwinding.md", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/10af239aad8024f1eed093947b8516ecf873d735/unwinding.md", "raw_url": "https://github.com/rust-lang/rust/raw/10af239aad8024f1eed093947b8516ecf873d735/unwinding.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/unwinding.md?ref=10af239aad8024f1eed093947b8516ecf873d735", "patch": "@@ -0,0 +1,82 @@\n+% Unwinding\n+\n+Rust has a *tiered* error-handling scheme:\n+\n+* If something might reasonably be absent, Option is used\n+* If something goes wrong and can reasonably be handled, Result is used\n+* If something goes wrong and cannot reasonably be handled, the thread panics\n+* If something catastrophic happens, the program aborts\n+\n+Option and Result are overwhelmingly preferred in most situations, especially\n+since they can be promoted into a panic or abort at the API user's discretion.\n+However, anything and everything *can* panic, and you need to be ready for this.\n+Panics cause the thread to halt normal execution and unwind its stack, calling\n+destructors as if every function instantly returned.\n+\n+As of 1.0, Rust is of two minds when it comes to panics. In the long-long-ago,\n+Rust was much more like Erlang. Like Erlang, Rust had lightweight tasks,\n+and tasks were intended to kill themselves with a panic when they reached an\n+untenable state. Unlike an exception in Java or C++, a panic could not be\n+caught at any time. Panics could only be caught by the owner of the task, at which\n+point they had to be handled or *that* task would itself panic.\n+\n+Unwinding was important to this story because if a task's\n+destructors weren't called, it would cause memory and other system resources to\n+leak. Since tasks were expected to die during normal execution, this would make\n+Rust very poor for long-running systems!\n+\n+As the Rust we know today came to be, this style of programming grew out of\n+fashion in the push for less-and-less abstraction. Light-weight tasks were\n+killed in the name of heavy-weight OS threads. Still, panics could only be\n+caught by the parent thread. This meant catching a panic required spinning up\n+an entire OS thread! Although Rust maintains the philosophy that panics should\n+not be used for \"basic\" error-handling like C++ or Java, it is still desirable\n+to not have the entire program crash in the face of a panic.\n+\n+In the near future there will be a stable interface for catching panics in an\n+arbitrary location, though we would encourage you to still only do this\n+sparingly. In particular, Rust's current unwinding implementation is heavily\n+optimized for the \"doesn't unwind\" case. If a program doesn't unwind, there\n+should be no runtime cost for the program being *ready* to unwind. As a\n+consequence, *actually* unwinding will be more expensive than in e.g. Java.\n+Don't build your programs to unwind under normal circumstances. Ideally, you\n+should only panic for programming errors.\n+\n+\n+\n+\n+# Exception Safety\n+\n+Being ready for unwinding is often referred to as \"exception safety\"\n+in the broader programming world. In Rust, their are two levels of exception\n+safety that one may concern themselves with:\n+\n+* In unsafe code, we *must* be exception safe to the point of not violating\n+  memory safety.\n+\n+* In safe code, it is *good* to be exception safe to the point of your program\n+  doing the right thing.\n+\n+As is the case in many places in Rust, unsafe code must be ready to deal with\n+bad safe code, and that includes code that panics. Code that transiently creates\n+unsound states must be careful that a panic does not cause that state to be\n+used. Generally this means ensuring that only non-panicing code is run while\n+these states exist, or making a guard that cleans up the state in the case of\n+a panic. This does not necessarily mean that the state a panic witnesses is a\n+fully *coherent* state. We need only guarantee that it's a *safe* state.\n+\n+For instance, consider extending a Vec:\n+\n+```rust\n+\n+impl Extend<T> for Vec<T> {\n+\tfn extend<I: IntoIter<Item=T>>(&mut self, iterable: I) {\n+\t\tlet mut iter = iterable.into_iter();\n+\t\tlet size_hint = iter.size_hint().0;\n+\t\tself.reserve(size_hint);\n+\t\tself.set_len(self.len() + size_hint());\n+\n+\t\tfor\n+\t}\n+}\n+"}]}