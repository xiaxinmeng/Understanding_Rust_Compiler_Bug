{"sha": "e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YmRiMDVlOTY3NmU4NWJkZDhmYTUwMDhlM2FkYTM4MTJiMzZmZDk=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-06-24T15:07:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-06-24T15:07:37Z"}, "message": "Merge #4990\n\n4990: Introduce an ItemTree layer to avoid reparsing files r=matklad a=jonas-schievink\n\nThis reduces the latency of \"go to definition\" in a simple benchmark on rust-analyzer by around 30%.\r\n\r\ncc https://github.com/rust-analyzer/rust-analyzer/issues/1650\r\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/3485\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>", "tree": {"sha": "a21d348fbfa2d06f1fba77622c5417383938e6fe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a21d348fbfa2d06f1fba77622c5417383938e6fe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe82w5CRBK7hj4Ov3rIwAAdHIIADi88OY4x5B+haRlUi/m/1Rq\noy8krv8i6xmSsetyVim+FOY61LYCvw/mQ2/IshK3Mq108VGnZNT5C8q7/YH7sM2O\no8EYqAEBwB4W1ws+FZZHO8LMx79xDk7hlMHql7apB8hSFsrhNo2c7gUokH5gBxVP\nDkdPIWZ1BumvlI/bZXZYfb1GIMU7X9QCTHrGEIbogBEcpqNNnLxGzNVEBf0fsP5u\nFeYnt9OXF3XV+3fjjCecPY2oX9oy8DjHsgiHYShJAEOPppF7cH47eWFkW/LVpiPb\n45VzXqU50x9kxtYs0R62ajCsEXzQHSKwVhFUc0wn0RnI/4WqJyHrhIyN3wF80y0=\n=/bdL\n-----END PGP SIGNATURE-----\n", "payload": "tree a21d348fbfa2d06f1fba77622c5417383938e6fe\nparent 1a3b507a007d0373a83bde203d780b860ea55ce1\nparent 2928600374a8356c2c2bffee080c47cb0f463fb9\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593011257 +0000\ncommitter GitHub <noreply@github.com> 1593011257 +0000\n\nMerge #4990\n\n4990: Introduce an ItemTree layer to avoid reparsing files r=matklad a=jonas-schievink\n\nThis reduces the latency of \"go to definition\" in a simple benchmark on rust-analyzer by around 30%.\r\n\r\ncc https://github.com/rust-analyzer/rust-analyzer/issues/1650\r\nCloses https://github.com/rust-analyzer/rust-analyzer/issues/3485\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\nCo-authored-by: Jonas Schievink <jonas.schievink@ferrous-systems.com>\nCo-authored-by: Jonas Schievink <jonasschievink@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "html_url": "https://github.com/rust-lang/rust/commit/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a3b507a007d0373a83bde203d780b860ea55ce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a3b507a007d0373a83bde203d780b860ea55ce1", "html_url": "https://github.com/rust-lang/rust/commit/1a3b507a007d0373a83bde203d780b860ea55ce1"}, {"sha": "2928600374a8356c2c2bffee080c47cb0f463fb9", "url": "https://api.github.com/repos/rust-lang/rust/commits/2928600374a8356c2c2bffee080c47cb0f463fb9", "html_url": "https://github.com/rust-lang/rust/commit/2928600374a8356c2c2bffee080c47cb0f463fb9"}], "stats": {"total": 3644, "additions": 2594, "deletions": 1050}, "files": [{"sha": "c2d00adebc58d231bc71652801b71786802adbb3", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -1018,6 +1018,7 @@ dependencies = [\n  \"ra_syntax\",\n  \"ra_tt\",\n  \"rustc-hash\",\n+ \"smallvec\",\n  \"stdx\",\n  \"test_utils\",\n ]"}, {"sha": "3169aa5b8cc4d25f4f8a058784af309b3a144f46", "filename": "crates/ra_arena/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_arena%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_arena%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_arena%2Fsrc%2Flib.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -116,6 +116,9 @@ impl<T> Arena<T> {\n     ) -> impl Iterator<Item = (Idx<T>, &T)> + ExactSizeIterator + DoubleEndedIterator {\n         self.data.iter().enumerate().map(|(idx, value)| (Idx::from_raw(RawId(idx as u32)), value))\n     }\n+    pub fn shrink_to_fit(&mut self) {\n+        self.data.shrink_to_fit();\n+    }\n }\n \n impl<T> Default for Arena<T> {"}, {"sha": "4a3ba57dabb9b391641d94e5d60952807e04ca02", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -114,7 +114,7 @@ pub trait SourceDatabase: CheckCanceled + FileLoader + std::fmt::Debug {\n }\n \n fn parse_query(db: &impl SourceDatabase, file_id: FileId) -> Parse<ast::SourceFile> {\n-    let _p = profile(\"parse_query\");\n+    let _p = profile(\"parse_query\").detail(|| format!(\"{:?}\", file_id));\n     let text = db.file_text(file_id);\n     SourceFile::parse(&*text)\n }"}, {"sha": "a379b9f49ba648d3d0caaec637963f1bd1eec60e", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -31,10 +31,7 @@ use hir_ty::{\n };\n use ra_db::{CrateId, CrateName, Edition, FileId};\n use ra_prof::profile;\n-use ra_syntax::{\n-    ast::{self, AttrsOwner, NameOwner},\n-    AstNode,\n-};\n+use ra_syntax::ast::{self, AttrsOwner, NameOwner};\n use rustc_hash::FxHashSet;\n \n use crate::{\n@@ -205,7 +202,8 @@ impl ModuleDef {\n }\n \n pub use hir_def::{\n-    attr::Attrs, item_scope::ItemInNs, visibility::Visibility, AssocItemId, AssocItemLoc,\n+    attr::Attrs, item_scope::ItemInNs, item_tree::ItemTreeNode, visibility::Visibility,\n+    AssocItemId, AssocItemLoc,\n };\n \n impl Module {\n@@ -872,7 +870,7 @@ where\n     ID: Lookup<Data = AssocItemLoc<AST>>,\n     DEF: From<ID>,\n     CTOR: FnOnce(DEF) -> AssocItem,\n-    AST: AstNode,\n+    AST: ItemTreeNode,\n {\n     match id.lookup(db.upcast()).container {\n         AssocContainerId::TraitId(_) | AssocContainerId::ImplId(_) => Some(ctor(DEF::from(id))),"}, {"sha": "bb67952de20a3da371fd54f1e70295da93ae690b", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -6,7 +6,7 @@ pub use hir_def::db::{\n     ExprScopesQuery, FunctionDataQuery, GenericParamsQuery, ImplDataQuery, ImportMapQuery,\n     InternConstQuery, InternDatabase, InternDatabaseStorage, InternEnumQuery, InternFunctionQuery,\n     InternImplQuery, InternStaticQuery, InternStructQuery, InternTraitQuery, InternTypeAliasQuery,\n-    InternUnionQuery, LangItemQuery, ModuleLangItemsQuery, RawItemsQuery, StaticDataQuery,\n+    InternUnionQuery, ItemTreeQuery, LangItemQuery, ModuleLangItemsQuery, StaticDataQuery,\n     StructDataQuery, TraitDataQuery, TypeAliasDataQuery, UnionDataQuery,\n };\n pub use hir_expand::db::{"}, {"sha": "6d43924e3007c947970de0705475c944fba73df5", "filename": "crates/ra_hir_def/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2FCargo.toml?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -17,6 +17,7 @@ drop_bomb = \"0.1.4\"\n fst = { version = \"0.4\", default-features = false }\n itertools = \"0.9.0\"\n indexmap = \"1.4.0\"\n+smallvec = \"1.4.0\"\n \n stdx = { path = \"../stdx\" }\n "}, {"sha": "197737ffce287dd7d191a98759ff83ac22acd46b", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 32, "deletions": 17, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -13,7 +13,11 @@ use ra_syntax::{\n use tt::Subtree;\n \n use crate::{\n-    db::DefDatabase, nameres::ModuleSource, path::ModPath, src::HasChildSource, src::HasSource,\n+    db::DefDatabase,\n+    item_tree::{ItemTreeId, ItemTreeNode},\n+    nameres::ModuleSource,\n+    path::ModPath,\n+    src::HasChildSource,\n     AdtId, AttrDefId, Lookup,\n };\n \n@@ -34,6 +38,8 @@ impl ops::Deref for Attrs {\n }\n \n impl Attrs {\n+    pub const EMPTY: Attrs = Attrs { entries: None };\n+\n     pub(crate) fn attrs_query(db: &dyn DefDatabase, def: AttrDefId) -> Attrs {\n         match def {\n             AttrDefId::ModuleId(module) => {\n@@ -65,19 +71,19 @@ impl Attrs {\n                 Attrs::from_attrs_owner(db, src.map(|it| it as &dyn AttrsOwner))\n             }\n             AttrDefId::AdtId(it) => match it {\n-                AdtId::StructId(it) => attrs_from_loc(it.lookup(db), db),\n-                AdtId::EnumId(it) => attrs_from_loc(it.lookup(db), db),\n-                AdtId::UnionId(it) => attrs_from_loc(it.lookup(db), db),\n+                AdtId::StructId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                AdtId::EnumId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+                AdtId::UnionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n             },\n-            AttrDefId::TraitId(it) => attrs_from_loc(it.lookup(db), db),\n+            AttrDefId::TraitId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n             AttrDefId::MacroDefId(it) => {\n                 it.ast_id.map_or_else(Default::default, |ast_id| attrs_from_ast(ast_id, db))\n             }\n-            AttrDefId::ImplId(it) => attrs_from_loc(it.lookup(db), db),\n-            AttrDefId::ConstId(it) => attrs_from_loc(it.lookup(db), db),\n-            AttrDefId::StaticId(it) => attrs_from_loc(it.lookup(db), db),\n-            AttrDefId::FunctionId(it) => attrs_from_loc(it.lookup(db), db),\n-            AttrDefId::TypeAliasId(it) => attrs_from_loc(it.lookup(db), db),\n+            AttrDefId::ImplId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::ConstId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::StaticId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::FunctionId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n+            AttrDefId::TypeAliasId(it) => attrs_from_item_tree(it.lookup(db).id, db),\n         }\n     }\n \n@@ -103,6 +109,18 @@ impl Attrs {\n         Attrs { entries }\n     }\n \n+    pub fn merge(&self, other: Attrs) -> Attrs {\n+        match (&self.entries, &other.entries) {\n+            (None, None) => Attrs { entries: None },\n+            (Some(entries), None) | (None, Some(entries)) => {\n+                Attrs { entries: Some(entries.clone()) }\n+            }\n+            (Some(a), Some(b)) => {\n+                Attrs { entries: Some(a.iter().chain(b.iter()).cloned().collect()) }\n+            }\n+        }\n+    }\n+\n     pub fn by_key(&self, key: &'static str) -> AttrQuery<'_> {\n         AttrQuery { attrs: self, key }\n     }\n@@ -187,11 +205,8 @@ where\n     Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n }\n \n-fn attrs_from_loc<T>(node: T, db: &dyn DefDatabase) -> Attrs\n-where\n-    T: HasSource,\n-    T::Value: ast::AttrsOwner,\n-{\n-    let src = node.source(db);\n-    Attrs::from_attrs_owner(db, src.as_ref().map(|it| it as &dyn AttrsOwner))\n+fn attrs_from_item_tree<N: ItemTreeNode>(id: ItemTreeId<N>, db: &dyn DefDatabase) -> Attrs {\n+    let tree = db.item_tree(id.file_id);\n+    let mod_item = N::id_to_mod_item(id.value);\n+    tree.attrs(mod_item).clone()\n }"}, {"sha": "3ced648e56ffd9c9d255ac857f4f4b5d89821bf7", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 125, "deletions": 52, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -5,7 +5,7 @@ use either::Either;\n use hir_expand::{\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    HirFileId, MacroDefId, MacroDefKind,\n+    AstId, HirFileId, MacroDefId, MacroDefKind,\n };\n use ra_arena::Arena;\n use ra_syntax::{\n@@ -27,6 +27,7 @@ use crate::{\n         LogicOp, MatchArm, Ordering, Pat, PatId, RecordFieldPat, RecordLitField, Statement,\n     },\n     item_scope::BuiltinShadowMode,\n+    item_tree::{FileItemTreeId, ItemTree, ItemTreeNode},\n     path::{GenericArgs, Path},\n     type_ref::{Mutability, Rawness, TypeRef},\n     AdtId, ConstLoc, ContainerId, DefWithBodyId, EnumLoc, FunctionLoc, Intern, ModuleDefId,\n@@ -35,6 +36,8 @@ use crate::{\n \n use super::{ExprSource, PatSource};\n use ast::AstChildren;\n+use rustc_hash::FxHashMap;\n+use std::sync::Arc;\n \n pub(crate) struct LowerCtx {\n     hygiene: Hygiene,\n@@ -60,10 +63,10 @@ pub(super) fn lower(\n     params: Option<ast::ParamList>,\n     body: Option<ast::Expr>,\n ) -> (Body, BodySourceMap) {\n+    let item_tree = db.item_tree(expander.current_file_id);\n     ExprCollector {\n         db,\n         def,\n-        expander,\n         source_map: BodySourceMap::default(),\n         body: Body {\n             exprs: Arena::default(),\n@@ -72,6 +75,12 @@ pub(super) fn lower(\n             body_expr: dummy_expr_id(),\n             item_scope: Default::default(),\n         },\n+        item_trees: {\n+            let mut map = FxHashMap::default();\n+            map.insert(expander.current_file_id, item_tree);\n+            map\n+        },\n+        expander,\n     }\n     .collect(params, body)\n }\n@@ -82,6 +91,8 @@ struct ExprCollector<'a> {\n     expander: Expander,\n     body: Body,\n     source_map: BodySourceMap,\n+\n+    item_trees: FxHashMap<HirFileId, Arc<ItemTree>>,\n }\n \n impl ExprCollector<'_> {\n@@ -533,6 +544,9 @@ impl ExprCollector<'_> {\n                             self.source_map\n                                 .expansions\n                                 .insert(macro_call, self.expander.current_file_id);\n+\n+                            let item_tree = self.db.item_tree(self.expander.current_file_id);\n+                            self.item_trees.insert(self.expander.current_file_id, item_tree);\n                             let id = self.collect_expr(expansion);\n                             self.expander.exit(self.db, mark);\n                             id\n@@ -547,6 +561,19 @@ impl ExprCollector<'_> {\n         }\n     }\n \n+    fn find_inner_item<S: ItemTreeNode>(&self, id: AstId<ast::ModuleItem>) -> FileItemTreeId<S> {\n+        let tree = &self.item_trees[&id.file_id];\n+\n+        // FIXME: This probably breaks with `use` items, since they produce multiple item tree nodes\n+\n+        // Root file (non-macro).\n+        tree.all_inner_items()\n+            .chain(tree.top_level_items().iter().copied())\n+            .filter_map(|mod_item| mod_item.downcast::<S>())\n+            .find(|tree_id| tree[*tree_id].ast_id().upcast() == id.value)\n+            .unwrap_or_else(|| panic!(\"couldn't find inner item for {:?}\", id))\n+    }\n+\n     fn collect_expr_opt(&mut self, expr: Option<ast::Expr>) -> ExprId {\n         if let Some(expr) = expr {\n             self.collect_expr(expr)\n@@ -578,56 +605,102 @@ impl ExprCollector<'_> {\n \n     fn collect_block_items(&mut self, block: &ast::BlockExpr) {\n         let container = ContainerId::DefWithBodyId(self.def);\n-        for item in block.items() {\n-            let (def, name): (ModuleDefId, Option<ast::Name>) = match item {\n-                ast::ModuleItem::FnDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (\n-                        FunctionLoc { container: container.into(), ast_id }.intern(self.db).into(),\n-                        def.name(),\n-                    )\n-                }\n-                ast::ModuleItem::TypeAliasDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (\n-                        TypeAliasLoc { container: container.into(), ast_id }.intern(self.db).into(),\n-                        def.name(),\n-                    )\n-                }\n-                ast::ModuleItem::ConstDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (\n-                        ConstLoc { container: container.into(), ast_id }.intern(self.db).into(),\n-                        def.name(),\n-                    )\n-                }\n-                ast::ModuleItem::StaticDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (StaticLoc { container, ast_id }.intern(self.db).into(), def.name())\n-                }\n-                ast::ModuleItem::StructDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (StructLoc { container, ast_id }.intern(self.db).into(), def.name())\n-                }\n-                ast::ModuleItem::EnumDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (EnumLoc { container, ast_id }.intern(self.db).into(), def.name())\n-                }\n-                ast::ModuleItem::UnionDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (UnionLoc { container, ast_id }.intern(self.db).into(), def.name())\n-                }\n-                ast::ModuleItem::TraitDef(def) => {\n-                    let ast_id = self.expander.ast_id(&def);\n-                    (TraitLoc { container, ast_id }.intern(self.db).into(), def.name())\n-                }\n-                ast::ModuleItem::ExternBlock(_) => continue, // FIXME: collect from extern blocks\n-                ast::ModuleItem::ImplDef(_)\n-                | ast::ModuleItem::UseItem(_)\n-                | ast::ModuleItem::ExternCrateItem(_)\n-                | ast::ModuleItem::Module(_)\n-                | ast::ModuleItem::MacroCall(_) => continue,\n-            };\n+\n+        let items = block\n+            .items()\n+            .filter_map(|item| {\n+                let (def, name): (ModuleDefId, Option<ast::Name>) = match item {\n+                    ast::ModuleItem::FnDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            FunctionLoc { container: container.into(), id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::TypeAliasDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            TypeAliasLoc { container: container.into(), id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::ConstDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            ConstLoc { container: container.into(), id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::StaticDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            StaticLoc { container, id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::StructDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            StructLoc { container, id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::EnumDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            EnumLoc { container, id: ast_id.with_value(id) }.intern(self.db).into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::UnionDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            UnionLoc { container, id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::TraitDef(def) => {\n+                        let ast_id = self.expander.ast_id(&def);\n+                        let id = self.find_inner_item(ast_id.map(|id| id.upcast()));\n+                        (\n+                            TraitLoc { container, id: ast_id.with_value(id) }\n+                                .intern(self.db)\n+                                .into(),\n+                            def.name(),\n+                        )\n+                    }\n+                    ast::ModuleItem::ExternBlock(_) => return None, // FIXME: collect from extern blocks\n+                    ast::ModuleItem::ImplDef(_)\n+                    | ast::ModuleItem::UseItem(_)\n+                    | ast::ModuleItem::ExternCrateItem(_)\n+                    | ast::ModuleItem::Module(_)\n+                    | ast::ModuleItem::MacroCall(_) => return None,\n+                };\n+\n+                Some((def, name))\n+            })\n+            .collect::<Vec<_>>();\n+\n+        for (def, name) in items {\n             self.body.item_scope.define_def(def);\n             if let Some(name) = name {\n                 let vis = crate::visibility::Visibility::Public; // FIXME determine correctly"}, {"sha": "81397b06318db48cb6a01a0e9663e858c8d787e5", "filename": "crates/ra_hir_def/src/body/scope.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Fscope.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -317,6 +317,26 @@ fn foo() {\n         );\n     }\n \n+    #[test]\n+    fn macro_inner_item() {\n+        do_check(\n+            r\"\n+            macro_rules! mac {\n+                () => {{\n+                    fn inner() {}\n+                    inner();\n+                }};\n+            }\n+\n+            fn foo() {\n+                mac!();\n+                <|>\n+            }\n+        \",\n+            &[],\n+        );\n+    }\n+\n     fn do_check_local_name(ra_fixture: &str, expected_offset: u32) {\n         let (db, position) = TestDB::with_position(ra_fixture);\n         let file_id = position.file_id;"}, {"sha": "f9e5701db2b37943f66f419d0f752d5823c4b0cb", "filename": "crates/ra_hir_def/src/data.rs", "status": "modified", "additions": 137, "deletions": 245, "changes": 382, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdata.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -2,27 +2,19 @@\n \n use std::sync::Arc;\n \n-use hir_expand::{\n-    hygiene::Hygiene,\n-    name::{name, AsName, Name},\n-    AstId, InFile,\n-};\n+use hir_expand::{name::Name, InFile};\n use ra_prof::profile;\n-use ra_syntax::ast::{\n-    self, AssocItem, AstNode, ModuleItemOwner, NameOwner, TypeAscriptionOwner, TypeBoundsOwner,\n-    VisibilityOwner,\n-};\n+use ra_syntax::ast;\n \n use crate::{\n     attr::Attrs,\n-    body::LowerCtx,\n+    body::Expander,\n     db::DefDatabase,\n-    path::{path, AssociatedTypeBinding, GenericArgs, Path},\n-    src::HasSource,\n-    type_ref::{Mutability, TypeBound, TypeRef},\n+    item_tree::{AssocItem, ItemTreeId, ModItem},\n+    type_ref::{TypeBound, TypeRef},\n     visibility::RawVisibility,\n-    AssocContainerId, AssocItemId, ConstId, ConstLoc, Expander, FunctionId, FunctionLoc, HasModule,\n-    ImplId, Intern, Lookup, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n+    AssocContainerId, AssocItemId, ConstId, ConstLoc, FunctionId, FunctionLoc, HasModule, ImplId,\n+    Intern, Lookup, ModuleId, StaticId, TraitId, TypeAliasId, TypeAliasLoc,\n };\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n@@ -41,82 +33,27 @@ pub struct FunctionData {\n impl FunctionData {\n     pub(crate) fn fn_data_query(db: &impl DefDatabase, func: FunctionId) -> Arc<FunctionData> {\n         let loc = func.lookup(db);\n-        let src = loc.source(db);\n-        let ctx = LowerCtx::new(db, src.file_id);\n-        let name = src.value.name().map(|n| n.as_name()).unwrap_or_else(Name::missing);\n-        let mut params = Vec::new();\n-        let mut has_self_param = false;\n-        if let Some(param_list) = src.value.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n-                    TypeRef::from_ast(&ctx, type_ref)\n-                } else {\n-                    let self_type = TypeRef::Path(name![Self].into());\n-                    match self_param.kind() {\n-                        ast::SelfParamKind::Owned => self_type,\n-                        ast::SelfParamKind::Ref => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n-                        }\n-                        ast::SelfParamKind::MutRef => {\n-                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n-                        }\n-                    }\n-                };\n-                params.push(self_type);\n-                has_self_param = true;\n-            }\n-            for param in param_list.params() {\n-                let type_ref = TypeRef::from_ast_opt(&ctx, param.ascribed_type());\n-                params.push(type_ref);\n-            }\n-        }\n-        let attrs = Attrs::new(&src.value, &Hygiene::new(db.upcast(), src.file_id));\n-\n-        let ret_type = if let Some(type_ref) = src.value.ret_type().and_then(|rt| rt.type_ref()) {\n-            TypeRef::from_ast(&ctx, type_ref)\n-        } else {\n-            TypeRef::unit()\n-        };\n-\n-        let ret_type = if src.value.async_token().is_some() {\n-            let future_impl = desugar_future_path(ret_type);\n-            let ty_bound = TypeBound::Path(future_impl);\n-            TypeRef::ImplTrait(vec![ty_bound])\n-        } else {\n-            ret_type\n-        };\n-\n-        let is_unsafe = src.value.unsafe_token().is_some();\n-\n-        let vis_default = RawVisibility::default_for_container(loc.container);\n-        let visibility =\n-            RawVisibility::from_ast_with_default(db, vis_default, src.map(|s| s.visibility()));\n-\n-        let sig =\n-            FunctionData { name, params, ret_type, has_self_param, is_unsafe, visibility, attrs };\n-        Arc::new(sig)\n+        let item_tree = db.item_tree(loc.id.file_id);\n+        let func = &item_tree[loc.id.value];\n+\n+        Arc::new(FunctionData {\n+            name: func.name.clone(),\n+            params: func.params.to_vec(),\n+            ret_type: func.ret_type.clone(),\n+            attrs: item_tree.attrs(loc.id.value.into()).clone(),\n+            has_self_param: func.has_self_param,\n+            is_unsafe: func.is_unsafe,\n+            visibility: item_tree[func.visibility].clone(),\n+        })\n     }\n }\n \n-fn desugar_future_path(orig: TypeRef) -> Path {\n-    let path = path![core::future::Future];\n-    let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n-    let mut last = GenericArgs::empty();\n-    last.bindings.push(AssociatedTypeBinding {\n-        name: name![Output],\n-        type_ref: Some(orig),\n-        bounds: Vec::new(),\n-    });\n-    generic_args.push(Some(Arc::new(last)));\n-\n-    Path::from_known_path(path, generic_args)\n-}\n-\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub struct TypeAliasData {\n     pub name: Name,\n     pub type_ref: Option<TypeRef>,\n     pub visibility: RawVisibility,\n+    /// Bounds restricting the type alias itself (eg. `type Ty: Bound;` in a trait or impl).\n     pub bounds: Vec<TypeBound>,\n }\n \n@@ -126,22 +63,15 @@ impl TypeAliasData {\n         typ: TypeAliasId,\n     ) -> Arc<TypeAliasData> {\n         let loc = typ.lookup(db);\n-        let node = loc.source(db);\n-        let name = node.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let lower_ctx = LowerCtx::new(db, node.file_id);\n-        let type_ref = node.value.type_ref().map(|it| TypeRef::from_ast(&lower_ctx, it));\n-        let vis_default = RawVisibility::default_for_container(loc.container);\n-        let visibility = RawVisibility::from_ast_with_default(\n-            db,\n-            vis_default,\n-            node.as_ref().map(|n| n.visibility()),\n-        );\n-        let bounds = if let Some(bound_list) = node.value.type_bound_list() {\n-            bound_list.bounds().map(|it| TypeBound::from_ast(&lower_ctx, it)).collect()\n-        } else {\n-            Vec::new()\n-        };\n-        Arc::new(TypeAliasData { name, type_ref, visibility, bounds })\n+        let item_tree = db.item_tree(loc.id.file_id);\n+        let typ = &item_tree[loc.id.value];\n+\n+        Arc::new(TypeAliasData {\n+            name: typ.name.clone(),\n+            type_ref: typ.type_ref.clone(),\n+            visibility: item_tree[typ.visibility].clone(),\n+            bounds: typ.bounds.to_vec(),\n+        })\n     }\n }\n \n@@ -155,30 +85,24 @@ pub struct TraitData {\n impl TraitData {\n     pub(crate) fn trait_data_query(db: &dyn DefDatabase, tr: TraitId) -> Arc<TraitData> {\n         let tr_loc = tr.lookup(db);\n-        let src = tr_loc.source(db);\n-        let name = src.value.name().map_or_else(Name::missing, |n| n.as_name());\n-        let auto = src.value.auto_token().is_some();\n+        let item_tree = db.item_tree(tr_loc.id.file_id);\n+        let tr_def = &item_tree[tr_loc.id.value];\n+        let name = tr_def.name.clone();\n+        let auto = tr_def.auto;\n         let module_id = tr_loc.container.module(db);\n-\n         let container = AssocContainerId::TraitId(tr);\n-        let mut items = Vec::new();\n-\n-        if let Some(item_list) = src.value.item_list() {\n-            let mut expander = Expander::new(db, tr_loc.ast_id.file_id, module_id);\n-            items.extend(collect_items(\n-                db,\n-                &mut expander,\n-                item_list.assoc_items(),\n-                src.file_id,\n-                container,\n-            ));\n-            items.extend(collect_items_in_macros(\n-                db,\n-                &mut expander,\n-                &src.with_value(item_list),\n-                container,\n-            ));\n-        }\n+        let mut expander = Expander::new(db, tr_loc.id.file_id, module_id);\n+\n+        let items = collect_items(\n+            db,\n+            module_id,\n+            &mut expander,\n+            tr_def.items.iter().copied(),\n+            tr_loc.id.file_id,\n+            container,\n+            100,\n+        );\n+\n         Arc::new(TraitData { name, items, auto })\n     }\n \n@@ -209,33 +133,28 @@ impl ImplData {\n     pub(crate) fn impl_data_query(db: &dyn DefDatabase, id: ImplId) -> Arc<ImplData> {\n         let _p = profile(\"impl_data_query\");\n         let impl_loc = id.lookup(db);\n-        let src = impl_loc.source(db);\n-        let lower_ctx = LowerCtx::new(db, src.file_id);\n \n-        let target_trait = src.value.target_trait().map(|it| TypeRef::from_ast(&lower_ctx, it));\n-        let target_type = TypeRef::from_ast_opt(&lower_ctx, src.value.target_type());\n-        let is_negative = src.value.excl_token().is_some();\n+        let item_tree = db.item_tree(impl_loc.id.file_id);\n+        let impl_def = &item_tree[impl_loc.id.value];\n+        let target_trait = impl_def.target_trait.clone();\n+        let target_type = impl_def.target_type.clone();\n+        let is_negative = impl_def.is_negative;\n         let module_id = impl_loc.container.module(db);\n         let container = AssocContainerId::ImplId(id);\n+        let mut expander = Expander::new(db, impl_loc.id.file_id, module_id);\n \n-        let mut items: Vec<AssocItemId> = Vec::new();\n-\n-        if let Some(item_list) = src.value.item_list() {\n-            let mut expander = Expander::new(db, impl_loc.ast_id.file_id, module_id);\n-            items.extend(\n-                collect_items(db, &mut expander, item_list.assoc_items(), src.file_id, container)\n-                    .into_iter()\n-                    .map(|(_, item)| item),\n-            );\n-            items.extend(\n-                collect_items_in_macros(db, &mut expander, &src.with_value(item_list), container)\n-                    .into_iter()\n-                    .map(|(_, item)| item),\n-            );\n-        }\n+        let items = collect_items(\n+            db,\n+            module_id,\n+            &mut expander,\n+            impl_def.items.iter().copied(),\n+            impl_loc.id.file_id,\n+            container,\n+            100,\n+        );\n+        let items = items.into_iter().map(|(_, item)| item).collect();\n \n-        let res = ImplData { target_trait, target_type, items, is_negative };\n-        Arc::new(res)\n+        Arc::new(ImplData { target_trait, target_type, items, is_negative })\n     }\n }\n \n@@ -250,22 +169,14 @@ pub struct ConstData {\n impl ConstData {\n     pub(crate) fn const_data_query(db: &dyn DefDatabase, konst: ConstId) -> Arc<ConstData> {\n         let loc = konst.lookup(db);\n-        let node = loc.source(db);\n-        let vis_default = RawVisibility::default_for_container(loc.container);\n-        Arc::new(ConstData::new(db, vis_default, node))\n-    }\n+        let item_tree = db.item_tree(loc.id.file_id);\n+        let konst = &item_tree[loc.id.value];\n \n-    fn new<N: NameOwner + TypeAscriptionOwner + VisibilityOwner>(\n-        db: &dyn DefDatabase,\n-        vis_default: RawVisibility,\n-        node: InFile<N>,\n-    ) -> ConstData {\n-        let ctx = LowerCtx::new(db, node.file_id);\n-        let name = node.value.name().map(|n| n.as_name());\n-        let type_ref = TypeRef::from_ast_opt(&ctx, node.value.ascribed_type());\n-        let visibility =\n-            RawVisibility::from_ast_with_default(db, vis_default, node.map(|n| n.visibility()));\n-        ConstData { name, type_ref, visibility }\n+        Arc::new(ConstData {\n+            name: konst.name.clone(),\n+            type_ref: konst.type_ref.clone(),\n+            visibility: item_tree[konst.visibility].clone(),\n+        })\n     }\n }\n \n@@ -279,107 +190,88 @@ pub struct StaticData {\n \n impl StaticData {\n     pub(crate) fn static_data_query(db: &dyn DefDatabase, konst: StaticId) -> Arc<StaticData> {\n-        let node = konst.lookup(db).source(db);\n-        let ctx = LowerCtx::new(db, node.file_id);\n-\n-        let name = node.value.name().map(|n| n.as_name());\n-        let type_ref = TypeRef::from_ast_opt(&ctx, node.value.ascribed_type());\n-        let mutable = node.value.mut_token().is_some();\n-        let visibility = RawVisibility::from_ast_with_default(\n-            db,\n-            RawVisibility::private(),\n-            node.map(|n| n.visibility()),\n-        );\n-\n-        Arc::new(StaticData { name, type_ref, visibility, mutable })\n-    }\n-}\n-\n-fn collect_items_in_macros(\n-    db: &dyn DefDatabase,\n-    expander: &mut Expander,\n-    impl_def: &InFile<ast::ItemList>,\n-    container: AssocContainerId,\n-) -> Vec<(Name, AssocItemId)> {\n-    let mut res = Vec::new();\n-\n-    // We set a limit to protect against infinite recursion\n-    let limit = 100;\n-\n-    for m in impl_def.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-        res.extend(collect_items_in_macro(db, expander, m, container, limit))\n+        let node = konst.lookup(db);\n+        let item_tree = db.item_tree(node.id.file_id);\n+        let statik = &item_tree[node.id.value];\n+\n+        Arc::new(StaticData {\n+            name: Some(statik.name.clone()),\n+            type_ref: statik.type_ref.clone(),\n+            visibility: item_tree[statik.visibility].clone(),\n+            mutable: statik.mutable,\n+        })\n     }\n-\n-    res\n }\n \n-fn collect_items_in_macro(\n+fn collect_items(\n     db: &dyn DefDatabase,\n+    module: ModuleId,\n     expander: &mut Expander,\n-    m: ast::MacroCall,\n+    assoc_items: impl Iterator<Item = AssocItem>,\n+    file_id: crate::HirFileId,\n     container: AssocContainerId,\n     limit: usize,\n ) -> Vec<(Name, AssocItemId)> {\n     if limit == 0 {\n         return Vec::new();\n     }\n \n-    if let Some((mark, items)) = expander.enter_expand(db, None, m) {\n-        let items: InFile<ast::MacroItems> = expander.to_source(items);\n-        let mut res = collect_items(\n-            db,\n-            expander,\n-            items.value.items().filter_map(|it| AssocItem::cast(it.syntax().clone())),\n-            items.file_id,\n-            container,\n-        );\n-\n-        // Recursive collect macros\n-        // Note that ast::ModuleItem do not include ast::MacroCall\n-        // We cannot use ModuleItemOwner::items here\n-        for it in items.value.syntax().children().filter_map(ast::MacroCall::cast) {\n-            res.extend(collect_items_in_macro(db, expander, it, container, limit - 1))\n-        }\n-        expander.exit(db, mark);\n-        res\n-    } else {\n-        Vec::new()\n-    }\n-}\n-\n-fn collect_items(\n-    db: &dyn DefDatabase,\n-    expander: &mut Expander,\n-    assoc_items: impl Iterator<Item = AssocItem>,\n-    file_id: crate::HirFileId,\n-    container: AssocContainerId,\n-) -> Vec<(Name, AssocItemId)> {\n-    let items = db.ast_id_map(file_id);\n-\n-    assoc_items\n-        .filter_map(|item_node| match item_node {\n-            ast::AssocItem::FnDef(it) => {\n-                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                if !expander.is_cfg_enabled(&it) {\n-                    return None;\n+    let item_tree = db.item_tree(file_id);\n+    let cfg_options = db.crate_graph()[module.krate].cfg_options.clone();\n+\n+    let mut items = Vec::new();\n+    for item in assoc_items {\n+        match item {\n+            AssocItem::Function(id) => {\n+                let item = &item_tree[id];\n+                let attrs = item_tree.attrs(id.into());\n+                if !attrs.is_cfg_enabled(&cfg_options) {\n+                    continue;\n                 }\n-                let def = FunctionLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n-                    .intern(db);\n-                Some((name, def.into()))\n+                let def = FunctionLoc { container, id: ItemTreeId::new(file_id, id) }.intern(db);\n+                items.push((item.name.clone(), def.into()));\n             }\n-            ast::AssocItem::ConstDef(it) => {\n-                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                let def = ConstLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n-                    .intern(db);\n-                Some((name, def.into()))\n+            // FIXME: cfg?\n+            AssocItem::Const(id) => {\n+                let item = &item_tree[id];\n+                let name = match item.name.clone() {\n+                    Some(name) => name,\n+                    None => continue,\n+                };\n+                let def = ConstLoc { container, id: ItemTreeId::new(file_id, id) }.intern(db);\n+                items.push((name, def.into()));\n             }\n-            ast::AssocItem::TypeAliasDef(it) => {\n-                let name = it.name().map_or_else(Name::missing, |it| it.as_name());\n-                let def =\n-                    TypeAliasLoc { container, ast_id: AstId::new(file_id, items.ast_id(&it)) }\n-                        .intern(db);\n-                Some((name, def.into()))\n+            AssocItem::TypeAlias(id) => {\n+                let item = &item_tree[id];\n+                let def = TypeAliasLoc { container, id: ItemTreeId::new(file_id, id) }.intern(db);\n+                items.push((item.name.clone(), def.into()));\n             }\n-        })\n-        .collect()\n+            AssocItem::MacroCall(call) => {\n+                let call = &item_tree[call];\n+                let ast_id_map = db.ast_id_map(file_id);\n+                let root = db.parse_or_expand(file_id).unwrap();\n+                let call = ast_id_map.get(call.ast_id).to_node(&root);\n+\n+                if let Some((mark, mac)) = expander.enter_expand(db, None, call) {\n+                    let src: InFile<ast::MacroItems> = expander.to_source(mac);\n+                    let item_tree = db.item_tree(src.file_id);\n+                    let iter =\n+                        item_tree.top_level_items().iter().filter_map(ModItem::as_assoc_item);\n+                    items.extend(collect_items(\n+                        db,\n+                        module,\n+                        expander,\n+                        iter,\n+                        src.file_id,\n+                        container,\n+                        limit - 1,\n+                    ));\n+\n+                    expander.exit(db, mark);\n+                }\n+            }\n+        }\n+    }\n+\n+    items\n }"}, {"sha": "9c3ede2d79dd768dda61455aa83cd48849cfd668", "filename": "crates/ra_hir_def/src/db.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fdb.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -14,8 +14,9 @@ use crate::{\n     docs::Documentation,\n     generics::GenericParams,\n     import_map::ImportMap,\n+    item_tree::ItemTree,\n     lang_item::{LangItemTarget, LangItems},\n-    nameres::{raw::RawItems, CrateDefMap},\n+    nameres::CrateDefMap,\n     AttrDefId, ConstId, ConstLoc, DefWithBodyId, EnumId, EnumLoc, FunctionId, FunctionLoc,\n     GenericDefId, ImplId, ImplLoc, ModuleId, StaticId, StaticLoc, StructId, StructLoc, TraitId,\n     TraitLoc, TypeAliasId, TypeAliasLoc, UnionId, UnionLoc,\n@@ -45,8 +46,8 @@ pub trait InternDatabase: SourceDatabase {\n \n #[salsa::query_group(DefDatabaseStorage)]\n pub trait DefDatabase: InternDatabase + AstDatabase + Upcast<dyn AstDatabase> {\n-    #[salsa::invoke(RawItems::raw_items_query)]\n-    fn raw_items(&self, file_id: HirFileId) -> Arc<RawItems>;\n+    #[salsa::invoke(ItemTree::item_tree_query)]\n+    fn item_tree(&self, file_id: HirFileId) -> Arc<ItemTree>;\n \n     #[salsa::invoke(crate_def_map_wait)]\n     #[salsa::transparent]"}, {"sha": "6a0f493a79c369c0fd5f724af4c9f3279ffc0873", "filename": "crates/ra_hir_def/src/generics.rs", "status": "modified", "additions": 56, "deletions": 6, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fgenerics.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -42,7 +42,7 @@ pub enum TypeParamProvenance {\n }\n \n /// Data about the generic parameters of a function, struct, impl, etc.\n-#[derive(Clone, PartialEq, Eq, Debug)]\n+#[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct GenericParams {\n     pub types: Arena<TypeParamData>,\n     // lifetimes: Arena<LocalLifetimeParamId, LifetimeParamData>,\n@@ -74,8 +74,53 @@ impl GenericParams {\n         def: GenericDefId,\n     ) -> Arc<GenericParams> {\n         let _p = profile(\"generic_params_query\");\n-        let (params, _source_map) = GenericParams::new(db, def);\n-        Arc::new(params)\n+\n+        let generics = match def {\n+            GenericDefId::FunctionId(id) => {\n+                let id = id.lookup(db).id;\n+                let tree = db.item_tree(id.file_id);\n+                let item = &tree[id.value];\n+                tree[item.generic_params].clone()\n+            }\n+            GenericDefId::AdtId(AdtId::StructId(id)) => {\n+                let id = id.lookup(db).id;\n+                let tree = db.item_tree(id.file_id);\n+                let item = &tree[id.value];\n+                tree[item.generic_params].clone()\n+            }\n+            GenericDefId::AdtId(AdtId::EnumId(id)) => {\n+                let id = id.lookup(db).id;\n+                let tree = db.item_tree(id.file_id);\n+                let item = &tree[id.value];\n+                tree[item.generic_params].clone()\n+            }\n+            GenericDefId::AdtId(AdtId::UnionId(id)) => {\n+                let id = id.lookup(db).id;\n+                let tree = db.item_tree(id.file_id);\n+                let item = &tree[id.value];\n+                tree[item.generic_params].clone()\n+            }\n+            GenericDefId::TraitId(id) => {\n+                let id = id.lookup(db).id;\n+                let tree = db.item_tree(id.file_id);\n+                let item = &tree[id.value];\n+                tree[item.generic_params].clone()\n+            }\n+            GenericDefId::TypeAliasId(id) => {\n+                let id = id.lookup(db).id;\n+                let tree = db.item_tree(id.file_id);\n+                let item = &tree[id.value];\n+                tree[item.generic_params].clone()\n+            }\n+            GenericDefId::ImplId(id) => {\n+                let id = id.lookup(db).id;\n+                let tree = db.item_tree(id.file_id);\n+                let item = &tree[id.value];\n+                tree[item.generic_params].clone()\n+            }\n+            GenericDefId::EnumVariantId(_) | GenericDefId::ConstId(_) => GenericParams::default(),\n+        };\n+        Arc::new(generics)\n     }\n \n     fn new(db: &dyn DefDatabase, def: GenericDefId) -> (GenericParams, InFile<SourceMap>) {\n@@ -156,7 +201,12 @@ impl GenericParams {\n         (generics, InFile::new(file_id, sm))\n     }\n \n-    fn fill(&mut self, lower_ctx: &LowerCtx, sm: &mut SourceMap, node: &dyn TypeParamsOwner) {\n+    pub(crate) fn fill(\n+        &mut self,\n+        lower_ctx: &LowerCtx,\n+        sm: &mut SourceMap,\n+        node: &dyn TypeParamsOwner,\n+    ) {\n         if let Some(params) = node.type_param_list() {\n             self.fill_params(lower_ctx, sm, params)\n         }\n@@ -165,7 +215,7 @@ impl GenericParams {\n         }\n     }\n \n-    fn fill_bounds(\n+    pub(crate) fn fill_bounds(\n         &mut self,\n         lower_ctx: &LowerCtx,\n         node: &dyn ast::TypeBoundsOwner,\n@@ -229,7 +279,7 @@ impl GenericParams {\n             .push(WherePredicate { target: WherePredicateTarget::TypeRef(type_ref), bound });\n     }\n \n-    fn fill_implicit_impl_trait_args(&mut self, type_ref: &TypeRef) {\n+    pub(crate) fn fill_implicit_impl_trait_args(&mut self, type_ref: &TypeRef) {\n         type_ref.walk(&mut |type_ref| {\n             if let TypeRef::ImplTrait(bounds) = type_ref {\n                 let param = TypeParamData {"}, {"sha": "d7bc64e6ca6dd05f501849c991b4169bc28f2162", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "added", "additions": 697, "deletions": 0, "changes": 697, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -0,0 +1,697 @@\n+//! A simplified AST that only contains items.\n+\n+mod lower;\n+#[cfg(test)]\n+mod tests;\n+\n+use std::{\n+    fmt::{self, Debug},\n+    hash::{Hash, Hasher},\n+    marker::PhantomData,\n+    ops::{Index, Range},\n+    sync::Arc,\n+};\n+\n+use ast::{AstNode, AttrsOwner, NameOwner, StructKind, TypeAscriptionOwner};\n+use either::Either;\n+use hir_expand::{\n+    ast_id_map::FileAstId,\n+    hygiene::Hygiene,\n+    name::{name, AsName, Name},\n+    HirFileId, InFile,\n+};\n+use ra_arena::{Arena, Idx, RawId};\n+use ra_syntax::{ast, match_ast};\n+use rustc_hash::FxHashMap;\n+use smallvec::SmallVec;\n+use test_utils::mark;\n+\n+use crate::{\n+    attr::Attrs,\n+    db::DefDatabase,\n+    generics::GenericParams,\n+    path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path, PathKind},\n+    type_ref::{Mutability, TypeBound, TypeRef},\n+    visibility::RawVisibility,\n+};\n+\n+#[derive(Copy, Clone, Eq, PartialEq)]\n+pub struct RawVisibilityId(u32);\n+\n+impl RawVisibilityId {\n+    pub const PUB: Self = RawVisibilityId(u32::max_value());\n+    pub const PRIV: Self = RawVisibilityId(u32::max_value() - 1);\n+    pub const PUB_CRATE: Self = RawVisibilityId(u32::max_value() - 2);\n+}\n+\n+impl fmt::Debug for RawVisibilityId {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut f = f.debug_tuple(\"RawVisibilityId\");\n+        match *self {\n+            Self::PUB => f.field(&\"pub\"),\n+            Self::PRIV => f.field(&\"pub(self)\"),\n+            Self::PUB_CRATE => f.field(&\"pub(crate)\"),\n+            _ => f.field(&self.0),\n+        };\n+        f.finish()\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+pub struct GenericParamsId(u32);\n+\n+impl GenericParamsId {\n+    pub const EMPTY: Self = GenericParamsId(u32::max_value());\n+}\n+\n+/// The item tree of a source file.\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct ItemTree {\n+    top_level: SmallVec<[ModItem; 1]>,\n+    attrs: FxHashMap<AttrOwner, Attrs>,\n+    inner_items: FxHashMap<FileAstId<ast::ModuleItem>, SmallVec<[ModItem; 1]>>,\n+\n+    data: Option<Box<ItemTreeData>>,\n+}\n+\n+impl ItemTree {\n+    pub fn item_tree_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<ItemTree> {\n+        let _p = ra_prof::profile(\"item_tree_query\").detail(|| format!(\"{:?}\", file_id));\n+        let syntax = if let Some(node) = db.parse_or_expand(file_id) {\n+            node\n+        } else {\n+            return Arc::new(Self::empty());\n+        };\n+\n+        let hygiene = Hygiene::new(db.upcast(), file_id);\n+        let ctx = lower::Ctx::new(db, hygiene.clone(), file_id);\n+        let mut top_attrs = None;\n+        let mut item_tree = match_ast! {\n+            match syntax {\n+                ast::SourceFile(file) => {\n+                    top_attrs = Some(Attrs::new(&file, &hygiene));\n+                    ctx.lower_module_items(&file)\n+                },\n+                ast::MacroItems(items) => {\n+                    ctx.lower_module_items(&items)\n+                },\n+                // Macros can expand to expressions. We return an empty item tree in this case, but\n+                // still need to collect inner items.\n+                ast::Expr(e) => {\n+                    ctx.lower_inner_items(e.syntax())\n+                },\n+                _ => {\n+                    panic!(\"cannot create item tree from {:?}\", syntax);\n+                },\n+            }\n+        };\n+\n+        if let Some(attrs) = top_attrs {\n+            item_tree.attrs.insert(AttrOwner::TopLevel, attrs);\n+        }\n+        item_tree.shrink_to_fit();\n+        Arc::new(item_tree)\n+    }\n+\n+    fn empty() -> Self {\n+        Self {\n+            top_level: Default::default(),\n+            attrs: Default::default(),\n+            inner_items: Default::default(),\n+            data: Default::default(),\n+        }\n+    }\n+\n+    fn shrink_to_fit(&mut self) {\n+        if let Some(data) = &mut self.data {\n+            let ItemTreeData {\n+                imports,\n+                extern_crates,\n+                functions,\n+                structs,\n+                fields,\n+                unions,\n+                enums,\n+                variants,\n+                consts,\n+                statics,\n+                traits,\n+                impls,\n+                type_aliases,\n+                mods,\n+                macro_calls,\n+                exprs,\n+                vis,\n+                generics,\n+            } = &mut **data;\n+\n+            imports.shrink_to_fit();\n+            extern_crates.shrink_to_fit();\n+            functions.shrink_to_fit();\n+            structs.shrink_to_fit();\n+            fields.shrink_to_fit();\n+            unions.shrink_to_fit();\n+            enums.shrink_to_fit();\n+            variants.shrink_to_fit();\n+            consts.shrink_to_fit();\n+            statics.shrink_to_fit();\n+            traits.shrink_to_fit();\n+            impls.shrink_to_fit();\n+            type_aliases.shrink_to_fit();\n+            mods.shrink_to_fit();\n+            macro_calls.shrink_to_fit();\n+            exprs.shrink_to_fit();\n+\n+            vis.arena.shrink_to_fit();\n+            generics.arena.shrink_to_fit();\n+        }\n+    }\n+\n+    /// Returns an iterator over all items located at the top level of the `HirFileId` this\n+    /// `ItemTree` was created from.\n+    pub fn top_level_items(&self) -> &[ModItem] {\n+        &self.top_level\n+    }\n+\n+    /// Returns the inner attributes of the source file.\n+    pub fn top_level_attrs(&self) -> &Attrs {\n+        self.attrs.get(&AttrOwner::TopLevel).unwrap_or(&Attrs::EMPTY)\n+    }\n+\n+    pub fn attrs(&self, of: ModItem) -> &Attrs {\n+        self.attrs.get(&AttrOwner::ModItem(of)).unwrap_or(&Attrs::EMPTY)\n+    }\n+\n+    /// Returns the lowered inner items that `ast` corresponds to.\n+    ///\n+    /// Most AST items are lowered to a single `ModItem`, but some (eg. `use` items) may be lowered\n+    /// to multiple items in the `ItemTree`.\n+    pub fn inner_items(&self, ast: FileAstId<ast::ModuleItem>) -> &[ModItem] {\n+        &self.inner_items[&ast]\n+    }\n+\n+    pub fn all_inner_items(&self) -> impl Iterator<Item = ModItem> + '_ {\n+        self.inner_items.values().flatten().copied()\n+    }\n+\n+    pub fn source<S: ItemTreeNode>(&self, db: &dyn DefDatabase, of: ItemTreeId<S>) -> S::Source {\n+        // This unwrap cannot fail, since it has either succeeded above, or resulted in an empty\n+        // ItemTree (in which case there is no valid `FileItemTreeId` to call this method with).\n+        let root =\n+            db.parse_or_expand(of.file_id).expect(\"parse_or_expand failed on constructed ItemTree\");\n+\n+        let id = self[of.value].ast_id();\n+        let map = db.ast_id_map(of.file_id);\n+        let ptr = map.get(id);\n+        ptr.to_node(&root)\n+    }\n+\n+    fn data(&self) -> &ItemTreeData {\n+        self.data.as_ref().expect(\"attempted to access data of empty ItemTree\")\n+    }\n+\n+    fn data_mut(&mut self) -> &mut ItemTreeData {\n+        self.data.get_or_insert_with(Box::default)\n+    }\n+}\n+\n+#[derive(Default, Debug, Eq, PartialEq)]\n+struct ItemVisibilities {\n+    arena: Arena<RawVisibility>,\n+}\n+\n+impl ItemVisibilities {\n+    fn alloc(&mut self, vis: RawVisibility) -> RawVisibilityId {\n+        match &vis {\n+            RawVisibility::Public => RawVisibilityId::PUB,\n+            RawVisibility::Module(path) if path.segments.is_empty() => match &path.kind {\n+                PathKind::Super(0) => RawVisibilityId::PRIV,\n+                PathKind::Crate => RawVisibilityId::PUB_CRATE,\n+                _ => RawVisibilityId(self.arena.alloc(vis).into_raw().into()),\n+            },\n+            _ => RawVisibilityId(self.arena.alloc(vis).into_raw().into()),\n+        }\n+    }\n+}\n+\n+static VIS_PUB: RawVisibility = RawVisibility::Public;\n+static VIS_PRIV: RawVisibility =\n+    RawVisibility::Module(ModPath { kind: PathKind::Super(0), segments: Vec::new() });\n+static VIS_PUB_CRATE: RawVisibility =\n+    RawVisibility::Module(ModPath { kind: PathKind::Crate, segments: Vec::new() });\n+\n+#[derive(Default, Debug, Eq, PartialEq)]\n+struct GenericParamsStorage {\n+    arena: Arena<GenericParams>,\n+}\n+\n+impl GenericParamsStorage {\n+    fn alloc(&mut self, params: GenericParams) -> GenericParamsId {\n+        if params.types.is_empty() && params.where_predicates.is_empty() {\n+            return GenericParamsId::EMPTY;\n+        }\n+\n+        GenericParamsId(self.arena.alloc(params).into_raw().into())\n+    }\n+}\n+\n+static EMPTY_GENERICS: GenericParams =\n+    GenericParams { types: Arena::new(), where_predicates: Vec::new() };\n+\n+#[derive(Default, Debug, Eq, PartialEq)]\n+struct ItemTreeData {\n+    imports: Arena<Import>,\n+    extern_crates: Arena<ExternCrate>,\n+    functions: Arena<Function>,\n+    structs: Arena<Struct>,\n+    fields: Arena<Field>,\n+    unions: Arena<Union>,\n+    enums: Arena<Enum>,\n+    variants: Arena<Variant>,\n+    consts: Arena<Const>,\n+    statics: Arena<Static>,\n+    traits: Arena<Trait>,\n+    impls: Arena<Impl>,\n+    type_aliases: Arena<TypeAlias>,\n+    mods: Arena<Mod>,\n+    macro_calls: Arena<MacroCall>,\n+    exprs: Arena<Expr>,\n+\n+    vis: ItemVisibilities,\n+    generics: GenericParamsStorage,\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Hash)]\n+enum AttrOwner {\n+    /// Attributes on an item.\n+    ModItem(ModItem),\n+    /// Inner attributes of the source file.\n+    TopLevel,\n+    // FIXME: Store variant and field attrs, and stop reparsing them in `attrs_query`.\n+}\n+\n+/// Trait implemented by all nodes in the item tree.\n+pub trait ItemTreeNode: Clone {\n+    type Source: AstNode + Into<ast::ModuleItem>;\n+\n+    fn ast_id(&self) -> FileAstId<Self::Source>;\n+\n+    /// Looks up an instance of `Self` in an item tree.\n+    fn lookup(tree: &ItemTree, index: Idx<Self>) -> &Self;\n+\n+    /// Downcasts a `ModItem` to a `FileItemTreeId` specific to this type.\n+    fn id_from_mod_item(mod_item: ModItem) -> Option<FileItemTreeId<Self>>;\n+\n+    /// Upcasts a `FileItemTreeId` to a generic `ModItem`.\n+    fn id_to_mod_item(id: FileItemTreeId<Self>) -> ModItem;\n+}\n+\n+pub struct FileItemTreeId<N: ItemTreeNode> {\n+    index: Idx<N>,\n+    _p: PhantomData<N>,\n+}\n+\n+impl<N: ItemTreeNode> Clone for FileItemTreeId<N> {\n+    fn clone(&self) -> Self {\n+        Self { index: self.index, _p: PhantomData }\n+    }\n+}\n+impl<N: ItemTreeNode> Copy for FileItemTreeId<N> {}\n+\n+impl<N: ItemTreeNode> PartialEq for FileItemTreeId<N> {\n+    fn eq(&self, other: &FileItemTreeId<N>) -> bool {\n+        self.index == other.index\n+    }\n+}\n+impl<N: ItemTreeNode> Eq for FileItemTreeId<N> {}\n+\n+impl<N: ItemTreeNode> Hash for FileItemTreeId<N> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.index.hash(state)\n+    }\n+}\n+\n+impl<N: ItemTreeNode> fmt::Debug for FileItemTreeId<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        self.index.fmt(f)\n+    }\n+}\n+\n+pub type ItemTreeId<N> = InFile<FileItemTreeId<N>>;\n+\n+macro_rules! mod_items {\n+    ( $( $typ:ident in $fld:ident -> $ast:ty ),+ $(,)? ) => {\n+        #[derive(Debug, Copy, Clone, Eq, PartialEq, Hash)]\n+        pub enum ModItem {\n+            $(\n+                $typ(FileItemTreeId<$typ>),\n+            )+\n+        }\n+\n+        $(\n+            impl From<FileItemTreeId<$typ>> for ModItem {\n+                fn from(id: FileItemTreeId<$typ>) -> ModItem {\n+                    ModItem::$typ(id)\n+                }\n+            }\n+        )+\n+\n+        $(\n+            impl ItemTreeNode for $typ {\n+                type Source = $ast;\n+\n+                fn ast_id(&self) -> FileAstId<Self::Source> {\n+                    self.ast_id\n+                }\n+\n+                fn lookup(tree: &ItemTree, index: Idx<Self>) -> &Self {\n+                    &tree.data().$fld[index]\n+                }\n+\n+                fn id_from_mod_item(mod_item: ModItem) -> Option<FileItemTreeId<Self>> {\n+                    if let ModItem::$typ(id) = mod_item {\n+                        Some(id)\n+                    } else {\n+                        None\n+                    }\n+                }\n+\n+                fn id_to_mod_item(id: FileItemTreeId<Self>) -> ModItem {\n+                    ModItem::$typ(id)\n+                }\n+            }\n+\n+            impl Index<Idx<$typ>> for ItemTree {\n+                type Output = $typ;\n+\n+                fn index(&self, index: Idx<$typ>) -> &Self::Output {\n+                    &self.data().$fld[index]\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+mod_items! {\n+    Import in imports -> ast::UseItem,\n+    ExternCrate in extern_crates -> ast::ExternCrateItem,\n+    Function in functions -> ast::FnDef,\n+    Struct in structs -> ast::StructDef,\n+    Union in unions -> ast::UnionDef,\n+    Enum in enums -> ast::EnumDef,\n+    Const in consts -> ast::ConstDef,\n+    Static in statics -> ast::StaticDef,\n+    Trait in traits -> ast::TraitDef,\n+    Impl in impls -> ast::ImplDef,\n+    TypeAlias in type_aliases -> ast::TypeAliasDef,\n+    Mod in mods -> ast::Module,\n+    MacroCall in macro_calls -> ast::MacroCall,\n+}\n+\n+macro_rules! impl_index {\n+    ( $($fld:ident: $t:ty),+ $(,)? ) => {\n+        $(\n+            impl Index<Idx<$t>> for ItemTree {\n+                type Output = $t;\n+\n+                fn index(&self, index: Idx<$t>) -> &Self::Output {\n+                    &self.data().$fld[index]\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+impl_index!(fields: Field, variants: Variant, exprs: Expr);\n+\n+impl Index<RawVisibilityId> for ItemTree {\n+    type Output = RawVisibility;\n+    fn index(&self, index: RawVisibilityId) -> &Self::Output {\n+        match index {\n+            RawVisibilityId::PRIV => &VIS_PRIV,\n+            RawVisibilityId::PUB => &VIS_PUB,\n+            RawVisibilityId::PUB_CRATE => &VIS_PUB_CRATE,\n+            _ => &self.data().vis.arena[Idx::from_raw(index.0.into())],\n+        }\n+    }\n+}\n+\n+impl Index<GenericParamsId> for ItemTree {\n+    type Output = GenericParams;\n+\n+    fn index(&self, index: GenericParamsId) -> &Self::Output {\n+        match index {\n+            GenericParamsId::EMPTY => &EMPTY_GENERICS,\n+            _ => &self.data().generics.arena[Idx::from_raw(index.0.into())],\n+        }\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Index<FileItemTreeId<N>> for ItemTree {\n+    type Output = N;\n+    fn index(&self, id: FileItemTreeId<N>) -> &N {\n+        N::lookup(self, id.index)\n+    }\n+}\n+\n+/// A desugared `use` import.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Import {\n+    pub path: ModPath,\n+    pub alias: Option<ImportAlias>,\n+    pub visibility: RawVisibilityId,\n+    pub is_glob: bool,\n+    pub is_prelude: bool,\n+    /// AST ID of the `use` or `extern crate` item this import was derived from. Note that many\n+    /// `Import`s can map to the same `use` item.\n+    pub ast_id: FileAstId<ast::UseItem>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct ExternCrate {\n+    pub path: ModPath,\n+    pub alias: Option<ImportAlias>,\n+    pub visibility: RawVisibilityId,\n+    /// Whether this is a `#[macro_use] extern crate ...`.\n+    pub is_macro_use: bool,\n+    pub ast_id: FileAstId<ast::ExternCrateItem>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Function {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub generic_params: GenericParamsId,\n+    pub has_self_param: bool,\n+    pub is_unsafe: bool,\n+    pub params: Box<[TypeRef]>,\n+    pub ret_type: TypeRef,\n+    pub ast_id: FileAstId<ast::FnDef>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Struct {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub generic_params: GenericParamsId,\n+    pub fields: Fields,\n+    pub ast_id: FileAstId<ast::StructDef>,\n+    pub kind: StructDefKind,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum StructDefKind {\n+    /// `struct S { ... }` - type namespace only.\n+    Record,\n+    /// `struct S(...);`\n+    Tuple,\n+    /// `struct S;`\n+    Unit,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Union {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub generic_params: GenericParamsId,\n+    pub fields: Fields,\n+    pub ast_id: FileAstId<ast::UnionDef>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Enum {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub generic_params: GenericParamsId,\n+    pub variants: Range<Idx<Variant>>,\n+    pub ast_id: FileAstId<ast::EnumDef>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Const {\n+    /// const _: () = ();\n+    pub name: Option<Name>,\n+    pub visibility: RawVisibilityId,\n+    pub type_ref: TypeRef,\n+    pub ast_id: FileAstId<ast::ConstDef>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Static {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub mutable: bool,\n+    pub type_ref: TypeRef,\n+    pub ast_id: FileAstId<ast::StaticDef>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Trait {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub generic_params: GenericParamsId,\n+    pub auto: bool,\n+    pub items: Box<[AssocItem]>,\n+    pub ast_id: FileAstId<ast::TraitDef>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Impl {\n+    pub generic_params: GenericParamsId,\n+    pub target_trait: Option<TypeRef>,\n+    pub target_type: TypeRef,\n+    pub is_negative: bool,\n+    pub items: Box<[AssocItem]>,\n+    pub ast_id: FileAstId<ast::ImplDef>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TypeAlias {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    /// Bounds on the type alias itself. Only valid in trait declarations, eg. `type Assoc: Copy;`.\n+    pub bounds: Box<[TypeBound]>,\n+    pub generic_params: GenericParamsId,\n+    pub type_ref: Option<TypeRef>,\n+    pub ast_id: FileAstId<ast::TypeAliasDef>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Mod {\n+    pub name: Name,\n+    pub visibility: RawVisibilityId,\n+    pub kind: ModKind,\n+    pub ast_id: FileAstId<ast::Module>,\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub enum ModKind {\n+    /// `mod m { ... }`\n+    Inline { items: Box<[ModItem]> },\n+\n+    /// `mod m;`\n+    Outline {},\n+}\n+\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct MacroCall {\n+    /// For `macro_rules!` declarations, this is the name of the declared macro.\n+    pub name: Option<Name>,\n+    /// Path to the called macro.\n+    pub path: ModPath,\n+    /// Has `#[macro_export]`.\n+    pub is_export: bool,\n+    /// Has `#[macro_export(local_inner_macros)]`.\n+    pub is_local_inner: bool,\n+    /// Has `#[rustc_builtin_macro]`.\n+    pub is_builtin: bool,\n+    pub ast_id: FileAstId<ast::MacroCall>,\n+}\n+\n+// NB: There's no `FileAstId` for `Expr`. The only case where this would be useful is for array\n+// lengths, but we don't do much with them yet.\n+#[derive(Debug, Clone, Eq, PartialEq)]\n+pub struct Expr;\n+\n+macro_rules! impl_froms {\n+    ($e:ident { $($v:ident ($t:ty)),* $(,)? }) => {\n+        $(\n+            impl From<$t> for $e {\n+                fn from(it: $t) -> $e {\n+                    $e::$v(it)\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl ModItem {\n+    pub fn as_assoc_item(&self) -> Option<AssocItem> {\n+        match self {\n+            ModItem::Import(_)\n+            | ModItem::ExternCrate(_)\n+            | ModItem::Struct(_)\n+            | ModItem::Union(_)\n+            | ModItem::Enum(_)\n+            | ModItem::Static(_)\n+            | ModItem::Trait(_)\n+            | ModItem::Impl(_)\n+            | ModItem::Mod(_) => None,\n+            ModItem::MacroCall(call) => Some(AssocItem::MacroCall(*call)),\n+            ModItem::Const(konst) => Some(AssocItem::Const(*konst)),\n+            ModItem::TypeAlias(alias) => Some(AssocItem::TypeAlias(*alias)),\n+            ModItem::Function(func) => Some(AssocItem::Function(*func)),\n+        }\n+    }\n+\n+    pub fn downcast<N: ItemTreeNode>(self) -> Option<FileItemTreeId<N>> {\n+        N::id_from_mod_item(self)\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, Eq, PartialEq)]\n+pub enum AssocItem {\n+    Function(FileItemTreeId<Function>),\n+    TypeAlias(FileItemTreeId<TypeAlias>),\n+    Const(FileItemTreeId<Const>),\n+    MacroCall(FileItemTreeId<MacroCall>),\n+}\n+\n+impl_froms!(AssocItem {\n+    Function(FileItemTreeId<Function>),\n+    TypeAlias(FileItemTreeId<TypeAlias>),\n+    Const(FileItemTreeId<Const>),\n+    MacroCall(FileItemTreeId<MacroCall>),\n+});\n+\n+impl From<AssocItem> for ModItem {\n+    fn from(item: AssocItem) -> Self {\n+        match item {\n+            AssocItem::Function(it) => it.into(),\n+            AssocItem::TypeAlias(it) => it.into(),\n+            AssocItem::Const(it) => it.into(),\n+            AssocItem::MacroCall(it) => it.into(),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq)]\n+pub struct Variant {\n+    pub name: Name,\n+    pub fields: Fields,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum Fields {\n+    Record(Range<Idx<Field>>),\n+    Tuple(Range<Idx<Field>>),\n+    Unit,\n+}\n+\n+/// A single field of an enum variant or struct\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Field {\n+    pub name: Name,\n+    pub type_ref: TypeRef,\n+    pub visibility: RawVisibilityId,\n+}"}, {"sha": "f10ad25f7004a53bcf8cef14850bbbca1262dd45", "filename": "crates/ra_hir_def/src/item_tree/lower.rs", "status": "added", "additions": 695, "deletions": 0, "changes": 695, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Flower.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -0,0 +1,695 @@\n+//! AST -> `ItemTree` lowering code.\n+\n+use super::*;\n+use crate::{\n+    attr::Attrs,\n+    generics::{GenericParams, TypeParamData, TypeParamProvenance},\n+};\n+use hir_expand::{ast_id_map::AstIdMap, hygiene::Hygiene, HirFileId};\n+use ra_arena::map::ArenaMap;\n+use ra_syntax::{\n+    ast::{self, ModuleItemOwner},\n+    SyntaxNode,\n+};\n+use smallvec::SmallVec;\n+use std::{collections::hash_map::Entry, mem, sync::Arc};\n+\n+fn id<N: ItemTreeNode>(index: Idx<N>) -> FileItemTreeId<N> {\n+    FileItemTreeId { index, _p: PhantomData }\n+}\n+\n+struct ModItems(SmallVec<[ModItem; 1]>);\n+\n+impl<T> From<T> for ModItems\n+where\n+    T: Into<ModItem>,\n+{\n+    fn from(t: T) -> Self {\n+        ModItems(SmallVec::from_buf([t.into(); 1]))\n+    }\n+}\n+\n+pub(super) struct Ctx {\n+    tree: ItemTree,\n+    hygiene: Hygiene,\n+    file: HirFileId,\n+    source_ast_id_map: Arc<AstIdMap>,\n+    body_ctx: crate::body::LowerCtx,\n+    inner_items: Vec<ModItem>,\n+    forced_visibility: Option<RawVisibilityId>,\n+}\n+\n+impl Ctx {\n+    pub(super) fn new(db: &dyn DefDatabase, hygiene: Hygiene, file: HirFileId) -> Self {\n+        Self {\n+            tree: ItemTree::empty(),\n+            hygiene,\n+            file,\n+            source_ast_id_map: db.ast_id_map(file),\n+            body_ctx: crate::body::LowerCtx::new(db, file),\n+            inner_items: Vec::new(),\n+            forced_visibility: None,\n+        }\n+    }\n+\n+    pub(super) fn lower_module_items(mut self, item_owner: &dyn ModuleItemOwner) -> ItemTree {\n+        self.tree.top_level = item_owner\n+            .items()\n+            .flat_map(|item| self.lower_mod_item(&item, false))\n+            .flat_map(|items| items.0)\n+            .collect();\n+        self.tree\n+    }\n+\n+    pub(super) fn lower_inner_items(mut self, within: &SyntaxNode) -> ItemTree {\n+        self.collect_inner_items(within);\n+        self.tree\n+    }\n+\n+    fn data(&mut self) -> &mut ItemTreeData {\n+        self.tree.data_mut()\n+    }\n+\n+    fn lower_mod_item(&mut self, item: &ast::ModuleItem, inner: bool) -> Option<ModItems> {\n+        assert!(inner || self.inner_items.is_empty());\n+\n+        // Collect inner items for 1-to-1-lowered items.\n+        match item {\n+            ast::ModuleItem::StructDef(_)\n+            | ast::ModuleItem::UnionDef(_)\n+            | ast::ModuleItem::EnumDef(_)\n+            | ast::ModuleItem::FnDef(_)\n+            | ast::ModuleItem::TypeAliasDef(_)\n+            | ast::ModuleItem::ConstDef(_)\n+            | ast::ModuleItem::StaticDef(_)\n+            | ast::ModuleItem::MacroCall(_) => {\n+                // Skip this if we're already collecting inner items. We'll descend into all nodes\n+                // already.\n+                if !inner {\n+                    self.collect_inner_items(item.syntax());\n+                }\n+            }\n+\n+            // These are handled in their respective `lower_X` method (since we can't just blindly\n+            // walk them).\n+            ast::ModuleItem::TraitDef(_)\n+            | ast::ModuleItem::ImplDef(_)\n+            | ast::ModuleItem::ExternBlock(_) => {}\n+\n+            // These don't have inner items.\n+            ast::ModuleItem::Module(_)\n+            | ast::ModuleItem::ExternCrateItem(_)\n+            | ast::ModuleItem::UseItem(_) => {}\n+        };\n+\n+        let attrs = Attrs::new(item, &self.hygiene);\n+        let items = match item {\n+            ast::ModuleItem::StructDef(ast) => self.lower_struct(ast).map(Into::into),\n+            ast::ModuleItem::UnionDef(ast) => self.lower_union(ast).map(Into::into),\n+            ast::ModuleItem::EnumDef(ast) => self.lower_enum(ast).map(Into::into),\n+            ast::ModuleItem::FnDef(ast) => self.lower_function(ast).map(Into::into),\n+            ast::ModuleItem::TypeAliasDef(ast) => self.lower_type_alias(ast).map(Into::into),\n+            ast::ModuleItem::StaticDef(ast) => self.lower_static(ast).map(Into::into),\n+            ast::ModuleItem::ConstDef(ast) => Some(self.lower_const(ast).into()),\n+            ast::ModuleItem::Module(ast) => self.lower_module(ast).map(Into::into),\n+            ast::ModuleItem::TraitDef(ast) => self.lower_trait(ast).map(Into::into),\n+            ast::ModuleItem::ImplDef(ast) => self.lower_impl(ast).map(Into::into),\n+            ast::ModuleItem::UseItem(ast) => Some(ModItems(\n+                self.lower_use(ast).into_iter().map(Into::into).collect::<SmallVec<_>>(),\n+            )),\n+            ast::ModuleItem::ExternCrateItem(ast) => self.lower_extern_crate(ast).map(Into::into),\n+            ast::ModuleItem::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n+            ast::ModuleItem::ExternBlock(ast) => {\n+                Some(ModItems(self.lower_extern_block(ast).into_iter().collect::<SmallVec<_>>()))\n+            }\n+        };\n+\n+        if !attrs.is_empty() {\n+            for item in items.iter().flat_map(|items| &items.0) {\n+                self.add_attrs(*item, attrs.clone());\n+            }\n+        }\n+\n+        items\n+    }\n+\n+    fn add_attrs(&mut self, item: ModItem, attrs: Attrs) {\n+        match self.tree.attrs.entry(AttrOwner::ModItem(item)) {\n+            Entry::Occupied(mut entry) => {\n+                *entry.get_mut() = entry.get().merge(attrs);\n+            }\n+            Entry::Vacant(entry) => {\n+                entry.insert(attrs);\n+            }\n+        }\n+    }\n+\n+    fn collect_inner_items(&mut self, container: &SyntaxNode) {\n+        let forced_vis = self.forced_visibility.take();\n+        let mut inner_items = mem::take(&mut self.tree.inner_items);\n+        inner_items.extend(\n+            container.descendants().skip(1).filter_map(ast::ModuleItem::cast).filter_map(|item| {\n+                let ast_id = self.source_ast_id_map.ast_id(&item);\n+                Some((ast_id, self.lower_mod_item(&item, true)?.0))\n+            }),\n+        );\n+        self.tree.inner_items = inner_items;\n+        self.forced_visibility = forced_vis;\n+    }\n+\n+    fn lower_assoc_item(&mut self, item: &ast::ModuleItem) -> Option<AssocItem> {\n+        match item {\n+            ast::ModuleItem::FnDef(ast) => self.lower_function(ast).map(Into::into),\n+            ast::ModuleItem::TypeAliasDef(ast) => self.lower_type_alias(ast).map(Into::into),\n+            ast::ModuleItem::ConstDef(ast) => Some(self.lower_const(ast).into()),\n+            ast::ModuleItem::MacroCall(ast) => self.lower_macro_call(ast).map(Into::into),\n+            _ => None,\n+        }\n+    }\n+\n+    fn lower_struct(&mut self, strukt: &ast::StructDef) -> Option<FileItemTreeId<Struct>> {\n+        let visibility = self.lower_visibility(strukt);\n+        let name = strukt.name()?.as_name();\n+        let generic_params = self.lower_generic_params(GenericsOwner::Struct, strukt);\n+        let fields = self.lower_fields(&strukt.kind());\n+        let ast_id = self.source_ast_id_map.ast_id(strukt);\n+        let kind = match strukt.kind() {\n+            ast::StructKind::Record(_) => StructDefKind::Record,\n+            ast::StructKind::Tuple(_) => StructDefKind::Tuple,\n+            ast::StructKind::Unit => StructDefKind::Unit,\n+        };\n+        let res = Struct { name, visibility, generic_params, fields, ast_id, kind };\n+        Some(id(self.data().structs.alloc(res)))\n+    }\n+\n+    fn lower_fields(&mut self, strukt_kind: &ast::StructKind) -> Fields {\n+        match strukt_kind {\n+            ast::StructKind::Record(it) => {\n+                let range = self.lower_record_fields(it);\n+                Fields::Record(range)\n+            }\n+            ast::StructKind::Tuple(it) => {\n+                let range = self.lower_tuple_fields(it);\n+                Fields::Tuple(range)\n+            }\n+            ast::StructKind::Unit => Fields::Unit,\n+        }\n+    }\n+\n+    fn lower_record_fields(&mut self, fields: &ast::RecordFieldDefList) -> Range<Idx<Field>> {\n+        let start = self.next_field_idx();\n+        for field in fields.fields() {\n+            if let Some(data) = self.lower_record_field(&field) {\n+                self.data().fields.alloc(data);\n+            }\n+        }\n+        let end = self.next_field_idx();\n+        start..end\n+    }\n+\n+    fn lower_record_field(&mut self, field: &ast::RecordFieldDef) -> Option<Field> {\n+        let name = field.name()?.as_name();\n+        let visibility = self.lower_visibility(field);\n+        let type_ref = self.lower_type_ref(&field.ascribed_type()?);\n+        let res = Field { name, type_ref, visibility };\n+        Some(res)\n+    }\n+\n+    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldDefList) -> Range<Idx<Field>> {\n+        let start = self.next_field_idx();\n+        for (i, field) in fields.fields().enumerate() {\n+            if let Some(data) = self.lower_tuple_field(i, &field) {\n+                self.data().fields.alloc(data);\n+            }\n+        }\n+        let end = self.next_field_idx();\n+        start..end\n+    }\n+\n+    fn lower_tuple_field(&mut self, idx: usize, field: &ast::TupleFieldDef) -> Option<Field> {\n+        let name = Name::new_tuple_field(idx);\n+        let visibility = self.lower_visibility(field);\n+        let type_ref = self.lower_type_ref(&field.type_ref()?);\n+        let res = Field { name, type_ref, visibility };\n+        Some(res)\n+    }\n+\n+    fn lower_union(&mut self, union: &ast::UnionDef) -> Option<FileItemTreeId<Union>> {\n+        let visibility = self.lower_visibility(union);\n+        let name = union.name()?.as_name();\n+        let generic_params = self.lower_generic_params(GenericsOwner::Union, union);\n+        let fields = match union.record_field_def_list() {\n+            Some(record_field_def_list) => {\n+                self.lower_fields(&StructKind::Record(record_field_def_list))\n+            }\n+            None => Fields::Record(self.next_field_idx()..self.next_field_idx()),\n+        };\n+        let ast_id = self.source_ast_id_map.ast_id(union);\n+        let res = Union { name, visibility, generic_params, fields, ast_id };\n+        Some(id(self.data().unions.alloc(res)))\n+    }\n+\n+    fn lower_enum(&mut self, enum_: &ast::EnumDef) -> Option<FileItemTreeId<Enum>> {\n+        let visibility = self.lower_visibility(enum_);\n+        let name = enum_.name()?.as_name();\n+        let generic_params = self.lower_generic_params(GenericsOwner::Enum, enum_);\n+        let variants = match &enum_.variant_list() {\n+            Some(variant_list) => self.lower_variants(variant_list),\n+            None => self.next_variant_idx()..self.next_variant_idx(),\n+        };\n+        let ast_id = self.source_ast_id_map.ast_id(enum_);\n+        let res = Enum { name, visibility, generic_params, variants, ast_id };\n+        Some(id(self.data().enums.alloc(res)))\n+    }\n+\n+    fn lower_variants(&mut self, variants: &ast::EnumVariantList) -> Range<Idx<Variant>> {\n+        let start = self.next_variant_idx();\n+        for variant in variants.variants() {\n+            if let Some(data) = self.lower_variant(&variant) {\n+                self.data().variants.alloc(data);\n+            }\n+        }\n+        let end = self.next_variant_idx();\n+        start..end\n+    }\n+\n+    fn lower_variant(&mut self, variant: &ast::EnumVariant) -> Option<Variant> {\n+        let name = variant.name()?.as_name();\n+        let fields = self.lower_fields(&variant.kind());\n+        let res = Variant { name, fields };\n+        Some(res)\n+    }\n+\n+    fn lower_function(&mut self, func: &ast::FnDef) -> Option<FileItemTreeId<Function>> {\n+        let visibility = self.lower_visibility(func);\n+        let name = func.name()?.as_name();\n+\n+        let mut params = Vec::new();\n+        let mut has_self_param = false;\n+        if let Some(param_list) = func.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_type = match self_param.ascribed_type() {\n+                    Some(type_ref) => TypeRef::from_ast(&self.body_ctx, type_ref),\n+                    None => {\n+                        let self_type = TypeRef::Path(name![Self].into());\n+                        match self_param.kind() {\n+                            ast::SelfParamKind::Owned => self_type,\n+                            ast::SelfParamKind::Ref => {\n+                                TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n+                            }\n+                            ast::SelfParamKind::MutRef => {\n+                                TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n+                            }\n+                        }\n+                    }\n+                };\n+                params.push(self_type);\n+                has_self_param = true;\n+            }\n+            for param in param_list.params() {\n+                let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ascribed_type());\n+                params.push(type_ref);\n+            }\n+        }\n+        let ret_type = match func.ret_type().and_then(|rt| rt.type_ref()) {\n+            Some(type_ref) => TypeRef::from_ast(&self.body_ctx, type_ref),\n+            _ => TypeRef::unit(),\n+        };\n+\n+        let ret_type = if func.async_token().is_some() {\n+            let future_impl = desugar_future_path(ret_type);\n+            let ty_bound = TypeBound::Path(future_impl);\n+            TypeRef::ImplTrait(vec![ty_bound])\n+        } else {\n+            ret_type\n+        };\n+\n+        let ast_id = self.source_ast_id_map.ast_id(func);\n+        let mut res = Function {\n+            name,\n+            visibility,\n+            generic_params: GenericParamsId::EMPTY,\n+            has_self_param,\n+            is_unsafe: func.unsafe_token().is_some(),\n+            params: params.into_boxed_slice(),\n+            ret_type,\n+            ast_id,\n+        };\n+        res.generic_params = self.lower_generic_params(GenericsOwner::Function(&res), func);\n+\n+        Some(id(self.data().functions.alloc(res)))\n+    }\n+\n+    fn lower_type_alias(\n+        &mut self,\n+        type_alias: &ast::TypeAliasDef,\n+    ) -> Option<FileItemTreeId<TypeAlias>> {\n+        let name = type_alias.name()?.as_name();\n+        let type_ref = type_alias.type_ref().map(|it| self.lower_type_ref(&it));\n+        let visibility = self.lower_visibility(type_alias);\n+        let bounds = self.lower_type_bounds(type_alias);\n+        let generic_params = self.lower_generic_params(GenericsOwner::TypeAlias, type_alias);\n+        let ast_id = self.source_ast_id_map.ast_id(type_alias);\n+        let res = TypeAlias {\n+            name,\n+            visibility,\n+            bounds: bounds.into_boxed_slice(),\n+            generic_params,\n+            type_ref,\n+            ast_id,\n+        };\n+        Some(id(self.data().type_aliases.alloc(res)))\n+    }\n+\n+    fn lower_static(&mut self, static_: &ast::StaticDef) -> Option<FileItemTreeId<Static>> {\n+        let name = static_.name()?.as_name();\n+        let type_ref = self.lower_type_ref_opt(static_.ascribed_type());\n+        let visibility = self.lower_visibility(static_);\n+        let mutable = static_.mut_token().is_some();\n+        let ast_id = self.source_ast_id_map.ast_id(static_);\n+        let res = Static { name, visibility, mutable, type_ref, ast_id };\n+        Some(id(self.data().statics.alloc(res)))\n+    }\n+\n+    fn lower_const(&mut self, konst: &ast::ConstDef) -> FileItemTreeId<Const> {\n+        let name = konst.name().map(|it| it.as_name());\n+        let type_ref = self.lower_type_ref_opt(konst.ascribed_type());\n+        let visibility = self.lower_visibility(konst);\n+        let ast_id = self.source_ast_id_map.ast_id(konst);\n+        let res = Const { name, visibility, type_ref, ast_id };\n+        id(self.data().consts.alloc(res))\n+    }\n+\n+    fn lower_module(&mut self, module: &ast::Module) -> Option<FileItemTreeId<Mod>> {\n+        let name = module.name()?.as_name();\n+        let visibility = self.lower_visibility(module);\n+        let kind = if module.semicolon_token().is_some() {\n+            ModKind::Outline {}\n+        } else {\n+            ModKind::Inline {\n+                items: module\n+                    .item_list()\n+                    .map(|list| {\n+                        list.items()\n+                            .flat_map(|item| self.lower_mod_item(&item, false))\n+                            .flat_map(|items| items.0)\n+                            .collect()\n+                    })\n+                    .unwrap_or_else(|| {\n+                        mark::hit!(name_res_works_for_broken_modules);\n+                        Box::new([]) as Box<[_]>\n+                    }),\n+            }\n+        };\n+        let ast_id = self.source_ast_id_map.ast_id(module);\n+        let res = Mod { name, visibility, kind, ast_id };\n+        Some(id(self.data().mods.alloc(res)))\n+    }\n+\n+    fn lower_trait(&mut self, trait_def: &ast::TraitDef) -> Option<FileItemTreeId<Trait>> {\n+        let name = trait_def.name()?.as_name();\n+        let visibility = self.lower_visibility(trait_def);\n+        let generic_params =\n+            self.lower_generic_params_and_inner_items(GenericsOwner::Trait(trait_def), trait_def);\n+        let auto = trait_def.auto_token().is_some();\n+        let items = trait_def.item_list().map(|list| {\n+            self.with_inherited_visibility(visibility, |this| {\n+                list.items()\n+                    .filter_map(|item| {\n+                        let attrs = Attrs::new(&item, &this.hygiene);\n+                        this.collect_inner_items(item.syntax());\n+                        this.lower_assoc_item(&item).map(|item| {\n+                            this.add_attrs(item.into(), attrs);\n+                            item\n+                        })\n+                    })\n+                    .collect()\n+            })\n+        });\n+        let ast_id = self.source_ast_id_map.ast_id(trait_def);\n+        let res = Trait {\n+            name,\n+            visibility,\n+            generic_params,\n+            auto,\n+            items: items.unwrap_or_default(),\n+            ast_id,\n+        };\n+        Some(id(self.data().traits.alloc(res)))\n+    }\n+\n+    fn lower_impl(&mut self, impl_def: &ast::ImplDef) -> Option<FileItemTreeId<Impl>> {\n+        let generic_params =\n+            self.lower_generic_params_and_inner_items(GenericsOwner::Impl, impl_def);\n+        let target_trait = impl_def.target_trait().map(|tr| self.lower_type_ref(&tr));\n+        let target_type = self.lower_type_ref(&impl_def.target_type()?);\n+        let is_negative = impl_def.excl_token().is_some();\n+\n+        // We cannot use `assoc_items()` here as that does not include macro calls.\n+        let items = impl_def\n+            .item_list()?\n+            .items()\n+            .filter_map(|item| {\n+                self.collect_inner_items(item.syntax());\n+                let assoc = self.lower_assoc_item(&item)?;\n+                let attrs = Attrs::new(&item, &self.hygiene);\n+                self.add_attrs(assoc.into(), attrs);\n+                Some(assoc)\n+            })\n+            .collect();\n+        let ast_id = self.source_ast_id_map.ast_id(impl_def);\n+        let res = Impl { generic_params, target_trait, target_type, is_negative, items, ast_id };\n+        Some(id(self.data().impls.alloc(res)))\n+    }\n+\n+    fn lower_use(&mut self, use_item: &ast::UseItem) -> Vec<FileItemTreeId<Import>> {\n+        // FIXME: cfg_attr\n+        let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n+        let visibility = self.lower_visibility(use_item);\n+        let ast_id = self.source_ast_id_map.ast_id(use_item);\n+\n+        // Every use item can expand to many `Import`s.\n+        let mut imports = Vec::new();\n+        let tree = self.tree.data_mut();\n+        ModPath::expand_use_item(\n+            InFile::new(self.file, use_item.clone()),\n+            &self.hygiene,\n+            |path, _tree, is_glob, alias| {\n+                imports.push(id(tree.imports.alloc(Import {\n+                    path,\n+                    alias,\n+                    visibility,\n+                    is_glob,\n+                    is_prelude,\n+                    ast_id,\n+                })));\n+            },\n+        );\n+\n+        imports\n+    }\n+\n+    fn lower_extern_crate(\n+        &mut self,\n+        extern_crate: &ast::ExternCrateItem,\n+    ) -> Option<FileItemTreeId<ExternCrate>> {\n+        let path = ModPath::from_name_ref(&extern_crate.name_ref()?);\n+        let alias = extern_crate.alias().map(|a| {\n+            a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n+        });\n+        let visibility = self.lower_visibility(extern_crate);\n+        let ast_id = self.source_ast_id_map.ast_id(extern_crate);\n+        // FIXME: cfg_attr\n+        let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");\n+\n+        let res = ExternCrate { path, alias, visibility, is_macro_use, ast_id };\n+        Some(id(self.data().extern_crates.alloc(res)))\n+    }\n+\n+    fn lower_macro_call(&mut self, m: &ast::MacroCall) -> Option<FileItemTreeId<MacroCall>> {\n+        let name = m.name().map(|it| it.as_name());\n+        let attrs = Attrs::new(m, &self.hygiene);\n+        let path = ModPath::from_src(m.path()?, &self.hygiene)?;\n+\n+        let ast_id = self.source_ast_id_map.ast_id(m);\n+\n+        // FIXME: cfg_attr\n+        let export_attr = attrs.by_key(\"macro_export\");\n+\n+        let is_export = export_attr.exists();\n+        let is_local_inner = if is_export {\n+            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n+                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n+                    ident.text.contains(\"local_inner_macros\")\n+                }\n+                _ => false,\n+            })\n+        } else {\n+            false\n+        };\n+\n+        let is_builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n+        let res = MacroCall { name, path, is_export, is_builtin, is_local_inner, ast_id };\n+        Some(id(self.data().macro_calls.alloc(res)))\n+    }\n+\n+    fn lower_extern_block(&mut self, block: &ast::ExternBlock) -> Vec<ModItem> {\n+        block.extern_item_list().map_or(Vec::new(), |list| {\n+            list.extern_items()\n+                .filter_map(|item| {\n+                    self.collect_inner_items(item.syntax());\n+                    let attrs = Attrs::new(&item, &self.hygiene);\n+                    let id = match item {\n+                        ast::ExternItem::FnDef(ast) => {\n+                            let func = self.lower_function(&ast)?;\n+                            func.into()\n+                        }\n+                        ast::ExternItem::StaticDef(ast) => {\n+                            let statik = self.lower_static(&ast)?;\n+                            statik.into()\n+                        }\n+                    };\n+                    self.add_attrs(id, attrs);\n+                    Some(id)\n+                })\n+                .collect()\n+        })\n+    }\n+\n+    /// Lowers generics defined on `node` and collects inner items defined within.\n+    fn lower_generic_params_and_inner_items(\n+        &mut self,\n+        owner: GenericsOwner<'_>,\n+        node: &impl ast::TypeParamsOwner,\n+    ) -> GenericParamsId {\n+        // Generics are part of item headers and may contain inner items we need to collect.\n+        if let Some(params) = node.type_param_list() {\n+            self.collect_inner_items(params.syntax());\n+        }\n+        if let Some(clause) = node.where_clause() {\n+            self.collect_inner_items(clause.syntax());\n+        }\n+\n+        self.lower_generic_params(owner, node)\n+    }\n+\n+    fn lower_generic_params(\n+        &mut self,\n+        owner: GenericsOwner<'_>,\n+        node: &impl ast::TypeParamsOwner,\n+    ) -> GenericParamsId {\n+        let mut sm = &mut ArenaMap::default();\n+        let mut generics = GenericParams::default();\n+        match owner {\n+            GenericsOwner::Function(func) => {\n+                generics.fill(&self.body_ctx, sm, node);\n+                // lower `impl Trait` in arguments\n+                for param in &*func.params {\n+                    generics.fill_implicit_impl_trait_args(param);\n+                }\n+            }\n+            GenericsOwner::Struct\n+            | GenericsOwner::Enum\n+            | GenericsOwner::Union\n+            | GenericsOwner::TypeAlias => {\n+                generics.fill(&self.body_ctx, sm, node);\n+            }\n+            GenericsOwner::Trait(trait_def) => {\n+                // traits get the Self type as an implicit first type parameter\n+                let self_param_id = generics.types.alloc(TypeParamData {\n+                    name: Some(name![Self]),\n+                    default: None,\n+                    provenance: TypeParamProvenance::TraitSelf,\n+                });\n+                sm.insert(self_param_id, Either::Left(trait_def.clone()));\n+                // add super traits as bounds on Self\n+                // i.e., trait Foo: Bar is equivalent to trait Foo where Self: Bar\n+                let self_param = TypeRef::Path(name![Self].into());\n+                generics.fill_bounds(&self.body_ctx, trait_def, self_param);\n+\n+                generics.fill(&self.body_ctx, &mut sm, node);\n+            }\n+            GenericsOwner::Impl => {\n+                // Note that we don't add `Self` here: in `impl`s, `Self` is not a\n+                // type-parameter, but rather is a type-alias for impl's target\n+                // type, so this is handled by the resolver.\n+                generics.fill(&self.body_ctx, &mut sm, node);\n+            }\n+        }\n+\n+        self.data().generics.alloc(generics)\n+    }\n+\n+    fn lower_type_bounds(&mut self, node: &impl ast::TypeBoundsOwner) -> Vec<TypeBound> {\n+        match node.type_bound_list() {\n+            Some(bound_list) => {\n+                bound_list.bounds().map(|it| TypeBound::from_ast(&self.body_ctx, it)).collect()\n+            }\n+            None => Vec::new(),\n+        }\n+    }\n+\n+    fn lower_visibility(&mut self, item: &impl ast::VisibilityOwner) -> RawVisibilityId {\n+        let vis = match self.forced_visibility {\n+            Some(vis) => return vis,\n+            None => RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene),\n+        };\n+\n+        self.data().vis.alloc(vis)\n+    }\n+\n+    fn lower_type_ref(&self, type_ref: &ast::TypeRef) -> TypeRef {\n+        TypeRef::from_ast(&self.body_ctx, type_ref.clone())\n+    }\n+    fn lower_type_ref_opt(&self, type_ref: Option<ast::TypeRef>) -> TypeRef {\n+        type_ref.map(|ty| self.lower_type_ref(&ty)).unwrap_or(TypeRef::Error)\n+    }\n+\n+    /// Forces the visibility `vis` to be used for all items lowered during execution of `f`.\n+    fn with_inherited_visibility<R>(\n+        &mut self,\n+        vis: RawVisibilityId,\n+        f: impl FnOnce(&mut Self) -> R,\n+    ) -> R {\n+        let old = mem::replace(&mut self.forced_visibility, Some(vis));\n+        let res = f(self);\n+        self.forced_visibility = old;\n+        res\n+    }\n+\n+    fn next_field_idx(&self) -> Idx<Field> {\n+        Idx::from_raw(RawId::from(\n+            self.tree.data.as_ref().map_or(0, |data| data.fields.len() as u32),\n+        ))\n+    }\n+    fn next_variant_idx(&self) -> Idx<Variant> {\n+        Idx::from_raw(RawId::from(\n+            self.tree.data.as_ref().map_or(0, |data| data.variants.len() as u32),\n+        ))\n+    }\n+}\n+\n+fn desugar_future_path(orig: TypeRef) -> Path {\n+    let path = path![core::future::Future];\n+    let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n+    let mut last = GenericArgs::empty();\n+    let binding =\n+        AssociatedTypeBinding { name: name![Output], type_ref: Some(orig), bounds: Vec::new() };\n+    last.bindings.push(binding);\n+    generic_args.push(Some(Arc::new(last)));\n+\n+    Path::from_known_path(path, generic_args)\n+}\n+\n+enum GenericsOwner<'a> {\n+    /// We need access to the partially-lowered `Function` for lowering `impl Trait` in argument\n+    /// position.\n+    Function(&'a Function),\n+    Struct,\n+    Enum,\n+    Union,\n+    /// The `TraitDef` is needed to fill the source map for the implicit `Self` parameter.\n+    Trait(&'a ast::TraitDef),\n+    TypeAlias,\n+    Impl,\n+}"}, {"sha": "dc035d809ecf7b707d5beecfb37e3737b44ff53c", "filename": "crates/ra_hir_def/src/item_tree/tests.rs", "status": "added", "additions": 435, "deletions": 0, "changes": 435, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -0,0 +1,435 @@\n+use super::{ItemTree, ModItem, ModKind};\n+use crate::{db::DefDatabase, test_db::TestDB};\n+use hir_expand::{db::AstDatabase, HirFileId, InFile};\n+use insta::assert_snapshot;\n+use ra_db::fixture::WithFixture;\n+use ra_syntax::{ast, AstNode};\n+use rustc_hash::FxHashSet;\n+use std::sync::Arc;\n+use stdx::format_to;\n+\n+fn test_inner_items(ra_fixture: &str) {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    let file_id = HirFileId::from(file_id);\n+    let tree = db.item_tree(file_id);\n+    let root = db.parse_or_expand(file_id).unwrap();\n+    let ast_id_map = db.ast_id_map(file_id);\n+\n+    // Traverse the item tree and collect all module/impl/trait-level items as AST nodes.\n+    let mut outer_items = FxHashSet::default();\n+    let mut worklist = tree.top_level_items().to_vec();\n+    while let Some(item) = worklist.pop() {\n+        let node: ast::ModuleItem = match item {\n+            ModItem::Import(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n+            ModItem::ExternCrate(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n+            ModItem::Function(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n+            ModItem::Struct(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n+            ModItem::Union(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n+            ModItem::Enum(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n+            ModItem::Const(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n+            ModItem::Static(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n+            ModItem::TypeAlias(it) => tree.source(&db, InFile::new(file_id, it)).into(),\n+            ModItem::Mod(it) => {\n+                if let ModKind::Inline { items } = &tree[it].kind {\n+                    worklist.extend(&**items);\n+                }\n+                tree.source(&db, InFile::new(file_id, it)).into()\n+            }\n+            ModItem::Trait(it) => {\n+                worklist.extend(tree[it].items.iter().map(|item| ModItem::from(*item)));\n+                tree.source(&db, InFile::new(file_id, it)).into()\n+            }\n+            ModItem::Impl(it) => {\n+                worklist.extend(tree[it].items.iter().map(|item| ModItem::from(*item)));\n+                tree.source(&db, InFile::new(file_id, it)).into()\n+            }\n+            ModItem::MacroCall(_) => continue,\n+        };\n+\n+        outer_items.insert(node);\n+    }\n+\n+    // Now descend the root node and check that all `ast::ModuleItem`s are either recorded above, or\n+    // registered as inner items.\n+    for item in root.descendants().skip(1).filter_map(ast::ModuleItem::cast) {\n+        if outer_items.contains(&item) {\n+            continue;\n+        }\n+\n+        let ast_id = ast_id_map.ast_id(&item);\n+        assert!(!tree.inner_items(ast_id).is_empty());\n+    }\n+}\n+\n+fn item_tree(ra_fixture: &str) -> Arc<ItemTree> {\n+    let (db, file_id) = TestDB::with_single_file(ra_fixture);\n+    db.item_tree(file_id.into())\n+}\n+\n+fn print_item_tree(ra_fixture: &str) -> String {\n+    let tree = item_tree(ra_fixture);\n+    let mut out = String::new();\n+\n+    format_to!(out, \"inner attrs: {:?}\\n\\n\", tree.top_level_attrs());\n+    format_to!(out, \"top-level items:\\n\");\n+    for item in tree.top_level_items() {\n+        fmt_mod_item(&mut out, &tree, *item);\n+        format_to!(out, \"\\n\");\n+    }\n+\n+    if !tree.inner_items.is_empty() {\n+        format_to!(out, \"\\ninner items:\\n\\n\");\n+        for (ast_id, items) in &tree.inner_items {\n+            format_to!(out, \"for AST {:?}:\\n\", ast_id);\n+            for inner in items {\n+                fmt_mod_item(&mut out, &tree, *inner);\n+                format_to!(out, \"\\n\\n\");\n+            }\n+        }\n+    }\n+\n+    out\n+}\n+\n+fn fmt_mod_item(out: &mut String, tree: &ItemTree, item: ModItem) {\n+    let attrs = tree.attrs(item);\n+    if !attrs.is_empty() {\n+        format_to!(out, \"#[{:?}]\\n\", attrs);\n+    }\n+\n+    let mut children = String::new();\n+    match item {\n+        ModItem::ExternCrate(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Import(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Function(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Struct(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Union(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Enum(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Const(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Static(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Trait(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+            for item in &*tree[it].items {\n+                fmt_mod_item(&mut children, tree, ModItem::from(*item));\n+                format_to!(children, \"\\n\");\n+            }\n+        }\n+        ModItem::Impl(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+            for item in &*tree[it].items {\n+                fmt_mod_item(&mut children, tree, ModItem::from(*item));\n+                format_to!(children, \"\\n\");\n+            }\n+        }\n+        ModItem::TypeAlias(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+        ModItem::Mod(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+            match &tree[it].kind {\n+                ModKind::Inline { items } => {\n+                    for item in &**items {\n+                        fmt_mod_item(&mut children, tree, *item);\n+                        format_to!(children, \"\\n\");\n+                    }\n+                }\n+                ModKind::Outline {} => {}\n+            }\n+        }\n+        ModItem::MacroCall(it) => {\n+            format_to!(out, \"{:?}\", tree[it]);\n+        }\n+    }\n+\n+    for line in children.lines() {\n+        format_to!(out, \"\\n> {}\", line);\n+    }\n+}\n+\n+#[test]\n+fn smoke() {\n+    assert_snapshot!(print_item_tree(r\"\n+        #![attr]\n+\n+        #[attr_on_use]\n+        use {a, b::*};\n+\n+        #[ext_crate]\n+        extern crate krate;\n+\n+        #[on_trait]\n+        trait Tr<U> {\n+            #[assoc_ty]\n+            type AssocTy: Tr<()>;\n+\n+            #[assoc_const]\n+            const CONST: u8;\n+\n+            #[assoc_method]\n+            fn method(&self);\n+\n+            #[assoc_dfl_method]\n+            fn dfl_method(&mut self) {}\n+        }\n+\n+        #[struct0]\n+        struct Struct0<T = ()>;\n+\n+        #[struct1]\n+        struct Struct1<T>(#[struct1fld] u8);\n+\n+        #[struct2]\n+        struct Struct2<T> {\n+            #[struct2fld]\n+            fld: (T, ),\n+        }\n+\n+        #[en]\n+        enum En {\n+            #[enum_variant]\n+            Variant {\n+                #[enum_field]\n+                field: u8,\n+            },\n+        }\n+\n+        #[un]\n+        union Un {\n+            #[union_fld]\n+            fld: u16,\n+        }\n+    \"), @r###\"\n+inner attrs: Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr\"))] }, input: None }]) }\n+\n+top-level items:\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n+Import { path: ModPath { kind: Plain, segments: [Name(Text(\"a\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: false, is_prelude: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UseItem>(0) }\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_on_use\"))] }, input: None }]) }]\n+Import { path: ModPath { kind: Plain, segments: [Name(Text(\"b\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_glob: true, is_prelude: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UseItem>(0) }\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"ext_crate\"))] }, input: None }]) }]\n+ExternCrate { path: ModPath { kind: Plain, segments: [Name(Text(\"krate\"))] }, alias: None, visibility: RawVisibilityId(\"pub(self)\"), is_macro_use: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ExternCrateItem>(1) }\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_trait\"))] }, input: None }]) }]\n+Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [TypeAlias(Idx::<TypeAlias>(0)), Const(Idx::<Const>(0)), Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::TraitDef>(2) }\n+> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_ty\"))] }, input: None }]) }]\n+> TypeAlias { name: Name(Text(\"AssocTy\")), visibility: RawVisibilityId(\"pub(self)\"), bounds: [Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Tr\"))] }, generic_args: [Some(GenericArgs { args: [Type(Tuple([]))], has_self_type: false, bindings: [] })] })], generic_params: GenericParamsId(4294967295), type_ref: None, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::TypeAliasDef>(8) }\n+> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_const\"))] }, input: None }]) }]\n+> Const { name: Some(Name(Text(\"CONST\"))), visibility: RawVisibilityId(\"pub(self)\"), type_ref: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"u8\"))] }, generic_args: [None] }), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ConstDef>(9) }\n+> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_method\"))] }, input: None }]) }]\n+> Function { name: Name(Text(\"method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Shared)], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(10) }\n+> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"assoc_dfl_method\"))] }, input: None }]) }]\n+> Function { name: Name(Text(\"dfl_method\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: true, is_unsafe: false, params: [Reference(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Self\"))] }, generic_args: [None] }), Mut)], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(11) }\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct0\"))] }, input: None }]) }]\n+Struct { name: Name(Text(\"Struct0\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), fields: Unit, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(3), kind: Unit }\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct1\"))] }, input: None }]) }]\n+Struct { name: Name(Text(\"Struct1\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(2), fields: Tuple(Idx::<Field>(0)..Idx::<Field>(1)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(4), kind: Tuple }\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"struct2\"))] }, input: None }]) }]\n+Struct { name: Name(Text(\"Struct2\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(3), fields: Record(Idx::<Field>(1)..Idx::<Field>(2)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::StructDef>(5), kind: Record }\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"en\"))] }, input: None }]) }]\n+Enum { name: Name(Text(\"En\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), variants: Idx::<Variant>(0)..Idx::<Variant>(1), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::EnumDef>(6) }\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"un\"))] }, input: None }]) }]\n+Union { name: Name(Text(\"Un\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), fields: Record(Idx::<Field>(3)..Idx::<Field>(4)), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::UnionDef>(7) }\n+    \"###);\n+}\n+\n+#[test]\n+fn simple_inner_items() {\n+    let tree = print_item_tree(\n+        r\"\n+        impl<T:A> D for Response<T> {\n+            fn foo() {\n+                end();\n+                fn end<W: Write>() {\n+                    let _x: T = loop {};\n+                }\n+            }\n+        }\n+    \",\n+    );\n+\n+    assert_snapshot!(tree, @r###\"\n+inner attrs: Attrs { entries: None }\n+\n+top-level items:\n+Impl { generic_params: GenericParamsId(0), target_trait: Some(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"D\"))] }, generic_args: [None] })), target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Response\"))] }, generic_args: [Some(GenericArgs { args: [Type(Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"T\"))] }, generic_args: [None] }))], has_self_type: false, bindings: [] })] }), is_negative: false, items: [Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ImplDef>(0) }\n+> Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n+\n+inner items:\n+\n+for AST FileAstId::<ra_syntax::ast::generated::nodes::ModuleItem>(2):\n+Function { name: Name(Text(\"end\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(1), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n+\n+    \"###);\n+}\n+\n+#[test]\n+fn extern_attrs() {\n+    let tree = print_item_tree(\n+        r#\"\n+        #[block_attr]\n+        extern \"C\" {\n+            #[attr_a]\n+            fn a() {}\n+            #[attr_b]\n+            fn b() {}\n+        }\n+    \"#,\n+    );\n+\n+    assert_snapshot!(tree, @r###\"\n+inner attrs: Attrs { entries: None }\n+\n+top-level items:\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n+Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }, Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"block_attr\"))] }, input: None }]) }]\n+Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n+    \"###);\n+}\n+\n+#[test]\n+fn trait_attrs() {\n+    let tree = print_item_tree(\n+        r#\"\n+        #[trait_attr]\n+        trait Tr {\n+            #[attr_a]\n+            fn a() {}\n+            #[attr_b]\n+            fn b() {}\n+        }\n+    \"#,\n+    );\n+\n+    assert_snapshot!(tree, @r###\"\n+inner attrs: Attrs { entries: None }\n+\n+top-level items:\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"trait_attr\"))] }, input: None }]) }]\n+Trait { name: Name(Text(\"Tr\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(0), auto: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::TraitDef>(0) }\n+> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n+> Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n+> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n+> Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n+    \"###);\n+}\n+\n+#[test]\n+fn impl_attrs() {\n+    let tree = print_item_tree(\n+        r#\"\n+        #[impl_attr]\n+        impl Ty {\n+            #[attr_a]\n+            fn a() {}\n+            #[attr_b]\n+            fn b() {}\n+        }\n+    \"#,\n+    );\n+\n+    assert_snapshot!(tree, @r###\"\n+inner attrs: Attrs { entries: None }\n+\n+top-level items:\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"impl_attr\"))] }, input: None }]) }]\n+Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"Ty\"))] }, generic_args: [None] }), is_negative: false, items: [Function(Idx::<Function>(0)), Function(Idx::<Function>(1))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ImplDef>(0) }\n+> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_a\"))] }, input: None }]) }]\n+> Function { name: Name(Text(\"a\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n+> #[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"attr_b\"))] }, input: None }]) }]\n+> Function { name: Name(Text(\"b\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(2) }\n+    \"###);\n+}\n+\n+#[test]\n+fn cursed_inner_items() {\n+    test_inner_items(\n+        r\"\n+        struct S<T: Trait = [u8; { fn f() {} 0 }]>(T);\n+\n+        enum En {\n+            Var1 {\n+                t: [(); { trait Inner {} 0 }],\n+            },\n+\n+            Var2([u16; { enum Inner {} 0 }]),\n+        }\n+\n+        type Ty = [En; { struct Inner; 0 }];\n+\n+        impl En {\n+            fn assoc() {\n+                trait InnerTrait<T = [u8; { fn f() {} }]> {}\n+                struct InnerStruct<T = [u8; { fn f() {} }]> {}\n+                impl<T = [u8; { fn f() {} }]> InnerTrait for InnerStruct {}\n+            }\n+        }\n+\n+        trait Tr<T = [u8; { fn f() {} }]> {\n+            type AssocTy = [u8; { fn f() {} }];\n+\n+            const AssocConst: [u8; { fn f() {} }];\n+        }\n+    \",\n+    );\n+}\n+\n+#[test]\n+fn inner_item_attrs() {\n+    let tree = print_item_tree(\n+        r\"\n+        fn foo() {\n+            #[on_inner]\n+            fn inner() {}\n+        }\n+    \",\n+    );\n+\n+    assert_snapshot!(tree, @r###\"\n+inner attrs: Attrs { entries: None }\n+\n+top-level items:\n+Function { name: Name(Text(\"foo\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(0) }\n+\n+inner items:\n+\n+for AST FileAstId::<ra_syntax::ast::generated::nodes::ModuleItem>(1):\n+#[Attrs { entries: Some([Attr { path: ModPath { kind: Plain, segments: [Name(Text(\"on_inner\"))] }, input: None }]) }]\n+Function { name: Name(Text(\"inner\")), visibility: RawVisibilityId(\"pub(self)\"), generic_params: GenericParamsId(4294967295), has_self_param: false, is_unsafe: false, params: [], ret_type: Tuple([]), ast_id: FileAstId::<ra_syntax::ast::generated::nodes::FnDef>(1) }\n+\n+    \"###);\n+}\n+\n+#[test]\n+fn assoc_item_macros() {\n+    let tree = print_item_tree(\n+        r\"\n+        impl S {\n+            items!();\n+        }\n+    \",\n+    );\n+\n+    assert_snapshot!(tree, @r###\"\n+inner attrs: Attrs { entries: None }\n+\n+top-level items:\n+Impl { generic_params: GenericParamsId(4294967295), target_trait: None, target_type: Path(Path { type_anchor: None, mod_path: ModPath { kind: Plain, segments: [Name(Text(\"S\"))] }, generic_args: [None] }), is_negative: false, items: [MacroCall(Idx::<MacroCall>(0))], ast_id: FileAstId::<ra_syntax::ast::generated::nodes::ImplDef>(0) }\n+> MacroCall { name: None, path: ModPath { kind: Plain, segments: [Name(Text(\"items\"))] }, is_export: false, is_local_inner: false, is_builtin: false, ast_id: FileAstId::<ra_syntax::ast::generated::nodes::MacroCall>(1) }\n+    \"###);\n+}"}, {"sha": "564434cccf0e79748b9446d6118528cfb8e56961", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 80, "deletions": 19, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -25,6 +25,8 @@ pub mod item_scope;\n pub mod dyn_map;\n pub mod keys;\n \n+pub mod item_tree;\n+\n pub mod adt;\n pub mod data;\n pub mod generics;\n@@ -48,18 +50,21 @@ pub mod import_map;\n #[cfg(test)]\n mod test_db;\n \n-use std::hash::Hash;\n+use std::hash::{Hash, Hasher};\n \n use hir_expand::{\n     ast_id_map::FileAstId, eager::expand_eager_macro, hygiene::Hygiene, AstId, HirFileId, InFile,\n     MacroCallId, MacroCallKind, MacroDefId, MacroDefKind,\n };\n use ra_arena::Idx;\n use ra_db::{impl_intern_key, salsa, CrateId};\n-use ra_syntax::{ast, AstNode};\n+use ra_syntax::ast;\n \n-use crate::body::Expander;\n use crate::builtin_type::BuiltinType;\n+use item_tree::{\n+    Const, Enum, Function, Impl, ItemTreeId, ItemTreeNode, ModItem, Static, Struct, Trait,\n+    TypeAlias, Union,\n+};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ModuleId {\n@@ -70,16 +75,62 @@ pub struct ModuleId {\n /// An ID of a module, **local** to a specific crate\n pub type LocalModuleId = Idx<nameres::ModuleData>;\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct ItemLoc<N: AstNode> {\n+#[derive(Debug)]\n+pub struct ItemLoc<N: ItemTreeNode> {\n     pub container: ContainerId,\n-    pub ast_id: AstId<N>,\n+    pub id: ItemTreeId<N>,\n+}\n+\n+impl<N: ItemTreeNode> Clone for ItemLoc<N> {\n+    fn clone(&self) -> Self {\n+        Self { container: self.container, id: self.id }\n+    }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct AssocItemLoc<N: AstNode> {\n+impl<N: ItemTreeNode> Copy for ItemLoc<N> {}\n+\n+impl<N: ItemTreeNode> PartialEq for ItemLoc<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.container == other.container && self.id == other.id\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Eq for ItemLoc<N> {}\n+\n+impl<N: ItemTreeNode> Hash for ItemLoc<N> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.container.hash(state);\n+        self.id.hash(state);\n+    }\n+}\n+\n+#[derive(Debug)]\n+pub struct AssocItemLoc<N: ItemTreeNode> {\n     pub container: AssocContainerId,\n-    pub ast_id: AstId<N>,\n+    pub id: ItemTreeId<N>,\n+}\n+\n+impl<N: ItemTreeNode> Clone for AssocItemLoc<N> {\n+    fn clone(&self) -> Self {\n+        Self { container: self.container, id: self.id }\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Copy for AssocItemLoc<N> {}\n+\n+impl<N: ItemTreeNode> PartialEq for AssocItemLoc<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.container == other.container && self.id == other.id\n+    }\n+}\n+\n+impl<N: ItemTreeNode> Eq for AssocItemLoc<N> {}\n+\n+impl<N: ItemTreeNode> Hash for AssocItemLoc<N> {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.container.hash(state);\n+        self.id.hash(state);\n+    }\n }\n \n macro_rules! impl_intern {\n@@ -104,22 +155,22 @@ macro_rules! impl_intern {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct FunctionId(salsa::InternId);\n-type FunctionLoc = AssocItemLoc<ast::FnDef>;\n+type FunctionLoc = AssocItemLoc<Function>;\n impl_intern!(FunctionId, FunctionLoc, intern_function, lookup_intern_function);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StructId(salsa::InternId);\n-type StructLoc = ItemLoc<ast::StructDef>;\n+type StructLoc = ItemLoc<Struct>;\n impl_intern!(StructId, StructLoc, intern_struct, lookup_intern_struct);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct UnionId(salsa::InternId);\n-pub type UnionLoc = ItemLoc<ast::UnionDef>;\n+pub type UnionLoc = ItemLoc<Union>;\n impl_intern!(UnionId, UnionLoc, intern_union, lookup_intern_union);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct EnumId(salsa::InternId);\n-pub type EnumLoc = ItemLoc<ast::EnumDef>;\n+pub type EnumLoc = ItemLoc<Enum>;\n impl_intern!(EnumId, EnumLoc, intern_enum, lookup_intern_enum);\n \n // FIXME: rename to `VariantId`, only enums can ave variants\n@@ -141,27 +192,27 @@ pub type LocalFieldId = Idx<adt::FieldData>;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct ConstId(salsa::InternId);\n-type ConstLoc = AssocItemLoc<ast::ConstDef>;\n+type ConstLoc = AssocItemLoc<Const>;\n impl_intern!(ConstId, ConstLoc, intern_const, lookup_intern_const);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct StaticId(salsa::InternId);\n-pub type StaticLoc = ItemLoc<ast::StaticDef>;\n+pub type StaticLoc = ItemLoc<Static>;\n impl_intern!(StaticId, StaticLoc, intern_static, lookup_intern_static);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TraitId(salsa::InternId);\n-pub type TraitLoc = ItemLoc<ast::TraitDef>;\n+pub type TraitLoc = ItemLoc<Trait>;\n impl_intern!(TraitId, TraitLoc, intern_trait, lookup_intern_trait);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub struct TypeAliasId(salsa::InternId);\n-type TypeAliasLoc = AssocItemLoc<ast::TypeAliasDef>;\n+type TypeAliasLoc = AssocItemLoc<TypeAlias>;\n impl_intern!(TypeAliasId, TypeAliasLoc, intern_type_alias, lookup_intern_type_alias);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Ord, PartialOrd)]\n pub struct ImplId(salsa::InternId);\n-type ImplLoc = ItemLoc<ast::ImplDef>;\n+type ImplLoc = ItemLoc<Impl>;\n impl_intern!(ImplId, ImplLoc, intern_impl, lookup_intern_impl);\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n@@ -365,7 +416,7 @@ impl HasModule for AssocContainerId {\n     }\n }\n \n-impl<N: AstNode> HasModule for AssocItemLoc<N> {\n+impl<N: ItemTreeNode> HasModule for AssocItemLoc<N> {\n     fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         self.container.module(db)\n     }\n@@ -392,6 +443,16 @@ impl HasModule for DefWithBodyId {\n     }\n }\n \n+impl DefWithBodyId {\n+    pub fn as_mod_item(self, db: &dyn db::DefDatabase) -> ModItem {\n+        match self {\n+            DefWithBodyId::FunctionId(it) => it.lookup(db).id.value.into(),\n+            DefWithBodyId::StaticId(it) => it.lookup(db).id.value.into(),\n+            DefWithBodyId::ConstId(it) => it.lookup(db).id.value.into(),\n+        }\n+    }\n+}\n+\n impl HasModule for GenericDefId {\n     fn module(&self, db: &dyn db::DefDatabase) -> ModuleId {\n         match self {"}, {"sha": "b279bdeef6abc89a1b2494a28fedb3ed9cfaf72c", "filename": "crates/ra_hir_def/src/nameres.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -47,7 +47,6 @@\n //! path and, upon success, we run macro expansion and \"collect module\" phase on\n //! the result\n \n-pub(crate) mod raw;\n mod collector;\n mod mod_resolution;\n mod path_resolution;"}, {"sha": "94da700ad37cb39e08803ca7b22dcd227ce07c7d", "filename": "crates/ra_hir_def/src/nameres/collector.rs", "status": "modified", "additions": 254, "deletions": 132, "changes": 386, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fcollector.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -4,6 +4,7 @@\n //! resolves imports and expands macros.\n \n use hir_expand::{\n+    ast_id_map::FileAstId,\n     builtin_derive::find_builtin_derive,\n     builtin_macro::find_builtin_macro,\n     name::{name, AsName, Name},\n@@ -19,13 +20,16 @@ use test_utils::mark;\n use crate::{\n     attr::Attrs,\n     db::DefDatabase,\n+    item_tree::{\n+        self, FileItemTreeId, ItemTree, ItemTreeId, MacroCall, Mod, ModItem, ModKind, StructDefKind,\n+    },\n     nameres::{\n         diagnostics::DefDiagnostic, mod_resolution::ModDir, path_resolution::ReachedFixedPoint,\n-        raw, BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n+        BuiltinShadowMode, CrateDefMap, ModuleData, ModuleOrigin, ResolveMode,\n     },\n     path::{ImportAlias, ModPath, PathKind},\n     per_ns::PerNs,\n-    visibility::Visibility,\n+    visibility::{RawVisibility, Visibility},\n     AdtId, AsMacroCall, AstId, AstIdWithPath, ConstLoc, ContainerId, EnumLoc, EnumVariantId,\n     FunctionLoc, ImplLoc, Intern, LocalModuleId, ModuleDefId, ModuleId, StaticLoc, StructLoc,\n     TraitLoc, TypeAliasLoc, UnionLoc,\n@@ -101,11 +105,51 @@ impl PartialResolvedImport {\n     }\n }\n \n+#[derive(Clone, Debug, Eq, PartialEq)]\n+struct Import {\n+    pub path: ModPath,\n+    pub alias: Option<ImportAlias>,\n+    pub visibility: RawVisibility,\n+    pub is_glob: bool,\n+    pub is_prelude: bool,\n+    pub is_extern_crate: bool,\n+    pub is_macro_use: bool,\n+}\n+\n+impl Import {\n+    fn from_use(tree: &ItemTree, id: FileItemTreeId<item_tree::Import>) -> Self {\n+        let it = &tree[id];\n+        let visibility = &tree[it.visibility];\n+        Self {\n+            path: it.path.clone(),\n+            alias: it.alias.clone(),\n+            visibility: visibility.clone(),\n+            is_glob: it.is_glob,\n+            is_prelude: it.is_prelude,\n+            is_extern_crate: false,\n+            is_macro_use: false,\n+        }\n+    }\n+\n+    fn from_extern_crate(tree: &ItemTree, id: FileItemTreeId<item_tree::ExternCrate>) -> Self {\n+        let it = &tree[id];\n+        let visibility = &tree[it.visibility];\n+        Self {\n+            path: it.path.clone(),\n+            alias: it.alias.clone(),\n+            visibility: visibility.clone(),\n+            is_glob: false,\n+            is_prelude: false,\n+            is_extern_crate: true,\n+            is_macro_use: it.is_macro_use,\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug, Eq, PartialEq)]\n struct ImportDirective {\n     module_id: LocalModuleId,\n-    import_id: raw::Import,\n-    import: raw::ImportData,\n+    import: Import,\n     status: PartialResolvedImport,\n }\n \n@@ -123,6 +167,13 @@ struct DeriveDirective {\n     ast_id: AstIdWithPath<ast::ModuleItem>,\n }\n \n+struct DefData<'a> {\n+    id: ModuleDefId,\n+    name: &'a Name,\n+    visibility: &'a RawVisibility,\n+    has_constructor: bool,\n+}\n+\n /// Walks the tree of module recursively\n struct DefCollector<'a> {\n     db: &'a dyn DefDatabase,\n@@ -140,18 +191,18 @@ struct DefCollector<'a> {\n impl DefCollector<'_> {\n     fn collect(&mut self) {\n         let file_id = self.db.crate_graph()[self.def_map.krate].root_file_id;\n-        let raw_items = self.db.raw_items(file_id.into());\n+        let item_tree = self.db.item_tree(file_id.into());\n         let module_id = self.def_map.root;\n         self.def_map.modules[module_id].origin = ModuleOrigin::CrateRoot { definition: file_id };\n         ModCollector {\n             def_collector: &mut *self,\n             macro_depth: 0,\n             module_id,\n             file_id: file_id.into(),\n-            raw_items: &raw_items,\n+            item_tree: &item_tree,\n             mod_dir: ModDir::root(),\n         }\n-        .collect(raw_items.items());\n+        .collect(item_tree.top_level_items());\n \n         // main name resolution fixed-point loop.\n         let mut i = 0;\n@@ -286,7 +337,7 @@ impl DefCollector<'_> {\n     fn import_macros_from_extern_crate(\n         &mut self,\n         current_module_id: LocalModuleId,\n-        import: &raw::ImportData,\n+        import: &item_tree::ExternCrate,\n     ) {\n         log::debug!(\n             \"importing macros from extern crate: {:?} ({:?})\",\n@@ -352,11 +403,7 @@ impl DefCollector<'_> {\n         }\n     }\n \n-    fn resolve_import(\n-        &self,\n-        module_id: LocalModuleId,\n-        import: &raw::ImportData,\n-    ) -> PartialResolvedImport {\n+    fn resolve_import(&self, module_id: LocalModuleId, import: &Import) -> PartialResolvedImport {\n         log::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n         if import.is_extern_crate {\n             let res = self.def_map.resolve_name_in_extern_prelude(\n@@ -649,17 +696,17 @@ impl DefCollector<'_> {\n         depth: usize,\n     ) {\n         let file_id: HirFileId = macro_call_id.as_file();\n-        let raw_items = self.db.raw_items(file_id);\n+        let item_tree = self.db.item_tree(file_id);\n         let mod_dir = self.mod_dirs[&module_id].clone();\n         ModCollector {\n             def_collector: &mut *self,\n             macro_depth: depth,\n             file_id,\n             module_id,\n-            raw_items: &raw_items,\n+            item_tree: &item_tree,\n             mod_dir,\n         }\n-        .collect(raw_items.items());\n+        .collect(item_tree.top_level_items());\n     }\n \n     fn finish(self) -> CrateDefMap {\n@@ -673,12 +720,12 @@ struct ModCollector<'a, 'b> {\n     macro_depth: usize,\n     module_id: LocalModuleId,\n     file_id: HirFileId,\n-    raw_items: &'a raw::RawItems,\n+    item_tree: &'a ItemTree,\n     mod_dir: ModDir,\n }\n \n impl ModCollector<'_, '_> {\n-    fn collect(&mut self, items: &[raw::RawItem]) {\n+    fn collect(&mut self, items: &[ModItem]) {\n         // Note: don't assert that inserted value is fresh: it's simply not true\n         // for macros.\n         self.def_collector.mod_dirs.insert(self.module_id, self.mod_dir.clone());\n@@ -695,105 +742,245 @@ impl ModCollector<'_, '_> {\n         // `#[macro_use] extern crate` is hoisted to imports macros before collecting\n         // any other items.\n         for item in items {\n-            if self.is_cfg_enabled(&item.attrs) {\n-                if let raw::RawItemKind::Import(import_id) = item.kind {\n-                    let import = self.raw_items[import_id].clone();\n-                    if import.is_extern_crate && import.is_macro_use {\n+            if self.is_cfg_enabled(self.item_tree.attrs(*item)) {\n+                if let ModItem::ExternCrate(id) = item {\n+                    let import = self.item_tree[*id].clone();\n+                    if import.is_macro_use {\n                         self.def_collector.import_macros_from_extern_crate(self.module_id, &import);\n                     }\n                 }\n             }\n         }\n \n-        for item in items {\n-            if self.is_cfg_enabled(&item.attrs) {\n-                match item.kind {\n-                    raw::RawItemKind::Module(m) => {\n-                        self.collect_module(&self.raw_items[m], &item.attrs)\n-                    }\n-                    raw::RawItemKind::Import(import_id) => {\n+        for &item in items {\n+            let attrs = self.item_tree.attrs(item);\n+            if self.is_cfg_enabled(attrs) {\n+                let module =\n+                    ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n+                let container = ContainerId::ModuleId(module);\n+\n+                let mut def = None;\n+                match item {\n+                    ModItem::Mod(m) => self.collect_module(&self.item_tree[m], attrs),\n+                    ModItem::Import(import_id) => {\n                         self.def_collector.unresolved_imports.push(ImportDirective {\n                             module_id: self.module_id,\n-                            import_id,\n-                            import: self.raw_items[import_id].clone(),\n+                            import: Import::from_use(&self.item_tree, import_id),\n                             status: PartialResolvedImport::Unresolved,\n                         })\n                     }\n-                    raw::RawItemKind::Def(def) => {\n-                        self.define_def(&self.raw_items[def], &item.attrs)\n+                    ModItem::ExternCrate(import_id) => {\n+                        self.def_collector.unresolved_imports.push(ImportDirective {\n+                            module_id: self.module_id,\n+                            import: Import::from_extern_crate(&self.item_tree, import_id),\n+                            status: PartialResolvedImport::Unresolved,\n+                        })\n                     }\n-                    raw::RawItemKind::Macro(mac) => self.collect_macro(&self.raw_items[mac]),\n-                    raw::RawItemKind::Impl(imp) => {\n+                    ModItem::MacroCall(mac) => self.collect_macro(&self.item_tree[mac]),\n+                    ModItem::Impl(imp) => {\n                         let module = ModuleId {\n                             krate: self.def_collector.def_map.krate,\n                             local_id: self.module_id,\n                         };\n                         let container = ContainerId::ModuleId(module);\n-                        let ast_id = self.raw_items[imp].ast_id;\n-                        let impl_id =\n-                            ImplLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                                .intern(self.def_collector.db);\n+                        let impl_id = ImplLoc { container, id: ItemTreeId::new(self.file_id, imp) }\n+                            .intern(self.def_collector.db);\n                         self.def_collector.def_map.modules[self.module_id]\n                             .scope\n                             .define_impl(impl_id)\n                     }\n+                    ModItem::Function(id) => {\n+                        let func = &self.item_tree[id];\n+                        def = Some(DefData {\n+                            id: FunctionLoc {\n+                                container: container.into(),\n+                                id: ItemTreeId::new(self.file_id, id),\n+                            }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                            name: &func.name,\n+                            visibility: &self.item_tree[func.visibility],\n+                            has_constructor: false,\n+                        });\n+                    }\n+                    ModItem::Struct(id) => {\n+                        let it = &self.item_tree[id];\n+\n+                        // FIXME: check attrs to see if this is an attribute macro invocation;\n+                        // in which case we don't add the invocation, just a single attribute\n+                        // macro invocation\n+                        self.collect_derives(attrs, it.ast_id.upcast());\n+\n+                        def = Some(DefData {\n+                            id: StructLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n+                            name: &it.name,\n+                            visibility: &self.item_tree[it.visibility],\n+                            has_constructor: it.kind != StructDefKind::Record,\n+                        });\n+                    }\n+                    ModItem::Union(id) => {\n+                        let it = &self.item_tree[id];\n+\n+                        // FIXME: check attrs to see if this is an attribute macro invocation;\n+                        // in which case we don't add the invocation, just a single attribute\n+                        // macro invocation\n+                        self.collect_derives(attrs, it.ast_id.upcast());\n+\n+                        def = Some(DefData {\n+                            id: UnionLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n+                            name: &it.name,\n+                            visibility: &self.item_tree[it.visibility],\n+                            has_constructor: false,\n+                        });\n+                    }\n+                    ModItem::Enum(id) => {\n+                        let it = &self.item_tree[id];\n+\n+                        // FIXME: check attrs to see if this is an attribute macro invocation;\n+                        // in which case we don't add the invocation, just a single attribute\n+                        // macro invocation\n+                        self.collect_derives(attrs, it.ast_id.upcast());\n+\n+                        def = Some(DefData {\n+                            id: EnumLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n+                            name: &it.name,\n+                            visibility: &self.item_tree[it.visibility],\n+                            has_constructor: false,\n+                        });\n+                    }\n+                    ModItem::Const(id) => {\n+                        let it = &self.item_tree[id];\n+\n+                        if let Some(name) = &it.name {\n+                            def = Some(DefData {\n+                                id: ConstLoc {\n+                                    container: container.into(),\n+                                    id: ItemTreeId::new(self.file_id, id),\n+                                }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n+                                name,\n+                                visibility: &self.item_tree[it.visibility],\n+                                has_constructor: false,\n+                            });\n+                        }\n+                    }\n+                    ModItem::Static(id) => {\n+                        let it = &self.item_tree[id];\n+\n+                        def = Some(DefData {\n+                            id: StaticLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n+                            name: &it.name,\n+                            visibility: &self.item_tree[it.visibility],\n+                            has_constructor: false,\n+                        });\n+                    }\n+                    ModItem::Trait(id) => {\n+                        let it = &self.item_tree[id];\n+\n+                        def = Some(DefData {\n+                            id: TraitLoc { container, id: ItemTreeId::new(self.file_id, id) }\n+                                .intern(self.def_collector.db)\n+                                .into(),\n+                            name: &it.name,\n+                            visibility: &self.item_tree[it.visibility],\n+                            has_constructor: false,\n+                        });\n+                    }\n+                    ModItem::TypeAlias(id) => {\n+                        let it = &self.item_tree[id];\n+\n+                        def = Some(DefData {\n+                            id: TypeAliasLoc {\n+                                container: container.into(),\n+                                id: ItemTreeId::new(self.file_id, id),\n+                            }\n+                            .intern(self.def_collector.db)\n+                            .into(),\n+                            name: &it.name,\n+                            visibility: &self.item_tree[it.visibility],\n+                            has_constructor: false,\n+                        });\n+                    }\n+                }\n+\n+                if let Some(DefData { id, name, visibility, has_constructor }) = def {\n+                    self.def_collector.def_map.modules[self.module_id].scope.define_def(id);\n+                    let vis = self\n+                        .def_collector\n+                        .def_map\n+                        .resolve_visibility(self.def_collector.db, self.module_id, visibility)\n+                        .unwrap_or(Visibility::Public);\n+                    self.def_collector.update(\n+                        self.module_id,\n+                        &[(name.clone(), PerNs::from_def(id, vis, has_constructor))],\n+                        vis,\n+                    )\n                 }\n             }\n         }\n     }\n \n-    fn collect_module(&mut self, module: &raw::ModuleData, attrs: &Attrs) {\n+    fn collect_module(&mut self, module: &Mod, attrs: &Attrs) {\n         let path_attr = attrs.by_key(\"path\").string_value();\n         let is_macro_use = attrs.by_key(\"macro_use\").exists();\n-        match module {\n+        match &module.kind {\n             // inline module, just recurse\n-            raw::ModuleData::Definition { name, visibility, items, ast_id } => {\n+            ModKind::Inline { items } => {\n                 let module_id = self.push_child_module(\n-                    name.clone(),\n-                    AstId::new(self.file_id, *ast_id),\n+                    module.name.clone(),\n+                    AstId::new(self.file_id, module.ast_id),\n                     None,\n-                    &visibility,\n+                    &self.item_tree[module.visibility],\n                 );\n \n                 ModCollector {\n                     def_collector: &mut *self.def_collector,\n                     macro_depth: self.macro_depth,\n                     module_id,\n                     file_id: self.file_id,\n-                    raw_items: self.raw_items,\n-                    mod_dir: self.mod_dir.descend_into_definition(name, path_attr),\n+                    item_tree: self.item_tree,\n+                    mod_dir: self.mod_dir.descend_into_definition(&module.name, path_attr),\n                 }\n                 .collect(&*items);\n                 if is_macro_use {\n                     self.import_all_legacy_macros(module_id);\n                 }\n             }\n             // out of line module, resolve, parse and recurse\n-            raw::ModuleData::Declaration { name, visibility, ast_id } => {\n-                let ast_id = AstId::new(self.file_id, *ast_id);\n+            ModKind::Outline {} => {\n+                let ast_id = AstId::new(self.file_id, module.ast_id);\n                 match self.mod_dir.resolve_declaration(\n                     self.def_collector.db,\n                     self.file_id,\n-                    name,\n+                    &module.name,\n                     path_attr,\n                 ) {\n                     Ok((file_id, is_mod_rs, mod_dir)) => {\n                         let module_id = self.push_child_module(\n-                            name.clone(),\n+                            module.name.clone(),\n                             ast_id,\n                             Some((file_id, is_mod_rs)),\n-                            &visibility,\n+                            &self.item_tree[module.visibility],\n                         );\n-                        let raw_items = self.def_collector.db.raw_items(file_id.into());\n+                        let item_tree = self.def_collector.db.item_tree(file_id.into());\n                         ModCollector {\n                             def_collector: &mut *self.def_collector,\n                             macro_depth: self.macro_depth,\n                             module_id,\n                             file_id: file_id.into(),\n-                            raw_items: &raw_items,\n+                            item_tree: &item_tree,\n                             mod_dir,\n                         }\n-                        .collect(raw_items.items());\n+                        .collect(item_tree.top_level_items());\n                         if is_macro_use {\n                             self.import_all_legacy_macros(module_id);\n                         }\n@@ -842,77 +1029,7 @@ impl ModCollector<'_, '_> {\n         res\n     }\n \n-    fn define_def(&mut self, def: &raw::DefData, attrs: &Attrs) {\n-        let module = ModuleId { krate: self.def_collector.def_map.krate, local_id: self.module_id };\n-        // FIXME: check attrs to see if this is an attribute macro invocation;\n-        // in which case we don't add the invocation, just a single attribute\n-        // macro invocation\n-        self.collect_derives(attrs, def);\n-\n-        let name = def.name.clone();\n-        let container = ContainerId::ModuleId(module);\n-        let vis = &def.visibility;\n-        let mut has_constructor = false;\n-\n-        let def: ModuleDefId = match def.kind {\n-            raw::DefKind::Function(ast_id) => FunctionLoc {\n-                container: container.into(),\n-                ast_id: AstId::new(self.file_id, ast_id),\n-            }\n-            .intern(self.def_collector.db)\n-            .into(),\n-            raw::DefKind::Struct(ast_id, mode) => {\n-                has_constructor = mode != raw::StructDefKind::Record;\n-                StructLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::Union(ast_id) => {\n-                UnionLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::Enum(ast_id) => {\n-                EnumLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::Const(ast_id) => {\n-                ConstLoc { container: container.into(), ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::Static(ast_id) => {\n-                StaticLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::Trait(ast_id) => {\n-                TraitLoc { container, ast_id: AstId::new(self.file_id, ast_id) }\n-                    .intern(self.def_collector.db)\n-                    .into()\n-            }\n-            raw::DefKind::TypeAlias(ast_id) => TypeAliasLoc {\n-                container: container.into(),\n-                ast_id: AstId::new(self.file_id, ast_id),\n-            }\n-            .intern(self.def_collector.db)\n-            .into(),\n-        };\n-        self.def_collector.def_map.modules[self.module_id].scope.define_def(def);\n-        let vis = self\n-            .def_collector\n-            .def_map\n-            .resolve_visibility(self.def_collector.db, self.module_id, vis)\n-            .unwrap_or(Visibility::Public);\n-        self.def_collector.update(\n-            self.module_id,\n-            &[(name, PerNs::from_def(def, vis, has_constructor))],\n-            vis,\n-        )\n-    }\n-\n-    fn collect_derives(&mut self, attrs: &Attrs, def: &raw::DefData) {\n+    fn collect_derives(&mut self, attrs: &Attrs, ast_id: FileAstId<ast::ModuleItem>) {\n         for derive_subtree in attrs.by_key(\"derive\").tt_values() {\n             // for #[derive(Copy, Clone)], `derive_subtree` is the `(Copy, Clone)` subtree\n             for tt in &derive_subtree.token_trees {\n@@ -923,27 +1040,27 @@ impl ModCollector<'_, '_> {\n                 };\n                 let path = ModPath::from_tt_ident(ident);\n \n-                let ast_id = AstIdWithPath::new(self.file_id, def.kind.ast_id(), path);\n+                let ast_id = AstIdWithPath::new(self.file_id, ast_id, path);\n                 self.def_collector\n                     .unexpanded_attribute_macros\n                     .push(DeriveDirective { module_id: self.module_id, ast_id });\n             }\n         }\n     }\n \n-    fn collect_macro(&mut self, mac: &raw::MacroData) {\n+    fn collect_macro(&mut self, mac: &MacroCall) {\n         let mut ast_id = AstIdWithPath::new(self.file_id, mac.ast_id, mac.path.clone());\n \n         // Case 0: builtin macros\n-        if mac.builtin {\n+        if mac.is_builtin {\n             if let Some(name) = &mac.name {\n                 let krate = self.def_collector.def_map.krate;\n                 if let Some(macro_id) = find_builtin_macro(name, krate, ast_id.ast_id) {\n                     self.def_collector.define_macro(\n                         self.module_id,\n                         name.clone(),\n                         macro_id,\n-                        mac.export,\n+                        mac.is_export,\n                     );\n                     return;\n                 }\n@@ -957,9 +1074,14 @@ impl ModCollector<'_, '_> {\n                     ast_id: Some(ast_id.ast_id),\n                     krate: Some(self.def_collector.def_map.krate),\n                     kind: MacroDefKind::Declarative,\n-                    local_inner: mac.local_inner,\n+                    local_inner: mac.is_local_inner,\n                 };\n-                self.def_collector.define_macro(self.module_id, name.clone(), macro_id, mac.export);\n+                self.def_collector.define_macro(\n+                    self.module_id,\n+                    name.clone(),\n+                    macro_id,\n+                    mac.is_export,\n+                );\n             }\n             return;\n         }"}, {"sha": "f44baa57942fb0dc887312ba0fdacef183973abb", "filename": "crates/ra_hir_def/src/nameres/raw.rs", "status": "removed", "additions": 0, "deletions": 482, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/1a3b507a007d0373a83bde203d780b860ea55ce1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a3b507a007d0373a83bde203d780b860ea55ce1/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Fraw.rs?ref=1a3b507a007d0373a83bde203d780b860ea55ce1", "patch": "@@ -1,482 +0,0 @@\n-//! Lowers syntax tree of a rust file into a raw representation of containing\n-//! items, *without* attaching them to a module structure.\n-//!\n-//! That is, raw items don't have semantics, just as syntax, but, unlike syntax,\n-//! they don't change with trivial source code edits, making them a great tool\n-//! for building salsa recomputation firewalls.\n-\n-use std::{ops::Index, sync::Arc};\n-\n-use hir_expand::{\n-    ast_id_map::AstIdMap,\n-    hygiene::Hygiene,\n-    name::{AsName, Name},\n-};\n-use ra_arena::{Arena, Idx};\n-use ra_prof::profile;\n-use ra_syntax::{\n-    ast::{self, AttrsOwner, NameOwner, VisibilityOwner},\n-    AstNode,\n-};\n-use test_utils::mark;\n-\n-use crate::{\n-    attr::Attrs,\n-    db::DefDatabase,\n-    path::{ImportAlias, ModPath},\n-    visibility::RawVisibility,\n-    FileAstId, HirFileId, InFile,\n-};\n-\n-/// `RawItems` is a set of top-level items in a file (except for impls).\n-///\n-/// It is the input to name resolution algorithm. `RawItems` are not invalidated\n-/// on most edits.\n-#[derive(Debug, Default, PartialEq, Eq)]\n-pub struct RawItems {\n-    modules: Arena<ModuleData>,\n-    imports: Arena<ImportData>,\n-    defs: Arena<DefData>,\n-    macros: Arena<MacroData>,\n-    impls: Arena<ImplData>,\n-    /// items for top-level module\n-    items: Vec<RawItem>,\n-}\n-\n-impl RawItems {\n-    pub(crate) fn raw_items_query(db: &dyn DefDatabase, file_id: HirFileId) -> Arc<RawItems> {\n-        let _p = profile(\"raw_items_query\");\n-        let mut collector = RawItemsCollector {\n-            raw_items: RawItems::default(),\n-            source_ast_id_map: db.ast_id_map(file_id),\n-            file_id,\n-            hygiene: Hygiene::new(db.upcast(), file_id),\n-        };\n-        if let Some(node) = db.parse_or_expand(file_id) {\n-            if let Some(source_file) = ast::SourceFile::cast(node.clone()) {\n-                collector.process_module(None, source_file);\n-            } else if let Some(item_list) = ast::MacroItems::cast(node) {\n-                collector.process_module(None, item_list);\n-            }\n-        }\n-        let raw_items = collector.raw_items;\n-        Arc::new(raw_items)\n-    }\n-\n-    pub(super) fn items(&self) -> &[RawItem] {\n-        &self.items\n-    }\n-}\n-\n-impl Index<Idx<ModuleData>> for RawItems {\n-    type Output = ModuleData;\n-    fn index(&self, idx: Idx<ModuleData>) -> &ModuleData {\n-        &self.modules[idx]\n-    }\n-}\n-\n-impl Index<Import> for RawItems {\n-    type Output = ImportData;\n-    fn index(&self, idx: Import) -> &ImportData {\n-        &self.imports[idx]\n-    }\n-}\n-\n-impl Index<Idx<DefData>> for RawItems {\n-    type Output = DefData;\n-    fn index(&self, idx: Idx<DefData>) -> &DefData {\n-        &self.defs[idx]\n-    }\n-}\n-\n-impl Index<Idx<MacroData>> for RawItems {\n-    type Output = MacroData;\n-    fn index(&self, idx: Idx<MacroData>) -> &MacroData {\n-        &self.macros[idx]\n-    }\n-}\n-\n-impl Index<Idx<ImplData>> for RawItems {\n-    type Output = ImplData;\n-    fn index(&self, idx: Idx<ImplData>) -> &ImplData {\n-        &self.impls[idx]\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Clone)]\n-pub(super) struct RawItem {\n-    pub(super) attrs: Attrs,\n-    pub(super) kind: RawItemKind,\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum RawItemKind {\n-    Module(Idx<ModuleData>),\n-    Import(Import),\n-    Def(Idx<DefData>),\n-    Macro(Idx<MacroData>),\n-    Impl(Idx<ImplData>),\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(super) enum ModuleData {\n-    Declaration {\n-        name: Name,\n-        visibility: RawVisibility,\n-        ast_id: FileAstId<ast::Module>,\n-    },\n-    Definition {\n-        name: Name,\n-        visibility: RawVisibility,\n-        ast_id: FileAstId<ast::Module>,\n-        items: Vec<RawItem>,\n-    },\n-}\n-\n-pub(crate) type Import = Idx<ImportData>;\n-\n-#[derive(Debug, Clone, PartialEq, Eq)]\n-pub struct ImportData {\n-    pub(super) path: ModPath,\n-    pub(super) alias: Option<ImportAlias>,\n-    pub(super) is_glob: bool,\n-    pub(super) is_prelude: bool,\n-    pub(super) is_extern_crate: bool,\n-    pub(super) is_macro_use: bool,\n-    pub(super) visibility: RawVisibility,\n-}\n-\n-// type Def = Idx<DefData>;\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(super) struct DefData {\n-    pub(super) name: Name,\n-    pub(super) kind: DefKind,\n-    pub(super) visibility: RawVisibility,\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum StructDefKind {\n-    Record,\n-    Tuple,\n-    Unit,\n-}\n-\n-#[derive(Debug, PartialEq, Eq, Clone, Copy)]\n-pub(super) enum DefKind {\n-    Function(FileAstId<ast::FnDef>),\n-    Struct(FileAstId<ast::StructDef>, StructDefKind),\n-    Union(FileAstId<ast::UnionDef>),\n-    Enum(FileAstId<ast::EnumDef>),\n-    Const(FileAstId<ast::ConstDef>),\n-    Static(FileAstId<ast::StaticDef>),\n-    Trait(FileAstId<ast::TraitDef>),\n-    TypeAlias(FileAstId<ast::TypeAliasDef>),\n-}\n-\n-impl DefKind {\n-    pub fn ast_id(self) -> FileAstId<ast::ModuleItem> {\n-        match self {\n-            DefKind::Function(it) => it.upcast(),\n-            DefKind::Struct(it, _) => it.upcast(),\n-            DefKind::Union(it) => it.upcast(),\n-            DefKind::Enum(it) => it.upcast(),\n-            DefKind::Const(it) => it.upcast(),\n-            DefKind::Static(it) => it.upcast(),\n-            DefKind::Trait(it) => it.upcast(),\n-            DefKind::TypeAlias(it) => it.upcast(),\n-        }\n-    }\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(super) struct MacroData {\n-    pub(super) ast_id: FileAstId<ast::MacroCall>,\n-    pub(super) path: ModPath,\n-    pub(super) name: Option<Name>,\n-    pub(super) export: bool,\n-    pub(super) local_inner: bool,\n-    pub(super) builtin: bool,\n-}\n-\n-#[derive(Debug, PartialEq, Eq)]\n-pub(super) struct ImplData {\n-    pub(super) ast_id: FileAstId<ast::ImplDef>,\n-}\n-\n-struct RawItemsCollector {\n-    raw_items: RawItems,\n-    source_ast_id_map: Arc<AstIdMap>,\n-    file_id: HirFileId,\n-    hygiene: Hygiene,\n-}\n-\n-impl RawItemsCollector {\n-    fn process_module(\n-        &mut self,\n-        current_module: Option<Idx<ModuleData>>,\n-        body: impl ast::ModuleItemOwner,\n-    ) {\n-        for item in body.items() {\n-            self.add_item(current_module, item)\n-        }\n-    }\n-\n-    fn add_item(&mut self, current_module: Option<Idx<ModuleData>>, item: ast::ModuleItem) {\n-        let attrs = self.parse_attrs(&item);\n-        let visibility = RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene);\n-        let (kind, name) = match item {\n-            ast::ModuleItem::Module(module) => {\n-                self.add_module(current_module, module);\n-                return;\n-            }\n-            ast::ModuleItem::UseItem(use_item) => {\n-                self.add_use_item(current_module, use_item);\n-                return;\n-            }\n-            ast::ModuleItem::ExternCrateItem(extern_crate) => {\n-                self.add_extern_crate_item(current_module, extern_crate);\n-                return;\n-            }\n-            ast::ModuleItem::ImplDef(it) => {\n-                self.add_impl(current_module, it);\n-                return;\n-            }\n-            ast::ModuleItem::StructDef(it) => {\n-                let kind = match it.kind() {\n-                    ast::StructKind::Record(_) => StructDefKind::Record,\n-                    ast::StructKind::Tuple(_) => StructDefKind::Tuple,\n-                    ast::StructKind::Unit => StructDefKind::Unit,\n-                };\n-                let id = self.source_ast_id_map.ast_id(&it);\n-                let name = it.name();\n-                (DefKind::Struct(id, kind), name)\n-            }\n-            ast::ModuleItem::UnionDef(it) => {\n-                let id = self.source_ast_id_map.ast_id(&it);\n-                let name = it.name();\n-                (DefKind::Union(id), name)\n-            }\n-            ast::ModuleItem::EnumDef(it) => {\n-                (DefKind::Enum(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::FnDef(it) => {\n-                (DefKind::Function(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::TraitDef(it) => {\n-                (DefKind::Trait(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::TypeAliasDef(it) => {\n-                (DefKind::TypeAlias(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::ConstDef(it) => {\n-                (DefKind::Const(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::StaticDef(it) => {\n-                (DefKind::Static(self.source_ast_id_map.ast_id(&it)), it.name())\n-            }\n-            ast::ModuleItem::MacroCall(it) => {\n-                self.add_macro(current_module, it);\n-                return;\n-            }\n-            ast::ModuleItem::ExternBlock(it) => {\n-                self.add_extern_block(current_module, it);\n-                return;\n-            }\n-        };\n-        if let Some(name) = name {\n-            let name = name.as_name();\n-            let def = self.raw_items.defs.alloc(DefData { name, kind, visibility });\n-            self.push_item(current_module, attrs, RawItemKind::Def(def));\n-        }\n-    }\n-\n-    fn add_extern_block(\n-        &mut self,\n-        current_module: Option<Idx<ModuleData>>,\n-        block: ast::ExternBlock,\n-    ) {\n-        if let Some(items) = block.extern_item_list() {\n-            for item in items.extern_items() {\n-                let attrs = self.parse_attrs(&item);\n-                let visibility =\n-                    RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene);\n-                let (kind, name) = match item {\n-                    ast::ExternItem::FnDef(it) => {\n-                        (DefKind::Function(self.source_ast_id_map.ast_id(&it)), it.name())\n-                    }\n-                    ast::ExternItem::StaticDef(it) => {\n-                        (DefKind::Static(self.source_ast_id_map.ast_id(&it)), it.name())\n-                    }\n-                };\n-\n-                if let Some(name) = name {\n-                    let name = name.as_name();\n-                    let def = self.raw_items.defs.alloc(DefData { name, kind, visibility });\n-                    self.push_item(current_module, attrs, RawItemKind::Def(def));\n-                }\n-            }\n-        }\n-    }\n-\n-    fn add_module(&mut self, current_module: Option<Idx<ModuleData>>, module: ast::Module) {\n-        let name = match module.name() {\n-            Some(it) => it.as_name(),\n-            None => return,\n-        };\n-        let attrs = self.parse_attrs(&module);\n-        let visibility = RawVisibility::from_ast_with_hygiene(module.visibility(), &self.hygiene);\n-\n-        let ast_id = self.source_ast_id_map.ast_id(&module);\n-        if module.semicolon_token().is_some() {\n-            let item =\n-                self.raw_items.modules.alloc(ModuleData::Declaration { name, visibility, ast_id });\n-            self.push_item(current_module, attrs, RawItemKind::Module(item));\n-            return;\n-        }\n-\n-        if let Some(item_list) = module.item_list() {\n-            let item = self.raw_items.modules.alloc(ModuleData::Definition {\n-                name,\n-                visibility,\n-                ast_id,\n-                items: Vec::new(),\n-            });\n-            self.process_module(Some(item), item_list);\n-            self.push_item(current_module, attrs, RawItemKind::Module(item));\n-            return;\n-        }\n-        mark::hit!(name_res_works_for_broken_modules);\n-    }\n-\n-    fn add_use_item(&mut self, current_module: Option<Idx<ModuleData>>, use_item: ast::UseItem) {\n-        // FIXME: cfg_attr\n-        let is_prelude = use_item.has_atom_attr(\"prelude_import\");\n-        let attrs = self.parse_attrs(&use_item);\n-        let visibility = RawVisibility::from_ast_with_hygiene(use_item.visibility(), &self.hygiene);\n-\n-        let mut buf = Vec::new();\n-        ModPath::expand_use_item(\n-            InFile { value: use_item, file_id: self.file_id },\n-            &self.hygiene,\n-            |path, _use_tree, is_glob, alias| {\n-                let import_data = ImportData {\n-                    path,\n-                    alias,\n-                    is_glob,\n-                    is_prelude,\n-                    is_extern_crate: false,\n-                    is_macro_use: false,\n-                    visibility: visibility.clone(),\n-                };\n-                buf.push(import_data);\n-            },\n-        );\n-        for import_data in buf {\n-            self.push_import(current_module, attrs.clone(), import_data);\n-        }\n-    }\n-\n-    fn add_extern_crate_item(\n-        &mut self,\n-        current_module: Option<Idx<ModuleData>>,\n-        extern_crate: ast::ExternCrateItem,\n-    ) {\n-        if let Some(name_ref) = extern_crate.name_ref() {\n-            let path = ModPath::from_name_ref(&name_ref);\n-            let visibility =\n-                RawVisibility::from_ast_with_hygiene(extern_crate.visibility(), &self.hygiene);\n-            let alias = extern_crate.alias().map(|a| {\n-                a.name().map(|it| it.as_name()).map_or(ImportAlias::Underscore, ImportAlias::Alias)\n-            });\n-            let attrs = self.parse_attrs(&extern_crate);\n-            // FIXME: cfg_attr\n-            let is_macro_use = extern_crate.has_atom_attr(\"macro_use\");\n-            let import_data = ImportData {\n-                path,\n-                alias,\n-                is_glob: false,\n-                is_prelude: false,\n-                is_extern_crate: true,\n-                is_macro_use,\n-                visibility,\n-            };\n-            self.push_import(current_module, attrs, import_data);\n-        }\n-    }\n-\n-    fn add_macro(&mut self, current_module: Option<Idx<ModuleData>>, m: ast::MacroCall) {\n-        let attrs = self.parse_attrs(&m);\n-        let path = match m.path().and_then(|path| ModPath::from_src(path, &self.hygiene)) {\n-            Some(it) => it,\n-            _ => return,\n-        };\n-\n-        let name = m.name().map(|it| it.as_name());\n-        let ast_id = self.source_ast_id_map.ast_id(&m);\n-\n-        // FIXME: cfg_attr\n-        let export_attr = attrs.by_key(\"macro_export\");\n-\n-        let export = export_attr.exists();\n-        let local_inner = if export {\n-            export_attr.tt_values().map(|it| &it.token_trees).flatten().any(|it| match it {\n-                tt::TokenTree::Leaf(tt::Leaf::Ident(ident)) => {\n-                    ident.text.contains(\"local_inner_macros\")\n-                }\n-                _ => false,\n-            })\n-        } else {\n-            false\n-        };\n-\n-        let builtin = attrs.by_key(\"rustc_builtin_macro\").exists();\n-\n-        let m = self.raw_items.macros.alloc(MacroData {\n-            ast_id,\n-            path,\n-            name,\n-            export,\n-            local_inner,\n-            builtin,\n-        });\n-        self.push_item(current_module, attrs, RawItemKind::Macro(m));\n-    }\n-\n-    fn add_impl(&mut self, current_module: Option<Idx<ModuleData>>, imp: ast::ImplDef) {\n-        let attrs = self.parse_attrs(&imp);\n-        let ast_id = self.source_ast_id_map.ast_id(&imp);\n-        let imp = self.raw_items.impls.alloc(ImplData { ast_id });\n-        self.push_item(current_module, attrs, RawItemKind::Impl(imp))\n-    }\n-\n-    fn push_import(\n-        &mut self,\n-        current_module: Option<Idx<ModuleData>>,\n-        attrs: Attrs,\n-        data: ImportData,\n-    ) {\n-        let import = self.raw_items.imports.alloc(data);\n-        self.push_item(current_module, attrs, RawItemKind::Import(import))\n-    }\n-\n-    fn push_item(\n-        &mut self,\n-        current_module: Option<Idx<ModuleData>>,\n-        attrs: Attrs,\n-        kind: RawItemKind,\n-    ) {\n-        match current_module {\n-            Some(module) => match &mut self.raw_items.modules[module] {\n-                ModuleData::Definition { items, .. } => items,\n-                ModuleData::Declaration { .. } => unreachable!(),\n-            },\n-            None => &mut self.raw_items.items,\n-        }\n-        .push(RawItem { attrs, kind })\n-    }\n-\n-    fn parse_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n-        Attrs::new(item, &self.hygiene)\n-    }\n-}"}, {"sha": "0c288a1085f7fe7a459f6442736cca0ba6db30f0", "filename": "crates/ra_hir_def/src/nameres/tests/incremental.rs", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fincremental.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -57,44 +57,6 @@ fn typing_inside_a_function_should_not_invalidate_def_map() {\n     );\n }\n \n-#[test]\n-fn adding_inner_items_should_not_invalidate_def_map() {\n-    check_def_map_is_not_recomputed(\n-        r\"\n-        //- /lib.rs\n-        struct S { a: i32}\n-        enum E { A }\n-        trait T {\n-            fn a() {}\n-        }\n-        mod foo;<|>\n-        impl S {\n-            fn a() {}\n-        }\n-        use crate::foo::bar::Baz;\n-        //- /foo/mod.rs\n-        pub mod bar;\n-\n-        //- /foo/bar.rs\n-        pub struct Baz;\n-        \",\n-        r\"\n-        struct S { a: i32, b: () }\n-        enum E { A, B }\n-        trait T {\n-            fn a() {}\n-            fn b() {}\n-        }\n-        mod foo;<|>\n-        impl S {\n-            fn a() {}\n-            fn b() {}\n-        }\n-        use crate::foo::bar::Baz;\n-        \",\n-    );\n-}\n-\n #[test]\n fn typing_inside_a_macro_should_not_invalidate_def_map() {\n     let (mut db, pos) = TestDB::with_position("}, {"sha": "e9a5e4cba1b2b6b6f7800fa77c1874af3c04c962", "filename": "crates/ra_hir_def/src/nameres/tests/mod_resolution.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fnameres%2Ftests%2Fmod_resolution.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -20,8 +20,11 @@ fn name_res_works_for_broken_modules() {\n         \",\n     );\n     assert_snapshot!(map, @r###\"\n-        \u22eecrate\n-        \u22eeBaz: _\n+crate\n+Baz: _\n+foo: t\n+\n+crate::foo\n     \"###);\n }\n \n@@ -719,10 +722,7 @@ fn unresolved_module_diagnostics() {\n                         ),\n                     ),\n                 ),\n-                value: FileAstId {\n-                    raw: Idx::<SyntaxNodePtr>(1),\n-                    _ty: PhantomData,\n-                },\n+                value: FileAstId::<ra_syntax::ast::generated::nodes::Module>(1),\n             },\n             candidate: \"bar.rs\",\n         },"}, {"sha": "043b93fad555fd272ac0136455aa7215927ed955", "filename": "crates/ra_hir_def/src/src.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fsrc.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -2,30 +2,37 @@\n \n use hir_expand::InFile;\n use ra_arena::map::ArenaMap;\n-use ra_syntax::AstNode;\n \n-use crate::{db::DefDatabase, AssocItemLoc, ItemLoc};\n+use crate::{db::DefDatabase, item_tree::ItemTreeNode, AssocItemLoc, ItemLoc};\n \n pub trait HasSource {\n     type Value;\n     fn source(&self, db: &dyn DefDatabase) -> InFile<Self::Value>;\n }\n \n-impl<N: AstNode> HasSource for AssocItemLoc<N> {\n-    type Value = N;\n+impl<N: ItemTreeNode> HasSource for AssocItemLoc<N> {\n+    type Value = N::Source;\n \n-    fn source(&self, db: &dyn DefDatabase) -> InFile<N> {\n-        let node = self.ast_id.to_node(db.upcast());\n-        InFile::new(self.ast_id.file_id, node)\n+    fn source(&self, db: &dyn DefDatabase) -> InFile<N::Source> {\n+        let tree = db.item_tree(self.id.file_id);\n+        let ast_id_map = db.ast_id_map(self.id.file_id);\n+        let root = db.parse_or_expand(self.id.file_id).unwrap();\n+        let node = &tree[self.id.value];\n+\n+        InFile::new(self.id.file_id, ast_id_map.get(node.ast_id()).to_node(&root))\n     }\n }\n \n-impl<N: AstNode> HasSource for ItemLoc<N> {\n-    type Value = N;\n+impl<N: ItemTreeNode> HasSource for ItemLoc<N> {\n+    type Value = N::Source;\n+\n+    fn source(&self, db: &dyn DefDatabase) -> InFile<N::Source> {\n+        let tree = db.item_tree(self.id.file_id);\n+        let ast_id_map = db.ast_id_map(self.id.file_id);\n+        let root = db.parse_or_expand(self.id.file_id).unwrap();\n+        let node = &tree[self.id.value];\n \n-    fn source(&self, db: &dyn DefDatabase) -> InFile<N> {\n-        let node = self.ast_id.to_node(db.upcast());\n-        InFile::new(self.ast_id.file_id, node)\n+        InFile::new(self.id.file_id, ast_id_map.get(node.ast_id()).to_node(&root))\n     }\n }\n "}, {"sha": "8136cb50ccfefa35f7b05cba88ddb966668ac47f", "filename": "crates/ra_hir_def/src/visibility.rs", "status": "modified", "additions": 1, "deletions": 20, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fvisibility.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -6,7 +6,7 @@ use ra_syntax::ast;\n use crate::{\n     db::DefDatabase,\n     path::{ModPath, PathKind},\n-    AssocContainerId, ModuleId,\n+    ModuleId,\n };\n \n /// Visibility of an item, not yet resolved.\n@@ -25,25 +25,6 @@ impl RawVisibility {\n         RawVisibility::Module(path)\n     }\n \n-    pub(crate) fn default_for_container(container_id: AssocContainerId) -> Self {\n-        match container_id {\n-            AssocContainerId::TraitId(_) => RawVisibility::Public,\n-            _ => RawVisibility::private(),\n-        }\n-    }\n-\n-    pub(crate) fn from_ast_with_default(\n-        db: &dyn DefDatabase,\n-        default: RawVisibility,\n-        node: InFile<Option<ast::Visibility>>,\n-    ) -> RawVisibility {\n-        Self::from_ast_with_hygiene_and_default(\n-            node.value,\n-            default,\n-            &Hygiene::new(db.upcast(), node.file_id),\n-        )\n-    }\n-\n     pub(crate) fn from_ast(\n         db: &dyn DefDatabase,\n         node: InFile<Option<ast::Visibility>>,"}, {"sha": "f4d31526a62e4d2cb9f3667afb231a400935b2c5", "filename": "crates/ra_hir_expand/src/ast_id_map.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fast_id_map.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -6,6 +6,8 @@\n //! changes.\n \n use std::{\n+    any::type_name,\n+    fmt,\n     hash::{Hash, Hasher},\n     marker::PhantomData,\n };\n@@ -14,7 +16,6 @@ use ra_arena::{Arena, Idx};\n use ra_syntax::{ast, AstNode, AstPtr, SyntaxNode, SyntaxNodePtr};\n \n /// `AstId` points to an AST node in a specific file.\n-#[derive(Debug)]\n pub struct FileAstId<N: AstNode> {\n     raw: ErasedFileAstId,\n     _ty: PhantomData<fn() -> N>,\n@@ -39,11 +40,17 @@ impl<N: AstNode> Hash for FileAstId<N> {\n     }\n }\n \n+impl<N: AstNode> fmt::Debug for FileAstId<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"FileAstId::<{}>({})\", type_name::<N>(), self.raw.into_raw())\n+    }\n+}\n+\n impl<N: AstNode> FileAstId<N> {\n     // Can't make this a From implementation because of coherence\n     pub fn upcast<M: AstNode>(self) -> FileAstId<M>\n     where\n-        M: From<N>,\n+        N: Into<M>,\n     {\n         FileAstId { raw: self.raw, _ty: PhantomData }\n     }\n@@ -89,7 +96,7 @@ impl AstIdMap {\n         }\n     }\n \n-    pub(crate) fn get<N: AstNode>(&self, id: FileAstId<N>) -> AstPtr<N> {\n+    pub fn get<N: AstNode>(&self, id: FileAstId<N>) -> AstPtr<N> {\n         self.arena[id.raw].clone().cast::<N>().unwrap()\n     }\n "}, {"sha": "85ff26a3682cb3cae34246ebaea25ed733929783", "filename": "crates/ra_hir_ty/src/tests.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftests.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -67,8 +67,8 @@ fn type_at_pos_displayed(\n     panic!(\"Can't find expression\")\n }\n \n-fn type_at(content: &str) -> String {\n-    let (db, file_pos) = TestDB::with_position(content);\n+fn type_at(ra_fixture: &str) -> String {\n+    let (db, file_pos) = TestDB::with_position(ra_fixture);\n     type_at_pos(&db, file_pos)\n }\n \n@@ -164,13 +164,19 @@ fn infer_with_mismatches(content: &str, include_mismatches: bool) -> String {\n     visit_module(&db, &crate_def_map, module.local_id, &mut |it| defs.push(it));\n     defs.sort_by_key(|def| match def {\n         DefWithBodyId::FunctionId(it) => {\n-            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n+            let loc = it.lookup(&db);\n+            let tree = db.item_tree(loc.id.file_id);\n+            tree.source(&db, loc.id).syntax().text_range().start()\n         }\n         DefWithBodyId::ConstId(it) => {\n-            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n+            let loc = it.lookup(&db);\n+            let tree = db.item_tree(loc.id.file_id);\n+            tree.source(&db, loc.id).syntax().text_range().start()\n         }\n         DefWithBodyId::StaticId(it) => {\n-            it.lookup(&db).ast_id.to_node(&db).syntax().text_range().start()\n+            let loc = it.lookup(&db);\n+            let tree = db.item_tree(loc.id.file_id);\n+            tree.source(&db, loc.id).syntax().text_range().start()\n         }\n     });\n     for def in defs {"}, {"sha": "b507000f22473016f22c5f7bf9afdad2a2766b82", "filename": "crates/ra_ide_db/src/change.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9/crates%2Fra_ide_db%2Fsrc%2Fchange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fchange.rs?ref=e9bdb05e9676e85bdd8fa5008e3ada3812b36fd9", "patch": "@@ -199,7 +199,7 @@ impl RootDatabase {\n             hir::db::InternEagerExpansionQuery\n \n             // DefDatabase\n-            hir::db::RawItemsQuery\n+            hir::db::ItemTreeQuery\n             hir::db::CrateDefMapQueryQuery\n             hir::db::StructDataQuery\n             hir::db::UnionDataQuery"}]}